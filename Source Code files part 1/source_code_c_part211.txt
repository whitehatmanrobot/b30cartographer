/////
////////////////////////////////////// Dump irql tracking log
/////////////////////////////////////////////////////////////////////

VOID
DumpTrackIrqlLog (
    PCSTR args
    )
{
    ULONG64 TrackIrqlQueueAddress;
    ULONG64 TrackIrqlIndexAddress;
    ULONG64 TrackIrqlQueueLengthAddress;
    ULONG64 TrackIrqlQueue;
    ULONG TrackIrqlIndex;
    ULONG TrackIrqlQueueLength;
    ULONG I, Index;
    ULONG64 Address;
    ULONG TrackIrqlTypeSize;
    UCHAR SymbolName[256];
    ULONG64 SymbolAddress;
    ULONG64 SymbolOffset;
    ULONG Result;
    ULONG ShowCount;
    ULONG Flags;

    //
    // Read how many traces we want to see.
    //

    ShowCount = 0;

    if (args) {
        ULONG64 tmp;

        if (GetExpressionEx(args, &tmp, &args)) {
            Flags = (ULONG) tmp;
            if (!sscanf (args, "%u", &ShowCount)) {
                ShowCount = 0;
            }
        }

        if (ShowCount == 0) {
            ShowCount = 4;
        }
    }
    else {
        ShowCount = 4;
    }

    //
    // Read track irql package data
    //

    TrackIrqlQueueAddress = GetExpression ("nt!ViTrackIrqlQueue");
    TrackIrqlIndexAddress = GetExpression ("nt!ViTrackIrqlIndex");
    TrackIrqlQueueLengthAddress = GetExpression ("nt!ViTrackIrqlQueueLength");

    if (TrackIrqlQueueAddress == 0 || TrackIrqlIndexAddress == 0) {
        dprintf ("Incorrect symbols. \n");
        return;
    }

    if (!ReadPointer (TrackIrqlQueueAddress, &TrackIrqlQueue)) {
        dprintf("Unable to reas TrackIrqlQueue at %p\n", TrackIrqlQueueAddress);
        TrackIrqlQueue = 0;
    }

    if (TrackIrqlQueue == 0) {

        dprintf ("Irql tracking is not enabled. You need to enable driver verifier \n");
        dprintf ("for at least one driver to activate irql tracking.               \n");
        return;
    }

    ReadMemory (TrackIrqlIndexAddress, &TrackIrqlIndex, sizeof(ULONG), &Result);

    if (Result != sizeof(ULONG)) {
        dprintf ("Trackirql: read error \n");
        return;
    }

    ReadMemory (TrackIrqlQueueLengthAddress, &TrackIrqlQueueLength, sizeof(ULONG), &Result);

    if (Result != sizeof(ULONG)) {
        dprintf ("Trackirql: read error \n");
        return;
    }

    TrackIrqlTypeSize = GetTypeSize("nt!_VI_TRACK_IRQL");

    //
    // Dump information
    //

    dprintf ("\nSize of track irql queue is 0x%X \n", TrackIrqlQueueLength);

    for (I = 0, Index = TrackIrqlIndex; I < TrackIrqlQueueLength; I += 1) {

        if (I >= ShowCount) {
            break;
        }

        Index -= 1;
        Index &= (TrackIrqlQueueLength - 1);

        Address = TrackIrqlQueue + Index * TrackIrqlTypeSize;
        InitTypeRead (Address, nt!_VI_TRACK_IRQL);

        dprintf ("\n");
        dprintf ("Thread:             %I64X\n", ReadField (Thread));
        dprintf ("Old irql:           %I64X\n", ReadField (OldIrql));
        dprintf ("New irql:           %I64X\n", ReadField (NewIrql));
        dprintf ("Processor:          %I64X\n", ReadField (Processor));
        dprintf ("Time stamp:         %I64X\n", ReadField (TickCount));
        dprintf ("\n");

        SymbolAddress = ReadField(StackTrace[0]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        SymbolAddress = ReadField(StackTrace[1]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        SymbolAddress = ReadField(StackTrace[2]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        SymbolAddress = ReadField(StackTrace[3]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        SymbolAddress = ReadField(StackTrace[4]);
        if (SymbolAddress == 0) { continue; }
        GetSymbol(SymbolAddress, SymbolName, &SymbolOffset);
        dprintf ("    %I64X %s+0x%I64x\n", SymbolAddress, SymbolName, SymbolOffset);

        if (CheckControlC()) {
            dprintf ("Interrupted \n");
            break;
        }

    }
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////// Dump fault injection trace log
/////////////////////////////////////////////////////////////////////

ULONG64
ReadPvoid (
    ULONG64 Address
    )
{
    ULONG64 RemoteValue = 0;
    ReadPointer( Address, &RemoteValue);
    return RemoteValue;
}

ULONG
ReadUlong(
    ULONG64 Address
    )
{
    ULONG RemoteValue = 0;
    ReadMemory( Address, &RemoteValue, sizeof( ULONG ), NULL );
    return RemoteValue;
}

VOID
DumpFaultInjectionTrace (
    ULONG64 Address
    )
{
    ULONG64 ReturnAddress;
    CHAR  SymbolName[ 1024 ];
    ULONG64 Displacement;
    ULONG I;
    ULONG PvoidSize;

    PvoidSize = IsPtr64() ? 8 : 4;


    for (I = 0; I < 8; I += 1) {

        ReturnAddress = ReadPvoid (Address + I * PvoidSize);

        if (ReturnAddress == 0) {
            break;
        }

        GetSymbol (ReturnAddress, SymbolName, &Displacement);

        dprintf ("    %p %s+0x%p\n",
                 ReturnAddress,
                 SymbolName,
                 Displacement);
    }
}

VOID
DumpFaultInjectionTraceLog (
    PCSTR Args
    )
{
    ULONG TracesToDisplay = 0;
    ULONG64 TraceAddress;
    ULONG64 Trace;
    ULONG64 IndexAddress;
    ULONG Index;
    ULONG64 LengthAddress;
    ULONG Length;
    ULONG I;
    ULONG PvoidSize;
    ULONG64 TraceBlockAddress;
    ULONG64 FirstReturnAddress;
    ULONG TracesFound = 0;
    BOOLEAN Interrupted = FALSE;
    ULONG Flags;

    if (Args) {

        ULONG64 tmp;

        if (GetExpressionEx(Args, &tmp, &Args)) {
            Flags = (ULONG) tmp;
            if (!sscanf (Args, "%u", &TracesToDisplay)) {
                TracesToDisplay = 0;
            }
        }


        if (TracesToDisplay == 0) {
            TracesToDisplay = 4;
        }
    }
    else {
        TracesToDisplay = 4;
    }

    PvoidSize = IsPtr64() ? 8 : 4;

    TraceAddress = (ULONG64) GetExpression ("nt!ViFaultTraces");
    IndexAddress = (ULONG64) GetExpression ("nt!ViFaultTracesIndex");
    LengthAddress = (ULONG64) GetExpression ("nt!ViFaultTracesLength");

    Trace = ReadPvoid (TraceAddress);

    if (Trace == 0) {
        dprintf ("Driver fault injection is not enabled for this system. \n");
        return;
    }

    Index = ReadUlong (IndexAddress);
    Length = ReadUlong (LengthAddress);

    for (I = 0; I < Length; I += 1) {

        Index -= 1;
        Index &= (Length - 1);

        TraceBlockAddress = Trace + Index * PvoidSize * 8;
        FirstReturnAddress = ReadPvoid (TraceBlockAddress);

        if (FirstReturnAddress != 0) {
            TracesFound += 1;

            dprintf ("\n");
            DumpFaultInjectionTrace (TraceBlockAddress);

            if (TracesFound >= TracesToDisplay) {
                break;
            }
        }

        if (CheckControlC()) {
            Interrupted = TRUE;
            dprintf ("Interrupted \n");
            break;
        }
    }

    if (Interrupted == FALSE && TracesFound == 0) {

        dprintf ("No fault injection traces found. \n");
    }
}

PUCHAR MemoryDescriptorType[] = {
    "ExceptionBlock",
    "SystemBlock",
    "Free",
    "Bad",
    "LoadedProgram",
    "FirmwareTemporary",
    "FirmwarePermanent",
    "OsloaderHeap",
    "OsloaderStack",
    "SystemCode",
    "HalCode",
    "BootDriver",
    "ConsoleInDriver",
    "ConsoleOutDriver",
    "StartupDpcStack",
    "StartupKernelStack",
    "StartupPanicStack",
    "StartupPcrPage",
    "StartupPdrPage",
    "RegistryData",
    "MemoryData",
    "NlsData",
    "SpecialMemory",
    "BBTMemory",
    "LoaderReserve",
    "XIPRom",
    "HALCachedMemory"
    };

#define MAXIMUM_MEMORY_TYPE (sizeof(MemoryDescriptorType)/sizeof(UCHAR))

DECLARE_API( loadermemorylist )

/*++

Routine Description:

    Displays the memory allocation list.   This is the list
    handed to the OS by the OSLOADER that describes physical
    memory.
    Displays the corresponding PDE and PTE.

Arguments:

    list - points to the listheader

Return Value:

    None.

--*/

{
    ULONG64 ListHeaderAddress;
    ULONG64 EntryAddress;
    ULONG64 LengthInPages;
    ULONG64 TypeOfMemory;
    ULONG   Count[MAXIMUM_MEMORY_TYPE];
    ULONG   i;

    UNREFERENCED_PARAMETER (Client);

    ListHeaderAddress = 0;

    ListHeaderAddress = GetExpression(args);
    if (ListHeaderAddress == 0) {
        dprintf("Usage: !loadermemorylist <address_of_listhead>\n");
        return E_INVALIDARG;
    }

    if (!ReadPointer(ListHeaderAddress, &EntryAddress)) {
        dprintf("Unable to read list header at %p\n", ListHeaderAddress);
        return E_INVALIDARG;
    }

    if (EntryAddress == ListHeaderAddress) {
        dprintf("List at %p is empty\n", ListHeaderAddress);
        return S_OK;
    }

    dprintf("Base        Length      Type\n");

    RtlZeroMemory(Count, sizeof(Count));

    do {
        if (CheckControlC()) {
            dprintf ("Interrupted \n");
            break;
        }

        InitTypeRead(EntryAddress, nt!MEMORY_ALLOCATION_DESCRIPTOR);
        TypeOfMemory = ReadField(MemoryType);
        if (TypeOfMemory < MAXIMUM_MEMORY_TYPE) {
            LengthInPages = ReadField(PageCount);
            dprintf("%08x    %08x    %s\n",
                    (ULONG)ReadField(BasePage),
                    (ULONG)LengthInPages,
                    MemoryDescriptorType[TypeOfMemory]);
            Count[TypeOfMemory] += (ULONG)LengthInPages;
        } else {
            dprintf("Unrecognized Descriptor at %p\n", EntryAddress);
        }
        EntryAddress = ReadField(ListEntry.Flink);
    } while (EntryAddress != ListHeaderAddress);

    dprintf("\nSummary\nMemory Type         Pages\n");
    LengthInPages = 0;
    for (i = 0; i < MAXIMUM_MEMORY_TYPE; i++) {
        if (Count[i]) {
            dprintf("%-20s%08x   (%8d)\n",
                    MemoryDescriptorType[i],
                    Count[i],
                    Count[i]);
            LengthInPages += Count[i];
        }
    }
    dprintf("                    ========    ========\n");
    dprintf("Total               %08x   (%8d) = ~%dMB\n",
            (ULONG)LengthInPages,
            (ULONG)LengthInPages,
            (ULONG)LengthInPages / (1024 * 1024 / 4096));
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////
BOOL
VerifyExpectedPfnNumberSize (
    VOID
    )
{
    ULONG PfnNumberTypeSize;
    ULONG ExpectedPfnNumberTypeSize;
    BOOL Success;

    Success = TRUE;

    PfnNumberTypeSize = GetTypeSize ("nt!PFN_NUMBER");

    if (PfnNumberTypeSize == 0) {

        dprintf ("ERROR: Cannot get the size of nt!PFN_NUMBER.\n"
                 "Please check your symbols.\n" );

        Success = FALSE;

        goto Done;
    }

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

        ExpectedPfnNumberTypeSize = sizeof(ULONG);
    }
    else {

        //
        // Assume 64 bit target machine.
        //

        ExpectedPfnNumberTypeSize = sizeof(ULONG64);
    }

    if (PfnNumberTypeSize != ExpectedPfnNumberTypeSize) {

        dprintf ("ERROR: sizeof (nt!PFN_NUMBER) = %u, expected %u.\n",
                  PfnNumberTypeSize,
                  ExpectedPfnNumberTypeSize);

        Success = FALSE;
    }

Done:

    return Success;
}


///////////////////////////////////////////////////////////////////////
BOOL
DumpMnwPfnInfo (
    IN ULONG64 PfnNumber,
    IN ULONG64 PfnAddr,
    IN ULONG CaFieldOffset,
    IN ULONG FilePointerFieldOffset,
    IN ULONG FileNameFieldOffset,
    IN ULONG UnicodeStrLengthFieldOffset,
    IN ULONG UnicodeStrBufferFieldOffset,
    IN ULONG64 OriginalPteAddr,
    IN ULONG Flags,
    OUT ULONG64 *FileAddr,
    OUT ULONG64 *CaAddr
    )
{
    ULONG64 SubsectionAddr;
    ULONG64 BufferAddr;
    ULONG ErrorCode;
    BOOL Continue;
    BOOL Success;
    USHORT Length;
    UNICODE_STRING UnicodeString;

    Continue = TRUE;

    *FileAddr = 0;
    *CaAddr = 0;

    ZeroMemory (&UnicodeString,
                sizeof (UnicodeString));

    //
    // Get the address of the subsection.
    //

    SubsectionAddr = DbgGetSubsectionAddress (OriginalPteAddr);

    //
    // Get the address of the control area.
    //

    ErrorCode = ReadPointer (SubsectionAddr + CaFieldOffset,
                             CaAddr);

    if (ErrorCode != TRUE) {

        dprintf ("ERROR: Cannot read ControlArea address from 0x%p\n",
                 SubsectionAddr + CaFieldOffset);
        Continue = FALSE;
        goto Done;
    }

    //
    // Get the address of the file object.
    //

    ErrorCode = ReadPointer (*CaAddr + FilePointerFieldOffset,
                             FileAddr);

    if (ErrorCode != TRUE) {

        dprintf ("ERROR: Cannot read file object address from 0x%p\n",
                 *CaAddr + FilePointerFieldOffset);
        Continue = FALSE;
        goto Done;
    }

    //
    // Get the file name, if it's not paged out.
    //

    Success = ReadMemory (*FileAddr + FileNameFieldOffset + UnicodeStrLengthFieldOffset,
                          &Length,
                          sizeof (Length),
                          NULL);

    if (Success != FALSE && Length > 0 && Length < 1024) {

        UnicodeString.Buffer = malloc (Length);

        if (UnicodeString.Buffer != NULL) {

            ErrorCode = ReadPointer (*FileAddr + FileNameFieldOffset + UnicodeStrBufferFieldOffset,
                                     &BufferAddr);

            if (ErrorCode == TRUE) {

                Success = ReadMemory (BufferAddr,
                                      UnicodeString.Buffer,
                                      Length,
                                      NULL);

                if (Success != FALSE) {

                    UnicodeString.Length = Length;
                    UnicodeString.MaximumLength = UnicodeString.Length;
                }
            }
        }
    }

    //
    // Print out everything we know about this physical page of memory.
    //

    if (Flags & 2) {

        dprintf ("%16p %16p %16p %16p %16p %wZ\n",
                 PfnNumber,
                 PfnAddr,
                 SubsectionAddr,
                 *CaAddr,
                 *FileAddr,
                 &UnicodeString);
    }

Done:

    if (UnicodeString.Buffer != NULL) {

        free (UnicodeString.Buffer);
        UnicodeString.Buffer = NULL;
    }

    return Continue;
}

///////////////////////////////////////////////////////////////////////
BOOL
DumpMnwPfnInfoFromPfnNoAddr (
    IN ULONG64 FirstPfnAddr,
    IN ULONG MmPfnTypeSize,
    IN ULONG OriginalPteFieldOffset,
    IN ULONG U1FlinkFieldOffset,
    IN ULONG CaFieldOffset,
    IN ULONG FilePointerFieldOffset,
    IN ULONG FileNameFieldOffset,
    IN ULONG UnicodeStrLengthFieldOffset,
    IN ULONG UnicodeStrBufferFieldOffset,
    IN ULONG Flags,
    IN OUT PULONG64 CurrentPfnNumberAddr,
    OUT ULONG64 *FileAddr,
    OUT ULONG64 *CaAddr
    )
{
    ULONG64 PfnNumber64;
    ULONG64 CrtPfnAddr;
    ULONG PfnNumber32;
    BOOL ContinueWithNextPfn;

#define MM_EMPTY_LIST_32BIT ((ULONG)-1)
#define MM_EMPTY_LIST_64BIT ((ULONG64)-1)

    ContinueWithNextPfn = TRUE;

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

        //
        // Read the current PFN number.
        //

        ContinueWithNextPfn = ReadMemory (*CurrentPfnNumberAddr,
                                          &PfnNumber32,
                                          sizeof (PfnNumber32),
                                          NULL);

        if (ContinueWithNextPfn == FALSE) {

            dprintf ("ERROR: Cannot read PFN_NUMBER at 0x%p\n",
                     *CurrentPfnNumberAddr);

            goto Done;
        }

        //
        // Check if this is the end of list marker.
        //

        if (PfnNumber32 == MM_EMPTY_LIST_32BIT) {

            dprintf ("ERROR: End of the PFN numbers list found before parsing all list elements!!!\n");

            ContinueWithNextPfn = FALSE;

            goto Done;
        }

        //
        // Cast our PFN number to 64 bit and continue with that.
        //

        PfnNumber64 = (ULONG64)PfnNumber32;
    }
    else {

        //
        // Read the current PFN number.
        //

        ContinueWithNextPfn = ReadMemory (*CurrentPfnNumberAddr,
                                          &PfnNumber64,
                                          sizeof (PfnNumber64),
                                          NULL);

        if (ContinueWithNextPfn == FALSE) {

            dprintf ("ERROR: Cannot read PFN_NUMBER at 0x%p\n",
                     *CurrentPfnNumberAddr);

            goto Done;
        }

        //
        // Check if this is the end of list marker.
        //

        if (PfnNumber64 == MM_EMPTY_LIST_64BIT) {

            dprintf ("ERROR: End of the PFN numbers list found before parsing all list elements!!!\n");

            ContinueWithNextPfn = FALSE;

            goto Done;
        }
    }

    CrtPfnAddr = FirstPfnAddr + PfnNumber64 * MmPfnTypeSize;

    ContinueWithNextPfn = DumpMnwPfnInfo (PfnNumber64,
                                          CrtPfnAddr,
                                          CaFieldOffset,
                                          FilePointerFieldOffset,
                                          FileNameFieldOffset,
                                          UnicodeStrLengthFieldOffset,
                                          UnicodeStrBufferFieldOffset,
                                          CrtPfnAddr + OriginalPteFieldOffset,
                                          Flags,
                                          FileAddr,
                                          CaAddr);

    //
    // Continue with the next PFN_NUMBER in the list.
    //

    *CurrentPfnNumberAddr = CrtPfnAddr + U1FlinkFieldOffset;

Done:

    return ContinueWithNextPfn;
}

///////////////////////////////////////////////////////////////////////
typedef struct _DBG_MNW_INFO {
    ULONG64 FileObject;
    ULONG64 ControlArea;
    ULONG Count;
} DBG_MNW_INFO, *PDBG_MNW_INFO;


VOID
AddMwnPage (
   IN ULONG64 FileAddr,
   IN ULONG64 CaAddr,
   IN OUT PDBG_MNW_INFO MnwInfo,
   IN OUT PULONG EntryCount
   )
{
    ULONG Index;

    //
    // See if we already have this file object in the aray.
    //

    for (Index = 0; Index < *EntryCount; Index += 1) {

        if (MnwInfo[Index].FileObject == FileAddr) {

            //
            // Found this file object. Increment its page count.
            //

            ASSERT (MnwInfo[Index].Count > 0);
            MnwInfo[Index].Count += 1;

            goto Done;
        }
    }

    //
    // Add a new entry for this file object.
    //

    MnwInfo[*EntryCount].ControlArea = CaAddr;
    MnwInfo[*EntryCount].FileObject = FileAddr;
    MnwInfo[*EntryCount].Count = 1;

    *EntryCount += 1;

Done:

    NOTHING;
}

int __cdecl
MwnInfoCompare(
    const void *elem1,
    const void *elem2
    )
{
    PDBG_MNW_INFO Info1;
    PDBG_MNW_INFO Info2;

    Info1 = (PDBG_MNW_INFO)elem1;
    Info2 = (PDBG_MNW_INFO)elem2;

    if (Info1->Count < Info2->Count) {

        return -1;
    }
    else if (Info1->Count > Info2->Count) {

        return 1;
    }
    else {

        return 0;
    }
}

VOID
DbgDumpMwnSummarry (
   IN ULONG FileNameFieldOffset,
   IN ULONG UnicodeStrLengthFieldOffset,
   IN ULONG UnicodeStrBufferFieldOffset,
   IN PDBG_MNW_INFO MnwInfo,
   IN ULONG EntryCount
   )
{
    ULONG Index;
    ULONG ErrorCode;
    USHORT Length;
    ULONG64 BufferAddr;
    BOOL Success;
    UNICODE_STRING UnicodeString;
    const char Separator[] = "===================================================\n";

    if (EntryCount > 0) {

        //
        // Sort by the number of pages per file object.
        //

        qsort (MnwInfo,
               EntryCount,
               sizeof (*MnwInfo),
               MwnInfoCompare);

        //
        // Print out the summarry.
        //

        dprintf ("\n");
        dprintf (Separator);

        dprintf ("%8s %16s %16s FileName\n",
                 "PagesNo",
                 "ControlArea",
                 "FileObject");

        dprintf (Separator);

        for (Index = 0; Index < EntryCount; Index += 1) {

            //
            // Get the file name, if it's not paged out.
            //

            ZeroMemory (&UnicodeString,
                        sizeof (UnicodeString));

            Success = ReadMemory (MnwInfo[Index].FileObject + FileNameFieldOffset + UnicodeStrLengthFieldOffset,
                                  &Length,
                                  sizeof (Length),
                                  NULL);

            if (Success != FALSE && Length > 0 && Length < 1024) {

                UnicodeString.Buffer = malloc (Length);

                if (UnicodeString.Buffer != NULL) {

                    ErrorCode = ReadPtr (MnwInfo[Index].FileObject + FileNameFieldOffset + UnicodeStrBufferFieldOffset,
                                         &BufferAddr);

                    if (ErrorCode == S_OK) {

                        Success = ReadMemory (BufferAddr,
                                              UnicodeString.Buffer,
                                              Length,
                                              NULL);

                        if (Success != FALSE) {

                            UnicodeString.Length = Length;
                            UnicodeString.MaximumLength = UnicodeString.Length;
                        }
                    }
                }
            }

            dprintf ("%8x %16p %16p %wZ\n",
                     MnwInfo[Index].Count,
                     MnwInfo[Index].ControlArea,
                     MnwInfo[Index].FileObject,
                     &UnicodeString);

            if (UnicodeString.Buffer != NULL) {

                free (UnicodeString.Buffer);
                UnicodeString.Buffer = NULL;
            }
        }

        dprintf (Separator);
    }
}

ULONG
DumpModifiedNoWriteInformation (
    ULONG Flags
    )
{
    ULONG64 MmModifiedNoWritePageListHeadAddr;
    ULONG64 TotalAddr;
    ULONG64 CurrentPfnNumberAddr;
    ULONG64 MmPfnDatabaseAddr;
    ULONG64 FirstPfnAddr;
    ULONG64 FileAddr;
    ULONG64 CaAddr;
    ULONG64 TotalPages64 = 0;
    ULONG64 CrtPageIndex = 0;
    ULONG FlinkFieldOffset;
    ULONG TotalFieldOffset;
    ULONG OriginalPteFieldOffset;
    ULONG U1FlinkFieldOffset;
    ULONG CaFieldOffset;
    ULONG FilePointerFieldOffset;
    ULONG FileNameFieldOffset;
    ULONG UnicodeStrLengthFieldOffset;
    ULONG UnicodeStrBufferFieldOffset;
    ULONG TotalPages32;
    ULONG ErrorCode;
    ULONG MmPfnTypeSize;
    ULONG MnwInfoEntryCount;
    BOOL Continue;
    const char Separator[] = "================================================================================================\n";
    PDBG_MNW_INFO MnwInfo = NULL;

    //
    // Verify the size of PFN_NUMBER. We expect this to be 32 bit
    // on x86 and 64 bit on the other platforms.
    //

    if (VerifyExpectedPfnNumberSize () == FALSE) {

        goto Done;
    }

    dprintf ("\nLooking for pages in the ModifiedNoWrite list...\n");

    //
    // Get the address of MmModifiedNoWritePageListHead.
    //

    MmModifiedNoWritePageListHeadAddr = GetExpression ("&nt!MmModifiedNoWritePageListHead");

    if (MmModifiedNoWritePageListHeadAddr == 0 ) {

        dprintf ("ERROR: Unable to resolve nt!MmModifiedNoWritePageListHead\n");
        goto Done;
    }

    dprintf ("MmModifiedNoWritePageListHead at 0x%p\n",
              MmModifiedNoWritePageListHeadAddr);

    //
    // Find out the offset of Total inside the MMPFNLIST structure.
    //

    ErrorCode = GetFieldOffset ("nt!_MMPFNLIST",
                                "Total",
                                &TotalFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot get Total field offset inside nt!_MMPFNLIST.\n");
        goto Done;
    }

    TotalAddr = MmModifiedNoWritePageListHeadAddr + TotalFieldOffset;

    //
    // Display the total number of PFNs in the list.
    //

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

        TotalPages32 = 0;

        Continue = ReadMemory (TotalAddr,
                              &TotalPages32,
                              sizeof (TotalPages32),
                              NULL);

        TotalPages64 = (ULONG64) TotalPages32;
    }
    else {

        Continue = ReadMemory (TotalAddr,
                              &TotalPages64,
                              sizeof (TotalPages64),
                              NULL);
    }

    if (Continue == FALSE) {

        dprintf ("ERROR: Cannot read number of list entries at 0x%p\n",
                 TotalAddr);

        goto Done;
    }

    dprintf ("Number of pages: 0x%I64x\n",
             TotalPages64);

    if (Flags & 1) {

        MnwInfo = malloc ( (SIZE_T)TotalPages64 * sizeof (*MnwInfo));

        if (MnwInfo == NULL) {

            dprintf ("ERRROR: Cannot allocate memory for the summary info - dumping detailed info only\n");
            Flags = (Flags & ~1) | 2;
        }
    }

    //
    // Get the field offset of ControlArea inside nt!_SUBSECTION
    //

    ErrorCode = GetFieldOffset ("nt!_SUBSECTION",
                                "ControlArea",
                                &CaFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot get ControlArea field offset inside nt!_SUBSECTION.\n");
        goto Done;
    }

    //
    // Get the field offset of FilePointer inside nt!_CONTROL_AREA.
    //

    ErrorCode = GetFieldOffset ("nt!_CONTROL_AREA",
                                "FilePointer",
                                &FilePointerFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot get FilePointer field offset inside nt!_CONTROL_AREA.\n");
        goto Done;
    }

    //
    // Get the field offset of FileName inside nt!_FILE_OBJECT.
    //

    ErrorCode = GetFieldOffset ("nt!_FILE_OBJECT",
                                "FileName",
                                &FileNameFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot get FileName field offset inside nt!_FILE_OBJECT.\n");
        goto Done;
    }

    //
    // Get the field offset of Length inside nt!_UNICODE_STRING.
    //

    ErrorCode = GetFieldOffset ("nt!_UNICODE_STRING",
                                "Length",
                                &UnicodeStrLengthFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot get Length field offset inside nt!_UNICODE_STRING.\n");
        goto Done;
    }

    //
    // Get the field offset of Length inside nt!_UNICODE_STRING.
    //

    ErrorCode = GetFieldOffset ("nt!_UNICODE_STRING",
                                "Buffer",
                                &UnicodeStrBufferFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot get Buffer field offset inside nt!_UNICODE_STRING.\n");
        goto Done;
    }

    //
    // Get the PFN database array address.
    //

    MmPfnDatabaseAddr = GetExpression ("&nt!MmPfnDatabase");

    if (MmPfnDatabaseAddr == 0 ) {

        dprintf( "ERROR: Unable to resolve nt!MmPfnDatabase\n");
        goto Done;
    }

    //
    // Get the address of the first PFN in the database.
    //

    ErrorCode = ReadPtr (MmPfnDatabaseAddr,
                         &FirstPfnAddr);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot read PFN address from 0x%p\n",
                 MmPfnDatabaseAddr);

        goto Done;
    }

    //
    // Get the size of the _MMPFN stucture.
    //

    MmPfnTypeSize = GetTypeSize ("nt!_MMPFN");

    if (MmPfnTypeSize == 0) {

        dprintf ("ERROR: Cannot get the size of nt!_MMPFN.\n");

        goto Done;
    }

    //
    // Get the offset of the OriginalPte field inside nt!_MMPFN.
    //

    ErrorCode = GetFieldOffset ("nt!_MMPFN",
                                "OriginalPte",
                                &OriginalPteFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot get OriginalPte field offset inside nt!_MMPFN.\n");
        goto Done;
    }

    //
    // Get the offset of the OriginalPte field inside nt!_MMPFN.
    //

    ErrorCode = GetFieldOffset ("nt!_MMPFN",
                                "u1.Flink",
                                &U1FlinkFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot get u1.Flink field offset inside nt!_MMPFN.\n");
        goto Done;
    }

    //
    // Get the offset of Flink inside the MMPFNLIST structure.
    //

    ErrorCode = GetFieldOffset ("nt!_MMPFNLIST",
                                "Flink",
                                &FlinkFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("ERROR: Cannot get Flink field offset inside nt!_MMPFNLIST.\n");
        goto Done;
    }

    //
    // Parse all the PFN list, starting with the head.
    //

    if (TotalPages64 > 0) {

        if (Flags & 2) {

            dprintf ("\n");
            dprintf (Separator);
            dprintf ("%16s %16s %16s %16s %16s File Name\n",
                     "PFN number",
                     "PFN address",
                     "Subsection",
                     "ControlArea",
                     "FileObject");

            dprintf (Separator);
        }

        CurrentPfnNumberAddr = MmModifiedNoWritePageListHeadAddr + FlinkFieldOffset;

        MnwInfoEntryCount = 0;

        for (CrtPageIndex = 0; CrtPageIndex < TotalPages64; CrtPageIndex += 1) {

            if (CheckControlC()) {

                goto DisplayStatistics;
            }

            //
            // Read the current PFN.
            //

            Continue = DumpMnwPfnInfoFromPfnNoAddr (FirstPfnAddr,
                                                    MmPfnTypeSize,
                                                    OriginalPteFieldOffset,
                                                    U1FlinkFieldOffset,
                                                    CaFieldOffset,
                                                    FilePointerFieldOffset,
                                                    FileNameFieldOffset,
                                                    UnicodeStrLengthFieldOffset,
                                                    UnicodeStrBufferFieldOffset,
                                                    Flags,
                                                    &CurrentPfnNumberAddr,
                                                    &FileAddr,
                                                    &CaAddr);

            if (Continue == FALSE) {

                goto DisplayStatistics;
            }

            if (Flags & 1) {

                AddMwnPage (FileAddr,
                            CaAddr,
                            MnwInfo,
                            &MnwInfoEntryCount);
            }
        }

DisplayStatistics:

        if ((Flags & 2) && CrtPageIndex > 0) {

            dprintf (Separator);
        }

        if (Flags & 1) {

            DbgDumpMwnSummarry (FileNameFieldOffset,
                               UnicodeStrLengthFieldOffset,
                               UnicodeStrBufferFieldOffset,
                               MnwInfo,
                               MnwInfoEntryCount);
        }

        dprintf ("\n\nPages displayed: 0x%I64x. Total pages 0x%I64x.\n",
                 CrtPageIndex,
                 TotalPages64);
    }

Done:

    if (MnwInfo != NULL) {

        free (MnwInfo);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\locks.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    locks.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

BOOLEAN
FindQWord(
    IN ULONG64 Value,
    IN ULONG64 Array[],
    IN ULONG EntriesToSearch
    )
{
    // clear low few bits which are sometimes used as flag bits :(

    Value &= ~(ULONG64)3;

    while (EntriesToSearch) {

        if (Array[--EntriesToSearch] == Value) {

            return TRUE;
        }
    }

    return FALSE;
}


BOOLEAN
GetWaitListFromDispatcherHeader(
    IN ULONG64 ShWaitListArray[],
    IN ULONG ArrayByteSize,
    IN ULONG64 DispatcherHeaderAddress,
    OUT PULONG EntriesFilledIn
    )
{
    ULONG KThreadWaitListOffset;
    ULONG64 TerminationAddress = 0;
    ULONG64 CurrListEntry;
    ULONG MaxEntries = ArrayByteSize / sizeof( ULONG64);
    ULONG64 NextListEntry;
    ULONG64 ThreadAddr;
    ULONG64 Mask = IsPtr64() ? ~(ULONG64)0 : 0xffffffff;

    *EntriesFilledIn = 0;

    GetFieldOffset("nt!_KTHREAD", "WaitBlock", &KThreadWaitListOffset);
    GetFieldOffset("nt!_DISPATCHER_HEADER", "WaitListHead", &(ULONG)TerminationAddress);

    TerminationAddress += DispatcherHeaderAddress;
    CurrListEntry = TerminationAddress;

    // note: does not process initial (pased in) list entry as an object.

    do {

        GetFieldValue( CurrListEntry, "nt!_LIST_ENTRY", "Flink", NextListEntry);
        CurrListEntry = NextListEntry;

        if (CurrListEntry != TerminationAddress) {

            ThreadAddr = CurrListEntry - KThreadWaitListOffset;
            ShWaitListArray[ *EntriesFilledIn] = ThreadAddr & Mask;
            *EntriesFilledIn += 1;
        }

        // better check CTRL+C here in case we're walking trash memory

        if ((0 == (*EntriesFilledIn % 10)) && CheckControlC() ) {
            *EntriesFilledIn = -1;
            return FALSE;
        }

    } while ((CurrListEntry != TerminationAddress) &&
             (*EntriesFilledIn < MaxEntries));

    // edge case here (entries == maxentries) but..

    if (*EntriesFilledIn == MaxEntries) {

        *EntriesFilledIn = -1;
    }

    return TRUE;
}


void
ShowThread(
    ULONG dwProcessor,
    ULONG64 Thread,
    ULONG ThreadCount,
    ULONG Verbose,
    PULONG Count,
    BOOLEAN IsOwner)
{
    ULONG ThreadType;
    ULONG64 ActualThread;

    if (Thread != 0) {
        (*Count)++;
        dprintf("%08p-%02x%s ", Thread, ThreadCount, IsOwner ? "<*>" : "   ");

        ActualThread = (Thread | 3) - 3;
        if (GetFieldValue(ActualThread, "nt!_ETHREAD", "Tcb.Header.Type", ThreadType) ||
            (ThreadType != ThreadObject)) {
            dprintf("*** Unknown owner, possibly FileSystem");
            *Count=4;

        } else if (Thread & 3) {
            dprintf("*** Actual Thread %p", ActualThread);
            *Count=4;
        }


        if (Verbose) {
            dprintf("\n\n");
            DumpThread(dwProcessor, "     ",  ActualThread, 0xf );
        }
    }

}

DECLARE_API( locks )

/*++

Routine Description:

    Dump kernel mode resource locks

Arguments:

    arg - [-V] [-P] [Address]

Return Value:

    None

--*/

{
    UCHAR       Buffer[256];
    LONG        ActiveCount;
    ULONG       ContentionCount;
    ULONG64     Displacement;
    BOOLEAN     DisplayZero;
    ULONG64     End;
    USHORT      Flag;
    ULONG       Index;
    USHORT      NumberOfExclusiveWaiters;
    USHORT      NumberOfSharedWaiters;
    BOOLEAN     Performance;
    ULONG64     PerformanceData;
    ULONG       TableSize;
    ULONG64     ResourceHead;
    ULONG64     Next;
    ULONG       Result;
    ULONG64     ResourceToDump;
    ULONG64     Resource;
    ULONG64     DdkResource;
    ULONG64     ShWaitListArray[1024];
    BOOLEAN     Owner;
    ULONG       i;
    ULONG       j;
    ULONG64     Thread;
    ULONG64     SharedWaitersSmpAdr;
    ULONG64     ExclusiveWaitersEvAdr;
    BOOLEAN     DetermineSharedOwners;
    BOOLEAN     AllSharedOwners;
    ULONG       SharedWaiterCount;
    LONG        ThreadCount;
    UCHAR       DdkThreadCount;
    BOOLEAN     Verbose;
    PUCHAR      s;
    ULONG       TotalLocks;
    ULONG       TotalUsedLocks;
    ULONG       SkippedLocks;
    ULONG       SizeOfListEntry, SizeofOwnerEntry;
    ULONG       InitialOwnerThreadsOffset, OwnerThreadsOffset;
    ULONG       dwProcessor=0;
    HRESULT     hr = S_OK;
    ULONG64     Link;
    ULONG64     FlinkBlink;
    ULONG64     BlinkFlink;
    ULONG       ResourceListOffset;

    INIT_API();
    GetCurrentProcessor(Client, &dwProcessor, NULL);
    ResourceToDump = 0;

    GetFieldOffset("nt!_ERESOURCE", "SystemResourcesList", &ResourceListOffset);

    DisplayZero = FALSE;
    Performance = FALSE;
    Verbose = FALSE;
    s       = (PSTR)args;
    while ( s != NULL && *s ) {
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch (*s) {
                    case 'D':
                    case 'd':
                        DisplayZero = TRUE;
                        break;

                    case 'P':
                    case 'p':
                        Performance = TRUE;
                        break;

                    case 'V':
                    case 'v':
                        Verbose = TRUE;
                        break;

                    case ' ':
                        goto gotBlank;

                    default:
                        dprintf( "KD: !locks invalid option flag '-%c'\n", *s );
                        break;
                }
            }
        } else if (*s != ' ') {
            ResourceToDump = GetExpression(s);
            s = strpbrk( s, " " );
        } else {
gotBlank:
            s++;
        }
    }

    //
    // Dump performance data if requested.
    //

    if (Performance != FALSE) {
        UCHAR ResPerf[]="nt!_RESOURCE_PERFORMANCE_DATA";
        ULONG TotalResourceCount, ActiveResourceCount, ExclusiveAcquire;
        ULONG SharedFirstLevel, SharedSecondLevel, StarveFirstLevel, StarveSecondLevel;
        ULONG WaitForExclusive, OwnerTableExpands, MaximumTableExpand;
        ULONG HashTableOffset;


        dprintf("**** Dump Resource Performance Data ****\n\n");
        PerformanceData = GetExpression("nt!ExpResourcePerformanceData");
        if ((PerformanceData == 0) ||
            GetFieldValue(PerformanceData, ResPerf,"TotalResourceCount",TotalResourceCount)) {

            //
            // The target build does not support resource performance data.
            //

            dprintf("%08p: No resource performance data available\n", PerformanceData);

        } else {

            GetFieldOffset(ResPerf, "HashTable", &HashTableOffset);

            GetFieldValue(PerformanceData, ResPerf, "ActiveResourceCount", ActiveResourceCount);
            GetFieldValue(PerformanceData, ResPerf,"ExclusiveAcquire", ExclusiveAcquire);
            GetFieldValue(PerformanceData, ResPerf, "SharedFirstLevel", SharedFirstLevel);
            GetFieldValue(PerformanceData, ResPerf,"SharedSecondLevel", SharedSecondLevel);
            GetFieldValue(PerformanceData, ResPerf, "StarveFirstLevel", StarveFirstLevel);
            GetFieldValue(PerformanceData, ResPerf, "StarveSecondLevel", StarveSecondLevel);
            GetFieldValue(PerformanceData, ResPerf, "WaitForExclusive", WaitForExclusive);
            GetFieldValue(PerformanceData, ResPerf, "OwnerTableExpands", OwnerTableExpands);
            GetFieldValue(PerformanceData, ResPerf, "MaximumTableExpand", MaximumTableExpand);

            //
            // Output the summary statistics.
            //

            dprintf("Total resources initialized   : %u\n",
                    TotalResourceCount);

            dprintf("Currently active resources    : %u\n",
                    ActiveResourceCount);

            dprintf("Exclusive resource acquires   : %u\n",
                    ExclusiveAcquire);

            dprintf("Shared resource acquires (fl) : %u\n",
                    SharedFirstLevel);

            dprintf("Shared resource acquires (sl) : %u\n",
                    SharedSecondLevel);

            dprintf("Starve resource acquires (fl) : %u\n",
                    StarveFirstLevel);

            dprintf("Starve resource acquires (sl) : %u\n",
                    StarveSecondLevel);

            dprintf("Shared wait resource acquires : %u\n",
                    WaitForExclusive);

            dprintf("Owner table expansions        : %u\n",
                    OwnerTableExpands);

            dprintf("Maximum table expansion       : %u\n\n",
                    MaximumTableExpand);

            //
            // Dump the inactive resource statistics.
            //

            dprintf("       Inactive Resource Statistics\n");
            dprintf("Contention  Number  Initialization Address\n\n");
            SizeOfListEntry = GetTypeSize("nt!_LIST_ENTRY");

            for (Index = 0; Index < RESOURCE_HASH_TABLE_SIZE; Index += 1) {
                End =  HashTableOffset + PerformanceData +  SizeOfListEntry * Index;

                GetFieldValue(End,"nt!_LIST_ENTRY","Flink",Next);
                while (Next != End) {
                    ULONG64 Address;
                    ULONG Number;

                    if (CheckControlC()) {
                        break;
                    }
                    if (!GetFieldValue(Next,
                                      "nt!_RESOURCE_HASH_ENTRY",
                                      "Address",
                                      Address)) {

                        GetSymbol(Address, Buffer, &Displacement);

                        GetFieldValue(Next,"nt!_RESOURCE_HASH_ENTRY","Number",Number);
                        GetFieldValue(Next,"nt!_RESOURCE_HASH_ENTRY","ContentionCount",ContentionCount);

                        dprintf("%10d  %6d  %s",
                                ContentionCount,
                                Number,
                                Buffer);

                        if (Displacement != 0) {
                            dprintf("+0x%x", Displacement);
                        }

                        dprintf("\n");
                    }

                    GetFieldValue(Next,"nt!_RESOURCE_HASH_ENTRY","ListEntry.Flink", Next);
                }
            }

            //
            // Dump the active resource statistics.
            //

            dprintf("\n        Active Resource Statistics\n");
            dprintf("Resource Contention  Initialization Address\n\n");

            //
            // Read the resource listhead and check if it is empty.
            //

            ResourceHead = GetNtDebuggerData( ExpSystemResourcesList );
            if ((ResourceHead == 0) ||
                (!GetFieldValue(ResourceHead,
                               "nt!_LIST_ENTRY",
                               "Flink",
                               Next) == FALSE)) {

                dprintf("%08p: Unable to get value of ExpSystemResourcesList\n", ResourceHead );
                hr = E_INVALIDARG;
                goto exitBangLocks;
            }

            if (Next == 0) {
                dprintf("ExpSystemResourcesList is NULL!\n");
                hr = E_INVALIDARG;
                goto exitBangLocks;
            }

            //
            // Scan the resource list and dump the resource information.
            //

            while(Next != ResourceHead) {
                ULONG64 Address;

                if (CheckControlC()) {
                    break;
                }
                Resource = Next; // SystemResourcesList is the first element in struct
                    // CONTAINING_RECORD(Next, ERESOURCE, SystemResourcesList);
                if (!GetFieldValue(Resource,
                                  "nt!_ERESOURCE",
                                  "ContentionCount",
                                  ContentionCount) == FALSE) {

                    dprintf("%08p: Unable to read _ERESOURCE\n", Resource);
                    continue;

                } else {
                    GetFieldValue(Resource,"nt!_ERESOURCE","Address",Address);
                    GetFieldValue(Resource,"nt!_ERESOURCE","ContentionCount",ContentionCount);

                    if ((ContentionCount != 0) ||
                        (DisplayZero != FALSE)) {
                        GetSymbol(Address,
                                  Buffer,
                                  &Displacement);

                        dprintf("%08p %10d  %s",
                                Resource,
                                ContentionCount,
                                Buffer);

                        if (Displacement != 0) {
                            dprintf("+0x%x", Displacement);
                        }

                        dprintf("\n");
                    }
                }

                GetFieldValue(Resource,"nt!_ERESOURCE","SystemResourcesList.Flink",Next);
            }

            dprintf("\n");

            //
            // Dump the active fast mutex statistics.
            //

            dprintf("\n        Active Fast Mutex Statistics\n");
            dprintf("Address  Contention  Fast Mutex Name\n\n");

            //
            // Dump statistics for static fast/guarded mutexes.
            //

            DumpStaticFastMutex("FsRtlCreateLockInfo");
            DumpStaticFastMutex("PspActiveProcessMutex");
            dprintf("\n");
        }

        hr = E_INVALIDARG;
        goto exitBangLocks;
    }

    //
    // Dump remaining lock data.
    //

    if (ResourceToDump == 0) {
        dprintf("**** DUMP OF ALL RESOURCE OBJECTS ****\n");
        ResourceHead = GetNtDebuggerData( ExpSystemResourcesList );
        if ( !ResourceHead ||
             (GetFieldValue(ResourceHead,
                            "nt!_LIST_ENTRY",
                            "Flink",
                            Next) != FALSE)) {
            dprintf("%08p: Unable to get value of ExpSystemResourcesList\n", ResourceHead );
            hr = E_INVALIDARG;
            goto exitBangLocks;
        }

        if (Next == 0) {
            dprintf("ExpSystemResourcesList is NULL!\n");
            hr = E_INVALIDARG;
            goto exitBangLocks;
        }

    } else {
        Next = 0;
        ResourceHead = 1;
    }

    TotalLocks      = 0;
    TotalUsedLocks  = 0;
    SkippedLocks    = 0;

    // Get the offset of OwnerThreads in ERESOURCE
    if (GetFieldOffset("nt!_ERESOURCE", "OwnerThreads", &OwnerThreadsOffset)) {
        dprintf("Cannot get _ERESOURCE type\n");
        hr = E_INVALIDARG;
        goto exitBangLocks;
    }

    if (!(SizeofOwnerEntry = GetTypeSize("nt!_OWNER_ENTRY"))) {
        dprintf("Cannot get nt!_OWNER_ENTRY type\n");
        hr = E_INVALIDARG;
        goto exitBangLocks;
    }

    while(Next != ResourceHead) {
        ULONG64 OwnerThreads, OwnerCounts, OwnerTable;

        if (Next != 0) {
            Resource = Next;// SystemResourcesList is the first element of struct ERESOURCE
            // CONTAINING_RECORD(Next,ERESOURCE,SystemResourcesList);

        } else {
            Resource = ResourceToDump;
        }
        /*
        if ( GetFieldValue( Resource,
                            "NTDDK_ERESOURCE",
                            "OwnerThreads",
                            OwnerThreads) ) {
            dprintf("%08lx: Unable to read NTDDK_ERESOURCE\n", Resource );
            break;
        }*/

        //
        //  Detect here if this is an NtDdk resource, and behave
        //  appropriatelty.  If the OwnerThreads is a pointer to the initial
        //  owner threads array (this must take into account that the LOCAL
        //  data structure is a copy of what's in the remote machine in a
        //  different address)
        //

//        DdkResource = (PNTDDK_ERESOURCE)&ResourceContents;
         {
            DdkResource = 0;
            GetFieldValue( Resource,"nt!_ERESOURCE","ActiveCount", ActiveCount);
            GetFieldValue( Resource,"nt!_ERESOURCE","ContentionCount",ContentionCount);
            GetFieldValue( Resource,"nt!_ERESOURCE","NumberOfExclusiveWaiters",NumberOfExclusiveWaiters);
            GetFieldValue( Resource,"nt!_ERESOURCE","NumberOfSharedWaiters",NumberOfSharedWaiters);
            GetFieldValue( Resource,"nt!_ERESOURCE","Flag",Flag);
            GetFieldValue( Resource,"nt!_ERESOURCE","OwnerTable",OwnerTable);
            GetFieldValue( Resource,"nt!_ERESOURCE","SharedWaiters",SharedWaitersSmpAdr);
            GetFieldValue( Resource,"nt!_ERESOURCE","ExclusiveWaiters",ExclusiveWaitersEvAdr);

            //
            //  Grab the Flink->Blink and Blink->Flink contents to verify list integrity.  Since
            //  ExDeleteResource doesn't null any fields, it's possible that what looks like
            //  a resource is no more.
            //

            FlinkBlink = BlinkFlink = 0;
            GetFieldValue( Resource,"nt!_ERESOURCE","SystemResourcesList.Flink",Link);
            GetFieldValue( Link,"nt!_LIST_ENTRY","Blink",FlinkBlink);
            GetFieldValue( Resource,"nt!_ERESOURCE","SystemResourcesList.Blink",Link);
            GetFieldValue( Link,"nt!_LIST_ENTRY","Flink",BlinkFlink);

            TableSize = 0;
            if (OwnerTable != 0) {
                if (GetFieldValue(OwnerTable,
                                   "nt!_OWNER_ENTRY",
                                   "TableSize",
                                   TableSize)) {
                    dprintf("\n%08p: Unable to read TableSize for resource\n", OwnerTable);
                    break;
                }

            }
        }

        TotalLocks++;
        if ((ResourceToDump != 0) || Verbose || (ActiveCount != 0)) {
            EXPRLastDump = Resource;
            if (SkippedLocks) {
                dprintf("\n");
                SkippedLocks = 0;
            }

            DetermineSharedOwners =
            AllSharedOwners = FALSE;

            dprintf("\n");
            dumpSymbolicAddress(Resource, Buffer, TRUE);
            dprintf("Resource @ %s", Buffer );

            if (ActiveCount == 0) {
                dprintf("    Available\n");

            } else if (Flag & ResourceOwnedExclusive) {
                TotalUsedLocks++;
                dprintf("    Exclusively owned\n");

            } else {
                // owned shared

                TotalUsedLocks++;
                dprintf("    Shared %u owning threads\n", ActiveCount);
                if (NumberOfSharedWaiters) {
                    DetermineSharedOwners = TRUE;
                }
                else {
                    AllSharedOwners = TRUE;
                }
            }

            if (FlinkBlink != Resource+ResourceListOffset) {
                dprintf("\nWARNING: SystemResourcesList->Flink chain invalid. Resource may be corrupted, or already deleted.\n\n");
            }
            if (BlinkFlink != Resource+ResourceListOffset) {
                dprintf("\nWARNING: SystemResourcesList->Blink chain invalid. Resource may be corrupted, or already deleted.\n\n");
            }

            if (ContentionCount != 0) {
                dprintf("    Contention Count = %u\n", ContentionCount);
            }

            if (NumberOfSharedWaiters != 0) {
                dprintf("    NumberOfSharedWaiters = %u\n", NumberOfSharedWaiters);
            }

            if (NumberOfExclusiveWaiters != 0) {
                dprintf("    NumberOfExclusiveWaiters = %u\n", NumberOfExclusiveWaiters);
            }

            if (ActiveCount != 0) {
                ULONG ThreadType;
                j = 0;

                if (DetermineSharedOwners) {

                    //  Extract the list of shared waiters from the semaphore.

                    if (!GetWaitListFromDispatcherHeader( ShWaitListArray,
                                                          sizeof( ShWaitListArray),
                                                          SharedWaitersSmpAdr,
                                                          &SharedWaiterCount)) {
                        hr = E_INVALIDARG;
                        goto exitBangLocks;
                    }

                    //  The count could be -1 meaning there were too many for our array.

                    if (-1 == SharedWaiterCount) {

                        dprintf("<< Too many shared waiters to determine owners >>\n");
                        DetermineSharedOwners = FALSE;
                        SharedWaiterCount = NumberOfSharedWaiters;
                    }

                    if (SharedWaiterCount != NumberOfSharedWaiters) {

                        dprintf("WARNING: Shared waiters in semaphore waitlist (%d) != count in resource (%d)\n",
                                SharedWaiterCount, NumberOfSharedWaiters);
                    }
                }

                dprintf("     Threads: ");

                //  Print the embedded 2 owner entries

                if (DdkResource == 0) {

                    GetFieldValue( Resource + OwnerThreadsOffset, "nt!_OWNER_ENTRY","OwnerThread",Thread);
                    GetFieldValue( Resource + OwnerThreadsOffset, "nt!_OWNER_ENTRY","OwnerCount",ThreadCount);

                    Owner = ResourceOwnedExclusive;
                    ShowThread(dwProcessor, Thread, ThreadCount, Verbose, &j, Owner);


                    GetFieldValue( Resource + OwnerThreadsOffset +SizeofOwnerEntry,
                                   "nt!_OWNER_ENTRY","OwnerThread",Thread);
                    GetFieldValue( Resource + OwnerThreadsOffset +SizeofOwnerEntry,
                                   "nt!_OWNER_ENTRY","OwnerCount",ThreadCount);

                    Owner = DetermineSharedOwners
                            ? !FindQWord( Thread, ShWaitListArray, SharedWaiterCount)
                            : AllSharedOwners;
                    ShowThread(dwProcessor, Thread, ThreadCount, Verbose, &j, Owner);

                }

                if (TableSize > 2000)
                {
                    // sanity check
                    dprintf("Owner TableSize too large (%ld) - probably a bad resource.\n");
                    hr = E_INVALIDARG;
                    goto exitBangLocks;
                }

                //  Now list the entries from the overflow owner table

                for (i = DdkResource ? 0 : 1; i < TableSize; i++) {
                    {
                        GetFieldValue( OwnerTable + SizeofOwnerEntry*i,
                                       "nt!_OWNER_ENTRY","OwnerThread",Thread);
                        GetFieldValue( OwnerTable + SizeofOwnerEntry*i,
                                       "nt!_OWNER_ENTRY","OwnerCount",ThreadCount);

                    }

                    if ((Thread == 0)  &&  (ThreadCount == 0)) {
                        continue;
                    }

                    if (j == 4) {
                        j = 0;
                        dprintf("\n              ");
                    }

                    Owner = DetermineSharedOwners
                            ? !FindQWord( Thread, ShWaitListArray, SharedWaiterCount)
                            : AllSharedOwners;
                    ShowThread(dwProcessor, Thread, ThreadCount, Verbose, &j, Owner);

                    if ( CheckControlC() ) {
                        hr = E_INVALIDARG;
                        goto exitBangLocks;
                    }
                }

                //  List any exclusive waiters

                if (NumberOfExclusiveWaiters) {

                    //  Extract the list of waiters from the event.

                    if (!GetWaitListFromDispatcherHeader( ShWaitListArray,
                                                          sizeof( ShWaitListArray),
                                                          ExclusiveWaitersEvAdr,
                                                          &SharedWaiterCount)) {
                        hr = E_INVALIDARG;
                        goto exitBangLocks;
                    }

                    //  The count could be -1 meaning there were too many for our array.

                    if (-1 == SharedWaiterCount) {

                        dprintf("<< Too many exclusive waiters to list>>\n");
                    }
                    else {

                        ULONG Count;

                        if (SharedWaiterCount != NumberOfExclusiveWaiters) {

                            dprintf("WARNING: Exclusive waiters in event waitlist (%d) != count in resource (%d)\n",
                                    SharedWaiterCount, NumberOfExclusiveWaiters);
                        }

                        dprintf("\n     Threads Waiting On Exclusive Access:");

                        for (Count = 0; Count < SharedWaiterCount; Count++) {

                            if (0 == (Count % 4)) {

                                dprintf("\n              ");
                            }

                            dprintf("%08p       ",ShWaitListArray[Count]);

                            if ((0 == (Count % 10)) && CheckControlC()) {
                                hr = E_INVALIDARG;
                                goto exitBangLocks;
                            }
                        }

                        dprintf("\n");
                    }
                }

                if (j) {
                    dprintf("\n");
                }

            }

        } else {
            if ((SkippedLocks++ % 32) == 0) {
                if (SkippedLocks == 1) {
                    dprintf("KD: Scanning for held locks." );

                } else {
                    dprintf("." );
                }
            }
        }

        if (ResourceToDump != 0) {
            break;
        }

        if (hr = GetFieldValue( Resource,"nt!_ERESOURCE","SystemResourcesList.Flink", Next))
        {
            dprintf("Error %lx in reading nt!_ERESOURCE.SystemResourcesList.Flink @ %p\n", Resource);
            goto exitBangLocks;
        }
        if ( CheckControlC() ) {
            hr = E_INVALIDARG;
            goto exitBangLocks;
        }
    }

    if (SkippedLocks) {
        dprintf("\n");
    }

    dprintf( "%u total locks", TotalLocks );
    if (TotalUsedLocks) {
        dprintf( ", %u locks currently held", TotalUsedLocks );
    }

    dprintf("\n");

exitBangLocks:

    EXIT_API();
    return hr;
}

VOID
DumpStaticFastMutex (
    IN PCHAR Name
    )

/*++

Routine Description:

    This function dumps the contention statistics for a fast mutex.

Arguments:

    Name - Supplies a pointer to the symbol name for the fast mutex.

Return Value:

    None.

--*/

{

    ULONG64 FastMutex;
    ULONG   Contention;
    ULONG Result;

    //
    // Get the address of the fast mutex, read the fast mutex contents,
    // and dump the contention data.
    //

    FastMutex = GetExpression(Name);
    if ((FastMutex != 0) &&
        (!GetFieldValue(FastMutex,
                       "nt!_FAST_MUTEX",
                       "Contention",
                       Contention))) {

        dprintf("%08p %10u  %s\n",
                FastMutex,
                Contention,
                &Name[0]);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\lookasid.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    LookAsid.c

Abstract:

    WinDbg Extension Api

Author:

    Gary Kimura [GaryKi]    22-Feb-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  A quick macro to dump a lookaside list given its variable name
//

#define Dump(S,R) { ULONG64 _a;                       \
    if( (_a = GetExpression( S )) == 0) {             \
        dprintf("Failed GetExpression(\"%s\")\n", S); \
    } else if ((R)) {                                 \
        ResetLookaside( _a, S );                      \
    } else {                                          \
        DumpLookaside( _a, S );                       \
    }                                                 \
}

#define GetAddressFromName(A,N) {                     \
    if (((A) = GetExpression( (N) )) == 0) {          \
        dprintf("Failed GetExpression(\"%s\")\n", N); \
        return;                                       \
    }                                                 \
}

#define ReadAtAddress(A,V,S) { ULONG _r;                           \
    if (!ReadMemory((A), &(V), (S), &_r ) || (_r < (S))) {         \
        dprintf("Can't Read Memory at %08p\n", (A));               \
        return;                                                    \
    }                                                              \
}

#define WriteAtAddress(A,V,S) { ULONG _r;                           \
    if (!WriteMemory( (A), &(V), (S), &_r ) || (_r < (S))) {        \
        dprintf("Can't Write Memory at %08p\n", (A));               \
        return;                                                     \
    }                                                               \
}

ULONG TotalPagedPotential;
ULONG TotalPagedUsed;
ULONG TotalNPagedPotential;
ULONG TotalNPagedUsed;


VOID
DumpLookaside (
    IN ULONG64 Address,
    IN PUCHAR  Name
    )

/*++

Routine Description:

    Dump a specific lookaside list.

Arguments:

    Address - Gives the address of the lookaside list to dump

    Name - Gives an optional name of to print next to the lookaside list

Return Value:

    None

--*/

{
    ULONG Results;

    ULONG AllocationHitRate;
    ULONG FreeHitRate;

    UCHAR Str[64];
    ULONG TotalAllocates, Depth, TotalFrees, Type, Size, Tag;

    //
    //  Read the lookaside list from memory
    //

    if (GetFieldValue( Address, "NPAGED_LOOKASIDE_LIST", 
                       "L.TotalAllocates", TotalAllocates)) {

        dprintf("Can't read lookaside \"%s\" at 0x%08p\n", Name, Address);
    }

    //
    //  Dump it out.  Note that for purposes of dumping a paged and nonpaged lookaside are
    //  the same.  I.e., the fields we're interested are at identical offsets
    //
    InitTypeRead(Address, NPAGED_LOOKASIDE_LIST);

    //
    //  Compute the hit rate
    //

    TotalFrees = (ULONG) ReadField(L.TotalFrees);
    AllocationHitRate = (TotalAllocates > 0 ? (((TotalAllocates - (ULONG) ReadField(L.AllocateMisses))*100)/TotalAllocates) : 0);
    FreeHitRate = (TotalFrees > 0 ? (((TotalFrees - (ULONG) ReadField(L.FreeMisses))*100)/TotalFrees) : 0);

    //
    //  Decide what type of pool is behind the lookaside list
    //

    Type = (ULONG) ReadField(L.Type);
    switch (Type & 0x7) {
    case NonPagedPool:                  sprintf(Str, "NonPagedPool");                  break;
    case PagedPool:                     sprintf(Str, "PagedPool");                     break;
    case NonPagedPoolMustSucceed:       sprintf(Str, "NonPagedPoolMustSucceed");       break;
    case DontUseThisType:               sprintf(Str, "DontUseThisType");               break;
    case NonPagedPoolCacheAligned:      sprintf(Str, "NonPagedPoolCacheAligned");      break;
    case PagedPoolCacheAligned:         sprintf(Str, "PagedPoolCacheAligned");         break;
    case NonPagedPoolCacheAlignedMustS: sprintf(Str, "NonPagedPoolCacheAlignedMustS"); break;
    default:                            sprintf(Str, "Unknown pool type");             break;
    }

    //
    //  Add to the total usage and potential based on pool type
    //
    Depth = (ULONG) ReadField(L.Depth);
    Size  = (ULONG) ReadField(L.Size);
    if (Type & 0x1) {

        TotalPagedUsed += (ULONG) ReadField(L.ListHead.Depth) * Size;
        TotalPagedPotential += Depth * Size;

    } else {

        TotalNPagedUsed += (ULONG) ReadField(ListHead.Depth) * Size;
        TotalNPagedPotential += Depth * Size;
    }

    //
    //  Now print everything
    //
    Tag = (ULONG) ReadField(L.Tag);
    dprintf("\nLookaside \"%s\" @ %08p \"%c%c%c%c\"\n", Name, Address, ((PUCHAR)&Tag)[0],
                                                                       ((PUCHAR)&Tag)[1],
                                                                       ((PUCHAR)&Tag)[2],
                                                                       ((PUCHAR)&Tag)[3]);
    dprintf("    Type     =     %04x %s", Type, Str);
    if (Type & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) { dprintf(" QuotaFailInsteadOrRaise"); }
    if (Type & POOL_RAISE_IF_ALLOCATION_FAILURE) { dprintf(" RaiseIfAllocationFailure"); }
    dprintf("\n");
    dprintf("    Current Depth  = %8ld   Max Depth  = %8ld\n", (ULONG) ReadField(L.ListHead.Depth), Depth);
    dprintf("    Size           = %8ld   Max Alloc  = %8ld\n", Size, Depth * Size);
    dprintf("    AllocateMisses = %8ld   FreeMisses = %8ld\n", (ULONG) ReadField(L.AllocateMisses), (ULONG) ReadField(L.FreeMisses));
    dprintf("    TotalAllocates = %8ld   TotalFrees = %8ld\n", TotalAllocates, TotalFrees);
    dprintf("    Hit Rate       =      %3d%%  Hit Rate   =      %3d%%\n", AllocationHitRate, FreeHitRate);

    return;
}


VOID
ResetLookaside (
    IN ULONG64 Address,
    IN PUCHAR  Name
    )

/*++

Routine Description:

    Resets the counters in a specific lookaside list.

Arguments:

    Address - Gives the address of the lookaside list to reset

    Name - Gives an optional name of to print in case of errors

Return Value:

    None

--*/

{
  //  NPAGED_LOOKASIDE_LIST Lookaside;
    ULONG Results, Off=0, Zero=0;

    //
    //  Get offset
    //

    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.TotalAllocates", &Off);
    //
    //  Zero out the counters
    //
    if (!WriteMemory( Address + Off, &Zero, sizeof(ULONG), &Results ) ||
        (Results < sizeof(ULONG))) {

        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }


    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.AllocateMisses", &Off);
    if (!WriteMemory( Address + Off, &Zero, sizeof(ULONG), &Results ) ||
        (Results < sizeof(ULONG))) {
        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }

    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.TotalFrees", &Off);
    if (!WriteMemory( Address + Off, &Zero, sizeof(ULONG), &Results ) ||
        (Results < sizeof(ULONG))) {
        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }

    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.FreeMisses", &Off);
    if (!WriteMemory( Address + Off, &Zero, sizeof(ULONG), &Results ) ||
        (Results < sizeof(ULONG))) {
        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }



    return;
}


VOID
SetDepthLookaside (
    IN ULONG64 Address,
    IN PUCHAR  Name,
    IN ULONG   Depth
    )

/*++

Routine Description:

    Set the depth of a specific lookaside list.

Arguments:

    Address - Gives the address of the lookaside list to reset

    Name - Gives an optional name of to print in case of errors

    Depth - Supplies the depth to set the lookaside list to

Return Value:

    None

--*/

{
    ULONG Results, Off=0;

    //
    //  Get offset
    //

    GetFieldOffset("NPAGED_LOOKASIDE_LIST", "L.Depth", &Off);
    //
    //  Set the depth
    //
    if (!WriteMemory( Address + Off, &Depth, sizeof(USHORT), &Results ) ||
        (Results < sizeof(USHORT))) {

        dprintf("Can't write lookaside \"%s\" at 0x%08p\n", Name, Address);
    }
    return;
}


DECLARE_API( lookaside )

/*++

Routine Description:

    Dump lookaside lists

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    ULONG64 LookasideToDump;
    ULONG   Options;
    ULONG   Depth;

    //
    //  If the caller specified an address then that the the lookaside list we dump
    //

    LookasideToDump = 0;
    Options = 0;
    Depth = 0;

    if (GetExpressionEx(args,&LookasideToDump, &args)) {
        if (!sscanf(args, "%lx %lx",&Options, &Depth)) {
            Options = 0;
            Depth = 0;
        }
    }

    if (LookasideToDump != 0) {

        if (Options == 0) {

            DumpLookaside( LookasideToDump, "");

        } else if (Options == 1) {

            ResetLookaside( LookasideToDump, "");

        } else if (Options == 2) {

            SetDepthLookaside( LookasideToDump, "", Depth );
        }

        return E_INVALIDARG;
    }

    //
    //  Reset the counters we use to sum up the potential pool usage
    //

    TotalPagedPotential = 0;
    TotalPagedUsed = 0;
    TotalNPagedPotential = 0;
    TotalNPagedUsed = 0;

    //
    //  Otherwise we'll dump a built in set of lookaside lists
    //

    Dump("nt!CcTwilightLookasideList", Options == 1);

    Dump("nt!IopSmallIrpLookasideList", Options == 1);
    Dump("nt!IopLargeIrpLookasideList", Options == 1);
    Dump("nt!IopMdlLookasideList", Options == 1);

    Dump("nt!FsRtlFastMutexLookasideList", Options == 1);
    Dump("nt!TunnelLookasideList", Options == 1);

    Dump("nt!ObpCreateInfoLookasideList", Options == 1);
    Dump("nt!ObpNameBufferLookasideList", Options == 1);

    Dump("afd!AfdWorkQueueLookasideList", Options == 1);

    Dump("Fastfat!FatIrpContextLookasideList", Options == 1);

    Dump("Ntfs!NtfsIoContextLookasideList", Options == 1);
    Dump("Ntfs!NtfsIrpContextLookasideList", Options == 1);
    Dump("Ntfs!NtfsKeventLookasideList", Options == 1);
    Dump("Ntfs!NtfsScbNonpagedLookasideList", Options == 1);
    Dump("Ntfs!NtfsScbSnapshotLookasideList", Options == 1);

    Dump("Ntfs!NtfsCcbLookasideList", Options == 1);
    Dump("Ntfs!NtfsCcbDataLookasideList", Options == 1);
    Dump("Ntfs!NtfsDeallocatedRecordsLookasideList", Options == 1);
    Dump("Ntfs!NtfsFcbDataLookasideList", Options == 1);
    Dump("Ntfs!NtfsFcbIndexLookasideList", Options == 1);
    Dump("Ntfs!NtfsIndexContextLookasideList", Options == 1);
    Dump("Ntfs!NtfsLcbLookasideList", Options == 1);
    Dump("Ntfs!NtfsNukemLookasideList", Options == 1);
    Dump("Ntfs!NtfsScbDataLookasideList", Options == 1);

    if (Options != 1) {

        dprintf("\n");
        dprintf("Total NonPaged currently allocated for above lists = %8ld\n", TotalNPagedUsed);
        dprintf("Total NonPaged potential for above lists           = %8ld\n", TotalNPagedPotential);
        dprintf("Total Paged currently allocated for above lists    = %8ld\n", TotalPagedUsed);
        dprintf("Total Paged potential for above lists              = %8ld\n", TotalPagedPotential);

        TotalPagedPotential = 0;
        TotalPagedUsed = 0;
        TotalNPagedPotential = 0;
        TotalNPagedUsed = 0;
    }

/*

    //
    //  Now dump out the small pool lookaside lists or zero their
    //  counters.
    //

    if (Options == 1) {

        ULONG Address;
        ULONG Results;
        ULONG i;

        //
        //  Get the location of the nonpaged list
        //

        GetAddressFromName( Address, "ExpSmallNPagedPoolLookasideLists" );

        //
        //  Read in each list, zero out it counters and write it back out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            LookasideList.TotalAllocates = 0;
            LookasideList.AllocateHits = 0;
            LookasideList.TotalFrees = 0;
            LookasideList.FreeHits = 0;

            WriteAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );
        }

        //
        //  Get the location of the paged list
        //

#ifndef TARGET_PPC

        GetAddressFromName( Address, "ExpSmallPagedPoolLookasideLists" );

        //
        //  Read in each list, zero out it counters and write it back out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            LookasideList.TotalAllocates = 0;
            LookasideList.AllocateHits = 0;
            LookasideList.TotalFrees = 0;
            LookasideList.FreeHits = 0;

            WriteAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );
        }

#endif // TARGET_PPC

    } else {

        ULONG Address;
        ULONG Results;
        ULONG i;

        //
        //  Get the location of the nonpaged list
        //

        GetAddressFromName( Address, "ExpSmallNPagedPoolLookasideLists" );
        dprintf("\nExpSmallNPagedLookasideLists @ %08lx\n", Address);

        //
        //  Read in each list and dump it out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;
            ULONG AllocationHitRate;
            ULONG FreeHitRate;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            TotalNPagedUsed += LookasideList.SListHead.Depth * (i+1)*32;
            TotalNPagedPotential += LookasideList.Depth * (i+1)*32;

            AllocationHitRate = (LookasideList.TotalAllocates > 0 ? ((LookasideList.AllocateHits*100)/LookasideList.TotalAllocates) : 0);
            FreeHitRate = (LookasideList.TotalFrees > 0 ? ((LookasideList.FreeHits*100)/LookasideList.TotalFrees) : 0);

            dprintf("\n  Nonpaged %d bytes @ %08lx\n", (i+1)*32, Location);

            dprintf("    Current Depth  = %8ld   Max Depth  = %8ld\n", LookasideList.SListHead.Depth, LookasideList.Depth);
            dprintf("    Size           = %8ld   Max Alloc  = %8ld\n", (i+1)*32, LookasideList.Depth * (i+1)*32);
            dprintf("    AllocateHits   = %8ld   FreeHits   = %8ld\n", LookasideList.AllocateHits, LookasideList.FreeHits);
            dprintf("    TotalAllocates = %8ld   TotalFrees = %8ld\n", LookasideList.TotalAllocates, LookasideList.TotalFrees);
            dprintf("    Hit Rate       =      %3d%%  Hit Rate   =      %3d%%\n", AllocationHitRate, FreeHitRate);
        }

        //
        //  Get the location of the paged list
        //

#ifndef TARGET_PPC

        GetAddressFromName( Address, "ExpSmallPagedPoolLookasideLists" );
        dprintf("\nExpSmallPagedLookasideLists @ %08lx\n", Address);

        //
        //  Read in each list and dump it out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;
            ULONG AllocationHitRate;
            ULONG FreeHitRate;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            TotalPagedUsed += LookasideList.SListHead.Depth * (i+1)*32;
            TotalPagedPotential += LookasideList.Depth * (i+1)*32;

            AllocationHitRate = (LookasideList.TotalAllocates > 0 ? ((LookasideList.AllocateHits*100)/LookasideList.TotalAllocates) : 0);
            FreeHitRate = (LookasideList.TotalFrees > 0 ? ((LookasideList.FreeHits*100)/LookasideList.TotalFrees) : 0);

            dprintf("\n  Paged %d bytes @ %08lx\n", (i+1)*32, Location);

            dprintf("    Current Depth  = %8ld   Max Depth  = %8ld\n", LookasideList.SListHead.Depth, LookasideList.Depth);
            dprintf("    Size           = %8ld   Max Alloc  = %8ld\n", (i+1)*32, LookasideList.Depth * (i+1)*32);
            dprintf("    AllocateHits   = %8ld   FreeHits   = %8ld\n", LookasideList.AllocateHits, LookasideList.FreeHits);
            dprintf("    TotalAllocates = %8ld   TotalFrees = %8ld\n", LookasideList.TotalAllocates, LookasideList.TotalFrees);
            dprintf("    Hit Rate       =      %3d%%  Hit Rate   =      %3d%%\n", AllocationHitRate, FreeHitRate);
        }

#endif // TARGET_PPC

        dprintf("\n");
        dprintf("Total NonPaged currently allocated for pool lists = %8ld\n", TotalNPagedUsed);
        dprintf("Total NonPaged potential for pool lists           = %8ld\n", TotalNPagedPotential);
        dprintf("Total Paged currently allocated for pool lists    = %8ld\n", TotalPagedUsed);
        dprintf("Total Paged potential for pool lists              = %8ld\n", TotalPagedPotential);
    }

    {
        ULONG Address;
        ULONG Results;

        ULONG i;
        ULONG j;

        UCHAR KeNumberProcessors;
        ULONG KiProcessorBlock[32];

        //
        //  First find out how many processors there are and then read in the
        //  array of processor block pointers
        //

        GetAddressFromName( Address, "KeNumberProcessors" );
        ReadAtAddress( Address, Address, sizeof(ULONG) );

        //
        //  For some bizarre reason sometimes we do a indirect read to get the
        //  number of processors and at other times it is more direct
        //

        if (Address <= 32) {

            KeNumberProcessors = (UCHAR)Address;

        } else {

            ReadAtAddress( Address, KeNumberProcessors, sizeof(UCHAR) );
        }

        GetAddressFromName( Address, "KiProcessorBlock" );
        ReadAtAddress( Address, KiProcessorBlock, sizeof(ULONG)*KeNumberProcessors );

        //
        //  Check if we are to reset the counters
        //

        if (Options == 1) {

            KPRCB Kprcb;

            for (i = 0; i < KeNumberProcessors; i += 1) {


                ReadAtAddress( KiProcessorBlock[i], Kprcb, sizeof(KPRCB) );

                for (j = 0; j < POOL_SMALL_LISTS; j += 1) {

                    Kprcb.SmallNPagedPoolLookasideLists[j].AllocateHits = 0;
                    Kprcb.SmallNPagedPoolLookasideLists[j].TotalAllocates = 0;

#ifndef TARGET_PPC
                    Kprcb.SmallPagedPoolLookasideLists[j].AllocateHits = 0;
                    Kprcb.SmallPagedPoolLookasideLists[j].TotalAllocates = 0;
#endif // TARGET_PPC
                }

                WriteAtAddress( KiProcessorBlock[i], Kprcb, sizeof(KPRCB) );
            }


        } else {

            KPRCB Kprcb[32];
            ULONG Addr[32];
            ULONG Depth[32];
            ULONG Hits[32];
            ULONG Total[32];
            ULONG HitRate[32];
            ULONG MaxAlloc[32];

            dprintf("\nSmall Pool Lookaside lists\n\n");
            dprintf("Kprcb    =");
            for (i = 0; i < KeNumberProcessors; i += 1) {

                dprintf(" %08lx ", KiProcessorBlock[i]);
                ReadAtAddress( KiProcessorBlock[i], Kprcb[i], sizeof(KPRCB) );
            }
            dprintf("\n");

            for ( j = 0; j < POOL_SMALL_LISTS; j += 1) {

                dprintf("\nNonpaged %d bytes\n", (j+1)*32);
                for (i = 0; i < KeNumberProcessors; i += 1) {

                    Addr[i] = KiProcessorBlock[i] + FIELD_OFFSET(KPRCB, SmallNPagedPoolLookasideLists[j]);

                    Depth[i] = Kprcb[i].SmallNPagedPoolLookasideLists[j].Depth;
                    Hits[i] = Kprcb[i].SmallNPagedPoolLookasideLists[j].AllocateHits;
                    Total[i] = Kprcb[i].SmallNPagedPoolLookasideLists[j].TotalAllocates;

                    HitRate[i] = (Total[i] > 0 ? ((Hits[i]*100)/Total[i]) : 0);
                    MaxAlloc[i] = ((j+1)*32) * Depth[i];
                }

                dprintf("Address  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %08lx ", Addr[i]); }   dprintf("\n");
                dprintf("Depth    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Depth[i]); }   dprintf("\n");
                dprintf("MaxAlloc ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", MaxAlloc[i]); } dprintf("\n");
                dprintf("Hits     ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Hits[i]); }    dprintf("\n");
                dprintf("Total    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Total[i]); }   dprintf("\n");
                dprintf("HitRate  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d%%", HitRate[i]); } dprintf("\n");
            }

#ifndef TARGET_PPC
            for ( j = 0; j < POOL_SMALL_LISTS; j += 1) {

                dprintf("\nPaged %d bytes\n", (j+1)*32);
                for (i = 0; i < KeNumberProcessors; i += 1) {

                    Addr[i] = KiProcessorBlock[i] + FIELD_OFFSET(KPRCB, SmallPagedPoolLookasideLists[j]);

                    Depth[i] = Kprcb[i].SmallPagedPoolLookasideLists[j].Depth;
                    Hits[i] = Kprcb[i].SmallPagedPoolLookasideLists[j].AllocateHits;
                    Total[i] = Kprcb[i].SmallPagedPoolLookasideLists[j].TotalAllocates;

                    HitRate[i] = (Total[i] > 0 ? ((Hits[i]*100)/Total[i]) : 0);
                    MaxAlloc[i] = ((j+1)*32) * Depth[i];
                }

                dprintf("Address  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %08lx ", Addr[i]); }   dprintf("\n");
                dprintf("Depth    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Depth[i]); }   dprintf("\n");
                dprintf("MaxAlloc ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", MaxAlloc[i]); } dprintf("\n");
                dprintf("Hits     ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Hits[i]); }    dprintf("\n");
                dprintf("Total    ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d ", Total[i]); }   dprintf("\n");
                dprintf("HitRate  ="); for (i = 0; i < KeNumberProcessors; i += 1) { dprintf(" %8d%%", HitRate[i]); } dprintf("\n");
            }
#endif // TARGET_PPC
        }
    }
*/

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\object.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    object.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:
 
    Kshitiz K. Sharma (kksharma)
    
    Using debugger type info.

    Daniel Mihai (DMihai)

    Add !htrace - for dumping handle tracing information.
--*/


#include "precomp.h"
#pragma hdrstop

typedef struct _SEGMENT_OBJECT {
    PVOID BaseAddress;
    ULONG TotalNumberOfPtes;
    LARGE_INTEGER SizeOfSegment;
    ULONG NonExtendedPtes;
    ULONG ImageCommitment;
    PVOID ControlArea;
} SEGMENT_OBJECT, *PSEGMENT_OBJECT;

typedef struct _SECTION_OBJECT {
    PVOID StartingVa;
    PVOID EndingVa;
    PVOID Parent;
    PVOID LeftChild;
    PVOID RightChild;
    PSEGMENT_OBJECT Segment;
} SECTION_OBJECT;


typedef ULONG64 (*ENUM_LIST_ROUTINE)(
                                     IN ULONG64 ListEntry,
                                     IN PVOID   Parameter
                                     );


static ULONG64           ObpTypeObjectType      = 0;
static ULONG64           ObpRootDirectoryObject = 0;
static WCHAR             ObjectNameBuffer[ MAX_PATH ];

//
// Object Type Structure
//

typedef struct _OBJECT_TYPE_READ {
    LIST_ENTRY64 TypeList;
    UNICODE_STRING64 Name; 
    ULONG64 DefaultObject;
    ULONG Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG Key;
} OBJECT_TYPE_READ, *POBJECT_TYPE_READ;

BOOLEAN
DumpObjectsForType(
                  IN ULONG64          pObjectHeader,
                  IN PVOID            Parameter
                  );

ULONG64
WalkRemoteList(
              IN ULONG64           Head,
              IN ENUM_LIST_ROUTINE EnumRoutine,
              IN PVOID             Parameter
              );

ULONG64
CompareObjectTypeName(
                     IN ULONG64      ListEntry,
                     IN PVOID        Parameter
                     );

PWSTR
GetObjectName(
             ULONG64 Object
             );


BOOLEAN
GetObjectTypeName(
                  IN UNICODE_STRING64 ustrTypeName,
                  IN ULONG64 lpType,
                  IN OUT WCHAR * wszTypeName
                 );

ULONG64 HighestUserAddress;


DECLARE_API( obtrace )

/*++

Routine Description:

    Dump the object trace information for an object.

Arguments:

    args - [object (pointer/path)]

Return Value:

    None

--*/
{
    ULONG64 ObpObjectTable,
            ObpStackTable,
            ObpObjectBuckets,
            ObpTraceDepth,
            ObpStacksPerObject,
            ObjectToTrace,
            ObjectHash,
            ObjectHeader,
            ObRefInfoPtr,
            ObRefInfoPtrLoc,
            BaseStackInfoAddr,
            Offset,
            TraceAddr,
            Trace;
    ULONG   ObjectHeaderBodyOffset,
            ObStackInfoTypeSize,
            PVoidTypeSize,
            Lupe,
            TraceNumber,
            NextPos,
            CountRef,
            CountDeref,
            BytesRead;
    USHORT  Sequence,
            Index;
    UCHAR   ImageFileName[16],
            FunctionName[256];

    FIELD_INFO ObRefInfoFields[] = {
        {"ObjectHeader",  NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &ObjectHeader},
        {"NextRef",       NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &ObRefInfoPtr},
        {"ImageFileName", NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, ImageFileName},
        {"StackInfo",     NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS,  0, NULL},
        {"NextPos",       NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &NextPos}
    },         ObStackInfoFields[] = {
        {"Sequence",      NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &Sequence},
        {"Index"   ,      NULL, 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, &Index}
    };

    SYM_DUMP_PARAM ObRefInfo = {
        sizeof (SYM_DUMP_PARAM), "nt!_OBJECT_REF_INFO", DBG_DUMP_NO_PRINT,
        0, NULL, NULL, NULL, 2, &ObRefInfoFields[0]
    },             ObStackInfo = {
        sizeof (SYM_DUMP_PARAM), "nt!_OBJECT_REF_STACK_INFO", DBG_DUMP_NO_PRINT,
        0, NULL, NULL, NULL, 2, &ObStackInfoFields[0]
    };

    ObpObjectTable = GetUlongValue("ObpObjectTable");
    ObpStackTable = GetUlongValue("ObpStackTable");
    ObpObjectBuckets = GetUlongValue("ObpObjectBuckets");
    ObpTraceDepth = GetUlongValue("ObpTraceDepth");
    ObpStacksPerObject = GetUlongValue("ObpStacksPerObject");

    if (GetFieldOffset("nt!_OBJECT_HEADER",
                       "Body",
                       &ObjectHeaderBodyOffset)) {
        return E_INVALIDARG;
    }

    ObStackInfoTypeSize = GetTypeSize("nt!_OBJECT_REF_STACK_INFO");
    PVoidTypeSize = IsPtr64() ? 8 : 4;
    
    if (strlen(args) < 1) {
        return E_INVALIDARG;
    }

    if (args[0] == '\\') {
        ObjectToTrace = FindObjectByName((PUCHAR)args, 0);
    } else {
        ObjectToTrace = GetExpression(args);
    }

    if (ObjectToTrace == 0) {
        dprintf("Object %s not found.\n", args);
        return E_INVALIDARG;
    } 

    // ObjectRefChain <= ObpObjectTable[OBTRACE_HASHOBJECT(ObjectToTrace)]
    ObjectHash = ((ObjectToTrace >> 4) & 0xfffff) % (ObpObjectBuckets ? ObpObjectBuckets : 1);
    ObRefInfoPtrLoc = ObpObjectTable + GetTypeSize("nt!POBJECT_REF_INFO") * ObjectHash;

    for (ObRefInfo.addr = GetPointerFromAddress(ObRefInfoPtrLoc);
         ObRefInfo.addr;
         ObRefInfo.addr = ObRefInfoPtr) {

        if (Ioctl(IG_DUMP_SYMBOL_INFO, &ObRefInfo, ObRefInfo.size)) {
            dprintf("Unable to read ObRefInfo %x\n", ObRefInfo.addr);
            return E_INVALIDARG;
        }

        if (ObjectHeader == ObjectToTrace - ObjectHeaderBodyOffset) {
            break;
        }

        if (CheckControlC()) {
            dprintf("Aborting object lookup\n");
            return S_OK;
        }
    }

    if (! ObRefInfo.addr) {
        dprintf("Unable to find object in table.\n");
        return E_INVALIDARG;
    }

    // We need the rest of the fields now
    ObRefInfo.nFields = sizeof(ObRefInfoFields) / sizeof(ObRefInfoFields[0]);
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &ObRefInfo, ObRefInfo.size)) {
        return E_INVALIDARG;
    }
    BaseStackInfoAddr = ObRefInfoFields[3].address;

    dprintf("Object: %x\n", ObjectToTrace);
    dprintf(" Image: %s\n", ImageFileName);
    dprintf("Seq.  Stack\n");
    dprintf("----  ----------------------------------------------------------\n");

    CountRef = 0;
    CountDeref = 0;

    for (Lupe = 0;
         Lupe < NextPos;
         Lupe++) {

        if (CheckControlC()) {
            return S_OK;
        }

        ObStackInfo.addr = BaseStackInfoAddr + Lupe * ObStackInfoTypeSize;
        if (Ioctl(IG_DUMP_SYMBOL_INFO, &ObStackInfo, ObStackInfo.size)) {
            dprintf("Unable to read ObStackInfo %x\n", ObStackInfo.addr);
            return E_INVALIDARG;
        }

        if (Index & 0x8000) {
            CountRef++;
        } else {
            CountDeref++;
        }

        for (TraceNumber = 0;
             TraceNumber < ObpTraceDepth;
             TraceNumber++) {
            TraceAddr = ObpStackTable
                + (PVoidTypeSize
                   * (ObpTraceDepth * (Index & 0x7fff)
                      + TraceNumber));
            Trace = GetPointerFromAddress(TraceAddr);
            if (Trace) {
                GetSymbol(Trace, FunctionName, &Offset);
                if (TraceNumber == 0) {
                    dprintf("%04x %c",
                            Sequence,
                            Index & 0x8000 ? '+' : ' ');
                } else {
                    dprintf("      "); /* six spaces */
                }
                dprintf("%s+%x\n", FunctionName, Offset);
            }

            if (CheckControlC()) {
                return S_OK;
            }
        }
        dprintf("\n");
    }

    dprintf("----  ----------------------------------------------------------\n");
    dprintf("References: %d, Dereferences %d", CountRef, CountDeref);
    if(CountDeref + CountRef == ObpStacksPerObject) {
        dprintf("  (maximum stacks reached)");
    }
    dprintf("\n");

    return S_OK;
}



DECLARE_API( object )

/*++

Routine Description:

    Dump an object manager object.

Arguments:

    args - 0 <TypeName> | <Path> | <Address> | -r

Return Value:

    None

--*/
{
    ULONG64   ObjectToDump = 0;
    char      NameBuffer[ MAX_PATH+1 ];
    ULONG     NumberOfObjects;
    ULONG     ObjectDumpFlags = 0xFFFFFFFF;

    HighestUserAddress = GetNtDebuggerDataValue(MmHighestUserAddress);
    if (!FetchObjectManagerVariables(FALSE)) {
        return E_INVALIDARG;
    }

    ObjectToDump    = EXPRLastDump;
    ZeroMemory(NameBuffer, sizeof(NameBuffer));

    // Skip leading whitespace
    while (args && (*args == ' ')) { 
        ++args;
    }

    //
    // If the argument looks like a path, try to chase it.
    //

    if (args[0] == '\\') {

        ULONG64 object;

        object = FindObjectByName((PUCHAR) args, 0);

        if (object != 0) {
            DumpObject("", object, ObjectDumpFlags);
        } else {
            dprintf("Object %s not found\n", args);
        }
        return S_OK;
    }

    //
    // If the argument is -r or -R, reload the cached symbol information
    //

    if ( !strcmp(args, "-r") ) {
        FetchObjectManagerVariables(TRUE);
        return S_OK;
    }

    if ( !strcmp(args, "-h") || !strcmp(args, "-?") ||
         (strlen(args) == 0) ) {
        dprintf("Usage: !object [[-r] | [<Path>] | [<Address>] | [0 <TypeName>]]\n");
        return S_OK;
    }

    //
    // If the argument looks like 0 <TypeName>, get TypeName
    //

    if ((args[0] == '0') && (args[1] == ' ')) {
        args += 2;
        while (args && (*args == ' ')) { 
            ++args;
        }
        strncpy(NameBuffer, args, sizeof(NameBuffer)/sizeof(char) - 1);
        ObjectToDump = 0;
    } else {

        //
        // Argument must be in form of address or expression
        //

        if (GetExpressionEx(args,&ObjectToDump, &args)) {
            DumpObject("", ObjectToDump, ObjectDumpFlags);
            return S_OK;
        } else {
            dprintf("*** Invalid address argument specified\n");
            return E_INVALIDARG;
        }
        if (!args || !*args) {
            dprintf("*** Unrecognized argument(s) specified: '%s'\n",
                    args);
            return E_INVALIDARG;
        }
    }

    if ( (ObjectToDump == 0) && (strlen( NameBuffer ) > 0) ) {
        NumberOfObjects = 0;
        if (WalkObjectsByType( NameBuffer, DumpObjectsForType, &NumberOfObjects )) {
            dprintf( "Total of %u objects of type '%s'\n", NumberOfObjects, NameBuffer );
            return S_OK;
        }

        return E_INVALIDARG;
    }

    dprintf( "*** invalid syntax.\n" );
    return E_INVALIDARG;
}


BOOLEAN
DumpObjectsForType(
                  IN ULONG64          pObjectHeader,
                  IN PVOID            Parameter
                  )
{
    ULONG64 Object;
    ULONG   BodyOffset;
    PULONG NumberOfObjects = (PULONG)Parameter;

    if (GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset)) {
        return FALSE;
    }

    *NumberOfObjects += 1;

    Object = pObjectHeader + BodyOffset;

    DumpObject( "", Object, 0xFFFFFFFF );
    return TRUE;
}


BOOLEAN
FetchObjectManagerVariables(
                           BOOLEAN ForceReload
                           )
{
    ULONG        Result;
    ULONG64      Addr;
    static BOOL  HaveObpVariables = FALSE;

    if (HaveObpVariables && !ForceReload) {
        return TRUE;
    }

    Addr = GetNtDebuggerData( ObpTypeObjectType );
    if ( !Addr ||
         !ReadPointer( Addr,
                  &ObpTypeObjectType) ) {
        dprintf("%08p: Unable to get value of ObpTypeObjectType\n", Addr );
        return FALSE;
    }

    Addr = GetNtDebuggerData( ObpRootDirectoryObject );
    if ( !Addr ||
         !ReadPointer( Addr,
                  &ObpRootDirectoryObject) ) {
        dprintf("%08p: Unable to get value of ObpRootDirectoryObject\n",Addr );
        return FALSE;
    }

    HaveObpVariables = TRUE;
    return TRUE;
}

ULONG64
FindObjectType(
              IN PUCHAR TypeName
              )
{
    WCHAR NameBuffer[ 64 ] = {0};
    FIELD_INFO offField = {"TypeList", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "nt!_OBJECT_TYPE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };

    // Get The offset
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        return 0;
    }




    _snwprintf( NameBuffer,
                sizeof( NameBuffer ) / sizeof( WCHAR ) - sizeof(WCHAR),
                L"%hs",
                TypeName
              );
    return WalkRemoteList( ObpTypeObjectType + offField.address,
                           CompareObjectTypeName,
                           NameBuffer
                         );
}




ULONG64
WalkRemoteList(
              IN ULONG64           Head,
              IN ENUM_LIST_ROUTINE EnumRoutine,
              IN PVOID             Parameter
              )
{
    ULONG        Result;
    ULONG64      Element;
    ULONG64      Flink;
    ULONG64      Next;

    if ( GetFieldValue(Head, "nt!_LIST_ENTRY", "Flink", Next)) {
        dprintf( "%08lx: Unable to read list\n", Head );
        return 0;
    }

    while (Next != Head) {

        Element = (EnumRoutine)( Next, Parameter );
        if (Element != 0) {
            return Element;
        }

        if ( CheckControlC() ) {
            return 0;
        }

        if ( GetFieldValue(Next, "nt!_LIST_ENTRY", "Flink", Flink)) {
            dprintf( "%08lx: Unable to read list\n", Next );
            return 0;
        }
        
        Next = Flink;
    }

    return 0;
}



ULONG64
CompareObjectTypeName(
                     IN ULONG64      ListEntry,
                     IN PVOID        Parameter
                     )
{
    ULONG           Result;
    ULONG64         pObjectTypeObjectHeader;
    WCHAR           NameBuffer[ 64 ];
    UNICODE_STRING64 Name64={0};

    ULONG64                     pCreatorInfo;
    ULONG64                     pNameInfo;
    ULONG BodyOffset, TypeListOffset;

    // Get The offset
    if (GetFieldOffset("nt!_OBJECT_HEADER_CREATOR_INFO", "TypeList", &TypeListOffset)) {
        dprintf("Type nt!_OBJECT_HEADER_CREATOR_INFO, field TypeList not found\n");
        return FALSE;
    }

    pCreatorInfo = ListEntry - TypeListOffset;
    pObjectTypeObjectHeader = (pCreatorInfo + GetTypeSize("nt!_OBJECT_HEADER_CREATOR_INFO"));
    
    KD_OBJECT_HEADER_TO_NAME_INFO( pObjectTypeObjectHeader, &pNameInfo);

    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Length", Name64.Length);
    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.MaximumLength", Name64.MaximumLength);
    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", Name64.Buffer);

    if (Name64.Length > sizeof( NameBuffer )) {
        Name64.Length = sizeof( NameBuffer ) - sizeof( UNICODE_NULL );
    }

    if (GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset)) {
        dprintf("Type nt!_OBJECT_HEADER, field Body not found\n");
        return FALSE;
    }

    if (!GetObjectTypeName(Name64, (pObjectTypeObjectHeader + BodyOffset) , NameBuffer))
    {
        dprintf( "%08p: Unable to read object type name.\n", pObjectTypeObjectHeader );
        return 0;
    }

    NameBuffer[ Name64.Length / sizeof( WCHAR ) ] = UNICODE_NULL;

    if (!_wcsicmp( NameBuffer, (PWSTR)Parameter )) {
        return (pObjectTypeObjectHeader + BodyOffset);
    }

    return 0;
}

typedef struct _OBJECT_HEADER_READ {
    LONG PointerCount;
    LONG HandleCount;
    ULONG64  SEntry;
    ULONG64  Type;
    UCHAR NameInfoOffset;
    UCHAR HandleInfoOffset;
    UCHAR QuotaInfoOffset;
    UCHAR Flags;
    ULONG64 ObjectCreateInfo;
    ULONG64  SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER_READ, *POBJECT_HEADER_READ;

typedef struct OBJECT_HEADER_NAME_INFO_READ {
    ULONG64          Directory;
    UNICODE_STRING64 Name;
} OBJECT_HEADER_NAME_INFO_READ;

typedef struct _OBJECT_INFO {
    ULONG64        pObjectHeader;
    OBJECT_HEADER_READ  ObjectHeader;
    OBJECT_TYPE_READ    ObjectType;
    OBJECT_HEADER_NAME_INFO_READ NameInfo;
    WCHAR          TypeName[ 32 ];
    WCHAR          ObjectName[ 256 ];
    WCHAR          FileSystemName[ 32 ];
    CHAR           Message[ 256 ];
} OBJECT_INFO, *POBJECT_INFO;


//+---------------------------------------------------------------------------
//
//  Function:   GetObjectTypeName
//
//  Synopsis:   Fill in the ObjectTypeName in the ObjectInfo struct
//
//  Arguments:  [Object]     -- object examined used only in an error message
//              [ObjectInfo] -- struct containing object type info that is
//                              modified to include the object type name
//
//  Returns:    TRUE if successful
//
//  History:    12-05-1997   benl   Created
//
//  Notes:      If the name is paged out we try a direct comparison against
//              known object types, this known list is not comprehensive
//
//----------------------------------------------------------------------------

BOOLEAN
GetObjectTypeName(IN UNICODE_STRING64 ustrTypeName, IN ULONG64 lpType,
                  IN OUT WCHAR * wszTypeName)
{
    DWORD   dwResult;
    BOOLEAN fRet = TRUE;
    ULONG64 dwIoFileObjectType = 0;
    ULONG64 dwCmpKeyObjectType = 0;
    ULONG64 dwMmSectionObjectType = 0;
    ULONG64 dwObpDirectoryObjectType = 0;
    ULONG64 dwObpSymbolicLinkObjectType = 0;


    __try
    {
        if (ReadMemory(  ustrTypeName.Buffer,
                         wszTypeName,
                         ustrTypeName.Length,
                         &dwResult
                       )){
            fRet = TRUE;
            __leave;
        }

        //
        // Unable to directly read object type name so try to load the known
        // types directly and compare addresses
        // This is not comprehensive for all object types, if we don't find
        // a match this way - revert to old behavior and fail with a message
        //


        if (!ReadPointer( GetExpression("NT!IoFileObjectType"),
                      &dwIoFileObjectType)) {
            dprintf("Unable to load NT!IoFileObjectType\n");
        } else if (dwIoFileObjectType == lpType) {
            wcscpy(wszTypeName, L"File");
            __leave;
        }

        if (!ReadPointer( GetExpression("NT!CmpKeyObjectType"),
                     &dwCmpKeyObjectType)) {
            dprintf("Unable to load NT!CmpKeyObjectType\n");
        } else if (dwCmpKeyObjectType == lpType) {
            wcscpy(wszTypeName, L"Key");
            __leave;
        }

        if (!ReadPointer( GetExpression("NT!MmSectionObjectType"),
                     &dwMmSectionObjectType)) {
            dprintf("Unable to load NT!MmSectionObjectType\n");
        } else if (dwMmSectionObjectType == lpType) {
            wcscpy(wszTypeName, L"Section");
            __leave;
        }

        if (!ReadPointer( GetExpression("NT!ObpDirectoryObjectType"),
                     &dwObpDirectoryObjectType)) {
            dprintf("Unable to load NT!ObpDirectoryObjectType\n");
        } else if (dwObpDirectoryObjectType == lpType) {
            wcscpy(wszTypeName, L"Directory");
            __leave;
        }

        if (!ReadPointer( GetExpression("NT!ObpSymbolicLinkObjectType"),
                      &dwObpDirectoryObjectType)) {
            dprintf("Unable to load NT!ObpSymbolicLinkObjectType\n");
        } else if (dwObpSymbolicLinkObjectType == lpType) {
            wcscpy(wszTypeName, L"SymbolicLink");
            __leave;
        }

        //
        //Fallthrough if type not found
        //
        wszTypeName[0] = L'\0';
        fRet = FALSE;

    } __finally
    {
    }
    return fRet;
} // GetObjectTypeName


BOOLEAN
GetObjectInfo(
             ULONG64 Object,
             POBJECT_INFO ObjectInfo
             )
{
    ULONG           Result;
    ULONG64         pNameInfo;
    BOOLEAN         PagedOut;
    UNICODE_STRING64  ObjectName;
    PWSTR           FileSystemName;
    SECTION_OBJECT  SectionObject;
    SEGMENT_OBJECT  SegmentObject;
    ULONG           BodyOffset;
#define Hdr         ObjectInfo->ObjectHeader
    FIELD_INFO ObjHdrFields[] = {
        {"PointerCount"     , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.PointerCount},
        {"HandleCount"      , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.HandleCount},
        {"SEntry"           , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.SEntry},
        {"Type"             , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RECUR_ON_THIS, 0, (PVOID) &Hdr.Type},
        {"NameInfoOffset"   , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.NameInfoOffset},
        {"HandleInfoOffset" , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.HandleInfoOffset},
        {"QuotaInfoOffset"  , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.QuotaInfoOffset},
        {"Flags"            , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.Flags},
        {"ObjectCreateInfo" , "", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.ObjectCreateInfo},
        {"SecurityDescriptor","", 0, DBG_DUMP_FIELD_COPY_FIELD_DATA, 0, (PVOID) &Hdr.SecurityDescriptor},
    };                                                                           
#undef Hdr
    SYM_DUMP_PARAM ObjSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "nt!_OBJECT_HEADER", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, sizeof (ObjHdrFields) / sizeof (FIELD_INFO), &ObjHdrFields[0]
    };

    PagedOut = FALSE;
    memset( ObjectInfo, 0, sizeof( *ObjectInfo ) );

    GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset);

    ObjectInfo->pObjectHeader = (Object - BodyOffset); // (OBJECT_TO_OBJECT_HEADER( Object );
    ObjSym.addr    = ObjectInfo->pObjectHeader;

    if (Ioctl(IG_DUMP_SYMBOL_INFO, &ObjSym, ObjSym.size)) {
    
        if (Object >= HighestUserAddress && (ULONG)Object < 0xF0000000) {
            PagedOut = TRUE;
            return FALSE;
            // Not using Opt Value
            /*
            sprintf( ObjectInfo->Message, "%08lx: object is paged out.", Object );
            if (!ARGUMENT_PRESENT( OptObjectHeader )) {
                return FALSE;
            }
            ObjectInfo->ObjectHeader.Flags = OptObjectHeader->Flags;
            ObjectInfo->ObjectHeader.HandleCount = OptObjectHeader->HandleCount;
            ObjectInfo->ObjectHeader.NameInfoOffset = OptObjectHeader->NameInfoOffset;
            ObjectInfo->ObjectHeader.ObjectCreateInfo = (ULONG64) OptObjectHeader->ObjectCreateInfo;
            ObjectInfo->ObjectHeader.PointerCount = OptObjectHeader->PointerCount;
            ObjectInfo->ObjectHeader.QuotaInfoOffset = OptObjectHeader->QuotaInfoOffset;
            ObjectInfo->ObjectHeader.SecurityDescriptor = (ULONG64) OptObjectHeader->SecurityDescriptor;
            ObjectInfo->ObjectHeader.SEntry = (ULONG64) OptObjectHeader->SEntry;
            ObjectInfo->ObjectHeader.Type = (ULONG64) OptObjectHeader->Type;*/
        } else {
            sprintf( ObjectInfo->Message, "%I64lx: not a valid object (ObjectHeader invalid @ -offset %x)", UNEXTEND64(Object), BodyOffset );
            return FALSE;
        }
    }

    if (!ObjectInfo->ObjectHeader.Type) {
        sprintf( ObjectInfo->Message, "%08I64lx: Not a valid object (ObjectType invalid)", UNEXTEND64(Object) );
        return FALSE;
    }

    GetFieldValue(ObjectInfo->ObjectHeader.Type, "nt!_OBJECT_TYPE", 
                      "Name.Length", ObjectInfo->ObjectType.Name.Length);
    GetFieldValue(ObjectInfo->ObjectHeader.Type, "nt!_OBJECT_TYPE", 
                      "Name.MaximumLength", ObjectInfo->ObjectType.Name.MaximumLength);
    GetFieldValue(ObjectInfo->ObjectHeader.Type, "nt!_OBJECT_TYPE", 
                      "Name.Buffer", ObjectInfo->ObjectType.Name.Buffer);

    if (ObjectInfo->ObjectType.Name.Length >= sizeof( ObjectInfo->TypeName )) {
        ObjectInfo->ObjectType.Name.Length = sizeof( ObjectInfo->TypeName ) - sizeof( UNICODE_NULL );
    }

    if (!GetObjectTypeName(ObjectInfo->ObjectType.Name,
                           ObjectInfo->ObjectHeader.Type, ObjectInfo->TypeName))
    {
        sprintf( ObjectInfo->Message, "%I64lx: Not a valid object "
                                      "(ObjectType.Name at 0x%I64lx invalid)",
                                      UNEXTEND64(Object), ObjectInfo->ObjectType.Name.Buffer);
        return FALSE;
    }

    ObjectInfo->TypeName[ ObjectInfo->ObjectType.Name.Length / sizeof( WCHAR ) ] = UNICODE_NULL;

    if (PagedOut) {
        return TRUE;
    }

    if (!wcscmp( ObjectInfo->TypeName, L"File" )) {
        ULONG64 DeviceObject=0;
        
        if (GetFieldValue(Object, "nt!_FILE_OBJECT", "FileName.Buffer", ObjectName.Buffer)) {
            sprintf( ObjectInfo->Message, "%08I64lx: unable to read _FILE_OBJECT for name\n", UNEXTEND64(Object) );
        } else {
        
            GetFieldValue(Object, "nt!_FILE_OBJECT", "DeviceObject", DeviceObject);
            GetFieldValue(Object, "nt!_FILE_OBJECT", "FileName.Length", ObjectName.Length);
            GetFieldValue(Object, "nt!_FILE_OBJECT", "FileName.MaximumLength", ObjectName.MaximumLength);
        
            FileSystemName = GetObjectName( DeviceObject );
            if (FileSystemName != NULL) {
                wcscpy( ObjectInfo->FileSystemName, FileSystemName );
            }
        }
    } else if (!wcscmp( ObjectInfo->TypeName, L"Key" )) {
        ULONG64 pKeyControlBlock=0;
        
        if (GetFieldValue(Object, "nt!_CM_KEY_BODY", "KeyControlBlock", pKeyControlBlock)) {
            sprintf( ObjectInfo->Message, "%08I64lx: unable to read key object for name\n", UNEXTEND64(Object) );
        } else if (!pKeyControlBlock) {
            sprintf( ObjectInfo->Message, "%08I64lx: unable to read key control block for name\n", UNEXTEND64(pKeyControlBlock) );
        } else {
            ObjectName.Length = GetKcbName( pKeyControlBlock,
                                            ObjectInfo->ObjectName,
                                            sizeof( ObjectInfo->ObjectName));
            return TRUE;
        }
    } else {
          
        if (ObjectInfo->ObjectHeader.NameInfoOffset) {
            pNameInfo = ObjectInfo->pObjectHeader - ObjectInfo->ObjectHeader.NameInfoOffset;
        } else {
            return TRUE;
         }
        if ( InitTypeRead(pNameInfo, nt!_OBJECT_HEADER_NAME_INFO) ) {              
            dprintf( ObjectInfo->Message, "*** unable to read _OBJECT_HEADER_NAME_INFO at %08p\n", pNameInfo );
            return FALSE;
        }

        ObjectInfo->NameInfo.Name.Length = (USHORT) ReadField(Name.Length);   
        ObjectInfo->NameInfo.Name.MaximumLength = (USHORT) ReadField(Name.MaximumLength);
        ObjectInfo->NameInfo.Name.Buffer = ReadField(Name.Buffer);
        ObjectInfo->NameInfo.Directory = ReadField(Directory);

        ObjectName = ObjectInfo->NameInfo.Name;
    }

    if (ObjectName.Length == 0 && !wcscmp( ObjectInfo->TypeName, L"Section" )) {
        ULONG PtrSize = GetTypeSize("nt!PVOID");
        ULONG64 Segment=0;

        //
        // Get Types of SectionObject etc
        //
        //
        // Assumption ptr to section object is 6th pointer value from Object
        //

        if (!GetFieldValue( Object, "nt!_SECTION_OBJECT", "Segment", Segment)) {
            ULONG64 ControlArea=0;
            if (Segment && !GetFieldValue( Segment, "nt!_SEGMENT_OBJECT", "ControlArea", ControlArea)) {
                ULONG64 FilePointer=0;
                if (ControlArea &&
                    !GetFieldValue( Segment, "nt!_CONTROL_AREA", "FilePointer", FilePointer)) {
                    if (FilePointer) {
                        GetFieldValue(FilePointer, "nt!_FILE_OBJECT", "FileName.Length", ObjectName.Length);
                        GetFieldValue(FilePointer, "nt!_FILE_OBJECT", "FileName.Buffer", ObjectName.Buffer);
                        ObjectName.MaximumLength = ObjectName.Length;
                    } else {
                        sprintf( ObjectInfo->Message, "unable to read file object at %08I64lx for section %08I64lx\n",
                                  UNEXTEND64(FilePointer), UNEXTEND64(Object) );
                    }
                } else {
                    sprintf( ObjectInfo->Message, "unable to read segment object at %08I64lx for section %08I64lx\n",
                           UNEXTEND64(ControlArea), UNEXTEND64(Object) );
                }

            } else {
                sprintf( ObjectInfo->Message, "unable to read segment object at %08I64lx for section %08I64lx\n",
                         UNEXTEND64(Segment), UNEXTEND64(Object) );
            }
        } else {
            sprintf( ObjectInfo->Message, "unable to read section object at %08lx\n", Object );
        }
    }

    if (ObjectName.Length >= sizeof( ObjectInfo->ObjectName )) {
        ObjectName.Length = sizeof( ObjectInfo->ObjectName ) - sizeof( UNICODE_NULL );
    }

    if (ObjectName.Length != 0) {
        if (!ReadMemory( ObjectName.Buffer,
                         ObjectInfo->ObjectName,
                         ObjectName.Length,
                         &Result
                       )
           ) {
            wcscpy( ObjectInfo->ObjectName, L"(*** Name not accessable ***)" );
        } else {
            ObjectInfo->ObjectName[ ObjectName.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
        }
    }

    return TRUE;
}


ULONG64
FindObjectByName(
                IN PUCHAR  Path,
                IN ULONG64 RootObject
                )
{
    ULONG Result, i, j;
    ULONG64           pDirectoryObject;
    ULONG64           pDirectoryEntry;
    ULONG64           HashBucketsAddress;
    ULONG             HashBucketSz;
    OBJECT_INFO ObjectInfo;
    BOOLEAN foundMatch = FALSE;
    ULONG             HashOffset;
    PUCHAR nextPath;

    if (RootObject == 0) {

        if (!FetchObjectManagerVariables(FALSE)) {
            return 0;
        }

        RootObject = ObpRootDirectoryObject;
    }

    pDirectoryObject = RootObject;

    //
    // See if we've reached the end of the path, at which point we know
    // that RootObject is the object to be dumped.
    //

    if (*Path == '\0') {
        return RootObject;
    }

    //
    // Scan the path looking for another delimiter or for the end of the
    // string.

    nextPath = Path;

    while ((*nextPath != '\0') &&
           (*nextPath != '\\')) {

        nextPath++;
    }

    //
    // if we found a delimeter remove it from the next path and use it to
    // truncate the current path.
    //

    if (*nextPath == '\\') {
        *nextPath = '\0';
        nextPath++;
    }

    //
    // Make sure there's a path node here.  If not, recursively call ourself
    // with the remainder of the path.
    //

    if (*Path == '\0') {
        return FindObjectByName(nextPath, RootObject);
    }

    //
    // Get the address of hashbuckets array and size of the pointer to scan the array
    //
    
    if (GetFieldOffset("nt!_OBJECT_DIRECTORY", "HashBuckets", &HashOffset)) {
        dprintf("Cannot find _OBJECT_DIRECTORY type.\n");
        return FALSE;
    }
    HashBucketsAddress = pDirectoryObject + HashOffset;
    HashBucketSz = IsPtr64() ? 8 : 4;

// From ob.h
#define NUMBER_HASH_BUCKETS 37

    for (i=0; i<NUMBER_HASH_BUCKETS; i++) {
        ULONG64 HashBucketI = 0;

        ReadPointer(HashBucketsAddress + i*HashBucketSz, &HashBucketI);
        if (HashBucketI != 0) {
            pDirectoryEntry = HashBucketI;
            while (pDirectoryEntry != 0) {
                ULONG64 Object=0, Next=0;

                if (CheckControlC()) {
                    return FALSE;
                }

                if ( GetFieldValue(pDirectoryEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "Object", Object)) {
                    // dprintf( "Unable to read directory entry at %x\n", pDirectoryEntry );
                    break;
                }

                if (!GetObjectInfo(Object, &ObjectInfo)) {
                    // dprintf( " - %s\n", ObjectInfo.Message );
                } else {
                    foundMatch = TRUE;

                    for (j = 0;
                        (Path[j] != '\0') && (ObjectInfo.ObjectName[j] != L'\0');
                        j++) {

                        if (tolower(Path[j]) !=
                            towlower(ObjectInfo.ObjectName[j])) {
                            foundMatch = FALSE;
                            break;
                        }

                    }

                    if (foundMatch) {

                        if ((Path[j] == '\0') &&
                            (ObjectInfo.ObjectName[j] == L'\0')) {

                            return FindObjectByName(nextPath, Object);
                        }

                    }

                }

                GetFieldValue(pDirectoryEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "ChainLink", Next);
                pDirectoryEntry = Next;
            }
        }
    }

    return 0;
}

VOID
DumpDirectoryObject(
                   IN char     *Pad,
                   IN ULONG64   Object
                   )
{
    ULONG Result, i;
    ULONG64           pDirectoryObject = Object;
    ULONG64           pDirectoryEntry;
    ULONG64           HashBucketsAddress;
    ULONG             HashBucketSz;
    ULONG             HashOffset;
    OBJECT_INFO ObjectInfo;
    ULONG SymbolicLinkUsageCount=0;
    ULONG Indent64; // extra indent to aligning column headers for 64-bit addresses

    //
    // Get the address of hashbuckets array and size of the pointer to scan the array
    //
    if (GetFieldOffset("nt!_OBJECT_DIRECTORY", "HashBuckets", &HashOffset)) {
        dprintf("Cannot find _OBJECT_DIRECTORY type.\n");
        return ;
    }
    HashBucketsAddress = pDirectoryObject + HashOffset;
    HashBucketSz = IsPtr64() ? 8 : 4;
    Indent64 = IsPtr64() ? 8 : 0;
    
    GetFieldValue(pDirectoryObject, "nt!_OBJECT_DIRECTORY", "SymbolicLinkUsageCount", SymbolicLinkUsageCount);

    if (SymbolicLinkUsageCount != 0) {
        dprintf( "%s    %u symbolic links snapped through this directory\n",
                 Pad,
                 SymbolicLinkUsageCount
               );
    }
    dprintf("\n");
    dprintf("%s    Hash Address%*s  Type          Name\n", Pad, Indent64, "");
    dprintf("%s    ---- -------%*s  ----          ----\n", Pad, Indent64, "");
    for (i=0; i<NUMBER_HASH_BUCKETS; i++) {
        ULONG64 HashBucketI = 0;

        ReadPointer(HashBucketsAddress + i*HashBucketSz, &HashBucketI);
        if (HashBucketI != 0) {
            dprintf( "%s     %02u  ",
                     Pad,
                     i
                   );
            pDirectoryEntry = HashBucketI;
            while (pDirectoryEntry != 0) {
                ULONG64 ObjectE=0, Next=0;
                
                if (GetFieldValue(pDirectoryEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "Object", ObjectE)) {
                    dprintf( "Unable to read directory entry at %p\n", pDirectoryEntry );
                    break;
                }

                if (pDirectoryEntry != HashBucketI) {
                    dprintf( "%s         ", Pad );
                }
                dprintf( "%p", ObjectE );

                if (!GetObjectInfo( ObjectE, &ObjectInfo)) {
                    dprintf( " - %s\n", ObjectInfo.Message );
                } else {

                    //
                    // !object \ObjectTypes shows WindowStation is longest
                    // object type name with 13 chars
                    //
                    dprintf( " %-13ws %ws\n", ObjectInfo.TypeName, ObjectInfo.ObjectName );
                }

                GetFieldValue(pDirectoryEntry, "nt!_OBJECT_DIRECTORY_ENTRY", "ChainLink", Next);
                pDirectoryEntry = Next;
            }
        }
    }
}

VOID
DumpSymbolicLinkObject(
                      IN char     *Pad,
                      IN ULONG64   Object,
                      OPTIONAL OUT PCHAR TargetString,
                      IN ULONG     TargetStringSize
                      )
{
    ULONG Result, i;
    ULONG64              pSymbolicLinkObject = Object;
    PWSTR s, FreeBuffer;
    ULONG Length;
    ULONG64 TargetBuffer=0, DosDeviceDriveIndex=0, LinkTargetObject=0;



    if (GetFieldValue(pSymbolicLinkObject, "nt!_OBJECT_SYMBOLIC_LINK", "LinkTarget.Length", Length)) {
        dprintf( "Unable to read symbolic link object at %p\n", Object );
        return;
    }

    if (Length > 0x1000) // sanity check
    {
        Length = 0x1000;
    }
    GetFieldValue(pSymbolicLinkObject, "nt!_OBJECT_SYMBOLIC_LINK", "LinkTarget.Buffer", TargetBuffer);
    GetFieldValue(pSymbolicLinkObject, "nt!_OBJECT_SYMBOLIC_LINK", "DosDeviceDriveIndex" , DosDeviceDriveIndex);
    GetFieldValue(pSymbolicLinkObject, "nt!_OBJECT_SYMBOLIC_LINK", "LinkTargetObject", LinkTargetObject);

    FreeBuffer = s = HeapAlloc( GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                Length + sizeof( UNICODE_NULL )
                              );
    if (s == NULL ||
        !ReadMemory( TargetBuffer,
                     s,
                     Length,
                     &Result
                   )
       ) {
        s = L"*** target string unavailable ***";
    }
    dprintf( "%s    Target String is '%ws'\n",
             Pad,
             s
           );
    if (TargetString && (TargetStringSize > wcslen(s))) {
        sprintf(TargetString, "%ws", s);
    }

    if (FreeBuffer != NULL) {
        HeapFree( GetProcessHeap(), 0, FreeBuffer );
    }


    if (DosDeviceDriveIndex != 0) {
        dprintf( "%s    Drive Letter Index is %I64u (%c:)\n",
                 Pad,
                 DosDeviceDriveIndex,
                 'A' + DosDeviceDriveIndex - 1
               );
    }
    if (LinkTargetObject != 0) {
        GetFieldValue(pSymbolicLinkObject, "_OBJECT_SYMBOLIC_LINK", "LinkTargetRemaining.Length", Length);

        if (Length > 0x1000) // sanity check
        {
            Length = 0x1000;
        }
        FreeBuffer = s = HeapAlloc( GetProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    Length + sizeof( UNICODE_NULL )
                                  );
        GetFieldValue(pSymbolicLinkObject, "_OBJECT_SYMBOLIC_LINK", "LinkTargetRemaining.Buffer", TargetBuffer);
        
        if (s == NULL ||
            !ReadMemory( TargetBuffer,
                         s,
                         Length,
                         &Result
                       )
           ) {
            s = L"*** remaining name unavailable ***";
        }
        dprintf( "%s    Snapped to Object %p '%ws'\n",
                 Pad,
                 LinkTargetObject,
                 s
               );

        if (FreeBuffer != NULL) {
            HeapFree( GetProcessHeap(), 0, FreeBuffer );
        }
    }

    return;
}


BOOLEAN
DumpObject(
          IN char     *Pad,
          IN ULONG64  Object,
          IN ULONG    Flags
          )
{
    OBJECT_INFO ObjectInfo;

    if (!GetObjectInfo(Object, &ObjectInfo)) {
        dprintf( "%s\n", ObjectInfo.Message );
        return FALSE;
    }
    dprintf( "Object: %08p  Type: (%08p) %ws\n",
             Object,
             ObjectInfo.ObjectHeader.Type,
             ObjectInfo.TypeName
           );
    dprintf( "    ObjectHeader: %08p\n",
             ObjectInfo.pObjectHeader
           );

    if (!(Flags & 0x1)) {
        return TRUE;
    }

    dprintf( "%s    HandleCount: %u  PointerCount: %u\n",
             Pad,
             ObjectInfo.ObjectHeader.HandleCount,
             ObjectInfo.ObjectHeader.PointerCount
           );

    if (ObjectInfo.ObjectName[ 0 ] != UNICODE_NULL ||
        ObjectInfo.NameInfo.Directory != 0
       ) {
        dprintf( "%s    Directory Object: %08p  Name: %ws",
                 Pad,
                 ObjectInfo.NameInfo.Directory,
                 ObjectInfo.ObjectName
               );
        if (ObjectInfo.FileSystemName[0] != UNICODE_NULL) {
            dprintf( " {%ws}\n", ObjectInfo.FileSystemName );
        } else {
            dprintf( "\n" );
        }
    }

    if ((Flags & 0x8)) {
        if (!wcscmp( ObjectInfo.TypeName, L"Directory" )) {
            DumpDirectoryObject( Pad, Object );
        } else if (!wcscmp( ObjectInfo.TypeName, L"SymbolicLink" )) {
            DumpSymbolicLinkObject( Pad, Object, NULL, 0 );
        }
    }

    return TRUE;
}


PWSTR
GetObjectName(
             ULONG64 Object
             )
{
    ULONG            Result;
    ULONG64          pObjectHeader;
    UNICODE_STRING64 ObjectName={0};

    ULONG64          pNameInfo;
    ULONG            NameInfoOffset=0;
    ULONG64          Type=0;
    ULONG            BodyOffset;

    if (GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset)) {
        return NULL;
    }
    
    pObjectHeader = Object - BodyOffset;
    
    if (GetFieldValue(pObjectHeader, "nt!_OBJECT_HEADER", "Type", Type) || 
        GetFieldValue(pObjectHeader, "nt!_OBJECT_HEADER", "NameInfoOffset", NameInfoOffset)) {
        if (Object >= HighestUserAddress && (ULONG)Object < 0xF0000000) {
            swprintf( ObjectNameBuffer, L"(%08I64lx: object is paged out)", UNEXTEND64(Object) );
            return ObjectNameBuffer;
        } else {
            swprintf( ObjectNameBuffer, L"(%08I64lx: invalid object header)", UNEXTEND64(Object) );
            return ObjectNameBuffer;
        }
    }

    pNameInfo =  NameInfoOffset ? (pObjectHeader - NameInfoOffset) : 0;
    if (pNameInfo == 0) {
        dprintf("NameInfoOffset not found for _OBJECT_HEADER at %p\n", pObjectHeader);
        return NULL;
    }

    if (GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Length", ObjectName.Length) || 
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", ObjectName.Buffer) || 
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.MaximumLength", ObjectName.MaximumLength)) {
        dprintf( "%08p: Unable to read object name info\n", pNameInfo );
        return NULL;
    }

    if (ObjectName.Length == 0 || ObjectName.Buffer == 0) {
        return NULL;
    }

    if (ObjectName.Length >= sizeof(ObjectNameBuffer) ) {
        ObjectName.Length = sizeof(ObjectNameBuffer) - sizeof(WCHAR);
    }

    if ( !ReadMemory( ObjectName.Buffer,
                      ObjectNameBuffer,
                      ObjectName.Length,
                      &Result) ) {
        swprintf( ObjectNameBuffer, L"(%08lx: name not accessable)", ObjectName.Buffer );
    } else {
        ObjectNameBuffer[ ( ObjectName.Length / sizeof( WCHAR ) ) ] = UNICODE_NULL;
    }

    return ObjectNameBuffer;
}



BOOLEAN
WalkObjectsByType(
                 IN PUCHAR               ObjectTypeName,
                 IN ENUM_TYPE_ROUTINE    EnumRoutine,
                 IN PVOID                Parameter
                 )
{
    ULONG        Result;
    LIST_ENTRY64 ListEntry;
    ULONG64      Head,   Next;
    ULONG64      pObjectHeader;
    ULONG64      pObjectType;
    BOOLEAN      WalkingBackwards;
    ULONG64      pCreatorInfo;
    ULONG        TotalNumberOfObjects=0;
    ULONG        TypeListOffset=0;
    ULONG        CreatorTypeListOffset=0, CreatorTypeSizeHeader = 0;
    ULONG64      Flink=0, TypeList_Flink=0, TypeList_Blink=0;

    if (GetFieldOffset("nt!_OBJECT_TYPE", "TypeList", &TypeListOffset)) {
       return FALSE;
    }

    pObjectType = FindObjectType( ObjectTypeName );
    if (pObjectType == 0) {
        dprintf( "*** unable to find '%s' object type.\n", ObjectTypeName );
        return FALSE;
    }

    if (GetFieldValue(pObjectType, "nt!_OBJECT_TYPE", "TypeList.Flink", Flink)) {
        dprintf( "%08lx: Unable to read object type\n", pObjectType );
        return FALSE;
    }
    GetFieldValue(pObjectType, "nt!_OBJECT_TYPE", "TypeList.Blink", TypeList_Blink);
    GetFieldValue(pObjectType, "nt!_OBJECT_TYPE", "TypeList.Flink", TypeList_Flink);
    GetFieldValue(pObjectType, "nt!_OBJECT_TYPE", "TotalNumberOfObjects", TotalNumberOfObjects);

    dprintf( "Scanning %u objects of type '%s'\n", TotalNumberOfObjects & 0x00FFFFFF, ObjectTypeName );

    Head        = pObjectType + TypeListOffset;
    ListEntry.Flink   = TypeList_Flink;
    ListEntry.Blink   = TypeList_Blink;
    Next        = Flink;
    WalkingBackwards = FALSE;

    if ((TotalNumberOfObjects & 0x00FFFFFF) != 0 && Next == Head) {
        dprintf( "*** objects of the same type are only linked together if the %x flag is set in NtGlobalFlags\n",
                 FLG_MAINTAIN_OBJECT_TYPELIST
               );
        return TRUE;
    }

    if (GetFieldOffset("nt!_OBJECT_HEADER_CREATOR_INFO", "TypeList", &CreatorTypeListOffset)) {
        return FALSE;
    }
    CreatorTypeSizeHeader = GetTypeSize("nt!_OBJECT_HEADER_CREATOR_INFO");

    while (Next != Head) {

        if ( GetFieldValue(Next, "nt!_LIST_ENTRY", "Blink", ListEntry.Blink) ||
             GetFieldValue(Next, "nt!_LIST_ENTRY", "Flink", ListEntry.Flink)) {

            if (WalkingBackwards) {
                dprintf( "%08p: Unable to read object type list\n", Next );
                return FALSE;
            }

            //
            //  Switch to walk in reverse direction
            //

            WalkingBackwards = TRUE ;
            Next = TypeList_Blink;
            dprintf( "%08p: Switch to walking backwards\n", Next );

            continue;
        }

        pCreatorInfo = Next - CreatorTypeListOffset; //  CONTAINING_RECORD( Next, OBJECT_HEADER_CREATOR_INFO, TypeList );
        pObjectHeader = pCreatorInfo + CreatorTypeSizeHeader;

        if ( GetFieldValue( pObjectHeader,"nt!OBJECT_HEADER","Flags", Result) ) {

            dprintf( "%08p: Not a valid object header\n", pObjectHeader );
            return FALSE;
        }

        if ( !(Result & OB_FLAG_CREATOR_INFO) )
        {
            dprintf("WARNING: Object header %p flag (%hx) does not have OB_FLAG_CREATOR_INFO (%hx) set\n",
                     pObjectHeader,
                     Result,
                     OB_FLAG_CREATOR_INFO);
            return FALSE;
        }

        //
        // Not reading the objectheader as before, just pass the address
        //

        if (!(EnumRoutine)( pObjectHeader, Parameter )) {
            return FALSE;
        }

        if ( CheckControlC() ) {
            return FALSE;
        }

        if (WalkingBackwards) {
            Next = ListEntry.Blink;
        } else {
            Next = ListEntry.Flink;
        }
    }

    return TRUE;
}

BOOLEAN
CaptureObjectName(
                 IN ULONG64          pObjectHeader,
                 IN PWSTR            Buffer,
                 IN ULONG            BufferSize
                 )
{
    ULONG Result;
    PWSTR s1 = L"*** unable to get object name";
    PWSTR s = &Buffer[ BufferSize ];
    ULONG n = BufferSize * sizeof( WCHAR );
    ULONG64                     pNameInfo;
    ULONG64                     pObjectDirectoryHeader = 0;
    ULONG64                     ObjectDirectory;
    UNICODE_STRING64            Name;
    ULONG                       BodyOffset;
    
    Buffer[ 0 ] = UNICODE_NULL;
    KD_OBJECT_HEADER_TO_NAME_INFO( pObjectHeader, &pNameInfo );
    if (pNameInfo == 0) {
        return TRUE;
    }

    if ( GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", Name.Buffer)) {
        wcscpy( Buffer, s1 );
        return FALSE;
    }
    GetFieldValue(pNameInfo, "_OBJECT_HEADER_NAME_INFO", "Name.Length", Name.Length);
    GetFieldValue(pNameInfo, "_OBJECT_HEADER_NAME_INFO", "Name.MaximumLength", Name.MaximumLength);

    if (Name.Length == 0) {
        return TRUE;
    }

    if (Name.Length > (ULONG64) (s - Buffer)) {
        if (Name.Length > 1024) {
            wsprintfW(Buffer, L"*** Bad object Name length for ObjHdr at %I64lx", UNEXTEND64(pObjectHeader));
            return FALSE;
        }
        Name.Length = (USHORT) (ULONG64) (s - Buffer);
    }
    
    *--s = UNICODE_NULL;
    s = (PWCH)((PCH)s - Name.Length);

    if ( !ReadMemory( Name.Buffer,
                      s,
                      Name.Length,
                      &Result) ) {
        wcscpy( Buffer, s1 );
        return FALSE;
    }

    GetFieldValue(pNameInfo, "_OBJECT_HEADER_NAME_INFO", "Directory", ObjectDirectory);
    while ((ObjectDirectory != ObpRootDirectoryObject) && (ObjectDirectory)) {

        pObjectDirectoryHeader = KD_OBJECT_TO_OBJECT_HEADER(ObjectDirectory);
        
        KD_OBJECT_HEADER_TO_NAME_INFO( pObjectDirectoryHeader, &pNameInfo );

        if ( GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", Name.Buffer)) {
            wcscpy( Buffer, s1 );
            return FALSE;
        }
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Length", Name.Length);
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.MaximumLength", Name.MaximumLength);

        if (Name.Length > (ULONG64) (s - Buffer)) {
            if (Name.Length > 1024) {
                wsprintfW(Buffer, L"*** Bad object Name length for ObjHdr at %I64lx", UNEXTEND64(pObjectDirectoryHeader));
                return FALSE;
            }
            Name.Length = (USHORT) (ULONG64) (s - Buffer);
        }
        *--s = OBJ_NAME_PATH_SEPARATOR;
        s = (PWCH)((PCH)s - Name.Length);
        if ( !ReadMemory( Name.Buffer,
                          s,
                          Name.Length,
                          &Result) ) {
            wcscpy( Buffer, s1 );
            return FALSE;
        }

        ObjectDirectory = 0;
        GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Directory", ObjectDirectory);

        if ( CheckControlC() ) {
            return FALSE;
        }
    }
    *--s = OBJ_NAME_PATH_SEPARATOR;

    wcscpy( Buffer, s );
    return TRUE;
}

/////////////////////////////////////////////////////////////
static BOOL
ReadStructFieldVerbose( ULONG64 AddrStructBase,
                        PCHAR StructTypeName,
                        PCHAR StructFieldName,
                        PVOID Buffer,
                        ULONG BufferSize )
{
    ULONG FieldOffset;
    ULONG ErrorCode;
    BOOL Success;

    Success = FALSE;

    //
    // Get the field offset
    //

    ErrorCode = GetFieldOffset (StructTypeName,
                                StructFieldName,
                                &FieldOffset );

    if (ErrorCode == S_OK) {

        //
        // Read the data
        //

        Success = ReadMemory (AddrStructBase + FieldOffset,
                              Buffer,
                              BufferSize,
                              NULL );

        if (Success != TRUE) {

            dprintf ("ERROR: Cannot read structure field value at 0x%p, error %u\n",
                     AddrStructBase + FieldOffset,
                     ErrorCode );
        }
    }
    else {

        dprintf ("ERROR: Cannot get field offset of %s in %s, error %u\n",
                 StructFieldName,
                 StructTypeName,
                 ErrorCode );
    }

    return Success;
}

/////////////////////////////////////////////////////////////
static BOOL
ReadPtrStructFieldVerbose( ULONG64 AddrStructBase,
                           PCHAR StructTypeName,
                           PCHAR StructFieldName,
                           PULONG64 Buffer )
{
    ULONG FieldOffset;
    ULONG ErrorCode;
    BOOL Success;

    Success = FALSE;

    //
    // Get the field offset inside the structure 
    //

    ErrorCode = GetFieldOffset (StructTypeName,
                                StructFieldName,
                                &FieldOffset );

    if (ErrorCode == S_OK) {

        //
        // Read the data
        //

        ErrorCode = ReadPtr (AddrStructBase + FieldOffset,
                             Buffer );

        if (ErrorCode != S_OK) {

            dprintf ("ERROR: Cannot read structure field value at 0x%p, error %u\n",
                     AddrStructBase + FieldOffset,
                     ErrorCode );
        }
        else {

            Success = TRUE;
        }
    }
    else {

        dprintf ("ERROR: Cannot get field offset of %s in structure %s, error %u\n",
                 StructFieldName,
                 StructTypeName,
                 ErrorCode );
    }

    return Success;
}

/////////////////////////////////////////////////////////////
static BOOL
DumpStackTrace (ULONG64 PointerAddress,
                ULONG MaxStackTraceDepth,
                ULONG PointerSize)
{
    ULONG64 CodePointer;
    ULONG64 Displacement;
    ULONG StackTraceDepth;
    ULONG ErrorCode;
    BOOL Continue;
    char Symbol[ 1024 ];

    Continue = TRUE;

    for (StackTraceDepth = 0; StackTraceDepth < MaxStackTraceDepth; StackTraceDepth += 1) {

        if (CheckControlC()) {

            Continue = FALSE;
            goto Done;
        }

        ErrorCode = ReadPtr (PointerAddress,
                             &CodePointer );

        if (ErrorCode != S_OK) {

            dprintf ("ERROR: Cannot read address at 0x%p, error %u\n",
                     PointerAddress,
                     ErrorCode );
        }
        else {

            if( CodePointer == 0 ) {

                //
                // End of stack trace
                //
                
                goto Done;
            }

            GetSymbol (CodePointer,
                       Symbol,
                       &Displacement);

            dprintf ("0x%p: %s+0x%I64X\n",
                     CodePointer,
                     Symbol,
                     Displacement );
        }

        PointerAddress += PointerSize;
    }

Done:

    return Continue;
}

/////////////////////////////////////////////////////////////
static BOOL
DumpHandleTraceEntry (ULONG64 TraceDbEntry,
                      ULONG64 Handle,
                      ULONG64 NullHandleEntry,
                      ULONG StackTraceFieldOffset,
                      ULONG MaxStackTraceDepth,
                      ULONG PointerSize,
                      PULONG EntriesDisplayed)
{
    ULONG64 EntryHandle;
    ULONG Type;
    BOOL Success;
    BOOL Continue;

#ifndef HANDLE_TRACE_DB_OPEN
#define HANDLE_TRACE_DB_OPEN   1
#endif

#ifndef HANDLE_TRACE_DB_CLOSE
#define HANDLE_TRACE_DB_CLOSE  2
#endif

#ifndef HANDLE_TRACE_DB_BADREF
#define HANDLE_TRACE_DB_BADREF 3
#endif

    Continue = TRUE;

    //
    // Read the handle of this entry
    //

    Success = ReadPtrStructFieldVerbose (TraceDbEntry,
                                         "nt!_HANDLE_TRACE_DB_ENTRY",
                                         "Handle",
                                         &EntryHandle );

    if (Success == FALSE) {

        dprintf ("ERROR: Cannot read handle for trace database entry at 0x%p.\n",
                 TraceDbEntry );
        goto Done;
    }

    //
    // Read the operation type
    //

    Success = ReadStructFieldVerbose (TraceDbEntry,
                                      "nt!_HANDLE_TRACE_DB_ENTRY",
                                      "Type",
                                      &Type,
                                      sizeof( Type ) );

    if (Success == FALSE) {

        dprintf ("ERROR: Cannot read operation type for trace database entry at 0x%p.\n",
                 TraceDbEntry );
        goto Done;
    }

    if (EntryHandle == 0 && Type == 0 && TraceDbEntry != NullHandleEntry) {

        //
        // We are done parsing the database.
        //

        Continue = FALSE;

        goto Done;
    }

    //
    // Check if we need to dump this entry.
    //

    if (Handle == 0 || Handle == EntryHandle) {


        *EntriesDisplayed += 1;

        dprintf( "--------------------------------------\n"
                 "Handle 0x%I64X - ",
                 EntryHandle );

        switch( Type ) {

        case HANDLE_TRACE_DB_OPEN:
            dprintf( "OPEN:\n" );
            break;

        case HANDLE_TRACE_DB_CLOSE:
            dprintf( "CLOSE:\n" );
            break;

        case HANDLE_TRACE_DB_BADREF:
            dprintf( "*** BAD REFERENCE ***:\n" );
            break;

        default:

            dprintf( "ERROR: Invalid operation type for database entry at 0x%p\n",
                     TraceDbEntry );

            Continue = FALSE;

            goto Done;
        }

        Continue = DumpStackTrace (TraceDbEntry + StackTraceFieldOffset,
                                   MaxStackTraceDepth,
                                   PointerSize );
    }

Done:

    return Continue;
}

/////////////////////////////////////////////////////////////
static VOID
DumpHandleTraces (ULONG64 Process,
                  ULONG64 Handle)
{
    ULONG64 ObjectTable;
    ULONG64 DebugInfo;
    ULONG64 TraceDbEntry;
    ULONG64 FirstDbEntry;
    ULONG SizeofDbEntry;
    ULONG CurrentStackIndex;
    ULONG SizeofDebugInfo;
    ULONG TraceDbFieldOffset;
    ULONG EntriesInTraceDb;
    ULONG EntriesParsed;
    ULONG StackTraceFieldOffset;
    ULONG MaxStackTraceDepth;
    ULONG PointerTypeSize;
    ULONG ErrorCode;
    ULONG EntriesDisplayed;
    BOOL Success;
    BOOL Continue;

    EntriesParsed = 0;
    EntriesDisplayed = 0;

    //
    // Get the pointer type size 
    //

    PointerTypeSize = GetTypeSize ("nt!PVOID");

    if (PointerTypeSize == 0) {

        dprintf ("ERROR: Cannot get the pointer size.\n");
        goto Done;
    }

    //
    // Read the address of the object table structure
    //

    Success = ReadPtrStructFieldVerbose (Process,
                                         "nt!_EPROCESS",
                                         "ObjectTable",
                                         &ObjectTable);

    if (Success == FALSE) {

        dprintf ("ERROR: Cannot read process object table address.\n");
        goto Done;
    }
    else {

        dprintf ("ObjectTable 0x%p\n\n",
                 ObjectTable );
    }

    //
    // Read the DebugInfo from the handle table structure
    //

    Success = ReadPtrStructFieldVerbose (ObjectTable,
                                         "nt!_HANDLE_TABLE",
                                         "DebugInfo",
                                         &DebugInfo );

    if (Success == FALSE) {

        dprintf( "ERROR: Cannot read object table debug information.\n" );
        goto Done;
    }

    if (DebugInfo == 0) {

        dprintf( "Trace information is not enabled for this process.\n" );
        goto Done;
    }

    //
    // Get the current index in the trace database
    //

    Success = ReadStructFieldVerbose (DebugInfo,
                                      "nt!_HANDLE_TRACE_DEBUG_INFO",
                                      "CurrentStackIndex",
                                      &CurrentStackIndex,
                                      sizeof( CurrentStackIndex ) );

    if (Success == FALSE) {

        dprintf( "ERROR: Cannot read the current index of the trace database.\n" );
        goto Done;
    }

    //
    // Get the size of the HANDLE_TRACE_DB_ENTRY type
    //

    SizeofDbEntry = GetTypeSize ("nt!HANDLE_TRACE_DB_ENTRY");

    if (SizeofDbEntry == 0) {

        dprintf ("Cannot get the size of the trace database entry structure\n");
        goto Done;
    }

    //
    // Get the max number of entries in the StackTrace array inside HANDLE_TRACE_DB_ENTRY
    //

    ErrorCode = GetFieldOffset ("nt!_HANDLE_TRACE_DB_ENTRY",
                                "StackTrace",
                                &StackTraceFieldOffset);

    if (ErrorCode != S_OK) {
        
        dprintf ("Cannot get StackTrace field offset.\n");
        goto Done;
    }

    MaxStackTraceDepth = (SizeofDbEntry - StackTraceFieldOffset) / PointerTypeSize;

    //
    // Get the size of the HANDLE_TRACE_DEBUG_INFO type
    //

    SizeofDebugInfo = GetTypeSize ("nt!HANDLE_TRACE_DEBUG_INFO");

    if (SizeofDebugInfo == 0) {

        dprintf ("ERROR: Cannot get the size of the debug info structure\n");
        goto Done;
    }

    //
    // Get the offset of TraceDb inside the _HANDLE_TRACE_DEBUG_INFO structure
    //

    ErrorCode = GetFieldOffset ("nt!_HANDLE_TRACE_DEBUG_INFO",
                                "TraceDb",
                                &TraceDbFieldOffset);

    if (ErrorCode != S_OK) {
        
        dprintf ("ERROR: Cannot get TraceDb field offset.\n");
        goto Done;
    }

    //
    // Compute the number of entries in the TraceDb array
    //

    EntriesInTraceDb = (SizeofDebugInfo - TraceDbFieldOffset) / SizeofDbEntry;

    if (EntriesInTraceDb == 0) {

        dprintf ("ERROR: zero entries in the trace database.\n");
        goto Done;
    }

    CurrentStackIndex = CurrentStackIndex % EntriesInTraceDb;

    //
    // Compute a pointer to the current stack trace database entry 
    //

    FirstDbEntry = DebugInfo + TraceDbFieldOffset;

    TraceDbEntry = FirstDbEntry + CurrentStackIndex * SizeofDbEntry;

    //
    // Dump all the valid entries in the array
    //

    EntriesDisplayed = 0;

    for (EntriesParsed = 0; EntriesParsed < EntriesInTraceDb; EntriesParsed += 1) {

        if (CheckControlC()) {

            goto Done;
        }

        //
        // The first entry in the array is never used so skip it
        //

        if (EntriesParsed != CurrentStackIndex) {


            Continue = DumpHandleTraceEntry( TraceDbEntry,
                                             Handle,
                                             FirstDbEntry,
                                             StackTraceFieldOffset,
                                             MaxStackTraceDepth,
                                             PointerTypeSize,
                                             &EntriesDisplayed );

            if (Continue == FALSE) {

                //
                // This current entry is free or the user pressed Ctrl-C 
                // so we don't have any entries left to dump.
                //

                EntriesParsed += 1;

                break;
            }

            //
            // Go backward
            //

            TraceDbEntry -= SizeofDbEntry;
        }
        else {

            //
            // We should be at the beginning of the array
            //

            if( TraceDbEntry != FirstDbEntry ) {


                dprintf ("ERROR: 0x%p should be the beginning of the traces array 0x%p\n",
                         TraceDbEntry,
                         FirstDbEntry);
                goto Done;
            }

            //
            // Start over again with the last entry in the array
            //

            TraceDbEntry = DebugInfo + TraceDbFieldOffset + ( EntriesInTraceDb - 1 ) * SizeofDbEntry;
        }
    }

Done:

    dprintf ("\n--------------------------------------\n"
            "Parsed 0x%X stack traces.\n"
            "Dumped 0x%X stack traces.\n",
            EntriesParsed,
            EntriesDisplayed);

    NOTHING;
}

/////////////////////////////////////////////////////////////
DECLARE_API( htrace )

/*++

Routine Description:

    Dump the trace information for a handle

Arguments:

    args - [process] [handle]

Return Value:

    None

--*/
{
    ULONG64 Handle;
    ULONG64 Process;
    ULONG CurrentProcessor;

    //
    // Did the user ask for help?
    //

    if(strcmp( args, "-?" ) == 0 || 
       strcmp( args, "?" ) == 0 || 
       strcmp( args, "-h" ) == 0) {

        dprintf( "\n!htrace [ handle [process] ]    - dump handle tracing information.\n" );
        goto Done;
    }


    Handle = 0;
    Process = 0;

    //
    // Get the current processor number
    //

    if (!GetCurrentProcessor(Client, &CurrentProcessor, NULL)) {
        CurrentProcessor = 0;
    }

    //
    // Did the user specify a process and a handle?
    //

    GetExpressionEx(args, &Handle, &args);
    if (args && *args)
    {
        GetExpressionEx(args, &Process, &args);
    }

    if (Process == 0) {

        GetCurrentProcessAddr( CurrentProcessor, 0, &Process );

        if (Process == 0) {

            dprintf ("Cannot get current process address\n"); 
            goto Done;
        }
        else {

            dprintf( "Process 0x%p\n",
                     Process );
        }
    }
    else {

        dprintf ("Process 0x%p\n",
                 Process );
    }

    DumpHandleTraces (Process,
                      Handle);

Done:

    return S_OK;
}


DECLARE_API( driveinfo )
{
    CHAR VolumeName[100];
    CHAR ObjectName[100];
    ULONG i=0;
    ULONG64 Object;
    CHAR targetVolume[100]={0};
    ULONG64 DevObjVPB;
    ULONG64 VpbDevice;
    ULONG64 DriverObject;
    ULONG64 DrvNameAddr;
    OBJECT_INFO ObjectInfo;
    WCHAR FileSystem[100]={0};
    PWSTR FsType;
    ULONG NameLen;
    ULONG result;

    while (*args == ' ') ++args;

    while (*args && *args != ' ' && i < sizeof(VolumeName)) {
        VolumeName[i++] = *args++;
    }
    if (!i) {
        dprintf("Usage :  !driveinfo <drive-name>[:]\n");
        return E_INVALIDARG;
    }
    if (VolumeName[i-1] == ':') {
        --i;
    }
    VolumeName[i]=0;


    // Build Object name
    strcpy(ObjectName, "\\global\?\?\\");
    if ((StringCchCat(ObjectName, sizeof(ObjectName), VolumeName) != S_OK) ||
        (StringCchCat(ObjectName, sizeof(ObjectName), ":") != S_OK))
    {
        Object = 0;
    } else
    {
        // GetObject info

        Object = FindObjectByName((PUCHAR) ObjectName, 0);
    }


    if (!Object) {
        dprintf("Drive object not found for %s\n", ObjectName);
        return E_FAIL;
    }
    dprintf("Drive %s:, DriveObject %p\n", VolumeName, Object);

    if (!GetObjectInfo(Object, &ObjectInfo)) {
        dprintf( "%s\n", ObjectInfo.Message );
        return E_FAIL;
    }

    if (ObjectInfo.ObjectName[ 0 ] != UNICODE_NULL ||
        ObjectInfo.NameInfo.Directory != 0
        ) {
        dprintf( "    Directory Object: %08p  Name: %ws",
                 ObjectInfo.NameInfo.Directory,
                 ObjectInfo.ObjectName
                 );
        if (ObjectInfo.FileSystemName[0] != UNICODE_NULL) {
            dprintf( " {%ws}\n", ObjectInfo.FileSystemName );
        } else {
            dprintf( "\n" );
        }
    }

    if (!wcscmp( ObjectInfo.TypeName, L"SymbolicLink" )) {
        DumpSymbolicLinkObject( "    ", Object, targetVolume, sizeof(targetVolume) );

    }
    
    // devobj for volume
    Object = FindObjectByName((PUCHAR) targetVolume, 0);

    if (!Object) {
        dprintf("Object not found for %s\n", targetVolume);
        return E_FAIL;
    }

    dprintf("    Volume DevObj: %p\n", Object);

    // Now get the vpb (volume parameter block) for devobj

    if (GetFieldValue(Object, "nt!_DEVICE_OBJECT", "Vpb", DevObjVPB)) {
        dprintf("Cannot get nt!_DEVICE_OBJECT.Vpb @ %p\n", DevObjVPB);
        return E_FAIL;
    }
    
    // Now find device object of VPB
    if (GetFieldValue(DevObjVPB, "nt!_VPB", "DeviceObject", VpbDevice)) {
        dprintf("Cannot get nt!_VPB.DeviceObject @ %p\n", VpbDevice);
        return E_FAIL;
    }
    dprintf("    Vpb: %p  DeviceObject: %p\n", DevObjVPB, VpbDevice);


    // Get fielsystem for VPB Device
    if (GetFieldValue(VpbDevice, "nt!_DEVICE_OBJECT", "DriverObject", DriverObject)) {
        dprintf("Error in getting _DEVICE_OBJECT.DriverObject @ %p\n", VpbDevice);
        return E_FAIL;
    }

    if (GetFieldValue(DriverObject, "nt!_DRIVER_OBJECT", "DriverName.MaximumLength", NameLen)) {
        dprintf("Cannot get driver name for %p\n", DriverObject);
        return E_FAIL;
    }
    GetFieldValue(DriverObject, "nt!_DRIVER_OBJECT", "DriverName.Buffer", DrvNameAddr);
    if (NameLen >= sizeof(FileSystem)/sizeof(WCHAR)) {
        NameLen = sizeof(FileSystem)/sizeof(WCHAR)-1;
    }
    if (!ReadMemory( DrvNameAddr,FileSystem,NameLen,&result)) {
        dprintf("Filesystem driver name paged out");
        return E_FAIL;
    }
    
    dprintf("    FileSystem: %ws\n", FileSystem);
    FsType = FileSystem + wcslen(L"\\FileSystem")+1;


    if (!wcscmp(FsType, L"Fastfat")) {
        ULONG NumberOfClusters, NumberOfFreeClusters, LogOfBytesPerSector,
            LogOfBytesPerCluster, FatIndexBitSize;
        ULONG64 ClusterSize;

        // Its a FAT system
        if (GetFieldValue(VpbDevice, 
                          "fastfat!VOLUME_DEVICE_OBJECT", 
                          "Vcb.AllocationSupport.NumberOfClusters", 
                          NumberOfClusters)) {
            dprintf("Cannot get  fastfat!VOLUME_DEVICE_OBJECT.Vcb @ %p\n", VpbDevice);
            return E_FAIL;
        }
        InitTypeRead(VpbDevice, fastfat!VOLUME_DEVICE_OBJECT);
        NumberOfFreeClusters = (ULONG) ReadField(Vcb.AllocationSupport.NumberOfFreeClusters);
        LogOfBytesPerSector = (ULONG) ReadField(Vcb.AllocationSupport.LogOfBytesPerSector);
        LogOfBytesPerCluster = (ULONG) ReadField(Vcb.AllocationSupport.LogOfBytesPerCluster);
        FatIndexBitSize = (ULONG) ReadField(Vcb.AllocationSupport.FatIndexBitSize);

        ClusterSize = (ULONG64) 1 << LogOfBytesPerCluster;
        dprintf("    Volume has 0x%lx (free) / 0x%lx (total) clusters of size 0x%I64lx\n",
                NumberOfFreeClusters, NumberOfClusters, ClusterSize);
#define _MB( Bytes ) ((double)(Bytes)/(((ULONG64)1) << 20))
        dprintf("    %I64g of %I64g MB free\n",
                _MB(NumberOfFreeClusters*ClusterSize), _MB(NumberOfClusters*ClusterSize));
    } else     if (!wcscmp(FsType, L"Ntfs")) {
        // Ntfs filesystem
        ULONG64 TotalClusters, FreeClusters, BytesPerCluster;
        if (GetFieldValue(VpbDevice, 
                          "ntfs!VOLUME_DEVICE_OBJECT", 
                          "Vcb.TotalClusters", 
                          TotalClusters)) {
            dprintf("Cannot get  ntfs!VOLUME_DEVICE_OBJECT.Vcb @ %p\n", VpbDevice);
            return E_FAIL;
        }
        InitTypeRead(VpbDevice, ntfs!VOLUME_DEVICE_OBJECT);
        FreeClusters = ReadField(Vcb.FreeClusters);
        BytesPerCluster = ReadField(Vcb.BytesPerCluster);
        dprintf("    Volume has 0x%I64lx (free) / 0x%I64lx (total) clusters of size 0x%I64lx\n",
                FreeClusters, TotalClusters, BytesPerCluster);
        dprintf("    %I64g of %I64g MB free\n",
                _MB(FreeClusters*BytesPerCluster), _MB(TotalClusters*BytesPerCluster));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\npx.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    trap.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef struct {
    ULONG   Mask;
    PUCHAR  String;
} BITENCODING, *PBITENCODING;

typedef unsigned __int64 ULONGLONG;

void  DumpNpxULongLong (PUCHAR s, ULONGLONG  l);
void  DumpNpxExtended  (PUCHAR str, PUCHAR Value);
void  DumpNpxBits      (ULONG, PUCHAR, ULONG, PBITENCODING);

PUCHAR NpxPrecisionControl[] = { "24Bits", "?1?", "53Bits", "64Bits" };
PUCHAR NpxRoundingControl[]  = { "Nearest", "Down", "Up", "Chop" };
PUCHAR NpxTagWord[]          = { "  ", "ZR", "SP", "  " };

BITENCODING NpxStatusBits[]  = {
        1 <<  8,    "C0",
        1 <<  9,    "C1",
        1 << 10,    "C2",
        1 << 14,    "C3",
        0x8000,     "Busy",
        0x0001,     "InvalidOp",
        0x0002,     "Denormal",
        0x0004,     "ZeroDivide",
        0x0008,     "Overflow",
        0x0010,     "Underflow",
        0x0020,     "Precision",
        0x0040,     "StackFault",
        0x0080,     "Summary",
        0,          0
        };

PUCHAR  NpxOpD8[] = {
        "fadd",  "fmul",  "fcom",  "fcomp",  "fsub",   "fsubr",  "fdiv",   "fdivr"
        };

PUCHAR  NpxOpD9[] = {
        "fld",   "??3",   "fst",   "fstp",   "fldenv", "fldcw",  "fstenv", "fstcw"
        };

PUCHAR  NpxOpDA[] = {
        "fiadd", "fimul", "ficom", "ficomp", "fisub",  "fisubr", "fidiv",  "fidivr"
        };

PUCHAR  NpxOpDB[] = {
        "fild",  "??4",   "fist",  "fistp",  "??5",    "fld",    "??6",    "fstp"
        };

PUCHAR  NpxOpDF[] = {
        "fild",  "??4",   "fist",  "fistp",  "fbld",   "fild",   "fbstp",  "fstp"
        };

PUCHAR *NpxSmOpTable[] = {
    NpxOpD8,
    NpxOpD9,
    NpxOpDA,
    NpxOpDB,
    NpxOpD8,    // DC
    NpxOpD9,    // DD
    NpxOpDA,    // DE
    NpxOpDF
    };






DECLARE_API( npx )

/*++

Routine Description:

    Dumps FNSAVE area format of NPX state

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64             Address;
    UCHAR               s[300], Reg[100];
    PUCHAR              Stack, p;
    ULONG               i, j, t, tos, Tag;
    ULONG               ControlWord, StatusWord;

    // X86_ONLY_API
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("!npx is X86 Only API\n");
        return E_INVALIDARG;
    }

    Address = GetExpression(args);

    if ( InitTypeRead(
            Address,
            FLOATING_SAVE_AREA)) {

        dprintf("unable to read floating save area\n");
        return  E_INVALIDARG;
    }
    ControlWord = (ULONG) ReadField(ControlWord);
    dprintf ("EIP.......: %08x  ControlWord: %s-%s mask: %02x   Cr0NpxState: %08x\n",
        (ULONG) ReadField(ErrorOffset),
        NpxPrecisionControl [(ControlWord >> 8)  & 0x3],
        NpxRoundingControl  [(ControlWord >> 10) & 0x3],
        ControlWord & 0x3f,
        (ULONG) ReadField(Cr0NpxState)
        );

    DumpNpxBits ( StatusWord = (ULONG) ReadField(StatusWord), s, sizeof(s), NpxStatusBits);
    tos = (StatusWord >> 11) & 7,

    dprintf ("StatusWord: %04x TOS:%x %s  (tagword: %04x)\n",
        StatusWord & 0xffff,
        tos,
        s,
        (ULONG) ReadField(TagWord) & 0xffff
        );

    GetFieldValue(Address, "FLOATING_SAVE_AREA", "RegisterArea", Reg);
    Stack = &Reg[0];

    Tag   = (ULONG) ReadField(TagWord);
    for (i=0; i < 8; i++) {
        j = (tos + i) & 7;
        t = (Tag >> (j*2)) & 3;

        if (t != 3) {
            sprintf (s, "%x%c%s",
                j,
                j == tos ? '>' : '.',
                NpxTagWord [t]
                );

            DumpNpxExtended (s, Stack);
        }

        Stack += 10;    // next stack location
    }

    dprintf ("\n");
    return S_OK;
}


void  DumpNpxBits (
        ULONG           Value,
        PUCHAR          Str,
        ULONG           StrSize,
        PBITENCODING    Bits
    )
{
    BOOLEAN     Flag;

    Flag = FALSE;
    *Str = 0;

    while (Bits->Mask) {
        if (Bits->Mask & Value) {
            if (Flag) {
                if (SUCCEEDED( StringCchCopy(Str, StrSize, ", ") ) )
                {
                    StrSize -=2; Str+=2;
                }
                if (StringCchCopy(Str, StrSize, Bits->String) == S_OK)
                {
                    StrSize -= strlen (Str);
                    Str += strlen (Str);
                }
            } else {
                if (StringCchCopy(Str, StrSize, Bits->String) == S_OK)
                {
                    StrSize -= strlen (Str);
                    Str += strlen (Str);
                    Flag = TRUE;
                }
            }
        }

        Bits += 1;
    }
}


void
DumpNpxULongLong (
    PUCHAR      s,
    ULONGLONG   l
    )
{
    UCHAR   c;
    UCHAR   t[80], *p;

    if (l == 0) {
        *(s++)= '0';
    }

    p = t;
    while (l) {
        c = (UCHAR) ((ULONGLONG) l % 10);
        *(p++) = c + '0';
        l /= 10;
    }

    while (p != t) {
        *(s++) = *(--p);
    }
    *(s++) = 0;
}

void
DumpNpxExtended (
    PUCHAR  str,
    PUCHAR  Value
    )
{
    UCHAR       *p, *o, c, out[100], t[100], ssig[100], ExponSign, SigSign;
    ULONG       i, indent, mag, scale;
    LONG        expon, delta;
    ULONGLONG   sig;

    p = Value;
    c = 0;
    o = out+90;
    indent = strlen (str) + 1;

    dprintf ("%s ", str);

    //
    // Build string of bits
    //

    *(--o) = 0;
    while (c < 80) {
        *(--o) = (*p & 0x01) + '0';
        *p >>= 1;
        c += 1;
        if ((c % 8) == 0) {
            p += 1;
        }
    }
    p = o;


    //dprintf (" %s\n", o);
    //dprintf ("%*s", indent, "");


    //
    // print bit string seperated into fields
    //

    p = o;
    //dprintf ("%c %15.15s 1%c%s\n", p[0], p+1, '.', p+1+15);
    //dprintf ("%*s", indent, "");

    //
    // Pull out exponent
    //

    expon = 0;
    p = o + 1;
    for (i=0; i < 15; i++) {
        expon *= 2;
        if (p[i] == '1') {
            expon += 1;
        }
    }

    expon -= 16383;                     // take out exponent bias

    //
    // Build sig into big #
    //

    p = o + 1+15;
    scale = 0;
    for (i=0; p[i]; i++) {
        if (p[i] == '1') {
            scale = i+1;
        }
    }
    SigSign = p[i-1] == '0' ? '+' : '-';

    sig = 0;
    for (i=0; i < scale; i++) {
        sig <<= 1;
        if (p[i] == '1') {
            sig += 1;
        }
    }

    delta = expon - (scale - 1);
    //dprintf ("delta %d, expon %d, scale %d\n", delta, expon, scale);

    //
    // Print values of each field
    //

    DumpNpxULongLong (ssig, sig);

    p = o;
    ExponSign = p[0] == '0' ? '+' : '-';
    dprintf ("%c %15.15s (%+5d) %c%c%s\n",
        ExponSign,
        p + 1,
        expon,
        p[1+15], '.', p+1+15+1
        );
    dprintf ("%*s", indent, "");

    if (expon == -16383) {
        if (SigSign == '+') {
            dprintf ("Denormal\n\n");
        } else {
            dprintf ("Pseudodenormal\n\n");
        }
        return ;
    }

    if (expon == 1024) {
        if (scale == 1) {
            dprintf ("%c Infinity\n", ExponSign);
        } else {

            p = o + 1+15;
            c = 0;
            for (i=0; p[i]; i++) {
                if (p[i] == '1') {
                    c++;
                }
            }

            if (SigSign == '+') {
                dprintf ("Signaling NaN\n");
            } else {
                if (c == 1) {
                    dprintf ("Indefinite - quite NaN\n");
                } else {
                    dprintf ("Quite NaN\n");
                }
            }
        }

        dprintf ("%*s", indent, "");
    }


    //dprintf ("%*s%c %15d %s    (delta %d)\n",
    //    indent, "",                     // indent
    //    p[0]    == '0' ? '+' : '-',     // sign of exponent
    //    expon, ssig,
    //    delta
    //    );
    //dprintf ("%*s", indent, "");

    t[0] = 0;
    p = t;
    if (delta < 0) {
        p += sprintf (p, "/ ");
        delta = -delta;
    } else if (delta > 0) {
        p += sprintf (p, "* ");
    }

    if (delta) {
        if (delta < 31) {
            p += sprintf (p, "%d", 1 << delta);
        } else {
            p += sprintf (p, "2^%d", delta);
        }
    }

    dprintf ("%s %s\n",
        ssig,
        t
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\mtrr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    mtrr.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 06-June-1994

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

ULONG
FindFirstSetRightBit (
    IN ULONGLONG    Set
    );

ULONGLONG
MaskToLength (
    IN ULONGLONG    Mask
    );

//
// MTRR MSR architecture definitions
//

#define MTRR_MSR_CAPABILITIES       0x0fe
#define MTRR_MSR_DEFAULT            0x2ff
#define MTRR_MSR_VARIABLE_BASE      0x200
#define MTRR_MSR_VARIABLE_MASK     (MTRR_MSR_VARIABLE_BASE+1)

#define MTRR_PAGE_SIZE              4096
#define MTRR_PAGE_MASK              (MTRR_PAGE_SIZE-1)

//
// Memory range types
//

#define MTRR_TYPE_UC            0
#define MTRR_TYPE_USWC          1
#define MTRR_TYPE_WT            4
#define MTRR_TYPE_WP            5
#define MTRR_TYPE_WB            6
#define MTRR_TYPE_MAX           7


// #include "pshpack1.h"

typedef struct _MTRR_CAPABILITIES {
    union {
        struct {
            ULONG VarCnt:8;
            ULONG FixSupported:1;
            ULONG Reserved_0:1;
            ULONG UswcSupported:1;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_CAPABILITIES;


typedef struct _MTRR_DEFAULT {
    union {
        struct {
            ULONG Type:8;
            ULONG Reserved_0:2;
            ULONG FixedEnabled:1;
            ULONG MtrrEnabled:1;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_DEFAULT;

typedef struct _MTRR_VARIABLE_BASE {
    union {
        struct {
            ULONGLONG   Type:8;
            ULONGLONG   Reserved_0:4;
            ULONGLONG   PhysBase:52;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_BASE;

#define MTRR_MASK_BASE  (~0xfff)

typedef struct _MTRR_VARIABLE_MASK {
    union {
        struct {
            ULONGLONG   Reserved_0:11;
            ULONGLONG   Valid:1;
            ULONGLONG   PhysMask:52;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_MASK;

#define MTRR_MASK_MASK  (~0xfff)

// Added support for Mask2Length conversion
#define MTRR_MAX_RANGE_SHIFT    36
#define MASK_OVERFLOW_MASK  (~0x1000000000)

CCHAR FindFirstSetRight[256] = {
        0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};


// #include "poppack.h"

//
// ----------------------------------------------------------------
//

PUCHAR
MtrrType (
    IN ULONG    Type
    )
{
    PUCHAR  p;
    static  UCHAR s[20];

    switch (Type) {
        case 0:     p = "UC";     break;
        case 1:     p = "USWC";     break;
        case 4:     p = "WT";     break;
        case 5:     p = "WP";     break;
        case 6:     p = "WB";     break;
        default:
            sprintf (s, "%02x??", Type & 0xff);
            p = s;
            break;
    }
    return p;
}

VOID
MtrrDumpFixed (
    IN ULONG    Base,
    IN ULONG    Size,
    IN ULONG    Msr
    )
{
    ULONG       x;
    ULONGLONG   li;

    ReadMsr(Msr, &li);

    for (x=0; x < 8; x++) {
        dprintf ("%s:%05x-%05x  ",
            MtrrType ( ((ULONG) li) & 0xff ),
            Base,
            Base + Size - 1
            );

        li >>= 8;
        Base += Size;

        if (x == 3) {
            dprintf ("\n");
        }
    }

    dprintf ("\n");
}


#define KF_MTRR             0x00000040

DECLARE_API( mtrr )

/*++

Routine Description:

    Dumps processors mtrr

Arguments:

    args - none

Return Value:

    None

--*/
{
    MTRR_CAPABILITIES   Capabilities;
    MTRR_DEFAULT        Default;
    MTRR_VARIABLE_BASE  Base;
    MTRR_VARIABLE_MASK  Mask;
    ULONG               Index;
    ULONG               i;
    PUCHAR              p;
    ULONG               fb;
    ULONG64             addr=0;
    ULONGLONG           Length, MtrrBase, MtrrMask;
    BOOL                ContiguousLength = TRUE;

    //
    // Quick sanity check
    //
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("!mtrr is X86 only Api.\n");
        return E_INVALIDARG;
    }

    i = 0;
    addr = GetExpression(args);

    if (i != 1) {
        addr = GetExpression("KeFeatureBits");
        if (!addr) {
            dprintf ("KeFeatureBits not found\n");
            return E_INVALIDARG;
        }

        fb = 0;
        ReadMemory(addr, &fb, sizeof(fb), &i);
        if (fb == -1  ||  !(fb & KF_MTRR)) {
            dprintf ("MTRR feature not present\n");
            return E_INVALIDARG;
        }
    }

    //
    // Dump MTRR
    //

    ReadMsr(MTRR_MSR_CAPABILITIES, &Capabilities.u.QuadPart);
    ReadMsr(MTRR_MSR_DEFAULT, &Default.u.QuadPart);

    dprintf ("MTTR: %s Var %d, Fixed-%s %s, USWC-%s, Default: %s\n",
        Default.u.hw.MtrrEnabled ? "" : "disabled",
        Capabilities.u.hw.VarCnt,
        Capabilities.u.hw.FixSupported ? "support" : "none",
        Default.u.hw.FixedEnabled ? "enabled" : "disabled",
        Capabilities.u.hw.UswcSupported ? "supported" : "none",
        MtrrType (Default.u.hw.Type)
        );

    MtrrDumpFixed (0x00000, 64*1024, 0x250);
    MtrrDumpFixed (0x80000, 16*1024, 0x258);
    MtrrDumpFixed (0xA0000, 16*1024, 0x259);
    MtrrDumpFixed (0xC0000,  4*1024, 0x268);
    MtrrDumpFixed (0xC8000,  4*1024, 0x269);
    MtrrDumpFixed (0xD0000,  4*1024, 0x26A);
    MtrrDumpFixed (0xD8000,  4*1024, 0x26B);
    MtrrDumpFixed (0xE0000,  4*1024, 0x26C);
    MtrrDumpFixed (0xE8000,  4*1024, 0x26D);
    MtrrDumpFixed (0xF0000,  4*1024, 0x26E);
    MtrrDumpFixed (0xE8000,  4*1024, 0x26F);

    dprintf ("Variable:                Base               Mask               Length\n");
    for (Index=0; Index < (ULONG) Capabilities.u.hw.VarCnt; Index++) {
        ReadMsr(MTRR_MSR_VARIABLE_BASE+2*Index, &Base.u.QuadPart);
        ReadMsr(MTRR_MSR_VARIABLE_MASK+2*Index, &Mask.u.QuadPart);
        dprintf (" %2d. ", Index);
        if (Mask.u.hw.Valid) {
            MtrrMask = Mask.u.QuadPart & MTRR_MASK_MASK;
            MtrrBase = Base.u.QuadPart & MTRR_MASK_BASE;
            Length = MaskToLength(MtrrMask);
                // Check for non-contiguous MTRR mask.
                if ((MtrrMask + Length) & MASK_OVERFLOW_MASK) {
                    ContiguousLength = FALSE;
                }

            dprintf ("%4s: %08x:%08x  %08x:%08x  %08x:%08x",
                MtrrType ((ULONG) Base.u.hw.Type),
                (ULONG) (Base.u.QuadPart >> 32), (ULONG) MtrrBase,
                (ULONG) (Mask.u.QuadPart >> 32), (ULONG) MtrrMask,
                (ULONG) (Length >> 32), (ULONG) Length);
            if (ContiguousLength == FALSE) {
                ContiguousLength = TRUE;
                dprintf("(non-contiguous)\n");
            }
            else {
                dprintf("\n");
            }

        } else {
            dprintf ("\n");
        }
    }
    return S_OK;
}


ULONGLONG
MaskToLength (
    IN ULONGLONG    Mask
    )
/*++

Routine Description:

    This function returns the length specified by a particular
    mtrr variable register mask.

--*/
{
    if (Mask == 0) {
        // Zero Mask signifies a length of      2**36
        return(((ULONGLONG) 1 << MTRR_MAX_RANGE_SHIFT));
    } else {
        return(((ULONGLONG) 1 << FindFirstSetRightBit(Mask)));
    }
}

ULONG
FindFirstSetRightBit (
    IN ULONGLONG    Set
    )
/*++

Routine Description:

    This function returns a bit position of the least significant
    bit set in the passed ULONGLONG parameter. Passed parameter
    must be non-zero.

--*/
{
    ULONG   bitno;

    for (bitno=0; !(Set & 0xFF); bitno += 8, Set >>= 8) ;
    return FindFirstSetRight[Set & 0xFF] + bitno;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\mps.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mps.c

Abstract:

    WinDbg Extension Api

Author:

    Peter Johnston (peterj) 30-September-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// HACKHACK
//
// The debugger extensions are a little bit broken at the
// moment (6/6/00) and I can't read a bitfield.  So I'm
// including the type here.  And it doesn't matter
// because this code only runs on 32-bit machines.
//

typedef struct _CPUIDENTIFIER {
    ULONG Stepping : 4;
    ULONG Model : 4;
    ULONG Family : 4;
    ULONG Reserved : 20;
} CPUIDENTIFIER, *PCPUIDENTIFIER;

//
// xReadMemory is easier to use than ReadMemory and is
// defined in ..\devnode.c
//

BOOLEAN
xReadMemory(
    ULONG64 S,
    PVOID D,
    ULONG Len
    );

PUCHAR
mpsGetIntTypeDesc(
    UCHAR IntType
    )
{
    switch (IntType) {
    case INT_TYPE_INTR:
        return "intr  ";
    case INT_TYPE_NMI:
        return "nmi   ";
    case INT_TYPE_SMI:
        return "smi   ";
    case INT_TYPE_EXTINT:
        return "extint";
    default:
        return "unknwn";
    }
}

PUCHAR
mpsExtAddrTypeToText(
    UCHAR AddressType
    )
{
    switch (AddressType) {
    case MPS_ADDRESS_MAP_IO:
        return "io port     ";
    case MPS_ADDRESS_MAP_MEMORY:
        return "memory      ";
    case MPS_ADDRESS_MAP_PREFETCH_MEMORY:
        return "prefetch mem";
    case MPS_ADDRESS_MAP_UNDEFINED:
        return "mps undef   ";
    default:
        return "unknown type";
    }
}

PUCHAR
mpsExtCompatibleListToText(
    ULONG List
    )
{
    switch (List) {
    case 0:
        return "ISA";
    case 1:
        return "VGA";
    default:
        return "unknown predefined range";
    }
}


BOOLEAN
mpsBaseTable(
    ULONG64 BaseTableAddress,
    ULONG   EntryCount
    )

/*++

Routine Description:

    Dumps entries from the MPS BASE table.

Arguments:

    BaseTableAddress    Address (in local memory) of the Base Entry Table
    EntryCount          Number of entries in this table.

Return Value:

    TRUE    is all is well
    FALSE   if execution cannot continue (ie we encountered an unknown
            entry type.  Can't continue because we don't know how big
            it is.

--*/

{
    ULONG64 bp = BaseTableAddress;
    ULONG   offset;
    ULONG   featureFlags;
    ULONG64 cpuAddr;
    ULONG   Family, Model, Stepping;
    CHAR    busId[8] = {0};
    CPUIDENTIFIER cpuId;

    //dprintf("BaseTableAddress: %x%x\n", BaseTableAddress);

    while (EntryCount--) {
        ULONG64   CharAtAddress;

        GetFieldValue(bp, "UCHAR", NULL, CharAtAddress);
        //dprintf("CharAtAddress: %x%x %x\n", bp, CharAtAddress);
        dprintf("  ");
        switch ((UCHAR) CharAtAddress) {
        case ENTRY_PROCESSOR:
            {
                InitTypeRead(bp, hal!_PcMpProcessorEntry);

                dprintf(
                    "processor. %s%sL.APIC ID %02x Vers %02x\n",
                    (ULONG) ReadField(CpuFlags) & CPU_ENABLED ? "EN " : "",
                    (ULONG) ReadField(CpuFlags) & BSP_CPU     ? "BP " : "",
                    (ULONG) ReadField(LocalApicId),
                    (ULONG) ReadField(LocalApicVersion)
                    );

                featureFlags = (ULONG)ReadField(FeatureFlags);

                GetFieldOffset("hal!_PcMpProcessorEntry", "CpuIdentification", &offset);
                cpuAddr = (bp + offset);
                
                xReadMemory(cpuAddr, &cpuId, 4);

                dprintf(
                    "             Family %x, Model %x, Stepping %x, CPUID Flags %04x\n",
                    cpuId.Family,
                    cpuId.Model,
                    cpuId.Stepping,
                    featureFlags
                    );
                
                bp += GetTypeSize("hal!_PcMpProcessorEntry");
            }
            break;
        case ENTRY_BUS:
            {
                GetFieldOffset("hal!_PcMpBusEntry", "BusType", &offset);
                xReadMemory((bp + offset), busId, 6);
                
                InitTypeRead(bp, hal!_PcMpBusEntry);
                dprintf(
                    "bus.       id %02x, type %6.6s\n",
                    (ULONG) ReadField(BusId),
                    busId
                    );

                bp += GetTypeSize("hal!_PcMpBusEntry");
            }
            break;
        case ENTRY_IOAPIC:
            {
                InitTypeRead(bp, hal!_PcMpIoApicEntry);
                bp += GetTypeSize("hal!_PcMpIoApicEntry");

                dprintf(
                    "io apic.   %s id %02x vers %02x @ %08x\n",
                    (ULONG) ReadField(IoApicFlag) & IO_APIC_ENABLED ? "EN" : "DI",
                    (ULONG) ReadField(IoApicId),
                    (ULONG) ReadField(IoApicVersion),
                    (ULONG) ReadField(IoApicAddress)
                    );
            }
            break;
        case ENTRY_INTI:
            {
                InitTypeRead(bp, hal!_PcMpApicIntiEntry);
                bp += GetTypeSize("hal!_PcMpApicIntiEntry");

                dprintf(
                    "io int.    %s po=%x el=%x, srcbus %02x irq %02x dst apic %02x intin %02x\n",
                    mpsGetIntTypeDesc((UCHAR) ReadField(IntType)),
                    (ULONG) ReadField(Signal.Polarity),
                    (ULONG) ReadField(Signal.Level),
                    (ULONG) ReadField(SourceBusId),
                    (ULONG) ReadField(SourceBusIrq),
                    (ULONG) ReadField(IoApicId),
                    (ULONG) ReadField(IoApicInti)
                    );
            }
            break;
        case ENTRY_LINTI:
            {
                InitTypeRead(bp, hal!_PcMpLintiEntry);
                bp += GetTypeSize("hal!_PcMpLintiEntry");

                dprintf(
                    "lcl int.   %s po=%x el=%x, srcbus %02x irq %02x dst apic %02x intin %02x\n",
                    mpsGetIntTypeDesc((UCHAR) ReadField(IntType)),
                    (ULONG) ReadField(Signal.Polarity),
                    (ULONG) ReadField(Signal.Level),
                    (ULONG) ReadField(SourceBusId),
                    (ULONG) ReadField(SourceBusIrq),
                    (ULONG) ReadField(DestLocalApicId),
                    (ULONG) ReadField(DestLocalApicInti)
                    );
            }
            break;
        default:
            dprintf(
                "Unknown MPS base type 0x%02x, cannot continue.\n",
                CharAtAddress
                );
            return FALSE;
        }
    }
    return TRUE;
}


BOOLEAN
mpsExtendedTable(
    ULONG64 ExtendedTableAddress,
    ULONG64 ExtendedTableAddressEnd
    )

/*++

Routine Description:

    Dumps entries from the MPS Extended table.

Arguments:

    BaseTableAddress    Address (in local memory) of the Base Entry Table
    EntryCount          Number of entries in this table.

Return Value:

    TRUE    is all is well
    FALSE   if execution cannot continue (ie we encountered an unknown
            entry type.  Can't continue because we don't know how big
            it is.

--*/

{
    ULONG64 bp = ExtendedTableAddress;

    if (!bp) {
        return TRUE;
    }
    dprintf("  extended table entries\n");

    while (bp < ExtendedTableAddressEnd) {

        if (InitTypeRead(bp, hal!MPS_EXTENTRY)) {
            dprintf("Cannot get hal!MPS_EXTENTRY at %p\n", bp);
            return FALSE;
        }

        if (ReadField(Length) == 0) {
            dprintf("Malformed extended entry, length = 0, cannot continue.\n");
            return FALSE;
        }

        dprintf("  ");

        switch ((ULONG) ReadField(Type)) {
        case EXTTYPE_BUS_ADDRESS_MAP:
            dprintf(
                "address.   bus %02x %s % 16I64x len %16I64x\n",
                (ULONG) ReadField(u.AddressMap.BusId),
                mpsExtAddrTypeToText((UCHAR) ReadField(u.AddressMap.Type)),
                ReadField(u.AddressMap.Base),
                ReadField(u.AddressMap.Length)
                );
            break;
        case EXTTYPE_BUS_HIERARCHY:
            dprintf(
                "child bus. bus %02x is child of bus %02x%s\n",
                (ULONG) ReadField(u.BusHierarchy.BusId),
                (ULONG) ReadField(u.BusHierarchy.ParentBusId),
                (ULONG) ReadField(u.BusHierarchy.SubtractiveDecode) ? " subtractive" : ""
                );
            break;
        case EXTTYPE_BUS_COMPATIBLE_MAP:
            dprintf(
                "bus comp.  bus %02x %s %s ranges\n",
                (ULONG) ReadField(u.CompatibleMap.BusId),
                (ULONG) ReadField(u.CompatibleMap.Modifier) ? "exclude" : "include",
                mpsExtCompatibleListToText((ULONG) ReadField(u.CompatibleMap.List))
                );
            break;
        case EXTTYPE_PERSISTENT_STORE:
            dprintf(
                "persist.   % 16I64x len %16I64x\n",
                ReadField(u.PersistentStore.Address),
                ReadField(u.PersistentStore.Length)
                );
            break;
        default:
            dprintf(
                "Unknown MPS extended type 0x%02x, cannot continue.\n",
                (ULONG) ReadField(Type)
                );
            return FALSE;
        }

        //
        // Advance to the next entry.
        //

        bp += (ULONG) ReadField(Length);
    }
    return TRUE;
}


DECLARE_API( mps )

/*++

Routine Description:

    Dumps the MPS (Multi Processor Specification) BIOS Tables.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG64 addr;
    UCHAR   halName[32];
    UCHAR   OemId[20]={0}, OemProductId[20]={0};
    ULONG64 PcMpTablePtr;
    ULONG entryCount;
    PUCHAR bp;
    UCHAR c;
    ULONG i, TableLength, ExtTableLength, Sz;
    UCHAR PcMpCfgTable[100];
    PUCHAR MpsBaseTable = NULL;
    PUCHAR MpsExtendedTable = NULL;
    PUCHAR MpsExtendedTableEnd;
    ULONG  OemOffset, SigOffset, Sig = 0;
    ULONG  BiosRev = 0;

    BOOLEAN halNameKnown = FALSE;

    if (TargetIsDump) {
        dprintf("!mps doesnt work on dump targets\n");
        return E_INVALIDARG;
    }
    //
    // Check to see if user entered the address of the MPS tables.
    // If not, try to obtain it using HAL symbols.
    //

    PcMpTablePtr = GetExpression(args);
    if (PcMpTablePtr == 0) {

        //
        // Get address of PC+MP structure from the HAL.
        // N.B. Should add code to allow hunting for the floating pointer.
        //

        addr = GetExpression("hal!HalName");

        if (addr == 0) {
            dprintf(
                "Unable to use HAL symbols (hal!HalName), please verify symbols.\n"
                );
            return E_INVALIDARG;
        }

        if (!xReadMemory(addr, halName, sizeof(halName))) {
            dprintf(
                "Failed to read HalName from host memory, quitting.\n"
                );
            return E_INVALIDARG;
        }

        halName[sizeof(halName)-1] = '\0';
        if (strstr(halName, "MPS ") == NULL) {
            dprintf("HAL = \"%s\".\n", halName);
            dprintf("HAL does not appear to be an MPS HAL, quitting.\n");
            return E_INVALIDARG;
        }
        halNameKnown = TRUE;

        addr = GetExpression("hal!PcMpTablePtr");

        if (addr == 0) {
            dprintf(
                "Unable to get address of hal!PcMpTablePtr, cannot continue.\n"
                );
            return E_INVALIDARG;
        }

        if (!ReadPointer(addr, &PcMpTablePtr)) {
            dprintf(
                "Failed to read PcMpTablePtr from host memory, cannot continue.\n"
                );
            return E_INVALIDARG;
        }
    }

    if (InitTypeRead(PcMpTablePtr, hal!PcMpTable)) {
        dprintf(
            "Failed to read MP Configuration Table Header @%08p\n"
            "Cannot continue.\n",
            PcMpTablePtr
            );
        return E_INVALIDARG;
    }

    GetFieldOffset("hal!PcMpTable", "Signature", &SigOffset);
    xReadMemory(PcMpTablePtr + SigOffset, &Sig, sizeof(Sig));

    if (Sig != PCMP_SIGNATURE) {
        dprintf(
            "MP Config Table Signature doesn't match.  Cannot continue.\n"
            );
        return E_INVALIDARG;
    }

    dprintf("  BIOS Revision ");

    BiosRev = (ULONG) ReadField(Revision);
    switch (BiosRev) {
    case 1:
        dprintf(
            "MPS 1.1 (WARNING: This BIOS might not support NT 5 depending\n"
            "                  upon system configuration.)\n"
            );
        break;
    case 4:
        dprintf(
            "MPS 1.4       "
            );
        break;
    default:
        dprintf(
            "Unknown MPS revision byte 0x%2x, dumped values\n"
            "  may be incorrect.\n",
            BiosRev);
        break;
    }

    if (halNameKnown) {
        dprintf("  HAL = %s", halName);
    }
    dprintf("\n");

    GetFieldOffset("hal!PcMpTable", "OemId", &OemOffset);
    xReadMemory(PcMpTablePtr + OemOffset, OemId, 8);
    
    dprintf(
        "  OEM ID         :%s\n",
        OemId
        );

    GetFieldOffset("hal!PcMpTable", "OemProductId", &OemOffset);
    xReadMemory(PcMpTablePtr + OemOffset, OemProductId, 12);
    
    dprintf(
        "  OEM Product ID :%s\n",
        OemProductId
        );

    TableLength = (ULONG) ReadField(TableLength);
    Sz = GetTypeSize("hal!PcMpTable");
    if (TableLength <= Sz) {
        dprintf(
            "MPS Base Table length (%d) is too small to be reasonable,\n",
            TableLength
            );
        dprintf(
            "Must be >= sizeof(fixed table header) (%d bytes).  "
            "Cannot continue.\n",
            Sz
            );
        return E_INVALIDARG;
    }

    //
    // Get memory for the base and extended tables and read them from
    // memory.
    //

    MpsBaseTable = malloc( TableLength - Sz);
    if (!MpsBaseTable) {
        dprintf(
            "Could not allocate %d bytes local memory, quitting.\n",
            TableLength - Sz
            );
        return E_INVALIDARG;
    }

    if (!xReadMemory(PcMpTablePtr + Sz,
                     MpsBaseTable,
                     TableLength - Sz)) {
        dprintf("Failed to read MPS Base Table from host memory.  Quitting.\n");
        goto cleanup;
    }

    if (ExtTableLength = (ULONG) ReadField(ExtTableLength)) {
        MpsExtendedTable = malloc(ExtTableLength);
        if (!MpsExtendedTable) {
            dprintf(
                "Could not allocate %d bytes local memory for extended MPS Table, quitting.\n",
                ExtTableLength
            );
            goto cleanup;
        }

        if (!xReadMemory(PcMpTablePtr + TableLength,
                         MpsExtendedTable,
                         ExtTableLength)) {
            dprintf(
                "Could not read MPS Extended table from host memory.\n"
                "Will attempt to dump base structures.\n"
                );
            free(MpsExtendedTable);
            MpsExtendedTable = NULL;
        }
        MpsExtendedTableEnd = MpsExtendedTable + ExtTableLength;
    }

    //
    // Validate checksums.
    //
    // Base checksum is the sum of all bytes (inc checksum) in the
    // base table (including the fixed header).
    //

    c = 0;

    //
    // Sum fixed header.
    //

    if (Sz > sizeof(PcMpCfgTable)) {
        return E_INVALIDARG;
    }
    xReadMemory(PcMpTablePtr, PcMpCfgTable, Sz);
    bp = (PUCHAR)&PcMpCfgTable[0];
    for (i = 0; i < Sz; i++) {
        c += *bp++;
    }

    //
    // Add rest of base table.
    //

    bp = MpsBaseTable;
    for (i = 0; i < TableLength - Sz; i++) {
        c += *bp++;
    }

    //
    // The result should be zero.
    //

    if (c) {
        dprintf(
            "MPS Base Table checksum is in error.\n"
            "Found 0x%02x, Computed 0x%02x (Total 0x%02x).\n",
            (ULONG) ReadField(Checksum),
            (UCHAR)(c - (UCHAR) ReadField(Checksum)),
            c
            );
    }

    //
    // Now do the extended table checksum.  This one doesn't include
    // itself so we should just match (rather than end up with zero).
    //

    if (MpsExtendedTable) {
        c = 0;
        bp = MpsExtendedTable;
        for (i = 0; i < ExtTableLength; i++) {
            c += *bp++;
        }

        //
        // To sum to zero it needs to end up being it's opposite.
        //

        c = -c;

        if (c != (UCHAR) ReadField(ExtTableChecksum)) {
            dprintf(
                "MPS Extended Table checksum is in error.\n"
                "Found 0x%02x, Computed 0x%02x.\n",
                (ULONG) ReadField(ExtTableChecksum),
                c
                );
        }
    }

    //
    // Dump the base table.
    //

    if (!mpsBaseTable(PcMpTablePtr + Sz, (ULONG) ReadField(NumOfEntries))) {
        goto cleanup;
    }


    //
    // Dump the extended table.
    //

    if (!mpsExtendedTable(PcMpTablePtr + TableLength, PcMpTablePtr + TableLength + ExtTableLength )) {
        goto cleanup;
    }

cleanup:
    if (MpsBaseTable) {
        free(MpsBaseTable);
    }
    if (MpsExtendedTable) {
        free(MpsExtendedTable);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\pat.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pat.c

Abstract:

    WinDbg Extension Api

Author:

    Shivnandan Kaushik Aug 1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "i386.h"
#pragma hdrstop

//
// PAT MSR architecture definitions
//

//
// PAT model specific register
//

#define PAT_MSR       0x277

//
// PAT memory attributes
//

#define PAT_TYPE_STRONG_UC  0       // corresponds to PPro PCD=1,PWT=1
#define PAT_TYPE_USWC       1
#define PAT_TYPE_WT         4
#define PAT_TYPE_WP         5
#define PAT_TYPE_WB         6
#define PAT_TYPE_WEAK_UC    7       // corresponds to PPro PCD=1,PWT=0
#define PAT_TYPE_MAX        8       

#include "pshpack1.h"

typedef union _PAT {
    struct {
        UCHAR Pat[8];
    } hw;
    ULONGLONG   QuadPart;
} PAT, *PPAT;

#include "poppack.h"

//
// ----------------------------------------------------------------
//

DECLARE_API( pat )

/*++

Routine Description:

    Dumps processors pat

Arguments:

    args - none

Return Value:

    None

--*/
{
    static PUCHAR Type[] = {
    //  0         1           2            3            4       
    "STRONG_UC","USWC     ","????     ","????     ","WT       ",
    //  5         6           7
    "WP       ","WB       ","WEAK_UC  "};
    PAT     Attributes;
    ULONG   i;
    PUCHAR  p;
    ULONG   fb;
    ULONG   Index;

    //
    // Quick sanity check
    //
    
    // X86_ONLY_API
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("!pat is X86 only API.\n");
        return E_INVALIDARG;
    }

    i = (ULONG) GetExpression(args);

    if (i != 1) {
        i = (ULONG) GetExpression("KeFeatureBits");
        if (!i) {
            dprintf ("KeFeatureBits not found\n");
            return E_INVALIDARG;
        }

        fb = 0;
        ReadMemory(i, &fb, sizeof(i), &i);
        if (fb == -1  ||  !(fb & KF_PAT_X86)) {
            dprintf ("PAT feature not present\n");
            return E_INVALIDARG;
        }
    }

    //
    // Dump PAT
    //

    ReadMsr(PAT_MSR, &Attributes.QuadPart);

    dprintf("PAT_Index PCD PWT     Memory Type\n");
    for (Index = 0; Index < 8; Index++) {
        p = "????";
        if (Attributes.hw.Pat[Index] < PAT_TYPE_MAX) {
            p = Type[Attributes.hw.Pat[Index]];
        }
        dprintf("%d         %d   %d       %s\n",(Index/4)%2,
            (Index/2)%2,Index%2,p);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\pci.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pci.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 18-August-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "i386.h"
#pragma hdrstop

DECLARE_API(pciir)
{
    ULONG64                 addr;
    ULONG64                 pciIrqRoutingTable;
    ULONG64                 slot;
    ULONG64                 lastSlot;
    ULONG                   slotSz, SizeOfRoutingTable, TableSize;

    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("X86 target only API.\n");
        return E_INVALIDARG;
    }

    slotSz = GetTypeSize("hal!_SLOT_INFO");
    SizeOfRoutingTable = GetTypeSize("hal!_PCI_IRQ_ROUTING_TABLE");
    addr = GetExpression("Hal!HalpPciIrqRoutingInfo");
    if (addr == 0)
    {
        dprintf("Error reading Pci Irq Routing Info!\n");
    }
    else
    {
        pciIrqRoutingTable = 0;
        if (ReadPointer(addr, &pciIrqRoutingTable))
        {
            if (pciIrqRoutingTable) 
            {
                //
                // Read and dump the header.
                //

                if (!InitTypeRead(pciIrqRoutingTable, hal!_PCI_IRQ_ROUTING_TABLE))
                {
                    dprintf("Version            = %04x\n", (ULONG) ReadField(Version));
                    dprintf("Size               = %04x\n", TableSize = (ULONG) ReadField(TableSize));
                    dprintf("RouterBus          = %02x\n", (ULONG) ReadField(RouterBus));
                    dprintf("RouterDevFunc      = %02x:%02x\n", (ULONG) ReadField(RouterDevFunc) >> 3, (ULONG) ReadField(RouterDevFunc) & 0x7);
                    dprintf("ExclusiveIRQs      = %04x\n", (ULONG) ReadField(ExclusiveIRQs));
                    dprintf("CompatibleRouterId = %08x\n", (ULONG) ReadField(CompatibleRouter));
                    dprintf("MiniportData       = %08x\n", (ULONG) ReadField(MiniportData));
                    dprintf("CheckSum           = %04x\n", (ULONG) ReadField(Checksum));

                    //
                    // Read and dump the table.
                    //

                    dprintf("----------------------------------------------------------------\n");
                    dprintf("Bus Device  LnkA  Mask  LnkB  Mask  LnkC  Mask  LnkD  Mask  Slot\n");
                    dprintf("----------------------------------------------------------------\n");
                    slot = pciIrqRoutingTable + SizeOfRoutingTable;
                    for (lastSlot = pciIrqRoutingTable + TableSize; slot < lastSlot; slot+=slotSz)
                    {
                        if (!InitTypeRead(slot, hal!_SLOT_INFO))
                        {
                                dprintf("%02x    %02x     %02x   %04x   %02x   %04x   %02x   %04x   %02x   %04x   %02x\n", 
                                        (ULONG) ReadField(BusNumber), 
                                        (ULONG) ReadField(DeviceNumber) >> 3,
                                        (ULONG) ReadField(PinInfo[0].Link), (ULONG) ReadField(PinInfo[0].InterruptMap),
                                        (ULONG) ReadField(PinInfo[1].Link), (ULONG) ReadField(PinInfo[1].InterruptMap),
                                        (ULONG) ReadField(PinInfo[2].Link), (ULONG) ReadField(PinInfo[2].InterruptMap),
                                        (ULONG) ReadField(PinInfo[3].Link), (ULONG) ReadField(PinInfo[3].InterruptMap),
                                        (ULONG) ReadField(SlotNumber));
                        }
                    }
                }
            }
            else
            {
                dprintf("Pci Irq Routing Table not found.\n");
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\pcmcia.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pcmcia.c

Abstract:

    WinDbg Extension Api to dump PCMCIA driver structures.
    This module references some routines & types defined
    in devnode.c

Author:

    Ravisankar Pudipeddi (ravisp) 1-Dec-1997
    Neil Sandlin (neilsa) 1-June-1999

Environment:

    User Mode.

--*/


#include "precomp.h"
#pragma hdrstop

#define FLAG_NAME(flag)           {flag, #flag}

//
// Table of PCMCIA device extension flags
// update them from pcmcia.h
//
FLAG_NAME PcmciaDeviceFlags[] = {
   FLAG_NAME(PCMCIA_DEVICE_STARTED),
   FLAG_NAME(PCMCIA_DEVICE_LOGICALLY_REMOVED),
   FLAG_NAME(PCMCIA_DEVICE_PHYSICALLY_REMOVED),
   FLAG_NAME(PCMCIA_DEVICE_MULTIFUNCTION),
   FLAG_NAME(PCMCIA_DEVICE_WAKE_PENDING),
   FLAG_NAME(PCMCIA_DEVICE_LEGACY_DETECTED),
   FLAG_NAME(PCMCIA_DEVICE_DELETED),
   FLAG_NAME(PCMCIA_DEVICE_CARDBUS),
   FLAG_NAME(PCMCIA_FILTER_ADDED_MEMORY),
   FLAG_NAME(PCMCIA_MEMORY_24BIT),
   FLAG_NAME(PCMCIA_CARDBUS_NOT_SUPPORTED),
   FLAG_NAME(PCMCIA_USE_POLLED_CSC),
   FLAG_NAME(PCMCIA_ATTRIBUTE_MEMORY_MAPPED),
   FLAG_NAME(PCMCIA_SOCKET_REGISTER_BASE_MAPPED),
   FLAG_NAME(PCMCIA_INTMODE_COMPAQ),
   FLAG_NAME(PCMCIA_POWER_WORKER_POWERUP),
   FLAG_NAME(PCMCIA_SOCKET_POWER_REQUESTED),
   FLAG_NAME(PCMCIA_CONFIG_STATUS_DEFERRED),
   FLAG_NAME(PCMCIA_POWER_STATUS_DEFERRED),
   FLAG_NAME(PCMCIA_INT_ROUTE_INTERFACE),
   {0,0}
};

//
// Table of PCMCIA socket structure flags
// update them from pcmcia.h
//
FLAG_NAME PcmciaSocketFlags[] = {
   FLAG_NAME(SOCKET_CARD_IN_SOCKET),
   FLAG_NAME(SOCKET_CARD_INITIALIZED),
   FLAG_NAME(SOCKET_CARD_POWERED_UP),
   FLAG_NAME(SOCKET_CARD_CONFIGURED),
   FLAG_NAME(SOCKET_CARD_MULTIFUNCTION),
   FLAG_NAME(SOCKET_CARD_CARDBUS),
   FLAG_NAME(SOCKET_CARD_MEMORY),
   FLAG_NAME(SOCKET_CHANGE_INTERRUPT),
   FLAG_NAME(SOCKET_CUSTOM_INTERFACE),
   FLAG_NAME(SOCKET_INSERTED_SOUND_PENDING),
   FLAG_NAME(SOCKET_REMOVED_SOUND_PENDING),
   FLAG_NAME(SOCKET_SUPPORT_MESSAGE_SENT),
   FLAG_NAME(SOCKET_MEMORY_WINDOW_ENABLED),
   FLAG_NAME(SOCKET_CARD_STATUS_CHANGE),
   FLAG_NAME(SOCKET_POWER_STATUS_DEFERRED),
   {0,0}
};

ENUM_NAME PcmciaControllerTypeEnum[] = {
   ENUM_NAME(PcmciaIntelCompatible),
   ENUM_NAME(PcmciaCardBusCompatible),
   ENUM_NAME(PcmciaElcController),
   ENUM_NAME(PcmciaDatabook),
   ENUM_NAME(PcmciaPciPcmciaBridge),
   ENUM_NAME(PcmciaCirrusLogic),
   ENUM_NAME(PcmciaTI),
   ENUM_NAME(PcmciaTopic),
   ENUM_NAME(PcmciaRicoh),
   ENUM_NAME(PcmciaDatabookCB),
   ENUM_NAME(PcmciaOpti),
   ENUM_NAME(PcmciaTrid),
   ENUM_NAME(PcmciaO2Micro),
   ENUM_NAME(PcmciaNEC),
   ENUM_NAME(PcmciaNEC_98),
   ENUM_NAME(PcmciaInvalidControllerType),
   {0,0}
};


ENUM_NAME PcmciaSocketPowerWorkerStates[] = {
   ENUM_NAME(SPW_Stopped),
   ENUM_NAME(SPW_Exit),
   ENUM_NAME(SPW_RequestPower),
   ENUM_NAME(SPW_ReleasePower),
   ENUM_NAME(SPW_SetPowerOn),
   ENUM_NAME(SPW_SetPowerOff),
   ENUM_NAME(SPW_ParentPowerUp),
   ENUM_NAME(SPW_ParentPowerUpComplete),
   {0,0}
};

ENUM_NAME PcmciaPdoPowerWorkerStates[] = {
   ENUM_NAME(PPW_Stopped),
   ENUM_NAME(PPW_Exit),
   ENUM_NAME(PPW_InitialState),
   ENUM_NAME(PPW_PowerUp),
   ENUM_NAME(PPW_PowerUpComplete),
   ENUM_NAME(PPW_PowerDown),
   ENUM_NAME(PPW_PowerDownComplete),
   ENUM_NAME(PPW_SendIrpDown),
   ENUM_NAME(PPW_16BitConfigure),
   ENUM_NAME(PPW_Deconfigure),
   ENUM_NAME(PPW_VerifyCard),
   ENUM_NAME(PPW_CardBusRefresh),
   ENUM_NAME(PPW_CardBusDelay),
   {0,0}
};

PUCHAR DeviceTypeTable[] = {
    "Multifunction",
    "Memory card",
    "Serial",
    "Parallel",
    "ATA",
    "Video",
    "Network controller",
    "AIMS",
    "Scsi controller",
    "Modem"
};


VOID
DumpEnum(
        ULONG       EnumVal,
        PENUM_NAME EnumTable
        )
/*++

Routine Description:

    Prints the supplied enum value in a readable string format
    by looking it up in the supplied enum table

Arguments:

    EnumVal   -  Enum to be printed
    EnumTable -  Table in which the enum is looked up to find
                 the string to be printed

Return Value:

None

--*/
{
   ULONG i;

   for (i=0; EnumTable[i].Name != NULL; i++) {
      if (EnumTable[i].EnumVal == EnumVal) {
         break;
      }
   }
   if (EnumTable[i].Name != NULL) {
      dprintf("%s", EnumTable[i].Name);
   } else {
      dprintf("Unknown ");
   }
   return;
}

ULONG64
SocFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!SOCKET", Field, Temp);
    return Temp;
}


VOID
DumpSocket(ULONG64 Socket, ULONG Depth)
/*++

Routine Description

   Dumps the socket structure

Arguments

   Socket - Pointer to the socket structure
   Depth  - Indentation at which to print

Return Value

   None
--*/
{
    ULONG64 tmp;

    dprintf("\n");
    xdprintf(Depth,""); dprintf("NextSocket  0x%p\n", SocFld(Socket, "NextSocket"));
    xdprintf(Depth,""); dprintf("SocketFnPtr 0x%p\n", SocFld(Socket, "SocketFnPtr"));
    xdprintf(Depth,""); dprintf("Fdo devext  0x%p\n", SocFld(Socket, "DeviceExtension"));
    xdprintf(Depth,""); dprintf("PdoList     0x%p\n", SocFld(Socket, "PdoList"));
    DumpFlags(Depth, "Socket Flags", (ULONG) SocFld(Socket, "Flags"), PcmciaSocketFlags);

    xdprintf(Depth,"Revision 0x%x\n", (ULONG) SocFld(Socket, "Revision"));
    xdprintf(Depth,"SocketNumber 0x%x\n", (ULONG) SocFld(Socket, "SocketNumber"));
    xdprintf(Depth,"NumberOfFunctions %d\n", (ULONG) SocFld(Socket, "NumberOfFunctions"));
    xdprintf(Depth,"AddressPort 0x%x\n", (ULONG) SocFld(Socket, "AddressPort"));
    xdprintf(Depth,"RegisterOffset 0x%x\n", (ULONG) SocFld(Socket, "RegisterOffset"));
    xdprintf(Depth,"CBReg Base 0x%I64x size 0x%x\n",
             SocFld(Socket, "CardBusSocketRegisterBase"),
             SocFld(Socket, "CardBusSocketRegisterSize"));
    xdprintf(Depth,"CisCache 0x%x\n", (ULONG) SocFld(Socket, "CisCache"));

    if (tmp = SocFld(Socket, "PciDeviceRelations")) {
        xdprintf(Depth,"PciDeviceRelations 0x%p\n", tmp);
    }

    xdprintf(Depth,"PowerRequests     %d\n", (ULONG) SocFld(Socket, "PowerRequests"));
    xdprintf(Depth,"PowerWorker State: ");
    DumpEnum((ULONG) SocFld(Socket, "WorkerState"), PcmciaSocketPowerWorkerStates);
    dprintf("\n");
    if (SocFld(Socket, "WorkerState") != SPW_Stopped) {
        xdprintf(Depth,"  Worker Phase %d\n", (ULONG) SocFld(Socket, "WorkerPhase"));
        xdprintf(Depth,"  PowerData 0x%x\n", (ULONG) SocFld(Socket, "PowerData"));
        xdprintf(Depth,""); dprintf("  PowerCompletionRoutine 0x%p\n", SocFld(Socket, "PowerCompletionRoutine"));
        xdprintf(Depth,""); dprintf("  PowerCompletionContext 0x%p\n", SocFld(Socket, "PowerCompletionContext"));
        xdprintf(Depth,"  CallerStatus 0x%x\n", (ULONG) SocFld(Socket, "CallerStatus"));
        xdprintf(Depth,"  DeferredStatus 0x%x\n", (ULONG) SocFld(Socket, "DeferredStatus"));
        xdprintf(Depth,"  DeferredPowerRequests 0x%x\n", (ULONG) SocFld(Socket, "DeferredPowerRequests"));
    }
    dprintf("\n");
    return;
}


VOID
DumpDevicePowerState(IN DEVICE_POWER_STATE PowerState)
/*++

Routine Description

   Converts the supplied enum device power state to a
   string & dumps it.

Arguments

   PowerState  - Device power state

Return Value

    None
--*/
{

   dprintf("  DevicePowerState: ");
   switch (PowerState) {
   case PowerDeviceUnspecified: {
         dprintf("PowerDeviceUnspecfied\n");
         break;
      }
   case PowerDeviceD0: {
         dprintf("PowerDeviceD0\n");
         break;
      }
   case PowerDeviceD1: {
         dprintf("PowerDeviceD1\n");
         break;
      }
   case PowerDeviceD2: {
         dprintf("PowerDeviceD2\n");
         break;
      }
   case PowerDeviceD3: {
         dprintf("PowerDeviceD3\n");
         break;
      }
   default:
         dprintf("???\n");
   }
}


VOID
DumpSystemPowerState(IN SYSTEM_POWER_STATE PowerState)
/*++

Routine Description

   Converts the supplied enum system power state to a
   string & dumps it.

Arguments

   PowerState     - System power state

Return Value

   None
--*/
{
   dprintf("  SystemPowerState: ");
   switch (PowerState) {
   case PowerSystemUnspecified: {
         dprintf("PowerSystemUnspecfied\n");
         break;
      }
   case PowerSystemWorking:{
         dprintf("PowerSystemWorking\n");
         break;
      }
   case PowerSystemSleeping1: {
         dprintf("PowerSystemSleeping1\n");
         break;
      }
   case PowerSystemSleeping2: {
         dprintf("PowerSystemSleeping2\n");
         break;
      }
   case PowerSystemSleeping3: {
         dprintf("PowerSystemSleeping3\n");
         break;
      }
   case PowerSystemHibernate: {
         dprintf("PowerSystemHibernate\n");
         break;
      }
   case PowerSystemShutdown: {
         dprintf("PowerSystemShutdown\n");
         break;
      }
   default:
         dprintf("???\n");
   }
}



ULONG64
ConfigFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!SOCKET_CONFIGURATION", Field, Temp);
    return Temp;
}

VOID
DumpSocketConfiguration(ULONG64 Config, ULONG Depth)
/*++

Routine Description

   Dumps the current configuration of the socket

Arguments

   Config      - Pointer to the current configuration for the socket
   Depth       - Indentation at which to print

Return Value

   None

--*/
{

    ULONG i;
    ULONG NumberOfIoPortRanges, NumberOfMemoryRanges;
    CHAR  Buffer[40], Buffer2[40], Buffer3[40];

    xdprintf(Depth, "Irq      0x%x\n", (ULONG) ConfigFld(Config, "Irq"));
    xdprintf(Depth, "ReadyIrq 0x%x\n", (ULONG) ConfigFld(Config, "ReadyIrq"));
    if ((NumberOfIoPortRanges = (ULONG) ConfigFld(Config, "NumberOfIoPortRanges")) > 0) {
        xdprintf(Depth,
                 "%x I/O range(s) configured, %s: ",
                 NumberOfIoPortRanges,
                 (ConfigFld(Config, "Io16BitAccess") ? "16-bit access" : "8-bit access"));

        for (i = 0; i < NumberOfIoPortRanges; i++) {
            if (CheckControlC()) {
                break;
            }
            sprintf(Buffer, "IoPortBase[%d]", i);
            sprintf(Buffer2, "IoPortLength[%d]", i);
            xdprintf(Depth+1, "Base 0x%x, length 0x%x\n",
                     (ULONG) ConfigFld(Config, Buffer), (ULONG) ConfigFld(Config, Buffer2) +1);
        }
    }
    if ((NumberOfMemoryRanges = (ULONG) ConfigFld(Config, "NumberOfMemoryRanges")) > 0) {
        xdprintf(Depth, "%x memory range(s) configured", NumberOfMemoryRanges);
        if (ConfigFld(Config, "Mem16BitAccess")) {
            dprintf(", 16-bit access");
        } else {
            dprintf(", 8-bit access");
        }
        dprintf(":\n");

        for (i = 0; i < NumberOfMemoryRanges; i++) {
            if (CheckControlC()) {
                break;
            }
            sprintf(Buffer, "MemoryHostBase[%d]", i);
            sprintf(Buffer2, "MemoryCardBase[%d]", i);
            sprintf(Buffer3, "MemoryLength[%d]", i);
            xdprintf(Depth+1,"Host base 0x%x, card base 0x%x, length 0x%x\n",
                     (ULONG) ConfigFld(Config, Buffer), (ULONG) ConfigFld(Config, Buffer2),
                     (ULONG) ConfigFld(Config, Buffer3));
        }
    }
}


VOID
DumpIrqMask(ULONG IrqMask)
/*++

Routine Description

   Dumps IRQ values as specified by the supplied mask.

Arguments

   IrqMask - Values correspoinging to bits set to 1 in this mask are dumped:
             the value of a bit is 0-based, counted from LSB to MSB
Return Value

   None

--*/
{
   ULONG temp, index, count;

   temp =  1;
   index = 0;
   count = 0;

   while (temp) {
      if (temp & IrqMask) {
         if (count > 0) {
            //
            // Print trailing comma
            //
            dprintf(",");
         }
         dprintf("%x", index);
         count++;
      }
      temp <<= 1; index++;
   }
   dprintf("\n");

}


ULONG64
EntryFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!CONFIG_ENTRY", Field, Temp);
    return Temp;
}

VOID
DumpConfigEntry(ULONG64 Config, ULONG Depth)
/*++

Routine Description

   Dumps a single "config entry", i.e. the encapsulation of a
   CISTPL_CONFIG_ENTRY tuple on a pc-card

Arguments

   Config      - Pointer to the config entry
   Depth       - Indentation at which to print

Return Value

   None

--*/
{
    ULONG i;
    ULONG NumberOfIoPortRanges, NumberOfMemoryRanges, IrqMask;
    CHAR  buffer[40], buffer2[40], buffer3[40];

    if (EntryFld(Config, "Flags") & PCMCIA_INVALID_CONFIGURATION) {
        xdprintf(Depth, "**This is an invalid configuration**\n");
    }

    xdprintf(Depth, "Index: 0x%x\n", (ULONG) EntryFld(Config, "IndexForThisConfiguration"));

    if ((NumberOfIoPortRanges = (ULONG) EntryFld(Config, "NumberOfIoPortRanges")) > 0) {

        for (i = 0; i < NumberOfIoPortRanges; i++) {
            ULONG IoPortBase;

            if (CheckControlC()) {
                break;
            }
            sprintf(buffer,"IoPortBase[%d]",i);
            sprintf(buffer2,"IoPortLength[%d]",i);
            sprintf(buffer3,"IoPortAlignment[%d]",i);

            if ((IoPortBase = (ULONG) EntryFld(Config, buffer)) == 0) {
                xdprintf(Depth,"I/O Any range of ");
            } else {
                xdprintf(Depth,"I/O Base 0x%x, ", IoPortBase);
            }

            dprintf("length 0x%x, alignment 0x%x, ",
                    (ULONG) EntryFld(Config, buffer2)+1,
                    (ULONG) EntryFld(Config, buffer3));

            if (EntryFld(Config, "Io16BitAccess") && EntryFld(Config, "Io8BitAccess")) {
                dprintf("16/8-bit access");
            } else  if (EntryFld(Config, "Io16BitAccess")) {
                dprintf("16-bit access");
            } else if (EntryFld(Config, "Io8BitAccess")) {
                dprintf("8-bit access");
            }

            dprintf("\n");
        }
    }
    if ((NumberOfMemoryRanges = (ULONG) EntryFld(Config, "NumberOfMemoryRanges")) > 0) {

        for (i = 0; i < NumberOfMemoryRanges; i++) {
            if (CheckControlC()) {
                break;
            }
            sprintf(buffer,"MemoryHostBase[%d]",i);
            sprintf(buffer2,"MemoryCardBase[%d]",i);
            sprintf(buffer3,"MemoryLength[%d]",i);
            xdprintf(Depth,"MEM Host base 0x%x, card base 0x%x, len 0x%x\n",
                     (ULONG) EntryFld(Config, buffer),
                     (ULONG) EntryFld(Config, buffer2),
                     (ULONG) EntryFld(Config, buffer3));
        }
    }

    if ((IrqMask = (ULONG)  EntryFld(Config, "IrqMask")) != 0) {
        xdprintf(Depth,"IRQ - one of: ", IrqMask);
        DumpIrqMask(IrqMask);
   }
   //
   // Have to dump level/share disposition information some time..
   //
}


VOID
DumpPcCardType(UCHAR Type,
               ULONG Depth)
/*++

Routine Description

    Prints the device type of  the pc-card

Arguments

    Type    - Device type value
    Depth   - Indentation

Return value

    None

--*/
{
    PUCHAR s;

    xdprintf(Depth,"Device type: ");

    //
    // Type should be <= number of DeviceTypeTable  entries - 1
    //
    if ((ULONG) Type >= sizeof(DeviceTypeTable)) {
        dprintf("Unknown\n");
    } else {
        dprintf("%s\n", DeviceTypeTable[(ULONG) Type]);
    }
}


VOID
DumpConfigEntryChain(ULONG64 ConfigEntryChain,
                     ULONG   Depth)
/*++
Routine Description

    Dumps the chain of config entries

Arguments

    ConfigEntryChain -  pointer to head of config entry  list
    Depth            -  indentation
--*/
{
   ULONG64 ce;

   ce = ConfigEntryChain;
   while (ce != 0) {
      if (CheckControlC()) {
         break;
      }
      xdprintf(Depth, ""); dprintf("ConfigEntry: 0x%p\n", ce);
      if (!GetFieldValue(ce, "pcmcia!CONFIG_ENTRY", "NextEntry", ConfigEntryChain)) {
         DumpConfigEntry(ce, Depth+1);
         ce = ConfigEntryChain;
      } else {
         ce = 0;
      }
   }
}


ULONG64
SocDataFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!SOCKET_DATA", Field, Temp);
    return Temp;
}


VOID
DumpSocketData(ULONG64 SocketData, ULONG Depth)
/*++

Routine Description

   Dumps the socket data structure hanging off the device extension
   for a pc-card pdo, which describes in entirety the pc-card, it's
   resource/power requirements etc.

Arguments

   SocketData     - Pointer to the socket data structure
   Depth          - Indentation at which to print

Return Value

   None

--*/
{
    ULONG d;
    CHAR Mfg[80]={0}, Ident[80]={0};
    ULONG64 DefaultConfiguration;

    xdprintf(Depth, "");
    dprintf("NextSocketData 0x%p PrevSocketData 0x%p\n",
             SocDataFld(SocketData, "Next"), SocDataFld(SocketData, "Prev"));
    xdprintf(Depth, ""); dprintf("PdoExtension   0x%p\n", SocDataFld(SocketData, "PdoExtension"));
    GetFieldValue(SocketData, "pcmcia!SOCKET_DATA", "Mfg", Mfg);
    GetFieldValue(SocketData, "pcmcia!SOCKET_DATA", "Ident", Ident);
    xdprintf(Depth, "Manufacturer: %s Identifier: %s\n", Mfg, Ident);

    DumpPcCardType((UCHAR) SocDataFld(SocketData, "DeviceType"), Depth);

    xdprintf(Depth,"CisCrc: 0x%X  LastEntryInCardConfig: 0x%x\n",
             (ULONG) SocDataFld(SocketData, "CisCrc"), (ULONG) SocDataFld(SocketData, "LastEntryInCardConfig"));
    xdprintf(Depth, "Manufacturer Code: 0x%x Info: 0x%x\n",
             (ULONG) SocDataFld(SocketData, "ManufacturerCode"),
             (ULONG) SocDataFld(SocketData, "ManufacturerInfo"));
    xdprintf(Depth, "Config Register Base: 0x%I64x\n", SocDataFld(SocketData, "ConfigRegisterBase"));
    //
    // Dump all the config entries hanging off this socket's pc-card
    //
    DumpConfigEntryChain(SocDataFld(SocketData, "ConfigEntryChain"), Depth);

    xdprintf(Depth, ""); dprintf("Default Configuration: 0x%p\n",
             (DefaultConfiguration = SocDataFld(SocketData, "DefaultConfiguration")));
    if (DefaultConfiguration != 0) {
        DumpConfigEntry(DefaultConfiguration, Depth+1);
    }

    xdprintf(Depth,"Vcc: 0x%x Vpp1: 0x%x Vpp2 0x%x\n",
             (ULONG) SocDataFld(SocketData, "Vcc"),
             (ULONG) SocDataFld(SocketData, "Vpp1"),
             (ULONG) SocDataFld(SocketData, "Vpp2"));
    xdprintf(Depth,"Audio: 0x%x RegistersPresentMask 0x%x\n",
             (ULONG) SocDataFld(SocketData, "Audio"),
             (ULONG) SocDataFld(SocketData, "RegistersPresentMask"));
    xdprintf(Depth, "ConfigIndex used for current card configuration: 0x%x\n",
             (ULONG) SocDataFld(SocketData, "ConfigIndexUsed"));
    xdprintf(Depth, "Function number (in a multifunc. card): 0x%x\n",
             (ULONG) SocDataFld(SocketData, "Function"));
    xdprintf(Depth, "Instance number: 0x%x\n", (ULONG) SocDataFld(SocketData, "Instance"));
    xdprintf(Depth, "Mf ResourceMap: irq index %x.%x, i/o index %x.%x, mem index %x.%x\n",
                   (ULONG) SocDataFld(SocketData, "MfIrqResourceMapIndex"),
                   (ULONG) SocDataFld(SocketData, "MfNeedsIrq"),
                   (ULONG) SocDataFld(SocketData, "MfIoPortResourceMapIndex"),
                   (ULONG) SocDataFld(SocketData, "MfIoPortCount"),
                   (ULONG) SocDataFld(SocketData, "MfMemoryResourceMapIndex"),
                   (ULONG) SocDataFld(SocketData, "MfMemoryCount"));
}


ULONG64
PDOxFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!PDO_EXTENSION", Field, Temp);
    return Temp;
}

ULONG64
FDOxFld (ULONG64 Addr, PUCHAR Field) {
    ULONG64 Temp;

    GetFieldValue(Addr, "pcmcia!FDO_EXTENSION", Field, Temp);
    return Temp;
}


VOID
DevExtPcmcia(
    ULONG64 Extension
    )

/*++

Routine Description:

    Dump a PCMCIA Device extension.

Arguments:

    Extension   Address of the extension to be dumped.

Return Value:

    None.

--*/
{
   ULONG64  DeviceObject=0;
   ULONG64  socketDataPtr;
   ULONG    Flags, depth;

   if (!ReadPointer(Extension, &DeviceObject)) {
      dprintf(
             "Failed to read PCMCIA extension at %08p, giving up.\n",
             Extension
             );
      return;
   }

   if (GetFieldValue(DeviceObject, "nt!_DEVICE_OBJECT", "Flags", Flags)) {
      return;
   }

   if (Flags & DO_BUS_ENUMERATED_DEVICE) {
      //
      // This is the extension for a PC-Card PDO
      //
      ULONG64       socketPtr, Capabilities;
      ULONG64       DeviceId;
      UCHAR         deviceId[PCMCIA_MAXIMUM_DEVICE_ID_LENGTH];

      if (GetFieldValue(Extension, "pcmcia!PDO_EXTENSION", "DeviceId", DeviceId)) {
         return;
      }

      dprintf("PDO Extension, Device Object 0x%p\n",PDOxFld(Extension, "DeviceObject"));

      DumpFlags(0, "  Device Flags", (ULONG) PDOxFld(Extension, "Flags"), PcmciaDeviceFlags);

      dprintf("  NextPdo 0x%p LowerDevice 0x%p PciPdo 0x%p\n",
              PDOxFld(Extension, "NextPdoInFdoChain"),
              PDOxFld(Extension, "LowerDevice"),
              PDOxFld(Extension, "PciPdo"));

      dprintf("  DeviceId 0x%p: ", DeviceId);
      if (DeviceId != 0) {
          ULONG status;

          ReadMemory(DeviceId, deviceId, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH, &status);
          dprintf("%s", deviceId);
      }
      dprintf("\n");

      dprintf("  Socket: 0x%x\n", PDOxFld(Extension, "Socket"));

      socketDataPtr = PDOxFld(Extension, "SocketData");
      while (socketDataPtr != 0) {
          //
          // Dump socket data structure
          //
          dprintf("  SocketData 0x%x\n", socketDataPtr);
          DumpSocketData(socketDataPtr, 2);

          socketDataPtr = SocDataFld(socketDataPtr, "Next");
      }

      DumpDevicePowerState((ULONG) PDOxFld(Extension, "DevicePowerState"));
      DumpSystemPowerState((ULONG) PDOxFld(Extension, "SystemPowerState"));
      dprintf("  WaitWakeIrp 0x%p\n", PDOxFld(Extension, "WaitWakeIrp"));
      dprintf("  PendingPowerIrp 0x%p\n", PDOxFld(Extension, "PendingPowerIrp"));
      dprintf("  DeviceCapabilities (at 0x%p): \n", (Capabilities = PDOxFld(Extension, "Capabilities")));
      if (Capabilities != 0) {
          DumpDeviceCapabilities(Capabilities);
      }

      dprintf("  ConfigurationPhase: %d\n", (ULONG) PDOxFld(Extension, "ConfigurationPhase"));

      dprintf("  PowerWorker State: ");
      DumpEnum((ULONG) PDOxFld(Extension, "PowerWorkerState"), PcmciaPdoPowerWorkerStates);
      dprintf("\n");
      if ((ULONG) PDOxFld(Extension, "PowerWorkerState") != PPW_Stopped) {
         dprintf("    Worker Phase %d\n", (ULONG) PDOxFld(Extension, "PowerWorkerPhase"));
         dprintf("    Worker Sequence 0x%x\n", (ULONG) PDOxFld(Extension, "PowerWorkerSequence"));
      }



   } else {
      //
      // This is the extension for the pcmcia controller FDO
      //
      ULONG64       addr, PdoList, NextFdo, Capabilities;
      ULONG         model, revision;
      ULONG         ControllerType, off;


      if (GetFieldValue(Extension, "pcmcia!FDO_EXTENSION", "PdoList", PdoList)) {
         return;
      }
      dprintf("FDO Extension, Device Object 0x%p\n", FDOxFld(Extension, "DeviceObject"));
      dprintf("  DriverObject 0x%p, RegistryPath 0x%p\n",
              FDOxFld(Extension, "DriverObject"), FDOxFld(Extension, "RegistryPath"));

      DumpFlags(0, "  Device Flags", (ULONG) FDOxFld(Extension, "Flags"), PcmciaDeviceFlags);

      dprintf("  ControllerType (%x): ", (ControllerType = (ULONG) FDOxFld(Extension, "ControllerType")));
      DumpEnum(PcmciaClassFromControllerType(ControllerType), PcmciaControllerTypeEnum);
      if (model = PcmciaModelFromControllerType(ControllerType)) {
         dprintf("%d", model);
      }
      if (revision = PcmciaRevisionFromControllerType(ControllerType)) {
         dprintf(", rev(%d)", revision);
      }
      dprintf("\n");

      dprintf("  Child PdoList head 0x%p ", PdoList);

      GetFieldOffset("nt!_DEVICE_OBJECT","DeviceExtension", &off);
      if ((PdoList != 0) &&
          ReadPointer( PdoList + off ,
                      &addr)) {
         dprintf("device extension 0x%p\n", addr);
      } else {
         dprintf("\n");
      }

      dprintf("  LivePdoCount       0x%x\n", (ULONG)  FDOxFld(Extension, "LivePdoCount"));
      dprintf("  NextFdo            0x%p ",  (NextFdo = FDOxFld(Extension, "NextFdo")));
      if ((NextFdo != 0) &&
          ReadPointer(NextFdo + off,
                      &addr)) {
         dprintf("device extension 0x%p\n", addr);
      } else {
         dprintf("\n");
      }
      dprintf("  Pdo (for this fdo) 0x%p\n", FDOxFld(Extension, "Pdo"));
      dprintf("  LowerDevice        0x%p\n", FDOxFld(Extension, "LowerDevice"));
      dprintf("  SocketList         0x%p\n", FDOxFld(Extension, "SocketList"));

      dprintf("  IRQ mask 0x%x allows IRQs: ", (ULONG) FDOxFld(Extension, "AllocatedIrqMask"));
      DumpIrqMask((ULONG) FDOxFld(Extension, "AllocatedIrqMask"));
      dprintf("  Memory window physical address 0x%p\n", FDOxFld(Extension, "PhysicalBase"));
      dprintf("  Memory window virtual  address 0x%p\n", FDOxFld(Extension, "AttributeMemoryBase"));
      dprintf("  Memory window size  0x%x\n", (ULONG) FDOxFld(Extension, "AttributeMemorySize"));
      dprintf("  DeviceDispatchIndex %x\n", (ULONG) FDOxFld(Extension, "DeviceDispatchIndex"));
      dprintf("  PCCard Ready Delay Iterations 0x%x (%d)\n",
              (ULONG) FDOxFld(Extension, "ReadyDelayIter"), (ULONG) FDOxFld(Extension, "ReadyDelayIter"));
      dprintf("  PCCard Ready Stall in usecs   0x%x (%d)\n",
              (ULONG) FDOxFld(Extension, "ReadyStall"), (ULONG) FDOxFld(Extension, "ReadyStall"));

      dprintf("  Number of sockets powered up        %d\n",
              (ULONG) FDOxFld(Extension, "NumberOfSocketsPoweredUp"));
      DumpDevicePowerState((ULONG) FDOxFld(Extension, "DevicePowerState"));
      DumpSystemPowerState((ULONG) FDOxFld(Extension, "SystemPowerState"));

      //
      // Pending wait wake irp
      //
      dprintf("  WaitWakeIrp: %p\n", FDOxFld(Extension, "WaitWakeIrp"));

      //
      // Dump saved register context
      //
      dprintf("  PCI     Context range, buffer: %p(%d), %p\n",
              FDOxFld(Extension, "PciContext.Range"), (ULONG) FDOxFld(Extension, "PciContext.RangeCount"),
              FDOxFld(Extension, "PciContextBuffer"));
      dprintf("  Cardbus Context range: %p(%d)\n",
              FDOxFld(Extension, "CardbusContext.Range"), (ULONG) FDOxFld(Extension, "CardbusContext.RangeCount"));
      dprintf("  Exca    Context range: %p(%d)\n",
              FDOxFld(Extension, "ExcaContext.Range"), (ULONG) FDOxFld(Extension, "ExcaContext.RangeCount"));

      //
      // Dump capabilities
      //
      dprintf("  DeviceCapabilities (at 0x%p): \n", (Capabilities = FDOxFld(Extension, "Capabilities")));
      if (Capabilities != 0) {
          DumpDeviceCapabilities(Capabilities);
      }
   }
}

DECLARE_API( socket )

/*++

Routine Description:

    Dump a socket

Arguments:

    args - the location of the socket to dump

Return Value:

    None

--*/
{
    ULONG64 socketAddr=0;
    ULONG   depth, status;

    socketAddr = GetExpression(args);

    if (ReadMemory(socketAddr, &depth, sizeof(depth), &status)) {
        dprintf("Socket at %p:\n", socketAddr);
        DumpSocket(socketAddr, 0);
    } else {
        dprintf("Could not read socket at %p\n", socketAddr);
    }
    return S_OK;
}

VOID
DumpFlagsBrief(ULONG Flags)
{
    if (Flags & PCMCIA_DEVICE_STARTED) {
        dprintf(" ST");
    } else {
        dprintf(" NS");
    }

    if (Flags & PCMCIA_DEVICE_LOGICALLY_REMOVED) {
        dprintf(" RM");
    }
    if (Flags & PCMCIA_DEVICE_PHYSICALLY_REMOVED) {
        dprintf(" EJ");
    }
    if (Flags & PCMCIA_DEVICE_DELETED) {
        dprintf(" DL");
    }
    if (Flags & PCMCIA_DEVICE_MULTIFUNCTION) {
        dprintf(" MF");
    }
    if (Flags & PCMCIA_DEVICE_WAKE_PENDING) {
        dprintf(" WP");
    }
    if (Flags & PCMCIA_DEVICE_LEGACY_DETECTED) {
        dprintf(" LD");
    }
    if (Flags & PCMCIA_DEVICE_CARDBUS) {
        dprintf(" CB");
    }
}


DECLARE_API( pcmcia )

/*++

Routine Description:

    Dumps overview of pcmcia driver state

Arguments:

    args - the location of the socket to dump

Return Value:

    None

--*/
{
   ULONG64 addr;
   ULONG64 fdoDevObj, pdoDevObj, pSocket;
   ULONG64 Extension;
   ULONG Count = 0, off;
   UCHAR deviceId[PCMCIA_MAXIMUM_DEVICE_ID_LENGTH];

   if (args[0] != '\0') {
      dprintf("!pcmcia - dumps general pcmcia driver state\n\n");
      dprintf("flag descriptions:\n");
      dprintf(" ST - Started\n");
      dprintf(" NS - Not Started\n");
      dprintf(" RM - Logically Removed\n");
      dprintf(" EJ - Physically Ejected\n");
      dprintf(" DL - Deleted\n");
      dprintf(" MF - MultiFunction\n");
      dprintf(" WP - Wake Pending\n");
      dprintf(" LD - Legacy Detected\n");
      dprintf(" CB - CardBus\n");
   }


   addr = GetExpression( "pcmcia!fdolist" );

   if (addr == 0) {
      dprintf("Error retrieving address of pcmcia!fdolist\n");
      return E_INVALIDARG;
   }

   if (!ReadPointer(addr, &fdoDevObj)) {
      dprintf("Failed to read fdolist at %08p, giving up.\n", addr);
      return E_INVALIDARG;
   }

   GetFieldOffset("nt!_DEVICE_OBJECT", "DeviceExtension", &off);

   while(fdoDevObj) {
       ULONG64 NextFdo;
       ULONG64 CbReg;

       if (CheckControlC()) {
           break;
       }

       if (!ReadPointer(fdoDevObj+off,&Extension)) {
           dprintf("Failed to read fdo extension address at %08p, giving up.\n", fdoDevObj+off);
           return E_INVALIDARG;
       }

       if (GetFieldValue(Extension, "pcmcia!FDO_EXTENSION", "NextFdo", NextFdo)) {
           dprintf("GetFieldValue failed for fdo extension at %08p, giving up.\n", Extension);
           return E_INVALIDARG;
       }

       dprintf("\nFDO %.8p ext %.8p\n", fdoDevObj, Extension);

       if (GetFieldValue(Extension, "pcmcia!FDO_EXTENSION", "CardBusSocketRegisterBase", CbReg)) {
           dprintf("GetFieldValue failed for fdo extension at %08p, giving up.\n", Extension);
           return E_INVALIDARG;
       }

       if (CbReg) {
          dprintf("    CbReg %.8p\n\n", CbReg);
       } else {
          dprintf("\n");
       }

       //
       // Print list of PDOs enumerated by this FDO
       //

      pdoDevObj = FDOxFld(Extension, "PdoList");
      pSocket = FDOxFld(Extension, "SocketList");
      if (!pdoDevObj) {
          xdprintf(2, "*no PDO's enumerated*\n");
      } else {
         xdprintf(2, "pdolist:");
      }
      while(pdoDevObj) {
         if (CheckControlC()) {
            break;
         }
         if (!ReadPointer(pdoDevObj+off,&Extension)) {
            return E_INVALIDARG;
         }
         dprintf("  %.8p", pdoDevObj);
         pdoDevObj = PDOxFld(Extension, "NextPdoInFdoChain");
      }
      dprintf("\n");

      //
      // Print list of sockets
      //

      if (!pSocket) {
         xdprintf(2, "*no sockets!*\n");
      }
      while(pSocket) {
          ULONG64 NextSocket;
          ULONG SocketNumber;
          if (CheckControlC()) {
              break;
          }

          if (GetFieldValue(pSocket, "pcmcia!SOCKET", "NextSocket", NextSocket)) {
              return E_INVALIDARG;
          }

          dprintf("  Socket %.8p\n", pSocket);
          dprintf("   base %.8p", SocFld(pSocket, "AddressPort"));
          if (SocketNumber = (ULONG) SocFld(pSocket, "SocketNumber")) {
              dprintf(".%d", SocketNumber);
          }
          dprintf("\n");

         //
         // Dump pdo's in socket list
         //
         pdoDevObj = SocFld(pSocket, "PdoList");
         if (!pdoDevObj) {
            xdprintf(3, "*empty*\n");
         }
         while(pdoDevObj) {
             ULONG64 DeviceId;
             ULONG status;

             if (CheckControlC()) {
                 break;
             }
             if (!ReadPointer(pdoDevObj + off,&Extension)) {
                 return E_INVALIDARG;
             }
             if (GetFieldValue(Extension, "pcmcia!PDO_EXTENSION", "DeviceId", DeviceId)) {
                 return E_INVALIDARG;
             }

             dprintf("   PDO %.8p ext %.8p", pdoDevObj, Extension);
             DumpFlagsBrief((ULONG) PDOxFld(Extension, "Flags"));
             dprintf("\n");

            if (DeviceId != 0) {
               ReadMemory(DeviceId, deviceId, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH, &status);
               dprintf("    %s\n", deviceId);
            }
            pdoDevObj = PDOxFld(Extension, "NextPdoInSocket");
         }

         pSocket = NextSocket;
      }

      fdoDevObj = NextFdo;
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\pnpexts.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    thermal

Abstract:

    WinDbg Extension Api

Author:

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "devnode.h"
#pragma hdrstop

DECLARE_API(locks);

BOOLEAN
DumpDeviceActionEntry(
    IN PDEBUG_CLIENT pDbgClient,
    IN ULONG64 Entry
    )
{
    ULONG64 deviceObject, requestType, requestArgument, module;
    ULONG typeId;
    CHAR name[MAX_PATH];

    dprintf("Dumping nt!_PI_DEVICE_REQUEST @ 0x%08p\n", Entry);

    if (GetFieldValue(Entry, "nt!_PI_DEVICE_REQUEST", "DeviceObject", deviceObject)) {

        dprintf("Error reading entry->DeviceObject (%#010p)\n", Entry);
        return FALSE;
    }

    if (GetFieldValue(Entry, "nt!_PI_DEVICE_REQUEST", "RequestType", requestType)) {

        dprintf("Error reading entry->RequestType (%#010p)\n", Entry);
        return FALSE;
    }

    if (ExtQuery(pDbgClient) != S_OK) {

        dprintf("Could not query debugger information\n");
        return FALSE;
    }

    if (g_ExtSymbols->GetSymbolTypeId("nt!_DEVICE_REQUEST_TYPE", &typeId, &module) != S_OK) {

        dprintf("Error reading name for request type\n");
        return FALSE;
    }

    if (g_ExtSymbols->GetConstantName(module, typeId, requestType, name, sizeof(name), NULL) != S_OK) {

        dprintf("Error reading name for request type\n");
        return FALSE;
    }
    
    dprintf("\tRequest to %s", name);

    if (deviceObject) {

        dprintf(" !devstack %08p\n", deviceObject);
    } else {

        dprintf("\n");
    }

    if (GetFieldValue(Entry, "nt!_PI_DEVICE_REQUEST", "RequestArgument", requestArgument)) {

        dprintf("Error reading entry->RequestType (%#010p)\n", Entry);
        return FALSE;
    }

    dprintf("\tArgument - %08p\n", requestArgument);

    ExtRelease();

    return TRUE;
}

DECLARE_API(pnpaction)

/*++

Routine Description:

    Dumps device action queue.

Arguments:

    args - Verbosity.

Return Value:

    None

--*/

{
    ULONG64 deviceActionListAddress, enumerationInProgressAddress;
    ULONG64 link, deviceActionEntry;
    ULONG offset, dummy;
    BOOLEAN enumerationInProgress;
    
    enumerationInProgressAddress = GetExpression("nt!PipEnumerationInProgress");
    if (enumerationInProgressAddress == 0) {

        dprintf("Error retrieving address of nt!PipEnumerationInProgress\n");
        return E_INVALIDARG;
    }

    enumerationInProgress = FALSE;
    if (!ReadMemory(enumerationInProgressAddress, &enumerationInProgress, sizeof(enumerationInProgress), &dummy)) {

        dprintf("Error retrieving value of nt!IopPnpEnumerationRequestList\n");
        return E_INVALIDARG;
    }

    deviceActionListAddress = GetExpression("nt!IopPnpEnumerationRequestList");

    if (deviceActionListAddress == 0) {

        dprintf("Error retrieving address of nt!IopPnpEnumerationRequestList\n");
        return E_INVALIDARG;
    }

    dprintf("\n********************************************************************************\n");
    dprintf("Dumping PnP DeviceAction Queue @ 0x%08p\n", deviceActionListAddress);
    dprintf("********************************************************************************\n\n");

    if (GetFieldValue(deviceActionListAddress, "nt!_LIST_ENTRY", "Flink", link)) {

        dprintf("Error reading IopPnpEnumerationRequestList.Flink (%#010p)\n", deviceActionListAddress);
        return E_INVALIDARG;
    }

    if (GetFieldOffset("nt!_PI_DEVICE_REQUEST", "ListEntry", &offset)) {

        dprintf("Cannot find nt!_PI_DEVICE_REQUEST type.\n");
        return E_INVALIDARG;
    }

    while (link != deviceActionListAddress && CheckControlC() == FALSE) {

        
        deviceActionEntry = link - offset; //  CONTAINING_RECORD(link, PI_DEVICE_REQUEST, ListEntry);

        if (!DumpDeviceActionEntry(Client, deviceActionEntry)) {

            return E_INVALIDARG;
        }

        if (GetFieldValue(deviceActionEntry, "nt!_PI_DEVICE_REQUEST", "ListEntry.Flink", link)) {

            dprintf("Error reading deviceRequest->ListEntry.Flink (%#010p)\n", deviceActionEntry);
            return E_INVALIDARG;
        }
    }

    if (enumerationInProgress) {

        dprintf("PnP DeviceActionWorker active!\n\n");
    }

    return S_OK;
}

DECLARE_API(pnptriage)

/*++

Routine Description:

    Helps triage PnP issues (mostly stress).

Arguments:

    args - Stress or otherwise.

Return Value:

    None

--*/

{
    //
    // Dump the PnP device action queue.
    // 
    if (pnpaction(Client, "") == S_OK) {

        //
        // Dump the PnP event queue.
        //
        if (pnpevent(Client, "") == S_OK) {

            //
            // Dump devnodes with problems.
            //
            dprintf("\n********************************************************************************\n");
            dprintf("Dumping devnodes with problems...\n");
            dprintf("********************************************************************************\n\n");
            devnode(Client, "0 21");

            //
            // Dump our locks.
            //
            dprintf("\n********************************************************************************\n");
            dprintf("Dumping PnP locks...\n");
            dprintf("********************************************************************************\n\n");

            locks(Client, "nt!PiEngineLock");
            locks(Client, "nt!IopDeviceTreeLock");
            locks(Client, "nt!PpRegistryDeviceResource");

            dprintf("\n********************************************************************************\n");
            dprintf("If NOT available, do !thread on the owner thread to find the thread hung in PnP\n");
            dprintf("********************************************************************************\n\n");
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\physical.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    physical.c

Abstract:

    WinDbg Extension Api

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


/*++

Routine Description:

    Reverse sign extension of the value returned by GetExpression()
    based on the assumption that no physical address may be bigger 
    than 0xfffffff00000000.

Arguments:

    Val - points to the value to reverse sign extension

Return Value:

    None.

--*/

void
ReverseSignExtension(ULONG64* Val)
{
    if ((*Val & 0xffffffff00000000) == 0xffffffff00000000) 
    {
        *Val &= 0x00000000ffffffff;
    }
}


DECLARE_API( chklowmem )

/*++

Routine Description:

    Calls an Mm function that checks if the physical pages
    below 4Gb have a required fill pattern for PAE systems
    booted with /LOWMEM switch.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER (args);
    UNREFERENCED_PARAMETER (Client);

    dprintf ("Checking the low 4GB of RAM for required fill pattern. \n");
    dprintf ("Please wait (verification takes approx. 20s) ...\n");

    Ioctl (IG_LOWMEM_CHECK, NULL, 0);

    dprintf ("Lowmem check done.\n");
    return S_OK;
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////// !search
/////////////////////////////////////////////////////////////////////

#define SEARCH_HITS 8192

ULONG64 g_SearchHits[SEARCH_HITS];

//
//  Kernel variable modification functions.
//
            
ULONG 
READ_ULONG (
    ULONG64 Address
    );

VOID
WRITE_ULONG (
    ULONG64 Address,
    ULONG Value
    );

ULONG64
READ_PVOID (
    ULONG64 Address
    );


ULONG
READ_PHYSICAL_ULONG (
    ULONG64 Address
    );

ULONG64
READ_PHYSICAL_ULONG64 (
    ULONG64 Address
    );


ULONG64
SearchGetSystemMemoryDescriptor (
    );

ULONG64
SearchConvertPageFrameToVa (
    ULONG64 PageFrameIndex,
    PULONG Flags,
    PULONG64 PteAddress
    );

#define SEARCH_VA_PROTOTYPE_ADDRESS     0x0001
#define SEARCH_VA_NORMAL_ADDRESS        0x0002
#define SEARCH_VA_LARGE_PAGE_ADDRESS    0x0004
#define SEARCH_VA_UNKNOWN_TYPE_ADDRESS  0x0008
#define SEARCH_VA_SUPER_PAGE_ADDRESS    0x0010

//
// PAE independent functions from p_i386\pte.c
//

ULONG64
DbgGetPdeAddress(
    IN ULONG64 VirtualAddress
    );

ULONG64
DbgGetPteAddress(
    IN ULONG64 VirtualAddress
    );

#define BANG_SEARCH_HELP \
"\n\
!search ADDRESS [DELTA [START_PFN END_PFN]]                     \n\
                                                                \n\
Search the physical pages in range [START_PFN..END_PFN]         \n\
for ULONG_PTRs with values in range ADDRESS+/-DELTA or values   \n\
that differ in only one bit position from ADDRESS.              \n\
                                                                \n\
The default value for DELTA is 0. For START/END_PFN the default \n\
values are lowest physical page and highest physical page.      \n\
                                                                \n\
Examples:                                                       \n\
                                                                \n\
!search AABBCCDD 0A                                             \n\
                                                                \n\
    Search all physical memory for values in range AABBCCD3 -   \n\
    AABBCCE8 or with only one bit different than AABBCCDD.      \n\
                                                                \n\
!search AABBCCDD 0A 13F 240                                     \n\
                                                                \n\
    Search page frames in range 13F - 240 for values in range   \n\
    AABBCCD3 - AABBCCE8 or with only one bit different          \n\
    than AABBCCDD.                                              \n\
                                                                \n\
By default only the first hit in the page is detected. If all   \n\
hits within the page are needed the START_PFN and END_PFN       \n\
must have the same value.                                       \n\
                                                                \n\
Note that a search through the entire physical memory will find \n\
hits in the search engine structures. By doing a search with a  \n\
completely different value it can be deduced what hits can be   \n\
ignored.                                                      \n\n"

        
//
// Comment this to get verbose output.
//
// #define _INTERNAL_DEBUG_
//


DECLARE_API( search )

/*++

Routine Description:

    This routine triggers a search within a given physical
    memory range for a pointer. The hits are defined by
    an interval (below and above the pointer value) and also
    by a Hamming distance equal to one (only one bit different).

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    ULONG64 ParamAddress;
    ULONG64 ParamDelta;
    ULONG64 ParamStart;
    ULONG64 ParamEnd;

    ULONG64 MmLowestPhysicalPage;
    ULONG64 MmHighestPhysicalPage;

    ULONG64 PageFrame;
    ULONG64 StartPage;
    ULONG64 EndPage;
    ULONG64 RunStartPage;
    ULONG64 RunEndPage;
    ULONG RunIndex;

    BOOLEAN RequestForInterrupt;
    BOOLEAN RequestAllOffsets;
    ULONG Hits;
    ULONG Index;
    ULONG64 PfnHit;
    ULONG64 VaHit;
    ULONG VaFlags;
    ULONG PfnOffset;
    ULONG64 AddressStart;
    ULONG64 AddressEnd;
    ULONG DefaultRange;
    ULONG64 MemoryDescriptor;
    ULONG64 PageCount, BasePage, NumberOfPages;
    ULONG   NumberOfRuns;
    POINTER_SEARCH_PHYSICAL PtrSearch;

    ULONG   SizeOfPfnNumber = 0;
    ULONG64 PteAddress;

    UNREFERENCED_PARAMETER (Client);

    SizeOfPfnNumber = GetTypeSize("nt!PFN_NUMBER");

    if (SizeOfPfnNumber == 0) {
        dprintf ("Search: cannot get size of PFN_NUMBER \n");
        return E_INVALIDARG;
    }

    RequestForInterrupt = FALSE;
    RequestAllOffsets = FALSE;
    DefaultRange = 128;

    ParamAddress = 0;
    ParamDelta = 0;
    ParamStart = 0;
    ParamEnd = 0;
    
    //
    // Help requested ?
    //

    if (strstr (args, "?") != 0) {

        dprintf (BANG_SEARCH_HELP);
        return S_OK;
        
    }
    
    //
    // Get command line arguments.
    //

    {
        PCHAR Current = (PCHAR)args;
        CHAR Buffer [64];
        ULONG BufferIndex;

        //
        // Get the 4 numeric arguments.
        //

        for (Index = 0; Index < 4; Index++) {

            //
            // Get rid of any leading spaces.
            //

            while (*Current == ' ' || *Current == '\t') {
                Current++;
            }
            
            if (*Current == 0) {

                if (Index == 0) {
                    
                    dprintf (BANG_SEARCH_HELP);
                    return E_INVALIDARG;
                }
                else {

                    break;
                }
            }

            //
            // Get the digits from the Index-th parameter.
            //

            Buffer [0] = '0';
            Buffer [1] = 'x';
            BufferIndex = 2;

            while ((*Current >= '0' && *Current <= '9')
                   || (*Current >= 'a' && *Current <= 'f')
                   || (*Current >= 'A' && *Current <= 'F')) {
                
                Buffer[BufferIndex] = *Current;
                Buffer[BufferIndex + 1] = 0;

                Current += 1;
                BufferIndex += 1;
            }

            switch (Index) {
                
                case 0: ParamAddress = GetExpression(Buffer); break;
                case 1: ParamDelta = GetExpression(Buffer); break;
                case 2: ParamStart = GetExpression(Buffer); break;
                case 3: ParamEnd = GetExpression(Buffer); break; 

                default: 
                        dprintf (BANG_SEARCH_HELP);
                        return E_INVALIDARG;
            }
        }
    }

    //
    // Read physical memory limits.
    //

    MmLowestPhysicalPage =  GetExpression ("nt!MmLowestPhysicalPage");
    MmHighestPhysicalPage =  GetExpression ("nt!MmHighestPhysicalPage");

#ifdef _INTERNAL_DEBUG_

    dprintf ("Low: %I64X, High: %I64X \n", 
             READ_PVOID (MmLowestPhysicalPage),
             READ_PVOID (MmHighestPhysicalPage));


#endif // #ifdef _INTERNAL_DEBUG_

    //
    // Figure out proper search parameters.
    //

    if (ParamStart == 0) {
        StartPage = READ_PVOID (MmLowestPhysicalPage);
        ParamStart = StartPage;
    }
    else {
        StartPage = ParamStart;
    }

    if (ParamEnd == 0) {
        EndPage = READ_PVOID (MmHighestPhysicalPage);
        ParamEnd = EndPage;
    }
    else {
        EndPage = ParamEnd;
    }

    //
    // Set range of addresses that we want to be searched.
    //

    AddressStart = ParamAddress - ParamDelta;
    AddressEnd = ParamAddress + ParamDelta;

    PtrSearch.PointerMin = AddressStart;
    PtrSearch.PointerMax = AddressEnd;
    PtrSearch.MatchOffsets = g_SearchHits;
    PtrSearch.MatchOffsetsSize = SEARCH_HITS;

    if (SizeOfPfnNumber == 8) {
        
        dprintf ("Searching PFNs in range %016I64X - %016I64X for [%016I64X - %016I64X]\n\n", 
                 StartPage, EndPage, AddressStart, AddressEnd);
        dprintf ("%-16s %-8s %-16s %-16s %-16s \n", "Pfn","Offset", "Hit", "Va", "Pte");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - ");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    }
    else {

        dprintf ("Searching PFNs in range %08I64X - %08I64X for [%08I64X - %08I64X]\n\n", 
                 StartPage, EndPage, AddressStart, AddressEnd);
        dprintf ("%-8s %-8s %-8s %-8s %-8s \n", "Pfn","Offset", "Hit", "Va", "Pte");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    }
    
    //
    // Get system memory description to figure out what ranges
    // should we skip. This is important for sparse PFN database
    // and for pages managed by drivers.
    //

    MemoryDescriptor = SearchGetSystemMemoryDescriptor ();

    if (MemoryDescriptor == 0) {
        dprintf ("Search error: cannot allocate system memory descriptor \n");
        return E_INVALIDARG;
    }

    //
    // Search all physical memory in the specified range.
    //

    if (StartPage == EndPage) {

        EndPage += 1;
        RequestAllOffsets = TRUE;
    }

    //
    // Find out what pages are physically available create
    // page search ranges based on that.
    //
    // SilviuC: I should use ReadField to read all these structures
    // so that I do not have to take into account padding myself.
    //

    NumberOfRuns = READ_ULONG (MemoryDescriptor);
    NumberOfPages = READ_PVOID (MemoryDescriptor + SizeOfPfnNumber);

#ifdef _INTERNAL_DEBUG_

    dprintf ("Runs: %x, Pages: %I64X \n", NumberOfRuns, NumberOfPages);

    for (RunIndex = 0; RunIndex < NumberOfRuns; RunIndex += 1) {

        ULONG64 RunAddress;

        RunAddress = MemoryDescriptor + 2 * SizeOfPfnNumber
            + RunIndex * GetTypeSize("nt!_PHYSICAL_MEMORY_RUN");

        BasePage = READ_PVOID (RunAddress);
        PageCount = READ_PVOID (RunAddress + SizeOfPfnNumber);

        dprintf ("Run[%d]: Base: %I64X, Count: %I64X \n",
            RunIndex, BasePage, PageCount);
    }
#endif // #if _INTERNAL_DEBUG_

#ifdef _INTERNAL_DEBUG_
    dprintf ("StartPage: %I64X, EndPage: %I64X \n", StartPage, EndPage);
#endif // #ifdef _INTERNAL_DEBUG_

    for (PageFrame = StartPage; PageFrame < EndPage; PageFrame += DefaultRange) {

        for (RunIndex = 0; RunIndex < NumberOfRuns; RunIndex += 1) {
            
            //
            // BaseAddress and PageCount for current memory run.
            //

            ULONG64 RunAddress;

#ifdef _INTERNAL_DEBUG_
            // dprintf ("Finding a good range ... \n");
#endif // #ifdef _INTERNAL_DEBUG_

            RunAddress = MemoryDescriptor + 2 * SizeOfPfnNumber
                + RunIndex * GetTypeSize("nt!_PHYSICAL_MEMORY_RUN");

            BasePage = READ_PVOID (RunAddress);
            PageCount = READ_PVOID (RunAddress + SizeOfPfnNumber);

            //
            // Figure out real start and end page.
            //

            RunStartPage = PageFrame;
            RunEndPage = PageFrame + DefaultRange;

            if (RunEndPage <= BasePage) {
                continue;
            }
            
            if (RunStartPage >= BasePage + PageCount) {
                continue;
            }
            
            if (RunStartPage < BasePage) {
                RunStartPage = BasePage;
            }

            if (RunEndPage > BasePage + PageCount) {
                RunEndPage = BasePage + PageCount;
            }

            PtrSearch.Offset = (ULONG64)RunStartPage * PageSize;

            if (RequestAllOffsets) {

                //
                // If the search is in only one page then we
                // will try to get all offsets with a hit.
                //

                PtrSearch.Length = PageSize;
                PtrSearch.Flags = PTR_SEARCH_PHYS_ALL_HITS;
            }
            else {

                PtrSearch.Length = (ULONG64)
                    (RunEndPage - RunStartPage) * PageSize;
                PtrSearch.Flags = 0;
            }

#ifdef _INTERNAL_DEBUG_
            dprintf ("Start: %I64X, End: %I64X \n", 
                     PtrSearch.Offset,
                     PtrSearch.Offset + PtrSearch.Length);
#endif // #if _INTERNAL_DEBUG_

            PtrSearch.MatchOffsetsCount = 0;
            
            Ioctl (IG_POINTER_SEARCH_PHYSICAL, &PtrSearch, sizeof(PtrSearch));

            //
            // Display results
            //

            Hits = PtrSearch.MatchOffsetsCount;

            for (Index = 0; Index < Hits; Index++) {

                PCHAR VaString = "";

                VaFlags = 0;

                PfnHit = g_SearchHits[Index] / PageSize;
                PfnOffset = (ULONG)(g_SearchHits[Index] & (PageSize - 1));
                VaHit = SearchConvertPageFrameToVa (PfnHit, &VaFlags, &PteAddress);

                // dprintf ("Hits: %u, Index: %u, Va: %I64X \n", Hits, Index, VaHit);

#if DBG
                if ((VaFlags & SEARCH_VA_NORMAL_ADDRESS)) {
                    VaString = ""; // "normal";
                }
                else if ((VaFlags & SEARCH_VA_LARGE_PAGE_ADDRESS)) {
                    VaString = "large page";
                }
                else if ((VaFlags & SEARCH_VA_PROTOTYPE_ADDRESS)) {
                    VaString = "prototype";
                }
                else if ((VaFlags & SEARCH_VA_UNKNOWN_TYPE_ADDRESS)) {
                    VaString = "unknown";
                }
                else if ((VaFlags & SEARCH_VA_SUPER_PAGE_ADDRESS)) {
                    VaString = "super page";
                }
#endif // #if DBG

                if (SizeOfPfnNumber == 8) {
                    
                    dprintf ("%016I64X %08X %016I64X %016I64X %016I64X %s\n", 
                             PfnHit,
                             PfnOffset, 
                             READ_PHYSICAL_ULONG64 (PfnHit * PageSize + PfnOffset),
                             (VaHit == 0 ? 0 : VaHit + PfnOffset), 
                             PteAddress,
                             VaString);
                }
                else {

                    VaHit &= (ULONG64)0xFFFFFFFF;
                    PteAddress &= (ULONG64)0xFFFFFFFF;
                    
                    dprintf ("%08I64X %08X %08X %08I64X %08I64X %s\n", 
                             PfnHit,
                             PfnOffset, 
                             READ_PHYSICAL_ULONG (PfnHit * PageSize + PfnOffset),
                             (VaHit == 0 ? 0 : VaHit + PfnOffset), 
                             PteAddress,
                             VaString);
                }
            }

            //
            // check for ctrl-c
            //

            if (CheckControlC()) {

                dprintf ("Search interrupted. \n");
                RequestForInterrupt = TRUE;
                break;
            }
        }

        if (RequestForInterrupt) {
            break;
        }
    }
    
    if (RequestForInterrupt) {
        
        return E_INVALIDARG;
    }
    else {

        dprintf ("Search done.\n");
    }
    return S_OK;
}

ULONG64
SearchGetSystemMemoryDescriptor (
    )
/*++

Routine Description:


Arguments:

    None.
    
Return Value:

    A malloc'd PHYSICAL_MEMORY_DESCRIPTOR structure.
    Caller is responsible of freeing.

Environment:

    Call triggered only from !search Kd extension.

--*/

{
    ULONG64 MemoryDescriptorAddress;
    ULONG NumberOfRuns;

    MemoryDescriptorAddress = READ_PVOID (GetExpression ("nt!MmPhysicalMemoryBlock"));
    NumberOfRuns = READ_ULONG (MemoryDescriptorAddress);

    if (NumberOfRuns == 0) {
        return 0;
    }

    return MemoryDescriptorAddress;
}



ULONG64 
SearchConvertPageFrameToVa (
    ULONG64 PageFrameIndex,
    PULONG  Flags,
    PULONG64 PteAddress
    )
/*++

Routine Description:

    This routine returnes the virtual address corresponding to a 
    PFN index if the reverse mapping is easy to figure out. For all
    other cases (e.g. prototype PTE) the result is null.

Arguments:

    PageFrameIndex - PFN index to convert.

Return Value:

    The corresponding virtual address or null in case the PFN index
    cannot be easily converted to a virtual address.

Environment:

    Call triggered only from Kd extension.

--*/

{
    ULONG64 Va;
    ULONG64 PfnAddress;
    ULONG BytesRead;
    MMPFNENTRY u3_e1;

    //
    // On IA64, if the physical address lies within KSEG0
    // it's part of a superpage mapping and the virtual
    // address should be computed directly from the KSEG0 base.
    //

    if (TargetMachine == IMAGE_FILE_MACHINE_IA64) {
        
        UCHAR SuperPageEnabled;

        SuperPageEnabled = (UCHAR) GetUlongValue ("nt!MiKseg0Mapping");
        if (SuperPageEnabled & 0x1) {

            ULONG64 Kseg0Start;
            ULONG64 Kseg0StartFrame;
            ULONG64 Kseg0EndFrame;

            Kseg0Start = GetPointerValue ("nt!MiKseg0Start");
            Kseg0StartFrame = GetPointerValue ("nt!MiKseg0StartFrame");
            Kseg0EndFrame = GetPointerValue ("nt!MiKseg0EndFrame");

            if (PageFrameIndex >= Kseg0StartFrame &&
                PageFrameIndex <= Kseg0EndFrame) {

                *Flags = SEARCH_VA_SUPER_PAGE_ADDRESS;
                // There is no corresponding PTE.
                *PteAddress = 0;
                return Kseg0Start +
                    (PageFrameIndex - Kseg0StartFrame) * PageSize;
            }
        }
    }
    
    //
    // Get address of PFN structure
    //

    PfnAddress = READ_PVOID (GetExpression("nt!MmPfnDatabase"))
        + PageFrameIndex * GetTypeSize("nt!_MMPFN");

    BytesRead = 0;
    *Flags = 0;
    
    InitTypeRead(PfnAddress, nt!_MMPFN);

    //
    // (SilviuC): should check if MI_IS_PFN_DELETED(Pfn) is on.
    //
    
    //
    // Try to figure out Va if possible.
    //

    *PteAddress = ((ULONG64)ReadField (PteAddress));
    GetFieldValue(PfnAddress, "nt!_MMPFN", "u3.e1", u3_e1);
    
    if (u3_e1.PrototypePte) {

        *Flags |= SEARCH_VA_PROTOTYPE_ADDRESS;
        return 0;
    }

    Va = DbgGetVirtualAddressMappedByPte (*PteAddress);

    *Flags |= SEARCH_VA_NORMAL_ADDRESS;
    return Va;        
}

//
// Read/write functions
//

ULONG 
READ_ULONG (
    ULONG64 Address
    )
{
    ULONG Value = 0;
    ULONG BytesRead;

    if (! ReadMemory (Address, &Value, sizeof Value, &BytesRead)) {
        dprintf ("Search: READ_ULONG error \n");
    }

    return Value;
}

VOID
WRITE_ULONG (
    ULONG64 Address,
    ULONG Value
    )
{
    ULONG BytesWritten; 

    if (! WriteMemory (Address, &Value, sizeof Value, &BytesWritten)) {
        dprintf ("Search: WRITE_ULONG error \n");
    }
}
            
ULONG64
READ_PVOID (
    ULONG64 Address
    )
{
    ULONG64 Value64 = 0;

    if (!ReadPointer(Address, &Value64)) {
        dprintf ("Search: READ_PVOID error \n");
    }
    return Value64;
}

ULONG
READ_PHYSICAL_ULONG (
    ULONG64 Address
    )
{
    ULONG Value = 0;
    ULONG Bytes = 0;

    ReadPhysical (Address, &Value, sizeof Value, &Bytes);

    if (Bytes != sizeof Value) {
        dprintf ("Search: READ_PHYSICAL_ULONG error \n");
    }

    return Value;
}


ULONG64
READ_PHYSICAL_ULONG64 (
    ULONG64 Address
    )
{
    ULONG64 Value = 0;
    ULONG Bytes = 0;

    ReadPhysical (Address, &Value, sizeof Value, &Bytes);

    if (Bytes != sizeof Value) {
        dprintf ("Search: READ_PHYSICAL_ULONG64 error \n");
    }

    return Value;
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////// !searchpte
/////////////////////////////////////////////////////////////////////

DECLARE_API( searchpte )
{
    ULONG64 ParamAddress;
    ULONG64 ParamDelta;
    ULONG64 ParamStart;
    ULONG64 ParamEnd;

    ULONG64 MmLowestPhysicalPage;
    ULONG64 MmHighestPhysicalPage;

    ULONG64 PageFrame;
    ULONG64 StartPage;
    ULONG64 EndPage;
    ULONG64 RunStartPage;
    ULONG64 RunEndPage;
    ULONG RunIndex;

    BOOLEAN RequestForInterrupt = FALSE;
    ULONG Hits;
    ULONG LastHits;
    ULONG Index;
    ULONG64 PfnHit;
    ULONG64 VaHit;
    ULONG VaFlags;
    ULONG PfnOffset;
    ULONG PfnValue;
    ULONG64 AddressStart;
    ULONG64 AddressEnd;
    ULONG DefaultRange = 128;
    ULONG64 MemoryDescriptor;
    ULONG64 PageCount, BasePage, NumberOfPages;
    ULONG   NumberOfRuns;

    ULONG   SizeOfPfnNumber = 0;
    ULONG64 PteAddress;

    ULONG64 PfnSearchValue;
    ULONG NumberOfHits = 0;

    PULONG64 PfnHitsBuffer = NULL;
    ULONG PfnHitsBufferIndex = 0;
    ULONG PfnHitsBufferSize = 1024;
    ULONG PfnIndex;
    HRESULT Result;
    POINTER_SEARCH_PHYSICAL PtrSearch;

    SizeOfPfnNumber = GetTypeSize("nt!PFN_NUMBER");

    if (SizeOfPfnNumber == 0) {
        dprintf ("Search: cannot get size of PFN_NUMBER \n");
        Result = E_INVALIDARG;
        goto Exit;
    }

    ParamAddress = 0;
    
    //
    // Help requested ?
    //

    if (strstr (args, "?") != 0) {

        dprintf ("!searchpte FRAME(in hex)                                        \n");
        dprintf ("                                                                \n");
        return S_OK;
    }
    
    //
    // Get command line arguments.
    //

    if (!sscanf (args, "%I64X", &ParamAddress))
    {
        ParamAddress = 0;
    }

    PfnSearchValue = ParamAddress;
    
    dprintf ("Searching for PTEs containing PFN value %I64X ...\n", PfnSearchValue);

    //
    // Read physical memory limits.
    //

    MmLowestPhysicalPage =  GetExpression ("nt!MmLowestPhysicalPage");
    MmHighestPhysicalPage =  GetExpression ("nt!MmHighestPhysicalPage");

    //
    // Figure out proper search parameters.
    //

    StartPage = READ_PVOID (MmLowestPhysicalPage);
    ParamStart = StartPage;
    
    EndPage = READ_PVOID (MmHighestPhysicalPage);
    ParamEnd = EndPage;

    //
    // Set the range of addresses that we want searched.
    //

    AddressStart = PfnSearchValue;
    AddressEnd = PfnSearchValue;

    PtrSearch.PointerMin = PfnSearchValue;
    PtrSearch.PointerMax = PfnSearchValue;
    PtrSearch.MatchOffsets = g_SearchHits;
    PtrSearch.MatchOffsetsSize = SEARCH_HITS;

    if (SizeOfPfnNumber == 8) {

        dprintf ("Searching PFNs in range %016I64X - %016I64X \n\n", 
                 StartPage, EndPage);
        dprintf ("%-16s %-8s %-16s %-16s %-16s \n", "Pfn","Offset", "Hit", "Va", "Pte");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - ");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    }
    else {

        dprintf ("Searching PFNs in range %08I64X - %08I64X \n\n", 
                 StartPage, EndPage);
        dprintf ("%-8s %-8s %-8s %-8s %-8s \n", "Pfn","Offset", "Hit", "Va", "Pte");
        dprintf ("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
    }
    
    //
    // Get system memory description to figure out what ranges
    // should we skip. This is important for sparse PFN database
    // and for pages managed by drivers.
    //

    MemoryDescriptor = SearchGetSystemMemoryDescriptor ();

    if (MemoryDescriptor == 0) {
        dprintf ("Search error: cannot allocate system memory descriptor \n");
        Result = E_INVALIDARG;
        goto Exit;
    }

    //
    // Allocate hits buffer.
    //

    PfnHitsBuffer = (PULONG64) malloc (PfnHitsBufferSize * sizeof(ULONG64));

    if (PfnHitsBuffer == NULL) {
        dprintf ("Search error: cannot allocate hits buffer. \n");
        Result = E_INVALIDARG;
        goto Exit;
    }

    //
    // Find out what pages are physically available create
    // page search ranges based on that.
    //
    // SilviuC: I should use ReadField to read all these structures
    // so that I do not have to take into account padding myself.
    //

    NumberOfRuns = READ_ULONG (MemoryDescriptor);
    NumberOfPages = READ_PVOID (MemoryDescriptor + SizeOfPfnNumber);

    for (PageFrame = StartPage; PageFrame < EndPage; PageFrame += DefaultRange) {

        for (RunIndex = 0; RunIndex < NumberOfRuns; RunIndex += 1) {
            
            //
            // BaseAddress and PageCount for current memory run.
            //

            ULONG64 RunAddress;

            RunAddress = MemoryDescriptor + 2 * SizeOfPfnNumber
                + RunIndex * GetTypeSize("nt!_PHYSICAL_MEMORY_RUN");

            BasePage = READ_PVOID (RunAddress);
            PageCount = READ_PVOID (RunAddress + SizeOfPfnNumber);

            //
            // Figure out real start and end page.
            //

            RunStartPage = PageFrame;
            RunEndPage = PageFrame + DefaultRange;

            if (RunEndPage <= BasePage) {
                continue;
            }
            
            if (RunStartPage >= BasePage + PageCount) {
                continue;
            }
            
            if (RunStartPage < BasePage) {
                RunStartPage = BasePage;
            }

            if (RunEndPage > BasePage + PageCount) {
                RunEndPage = BasePage + PageCount;
            }

            PtrSearch.Offset = (ULONG64)RunStartPage * PageSize;
            PtrSearch.Length = (ULONG64)
                (RunEndPage - RunStartPage) * PageSize;
            PtrSearch.Flags = PTR_SEARCH_PHYS_PTE;
            PtrSearch.MatchOffsetsCount = 0;
            
            Ioctl (IG_POINTER_SEARCH_PHYSICAL, &PtrSearch, sizeof(PtrSearch));

            //
            // Display results
            //

            Hits = PtrSearch.MatchOffsetsCount;

            for (Index = 0; Index < Hits; Index++) {

                NumberOfHits += 1;

                dprintf (".");

                //
                // Add to hits buffer
                //

                PfnHit = g_SearchHits[Index] / PageSize;
                PfnHitsBuffer [PfnHitsBufferIndex] = PfnHit;
                PfnHitsBufferIndex += 1;

                if (PfnHitsBufferIndex >= PfnHitsBufferSize) {
                    PVOID NewBuffer;
                    
                    PfnHitsBufferSize *= 2;

                    NewBuffer = realloc (PfnHitsBuffer,
                                         PfnHitsBufferSize * sizeof(ULONG64));

                    if (NewBuffer == NULL) {
                        dprintf ("Search error: cannot reallocate hits buffer with size %u. \n",
                                 PfnHitsBufferSize);
                        Result = E_INVALIDARG;
                        goto Exit;
                    }

                    PfnHitsBuffer = NewBuffer;
                }
            }

            //
            // check for ctrl-c
            //

            if (CheckControlC()) {

                RequestForInterrupt = TRUE;
                break;
            }
        }

        if (RequestForInterrupt) {
            break;
        }
    }
    
    //
    // Now find all hits in all pages.
    //

    dprintf ("\n");
    dprintf ("Found %u pages with hits. \n", PfnHitsBufferIndex);
    dprintf ("Searching now for all hits in relevant pages ... \n");

    NumberOfHits = 0;

    for (PfnIndex = 0; 
         !RequestForInterrupt && PfnIndex < PfnHitsBufferIndex; 
         PfnIndex += 1) {

        PtrSearch.Offset = (ULONG64)PfnHitsBuffer[PfnIndex] * PageSize;
        PtrSearch.Length = PageSize;
        PtrSearch.Flags = PTR_SEARCH_PHYS_ALL_HITS | PTR_SEARCH_PHYS_PTE;
        PtrSearch.MatchOffsetsCount = 0;
            
        Ioctl (IG_POINTER_SEARCH_PHYSICAL, &PtrSearch, sizeof(PtrSearch));

        Hits = PtrSearch.MatchOffsetsCount;

        for (Index = 0; Index < Hits; Index++) {

            NumberOfHits += 1;

            PfnHit = g_SearchHits[Index] / PageSize;
            PfnOffset = (ULONG)(g_SearchHits[Index] & (PageSize - 1));
            VaHit = SearchConvertPageFrameToVa (PfnHit, &VaFlags, &PteAddress);

            if (SizeOfPfnNumber == 8) {

                dprintf ("%016I64X %08X %016I64X %016I64X %016I64X \n", 
                         PfnHit,
                         PfnOffset, 
                         READ_PHYSICAL_ULONG64 (PfnHit * PageSize + PfnOffset),
                         (VaHit == 0 ? 0 : VaHit + PfnOffset), 
                         PteAddress);
            }
            else {

                VaHit &= (ULONG64)0xFFFFFFFF;
                PteAddress &= (ULONG64)0xFFFFFFFF;

                dprintf ("%08I64X %08X %08X %08I64X %08I64X \n", 
                         PfnHit,
                         PfnOffset, 
                         READ_PHYSICAL_ULONG (PfnHit * PageSize + PfnOffset),
                         (VaHit == 0 ? 0 : VaHit + PfnOffset), 
                         PteAddress);
            }

            if (CheckControlC()) {
                RequestForInterrupt = TRUE;
                break;
            }
        }
    }

    dprintf ("\n");

    Result = S_OK;

    //
    // Exit point
    //

 Exit:

    if (PfnHitsBuffer) {
        free (PfnHitsBuffer);
    }

    if (! RequestForInterrupt) {
        
        dprintf ("Search done (%u hits in %u pages).\n", 
                 NumberOfHits,
                 PfnHitsBufferIndex);
    }
    else {
        
        dprintf ("Search interrupted. \n");
    }
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\pic.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pic.c

Abstract:

    WinDbg Extension Api

Author:

    Santosh Jodh (santoshj) 29-June-1998

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define PIC_MASTER_PORT0    0x20
#define PIC_MASTER_PORT1    0x21

#define PIC_SLAVE_PORT0     0xA0
#define PIC_SLAVE_PORT1     0xA1

#define ELCR_PORT0          0x4D0
#define ELCR_PORT1          0x4D1


VOID
ShowMask (
    ULONG  Mask
    )
{
    ULONG interrupt;
    
    for (   interrupt = 0;
            interrupt <= 0x0F;
            interrupt++)
    {
        if (Mask & (1 << interrupt))        
            dprintf("  Y");                    
        else
            dprintf("  .");
    }
    
    dprintf("\n");
}

BOOLEAN
GetPICStatus (
    UCHAR   Type,
    PULONG  Status
    )
{
    ULONG   size;
    ULONG   data;
    ULONG   mask;
    
    //
    // Send OCW3 to master.
    //
    
    size = 1;
    WriteIoSpace64(PIC_MASTER_PORT0, Type, &size);

    //
    // Read master's status.
    //
    
    data = 0;
    size = 1;
    ReadIoSpace64(PIC_MASTER_PORT0, &data, &size);
    if (size == 1)
    {
        //
        // Send OCW3 to slave.
        //
        
        mask = data;
        size = 1;
        WriteIoSpace64(PIC_SLAVE_PORT0, Type, &size);

        //
        // Get the slave's status.
        //
        
        data = 0;
        size = 1;
        ReadIoSpace64(PIC_SLAVE_PORT0, &data, &size);
        if (size == 1)
        {
            mask |= (data << 8);
            *Status = mask;

            return (TRUE);
        }
    }

    *Status = 0;
    
    return (FALSE);
}

BOOLEAN
GetELCRStatus(
    OUT PULONG Status
    )
{

    ULONG   data = 0;
    ULONG   size = 1;
    ULONG   mask = 0;

    *Status = 0;
     
    ReadIoSpace64(ELCR_PORT0, &data, &size);

    if (size == 1) {

        mask = data;

        ReadIoSpace64(ELCR_PORT1, &data, &size);

        if (size == 1) {

            mask |= (data << 8);
            *Status = mask;

            return TRUE;
        }

    }

    return FALSE;

}


DECLARE_API(pic)

/*++

Routine Description:

    Dumps PIC information.

Input Parameters:

    args - Supplies the options.

Return Value:

    None

--*/

{
    ULONG   data;
    ULONG   size;
    ULONG   mask;
    ULONG64 addr;
    UCHAR   halName[32];
    BOOL    dumpElcr=FALSE;


    // X86_ONLY_API
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("!pic is for X86 targets only.\n");
        return E_INVALIDARG;
    }

    if (strcmp(args, "-e")==0) {

        //
        //  Here we trust that the user knows this machine architecture
        //  such that the ELCR exists at these ports.
        //
        dumpElcr = TRUE;

    }else{

        //
        //  Now lets see what HAL we are running. Currently
        //  we can only dump the ELCR mask safely on ACPI (non-apic) machines
        //  as ACPI has defined static ports for this. 
        //
        addr = GetExpression("hal!HalName");
    
        if (addr == 0) {
            dprintf("Unable to use HAL symbols (hal!HalName), please verify symbols.\n");
            return E_INVALIDARG;
        }
    
        if (!xReadMemory(addr, halName, sizeof(halName))) {
            dprintf("Failed to read HalName from host memory, quitting.\n");
            return E_INVALIDARG;
        }
        
        halName[sizeof(halName)-1] = '\0';
    
        if (strcmp(halName, "ACPI Compatible Eisa/Isa HAL")==0) {
            
            dumpElcr = TRUE;
        }

    }

    //
    // Display the title.
    //
    dprintf("----- IRQ Number ----- 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n");

    //
    // Dump the Interrupt Service Register information.
    //
    dprintf("Physically in service:");
    
    if (GetPICStatus(0x0B, &mask))
    {
        ShowMask(mask);
    }
    else
    {
        dprintf("Error reading PIC!\n");
    }

    //
    // Dump the Interrupt Mask Register information.
    //
    dprintf("Physically masked:    ");

    data = 0;
    size = 1;
    ReadIoSpace64(PIC_MASTER_PORT1, &data, &size);
    if (size == 1)
    {
        mask = data;
        data = 0;
        size = 1;
        ReadIoSpace64(PIC_SLAVE_PORT1, &data, &size);
        if (size == 1)
        {
            mask |= (data << 8);
            ShowMask(mask);    
        }
        else
        {
            dprintf("Error reading PIC!\n");    
        }
    }
    else
    {
        dprintf("Error reading PIC!\n");    
    }

    
    //
    // Dump the Interrupt Request Register information.
    //
    dprintf("Physically requested: ");

    if (GetPICStatus(0x0A, &mask))
    {
        ShowMask(mask);
    }
    else
    {
        dprintf("Error reading PIC!\n");
    }

    
    if (dumpElcr) {
    
        //
        // Dump the Edge/Level Control Register information.
        //
        dprintf("Level Triggered:      ");
        
        if (GetELCRStatus(&mask)) {
    
            ShowMask(mask);
    
        }else{
    
            dprintf("Error reading ELCR!\n");
    
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\pmc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ia64 pmc

Abstract:

    KD Extension Api

Author:

    Thierry Fevrier (v-thief)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ia64.h"

// 
// EmPmcFields: EM register fields for the Performance Monitor Counter register.
//

EM_REG_FIELD EmGenPmcFields[] = {
        { "plm", "Privilege Level Mask"   , 0x4, 0 },   // 0-3
        { "ev",  "External Visibility"  , 0x1, 4 },   // 4
        { "oi",  "Overflow Interrupt", 0x1, 5 }, // 5
        { "pm",  "Privileged Monitor", 0x1, 6 }, // 6
        { "ig",  "ignored1", 0x1, 7 }, // 7
        { "es",  "Event Selection", 0x7, 8 }, // 8-14
        { "ig",  "ignored2", 0x1, 15 }, // 15
        { "umk", "Unit Mask",    0x4, 16 }, // 16-19
        { "thr", "Event Threshold", 0x3, 20 }, // 20-[21-22]
        { "ig",  "ignored3", 0x1, 23 }, // 23
        { "ism", "Instruction Set Mask", 0x2, 24 }, // 24-25
        { "ig",  "ignored4", 0x26, 26 } // 26-63
};

EM_REG_FIELD EmBtbPmcFields[] = {
        { "plm", "Privilege Level Mask", 0x4, 0 }, // 0-3
        { "ign", "ignored1", 0x2, 4 }, // 4-5
        { "pm" , "Privileged Monitor", 0x1, 6}, // 6
        { "tar", "Target Address Register", 0x1, 7 }, // 7
        { "tm" , "Taken Mask", 0x2, 8 }, // 8-9
        { "ptm", "Predicted Target Address Mask", 0x2, 10 }, // 10-11
        { "ppm", "Predicted Predicate Mask", 0x2, 12 }, // 12-13
        { "bpt", "Branch Prediction Table", 0x1, 14 }, // 14
        { "bac", "Branch Address Calculator", 0x1, 15 }, // 15
        { "ign", "ignored2", 0x30, 16 } // 16-63
};

EM_REG_FIELD EmBtbPmdFields[] = {
        { "b",   "Branch Bit", 0x1, 0 }, // 0
        { "mp",  "Mispredit Bit", 0x1, 1 }, // 1
        { "slt", "Instruction Slot", 0x2, 2}, // 2-3
        { "add", "Address", 0x3c, 4 } // 4-63
};

EM_REG_FIELD EmBtbIndexPmdFields[] = {
        { "bbi", "Branch Buffer Index", 0x3, 0 }, // 0-2
        { "ful", "Full Bit", 0x1, 3 }, // 3
        { "ign", "ignored", 0x3c, 4 } // 4-63
};

typedef
VOID
(*PDISPLAY_PMC)(
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    ); 

VOID
DisplayPmcIA64( 
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    )
{

    dprintf("%s0x%I64x\n", ( Header ? Header : " pmc: " ), PmcValue );
    return;

} // DisplayPmcIA64()

VOID
DisplayGenPmcIA64( 
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( PmcValue, EmGenPmcFields, DisplayMode );
    }
    else   {
        EM_PMC emPmc;

        emPmc = ULong64ToEM_PMC( PmcValue );
        dprintf(
            "plm ev oi pm es umk thr ism\n       "
            "%1I64x   %1I64x  %1I64x  %1I64x %2I64x  %1I64x   %1I64x   %1I64x\n",
            emPmc.plm,
            emPmc.ev,
            emPmc.oi,
            emPmc.pm,
            emPmc.es,
            emPmc.umask,
            emPmc.threshold,
            emPmc.ism
            );
    }
    return;
} // DisplayGenPmcIA64()

VOID
DisplayBtbPmcIA64( 
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( PmcValue, EmBtbPmcFields, DisplayMode );
    }
    else   {
        EM_BTB_PMC emPmc;

        emPmc = ULong64ToEM_BTB_PMC( PmcValue );
        dprintf(
            "plm pm tar tm ptm ppm bpt bac\n       "
            "%1I64x   %1I64x  %1I64x   %1I64x  %1I64x   %1I64x   %1I64x   %1I64x\n",
            emPmc.plm,
            emPmc.pm,
            emPmc.tar,
            emPmc.tm,
            emPmc.ptm,
            emPmc.ppm,
            emPmc.bpt,
            emPmc.bac
            );
    }
    return;
} // DisplayBtbPmcIA64()

VOID
DisplayBtbPmdIA64(
    IN const  PCHAR         Header,      // Header string displayed before pmc.
    IN        ULONG64       PmdValue,    // PMD value.
    IN        DISPLAY_MODE  DisplayMode  // Display mode.
    )
{
    

    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( PmdValue, EmBtbPmdFields, DisplayMode );
    }
    else    {
        EM_BTB_PMD btbPmd;
        ULONG64    brAddress;
    
        btbPmd    = ULong64ToEM_BTB_PMD( PmdValue );
#define ITANIUM_PA_ADDRESSING_MASK     0x80000FFFFFFFFFFFUI64 
#define ITANIUM_VA_ADDRESSING_MASK     0xE007FFFFFFFFFFFFUI64
#define ITANIUM_BTB_PMD_ADDRESS_MASK( _pmdValue) \
                    ( ((_pmdValue) & 0xfffffffffffffff0UI64) & ITANIUM_VA_ADDRESSING_MASK )

        brAddress = ITANIUM_BTB_PMD_ADDRESS_MASK( PmdValue );
        dprintf(
            "%1I64x  %1I64x    %1I64x 0x%016I64x ",
            btbPmd.b,
            btbPmd.mp,
            btbPmd.slot,
            brAddress
            );

#if 0
// Thierry 03/19/2001 - BUGBUG
// Itanium Processor Programmer's guide does not present the 
// PMD[8-15] branch/interrupt mode 2 formats.
// I am disabling this check until I can implement it correctly with a context
// that can distinguish between mode 1 and mode 2 at the time this history was created.
        if ( (btbPmd.b == 0) && (btbPmd.mp == 0)) {
            dprintf("<invalid entry>");
        }
        else 
#endif 
        {
            CCHAR    symbol[256];
            PCHAR    s;
            ULONG64  displacement;

            symbol[0] = '!';
            GetSymbol( brAddress, symbol, &displacement);
            s = (PCHAR)symbol + strlen( (PCHAR)symbol );
            if (s == (PCHAR)symbol ) {
                sprintf( s, (IsPtr64() ? "0x%016I64x" : "0x%08x"), brAddress );
            }
            else {
                if ( displacement ) {
                    sprintf( s, (IsPtr64() ? "+0x%I64x" : "+0x%x"), displacement );
                }
            }
            dprintf( "%s", symbol );
        }
        dprintf("\n");
    }

    return;

} // DisplayBtbPmdIA64()

VOID
DisplayBtbIndexPmdIA64(
    IN const PCHAR         Header,
    IN       ULONG64       PmcValue,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( PmcValue, EmBtbIndexPmdFields, DisplayMode );
    }
    else   {
        EM_BTB_INDEX_PMD emPmd;

        emPmd = ULong64ToEM_BTB_INDEX_PMD( PmcValue );
        dprintf(
            "bbi full\n             "
            "%1I64x    %1I64x\n",
            emPmd.bbi,
            emPmd.full
            );
    }
    return;
} // DisplayBtbIndexPmdIA64()

PDISPLAY_PMC
GetPmcDisplayFunction(
    char *Str
    )
{
    LONG pmc;
    char *c;

    c = Str;
    while( isalnum( (int)(*c) ) )   {
        c++;
    }
    *c = '\0';
    
    pmc = atol( Str );
    switch( pmc )   {
        case 4:
        case 5:
        case 6:
        case 7:
            return( (PDISPLAY_PMC)DisplayGenPmcIA64 );

        case 12:
            return( (PDISPLAY_PMC)DisplayBtbPmcIA64 );

        default:
            if ( !strcmp( Str, "gen" ) ) {
                return( (PDISPLAY_PMC)DisplayGenPmcIA64 ); 
            }
            if ( !strcmp( Str, "btb" ) ) {
                return( (PDISPLAY_PMC)DisplayBtbPmcIA64 );
            }
            return ( (PDISPLAY_PMC)DisplayPmcIA64 );
    }
    
} // IsPmcSupported()

DECLARE_API( pmc )

/*++

Routine Description:

    Dumps a IA-64 Processor PMC Register.
    // Thierry 11/2000: The following scheme could also be used for PMD registers.

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64       pmcValue   = 0;
    ULONG         result;
    ULONG         flags      = 0;
    char         *option     = NULL;
    PDISPLAY_PMC  displayPmc = DisplayGenPmcIA64;  // Default display function.
    char         *header;

    if ( TargetMachine != IMAGE_FILE_MACHINE_IA64 )
    {
        dprintf("!pmc not implemented for this architecture.\n");
        return S_OK;
    }

    option = strchr( args, '-' );
    if ( option ) {
        displayPmc = GetPmcDisplayFunction( ++option );
        args += (strlen(option) + 2);
    }
        
    result = sscanf(args,"%I64lx %lx", &pmcValue, &flags);
        if ((result != 1) && (result != 2)) {
        //
        // If user specified "@kpfc*"...
        //

        char kpfcStr[16];
        BOOLEAN valid = FALSE;

        result = sscanf(args,"%15s %lx", kpfcStr, &flags);
        if ( (result == 1) || (result == 2) )  {
            if ( option == NULL )   { // If we did not force the display format.
                char *str;

                str = strstr( kpfcStr, "@kpfc" );
                if ( str )      {
                    str += strlen("@kpfc");
                    displayPmc = GetPmcDisplayFunction( str );
                }
            }
        }
        else  {
            dprintf( "USAGE: !pmc [-opt] 0xValue [display_mode:0,1,2]\n"
                     "USAGE: !pmc @kpfc*         [display_mode:0,1,2]\n"
                     "where currently supported option:\n"
                     "\tgen [or 4,5,6,7] - generic PMC registers\n"
                     "\tbtb [or 12]      - branch trace buffer PMC register\n"
                     "\tEx: !pmc -btb @r2 2\n"
                   );
            return E_INVALIDARG;
        }      
        pmcValue = GetExpression(kpfcStr);
    }
    
    header = (flags > DISPLAY_MIN) ? NULL : " pmc: ";
    (*displayPmc)( header, pmcValue, flags );

    return S_OK;

} // !pmc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\pool.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pool.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (Loup) 5-Nov-1993

Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma)

    Using debugger type info.

--*/

#include "precomp.h"
#pragma hdrstop

#define TAG 0
#define NONPAGED_ALLOC 1
#define NONPAGED_FREE 2
#define PAGED_ALLOC 3
#define PAGED_FREE 4
#define NONPAGED_USED 5
#define PAGED_USED 6

BOOL  NewPool;
ULONG SortBy;

typedef struct _FILTER {
    ULONG Tag;
    BOOLEAN Exclude;
} FILTER, *PFILTER;

typedef struct _POOLTRACK_READ {
    ULONG64 Address;
    ULONG Key;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    ULONG PagedAllocs;
    ULONG PagedFrees;
    LONG64 NonPagedBytes;
    LONG64 PagedBytes;
} POOLTRACK_READ, *PPOOLTRACK_READ;

#define MAX_FILTER 64
FILTER Filter[MAX_FILTER];

ULONG64 SpecialPoolStart;
ULONG64 SpecialPoolEnd;
ULONG64 PoolBigTableAddress;


#define DecodeLink(Pool)    ( (ULONG64) (Pool & (ULONG64) ~1))

//
// Size of a pool page.
//
// This must be greater than or equal to the page size.
//

#define POOL_PAGE_SIZE          PageSize
#define MAX_POOL_HEADER_COUNT   (PageSize/SizeOfPoolHdr)

//
// The smallest pool block size must be a multiple of the page size.
//
// Define the block size as 32.
//


#define POOL_LIST_HEADS (POOL_PAGE_SIZE / (1 << POOL_BLOCK_SHIFT))



#define SPECIAL_POOL_BLOCK_SIZE(PoolHeader_Ulong1) (PoolHeader_Ulong1 & (MI_SPECIAL_POOL_VERIFIER - 1))

NTSTATUS
DiagnosePoolPage(
    ULONG64 PoolPageToDump
    );

#ifndef  _EXTFNS_H
// GetPoolTagDescription
typedef HRESULT
(WINAPI *PGET_POOL_TAG_DESCRIPTION)(
    ULONG PoolTag,
    PSTR *pDescription
    );
#endif

ULONG64
GetSpecialPoolHeader (
                     IN PVOID     pDataPage,
                     IN ULONG64   RealDataPage,
                     OUT PULONG64 ReturnedDataStart
                     );

int __cdecl
ulcomp(const void *e1,const void *e2)
{
    PPOOLTRACK_READ p1, p2;
    ULONG u1;

    p1 = (PPOOLTRACK_READ) e1;
    p2 = (PPOOLTRACK_READ) e2;
    switch (SortBy) {
    case TAG:


        u1 = ((PUCHAR)&p1->Key)[0] - ((PUCHAR)&p2->Key)[0];
        if (u1 != 0) {
            return u1;
        }
        u1 = ((PUCHAR)&p1->Key)[1] - ((PUCHAR)&p2->Key)[1];
        if (u1 != 0) {
            return u1;
        }
        u1 = ((PUCHAR)&p1->Key)[2] - ((PUCHAR)&p2->Key)[2];
        if (u1 != 0) {
            return u1;
        }
        u1 = ((PUCHAR)&p1->Key)[3] - ((PUCHAR)&p2->Key)[3];
        return u1;

    case NONPAGED_ALLOC:
        if (p2->NonPagedAllocs == p1->NonPagedAllocs) {
            return 0;
        }
        if (p2->NonPagedAllocs > p1->NonPagedAllocs) {
            return 1;
        }
        return -1;

    case NONPAGED_FREE:
        if (p2->NonPagedFrees == p1->NonPagedFrees) {
            return 0;
        }
        if (p2->NonPagedFrees > p1->NonPagedFrees) {
            return 1;
        }
        return -1;

    case NONPAGED_USED:
        if (p2->NonPagedBytes == p1->NonPagedBytes) {
            return 0;
        }
        if (p2->NonPagedBytes > p1->NonPagedBytes) {
            return 1;
        }
        return -1;

    case PAGED_USED:
        if (p2->PagedBytes == p1->PagedBytes) {
            return 0;
        }
        if (p2->PagedBytes > p1->PagedBytes) {
            return 1;
        }
        return -1;

    default:
        break;
    }
    return 0;
}




/*++

Routine Description:

    Sets up generally useful pool globals.

    Must be called in every DECLARE_API interface that uses pool.

Arguments:

    None.

Return Value:

    None

--*/

LOGICAL PoolInitialized = FALSE;

LOGICAL
PoolInitializeGlobals(
                     VOID
                     )
{
    if (PoolInitialized == TRUE) {
        return TRUE;
    }

    SpecialPoolStart = GetPointerValue("nt!MmSpecialPoolStart");
    SpecialPoolEnd = GetPointerValue("nt!MmSpecialPoolEnd");


    if (PageSize < 0x1000 || (PageSize & (ULONG)0xFFF)) {
        dprintf ("unable to get MmPageSize (0x%x) - probably bad symbols\n", PageSize);
        return FALSE;
    }

    PoolInitialized = TRUE;

    return TRUE;
}

DECLARE_API( frag )

/*++

Routine Description:

    Dump pool fragmentation

Arguments:

    args - Flags

Return Value:

    None

--*/

{
    ULONG Flags;
    ULONG result;
    ULONG i;
    ULONG count;
    ULONG64 Pool;
    ULONG64 PoolLoc1;
    ULONG TotalFrag;
    ULONG TotalCount;
    ULONG Frag;
    ULONG64 PoolStart;
    ULONG   PoolOverhead;
    ULONG64 PoolLoc;
    ULONG PoolTag, BlockSize, PreviousSize, PoolIndex;
    ULONG TotalPages, TotalBigPages;
    ULONG64 Flink, Blink;
    PCHAR pc;
    ULONG ListHeadOffset, ListEntryOffset;
    ULONG64 tmp;

#define PoolBlk(F,V) GetFieldValue(Pool, "nt!_POOL_HEADER", #F, V)

    if (PoolInitializeGlobals() == FALSE) {
        return E_INVALIDARG;
    }

    dprintf("\n  NonPaged Pool Fragmentation\n\n");
    Flags = 0;
    PoolStart = 0;

    if (GetExpressionEx(args, &tmp, &args)) {
        Flags = (ULONG) tmp;
        PoolStart = GetExpression (args);
    }

    PoolOverhead  = GetTypeSize("nt!_POOL_HEADER");
    if (PoolStart != 0) {
        PoolStart += PoolOverhead;

        Pool = DecodeLink(PoolStart);
        do {

            Pool = Pool - PoolOverhead;
            if ( PoolBlk(k, PoolTag) ) {
                dprintf("%08p: Unable to get contents of pool block\n", Pool );
                return E_INVALIDARG;
            }

            PoolBlk(BlockSize,BlockSize);
            PoolBlk(PreviousSize,PreviousSize);
            ReadPointer(Pool + PoolOverhead, &Flink);
            ReadPointer(Pool + PoolOverhead + DBG_PTR_SIZE, &Blink);

            dprintf(" %p size: %4lx previous size: %4lx  %c%c%c%c links: %8p %8p\n",
                    Pool,
                    (ULONG)BlockSize << POOL_BLOCK_SHIFT,
                    (ULONG)PreviousSize << POOL_BLOCK_SHIFT,
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                    PP(PoolTag),
                    PP(PoolTag >> 8),
                    PP(PoolTag >> 16),
                    PP((PoolTag&~PROTECTED_POOL) >> 24),
#undef PP
                    Flink,
                    Blink);

            if (Flags != 3) {
                Pool = Flink;
            } else {
                Pool = Blink;
            }

            Pool = DecodeLink(Pool);

            if (CheckControlC()) {
                return E_INVALIDARG;
            }

        } while ( (Pool & (ULONG64) ~0xf) != (PoolStart & (ULONG64) ~0xf) );

        return E_INVALIDARG;
    }

    PoolLoc1 = GetNtDebuggerData( NonPagedPoolDescriptor );

    if (PoolLoc1 == 0) {
        dprintf ("unable to get nonpaged pool head\n");
        return E_INVALIDARG;
    }

    PoolLoc = PoolLoc1;
    GetFieldOffset("nt!_POOL_DESCRIPTOR", "ListHeads", &ListHeadOffset);

    TotalFrag   = 0;
    TotalCount  = 0;

    for (i = 0; i < POOL_LIST_HEADS; i += 1) {

        Frag  = 0;
        count = 0;

        // Get Offset of this entry
        ListEntryOffset = ListHeadOffset + i * 2 * DBG_PTR_SIZE;

        if (GetFieldValue(PoolLoc + ListEntryOffset, "nt!_LIST_ENTRY", "Flink", Pool)) {
            dprintf ("Unable to get pool descriptor list entry %#lx, %p\n", i, PoolLoc1);
            return E_INVALIDARG;
        }
//        Pool  = (PUCHAR)PoolDesc.ListHeads[i].Flink;
        Pool = DecodeLink(Pool);

        while (Pool != (ListEntryOffset + PoolLoc)) {

            Pool = Pool - PoolOverhead;
            if ( PoolBlk(PoolTag, PoolTag) ) {
                dprintf("%08p: Unable to get contents of pool block\n", Pool );
                return E_INVALIDARG;
            }

            PoolBlk(BlockSize,BlockSize);
            PoolBlk(PreviousSize,PreviousSize);
            ReadPointer(Pool + PoolOverhead, &Flink);
            ReadPointer(Pool + PoolOverhead + DBG_PTR_SIZE, &Blink);

            Frag  += BlockSize << POOL_BLOCK_SHIFT;
            count += 1;

            if (Flags & 2) {
                dprintf(" ListHead[%x]: %p size: %4lx previous size: %4lx  %c%c%c%c\n",
                        i,
                        (ULONG)Pool,
                        (ULONG)BlockSize << POOL_BLOCK_SHIFT,
                        (ULONG)PreviousSize << POOL_BLOCK_SHIFT,
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                        PP(PoolTag),
                        PP(PoolTag >> 8),
                        PP(PoolTag >> 16),
                        PP((PoolTag&~PROTECTED_POOL) >> 24));
#undef PP
            }
            Pool = Flink;
            Pool = DecodeLink(Pool);

            if (CheckControlC()) {
                return E_INVALIDARG;
            }
        }
        if (Flags & 1) {
            dprintf("index: %2ld number of fragments: %5ld  bytes: %6ld\n",
                    i,count,Frag);
        }
        TotalFrag  += Frag;
        TotalCount += count;
    }

    dprintf("\n Number of fragments: %7ld consuming %7ld bytes\n",
            TotalCount,TotalFrag);
    GetFieldValue(PoolLoc, "nt!_POOL_DESCRIPTOR", "TotalPages",TotalPages);
    GetFieldValue(PoolLoc, "nt!_POOL_DESCRIPTOR", "TotalBigPages", TotalBigPages);

    dprintf(  " NonPagedPool Usage:  %7ld bytes\n",(TotalPages + TotalBigPages)*PageSize);
    return S_OK;
#undef PoolBlk
}


PRTL_BITMAP
GetBitmap(
         ULONG64 pBitmap
         )
{
    PRTL_BITMAP p;
    ULONG Size, Result;
    ULONG64 Buffer=0;

    if (!pBitmap || GetFieldValue(pBitmap, "nt!_RTL_BITMAP", "Buffer", Buffer)) {
        dprintf("%08p: Unable to get contents of bitmap\n", pBitmap );
        return 0;
    }
    GetFieldValue(pBitmap, "nt!_RTL_BITMAP", "SizeOfBitMap", Size);

    p = HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) + (Size / 8) );
    if (p) {
        p->SizeOfBitMap = Size;
        p->Buffer = (PULONG)(p + 1);
        if ( !ReadMemory( Buffer,
                          p->Buffer,
                          Size / 8,
                          &Result) ) {
            dprintf("%08p: Unable to get contents of bitmap buffer\n", Buffer );
            HeapFree( GetProcessHeap(), 0, p );
            p = NULL;
        }
    }


    return p;
}

VOID
DumpPool(
        VOID
        )
{
    ULONG64 p, pStart;
    ULONG64 Size;
    ULONG BusyFlag;
    ULONG CurrentPage, NumberOfPages;
    PRTL_BITMAP StartMap;
    PRTL_BITMAP EndMap;
    ULONG64 PagedPoolStart;
    ULONG64 PagedPoolEnd;
    ULONG Result;
    UCHAR PgPool[] = "nt!_MM_PAGED_POOL_INFO";
    ULONG64 PagedPoolInfoPointer;
    ULONG64 PagedPoolAllocationMap=0, EndOfPagedPoolBitmap=0;

    if (PoolInitializeGlobals() == FALSE) {
        return;
    }

    PagedPoolInfoPointer = GetNtDebuggerData( MmPagedPoolInformation );

    if ( GetFieldValue( PagedPoolInfoPointer,
                        PgPool,
                        "PagedPoolAllocationMap",
                        PagedPoolAllocationMap)) {
        dprintf("%08p: Unable to get contents of paged pool information\n",
                PagedPoolInfoPointer );
        return;
    }

    GetFieldValue( PagedPoolInfoPointer, PgPool, "EndOfPagedPoolBitmap",  EndOfPagedPoolBitmap);


    StartMap = GetBitmap( PagedPoolAllocationMap );
    EndMap = GetBitmap( EndOfPagedPoolBitmap );

    PagedPoolStart = GetNtDebuggerDataPtrValue( MmPagedPoolStart );
    PagedPoolEnd = GetNtDebuggerDataPtrValue( MmPagedPoolEnd );

    if (StartMap && EndMap) {
        p = PagedPoolStart;
        CurrentPage = 0;
        dprintf( "Paged Pool: %p .. %p\n", PagedPoolStart, PagedPoolEnd );

        while (p < PagedPoolEnd) {
            if ( CheckControlC() ) {
                return;
            }
            pStart = p;
            BusyFlag = RtlCheckBit( StartMap, CurrentPage );
            while ( ~(BusyFlag ^ RtlCheckBit( StartMap, CurrentPage )) ) {
                p += PageSize;
                if (RtlCheckBit( EndMap, CurrentPage )) {
                    CurrentPage++;
                    break;
                }

                CurrentPage++;
                if (p > PagedPoolEnd) {
                    break;
                }
            }

            Size = p - pStart;
            dprintf( "%p: %I64x - %s\n", pStart, Size, BusyFlag ? "busy" : "free" );
        }
    }

    HeapFree( GetProcessHeap(), 0, StartMap );
    HeapFree( GetProcessHeap(), 0, EndMap );
}

void
PrintPoolTagComponent(
    ULONG PoolTag
    )
{
    PGET_POOL_TAG_DESCRIPTION GetPoolTagDescription;
    PSTR TagComponent;
#ifdef  _EXTFNS_H
    DEBUG_POOLTAG_DESCRIPTION Desc = {0};
    Desc.SizeOfStruct = sizeof(DEBUG_POOLTAG_DESCRIPTION);
    GetPoolTagDescription = NULL;
    if ((GetExtensionFunction("GetPoolTagDescription", (FARPROC*) &GetPoolTagDescription) != S_OK) ||
        !GetPoolTagDescription) {
        return;
    }

    (*GetPoolTagDescription)(PoolTag, &Desc);

    if (Desc.Description[0]) {
        dprintf("\t\tPooltag %4.4s : %s", &PoolTag, Desc.Description);
        if (Desc.Binary[0]) {
            dprintf(", Binary : %s",Desc.Binary);
        }
        if (Desc.Owner[0]) {
            dprintf(", Owner : %s", Desc.Owner);
        }
        dprintf("\n");
    } else {
        dprintf("\t\tOwning component : Unknown (update pooltag.txt)\n");
    }

#else
    GetPoolTagDescription = NULL;
    if ((GetExtensionFunction("GetPoolTagDescription", (FARPROC*) &GetPoolTagDescription) != S_OK) ||
        !GetPoolTagDescription) {
        return;
    }

    (*GetPoolTagDescription)(PoolTag, &TagComponent);
    if (TagComponent && (100 < (ULONG64) TagComponent)) {
        dprintf("\t\tOwning component : %s\n", TagComponent);
    } else {
        dprintf("\t\tOwning component : Unknown (update pooltag.txt)\n");
    }

#endif
}

PSTR g_PoolRegion[DbgPoolRegionMax] = {
    "Unknown",                      // DbgPoolRegionUnknown,
    "Special pool",                 // DbgPoolRegionSpecial,
    "Paged pool",                   // DbgPoolRegionPaged,
    "Nonpaged pool",                // DbgPoolRegionNonPaged,
    "Pool code",                    // DbgPoolRegionCode,
    "Nonpaged pool expansion",      // DbgPoolRegionNonPagedExpansion,
};

DEBUG_POOL_REGION
GetPoolRegion(
    ULONG64 Pool
    )
{
    static ULONG64 PoolCodeEnd;
    static ULONG64 PagedPoolEnd;
    static ULONG64 NonPagedPoolEnd;
    static ULONG64 NonPagedPoolStart;
    static ULONG64 PagedPoolStart;
    static ULONG64 SessionPagedPoolStart;
    static ULONG64 SessionPagedPoolEnd;
    static ULONG64 NonPagedPoolExpansionStart;
    static ULONG64 PoolCodeStart;
    static BOOL GotAll = FALSE;

    if (!GotAll) {
        PoolCodeEnd = GetPointerValue("nt!MmPoolCodeEnd");
        SpecialPoolEnd = GetPointerValue("nt!MmSpecialPoolEnd");
        PagedPoolEnd = GetPointerValue("nt!MmPagedPoolEnd");
        NonPagedPoolEnd = GetPointerValue("nt!MmNonPagedPoolEnd");
        NonPagedPoolStart = GetPointerValue("nt!MmNonPagedPoolStart");
        SpecialPoolStart = GetPointerValue("nt!MmSpecialPoolStart");
        PagedPoolStart = GetPointerValue("nt!MmPagedPoolStart");
        SessionPagedPoolStart = GetPointerValue("nt!MiSessionPoolStart");
        SessionPagedPoolEnd = GetPointerValue("nt!MiSessionPoolEnd");
        NonPagedPoolExpansionStart = GetPointerValue("nt!MmNonPagedPoolExpansionStart");
        PoolCodeStart = GetPointerValue("nt!MmPoolCodeStart");
        GotAll = TRUE;
    }
    if (!(PoolCodeStart || SpecialPoolStart || SpecialPoolEnd || PoolCodeEnd ||
        NonPagedPoolExpansionStart || NonPagedPoolStart || NonPagedPoolEnd ||
        SessionPagedPoolStart || SessionPagedPoolEnd || PagedPoolStart || PagedPoolEnd)) {
        GotAll = FALSE;
        return DbgPoolRegionUnknown;
    }
    if ( Pool >= SpecialPoolStart && Pool < SpecialPoolEnd) {
        return DbgPoolRegionSpecial;
    } else if ( Pool >= PagedPoolStart && Pool < PagedPoolEnd) {
        return DbgPoolRegionPaged;
    } else if ( Pool >= SessionPagedPoolStart && Pool < SessionPagedPoolEnd) {
        return DbgPoolRegionPaged;
    } else if ( Pool >= NonPagedPoolStart && Pool < NonPagedPoolEnd) {
        return DbgPoolRegionNonPaged;
    } else if ( Pool >= PoolCodeStart && Pool < PoolCodeEnd) {
        return DbgPoolRegionCode;
    } else if ( Pool >= NonPagedPoolExpansionStart) {
        return DbgPoolRegionNonPagedExpansion;
    } else {
        return DbgPoolRegionUnknown;
    }
    return DbgPoolRegionUnknown;
}

void
PrintPoolRegion(
    ULONG64 Pool
    )
{
    PSTR pszRegion;
    DEBUG_POOL_REGION Region;


    Region = GetPoolRegion(Pool);

    pszRegion = g_PoolRegion[Region];
    if (pszRegion) {
        dprintf(pszRegion);
        dprintf("\n");
    } else {
        dprintf("Region unkown (0x%I64X)\n", Pool);
    }

}

ULONG64
READ_PVOID (
    ULONG64 Address
    );

UCHAR       DataPage[0x5000];

HRESULT
ListPoolPage(
    ULONG64 PoolPageToDump,
    ULONG   Flags,
    PDEBUG_POOL_DATA PoolData
    )
{
    LOGICAL     QuotaProcessAtEndOfPoolBlock;
    ULONG64     PoolTableAddress;
    ULONG       result;
    ULONG       PoolTag;
    ULONG       Result;
    ULONG64     StartPage;
    ULONG64     Pool;
    ULONG       PoolBlockSize;
    ULONG       PoolHeaderSize;
    ULONG64     PoolHeader;
    ULONG       Previous;
    UCHAR       c;
    PUCHAR      p;
    ULONG64     PoolDataEnd;
    UCHAR       PoolBlockPattern;
    PUCHAR      DataStart;
    ULONG64     RealDataStart;
    LOGICAL     Pagable;
    LOGICAL     FirstBlock;
    ULONG       BlockType;
    ULONG       PoolWhere;
    ULONG       i;
    ULONG       j;
    ULONG       ct;
    ULONG       start;
    ULONG       PoolBigPageTableSize;
    ULONG       SizeOfPoolHdr=GetTypeSize("nt!_POOL_HEADER");

    if (!SpecialPoolStart) {
        SpecialPoolStart = GetPointerValue("nt!MmSpecialPoolStart");
        SpecialPoolEnd = GetPointerValue("nt!MmSpecialPoolEnd");
    }

    Pool        = PAGE_ALIGN64 (PoolPageToDump);
    StartPage   = Pool;
    Previous    = 0;

    if (PoolData) {
        ZeroMemory(PoolData, sizeof(DEBUG_POOL_DATA));
    }

    if (!(Flags & 0x80000000)) {
        dprintf("Pool page %p region is ", PoolPageToDump);
        PrintPoolRegion(PoolPageToDump);
    }

    if (Pool >= SpecialPoolStart && Pool < SpecialPoolEnd) {

        ULONG Hdr_Ulong=0;

        // Pre read the pool
        if ( !ReadMemory( Pool,
                          &DataPage[0],
                          min(PageSize, sizeof(DataPage)),
                          &Result) ) {
            dprintf("%08p: Unable to get contents of special pool block\n", Pool );
            return  E_INVALIDARG;
        }

        if ( GetFieldValue( Pool, "nt!_POOL_HEADER", "Ulong1", Hdr_Ulong)) {
            dprintf("%08p: Unable to get nt!_POOL_HEADER\n", Pool );
            return E_INVALIDARG;
        }

        //
        // Determine whether the data is at the start or end of the page.
        // Start off by assuming the data is at the end, in this case the
        // header will be at the start.
        //

        PoolHeader = GetSpecialPoolHeader((PVOID) &DataPage[0], Pool, &RealDataStart);

        if (PoolHeader == 0) {
            dprintf("Block %p is a corrupted special pool allocation\n",
                    PoolPageToDump);
            return  E_INVALIDARG;
        }
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", Hdr_Ulong);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolTag", PoolTag);
        PoolBlockSize = SPECIAL_POOL_BLOCK_SIZE(Hdr_Ulong);

        if (Hdr_Ulong & MI_SPECIAL_POOL_PAGABLE) {
            Pagable = TRUE;
        } else {
            Pagable = FALSE;
        }

        if (PoolData) {
            PoolData->Pool = RealDataStart;
            PoolData->PoolBlock = PoolPageToDump;
            PoolData->SpecialPool = 1;
            PoolData->Pageable = Hdr_Ulong & 0x8000 ? 1 : 0;
            PoolData->Size = PoolBlockSize;
            if (Flags & 0x80000000) {
                // do not print anything
                return S_OK;
            }
        }
        dprintf("*%p size: %4lx %s special pool, Tag is %c%c%c%c\n",
                RealDataStart,
                PoolBlockSize,
                Hdr_Ulong & 0x8000 ? "pagable" : "non-paged",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                PP(PoolTag),
                PP(PoolTag >> 8),
                PP(PoolTag >> 16),
                PP(PoolTag >> 24)
               );
#undef PP
        PrintPoolTagComponent(PoolTag);

        //
        // Add code to validate whole block.
        //

        return S_OK;
    }

    FirstBlock = TRUE;
    QuotaProcessAtEndOfPoolBlock = FALSE;

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
        if (GetExpression ("nt!ExGetPoolTagInfo") != 0) {

            //
            // This is a kernel where the quota process pointer is at the end
            // of the pool block instead of overlaid on the tag field.
            //

            QuotaProcessAtEndOfPoolBlock = TRUE;
        }
    }

    while (PAGE_ALIGN64(Pool) == StartPage) {
        ULONG BlockSize=0, PreviousSize=0, PoolType=0, AllocatorBackTraceIndex=0;
        ULONG PoolTagHash=0, PoolIndex=0;
        ULONG64 ProcessBilled=0;

        if ( CheckControlC() ) {
            return E_INVALIDARG;
        }

        if ( GetFieldValue( Pool, "nt!_POOL_HEADER", "BlockSize", BlockSize) ) {

            //
            // If this is a large pool allocation the memory address at this address
            // might still be DemandZero and we cannot read from it. This is not an error -
            // we could still find the allocation in the large allocations table.
            //

            BlockType = 1;

            goto TryLargePool;
        }

        if (PoolPageToDump >= Pool &&
            PoolPageToDump < (Pool + ((ULONG64) BlockSize << POOL_BLOCK_SHIFT))
           ) {
            c = '*';
        } else {
            c = ' ';
        }

        GetFieldValue( Pool, "nt!_POOL_HEADER", "PreviousSize", PreviousSize);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolType", PoolType);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolTag", PoolTag);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolTagHash", PoolTagHash);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolIndex", PoolIndex);
        GetFieldValue( Pool, "nt!_POOL_HEADER", "AllocatorBackTraceIndex", AllocatorBackTraceIndex);

        BlockType = 0;

        if ((BlockSize << POOL_BLOCK_SHIFT) >= POOL_PAGE_SIZE) {
            BlockType = 1;
        } else if (BlockSize == 0) {
            BlockType = 2;
        } else if (PreviousSize != Previous) {
            BlockType = 3;
        }

TryLargePool:

        if (BlockType != 0) {
            ULONG BigPageSize = GetTypeSize ("nt!_POOL_TRACKER_BIG_PAGES");

            if (!BigPageSize) {
                dprintf("Cannot get _POOL_TRACKER_BIG_PAGES type size\n");
                break;
            }

            //
            // See if this is a big block allocation.  Iff we have not parsed
            // any other small blocks in here already.
            //

            if (FirstBlock == TRUE) {

                if (!PoolBigTableAddress) {
                    PoolBigTableAddress = GetPointerValue ("nt!PoolBigPageTable");
                }

                PoolTableAddress = PoolBigTableAddress;

                if (PoolTableAddress) {

                    dprintf ("%p is not a valid small pool allocation, checking large pool...\n", Pool);

                    PoolBigPageTableSize = GetUlongValue ("nt!PoolBigPageTableSize");
                    //
                    // Scan the table looking for a match.
                    //

                    i = 0;
                    ct = PageSize / BigPageSize;

                    while (i < PoolBigPageTableSize) {
                        ULONG64 Va=0;
                        ULONG Key=0, NumberOfPages=0;

                        if (PoolBigPageTableSize - i < ct) {
                            ct = PoolBigPageTableSize - i;
                        }

                        if ( GetFieldValue( PoolTableAddress,
                                            "nt!_POOL_TRACKER_BIG_PAGES",
                                            "Va",
                                            Va) ) {
                            dprintf("%08p: Unable to get contents of pool block\n", PoolTableAddress );
                            return E_INVALIDARG;
                        }

                        for (j = 0; j < ct; j += 1) {

                            if ( GetFieldValue( PoolTableAddress + BigPageSize*j,
                                                "nt!_POOL_TRACKER_BIG_PAGES",
                                                "Va",
                                                Va) ) {
                                dprintf("%08p: Unable to get contents of pool block\n", PoolTableAddress );
                                return E_INVALIDARG;
                            }

                            if (((Va & 0x1) == 0) && (Pool >= Va)) {

                                GetFieldValue( PoolTableAddress + BigPageSize*j,
                                               "nt!_POOL_TRACKER_BIG_PAGES",
                                               "NumberOfPages",
                                               NumberOfPages);

                                if (Pool < (Va + (NumberOfPages * PageSize))) {
                                    //
                                    // Match !
                                    //
                                    GetFieldValue( PoolTableAddress + BigPageSize*j,
                                                   "nt!_POOL_TRACKER_BIG_PAGES",
                                                   "Key",
                                                   Key);
                                    PoolTag = Key;

                                    if (PoolData) {
                                        PoolData->Pool = PoolPageToDump;
                                        PoolData->Size = NumberOfPages*PageSize;
                                        PoolData->PoolTag = PoolTag;
                                        PoolData->LargePool = 1;
                                        PoolData->Free = (Pool & POOL_BIG_TABLE_ENTRY_FREE) ? 1 : 0;
                                        if (Flags & 0x80000000) {
                                            // do not print anything
                                            return S_OK;
                                        }
                                    }
                                    dprintf("*%p :%s large page allocation, Tag is %c%c%c%c, size is 0x%I64x bytes\n",
                                            (Pool & ~POOL_BIG_TABLE_ENTRY_FREE),
                                            (Pool & POOL_BIG_TABLE_ENTRY_FREE) ? "free " : "",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                                            PP(PoolTag),
                                            PP(PoolTag >> 8),
                                            PP(PoolTag >> 16),
                                            PP(PoolTag >> 24),
                                            (ULONG64)NumberOfPages * PageSize
                                           );
#undef PP
                                    PrintPoolTagComponent(PoolTag);
                                    return S_OK;
                                }
                            }
                        }
                        i += ct;
                        PoolTableAddress += (ct * BigPageSize);
                    }

                    //
                    // No match in small or large pool, must be
                    // freed or corrupt pool
                    //

                    dprintf("%p is freed (or corrupt) pool\n", Pool);

                    return E_INVALIDARG;
                }

                dprintf("unable to get pool big page table - either wrong symbols or pool tagging is disabled\n");
            }

            if (BlockType == 1) {
                dprintf("Bad allocation size @%p, too large\n", Pool);
            } else if (BlockType == 2) {
                dprintf("Bad allocation size @%p, zero is invalid\n", Pool);
            } else if (BlockType == 3) {
                dprintf("Bad previous allocation size @%p, last size was %lx\n",
                        Pool, Previous);
            }

            if (BlockType != 0) {

                //
                // Attempt to diagnose what is wrong with the pool page
                //
                DiagnosePoolPage(Pool);

                return E_INVALIDARG;

            }
        }

        switch (TargetMachine) {
            case IMAGE_FILE_MACHINE_IA64:
            case IMAGE_FILE_MACHINE_AMD64:
                    GetFieldValue( Pool, "nt!_POOL_HEADER", "ProcessBilled", ProcessBilled);
                break;
            default:
                if (QuotaProcessAtEndOfPoolBlock == TRUE) {

                    ULONG SizeOfPvoid = 0;
                    ULONG64 ProcessBillAddress;

                    SizeOfPvoid =  DBG_PTR_SIZE;

                    if (SizeOfPvoid == 0) {
                        dprintf ("Search: cannot get size of PVOID\n");
                        return E_INVALIDARG;
                    }
                    ProcessBillAddress = Pool + ((ULONG64) BlockSize << POOL_BLOCK_SHIFT) - SizeOfPvoid;
                    ProcessBilled = READ_PVOID (ProcessBillAddress);
                }
                else {
                    GetFieldValue( Pool, "nt!_POOL_HEADER", "ProcessBilled", ProcessBilled);
                }
                break;
        }

        GetFieldValue( Pool, "nt!_POOL_HEADER", "PoolTag", PoolTag);


        if (!(Flags & 2) || c == '*') {
            if (PoolData) {
                PoolData->Pool          = Pool;
                PoolData->PoolBlock     = PoolPageToDump;
                PoolData->PoolTag       = PoolTag & ~PROTECTED_POOL;
                PoolData->ProcessBilled = ProcessBilled;
                PoolData->PreviousSize  = PreviousSize << POOL_BLOCK_SHIFT;
                PoolData->Size          = BlockSize << POOL_BLOCK_SHIFT;
                PoolData->Free          = ((PoolType != 0) && (!NewPool ?
                                                               (PoolIndex & 0x80) : (PoolType & 0x04))) ? 0 : 1;
                PoolData->Protected     = (PoolTag&PROTECTED_POOL) ? 1 : 0;
                if (Flags & 0x80000000) {
                    // do not print anything
                    return S_OK;
                }
            }

            dprintf("%c%p size: %4lx previous size: %4lx ",
                    c,
                    Pool,
                    BlockSize << POOL_BLOCK_SHIFT,
                    PreviousSize << POOL_BLOCK_SHIFT);

            if (PoolType == 0) {

                //
                // "Free " with a space after it before the parentheses means
                // it's been freed to a (pool manager internal) lookaside list.
                // We used to print "Lookaside" but that just confused driver
                // writers because they didn't know if this meant in use or not
                // and many would say "but I don't use lookaside lists - the
                // extension or kernel is broken".
                //
                // "Free" with no space after it before the parentheses means
                // it is not on a pool manager internal lookaside list and is
                // instead on the regular pool manager internal flink/blink
                // chains.
                //
                // Note to anyone using the pool package, these 2 terms are
                // equivalent.  The fine distinction is only for those actually
                // writing pool internal code.
                //

                dprintf(" (Free)");

#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                dprintf("      %c%c%c%c%c\n",
                        c,
                        PP(PoolTag),
                        PP(PoolTag >> 8),
                        PP(PoolTag >> 16),
                        PP((PoolTag&~PROTECTED_POOL) >> 24)
                       );
#undef PP
                if (c=='*') {
                    PrintPoolTagComponent(PoolTag & ~PROTECTED_POOL);
                }
            } else {

                if (!NewPool ? (PoolIndex & 0x80) : (PoolType & 0x04)) {
                    dprintf(" (Allocated)");
                } else {
                    //
                    // "Free " with a space after it before the parentheses means
                    // it's been freed to a (pool manager internal) lookaside list.
                    // We used to print "Lookaside" but that just confused driver
                    // writers because they didn't know if this meant in use or not
                    // and many would say "but I don't use lookaside lists - the
                    // extension or kernel is broken".
                    //
                    // "Free" with no space after it before the parentheses means
                    // it is not on a pool manager internal lookaside list and is
                    // instead on the regular pool manager internal flink/blink
                    // chains.
                    //
                    // Note to anyone using the pool package, these 2 terms are
                    // equivalent.  The fine distinction is only for those actually
                    // writing pool internal code.
                    //
                    dprintf(" (Free )");
                }
                if ((PoolType & POOL_QUOTA_MASK) == 0) {
                    /*
                    ULONG Key=0;
                    if (AllocatorBackTraceIndex != 0 &&
                        AllocatorBackTraceIndex & POOL_BACKTRACEINDEX_PRESENT
                       ) {
                        if ( GetFieldValue( PoolTrackTable + ( PoolTagHash&~(PROTECTED_POOL >> 16) )*GetTypeSize("nt!_POOL_TRACKER_TABLE"),
                                            "nt!_POOL_TRACKER_TABLE",
                                            "Key",
                                            Key) ) {
                            PoolTag = 0;
                        } else {
                            PoolTag = Key;
                        }

                        if (PoolTagHash & (PROTECTED_POOL >> 16)) {
                            PoolTag |= PROTECTED_POOL;
                        }

                    } else {
                        PoolTag = PoolTag;
                    }*/

                    dprintf(" %c%c%c%c%c%s\n",
                            c,
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                            PP(PoolTag),
                            PP(PoolTag >> 8),
                            PP(PoolTag >> 16),
                            PP((PoolTag&~PROTECTED_POOL) >> 24),
                            (PoolTag&PROTECTED_POOL) ? " (Protected)" : ""
#undef PP
                        );

                    if (c=='*') {
                        PrintPoolTagComponent(PoolTag & ~PROTECTED_POOL);
                    }
                } else {
                    if ((QuotaProcessAtEndOfPoolBlock == TRUE) ||
                        (TargetMachine != IMAGE_FILE_MACHINE_I386)) {

                        dprintf(" %c%c%c%c%c%s",
                                c,
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                                PP(PoolTag),
                                PP(PoolTag >> 8),
                                PP(PoolTag >> 16),
                                PP((PoolTag&~PROTECTED_POOL) >> 24),
                                (PoolTag&PROTECTED_POOL) ? " (Protected)" : ""
#undef PP
                        );

                        if (ProcessBilled != 0) {
                            dprintf(" Process: %0p\n", ProcessBilled );
                        }
                        else {
                            dprintf("\n");
                        }

                        if (c=='*') {
                            PrintPoolTagComponent(PoolTag & ~PROTECTED_POOL);
                        }
                    }
                    else {
                        if (ProcessBilled != 0) {
                            dprintf(" Process: %0p", ProcessBilled );
                        }
                        dprintf("\n");
                    }
                }
            }

        }


        if (Flags & 1) {

            PULONG  Contents;
            ULONG   Size;

            Size = BlockSize << POOL_BLOCK_SHIFT;

            //
            // the blocksize includes the size of the header,
            // so we want to account for the header size
            // when we determine how much data to display
            //
            Size -= SizeOfPoolHdr;

            if (Size > 0) {

                Contents = malloc(Size);

                if (Contents) {

                    ULONG64 m;
                    ULONG64 q;

                    q = Pool + SizeOfPoolHdr;

                    ReadMemory(q,
                               Contents,
                               Size,
                               &i);

                    for (m = 0; m < (Size / sizeof(Contents[0])); m++) {

                        if (m % 4 == 0) {

                            if (m > 0) {
                                dprintf("\n");
                            }

                            dprintf("    %0p ", q + (m * sizeof(Contents[0])));

                        }

                        dprintf(" %08lx", Contents[m]);

                    }

                    dprintf("\n\n");

                    free(Contents);

                }
            } else {
                dprintf("\n");
            }
        }

        Previous = BlockSize;
        Pool += ((ULONG64) Previous << POOL_BLOCK_SHIFT);
        FirstBlock = FALSE;
    }
    return S_OK;
}

DECLARE_API( pool )

/*++

Routine Description:

    Dump kernel mode heap

Arguments:

    args - Page Flags

Return Value:

    None

--*/

{
    ULONG64     PoolPageToDump;
    ULONG       Flags;
    HRESULT     Hr;

    INIT_API();
    if (PoolInitializeGlobals() == FALSE) {
        Hr = E_INVALIDARG;
    } else {
        PoolPageToDump = 0;
        Flags = 0;
        if (GetExpressionEx(args, &PoolPageToDump, &args)) {
            Flags = (ULONG) GetExpression (args);
        }

        if (PoolPageToDump == 0) {
            DumpPool();
            Hr = S_OK;;
        } else {
            Hr = ListPoolPage(PoolPageToDump, Flags, NULL);
        }

    }
    EXIT_API();

    return Hr;

}

//
// header info meta information
//
#define HEADER_BACK_LINK            (0x1 << 0)  // node has a valid backward link
#define HEADER_FORWARD_LINK         (0x1 << 1)  // node has a valid forward link
#define HEADER_FIXED_BACK_LINK      (0x1 << 2)  // an attempt was made to correct the backward link
#define HEADER_FIXED_FORWARD_LINK   (0x1 << 3)  // an attempt was made to correct the forward link
#define HEADER_FIRST_LINK           (0x1 << 4)  // node is the first of a contiguous linked list
#define HEADER_LAST_LINK            (0x1 << 5)  // node is the last of a contiguous linked list
#define HEADER_START_PAGE_BLOCK     (0x1 << 6)  // node is at the start of the pool page
#define HEADER_END_PAGE_BLOCK       (0x1 << 7)  // node refers to the end of the pool page - implies LAST_LINK

typedef struct _VALIDATE_POOL_HEADER_INFO {
    UCHAR   Info;
    ULONG   Pass;
    UINT64  Node;
    UINT64  ForwardLink;
    UINT64  BackLink;
    UINT64  FixedPreviousSize;
    UINT64  FixedBlockSize;
} VALIDATE_POOL_HEADER_INFO, *PVALIDATE_POOL_HEADER_INFO;

#define IS_VALID_PASS(_x) ((_x > 0) && (_x < 0xff))

#define VERBOSE_SHOW_ERRORS_ONLY    (0)         //
#define VERBOSE_SHOW_LISTS          (0x1 << 0)  //
#define VERBOSE_SHOW_HEADER_INFO    (0x1 << 1)  //
#define VERBOSE_DUMP_HEADERS        (0x1 << 2)  //
#define VERBOSE_SHOW_ALL            (0x1 << 7)

UCHAR
ValidatePoolHeaderBackLink(
    IN ULONG64  Pool
    )
/*++

Description:

    This routine determines if the
    back link of a given pool header as valid

Arguments:

    Pool    - header (node) to analyze

Returns:

    Header info for the node

--*/
{
    UCHAR   HeaderInfo;
    ULONG64 StartPage;
    ULONG64 p;
    ULONG   tmpBlockSize;
    ULONG   PreviousSize;

    //
    // find where the page starts
    //
    StartPage = PAGE_ALIGN64(Pool);

    //
    // clear the header info
    //
    HeaderInfo = 0;

    //
    // get the previous size for the current node
    //
    GetFieldValue( Pool, "nt!_POOL_HEADER", "PreviousSize", PreviousSize);

    //
    // Validate Back link
    //
    if (Pool == StartPage) {

        //
        // ensure that the PreviousSize is 0 before
        // we declare we have a valid back link
        //
        if (PreviousSize == 0) {

            //
            // the page always begins with a block
            // and the back link is not used (0)
            //
            HeaderInfo |= HEADER_BACK_LINK;

        }

        HeaderInfo |= HEADER_START_PAGE_BLOCK;

    } else {

        p = Pool - ((ULONG64)PreviousSize << POOL_BLOCK_SHIFT);

        if (PAGE_ALIGN64(p) == StartPage) {

            GetFieldValue( p, "nt!_POOL_HEADER", "BlockSize", tmpBlockSize);

            if ((tmpBlockSize == PreviousSize) && (tmpBlockSize != 0)) {

                HeaderInfo |= HEADER_BACK_LINK;

            }

        }

    }

    return HeaderInfo;
}

UCHAR
ValidatePoolHeaderForwardLink(
    IN ULONG64  Pool
    )
/*++

Description:

    This routine determines if the
    forward link of a given pool header as valid

Arguments:

    Pool    - header (node) to analyze

Returns:

    Header info for the node

--*/
{
    UCHAR   HeaderInfo;
    ULONG64 StartPage;
    ULONG64 p;
    ULONG   tmpPreviousSize;
    ULONG   BlockSize;

    //
    //
    //
    StartPage = PAGE_ALIGN64(Pool);

    //
    //
    //
    HeaderInfo = 0;

    //
    //
    //
    GetFieldValue( Pool, "nt!_POOL_HEADER", "BlockSize", BlockSize);

    //
    // Validate Forward link
    //
    p = Pool + ((ULONG64)BlockSize << POOL_BLOCK_SHIFT);

    //
    // If p is still on the same page,
    // then see if the block we point to has its
    //      previousblocksize == blocksize
    //
    if (PAGE_ALIGN64(p) == StartPage) {

        GetFieldValue( p, "nt!_POOL_HEADER", "PreviousSize", tmpPreviousSize);

        if ((tmpPreviousSize == BlockSize) && (tmpPreviousSize != 0)) {

            HeaderInfo |= HEADER_FORWARD_LINK;

        }

    } else {

        //
        // if p points to the beginning of the next page,
        // then the block Pool refers to *may* be the last block
        // on the page
        //
        if (p == (StartPage + POOL_PAGE_SIZE)) {

            HeaderInfo |= HEADER_FORWARD_LINK;
            HeaderInfo |= HEADER_END_PAGE_BLOCK;

        }

    }

    return HeaderInfo;
}

UCHAR
ValidatePoolHeader(
    IN ULONG64  Pool
    )
/*++

Description:

    This routine determines if a given pool header as valid
    forward and backward links.

Arguments:

    Pool    - header (node) to analyze

Returns:

    Header info for the node

--*/
{
    UCHAR   HeaderInfo;

    HeaderInfo = 0;
    HeaderInfo |= ValidatePoolHeaderBackLink(Pool);
    HeaderInfo |= ValidatePoolHeaderForwardLink(Pool);

    return HeaderInfo;
}

NTSTATUS
ScanPoolHeaders(
    IN      ULONG64 PoolPageToEnumerate,
    IN OUT  PVOID   Data,
    IN      ULONG   DataSize
    )
/*++

Description:

    This routine does the first pass analysis of the pool page headers.
    The net result of this routine is that we end up with a set of
    pool header meta information, where the information describes
    the health of a node - if the forward and back links exist, etc.

Arguments:

    PoolPageToEnumerate - page to analyze
    Data                - the pool header info
    DataLength          - the # of entries in the header info

Returns:

    Status

--*/
{
    NTSTATUS    Status;
    ULONG64     StartPage;
    ULONG64     StartHeader;
    ULONG64     Pool;
    ULONG       SizeOfPoolHdr;
    ULONG       PoolIndex;
    PVALIDATE_POOL_HEADER_INFO  p;
    ULONG       Pass;
    BOOLEAN     Done;
    BOOLEAN     Tracing;

    //
    // default
    //
    SizeOfPoolHdr   = GetTypeSize("nt!_POOL_HEADER");
    Pool            = PAGE_ALIGN64 (PoolPageToEnumerate);
    StartPage       = Pool;
    Status          = STATUS_SUCCESS;
    PoolIndex       = 0;
    p               = (PVALIDATE_POOL_HEADER_INFO)Data;
    StartHeader     = StartPage;
    Pass            = 0;
    Done            = FALSE;

    //
    // iterate through the page and validate the headers
    //

#if DBG_SCAN
    dprintf("DataSize = %d, DataLength = %d\r\n", DataSize, DataSize / sizeof(VALIDATE_POOL_HEADER_INFO));
#endif

    //
    // algorithm:
    //
    //      Consider each possible node in the pool page to be
    //      the start of a linked list.  For each start node (head),
    //      attempt to follow the list by tracing forward links.  
    //      All nodes that are part of a single list, are assigned
    //      the same pass value - they were all traced on the same pass.
    //      The net result is a set of linked lists grouped by pass.
    //
    //      We skip nodes that have already been marked as being part
    //          of another linked list
    //
    //
    while ((PAGE_ALIGN64(StartHeader) == StartPage) && !Done) {

        //
        // each iteration is a new pass
        //
        Pass       += 1;

        //
        // start scanning from the new first node
        //
        Pool        = StartHeader;
        PoolIndex   = (ULONG)((Pool - StartPage) / SizeOfPoolHdr);
        
        //
        // default: we have not found the start of a linked list 
        //
        Tracing     = FALSE;

        //
        // while we are still on the correct page
        //
        while ((PAGE_ALIGN64(Pool) == StartPage)) {

#if DBG_SCAN
            dprintf("Pass = %d, PoolIndex = %d, Pool = %p\r\n", Pass, PoolIndex, Pool);
#endif

            ASSERT(PoolIndex < (DataSize/sizeof(VALIDATE_POOL_HEADER_INFO)));

            if ( CheckControlC() ) {
                Done = TRUE;
                break;
            }

#if DBG_SCAN
            dprintf("p[PoolIndex].Pass = %d\r\n", p[PoolIndex].Pass);
#endif

            //
            //
            // Skip nodes that have already been marked as being part
            //          of another linked list
            //
            if (p[PoolIndex].Pass == 0) {

                //
                // determine the link info for this header
                //
                p[PoolIndex].Info = ValidatePoolHeader(Pool);

#if DBG_SCAN
                dprintf("p[PoolIndex].Info = %d\r\n", p[PoolIndex].Info);
#endif

                //
                // if the node has any chance of being valid,
                // then consider it
                // otherwise mark it invalid
                //
                if ((p[PoolIndex].Info & HEADER_FORWARD_LINK) ||
                    (p[PoolIndex].Info & HEADER_BACK_LINK) ||
                    (p[PoolIndex].Info & HEADER_START_PAGE_BLOCK)
                    ) {

                    //
                    // if we are not already tracing,
                    // then we have found the first node of a linked list
                    //
                    if (!Tracing) {

                        //
                        // we have found a valid node,
                        // so we now consider ourselves tracing
                        // the links of a list
                        //
                        Tracing = TRUE;

                        //
                        // mark the current node as the start of the list
                        //
                        p[PoolIndex].Info |= HEADER_FIRST_LINK;

                    }

                    //
                    // the node has a valid link,
                    // so it is part of this pass
                    //
                    // if the back link is good and the forward link is bad
                    // then this is the end of a list
                    // if the back link is bad and the forward link is good
                    // then this is the start of a list
                    // if both are good,
                    // then this is the middle node of a list
                    //
                    p[PoolIndex].Pass = Pass;

                    //
                    // keep track of the node's address
                    //
                    p[PoolIndex].Node = Pool;

                    //
                    // keep track of what may or may not be a valid back link
                    // we use this value later when/if we need to correct broken links
                    //
                    {
                       ULONG   PreviousSize;

                        //
                        // calculate the backward node
                        //
                        GetFieldValue( Pool, "nt!_POOL_HEADER", "PreviousSize", PreviousSize);

                        p[PoolIndex].BackLink = Pool - ((ULONG64)PreviousSize << POOL_BLOCK_SHIFT);

                    }

                    //
                    // keep track of what may or may not be a valid forward link
                    // we use this value later when/if we need to correct broken links
                    //
                    {
                        ULONG   BlockSize;

                        //
                        // calculate the forward node
                        //
                        GetFieldValue( Pool, "nt!_POOL_HEADER", "BlockSize", BlockSize);

                        //
                        // keep track of the forward node
                        //
                        p[PoolIndex].ForwardLink = Pool + ((ULONG64)BlockSize << POOL_BLOCK_SHIFT);

                    }

                    //
                    // if the node has a valid forward link,
                    // then follow it as part of this pass
                    //
                    if (p[PoolIndex].Info & HEADER_FORWARD_LINK) {

                        //
                        // calculate the forward node
                        //
                        Pool = p[PoolIndex].ForwardLink;

                        //
                        // calculate the pool info index of the forward node
                        //
                        PoolIndex   = (ULONG)((Pool - StartPage) / SizeOfPoolHdr);

                        continue;

                    } else {

                        //
                        // the forward link is broken,
                        // hence we are at the end of a list
                        //
                        p[PoolIndex].Info |= HEADER_LAST_LINK;

                        break;

                    }

                } else {

                    //
                    // assert: if we got here and are tracing a list
                    //         then the forward link of the previous node
                    //         pointed to a node with no valid links
                    //         this is impossible and probably implies
                    //         that the code to determine the forward link
                    //         is broken
                    //
                    if (Tracing) {
                        dprintf("error: forward link lead to invalid node! header = %p\r\n", Pool);
                    }
                    ASSERT(!Tracing);

                    //
                    // mark this as a NULL pass
                    //
                    p[PoolIndex].Pass = 0xff;

                }

            }

            //
            // assert: we should only reach here if we havent started
            //         tracing a list, otherwise we have landed on
            //         a node which we already explored!
            //
            if (Tracing) {
                dprintf("error: two lists share a node! header = %p\r\n", Pool);
            }
            ASSERT(!Tracing);

            //
            //
            //
            Pool        = Pool + SizeOfPoolHdr;
            PoolIndex  += 1;

        }

        //
        // if we never started tracing a linked list,
        // then we should bail because no further searches
        //      will yield a list
        //
        if (!Tracing) {
            
#if DBG_SCAN
            dprintf("no new valid headers found: giving up poolheader scanning\n");
#endif
            
            break;
        }

        StartHeader += SizeOfPoolHdr;

    }

    return Status;
}

NTSTATUS
ResolvePoolHeaders(
    IN      ULONG64 PoolPageToDump,
    IN OUT  PVOID   Data,
    IN      ULONG   DataLength
    )
/*++

Description:

    This routine does the main work of resolving broken links in
    the pool header meta information.  Given the raw pool header
    info, this routine tries to fix broken forward and back links.
    It also determines contiguous linked lists (passes) as well
    as marking various pool header attributes.

Arguments:

    PoolPageToDump  - page to analyze
    Data            - the pool header info
    DataLength      - the # of entries in the header info

Returns:

    None

--*/
{

    PVALIDATE_POOL_HEADER_INFO  PoolHeaderInfo;
    ULONG   i;
    ULONG   j;
    ULONG   Pass;
    BOOLEAN Found;
    ULONG   PoolHeaderInfoLength;
    ULONG   SizeOfPoolHdr;
    UINT64  StartPage;
    NTSTATUS    Status;

    //
    // default: we were successful
    //
    Status = STATUS_SUCCESS;

    //
    //
    //
    SizeOfPoolHdr       = GetTypeSize("nt!_POOL_HEADER");
    StartPage           = PAGE_ALIGN64(PoolPageToDump);

    PoolHeaderInfo          = (PVALIDATE_POOL_HEADER_INFO)Data;
    PoolHeaderInfoLength    = DataLength;

    Pass = 0;

    //
    // while we continue to find linked lists,
    // continue to process them.
    //
    // when the pool page was scanned, we marked each unique linked list
    // with the pass # that it was found/traced on.  Here, we
    // are looking for all the nodes - i.e., the list which belong
    // to our current pass.
    //
    // If we do not find (Found == FALSE) a linked list, then
    // we have processed all the scanned lists.
    //
    do {

#if DBG_RESOLVE
        dprintf("ResolvePoolHeaders: Pass = %d\n", Pass);
#endif
        
        if ( CheckControlC() ) {
            break;
        }

        //
        // advance to the next pass
        //
        Pass += 1;
        
        //
        // default: there is no linked list in this pass
        //
        Found = FALSE;

        //
        // for every header in the pool page 
        //  find the beginning of the linked list belonging to our pass
        //  if necessary, attempt to repair any broken nodes.
        //
        for (i = 0; i < PoolHeaderInfoLength; i++) {

#if DBG_RESOLVE
            dprintf("ResolvePoolHeaders: PoolHeaderInfo[%d].Info = %d\n", i, PoolHeaderInfo[i].Info);
#endif
            
            //
            // Look for all the nodes which belong to our current pass
            //
            if (PoolHeaderInfo[i].Pass == Pass) {

                //
                // we found a linked list - of atleast 1 node
                //
                Found = TRUE;

                //
                // if the node is the head of a list
                //
                if (PoolHeaderInfo[i].Info & HEADER_FIRST_LINK) {

                    //
                    // start of list
                    //

                    if (PoolHeaderInfo[i].Info & HEADER_BACK_LINK) {

                        if (PoolHeaderInfo[i].Info & HEADER_START_PAGE_BLOCK) {

                            //
                            // back link is valid
                            //
                            NOTHING;

                        } else {

                            //
                            // invalid condition:
                            //
                            // this implies that the node is the first node of a list,
                            // it has a valid back link, but is not the first
                            // node of a pool page.
                            //
                            dprintf("\n");
                            dprintf("error: Inconsistent condition occured while resolving @ %p.\n", PoolHeaderInfo[i].Node);
                            dprintf("error: Node is the first node of a list and it has a valid back link,\n");
                            dprintf("error: but the node is not at the start of the page\n");
                            dprintf("\n");

                            Status = STATUS_UNSUCCESSFUL;

                            break;                     

                        }

                    } else {

                        ULONG   k;
                        ULONG   target;
                        BOOLEAN bHaveTarget;

                        bHaveTarget = FALSE;

                        //
                        // node does not have a valid back link
                        //
                        if (PoolHeaderInfo[i].Info & HEADER_START_PAGE_BLOCK) {

                            PoolHeaderInfo[i].Info              |= HEADER_FIXED_BACK_LINK;
                            PoolHeaderInfo[i].FixedPreviousSize = 0;

                            continue;

                        }

                        //
                        // validate the forward link of the previous node:
                        //
                        // assume the back link of the current node (i) is broken:
                        // attempt to find a node that has a forward
                        // link that refers to this node
                        //
                        for (k = 0; k < i; k++) {

                            //
                            // see if the forward link refers to our node
                            //
                            bHaveTarget = (PoolHeaderInfo[k].ForwardLink == PoolHeaderInfo[i].Node);

                            //
                            // make sure the node has a broken forward link
                            //
                            bHaveTarget = bHaveTarget && (! (PoolHeaderInfo[k].Info & HEADER_FORWARD_LINK));

                            if (bHaveTarget) {
                                target = k;
                                break;
                            }

                        }
                        if (bHaveTarget) {

                            //
                            // we have found a node whose forward link refers to
                            // the current node.
                            // therefore, the current node's previous size is corrupted
                            // we can correct it using the previous node's blocksize
                            //
                            PoolHeaderInfo[i].Info              |= HEADER_FIXED_BACK_LINK;
                            PoolHeaderInfo[i].FixedPreviousSize =
                                (PoolHeaderInfo[i].Node - PoolHeaderInfo[k].Node) >> POOL_BLOCK_SHIFT;

                            //
                            // we now know the forward link of the target node is correct
                            //
                            PoolHeaderInfo[k].Info              |= HEADER_FORWARD_LINK;

                            continue;

                        }

                        //
                        // validate back link of this node:
                        //
                        // assume the forward link of a previous node (k) is broken:
                        // determine if the node that this node's back link
                        // refers to is valid
                        //
                        for (k = 0; k < i; k++) {

                            //
                            // see if the current node's back link refers to any previous node
                            //
                            bHaveTarget = (PoolHeaderInfo[k].Node == PoolHeaderInfo[i].BackLink);

                            //
                            // make sure the node has a broken forward link
                            //
                            bHaveTarget = bHaveTarget && (! (PoolHeaderInfo[k].Info & HEADER_FORWARD_LINK));

                            if (bHaveTarget) {
                                target = k;
                                break;
                            }

                        }
                        if (bHaveTarget) {

                            //
                            // we have found a node that the current node's backlink refers to.
                            // therefore, the current node's previous size is valid
                            // we can correct it using the previous node's blocksize
                            //
                            PoolHeaderInfo[k].Info              |= HEADER_FIXED_FORWARD_LINK;
                            PoolHeaderInfo[k].FixedBlockSize =
                                (PoolHeaderInfo[i].Node - PoolHeaderInfo[k].Node) >> POOL_BLOCK_SHIFT;

                            //
                            // we now know the back link of our current node is correct
                            //
                            PoolHeaderInfo[i].Info              |= HEADER_BACK_LINK;

                            continue;

                        }

                        //
                        // otherwise:
                        //
                        //  the back link of this node is broken
                        //  the forward link of the previous known good
                        //      node is broken
                        //
                        //  hence there is a corrupt region between
                        //  and possibly including portions of these nodes
                        //
                        NOTHING;

                    }

                }

                //
                // if the node is the tail of a list
                //
                if (PoolHeaderInfo[i].Info & HEADER_LAST_LINK) {

                    if (PoolHeaderInfo[i].Info & HEADER_END_PAGE_BLOCK) {

                        //
                        // the forward link of this node is valid
                        //
                        NOTHING;

                    } else {

                        ULONG   k;
                        ULONG   target;
                        BOOLEAN bHaveTarget;

                        bHaveTarget = FALSE;

                        //
                        // the last link of a list should always point
                        // to the page end, hence
                        // the forward link of this node is INVALID/corrupt
                        //

                        //
                        // validate the back link of the next node:
                        //
                        // assume the forward link for the current node (i) is bad:
                        // attempt to find a node that has a back
                        // link that refers to this node
                        //
                        for (k = i+1; k < PoolHeaderInfoLength; k++) {

                            //
                            // see if the a following node refers to the current node
                            //
                            bHaveTarget = (PoolHeaderInfo[k].BackLink == PoolHeaderInfo[i].Node);

                            //
                            // make sure the following node is missing it's back link
                            //
                            bHaveTarget = bHaveTarget && (! (PoolHeaderInfo[k].Info & HEADER_BACK_LINK));

                            if (bHaveTarget) {
                                target = k;
                                break;
                            }

                        }
                        if (bHaveTarget) {

                            //
                            // we have found a node whose forward link refers to
                            // the current node.
                            // therefore, the current node's previous size is corrupted
                            // we can correct it using the previous node's blocksize
                            //
                            PoolHeaderInfo[i].Info          |= HEADER_FIXED_FORWARD_LINK;
                            PoolHeaderInfo[i].FixedBlockSize =
                                (PoolHeaderInfo[k].Node - PoolHeaderInfo[i].Node) >> POOL_BLOCK_SHIFT;

                            //
                            // we now know the back link of our target node is correct
                            //
                            PoolHeaderInfo[k].Info          |= HEADER_BACK_LINK;

                            continue;

                        }

                        //
                        // validate forward link of this node:
                        //
                        // assume the back link for a following node (k) is bad:
                        // determine if the node that this node's forward link
                        // refers to is valid
                        //
                        for (k = i+1; k < PoolHeaderInfoLength; k++) {

                            //
                            // see if the a following node refers to the current node
                            //
                            bHaveTarget = (PoolHeaderInfo[k].Node == PoolHeaderInfo[i].ForwardLink);

                            //
                            // make sure the following node is missing it's back link
                            //
                            bHaveTarget = bHaveTarget && (! (PoolHeaderInfo[k].Info & HEADER_BACK_LINK));

                            if (bHaveTarget) {
                                target = k;
                                break;
                            }

                        }
                        if (bHaveTarget) {

                            //
                            // we have found a node whose forward link refers to
                            // the current node.
                            // therefore, the current node's previous size is corrupted
                            // we can correct it using the previous node's blocksize
                            //
                            PoolHeaderInfo[k].Info              |= HEADER_FIXED_BACK_LINK;
                            PoolHeaderInfo[k].FixedPreviousSize =
                                (PoolHeaderInfo[k].Node - PoolHeaderInfo[i].Node) >> POOL_BLOCK_SHIFT;

                            //
                            // we now know the back link of our target node is correct
                            //
                            PoolHeaderInfo[i].Info              |= HEADER_FORWARD_LINK;

                            continue;

                        }


                        //
                        // otherwise:
                        //
                        //  the forward link of this node is broken
                        //  the back link of the next known good
                        //      node is broken
                        //
                        //  hence there is a corrupt region between
                        //  and possibly including portions of these nodes
                        //
                        NOTHING;

                    }

                }

            } else {

                //
                // Node was not part of linked list belonging to this pass
                // 
                NOTHING;

            }

        }

        if (! NT_SUCCESS(Status)) {
            break;
        }

    } while ( Found );

    return Status;

}

VOID
DumpPoolHeaderInfo(
    IN      ULONG64 PoolPageToDump,
    IN OUT  PVOID   Data,
    IN      ULONG   DataLength,
    IN      ULONG   i,
    IN      UCHAR   Verbose
    )
/*++

Description:

    Debug utility

    dump a SINGLE pool header meta info structure that has been collected

Arguments:

    PoolPageToDump  - page to analyze
    Data            - the pool header info
    DataLength      - the # of entries in the header info
    i               - the structure to dump

Returns:

    None

--*/
{

    PVALIDATE_POOL_HEADER_INFO  PoolHeaderInfo;
    ULONG   PoolHeaderInfoLength;
    UINT64  StartPage;
    ULONG   SizeOfPoolHdr;

    //
    //
    //
    StartPage               = PAGE_ALIGN64(PoolPageToDump);
    SizeOfPoolHdr           = GetTypeSize("nt!_POOL_HEADER");

    PoolHeaderInfo          = (PVALIDATE_POOL_HEADER_INFO)Data;
    PoolHeaderInfoLength    = DataLength;

    //
    //
    //
    {
        BOOLEAN First;

        First = TRUE;

        dprintf("[ %p ]:", StartPage + (i*SizeOfPoolHdr));

        if (PoolHeaderInfo[i].Info & HEADER_FIRST_LINK) {
            dprintf("%s FIRST_LINK", !First ? " |" : ""); First = FALSE;
        }
        if (PoolHeaderInfo[i].Info & HEADER_LAST_LINK) {
            dprintf("%s LAST_LINK", !First ? " |" : ""); First = FALSE;
        }
        if (PoolHeaderInfo[i].Info & HEADER_START_PAGE_BLOCK) {
            dprintf("%s START_PAGE_BLOCK", !First ? " |" : ""); First = FALSE;
        }
        if (PoolHeaderInfo[i].Info & HEADER_END_PAGE_BLOCK) {
            dprintf("%s END_PAGE_BLOCK", !First ? " |" : ""); First = FALSE;
        }
        if (First) {
            dprintf(" interior node");
        }
        dprintf("\n");

    }

    if (PoolHeaderInfo[i].Info & HEADER_BACK_LINK) {

        dprintf(
            "[ %p ]: back link [ %p ]\n",
            PoolHeaderInfo[i].Node,
            PoolHeaderInfo[i].BackLink
            );

    }

    if (PoolHeaderInfo[i].Info & HEADER_FORWARD_LINK) {

        dprintf(
            "[ %p ]: forward link [ %p ]\n",
            PoolHeaderInfo[i].Node,
            PoolHeaderInfo[i].ForwardLink
            );

    }

    if (PoolHeaderInfo[i].Info & HEADER_FIXED_BACK_LINK) {

        ULONG   PreviousSize;

        GetFieldValue( PoolHeaderInfo[i].Node, "nt!_POOL_HEADER", "PreviousSize", PreviousSize);

        dprintf(
            "[ %p ]: invalid previous size [ %d ] should be [ %d ]\n",
            PoolHeaderInfo[i].Node,
            PreviousSize,
            PoolHeaderInfo[i].FixedPreviousSize
            );

    }

    if (PoolHeaderInfo[i].Info & HEADER_FIXED_FORWARD_LINK) {

        ULONG   BlockSize;

        GetFieldValue( PoolHeaderInfo[i].Node, "nt!_POOL_HEADER", "BlockSize", BlockSize);

        dprintf(
            "[ %p ]: invalid block size [ %d ] should be [ %d ]\n",
            PoolHeaderInfo[i].Node,
            BlockSize,
            PoolHeaderInfo[i].FixedBlockSize
            );

    }

}

VOID
DiagnosePoolHeadersDumpInfo(
    IN      ULONG64 PoolPageToDump,
    IN OUT  PVOID   Data,
    IN      ULONG   DataLength,
    IN      UCHAR   Verbose
    )
/*++

Description:

    Debug utility

    dump all of the pool header meta info that has been collected

Arguments:

    PoolPageToDump  - page to analyze
    Data            - the pool header info
    DataLength      - the # of entries in the header info

Returns:

    None

--*/
{

    PVALIDATE_POOL_HEADER_INFO  PoolHeaderInfo;
    ULONG64 i;
    ULONG   PoolHeaderInfoLength;
    UINT64  StartPage;
    ULONG   SizeOfPoolHdr;

    //
    //
    //
    StartPage               = PAGE_ALIGN64(PoolPageToDump);
    SizeOfPoolHdr           = GetTypeSize("nt!_POOL_HEADER");

    PoolHeaderInfo          = (PVALIDATE_POOL_HEADER_INFO)Data;
    PoolHeaderInfoLength    = DataLength;

    for (i = 0; i < PoolHeaderInfoLength; i++) {

        if ( CheckControlC() ) {
            break;
        }

        if (! IS_VALID_PASS(PoolHeaderInfo[i].Pass)) {
            continue;
        }

        DumpPoolHeaderInfo(
            PoolPageToDump,
            Data,
            DataLength,
            (ULONG)i,
            Verbose
            );

        dprintf("\n");

    }

}

BOOLEAN
DiagnosePoolHeadersIsValid(
    IN      ULONG64 PoolPageToDump,
    IN OUT  PVOID   Data,
    IN      ULONG   DataLength
    )
/*++

Description:

    Determines if a pool page is corrupt

Arguments:

    PoolPageToDump  - page to analyze
    Data            - the pool header info
    DataLength      - the # of entries in the header info

Returns:

    TRUE    - page is corrupt
    FALSE   - page is NOT corrupt

--*/
{

    PVALIDATE_POOL_HEADER_INFO  PoolHeaderInfo;
    ULONG64 i;
    ULONG   PoolHeaderInfoLength;
    BOOLEAN IsValid;
    UINT64  StartPage;
    ULONG   SizeOfPoolHdr;

    //
    //
    //
    StartPage           = PAGE_ALIGN64(PoolPageToDump);
    SizeOfPoolHdr       = GetTypeSize("nt!_POOL_HEADER");

    PoolHeaderInfo          = (PVALIDATE_POOL_HEADER_INFO)Data;
    PoolHeaderInfoLength    = DataLength;

    IsValid = TRUE;

    i=0;
    while ( i < PoolHeaderInfoLength ) {

        if ( CheckControlC() ) {
            break;
        }

        if (IS_VALID_PASS(PoolHeaderInfo[i].Pass)) {

            //
            // if both links are valid,
            // then follow the forward link
            // else the list is invalid
            //
            if ((PoolHeaderInfo[i].Info & HEADER_BACK_LINK) &&
                (PoolHeaderInfo[i].Info & HEADER_FORWARD_LINK)) {

                i = (PoolHeaderInfo[i].ForwardLink - StartPage) / SizeOfPoolHdr;

            } else {

                IsValid = FALSE;

                break;

            }

        } else {

            IsValid = FALSE;

            break;

        }

    }

    return IsValid;

}

VOID
DiagnosePoolHeadersDisplayLists(
    IN      ULONG64 PoolPageToDump,
    IN OUT  PVOID   Data,
    IN      ULONG   DataLength,
    IN      UCHAR   Verbose
    )
/*++

Description:

    This routine displays all of the linked lists in a given pool page

Arguments:

    PoolPageToDump  - page to analyze
    Data            - the pool header info
    DataLength      - the # of entries in the header info

Returns:

    none

--*/
{

    PVALIDATE_POOL_HEADER_INFO  PoolHeaderInfo;
    ULONG   i;
    ULONG   j;
    ULONG   PoolHeaderInfoLength;
    UINT64  StartPage;
    ULONG   SizeOfPoolHdr;

    //
    //
    //
    StartPage           = PAGE_ALIGN64(PoolPageToDump);
    SizeOfPoolHdr       = GetTypeSize("nt!_POOL_HEADER");

    PoolHeaderInfo          = (PVALIDATE_POOL_HEADER_INFO)Data;
    PoolHeaderInfoLength    = DataLength;

    for (i = 0; i < PoolHeaderInfoLength; i++) {

        if ( CheckControlC() ) {
            break;
        }

        if (IS_VALID_PASS(PoolHeaderInfo[i].Pass)) {

            //
            //
            //
#if 0
            if (Verbose & VERBOSE_SHOW_HEADER_INFO) {
                dprintf("[ headerinfo = %02x @ %p ]: ", PoolHeaderInfo[i].Info, StartPage + (i*SizeOfPoolHdr));
            } else {
                dprintf("[ %p ]: ", StartPage + (i*SizeOfPoolHdr));
            }

            for (j = 0; j < PoolHeaderInfo[i].Pass; j++) {

                dprintf("  ");

            }

            dprintf("%02d\r\n", PoolHeaderInfo[i].Pass);

#else

            if (Verbose & VERBOSE_SHOW_HEADER_INFO) {

                DumpPoolHeaderInfo(
                    PoolPageToDump,
                    Data,
                    DataLength,
                    (ULONG)i,
                    Verbose
                    );

            }

            dprintf("[ %p ]: ", StartPage + (i*SizeOfPoolHdr));

            for (j = 0; j < PoolHeaderInfo[i].Pass; j++) {

                dprintf("  ");

            }

            dprintf("%02d\r\n", PoolHeaderInfo[i].Pass);

            if (Verbose & VERBOSE_SHOW_HEADER_INFO) {
                dprintf("\n");
            }

#endif

        }

    }

}

NTSTATUS
FindLongestList(
    IN      ULONG64 PoolPageToDump,
    IN OUT  PVOID   Data,
    IN      ULONG   DataLength,
    OUT     PULONG  PassStart
    )
/*++

Description:

    Find the longest contiguous linked list in the pool page

Arguments:

    PoolPageToDump  - page to analyze
    Data            - the pool header info
    DataLength      - the # of entries in the header info
    PassStart       - List # we think is the start of the longest list

Returns:

    status

--*/
{
    NTSTATUS    Status;
    PVALIDATE_POOL_HEADER_INFO  PoolHeaderInfo;
    ULONG64 i;
    ULONG   PoolHeaderInfoLength;
    BOOLEAN InCorruptedRegion;
    UINT64  CorruptedRegionStart;
    ULONG   CorruptedRegionPassStart;
    UINT    MaxListPassStart;
    UINT    MaxListLength;
    BOOLEAN Found;
    ULONG   Pass;
    ULONG   SizeOfPoolHdr;
    ULONG64 StartPage;
    ULONG   ListLength;
    ULONG   ListPassStart;

    //
    // default: we were successful
    //
    Status = STATUS_SUCCESS;

    //
    //
    //
    PoolHeaderInfo          = (PVALIDATE_POOL_HEADER_INFO)Data;
    PoolHeaderInfoLength    = DataLength;

    //
    //
    //
    MaxListPassStart    = 0;
    MaxListLength       = 0;
    *PassStart          = 0;

    Pass                = 0;

    StartPage           = PAGE_ALIGN64(PoolPageToDump);
    SizeOfPoolHdr       = GetTypeSize("nt!_POOL_HEADER");

    do {

        if ( CheckControlC() ) {
            break;
        }

        Pass++;

        InCorruptedRegion   = FALSE;

        ListLength          = 0;
        ListPassStart       = Pass;

        Found               = FALSE;

        for (i = 0; i < PoolHeaderInfoLength; i++) {
            if (PoolHeaderInfo[i].Pass == Pass) {
                Found = TRUE;
                break;
            }
        }

        while (i < PoolHeaderInfoLength) {

            if ( CheckControlC() ) {
                break;
            }

            //
            // make sure we arent in an infinite loop
            //
            // if we are, then we could be looking at memory
            // that is not available - mini dump and PoolPageToDump = 0
            //
            if (ListLength > MAX_POOL_HEADER_COUNT) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if (IS_VALID_PASS(PoolHeaderInfo[i].Pass)) {

                //
                // if we are in a corrupt region,
                // then determine if where we are in the region.
                //
                if (InCorruptedRegion) {

                    //
                    // ignore nodes that are clearly part of another
                    // linked list
                    // if we are tracing the longest list,
                    // then these nodes are considered spurious
                    //
                    if ((PoolHeaderInfo[i].Info & HEADER_BACK_LINK) ||
                        (PoolHeaderInfo[i].Info & HEADER_FIXED_BACK_LINK)) {

                        //
                        // we've hit the middle of another linked list so
                        // continue until we find the beginning of a
                        // list
                        //
                        i++;

                        continue;

                    } else {

                        //
                        // we've found the beginning of a new list
                        // and are no longer in a Corrupt region
                        //
                        InCorruptedRegion = FALSE;

                    }

                }

                //
                //
                //
                if ((PoolHeaderInfo[i].Info & HEADER_FORWARD_LINK) ||
                    (PoolHeaderInfo[i].Info & HEADER_FIXED_FORWARD_LINK)) {

                    ListLength++;

                    if (PoolHeaderInfo[i].Info & HEADER_FORWARD_LINK) {

                        i = (PoolHeaderInfo[i].ForwardLink - StartPage) / SizeOfPoolHdr;

                    } else if (PoolHeaderInfo[i].Info & HEADER_FIXED_FORWARD_LINK) {

                        UINT64  offset;

                        offset = PoolHeaderInfo[i].FixedBlockSize << POOL_BLOCK_SHIFT;

                        i = ((PoolHeaderInfo[i].Node + offset) - StartPage ) / SizeOfPoolHdr;

                    }

                    continue;

                } else {

                    //
                    //
                    //
                    CorruptedRegionStart = PoolHeaderInfo[i].Node;
                    CorruptedRegionPassStart = PoolHeaderInfo[i].Pass;

                    InCorruptedRegion = TRUE;

                }

            }

            //
            // if pool header was not valid,
            // then increment by one header
            //
            i++;

        }

        if (! NT_SUCCESS(Status)) {
            break;
        }

        if (ListLength > MaxListLength) {
            MaxListLength       = ListLength;
            MaxListPassStart    = ListPassStart;
        }

    } while ( Found );

    if (NT_SUCCESS(Status)) {
        //
        // send back the max list start point
        //
        *PassStart = MaxListPassStart;
    } 
    
    return Status;
}

NTSTATUS
AnalyzeLongestList(
    IN      ULONG64 PoolPageToDump,
    IN OUT  PVOID   Data,
    IN      ULONG   DataLength,
    IN      ULONG   PassStart,
    IN      UCHAR   Verbose
    )
/*++

Description:

    Attempt to diagnose the longest linked list.

Arguments:

    PoolPageToDump  - page to analyze
    Data            - the pool header info
    DataLength      - the # of entries in the header info
    PassStart       - the list # that we think is the beginning
                      of the longest list
    Verbose         - the level of spew

Returns:

    None

--*/
{
    NTSTATUS    Status;
    PVALIDATE_POOL_HEADER_INFO  PoolHeaderInfo;
    ULONG64 i;
    ULONG   PoolHeaderInfoLength;
    BOOLEAN InCorruptedRegion;
    UINT64  CorruptedRegionStart;
    ULONG   CorruptedRegionPassStart;
    ULONG   Pass;
    ULONG   SizeOfPoolHdr;
    ULONG64 StartPage;

    //
    // default: we were successful
    //
    Status = STATUS_SUCCESS;

    //
    //
    //
    PoolHeaderInfo          = (PVALIDATE_POOL_HEADER_INFO)Data;
    PoolHeaderInfoLength    = DataLength;

    Pass                    = PassStart;

    if (PassStart > 0) {
        Pass--;
    }

    StartPage           = PAGE_ALIGN64(PoolPageToDump);
    SizeOfPoolHdr       = GetTypeSize("nt!_POOL_HEADER");

    Pass++;

    InCorruptedRegion   = FALSE;

    for (i = 0; i < PoolHeaderInfoLength; i++) {
        if (PoolHeaderInfo[i].Pass == Pass) {
            break;
        }
    }

    while (i < PoolHeaderInfoLength) {

        if ( CheckControlC() ) {
            break;
        }

        if (IS_VALID_PASS(PoolHeaderInfo[i].Pass)) {

            //
            // if we are in a corrupt region,
            // then determine if where we are in the region.
            //
            if (InCorruptedRegion) {

                //
                // ignore nodes that are clearly part of another
                // linked list
                // if we are tracing the longest list,
                // then these nodes are considered spurious
                //
                if ((PoolHeaderInfo[i].Info & HEADER_BACK_LINK) ||
                    (PoolHeaderInfo[i].Info & HEADER_FIXED_BACK_LINK)) {

                    //
                    // we've hit the middle of another linked list so
                    // continue until we find the beginning of a
                    // list
                    //

                    if (Verbose & VERBOSE_SHOW_ALL) {
                        dprintf("[ %p ]: found middle node in Corrupt region\n", PoolHeaderInfo[i].Node);
                    }

                    i++;

                    continue;

                } else {

                    //
                    // we've found the beginning of a new list
                    // and are no longer in a Corrupt region
                    //

                    if (Verbose & VERBOSE_SHOW_ALL) {
                        dprintf("[ %p ]: Corrupt region stopped\n", PoolHeaderInfo[i].Node);
                    }

                    dprintf("[ %p --> %p (size = 0x%x bytes)]: Corrupt region\n",
                            CorruptedRegionStart,
                            PoolHeaderInfo[i].Node,
                            PoolHeaderInfo[i].Node - CorruptedRegionStart
                            );

                    InCorruptedRegion = FALSE;

                }

            }

            //
            // emit
            //
            if (Verbose) {

                //
                // emit the current node info
                //
                {
                    ULONG   j;

                    //
                    //
                    //
#if 1
                    if (Verbose & VERBOSE_SHOW_HEADER_INFO) {
                        dprintf("[ headerinfo = 0x%02x @ %p ]: ", PoolHeaderInfo[i].Info, StartPage + (i*SizeOfPoolHdr));
                    } else {
                        dprintf("[ %p ]: ", StartPage + (i*SizeOfPoolHdr));
                    }
#else
                    dprintf("[ %p ]: ", StartPage + (i*SizeOfPoolHdr));
#endif

                    for (j = 0; j < PoolHeaderInfo[i].Pass; j++) {

                        dprintf("  ");

                    }

                    dprintf("%02d\r\n", PoolHeaderInfo[i].Pass);

                }

            }

            //
            // if the back link is corrected,
            // then display the correction
            //
            if (PoolHeaderInfo[i].Info & HEADER_FIXED_BACK_LINK) {

                ULONG   PreviousSize;

                GetFieldValue( PoolHeaderInfo[i].Node, "nt!_POOL_HEADER", "PreviousSize", PreviousSize);

                dprintf(
                    "[ %p ]: invalid previous size [ 0x%x ] should be [ 0x%x ]\n",
                    PoolHeaderInfo[i].Node,
                    PreviousSize,
                    PoolHeaderInfo[i].FixedPreviousSize
                    );

            }

            //
            //
            //
            if ((PoolHeaderInfo[i].Info & HEADER_FORWARD_LINK) ||
                (PoolHeaderInfo[i].Info & HEADER_FIXED_FORWARD_LINK)) {

                if (PoolHeaderInfo[i].Info & HEADER_FORWARD_LINK) {

//                    dprintf("using good forward link: %p\n", PoolHeaderInfo[i].ForwardLink);

                    i = (PoolHeaderInfo[i].ForwardLink - StartPage) / SizeOfPoolHdr;

                } else if (PoolHeaderInfo[i].Info & HEADER_FIXED_FORWARD_LINK) {

                    UINT64  offset;
                    ULONG   BlockSize;

                    GetFieldValue( PoolHeaderInfo[i].Node, "nt!_POOL_HEADER", "BlockSize", BlockSize);

                    dprintf(
                        "[ %p ]: invalid block size [ 0x%x ] should be [ 0x%x ]\n",
                        PoolHeaderInfo[i].Node,
                        BlockSize,
                        PoolHeaderInfo[i].FixedBlockSize
                        );

                    offset = PoolHeaderInfo[i].FixedBlockSize << POOL_BLOCK_SHIFT;

                    i = ((PoolHeaderInfo[i].Node + offset) - StartPage ) / SizeOfPoolHdr;

                }

                continue;

            } else {

                //
                //
                //
                CorruptedRegionStart = PoolHeaderInfo[i].Node;
                CorruptedRegionPassStart = PoolHeaderInfo[i].Pass;

                if (Verbose & VERBOSE_SHOW_ALL) {
                    dprintf("[ %p ]: Corrupt region started\n", CorruptedRegionStart);
                }

                InCorruptedRegion = TRUE;

            }

        }

        //
        // if pool header was not valid,
        // then increment by one header
        //
        i++;

    }

    return Status;

}

NTSTATUS
DiagnosePoolHeadersAnalyzeLongestList(
    IN      ULONG64 PoolPageToDump,
    IN OUT  PVOID   Data,
    IN      ULONG   DataLength,
    IN      UCHAR   Verbose
    )
/*++

Description:

    Determines the longest contiguous linked list in the pool page.

    We make the conclusion that the longest list is likely to be
    the original, uncorrupted list.

Arguments:

    PoolPageToDump  - page to analyze
    Data            - the pool header info
    DataLength      - the # of entries in the header info
    Verbose         - level of verbosity

Returns:

    None

--*/
{
    NTSTATUS    Status;
    ULONG       PassStart;

    do {

        //
        // first, find the longest list
        //
        Status = FindLongestList(
            PoolPageToDump,
            Data,
            DataLength,
            &PassStart
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // once we have found the longest list
        // we then try to analyze it
        //
        Status = AnalyzeLongestList(
            PoolPageToDump,
            Data,
            DataLength,
            PassStart,
            Verbose
            );
    
    } while ( FALSE );

    return Status;
}

ULONG
GetHammingDistance(
    ULONG   a,
    ULONG   b
    )
{
    ULONG   x;
    ULONG   r;

    x = a ^ b;

    x -= ((x >> 1) & 0x55555555);
    x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
    x = (((x >> 4) + x) & 0x0f0f0f0f);
    x += (x >> 8);
    x += (x >> 16);

    r = (x & 0x0000003f);

//    dprintf("a = %d, b = %d, r = %d\n", a, b, r);

    return(r);
}

VOID
DiagnosePoolHeadersSingleBitErrors(
    IN      ULONG64 PoolPageToDump,
    IN OUT  PVOID   Data,
    IN      ULONG   DataLength,
    IN      UCHAR   Verbose
    )
/*++

Description:

    Determins if & where there are any single bit errors in the pool headers.

Arguments:

    PoolPageToDump  - page to analyze
    Data            - the pool header info
    DataLength      - the # of entries in the header info

Returns:

    None

--*/
{

    PVALIDATE_POOL_HEADER_INFO  PoolHeaderInfo;
    ULONG   i;
    ULONG   PoolHeaderInfoLength;
    UINT64  StartPage;
    BOOLEAN Found;
    ULONG   SizeOfPoolHdr;

    //
    //
    //
    StartPage               = PAGE_ALIGN64(PoolPageToDump);
    SizeOfPoolHdr           = GetTypeSize("nt!_POOL_HEADER");

    PoolHeaderInfo          = (PVALIDATE_POOL_HEADER_INFO)Data;
    PoolHeaderInfoLength    = DataLength;

    Found                   = FALSE;

    for (i = 0; i < PoolHeaderInfoLength; i++) {

        if ( CheckControlC() ) {
            break;
        }

        if (IS_VALID_PASS(PoolHeaderInfo[i].Pass)) {

            //
            //
            //
            if (PoolHeaderInfo[i].Info & HEADER_FIXED_BACK_LINK) {

                ULONG   PreviousSize;
                ULONG   HammingDistance;

                GetFieldValue( PoolHeaderInfo[i].Node, "nt!_POOL_HEADER", "PreviousSize", PreviousSize);

                //
                //
                //
                HammingDistance = GetHammingDistance(
                    PreviousSize,
                    (ULONG)PoolHeaderInfo[i].FixedPreviousSize
                    );

                if (HammingDistance == 1) {

                    Found = TRUE;

                    //
                    //
                    //
#if 0
                    if (Verbose & VERBOSE_SHOW_HEADER_INFO) {
                        dprintf("[ headerinfo = 0x%02x @ %p ]: ", PoolHeaderInfo[i].Info, StartPage + (i*SizeOfPoolHdr));
                    } else {
                        dprintf("[ %p ]: ", StartPage + (i*SizeOfPoolHdr));
                    }
                    dprintf(
                        "previous size [ 0x%x ] should be [ 0x%x ]\n",
                        PreviousSize,
                        PoolHeaderInfo[i].FixedPreviousSize
                        );

#else

                    dprintf("[ %p ]: ", StartPage + (i*SizeOfPoolHdr));
                    dprintf(
                        "previous size [ 0x%x ] should be [ 0x%x ]\n",
                        PreviousSize,
                        PoolHeaderInfo[i].FixedPreviousSize
                        );

#endif
                }

            }

            if (PoolHeaderInfo[i].Info & HEADER_FIXED_FORWARD_LINK) {

                ULONG   BlockSize;
                ULONG   HammingDistance;

                GetFieldValue( PoolHeaderInfo[i].Node, "nt!_POOL_HEADER", "BlockSize", BlockSize);

                //
                //
                //
                HammingDistance = GetHammingDistance(
                    BlockSize,
                    (ULONG)PoolHeaderInfo[i].FixedPreviousSize
                    );

                if (HammingDistance == 1) {

                    Found = TRUE;

#if 0

                    if (Verbose & VERBOSE_SHOW_HEADER_INFO) {
                        dprintf("[ headerinfo = 0x%02x @ %p ]: ", PoolHeaderInfo[i].Info, StartPage + (i*SizeOfPoolHdr));
                    } else {
                        dprintf("[ %p ]: ", StartPage + (i*SizeOfPoolHdr));
                    }
                    dprintf(
                        "previous size [ 0x%x ] should be [ 0x%x ]\n",
                        PreviousSize,
                        PoolHeaderInfo[i].FixedPreviousSize
                        );

#else

                    dprintf("[ %p ]: ", StartPage + (i*SizeOfPoolHdr));
                    dprintf(
                        "block size [ 0x%x ] should be [ 0x%x ]\n",
                        BlockSize,
                        PoolHeaderInfo[i].FixedBlockSize
                        );

#endif

                }

            }

        }

    }

    if (!Found) {

        dprintf("\n");
        dprintf("None found\n");

    }

    dprintf("\n");

}

NTSTATUS
ValidatePoolPage(
    IN ULONG64  PoolPageToDump,
    IN UCHAR    Verbose
    )
/*++

Description:

    Provides the core, high level, functionality of analyzing the pool page

Arguments:

    PoolPageToDump  - page to analyze
    Verbose         - diagnostic level

Returns:

    Status

--*/
{
    PVALIDATE_POOL_HEADER_INFO  PoolHeaderInfo;
    NTSTATUS    Status;
    ULONG       PoolHeaderInfoSize;
    ULONG       PoolHeaderInfoLength;
    ULONG       SizeofPoolHdr;
    ULONG64     StartPage;
    BOOLEAN     IsValid;

    //
    //
    //
    Status              = STATUS_SUCCESS;

    SizeofPoolHdr       = GetTypeSize("nt!_POOL_HEADER");
    StartPage           = PAGE_ALIGN64(PoolPageToDump);

    PoolHeaderInfo      = NULL;
    PoolHeaderInfoSize  = 0;

    do {

        //
        // Allocate the pool header info array
        //
        PoolHeaderInfoLength    = (POOL_PAGE_SIZE / SizeofPoolHdr);
        PoolHeaderInfoSize      = sizeof(VALIDATE_POOL_HEADER_INFO) * PoolHeaderInfoLength;
        PoolHeaderInfo          = malloc(PoolHeaderInfoSize);

        if (PoolHeaderInfo == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(PoolHeaderInfo, PoolHeaderInfoSize);

        //
        // Construct the first layer of meta info:
        //
        // determine the link status for each pool header
        // in the page
        //
        Status = ScanPoolHeaders(
            PoolPageToDump,
            PoolHeaderInfo,
            PoolHeaderInfoSize
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }

        //
        // Construct the second layer of meta info:
        //
        // attempt to resolve the linked lists found
        // in the pool page
        //
        Status = ResolvePoolHeaders(
            PoolPageToDump,
            PoolHeaderInfo,
            PoolHeaderInfoLength
            );

        if (! NT_SUCCESS(Status)) {
            break;
        }
        
        //
        // begin diagnosis output
        //
        dprintf("\n");

        IsValid = DiagnosePoolHeadersIsValid(
            PoolPageToDump,
            PoolHeaderInfo,
            PoolHeaderInfoLength
            );

        dprintf("Pool page [ %p ] is %sVALID.\n",
            StartPage,
            IsValid ? "" : "IN"
            );

        if (! IsValid) {

            if (Verbose & VERBOSE_DUMP_HEADERS) {

                //
                //
                //
                dprintf("\n\n");
                dprintf("Displaying all POOL_HEADER meta info...\n");

                DiagnosePoolHeadersDumpInfo(
                    PoolPageToDump,
                    PoolHeaderInfo,
                    PoolHeaderInfoLength,
                    Verbose
                    );

            }

            if (Verbose & VERBOSE_SHOW_LISTS) {

                //
                //
                //
                dprintf("\n");
                dprintf("Displaying linked lists...\n");

                DiagnosePoolHeadersDisplayLists(
                    PoolPageToDump,
                    PoolHeaderInfo,
                    PoolHeaderInfoLength,
                    Verbose
                    );

            }

            //
            //
            //
            dprintf("\n");

            if (Verbose & VERBOSE_SHOW_LISTS) {
                dprintf("Analyzing longest linked list...\n");
            } else {
                dprintf("Analyzing linked list...\n");
            }

            Status = DiagnosePoolHeadersAnalyzeLongestList(
                PoolPageToDump,
                PoolHeaderInfo,
                PoolHeaderInfoLength,
                Verbose
                );

            if (! NT_SUCCESS(Status)) {
                break;
            }
            
            //
            //
            //
            dprintf("\n\n");
            dprintf("Scanning for single bit errors...\n");

            DiagnosePoolHeadersSingleBitErrors(
                PoolPageToDump,
                PoolHeaderInfo,
                PoolHeaderInfoLength,
                Verbose
                );

        } else {

            dprintf("\n");

        }

    } while ( FALSE );

    if (! NT_SUCCESS(Status)) {
        dprintf("\n");
        dprintf("Failed to diagnose pool page\n");
        dprintf("\n");
    }

    if (PoolHeaderInfo) {
        free(PoolHeaderInfo);
    }

    return Status;

}

NTSTATUS
DiagnosePoolPage(
    ULONG64 PoolPageToDump
    )
/*++

Routine Description:

    Diagnose a pool page for the !pool command.
    This routine is called if the !pool command detects an error while
    traversing a pool page.

Arguments:

    PoolPageToDump  - the page !pool was examining

Return Value:

    Status

--*/
{
    NTSTATUS            Status;
    DEBUG_POOL_REGION   Region;

    //
    // determine the pool region
    //
    Region = GetPoolRegion(PoolPageToDump);
        
    //
    // we only try to diagnose known pool regions
    //
    // you can manually diagnose using !poolval
    //
    //
    // Note: if someone passes us a 0 pool address, 
    //       then we proactively fail the diagnosis process
    //
    if ((Region == DbgPoolRegionUnknown) || (PoolPageToDump == 0)) {
    
        dprintf("\n");
        dprintf("***\n");
        dprintf("*** An error (or corruption) in the pool was detected;\n");
        dprintf("*** Pool Region unkown (0x%I64X)\n", PoolPageToDump);
        dprintf("***\n");
        dprintf("*** Use !poolval %p for more details.\n", PAGE_ALIGN64(PoolPageToDump));
        dprintf("***\n");
        dprintf("\n");

        Status = STATUS_SUCCESS;

    } else {
   
        dprintf("\n");
        dprintf("***\n");
        dprintf("*** An error (or corruption) in the pool was detected;\n");
        dprintf("*** Attempting to diagnose the problem.\n");
        dprintf("***\n");
        dprintf("*** Use !poolval %p for more details.\n", PAGE_ALIGN64(PoolPageToDump));
        dprintf("***\n");

        Status = ValidatePoolPage(
            PoolPageToDump,
            VERBOSE_SHOW_ERRORS_ONLY
            );
    
    }

    return Status;

}

DECLARE_API( poolval )

/*++

Routine Description:

    Provide in-depth heap diagnosis.

    Given a suspect pool page, the primary purpose of this command
    is to analyze the page and determine:

    1. where in the page the corruption exists.
    2. single bit errors in page headers (previous/block sizes)
    3. what the correct link list should be

Arguments:

    args - the page to analyze

Return Value:

    None

--*/

{
    ULONG64     PoolPageToDump;
    ULONG       Flags;
    HRESULT     Hr;

    INIT_API();

    Status = STATUS_SUCCESS;

    if (PoolInitializeGlobals() == FALSE) {
        Hr = E_INVALIDARG;
    } else {

        PoolPageToDump = 0;
        Flags = 0;
        if (GetExpressionEx(args, &PoolPageToDump, &args)) {
            Flags = (ULONG) GetExpression (args);
        }

        if (PoolPageToDump == 0) {
            Hr = S_OK;;
        } else {

            UCHAR       Verbose;

            //
            //
            //
            dprintf("Pool page %p region is ", PoolPageToDump);
            PrintPoolRegion(PoolPageToDump);

            //
            //
            //
            dprintf("\n");
            dprintf("Validating Pool headers for pool page: %p\n", PoolPageToDump);

            //
            //
            //
            Verbose = VERBOSE_SHOW_ERRORS_ONLY;
            switch (Flags) {
            case 2: Verbose |= VERBOSE_SHOW_LISTS | VERBOSE_SHOW_HEADER_INFO; break;
            case 3: Verbose |= VERBOSE_SHOW_LISTS | VERBOSE_SHOW_HEADER_INFO | VERBOSE_DUMP_HEADERS; break;

            case 1: Verbose |= VERBOSE_SHOW_LISTS;
            default:
                break;
            }

            //
            // Attempt to Analyze and Diagnose the specified poolpage
            //
            Status = ValidatePoolPage(
                PoolPageToDump,
                Verbose
                );

        }

    }
    EXIT_API();

    if (NT_SUCCESS(Status)) {
        Hr = S_OK;
    } else {
        Hr = E_FAIL;
    }

    return Hr;

}


DECLARE_API( poolused )

/*++

Routine Description:

    Dump usage by pool tag

Arguments:

    args -

    Flags : Bitfield with the following meaning:

            0x1: Dump both allocations & frees (instead of the difference)
            0x2: Sort by nonpaged pool consumption
            0x4: Sort by paged pool consumption
            0x8: Dump session space consumption

Return Value:

    None

--*/

{
    ULONG PoolTrackTableSize;
    ULONG PoolTrackTableSizeInBytes;
    ULONG PoolTrackTableExpansionSize;
    ULONG PoolTrackTableExpansionSizeInBytes;
    PPOOLTRACK_READ p;
    PPOOLTRACK_READ pentry;
    PPOOLTRACK_READ PoolTrackTableData;
    ULONG Flags;
    ULONG i;
    ULONG result;
    ULONG ct;
    ULONG TagName;
    CHAR TagNameX[4] = {'*','*','*','*'};
    ULONG SizeOfPoolTracker;
    ULONG64 PoolTableAddress;
    ULONG64 PoolTrackTable;
    ULONG64 PoolTrackTableExpansion;
    ULONG NonPagedAllocsTotal,NonPagedFreesTotal,PagedAllocsTotal,PagedFreesTotal;
    ULONG64 NonPagedBytesTotal, PagedBytesTotal;
    ULONG Processor, MaxProcessors;
    ULONG64 ExPoolTagTables;
    POOLTRACK_READ PoolTrackEntry;
    ULONG64  Location;

    ExPoolTagTables = GetExpression("nt!ExPoolTagTables");

    if (PoolInitializeGlobals() == FALSE) {
        return E_INVALIDARG;
    }

    Flags = 0;
    if (!sscanf(args,"%lx %c%c%c%c", &Flags, &TagNameX[0],
           &TagNameX[1], &TagNameX[2], &TagNameX[3])) {
        Flags = 0;
    }

    TagName = TagNameX[0] | (TagNameX[1] << 8) | (TagNameX[2] << 16) | (TagNameX[3] << 24);


    PoolTrackTableExpansionSize = 0;

    if (!(SizeOfPoolTracker = GetTypeSize("nt!_POOL_TRACKER_TABLE"))) {
        dprintf("Unable to get _POOL_TRACKER_TABLE : probably wrong symbols.\n");
        return E_INVALIDARG;
    }

    if (Flags & 0x8) {
        Location = GetExpression ("ExpSessionPoolTrackTable");
        if (!Location) {
            dprintf("Unable to get ExpSessionPoolTrackTable\n");
            return E_INVALIDARG;
        }

        ReadPointer(Location, &PoolTrackTable);
        PoolTrackTableSize = 0;
        PoolTrackTableSize = GetUlongValue ("nt!ExpSessionPoolTrackTableSize");
    }
    else {
        PoolTrackTable = GetNtDebuggerDataPtrValue( PoolTrackTable );
        PoolTrackTableSize = GetUlongValue ("nt!PoolTrackTableSize");
        PoolTrackTableExpansionSize = GetUlongValue ("nt!PoolTrackTableExpansionSize");
    }

    if (PoolTrackTable == 0) {
        dprintf ("unable to get PoolTrackTable - ");
        if (GetExpression("nt!PoolTrackTable")) {
            dprintf ("pool tagging is disabled, enable it to use this command\n");
            dprintf ("Use gflags.exe and check the box that says \"Enable pool tagging\".\n");
        } else {
            dprintf ("symbols could be worng\n");
        }
        return  E_INVALIDARG;
    }

    if (Flags & 2) {
        SortBy = NONPAGED_USED;
        dprintf("   Sorting by %s NonPaged Pool Consumed\n", Flags & 0x8 ? "Session" : "");
    } else if (Flags & 4) {
        SortBy = PAGED_USED;
        dprintf("   Sorting by %s Paged Pool Consumed\n", Flags & 0x8 ? "Session" : "");
    } else {
        SortBy = TAG;
        dprintf("   Sorting by %s Tag\n", Flags & 0x8 ? "Session" : "");
    }

    dprintf("\n  Pool Used:\n");
    if (!(Flags & 1)) {
        dprintf("            NonPaged            Paged\n");
        dprintf(" Tag    Allocs     Used    Allocs     Used\n");

    } else {
        dprintf("            NonPaged                    Paged\n");
        dprintf(" Tag    Allocs    Frees     Diff     Used   Allocs    Frees     Diff     Used\n");
    }



    //
    // Allocate a temp buffer, read the data, then free the data.
    // (KD will cache the data).
    //

    PoolTrackTableSizeInBytes = PoolTrackTableSize * SizeOfPoolTracker;

    PoolTrackTableExpansionSizeInBytes = PoolTrackTableExpansionSize * SizeOfPoolTracker;

    PoolTrackTableData = malloc (PoolTrackTableSizeInBytes);
    if (PoolTrackTableData == NULL) {
        dprintf("unable to allocate memory for tag table.\n");
        return E_INVALIDARG;
    }

    PoolTableAddress = PoolTrackTable;
    if ( !ReadMemory( PoolTableAddress,
                      &PoolTrackTableData[0],
                      PoolTrackTableSizeInBytes,
                      &result) ) {
        dprintf("%08p: Unable to get contents of pool block\n", PoolTableAddress );
        dprintf("\nThe current process probably is not a session process.\n");
        dprintf("Note the system, idle and smss processes are non-session processes.\n");
        free (PoolTrackTableData);
        return E_INVALIDARG;
    }

    ct = PageSize / SizeOfPoolTracker;
    i = 0;
    PoolTableAddress = PoolTrackTable;

    free (PoolTrackTableData);

    //
    // Create array of POOL_TRACKER_TABLE addresses and sort the addresses
    //

    PoolTrackTableData = malloc ((PoolTrackTableSize + PoolTrackTableExpansionSize) * sizeof(POOLTRACK_READ));
    if (PoolTrackTableData == NULL) {
        dprintf("unable to allocate memory for tag table.\n");
        return E_INVALIDARG;
    }

    if (Flags & 0x8) {
        MaxProcessors = 1;
    }
    else {
        MaxProcessors = (UCHAR) GetUlongValue ("KeNumberProcessors");
    }

    Processor = 0;
    NonPagedAllocsTotal = 0;
    NonPagedFreesTotal = 0;
    NonPagedBytesTotal = 0;

    PagedAllocsTotal = 0;
    PagedFreesTotal = 0;
    PagedBytesTotal = 0;
    p = PoolTrackTableData;

    do {

        pentry = &PoolTrackEntry;

        for (i = 0; i < PoolTrackTableSize; i += 1) {

            if (Processor == 0) {
                pentry->Address = PoolTableAddress + i * SizeOfPoolTracker;
            }
            else {
                pentry->Address = PoolTrackTable + i * SizeOfPoolTracker;
            }

#define TrackFld(Fld)        GetFieldValue(pentry->Address, "nt!_POOL_TRACKER_TABLE", #Fld, pentry->Fld)

            TrackFld(Key);
            TrackFld(NonPagedAllocs);
            TrackFld(NonPagedBytes);
            TrackFld(PagedBytes);
            TrackFld(NonPagedFrees);
            TrackFld(PagedAllocs);
            TrackFld(PagedFrees);

#undef TrackFld

#if 0
            if (pentry->Key != 0) {
                dprintf("%c%c%c%c %8x %8x %8I64x  %8x %8x %8I64x\n",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                        PP(pentry->Key),
                        PP(pentry->Key >> 8),
                        PP(pentry->Key >> 16),
                        PP(pentry->Key >> 24),
                        pentry->NonPagedAllocs,
                        pentry->NonPagedFrees,
                        pentry->NonPagedBytes,
                        pentry->PagedAllocs,
                        pentry->PagedFrees,
                        pentry->PagedBytes);
            }
#endif

            if (Processor == 0) {
                p[i].Address = pentry->Address;
                p[i].Key = pentry->Key;

                p[i].NonPagedAllocs = pentry->NonPagedAllocs;
                p[i].NonPagedFrees = pentry->NonPagedFrees;
                p[i].NonPagedBytes = pentry->NonPagedBytes;

                p[i].PagedAllocs = pentry->PagedAllocs;
                p[i].PagedBytes = pentry->PagedBytes;
                p[i].PagedFrees = pentry->PagedFrees;
            }

            if ((pentry->Key != 0) &&
                (CheckSingleFilter ((PCHAR)&pentry->Key, (PCHAR)&TagName))) {

                if (Processor != 0) {
                    p[i].NonPagedAllocs += pentry->NonPagedAllocs;
                    p[i].NonPagedFrees += pentry->NonPagedFrees;
                    p[i].NonPagedBytes += pentry->NonPagedBytes;

                    p[i].PagedAllocs += pentry->PagedAllocs;
                    p[i].PagedFrees += pentry->PagedFrees;
                    p[i].PagedBytes += pentry->PagedBytes;
                }

            }

            if (!IsPtr64()) {
                p[i].NonPagedBytes &= (LONG64) 0xFFFFFFFF;
                p[i].PagedBytes &= (LONG64) 0xFFFFFFFF;
            }
        }

        Processor += 1;

        if (Processor >= MaxProcessors) {
            break;
        }

        if (ExPoolTagTables == 0) {
            break;
        }

        ReadPointer (ExPoolTagTables+DBG_PTR_SIZE*Processor, &PoolTrackTable);

    } while (TRUE);

    //
    // Add the expansion table too (if there is one).
    //

    if (PoolTrackTableExpansionSize != 0) {

        //
        // Allocate a temp buffer, read the data, then free the data.
        // (KD will cache the data).
        //

        pentry = malloc (PoolTrackTableExpansionSizeInBytes);
        if (pentry == NULL) {
            dprintf("unable to allocate memory for expansion tag table.\n");
        }
        else {
            PoolTrackTableExpansion = GetPointerValue("nt!PoolTrackTableExpansion");
            PoolTableAddress = PoolTrackTableExpansion;
            if ( !ReadMemory( PoolTableAddress,
                              pentry,
                              PoolTrackTableExpansionSizeInBytes,
                              &result) ) {
                dprintf("%08p: Unable to get contents of expansion tag table\n", PoolTableAddress );
            }
            else {

                PoolTrackTableSize += PoolTrackTableExpansionSize;

                ct = 0;
                for ( ; i < PoolTrackTableSize; i += 1, ct += 1) {

                    p[i].Address = PoolTableAddress + ct * SizeOfPoolTracker;

#define TrackFld(Fld)        GetFieldValue(p[i].Address, "nt!_POOL_TRACKER_TABLE", #Fld, p[i].Fld)

                    TrackFld(Key);
                    TrackFld(NonPagedAllocs);
                    TrackFld(NonPagedBytes);
                    TrackFld(PagedBytes);
                    TrackFld(NonPagedFrees);
                    TrackFld(PagedAllocs);
                    TrackFld(PagedFrees);

#if 0
                    if (p[i].Key != 0) {
                        dprintf("%c%c%c%c %8x %8x %8I64x  %8x %8x %8I64x\n",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                                PP(p[i].Key),
                                PP(p[i].Key >> 8),
                                PP(p[i].Key >> 16),
                                PP(p[i].Key >> 24),
                                p[i].NonPagedAllocs,
                                p[i].NonPagedFrees,
                                p[i].NonPagedBytes,
                                p[i].PagedAllocs,
                                p[i].PagedFrees,
                                p[i].PagedBytes);
                    }
#endif
                }
            }
            free (pentry);
        }
    }

    qsort((void *)PoolTrackTableData,
          (size_t)PoolTrackTableSize,
          (size_t)sizeof(POOLTRACK_READ),
          ulcomp);

    i = 0;
    p = PoolTrackTableData;
    for ( ; i < PoolTrackTableSize; i += 1) {

        if ((p[i].Key != 0) &&
            (CheckSingleFilter ((PCHAR)&p[i].Key, (PCHAR)&TagName))) {

            if (!(Flags & 1)) {

                if ((p[i].NonPagedBytes != 0) || (p[i].PagedBytes != 0)) {

                    dprintf(" %c%c%c%c %8ld %8I64ld  %8ld %8I64ld\n",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                            PP(p[i].Key),
                            PP(p[i].Key >> 8),
                            PP(p[i].Key >> 16),
                            PP(p[i].Key >> 24),
                            p[i].NonPagedAllocs - p[i].NonPagedFrees,
                            p[i].NonPagedBytes,
                            p[i].PagedAllocs - p[i].PagedFrees,
                            p[i].PagedBytes);

                    NonPagedAllocsTotal += p[i].NonPagedAllocs;
                    NonPagedFreesTotal += p[i].NonPagedFrees;
                    NonPagedBytesTotal += p[i].NonPagedBytes;

                    PagedAllocsTotal += p[i].PagedAllocs;
                    PagedFreesTotal += p[i].PagedFrees;
                    PagedBytesTotal += p[i].PagedBytes;
                }
            } else {

                dprintf(" %c%c%c%c %8ld %8ld %8ld %8I64ld %8ld %8ld %8ld %8I64ld\n",
                        PP(p[i].Key),
                        PP(p[i].Key >> 8),
                        PP(p[i].Key >> 16),
                        PP(p[i].Key >> 24),
                        p[i].NonPagedAllocs,
                        p[i].NonPagedFrees,
                        p[i].NonPagedAllocs - p[i].NonPagedFrees,
                        p[i].NonPagedBytes,
                        p[i].PagedAllocs,
                        p[i].PagedFrees,
                        p[i].PagedAllocs - p[i].PagedFrees,
                        p[i].PagedBytes);
#undef PP
                NonPagedAllocsTotal += p[i].NonPagedAllocs;
                NonPagedFreesTotal += p[i].NonPagedFrees;
                NonPagedBytesTotal += p[i].NonPagedBytes;

                PagedAllocsTotal += p[i].PagedAllocs;
                PagedFreesTotal += p[i].PagedFrees;
                PagedBytesTotal += p[i].PagedBytes;
            }
        }
    }

    if (!(Flags & 1)) {
        dprintf(" TOTAL    %8ld %8I64ld  %8ld %8I64ld\n",
                NonPagedAllocsTotal - NonPagedFreesTotal,
                NonPagedBytesTotal,
                PagedAllocsTotal - PagedFreesTotal,
                PagedBytesTotal);
    } else {
        dprintf(" TOTAL    %8ld %8ld %8ld %8I64ld %8ld %8ld %8ld %8I64ld\n",
                NonPagedAllocsTotal,
                NonPagedFreesTotal,
                NonPagedAllocsTotal - NonPagedFreesTotal,
                NonPagedBytesTotal,
                PagedAllocsTotal,
                PagedFreesTotal,
                PagedAllocsTotal - PagedFreesTotal,
                PagedBytesTotal);
    }

    free (PoolTrackTableData);
    return S_OK;
}

#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')

BOOLEAN WINAPI
CheckSingleFilterAndPrint (
                          PCHAR Tag,
                          PCHAR Filter,
                          ULONG Flags,
                          ULONG64 PoolHeader,
                          ULONG64 BlockSize,
                          ULONG64 Data,
                          PVOID Context
                          )
/*++

Routine Description:

    Callback to check a piece of pool and print out information about it
    if it matches the specified tag.

Arguments:

    Tag - Supplies the tag to search for.

    Filter - Supplies the filter string to match against.

    Flags - Supplies 0 if a nonpaged pool search is desired.
            Supplies 1 if a paged pool search is desired.
            Supplies 2 if a special pool search is desired.
            Supplies 4 if a pool is a large pool

    PoolHeader - Supplies the pool header.

    BlockSize - Supplies the size of the pool block in bytes.

    Data - Supplies the address of the pool block.

    Context - Unused.

Return Value:

    TRUE for a match, FALSE if not.

--*/
{
    ULONG UTag = *((PULONG)Tag);
    ULONG HdrUlong1=0, HdrPoolSize ;
    LOGICAL QuotaProcessAtEndOfPoolBlock = FALSE;

    UNREFERENCED_PARAMETER (Context);

    if (CheckSingleFilter (Tag, Filter) == FALSE) {
        return FALSE;
    }

    HdrPoolSize = GetTypeSize("nt!_POOL_HEADER");
    if ((BlockSize >= (PageSize-2*HdrPoolSize)) || (Flags & 0x8)) {
        dprintf("*%p :%slarge page allocation, Tag %3s %c%c%c%c, size %3s 0x%I64x bytes\n",
                (Data & ~POOL_BIG_TABLE_ENTRY_FREE),
                (Data & POOL_BIG_TABLE_ENTRY_FREE) ? "free " : "",
                (Data & POOL_BIG_TABLE_ENTRY_FREE) ? "was" : "is",
                PP(UTag),
                PP(UTag >> 8),
                PP(UTag >> 16),
                PP(UTag >> 24),
                (Data & POOL_BIG_TABLE_ENTRY_FREE) ? "was" : "is",
                BlockSize
               );
    } else if (Flags & 0x2) {
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", HdrUlong1);
        dprintf("*%p size: %4lx %s special pool, Tag is %c%c%c%c\n",
                Data,
                BlockSize,
                HdrUlong1 & MI_SPECIAL_POOL_PAGABLE ? "pagable" : "non-paged",
                PP(UTag),
                PP(UTag >> 8),
                PP(UTag >> 16),
                PP(UTag >> 24)
               );
    } else {
        ULONG BlockSizeR, PreviousSize, PoolType, PoolIndex, AllocatorBackTraceIndex;
        ULONG PoolTagHash, PoolTag;
        ULONG64 ProcessBilled;

        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", BlockSizeR);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolType", PoolType);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolTagHash", PoolTagHash);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolTag", PoolTag);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex);
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PreviousSize", PreviousSize);
        if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
            if (GetExpression ("nt!ExGetPoolTagInfo") != 0) {

                //
                // This is a kernel where the quota process pointer is at
                // the end of the pool block instead of overlaid on the
                // tag field.
                //

                QuotaProcessAtEndOfPoolBlock = TRUE;
                if (QuotaProcessAtEndOfPoolBlock == TRUE) {

                    ULONG SizeOfPvoid = 0;
                    ULONG64 ProcessBillAddress;

                    SizeOfPvoid =  DBG_PTR_SIZE;

                    if (SizeOfPvoid == 0) {
                        dprintf ("Search: cannot get size of PVOID\n");
                        return FALSE;
                    }
                    ProcessBillAddress = PoolHeader + ((ULONG64) BlockSizeR << POOL_BLOCK_SHIFT) - SizeOfPvoid;
                    ProcessBilled = READ_PVOID (ProcessBillAddress);
                }
            }
            else {
                GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "ProcessBilled", ProcessBilled);
            }
        }
        else {
            GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "ProcessBilled", ProcessBilled);
        }

        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "AllocatorBackTraceIndex", AllocatorBackTraceIndex);

        dprintf("%p size: %4lx previous size: %4lx ",
                Data - HdrPoolSize,
                BlockSizeR << POOL_BLOCK_SHIFT,
                PreviousSize << POOL_BLOCK_SHIFT);

        if (PoolType == 0) {
            //
            // "Free " with a space after it before the parentheses means
            // it's been freed to a (pool manager internal) lookaside list.
            // We used to print "Lookaside" but that just confused driver
            // writers because they didn't know if this meant in use or not
            // and many would say "but I don't use lookaside lists - the
            // extension or kernel is broken".
            //
            // "Free" with no space after it before the parentheses means
            // it is not on a pool manager internal lookaside list and is
            // instead on the regular pool manager internal flink/blink
            // chains.
            //
            // Note to anyone using the pool package, these 2 terms are
            // equivalent.  The fine distinction is only for those actually
            // writing pool internal code.
            //
            dprintf(" (Free)");
            dprintf("      %c%c%c%c\n",
                    PP(UTag),
                    PP(UTag >> 8),
                    PP(UTag >> 16),
                    PP(UTag >> 24)
                   );
        } else {

            if (!NewPool ? (PoolIndex & 0x80) : (PoolType & 0x04)) {
                dprintf(" (Allocated)");
            } else {
                //
                // "Free " with a space after it before the parentheses means
                // it's been freed to a (pool manager internal) lookaside list.
                // We used to print "Lookaside" but that just confused driver
                // writers because they didn't know if this meant in use or not
                // and many would say "but I don't use lookaside lists - the
                // extension or kernel is broken".
                //
                // "Free" with no space after it before the parentheses means
                // it is not on a pool manager internal lookaside list and is
                // instead on the regular pool manager internal flink/blink
                // chains.
                //
                // Note to anyone using the pool package, these 2 terms are
                // equivalent.  The fine distinction is only for those actually
                // writing pool internal code.
                //
                dprintf(" (Free )");
            }
            if ((PoolType & POOL_QUOTA_MASK) == 0) {

                UTag = PoolTag;

                dprintf(" %c%c%c%c%s\n",
                        PP(UTag),
                        PP(UTag >> 8),
                        PP(UTag >> 16),
                        PP((UTag &~PROTECTED_POOL) >> 24),
                        (UTag & PROTECTED_POOL) ? " (Protected)" : ""
                       );

            } else {

                if ((QuotaProcessAtEndOfPoolBlock == TRUE) ||
                    (TargetMachine != IMAGE_FILE_MACHINE_I386)) {

                    UTag = PoolTag;

                    dprintf(" %c%c%c%c%s",
                            PP(UTag),
                            PP(UTag >> 8),
                            PP(UTag >> 16),
                            PP((UTag &~PROTECTED_POOL) >> 24),
                            (UTag & PROTECTED_POOL) ? " (Protected)" : ""
                           );
                }

                if (ProcessBilled != 0) {
                    dprintf(" Process: %08p\n", ProcessBilled );
                }
                else {
                    dprintf("\n");
                }
            }
        }
    }


    return TRUE;
} // CheckSingleFilterAndPrint

#undef PP

ULONG64
GetNextResidentAddress (
                       ULONG64 VirtualAddress,
                       ULONG64 MaximumVirtualAddress
                       )
{
    ULONG64 PointerPde;
    ULONG64 PointerPte;
    ULONG SizeOfPte;
    ULONG Valid;

    //
    // Note this code will need to handle one more level of indirection for
    // WIN64.
    //

    if (!(SizeOfPte=GetTypeSize("nt!_MMPTE"))) {
        dprintf("Cannot get MMPTE type.\n");
        return 0;
    }

top:

    PointerPde = DbgGetPdeAddress (VirtualAddress);

    while (GetFieldValue(PointerPde,
                         "nt!_MMPTE",
                         "u.Hard.Valid",
                         Valid) ||
           (Valid == 0)) {

        //
        // Note that on 32-bit systems, the PDE should always be readable.
        // If the PDE is not valid then increment to the next PDE's VA.
        //

        PointerPde = (PointerPde + SizeOfPte);

        VirtualAddress = DbgGetVirtualAddressMappedByPte (PointerPde);
        VirtualAddress = DbgGetVirtualAddressMappedByPte (VirtualAddress);

        if (VirtualAddress >= MaximumVirtualAddress) {
            return VirtualAddress;
        }

        if (CheckControlC()) {
            return VirtualAddress;
        }
        continue;
    }

    PointerPte = DbgGetPteAddress (VirtualAddress);

    while (GetFieldValue(PointerPde,
                         "nt!_MMPTE",
                         "u.Hard.Valid",
                         Valid) ||
           (Valid == 0)) {

        //
        // If the PTE cannot be read then increment by PAGE_SIZE.
        //

        VirtualAddress = (VirtualAddress + PageSize);

        if (CheckControlC()) {
            return VirtualAddress;
        }

        PointerPte = (PointerPte + SizeOfPte);
        if ((PointerPte & (PageSize - 1)) == 0) {
            goto top;
        }

        if (VirtualAddress >= MaximumVirtualAddress) {
            return VirtualAddress;
        }
    }

    return VirtualAddress;
}

VOID
SearchPool(
          ULONG TagName,
          ULONG Flags,
          ULONG64 RestartAddr,
          POOLFILTER Filter,
          PVOID Context
          )
/*++

Routine Description:

    Engine to search the pool.

Arguments:

    TagName - Supplies the tag to search for.

    Flags - Supplies 0 if a nonpaged pool search is desired.
            Supplies 1 if a paged pool search is desired.
            Supplies 2 if a special pool search is desired.
            Supplies 4 if a session pool search is desired.

    RestartAddr - Supplies the address to restart the search from.

    Filter - Supplies the filter routine to use.

    Context - Supplies the user defined context blob.

Return Value:

    None.

--*/
{
    ULONG64     Location;
    LOGICAL     PhysicallyContiguous;
    ULONG64     PoolBlockSize;
    ULONG64     PoolHeader;
    ULONG       PoolTag;
    ULONG       Result;
    ULONG64     PoolPage;
    ULONG64     StartPage;
    ULONG64     Pool;
    ULONG       Previous;
    ULONG64     PoolStart;
    ULONG64     PoolPteAddress;
    ULONG64     PoolEnd;
    ULONG64       ExpandedPoolStart;
    ULONG64     ExpandedPoolEnd;
    ULONG       InitialPoolSize;
    ULONG       SkipSize;
    BOOLEAN     TwoPools;
    ULONG64     DataPageReal;
    ULONG64     DataStartReal;
    LOGICAL     Found;
    ULONG       i;
    ULONG       j;
    ULONG       ct;
    ULONG       PoolBigPageTableSize;
    ULONG64     PoolTableAddress;
    UCHAR       FastTag[4];
    ULONG       TagLength;
    ULONG       SizeOfBigPages;
    ULONG       PoolTypeFlags = Flags & 0x7;
    ULONG       Ulong1;
    ULONG       HdrSize;

    if (PoolInitializeGlobals() == FALSE) {
        return;
    }

    if (PoolTypeFlags == 2) {

        if (RestartAddr && (RestartAddr >= SpecialPoolStart) && (RestartAddr <= SpecialPoolEnd)) {
            Pool = RestartAddr;
        } else {
            Pool = SpecialPoolStart;
        }

        dprintf("\nSearching special pool (%p : %p) for Tag: %c%c%c%c\r\n\n",
                Pool,
                SpecialPoolEnd,
                TagName,
                TagName >> 8,
                TagName >> 16,
                TagName >> 24);

        Found = FALSE;
        SkipSize = PageSize;

        if (SpecialPoolStart && SpecialPoolEnd) {

            //
            // Search special pool for the tag.
            //

            while (Pool < SpecialPoolEnd) {

                if ( CheckControlC() ) {
                    dprintf("\n...terminating - searched pool to %p\n",
                            Pool);
                    return;
                }

                DataStartReal = Pool;
                DataPageReal = Pool;
                if ( !ReadMemory( Pool,
                                  &DataPage[0],
                                  min(PageSize, sizeof(DataPage)),
                                  &Result) ) {
                    ULONG64 PteLong=0, PageFileHigh;

                    if (SkipSize != 2 * PageSize) {

//                        dprintf("SP skip %x", Pool);
                        PoolPteAddress = DbgGetPteAddress (Pool);

                        if (!GetFieldValue(PoolPteAddress,
                                           "nt!_MMPTE",
                                           "u.Soft.PageFileHigh",
                                           PageFileHigh) ) {

                            if ((PageFileHigh == 0) ||
                                (PageFileHigh == MI_SPECIAL_POOL_PTE_PAGABLE) ||
                                (PageFileHigh == MI_SPECIAL_POOL_PTE_NONPAGABLE)) {

                                //
                                // Found a NO ACCESS PTE - skip these from
                                // here on to speed up the search.
                                //

                                // dprintf("SP skip double %p", PoolPteAddress);
                                SkipSize = 2 * PageSize;
                                Pool += PageSize;
                                // dprintf("SP skip final %p", Pool);
                                continue;
                            }
                        }
                    }

                    Pool += SkipSize;
                    continue;
                }

                //
                // Determine whether this is a valid special pool block.
                //

                PoolHeader = GetSpecialPoolHeader (DataPage,
                                                   DataPageReal,
                                                   &DataStartReal);

                if (PoolHeader != 0) {

                    GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolTag", PoolTag);
                    GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", Ulong1);
                    PoolBlockSize = SPECIAL_POOL_BLOCK_SIZE(Ulong1);

                    Found = Filter( (PCHAR)&PoolTag,
                                    (PCHAR)&TagName,
                                    Flags,
                                    PoolHeader,
                                    PoolBlockSize,
                                    DataStartReal,
                                    Context );
                } else {
                    dprintf( "No pool header for page: 0x%p\n", Pool );
                }
                Pool += SkipSize;
            }
        }

        if (Found == FALSE) {
            dprintf("The %c%c%c%c tag could not be found in special pool.\n",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                    PP(TagName),
                    PP(TagName >> 8),
                    PP(TagName >> 16),
                    PP(TagName >> 24)
                   );
#undef PP
        }
        return;
    }

    if (PoolTypeFlags == 0) {
        PhysicallyContiguous = TRUE;
    } else {
        PhysicallyContiguous = FALSE;
    }

    __try {
        TwoPools = FALSE;

        if (((PoolTypeFlags & 0x4)== 0) || (BuildNo <= 2600)) {
            PoolBigTableAddress = GetPointerValue ("nt!PoolBigPageTable");
            PoolBigPageTableSize = GetUlongValue ("nt!PoolBigPageTableSize");
        }
        else {
            PoolBigTableAddress = GetPointerValue ("ExpSessionPoolBigPageTable");
            PoolBigPageTableSize = GetUlongValue ("ExpSessionPoolBigPageTableSize");
        }

        PoolTableAddress = PoolBigTableAddress;

        if (PoolTableAddress) {

            ULONG VaOffset;
            ULONG NumPagesOffset;
            ULONG PtrSize;
            ULONG KeyOffset;

            //
            //  Scan the table looking for a match. We read close to a page at a time
            //  physical page / sizeof ( pool_tracker_big_page ) *  sizeof ( pool_tracker_big_page )
            //  on x86 this works out to ffc
            //

            i = 0;
            SizeOfBigPages =  GetTypeSize ("nt!_POOL_TRACKER_BIG_PAGES");
            if (!SizeOfBigPages) {
                dprintf("Cannot get _POOL_TRACKER_BIG_PAGES type size\n");
                __leave;
            }
            ct = PageSize / SizeOfBigPages;

            dprintf( "\nScanning large pool allocation table for Tag: %c%c%c%c (%p : %p)\n\n\r",
                     TagName,
                     TagName >> 8,
                     TagName >> 16,
                     TagName >> 24,
                     PoolBigTableAddress,
                     PoolBigTableAddress + PoolBigPageTableSize * SizeOfBigPages );

            GetFieldOffset( "nt!_POOL_TRACKER_BIG_PAGES", "Va", &VaOffset );
            GetFieldOffset( "nt!_POOL_TRACKER_BIG_PAGES", "NumberOfPages", &NumPagesOffset );
            GetFieldOffset( "nt!_POOL_TRACKER_BIG_PAGES", "Key", &KeyOffset );
            PtrSize = IsPtr64() ? 8 : 4;

            while (i < PoolBigPageTableSize) {

                if (PoolBigPageTableSize - i < ct) {
                    ct = PoolBigPageTableSize - i;
                }

                if ( !ReadMemory( PoolTableAddress,
                                  &DataPage[0],
                                  min(ct * SizeOfBigPages, sizeof(DataPage)),
                                  &Result) ) {

                    dprintf( "%08lx: Unable to get contents of big pool block\r\n", PoolTableAddress );
                    break;
                }

                for (j = 0; j < ct; j += 1) {
                    ULONG64 Va = 0;

                    memcpy( &Va, (PCHAR)DataPage + (SizeOfBigPages * j) + VaOffset, PtrSize );

                    Filter( ((PCHAR)DataPage + (SizeOfBigPages * j) + KeyOffset),
                            (PCHAR)&TagName,
                            Flags | 0x8, // To assist filter routine to recognize this as large pool
                            PoolTableAddress + SizeOfBigPages * j,
                            (ULONG64)(*((PULONG)((PCHAR)DataPage + (SizeOfBigPages * j) + NumPagesOffset))) * PageSize,
                            Va,
                            Context );
                    if ( CheckControlC() ) {
                        dprintf("\n...terminating - searched pool to %p\n",
                                PoolTableAddress + j * SizeOfBigPages);
                        __leave;
                    }
                }
                i += ct;
                PoolTableAddress += (ct * SizeOfBigPages);
                if ( CheckControlC() ) {
                    dprintf("\n...terminating - searched pool to %p\n",
                            PoolTableAddress);
                    __leave;
                }

            }
        } else {
            dprintf("unable to get large pool allocation table - either wrong symbols or pool tagging is disabled\n");
        }

        if (PoolTypeFlags == 0) {
            PoolStart = GetNtDebuggerDataPtrValue( MmNonPagedPoolStart );

            if (0 == PoolStart) {
                dprintf( "Unable to get MmNonPagedPoolStart\n" );
            }

            PoolEnd =
            PoolStart + GetNtDebuggerDataPtrValue( MmMaximumNonPagedPoolInBytes );

            ExpandedPoolEnd = GetNtDebuggerDataPtrValue( MmNonPagedPoolEnd );

            if (PoolEnd != ExpandedPoolEnd) {
                InitialPoolSize = (ULONG)GetUlongValue( "MmSizeOfNonPagedPoolInBytes" );
                PoolEnd = PoolStart + InitialPoolSize;

                ExpandedPoolStart = GetPointerValue( "MmNonPagedPoolExpansionStart" );
                TwoPools = TRUE;
            }
            for (TagLength = 0;TagLength < 3; TagLength++) {
                if ((*(((PCHAR)&TagName)+TagLength) == '?') ||
                    (*(((PCHAR)&TagName)+TagLength) == '*')) {
                    break;
                }
                FastTag[TagLength] = *(((PCHAR)&TagName)+TagLength);
            }

        } else if (PoolTypeFlags == 1) {
            PoolStart = GetNtDebuggerDataPtrValue( MmPagedPoolStart );
            PoolEnd =
            PoolStart + GetNtDebuggerDataPtrValue( MmSizeOfPagedPoolInBytes );
        } else {
            Location = GetExpression ("MiSessionPoolStart");
            if (!Location) {
                dprintf("Unable to get MiSessionPoolStart\n");
                __leave;
            }

            ReadPointer(Location, &PoolStart);

            Location = GetExpression ("MiSessionPoolEnd");
            if (!Location) {
                dprintf("Unable to get MiSessionPoolEnd\n");
                __leave;
            }

            ReadPointer(Location, &PoolEnd);
        }

        if (RestartAddr) {
            PoolStart = RestartAddr;
            if (TwoPools == TRUE) {
                if (PoolStart > PoolEnd) {
                    TwoPools = FALSE;
                    PoolStart = RestartAddr;
                    PoolEnd = ExpandedPoolEnd;
                }
            }
        }

        dprintf("\nSearching %s pool (%p : %p) for Tag: %c%c%c%c\r\n\n",
                (PoolTypeFlags == 0) ? "NonPaged" : PoolTypeFlags == 1 ? "Paged": "SessionPaged",
                PoolStart,
                PoolEnd,
                TagName,
                TagName >> 8,
                TagName >> 16,
                TagName >> 24);

        PoolPage = PoolStart;
        HdrSize = GetTypeSize("nt!_POOL_HEADER");

        while (PoolPage < PoolEnd) {

            //
            // Optimize things by ioctl'ing over to the other side to
            // do a fast search and start with that page.
            //

            if ((PoolTypeFlags == 0) &&
                PhysicallyContiguous &&
                (TagLength > 0)) {

                SEARCHMEMORY Search;

                Search.SearchAddress = PoolPage;
                Search.SearchLength  = PoolEnd-PoolPage;
                Search.PatternLength = TagLength;
                Search.Pattern = FastTag;
                Search.FoundAddress = 0;
                if ((Ioctl(IG_SEARCH_MEMORY, &Search, sizeof(Search))) &&
                    (Search.FoundAddress != 0)) {
                    //
                    // Got a hit, search the whole page
                    //
                    PoolPage = PAGE_ALIGN64(Search.FoundAddress);
                } else {
                    //
                    // The tag was not found at all, so we can just skip
                    // this chunk entirely.
                    //
                    PoolPage = PoolEnd;
                    goto skiprange;
                }
            }

            Pool        = PAGE_ALIGN64 (PoolPage);
            StartPage   = Pool;
            Previous    = 0;

            while (PAGE_ALIGN64(Pool) == StartPage) {

                ULONG HdrPoolTag, BlockSize, PreviousSize, AllocatorBackTraceIndex, PoolTagHash;
                ULONG PoolType;

                if ( GetFieldValue(Pool,
                                   "nt!_POOL_HEADER",
                                   "PoolTag",
                                   HdrPoolTag) ) {

                    PoolPage = GetNextResidentAddress (Pool, PoolEnd);

                    //
                    //  If we're half resident - half non-res then we'll get back
                    //  that are starting address is the next resident page. In that
                    //  case just go on to the next page
                    //

                    if (PoolPage == Pool) {
                        PoolPage = PoolPage + PageSize;
                    }

                    goto nextpage;
                }

                GetFieldValue(Pool,"nt!_POOL_HEADER","PoolTag",HdrPoolTag);
                GetFieldValue(Pool,"nt!_POOL_HEADER","PoolType", PoolType);
                GetFieldValue(Pool,"nt!_POOL_HEADER","BlockSize",BlockSize);
                GetFieldValue(Pool,"nt!_POOL_HEADER","PoolTagHash",PoolTagHash);
                GetFieldValue(Pool,"nt!_POOL_HEADER","PreviousSize",PreviousSize);
                GetFieldValue(Pool,"nt!_POOL_HEADER","AllocatorBackTraceIndex",AllocatorBackTraceIndex);

                if ((BlockSize << POOL_BLOCK_SHIFT) > POOL_PAGE_SIZE) {
                    //dprintf("Bad allocation size @%lx, too large\n", Pool);
                    break;
                }

                if (BlockSize == 0) {
                    //dprintf("Bad allocation size @%lx, zero is invalid\n", Pool);
                    break;
                }

                if (PreviousSize != Previous) {
                    //dprintf("Bad previous allocation size @%lx, last size was %lx\n",Pool, Previous);
                    break;
                }

                PoolTag = HdrPoolTag;

                Filter((PCHAR)&PoolTag,
                       (PCHAR)&TagName,
                       Flags,
                       Pool,
                       (ULONG64)BlockSize << POOL_BLOCK_SHIFT,
                       Pool + HdrSize,
                       Context );

                Previous = BlockSize;
                Pool += ((ULONG64) Previous << POOL_BLOCK_SHIFT);
                if ( CheckControlC() ) {
                    dprintf("\n...terminating - searched pool to %p\n",
                            PoolPage);
                    __leave;
                }
            }
            PoolPage = (PoolPage + PageSize);

nextpage:
            if ( CheckControlC() ) {
                dprintf("\n...terminating - searched pool to %p\n",
                        PoolPage);
                __leave;
            }

skiprange:
            if (TwoPools == TRUE) {
                if (PoolPage == PoolEnd) {
                    TwoPools = FALSE;
                    PoolStart = ExpandedPoolStart;
                    PoolEnd = ExpandedPoolEnd;
                    PoolPage = PoolStart;
                    PhysicallyContiguous = FALSE;

                    dprintf("\nSearching %s pool (%p : %p) for Tag: %c%c%c%c\n\n",
                            "NonPaged",
                            PoolStart,
                            PoolEnd,
                            TagName,
                            TagName >> 8,
                            TagName >> 16,
                            TagName >> 24);
                }
            }
        }
    } __finally {
    }

    return;
} // SearchPool



DECLARE_API( poolfind )

/*++

Routine Description:

    flags == 0 means finds a tag in nonpaged pool.
    flags == 1 means finds a tag in paged pool.
    flags == 2 means finds a tag in special pool.
    flags == 4 means finds a tag in session pool.

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG       Flags;
    CHAR        TagNameX[4] = {' ',' ',' ',' '};
    ULONG       TagName;
    ULONG64     PoolTrackTable;

    Flags = 0;
    if (!sscanf(args,"%c%c%c%c %lx", &TagNameX[0],
           &TagNameX[1], &TagNameX[2], &TagNameX[3], &Flags)) {
        Flags = 0;
    }

    if (TagNameX[0] == '0' && TagNameX[1] == 'x') {
        if (!sscanf( args, "%lx %lx", &TagName, &Flags )) {
            TagName = 0;
        }
    } else {
        TagName = TagNameX[0] | (TagNameX[1] << 8) | (TagNameX[2] << 16) | (TagNameX[3] << 24);
    }

    PoolTrackTable = GetNtDebuggerDataPtrValue( PoolTrackTable );
    if (PoolTrackTable == 0) {
        dprintf ("unable to get PoolTrackTable - probably pool tagging disabled or wrong symbols\n");
    }


    SearchPool( TagName, Flags, 0, CheckSingleFilterAndPrint, NULL );

    return S_OK;
}


BOOLEAN
CheckSingleFilter (
                  PCHAR Tag,
                  PCHAR Filter
                  )
{
    ULONG i;
    UCHAR tc;
    UCHAR fc;

    for ( i = 0; i < 4; i++ ) {
        tc = (UCHAR) *Tag++;
        fc = (UCHAR) *Filter++;
        if ( fc == '*' ) return TRUE;
        if ( fc == '?' ) continue;
        if (i == 3 && (tc & ~(PROTECTED_POOL >> 24)) == fc) continue;
        if ( tc != fc ) return FALSE;
    }
    return TRUE;
}

ULONG64
GetSpecialPoolHeader (
                     IN PVOID     pDataPage,
                     IN ULONG64   RealDataPage,
                     OUT PULONG64 ReturnedDataStart
                     )

/*++

Routine Description:

    Examine a page of data to determine if it is a special pool block.

Arguments:

    pDataPage - Supplies a pointer to a page of data to examine.

    ReturnedDataStart - Supplies a pointer to return the start of the data.
                        Only valid if this routine returns non-NULL.

Return Value:

    Returns a pointer to the pool header for this special pool block or
    NULL if the block is not valid special pool.

--*/

{
    ULONG       PoolBlockSize;
    ULONG       PoolHeaderSize;
    ULONG       PoolBlockPattern;
    PUCHAR      p;
    PUCHAR      PoolDataEnd;
    PUCHAR      DataStart;
    ULONG64     PoolHeader;
    ULONG       HdrUlong1;

    PoolHeader = RealDataPage;
    GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", HdrUlong1);
    //
    // Determine whether the data is at the start or end of the page.
    // Start off by assuming the data is at the end, in this case the
    // header will be at the start.
    //

    PoolBlockSize = SPECIAL_POOL_BLOCK_SIZE(HdrUlong1);

    if ((PoolBlockSize != 0) && (PoolBlockSize < PageSize - POOL_OVERHEAD)) {

        PoolHeaderSize = POOL_OVERHEAD;
        if (HdrUlong1 & MI_SPECIAL_POOL_VERIFIER) {
            PoolHeaderSize += GetTypeSize ("nt!_MI_VERIFIER_POOL_HEADER");
        }


        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", PoolBlockPattern);

        DataStart = (PUCHAR)pDataPage + PageSize - PoolBlockSize;
        p = (PUCHAR)pDataPage + PoolHeaderSize;

        for ( ; p < DataStart; p += 1) {
            if (*p != PoolBlockPattern) {
                break;
            }
        }

        if (p == DataStart || p >= (PUCHAR)pDataPage + PoolHeaderSize + 0x10) {

            //
            // For this page, the data is at the end of the block.
            // The 0x10 is just to give corrupt blocks some slack.
            // All pool allocations are quadword aligned.
            //

            DataStart = (PUCHAR)pDataPage + ((PageSize - PoolBlockSize) & ~(sizeof(QUAD)-1));

            *ReturnedDataStart = RealDataPage + (ULONG64) ((PUCHAR) DataStart - (PUCHAR) pDataPage);
            return PoolHeader;
        }

        //
        // The data must be at the front or the block is corrupt.
        //
    }

    //
    // Try for the data at the front.  Checks are necessary as
    // the page could be corrupt on both ends.
    //

    PoolHeader = (RealDataPage + PageSize - POOL_OVERHEAD);
    GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "Ulong1", HdrUlong1);
    PoolBlockSize = SPECIAL_POOL_BLOCK_SIZE(HdrUlong1);

    if ((PoolBlockSize != 0) && (PoolBlockSize < PageSize - POOL_OVERHEAD)) {
        PoolDataEnd = (PUCHAR)PoolHeader;

        if (HdrUlong1 & MI_SPECIAL_POOL_VERIFIER) {
            PoolDataEnd -= GetTypeSize ("nt!_MI_VERIFIER_POOL_HEADER");
        }


        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", PoolBlockPattern);
        DataStart = (PUCHAR)pDataPage;

        p = DataStart + PoolBlockSize;
        for ( ; p < PoolDataEnd; p += 1) {
            if (*p != PoolBlockPattern) {
                break;
            }
        }
        if (p == (PUCHAR)PoolDataEnd || p > (PUCHAR)pDataPage + PoolBlockSize + 0x10) {
            //
            // For this page, the data is at the front of the block.
            // The 0x10 is just to give corrupt blocks some slack.
            // All pool allocations are quadword aligned.
            //

            *ReturnedDataStart = RealDataPage + (ULONG64)( (PUCHAR)DataStart - (PUCHAR) pDataPage);
            return PoolHeader;
        }
    }

    //
    // Not valid special pool.
    //

    return 0;
}



#define BYTE(u,n)  ((u & (0xff << 8*n)) >> 8*n)
#define LOCHAR_BYTE(u,n)  (tolower(BYTE(u,n)) & 0xff)
#define REVERSE_ULONGBYTES(u) (LOCHAR_BYTE(u,3) | (LOCHAR_BYTE(u,2) << 8) | (LOCHAR_BYTE(u,1) << 16) | (LOCHAR_BYTE(u,0) << 24))


EXTENSION_API ( GetPoolRegion )(
     PDEBUG_CLIENT Client,
     ULONG64 Pool,
     DEBUG_POOL_REGION *PoolData
     )
{
    INIT_API();

    *PoolData = GetPoolRegion(Pool);

    EXIT_API();
    return S_OK;
}

EXTENSION_API ( GetPoolData )(
     PDEBUG_CLIENT Client,
     ULONG64 Pool,
     PDEBUG_POOL_DATA PoolData
     )
{
    PCHAR Desc;
    HRESULT Hr;
    PGET_POOL_TAG_DESCRIPTION GetPoolTagDescription;

    INIT_API();

    if (!PoolInitializeGlobals()) {
        EXIT_API();
        return E_INVALIDARG;
    }

    Hr = ListPoolPage(Pool, 0x80000002, PoolData);

    if (Hr != S_OK) {
        EXIT_API();
        return Hr;
    }

    GetPoolTagDescription = NULL;
#ifndef  _EXTFNS_H
    if (!GetExtensionFunction("GetPoolTagDescription", (FARPROC*) &GetPoolTagDescription)) {
        EXIT_API();
        return E_INVALIDARG;
    }
    (*GetPoolTagDescription)(PoolData->PoolTag, &Desc);
    if (Desc) {
        ULONG strsize = strlen(Desc);
        if (strsize > sizeof(PoolData->PoolTagDescription)) {
            strsize = sizeof(PoolData->PoolTagDescription);
        }
        strncpy(PoolData->PoolTagDescription, Desc, strsize);
        PoolData->PoolTagDescription[strsize] = 0;
    }
#endif
    EXIT_API();
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\portclsd.cpp ===
/*****************************************************************************
 * portclsd.cpp - Portcls WinDbg/KD Debugger Extensions
 *****************************************************************************
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"

#define PC_KDEXT

typedef enum _PCKD_PORTTYPE
{
    Topology = 0,
    WaveCyclic,
    WavePci,
    Midi,
    UnknownPort
} PCKD_PORTTYPE;

#define MAPPED_QUEUE  0
#define LOCKED_QUEUE  1
#define PRELOCK_QUEUE 2
#define MAX_QUEUES    3

typedef union _PORTCLS_FLAGS
{
    struct
    {
        ULONG   PortDump        : 1;
        ULONG   FilterDump      : 1;
        ULONG   PinDump         : 1;
        ULONG   DeviceContext   : 1;
        ULONG   PowerInfo       : 1;
        ULONG   Reserved1       : 3;
        ULONG   Verbose         : 1;
        ULONG   ReallyVerbose   : 1;
        ULONG   Reserved        : 22;
    };
    ULONG       Flags;
} PORTCLS_FLAGS;

typedef struct _PCKD_IRPSTREAM_ENTRY
{
    LIST_ENTRY      ListEntry;
    PVOID           Irp;
    ULONG           QueueType;
} PCKD_IRP_ENTRY;

typedef struct _PCKD_PIN_ENTRY
{
    LIST_ENTRY  ListEntry;
    LIST_ENTRY  IrpList;
    PVOID       PinData;
    PVOID       IrpStreamData;
    ULONG       PinInstanceId;
} PCKD_PIN_ENTRY;

typedef struct _PCKD_FILTER_ENTRY
{
    LIST_ENTRY  ListEntry;
    LIST_ENTRY  PinList;
    PVOID       FilterData;
    ULONG       FilterInstanceId;
} PCKD_FILTER_ENTRY;

typedef struct _PCKD_PORT
{
    LIST_ENTRY      FilterList;
    PCKD_PORTTYPE   PortType;
    PVOID           PortData;
} PCKD_PORT;

typedef struct {
    ULONG64                 Create;
    ULONG64                 Context;
    UNICODE_STRING          ObjectClass;
    ULONG64                 ObjectClassBuffer;
    ULONG64                 SecurityDescriptor;
    ULONG                   Flags;
} KSOBJECT_CREATE_ITEM_READ, *PKSOBJECT_CREATE_ITEM_READ;


typedef struct _PCKD_SUBDEVICE_ENTRY
{
    LIST_ENTRY              ListEntry;
    PCKD_PORT               Port;
    ULONG64                 CreateItemAddr;
    KSOBJECT_CREATE_ITEM_READ CreateItem;
} PCKD_SUBDEVICE_ENTRY;



#define TranslateDevicePower( x ) \
    ( x == PowerDeviceD0 ? "PowerDeviceD0" :    \
      x == PowerDeviceD1 ? "PowerDeviceD1" :    \
      x == PowerDeviceD2 ? "PowerDeviceD2" :    \
      x == PowerDeviceD3 ? "PowerDeviceD3" : "Unknown" )
      
#define TranslateSystemPower( x ) \
    ( x == PowerSystemWorking ? "PowerSystemWorking" :  \
      x == PowerSystemSleeping1 ? "PowerSystemSleeping1" :  \
      x == PowerSystemSleeping2 ? "PowerSystemSleeping2" :  \
      x == PowerSystemSleeping3 ? "PowerSystemSleeping3" :  \
      x == PowerSystemHibernate ? "PowerSystemHibernate" :  \
      x == PowerSystemShutdown ? "PowerSystemShutdown" : "Unknown" )
      
#define TranslateKsState( x ) \
    ( x == KSSTATE_STOP ? "KSSTATE_STOP" :          \
      x == KSSTATE_ACQUIRE ? "KSSTATE_ACQUIRE" :    \
      x == KSSTATE_PAUSE ? "KSSTATE_PAUSE" :        \
      x == KSSTATE_RUN ? "KSSTATE_RUN" : "Unknown" )
      
#define TranslateKsDataFlow( x ) \
    ( x == KSPIN_DATAFLOW_IN ? "KSPIN_DATAFLOW_IN" :    \
      x == KSPIN_DATAFLOW_OUT ? "KSPIN_DATAFLOW_OUT" : "Unknown" )      
      
#define TranslateQueueType( x ) \
    ( x == PRELOCK_QUEUE ? "P" :    \
      x == LOCKED_QUEUE ? "L" :     \
      x == MAPPED_QUEUE ? "M" : "U" )

/**********************************************************************
 * Forward References
 **********************************************************************
 */
BOOL
PCKD_ValidateDevObj
(
    PDEVICE_CONTEXT DeviceContext
);

VOID
PCKD_AcquireDeviceData
(
    PDEVICE_CONTEXT DeviceContext,
    PLIST_ENTRY     SubdeviceList,
    ULONG           Flags
);

VOID
PCKD_DisplayDeviceData
(
    PDEVICE_CONTEXT DeviceContext,
    PLIST_ENTRY     SubdeviceList,
    ULONG           Flags
);

VOID
PCKD_FreeDeviceData
(
    PLIST_ENTRY     SubdeviceList
);

VOID
PCKD_AcquireIrpStreamData
(
    PVOID           PinEntry,
    CIrpStream     *RemoteIrpStream,
    CIrpStream     *LocalIrpStream

);

/**********************************************************************
 * DECLARE_API( portcls )
 **********************************************************************
 * Description:
 *      Dumps PortCls data given the device object (FDO) of a PortCls
 *      bound DevObj.
 *
 * Arguments:
 *      args - address flags
 *
 * Return Value:
 *      None
 */
extern "C"
DECLARE_API( portcls )
{
    ULONG64         memLoc;
    ULONG           result;
    CHAR            buffer[256];
    PORTCLS_FLAGS   flags;
    LIST_ENTRY      SubdeviceList;
    ULONG64         DeviceExtension;

    buffer[0] = '\0';
    flags.Flags = 0;

    //
    // get the arguments
    //
    if( !*args )
    {
        memLoc = EXPRLastDump;
    } else
    {
        if (GetExpressionEx(args, &memLoc, &args)) {
            StringCchCopy(buffer, sizeof(buffer), args);
        }
    }

    flags.Flags = 0;
    if ('\0' != buffer[0]) {
        flags.Flags = GetExpression(buffer);
    }

    //
    // print out info
    //
    dprintf("Dump Portcls DevObj Info %p %x \n", memLoc, flags.Flags );

    //
    // get the DevObj data
    //
    if( memLoc )
    {
        if( GetFieldValue( memLoc, "DEVICE_OBJECT", "DeviceExtension", DeviceExtension ) )
        {
            dprintf("Could not read DevObj data\n");
            return E_INVALIDARG;
        }
    } else
    {
        dprintf("\nSYNTAX:  !portcls <devobj> [flags]\n");
    }

    //
    // check for device extension
    //
    if( !DeviceExtension )
    {
        dprintf("DevObj has no device extension\n");
        return E_INVALIDARG;
    }

    //
    // get the device context
    //
    if( InitTypeRead( DeviceExtension, "DEVICE_CONTEXT" ) )
    {
        dprintf("Could not read DevObj device extension\n");
        return E_INVALIDARG;
    }

    //
    // validate the DevObj
    //
    if( !PCKD_ValidateDevObj( DeviceExtension ) )
    {
        dprintf("DevObj not valid or not bound to PortCls\n");
        return E_INVALIDARG;
    }

    //
    // initialize the subdevice list
    //
    InitializeListHead( &SubdeviceList );

    //
    // acquire the device data
    //
    PCKD_AcquireDeviceData( DeviceExtension, &SubdeviceList, flags.Flags );

    //
    // display the requested info
    //
    PCKD_DisplayDeviceData( DeviceExtension, &SubdeviceList, flags.Flags );

    //
    // release the device data
    //
    PCKD_FreeDeviceData( &SubdeviceList );
    return S_OK;
}

/**********************************************************************
 * PCKD_ValidateDevObj
 **********************************************************************
 * Description:
 *      This routine attempts to validate whether or not a given device
 *      extension is from a PortCls bound DevObj.
 *
 * Arguments:
 *      PDEVICE_CONTEXT     DeviceContext
 *      PORTCLS_FLAGS       Flags
 *
 * Return Value:
 *      BOOL                TRUE = Valid, FALSE = Invalid
 */
BOOL
PCKD_ValidateDevObj
(
    ULONG64     DeviceContext
)
{
    UNREFERENCED_PARAMETER( DeviceContext );

    // TODO - Validate device extension
    return TRUE;
}

/**********************************************************************
 * PCKD_AcquireDeviceData
 **********************************************************************
 * Description:
 *      This routine acquires device data given a validated device
 *      context and builds a subdevice list contain all of the data.
 *
 * Arguments:
 *      PDEVICE_CONTEXT     DeviceContext
 *      PLIST_ENTRY         SubdeviceList
 *      PORTCLS_FLAGS       Flags
 *
 * Return Value:
 *      None
 */
VOID
PCKD_AcquireDeviceData
(
    ULONG64             DeviceContext,
    PLIST_ENTRY         SubdeviceList,
    ULONG               flags
)
{
    ULONG                   SubdeviceIndex;
    PCKD_SUBDEVICE_ENTRY   *SubdeviceEntry;
    ULONG64                 CreateItems;
    ULONG64                 CurrentCreateItemAddr;
    PKSOBJECT_CREATE_ITEM_READ   ReadCreateItems;
    PKSOBJECT_CREATE_ITEM_READ   CurrentCreateItem;
    PWSTR                   Buffer;
    ULONG                   Size;
    ULONG                   Result;
    ANSI_STRING             AnsiString;
    PLIST_ENTRY             ListEntry;
    PORTCLS_FLAGS           Flags;
    ULONG                   ItemSz, MaxObjects;
    ULONG                   i;
    Flags.Flags = flags;


    ItemSz = GetTypeSize("KSOBJECT_CREATE_ITEM");

    InitTypeRead(DeviceContext, DEVICE_CONTEXT);

    // allocate local memory for the create items table
    Size =  (MaxObjects = (ULONG) ReadField(MaxObjects)) * sizeof(KSOBJECT_CREATE_ITEM_READ);
    
    ReadCreateItems = (PKSOBJECT_CREATE_ITEM_READ)LocalAlloc( LPTR, Size );
    if( !ReadCreateItems )
    {
        dprintf("** Unable to allocate create item table memory\n");
        return;
    }

    CreateItems = ReadField(CreateItems);

    // copy the create items table to local memory
    for (i=0, CurrentCreateItemAddr=CreateItems; 
         i<MaxObjects, CurrentCreateItemAddr+=IteSz; 
         i++) { 
        InitTypeRead(CurrentCreateItemAddr, KSOBJECT_CREATE_ITEM);
        ReadCreateItems[i].Context = ReadField(Context);
        ReadCreateItems[i].Create  = ReadField(Create);
        ReadCreateItems[i].Flags   = ReadField(Flags);
        ReadCreateItems[i].ObjectClassBuffer   = ReadField(ObjectClass.Buffer);
        ReadCreateItems[i].ObjectClass.MaximumLength = ReadField(ObjectClass.MaximumLength);
        ReadCreateItems[i].ObjectClass.Length = ReadField(ObjectClass.Length);
        ReadCreateItems[i].SecurityDescriptor   = ReadField(SecurityDescriptor);
    }
    
    // check out each potential subdevice
    for( SubdeviceIndex = 0, CurrentCreateItem = ReadCreateItems;
         SubdeviceIndex < MaxObjects;
         SubdeviceIndex++, CurrentCreateItem++ )
    {

        if( CurrentCreateItem->Create) )
        {
            // allocate a subdevice list entry
            SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_SUBDEVICE_ENTRY) );
            if( SubdeviceEntry )
            {
                // initialize the port filter list
                InitializeListHead( &(SubdeviceEntry->Port.FilterList) );

                // copy the create item data
                memcpy( &(SubdeviceEntry->CreateItem), CurrentCreateItem, sizeof(KSOBJECT_CREATE_ITEM_READ) );

                // allocate memory for the unicode string buffer
                Buffer = (PWSTR)LocalAlloc( LPTR, CurrentCreateItem->ObjectClass.MaximumLength );
                if( !Buffer )
                {
                    dprintf("** Unable to allocate unicode string buffer\n");
                    LocalFree( SubdeviceEntry );
                    break;
                }

                // read unicode string data
                if( !ReadMemory( CurrentCreateItem->ObjectClassBuffer,
                                 Buffer,
                                 CurrentCreateItem->ObjectClass.MaximumLength,
                                 &Result ) )
                {
                    dprintf("** Unable to read unicode string buffer (0x%p)\n",CurrentCreateItem->ObjectClassBuffer);
                    LocalFree( Buffer );
                    LocalFree( SubdeviceEntry );
                    break;
                }

                // point the create item string to the local buffer
                // ?????
                SubdeviceEntry->CreateItem.ObjectClass.Buffer = Buffer;

                // determine port type by checking string
                // TODO: this should be done by the GUID
                //
                
                // convert to ansi
                RtlUnicodeStringToAnsiString( &AnsiString,
                                              &(SubdeviceEntry->CreateItem.ObjectClass),
                                              TRUE );

                if( 0 == _stricmp( AnsiString.Buffer, "topology" ) )
                {
                    SubdeviceEntry->Port.PortType = Topology;
                    SubdeviceEntry->Port.PortData = NULL;

                } else if( 0 == _stricmp( AnsiString.Buffer, "wave" ) )
                {
                    SubdeviceEntry->Port.PortType = WaveCyclic;
                    SubdeviceEntry->Port.PortData = NULL;

                } else if( (0 == _stricmp( AnsiString.Buffer, "uart") ) ||
                           (0 == _stricmp( AnsiString.Buffer, "fmsynth") ) )
                {
                    SubdeviceEntry->Port.PortType = Midi;
                    SubdeviceEntry->Port.PortData = NULL;
                } else
                {
                    SubdeviceEntry->Port.PortType = UnknownPort;
                    SubdeviceEntry->Port.PortData = NULL;
                }

                // free the ansi string
                RtlFreeAnsiString( &AnsiString );

                // add the subdevice entry to the subdevice list
                InsertTailList( SubdeviceList, &(SubdeviceEntry->ListEntry) );               

            } else
            {
                dprintf("** Unable to allocate subdevice memory\n");
            }
        }
    }

    // free the create item table local storage
    LocalFree( ReadCreateItems );

    // acquire the port, filter, and pin data
    if( (!IsListEmpty(SubdeviceList)) && (Flags.PortDump || Flags.FilterDump || Flags.PinDump) )
    {
        for( ListEntry = SubdeviceList->Flink; ListEntry != SubdeviceList; ListEntry = ListEntry->Flink )
        {
            SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *) ListEntry;

            // read basic port data
            PVOID Port;
            ULONG PortSize;

            switch( SubdeviceEntry->Port.PortType)
            {
                case Topology:
                    Port = LocalAlloc( LPTR, sizeof(CPortTopology) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortTopology *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortTopology),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                case WaveCyclic:
                    Port = LocalAlloc( LPTR, sizeof(CPortWaveCyclic) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortWaveCyclic *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortWaveCyclic),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                case WavePci:
                    Port = LocalAlloc( LPTR, sizeof(CPortWavePci) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortWavePci *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortWavePci),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                case Midi:
                    Port = LocalAlloc( LPTR, sizeof(CPortMidi) );
                    if( !Port )
                    {
                        dprintf("** Unable to allocate port memory\n");
                        break;
                    }

                    if( !ReadMemory( (ULONG)((CPortMidi *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context))),
                        Port,
                        sizeof(CPortMidi),
                        &Result ) )
                    {
                        dprintf("** Unable to read port data\n");
                        LocalFree( Port );
                        Port = NULL;
                        break;
                    }
                    break;

                default:
                    break;
            }

            // attach the port data to the subdevice entry
            SubdeviceEntry->Port.PortData = Port;

            switch( SubdeviceEntry->Port.PortType )
            {
                case Topology:
                    break;

                case WaveCyclic:
                    {
                        CPortWaveCyclic *PortWaveCyclic = (CPortWaveCyclic *)Port;


                        // get the filter and pin data
                        if( Flags.FilterDump || Flags.PinDump )
                        {
                            ULONG               Offset;
                            ULONG               PortBase;
                            PLIST_ENTRY         Flink;
                            PLIST_ENTRY         TempListEntry;
                            ULONG               PinNumber = 0;
                            CPortPinWaveCyclic *PortPinWaveCyclic;
                            CIrpStream         *IrpStream;
                            PCKD_PIN_ENTRY     *CurrentPinEntry;
                            BOOL                NeedNewFilter;

                            // get the offsets needed to walk the list
                            Offset = FIELD_OFFSET(CPortWaveCyclic,m_PinList);
                            PortBase = (ULONG)((CPortWaveCyclic *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context)));

                            // get the first pin pointer
                            Flink = PortWaveCyclic->m_PinList.Flink;

                            while (Flink != PLIST_ENTRY(PortBase + Offset))
                            {
                                // allocate a pin list entry
                                CurrentPinEntry = (PCKD_PIN_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_PIN_ENTRY) );
                                if( !CurrentPinEntry )
                                {
                                    dprintf("** Unable to allocate pin list entry\n");
                                    break;
                                }
                                
                                // initialize the pin entry
                                InitializeListHead( &(CurrentPinEntry->IrpList) );
                                CurrentPinEntry->PinData = NULL;
                                CurrentPinEntry->IrpStreamData = NULL;
                                CurrentPinEntry->PinInstanceId = PinNumber++;

                                // allocate local storage for the pin data
                                PortPinWaveCyclic = (CPortPinWaveCyclic *)LocalAlloc( LPTR, sizeof(CPortPinWaveCyclic) );
                                if( !PortPinWaveCyclic )
                                {
                                    dprintf("** Unable to allocate pin data storage\n");
                                    LocalFree( CurrentPinEntry );
                                    break;
                                }

                                // read the pin data
                                if( !ReadMemory( (ULONG)CONTAINING_RECORD(Flink,
                                                                          CPortPinWaveCyclic,
                                                                          m_PinListEntry),
                                                 PortPinWaveCyclic,
                                                 sizeof(CPortPinWaveCyclic),
                                                 &Result ) )
                                {
                                    dprintf("** Unable to read pin data\n");
                                    LocalFree( PortPinWaveCyclic );
                                    LocalFree( CurrentPinEntry );
                                    break;
                                }

                                // is there an irp stream
                                if( PortPinWaveCyclic->m_IrpStream )
                                {
                                    // allocate local storage for the irp stream data
                                    IrpStream = (CIrpStream *)LocalAlloc( LPTR, sizeof(CIrpStream) );
                                    if( IrpStream )
                                    {
                                        // read the irp stream data
                                        if( !ReadMemory( (ULONG)((CIrpStream *)(PortPinWaveCyclic->m_IrpStream)),
                                                         IrpStream,
                                                         sizeof(CIrpStream),
                                                         &Result ) )
                                        {
                                            dprintf("** Unable to read irp stream data\n");
                                            LocalFree( IrpStream );
                                        } else
                                        {
                                            PCKD_AcquireIrpStreamData( CurrentPinEntry,
                                                                       (CIrpStream *)(PortPinWaveCyclic->m_IrpStream),
                                                                       IrpStream );
                                        }
                                    } else
                                    {
                                        dprintf("** Unable to allocate irp stream storage\n");
                                    }
                                }

                                // we need a new filter unless we find it in the filter list
                                NeedNewFilter = TRUE;

                                // is the filter list empty?
                                if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                                {
                                    PLIST_ENTRY     FilterListEntry;

                                    for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                                         FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                                         FilterListEntry = FilterListEntry->Flink )
                                    {
                                        PCKD_FILTER_ENTRY *CurrentFilterEntry = (PCKD_FILTER_ENTRY *) FilterListEntry;

                                        if( CurrentFilterEntry->FilterInstanceId == (ULONG)(PortPinWaveCyclic->m_Filter) )
                                        {
                                            // found our filter
                                            NeedNewFilter = FALSE;

                                            // add the pin data to the pin entry
                                            CurrentPinEntry->PinData = (PVOID)PortPinWaveCyclic;

                                            // add the pin entry to the filter's pin list
                                            InsertTailList( &(CurrentFilterEntry->PinList),
                                                            &(CurrentPinEntry->ListEntry) );
                                        }
                                    }
                                }

                                // do we need a new filter entry?
                                if( NeedNewFilter )
                                {
                                    PCKD_FILTER_ENTRY   *CurrentFilterEntry;

                                    // allocate a new filter entry
                                    CurrentFilterEntry = (PCKD_FILTER_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_FILTER_ENTRY) );
                                    if(!CurrentFilterEntry)
                                    {
                                        dprintf("** Unable to allocate filter entry\n");
                                        LocalFree( PortPinWaveCyclic );
                                        if( CurrentPinEntry->IrpStreamData )
                                        {
                                            LocalFree( CurrentPinEntry->IrpStreamData );
                                        }
                                        // free up any irps in the irp list
                                        while(!IsListEmpty( &(CurrentPinEntry->IrpList)))
                                        {
                                            PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(CurrentPinEntry->IrpList));
                                            LocalFree( IrpEntry );                                                
                                        }
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    //initialize the new filter entry
                                    InitializeListHead( &(CurrentFilterEntry->PinList) );
                                    CurrentFilterEntry->FilterData = NULL;
                                    CurrentFilterEntry->FilterInstanceId = (ULONG)(PortPinWaveCyclic->m_Filter);

                                    // add the pin data to the pin entry
                                    CurrentPinEntry->PinData = (PVOID)PortPinWaveCyclic;

                                    // add the pin entry to the filter's pin list
                                    InsertTailList( &(CurrentFilterEntry->PinList),
                                                    &(CurrentPinEntry->ListEntry) );

                                    /// add the filter entry to the port's filter list
                                    InsertTailList( &(SubdeviceEntry->Port.FilterList),
                                                    &(CurrentFilterEntry->ListEntry) );
                                }
                                
                                // allocate list entry storage
                                TempListEntry = (PLIST_ENTRY)LocalAlloc( LPTR, sizeof(LIST_ENTRY) );
                                if( TempListEntry )
                                {
                                    // read in the next list entry
                                    if( !ReadMemory( (ULONG)Flink,
                                                     TempListEntry,
                                                     sizeof(LIST_ENTRY),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read temp list entry\n");
                                        LocalFree(TempListEntry);
                                        break;
                                    }

                                    // update FLINK
                                    Flink = TempListEntry->Flink;

                                    // free the temp list entry
                                    LocalFree( TempListEntry );
                                } else
                                {
                                    dprintf("** Unable to allocate temp list entry\n");
                                    break;
                                }                                                
                            }
                        }
                    }
                    break;

                case WavePci:
                    {
                        CPortWavePci *PortWavePci = (CPortWavePci *)Port;


                        // get the filter and pin data
                        if( Flags.FilterDump || Flags.PinDump )
                        {
                            ULONG               Offset;
                            ULONG               PortBase;
                            PLIST_ENTRY         Flink;
                            PLIST_ENTRY         TempListEntry;
                            ULONG               PinNumber = 0;
                            CPortPinWavePci *PortPinWavePci;
                            CIrpStream         *IrpStream;
                            PCKD_PIN_ENTRY     *CurrentPinEntry;
                            BOOL                NeedNewFilter;

                            // get the offsets needed to walk the list
                            Offset = FIELD_OFFSET(CPortWavePci,m_PinList);
                            PortBase = (ULONG)((CPortWavePci *)((ISubdevice *)(SubdeviceEntry->CreateItem.Context)));

                            // get the first pin pointer
                            Flink = PortWavePci->m_PinList.Flink;

                            while (Flink != PLIST_ENTRY(PortBase + Offset))
                            {
                                // allocate a pin list entry
                                CurrentPinEntry = (PCKD_PIN_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_PIN_ENTRY) );
                                if( !CurrentPinEntry )
                                {
                                    dprintf("** Unable to allocate pin list entry\n");
                                    break;
                                }
                                
                                // initialize the pin entry
                                InitializeListHead( &(CurrentPinEntry->IrpList) );
                                CurrentPinEntry->PinData = NULL;
                                CurrentPinEntry->IrpStreamData = NULL;
                                CurrentPinEntry->PinInstanceId = PinNumber++;

                                // allocate local storage for the pin data
                                PortPinWavePci = (CPortPinWavePci *)LocalAlloc( LPTR, sizeof(CPortPinWavePci) );
                                if( !PortPinWavePci )
                                {
                                    dprintf("** Unable to allocate pin data storage\n");
                                    LocalFree( CurrentPinEntry );
                                    break;
                                }

                                // read the pin data
                                if( !ReadMemory( (ULONG)CONTAINING_RECORD(Flink,
                                                                          CPortPinWavePci,
                                                                          m_PinListEntry),
                                                 PortPinWavePci,
                                                 sizeof(CPortPinWavePci),
                                                 &Result ) )
                                {
                                    dprintf("** Unable to read pin data\n");
                                    LocalFree( PortPinWavePci );
                                    LocalFree( CurrentPinEntry );
                                    break;
                                }

                                // is there an irp stream
                                if( PortPinWavePci->m_IrpStream )
                                {
                                    // allocate local storage for the irp stream data
                                    IrpStream = (CIrpStream *)LocalAlloc( LPTR, sizeof(CIrpStream) );
                                    if( IrpStream )
                                    {
                                        // read the irp stream data
                                        if( !ReadMemory( (ULONG)((CIrpStream *)(PortPinWavePci->m_IrpStream)),
                                                         IrpStream,
                                                         sizeof(CIrpStream),
                                                         &Result ) )
                                        {
                                            dprintf("** Unable to read irp stream data\n");
                                            LocalFree( IrpStream );
                                        } else
                                        {
                                            PCKD_AcquireIrpStreamData( CurrentPinEntry,
                                                                       (CIrpStream *)(PortPinWavePci->m_IrpStream),
                                                                       IrpStream );
                                        }
                                    } else
                                    {
                                        dprintf("** Unable to allocate irp stream storage\n");
                                    }
                                }

                                // we need a new filter unless we find it in the filter list
                                NeedNewFilter = TRUE;

                                // is the filter list empty?
                                if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                                {
                                    PLIST_ENTRY     FilterListEntry;

                                    for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                                         FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                                         FilterListEntry = FilterListEntry->Flink )
                                    {
                                        PCKD_FILTER_ENTRY *CurrentFilterEntry = (PCKD_FILTER_ENTRY *) FilterListEntry;

                                        if( CurrentFilterEntry->FilterInstanceId == (ULONG)(PortPinWavePci->Filter) )
                                        {
                                            // found our filter
                                            NeedNewFilter = FALSE;

                                            // add the pin data to the pin entry
                                            CurrentPinEntry->PinData = (PVOID)PortPinWavePci;

                                            // add the pin entry to the filter's pin list
                                            InsertTailList( &(CurrentFilterEntry->PinList),
                                                            &(CurrentPinEntry->ListEntry) );
                                        }
                                    }
                                }

                                // do we need a new filter entry?
                                if( NeedNewFilter )
                                {
                                    PCKD_FILTER_ENTRY   *CurrentFilterEntry;

                                    // allocate a new filter entry
                                    CurrentFilterEntry = (PCKD_FILTER_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_FILTER_ENTRY) );
                                    if(!CurrentFilterEntry)
                                    {
                                        dprintf("** Unable to allocate filter entry\n");
                                        LocalFree( PortPinWavePci );
                                        if( CurrentPinEntry->IrpStreamData )
                                        {
                                            LocalFree( CurrentPinEntry->IrpStreamData );
                                        }
                                        // free up any irps in the irp list
                                        while(!IsListEmpty( &(CurrentPinEntry->IrpList)))
                                        {
                                            PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(CurrentPinEntry->IrpList));
                                            LocalFree( IrpEntry );                                                
                                        }
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    //initialize the new filter entry
                                    InitializeListHead( &(CurrentFilterEntry->PinList) );
                                    CurrentFilterEntry->FilterData = NULL;
                                    CurrentFilterEntry->FilterInstanceId = (ULONG)(PortPinWavePci->Filter);

                                    // add the pin data to the pin entry
                                    CurrentPinEntry->PinData = (PVOID)PortPinWavePci;

                                    // add the pin entry to the filter's pin list
                                    InsertTailList( &(CurrentFilterEntry->PinList),
                                                    &(CurrentPinEntry->ListEntry) );

                                    /// add the filter entry to the port's filter list
                                    InsertTailList( &(SubdeviceEntry->Port.FilterList),
                                                    &(CurrentFilterEntry->ListEntry) );
                                }
                                
                                // allocate list entry storage
                                TempListEntry = (PLIST_ENTRY)LocalAlloc( LPTR, sizeof(LIST_ENTRY) );
                                if( TempListEntry )
                                {
                                    // read in the next list entry
                                    if( !ReadMemory( (ULONG)Flink,
                                                     TempListEntry,
                                                     sizeof(LIST_ENTRY),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read temp list entry\n");
                                        LocalFree(TempListEntry);
                                        break;
                                    }

                                    // update FLINK
                                    Flink = TempListEntry->Flink;

                                    // free the temp list entry
                                    LocalFree( TempListEntry );
                                } else
                                {
                                    dprintf("** Unable to allocate temp list entry\n");
                                    break;
                                }                                                
                            }
                        }
                    }                    
                    break;

                case Midi:
                    {
                        CPortMidi *PortMidi = (CPortMidi *)Port;

                        // get the filter and pin data
                        if( Flags.FilterDump || Flags.PinDump )
                        {
                            ULONG               PinIndex;
                            CPortPinMidi       *PortPinMidi;
                            CIrpStream         *IrpStream;
                            PCKD_PIN_ENTRY     *CurrentPinEntry;
                            BOOL                NeedNewFilter;

                            for( PinIndex = 0; PinIndex < PortMidi->m_PinEntriesUsed; PinIndex++ )
                            {
                                if( PortMidi->m_Pins[ PinIndex] )
                                {
                                    // allocate a pin list entry
                                    CurrentPinEntry = (PCKD_PIN_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_PIN_ENTRY) );
                                    if( !CurrentPinEntry )
                                    {
                                        dprintf("** Unable to allocate pin list entry\n");
                                        break;
                                    }

                                    // initialize the pin entry
                                    InitializeListHead( &(CurrentPinEntry->IrpList) );
                                    CurrentPinEntry->PinData = NULL;
                                    CurrentPinEntry->PinInstanceId = (ULONG)(PortMidi->m_Pins[ PinIndex ]);

                                    // allocate local storage for the pin data
                                    PortPinMidi = (CPortPinMidi *)LocalAlloc( LPTR, sizeof(CPortPinMidi) );
                                    if( !PortPinMidi )
                                    {
                                        dprintf("** Unable to allocate pin data storage\n");
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // read the pin data
                                    if( !ReadMemory( (ULONG)(PortMidi->m_Pins[ PinIndex ]),
                                                     PortPinMidi,
                                                     sizeof(CPortPinMidi),
                                                     &Result ) )
                                    {
                                        dprintf("** Unable to read pin data\n");
                                        LocalFree( PortPinMidi );
                                        LocalFree( CurrentPinEntry );
                                        break;
                                    }

                                    // is there an irp stream
                                    if( PortPinMidi->m_IrpStream )
                                    {
                                        // allocate local storage for the irp stream data
                                        IrpStream = (CIrpStream *)LocalAlloc( LPTR, sizeof(CIrpStream) );
                                        if( IrpStream )
                                        {
                                            // read the irp stream data
                                            if( !ReadMemory( (ULONG)(PortPinMidi->m_IrpStream),
                                                             IrpStream,
                                                             sizeof(CIrpStream),
                                                             &Result ) )
                                            {
                                                dprintf("** Unable to read irp stream data\n");
                                                LocalFree( IrpStream );
                                            } else
                                            {
                                                PCKD_AcquireIrpStreamData( CurrentPinEntry,
                                                                           (CIrpStream *)(PortPinMidi->m_IrpStream),
                                                                           IrpStream );
                                            }
                                        } else
                                        {
                                            dprintf("** Unable to allocate irp stream storage\n");
                                        }
                                    }

                                    // we need a new filter unless we find it in the filter list
                                    NeedNewFilter = TRUE;

                                    // is the filter list empty?
                                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                                    {
                                        PLIST_ENTRY     FilterListEntry;

                                        for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                                             FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                                             FilterListEntry = FilterListEntry->Flink )
                                        {
                                            PCKD_FILTER_ENTRY *CurrentFilterEntry = (PCKD_FILTER_ENTRY *) FilterListEntry;

                                            if( CurrentFilterEntry->FilterInstanceId == (ULONG)(PortPinMidi->m_Filter) )
                                            {
                                                // found our filter
                                                NeedNewFilter = FALSE;

                                                // add the pin data to the pin entry
                                                CurrentPinEntry->PinData = (PVOID)PortPinMidi;

                                                // add the pin entry to the filter's pin list
                                                InsertTailList( &(CurrentFilterEntry->PinList),
                                                                &(CurrentPinEntry->ListEntry) );
                                            }
                                        }
                                    }

                                    // do we need a new filter entry?
                                    if( NeedNewFilter )
                                    {
                                        PCKD_FILTER_ENTRY   *CurrentFilterEntry;

                                        // allocate a new filter entry
                                        CurrentFilterEntry = (PCKD_FILTER_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_FILTER_ENTRY) );
                                        if(!CurrentFilterEntry)
                                        {
                                            dprintf("** Unable to allocate filter entry\n");
                                            LocalFree( PortPinMidi );
                                            if( CurrentPinEntry->IrpStreamData )
                                            {
                                                LocalFree( CurrentPinEntry->IrpStreamData );
                                            }
                                            // free up any irps in the irp list
                                            while(!IsListEmpty( &(CurrentPinEntry->IrpList)))
                                            {
                                                PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(CurrentPinEntry->IrpList));
                                                LocalFree( IrpEntry );
                                            }
                                            LocalFree( CurrentPinEntry );
                                            break;
                                        }

                                        //initialize the new filter entry
                                        InitializeListHead( &(CurrentFilterEntry->PinList) );
                                        CurrentFilterEntry->FilterData = NULL;
                                        CurrentFilterEntry->FilterInstanceId = (ULONG)(PortPinMidi->m_Filter);

                                        // add the pin data to the pin entry
                                        CurrentPinEntry->PinData = (PVOID)PortPinMidi;

                                        // add the pin entry to the filter's pin list
                                        InsertTailList( &(CurrentFilterEntry->PinList),
                                                        &(CurrentPinEntry->ListEntry) );

                                        /// add the filter entry to the port's filter list
                                        InsertTailList( &(SubdeviceEntry->Port.FilterList),
                                                        &(CurrentFilterEntry->ListEntry) );
                                    }
                                }
                            }
                        }
                    }                    
                    break;

                default:
                    break;
            }
        }
    }
}

/**********************************************************************
 * PCKD_DisplayDeviceData
 **********************************************************************
 * Description:
 *      This routine displays the requested device data on the debugger
 *      given a valid device context and a subdevice list built with
 *      PCKD_AcquireDeviceData.
 * Arguments:
 *      PDEVICE_CONTEXT     DeviceContext
 *      PLIST_ENTRY         SubdeviceList
 *      PORTCLS_FLAGS       Flags
 *
 * Return Value:
 *      None
 */
VOID
PCKD_DisplayDeviceData
(
    PDEVICE_CONTEXT     DeviceContext,
    PLIST_ENTRY         SubdeviceList,
    ULONG               flags
)
{
    PLIST_ENTRY             SubdeviceListEntry;
    PCKD_SUBDEVICE_ENTRY    *SubdeviceEntry;
    ANSI_STRING             AnsiNameString;
    PORTCLS_FLAGS           Flags;

    Flags.Flags = flags;

    dprintf("\n");

    // dump misc device context information
    if( Flags.DeviceContext )
    {
        dprintf("\n  DEVICE INFO:\n");
    
        dprintf("    PDO:                   0x%x\n",DeviceContext->PhysicalDeviceObject);
        if( Flags.Verbose )
        {
            if( Flags.ReallyVerbose )
            {
                dprintf("    Max Objects:           0x%x\n",DeviceContext->MaxObjects);
            }
            dprintf("    Existing Objects:      0x%x\n",DeviceContext->ExistingObjectCount);
            dprintf("    Active Pin Count:      0x%x\n",DeviceContext->ActivePinCount);
            dprintf("    Pending IRP Count:     0x%x\n",DeviceContext->PendingIrpCount);
        }
    }

    // dump power management information
    if( Flags.PowerInfo )
    {
        dprintf("\n  POWER INFO:\n");

        dprintf("    DeviceState:           %s\n", TranslateDevicePower( DeviceContext->CurrentDeviceState ) );
        dprintf("    SystemState:           %s\n", TranslateSystemPower( DeviceContext->CurrentSystemState ) );
        dprintf("    AdapterPower:          0x%x\n", DeviceContext->pAdapterPower );
        if( Flags.Verbose && Flags.ReallyVerbose )
        {
            ULONG index;
            
            dprintf("    Idle Timer:            0x%x\n", DeviceContext->IdleTimer );
            dprintf("    Cons Idle Time:        0x%x\n", DeviceContext->ConservationIdleTime );
            dprintf("    Perf Idle Time:        0x%x\n", DeviceContext->PerformanceIdleTime );
            dprintf("    Idle Device State:     %s\n", TranslateDevicePower( DeviceContext->IdleDeviceState ) );

            dprintf("    State Mappings:\n");    
            for( index = 0; index < (ULONG)PowerSystemMaximum; index++ )
            {
                dprintf("      %20s ==> %14s\n", TranslateSystemPower( index ),
                                                 TranslateDevicePower( DeviceContext->DeviceStateMap[ index ] ) );
            }
        }
    }

    // dump port/filter/pin information
    if( Flags.PortDump || Flags.FilterDump || Flags.PinDump )
    {
        if( !IsListEmpty( SubdeviceList ) )
        {
            // go through the subdevice list
            for( SubdeviceListEntry = SubdeviceList->Flink;
                 SubdeviceListEntry != SubdeviceList;
                 SubdeviceListEntry = SubdeviceListEntry->Flink )
            {
                SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *)SubdeviceListEntry;

                switch( SubdeviceEntry->Port.PortType )
                {
                    case Topology:
                        // dump port name
                        dprintf("\n  TOPOLOGY PORT:\n");
                        break;

                    case WaveCyclic:
                        // dump port name
                        dprintf("\n  WAVECYCLIC PORT:\n");
                        break;

                    case WavePci:
                        // dump port name
                        dprintf("\n  WAVEPCI PORT:\n");
                        break;

                    case Midi:
                        // dump port name
                        dprintf("\n  MIDI PORT:\n");
                        break;

                    default:
                        // dump port name
                        dprintf("\n  UNKNOWN PORT:\n");
                        break;                        
                }

                // print out the real name
                RtlUnicodeStringToAnsiString( &AnsiNameString,
                                              &(SubdeviceEntry->CreateItem.ObjectClass),
                                              TRUE );
                dprintf("    Name:                  %s\n",AnsiNameString.Buffer);
                RtlFreeAnsiString( &AnsiNameString );

                // dump the port instance
                dprintf("    Port Instance:         0x%x\n",SubdeviceEntry->CreateItem.Context);

                if( Flags.Verbose && Flags.ReallyVerbose )
                {
                    // dump generic port data
                    dprintf("    Create:                0x%x\n",SubdeviceEntry->CreateItem.Create);
                    dprintf("    Security:              0x%x\n",SubdeviceEntry->CreateItem.SecurityDescriptor);
                    dprintf("    Flags:                 0x%x\n",SubdeviceEntry->CreateItem.Flags);
                }

                // dump port type specific port data
                switch( SubdeviceEntry->Port.PortType )
                {
                    case Topology:
                        {
                            CPortTopology *port = (CPortTopology *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                        }
                        break;

                    case WaveCyclic:
                        {
                            CPortWaveCyclic *port = (CPortWaveCyclic *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                        }
                        break;

                    case WavePci:
                        {
                            CPortWavePci *port = (CPortWavePci *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                        }
                        break;

                    case Midi:
                        {
                            CPortMidi *port = (CPortMidi *)(SubdeviceEntry->Port.PortData);
                            dprintf("    Miniport:              0x%x\n",port->m_Miniport);
                            if( Flags.Verbose && Flags.ReallyVerbose )
                            {
                                dprintf("    Subdevice Desc:        0x%x\n",port->m_pSubdeviceDescriptor);
                                dprintf("    Filter Desc:           0x%x\n",port->m_pPcFilterDescriptor);
                            }
                            dprintf("    Pin Count:             0x%x\n",port->m_PinEntriesUsed);
                        }
                        break;

                    default:
                        break;
                }

                if( Flags.FilterDump || Flags.PinDump )
                {
                    // dump the filters
                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                    {
                        PLIST_ENTRY         FilterListEntry;
                        PCKD_FILTER_ENTRY   *FilterEntry;                        

                        // run through the filter list
                        for( FilterListEntry = SubdeviceEntry->Port.FilterList.Flink;
                             FilterListEntry != &(SubdeviceEntry->Port.FilterList);
                             FilterListEntry = FilterListEntry->Flink )
                        {
                            FilterEntry = (PCKD_FILTER_ENTRY *)FilterListEntry;

                            dprintf("      Filter Instance:     0x%x\n",FilterEntry->FilterInstanceId);

                            if( Flags.PinDump )
                            {
                                // dump the pins
                                if( !IsListEmpty( &(FilterEntry->PinList) ) )
                                {
                                    PLIST_ENTRY         PinListEntry;
                                    PCKD_PIN_ENTRY      *PinEntry;

                                    // run through the pin list
                                    for( PinListEntry = FilterEntry->PinList.Flink;
                                         PinListEntry != &(FilterEntry->PinList);
                                         PinListEntry = PinListEntry->Flink )
                                    {
                                        PinEntry = (PCKD_PIN_ENTRY *)PinListEntry;

                                        dprintf("        Pin Instance:      0x%x\n",PinEntry->PinInstanceId);

                                        // dump the pin data
                                        switch( SubdeviceEntry->Port.PortType )
                                        {
                                            case WaveCyclic:
                                                {
                                                    CPortPinWaveCyclic *pin = (CPortPinWaveCyclic *)(PinEntry->PinData);

                                                    if( pin )
                                                    {
                                                        dprintf("          Miniport Stream: 0x%x\n",pin->m_Stream);
                                                        dprintf("          Stream State:    %s\n", TranslateKsState(pin->m_DeviceState));
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin ID:          0x%x\n",pin->m_Id);
                                                            dprintf("          Commanded State: %s\n", TranslateKsState(pin->m_CommandedState));
                                                            dprintf("          Suspended:       %s\n", pin->m_Suspended ? "TRUE" : "FALSE");
                                                        }
                                                        dprintf("          Dataflow:        %s\n",TranslateKsDataFlow( pin->m_DataFlow ) );
                                                        dprintf("          Data Format:     0x%x\n",pin->m_DataFormat);
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin Desc:        0x%x\n",pin->m_Descriptor);                                                           
                                                        }
                                                        if( Flags.Verbose )
                                                        {
                                                            dprintf("          Service Group:   0x%x\n",pin->m_ServiceGroup);
                                                            dprintf("          Dma Channel:     0x%x\n",pin->m_DmaChannel);
                                                            dprintf("          Irp Stream:      0x%x\n",pin->m_IrpStream);
                                                            if( !IsListEmpty( &(PinEntry->IrpList) ) )
                                                            {
                                                                PLIST_ENTRY     IrpListEntry;
                                                                PCKD_IRP_ENTRY *IrpEntry;

                                                                // run through the irp list
                                                                for( IrpListEntry = PinEntry->IrpList.Flink;
                                                                     IrpListEntry != &(PinEntry->IrpList);
                                                                     IrpListEntry = IrpListEntry->Flink )
                                                                {
                                                                    IrpEntry = (PCKD_IRP_ENTRY *)IrpListEntry;
                                                                    dprintf("            Irp:           0x%x (%s)\n",IrpEntry->Irp,
                                                                                                                     TranslateQueueType(IrpEntry->QueueType));
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                break;

                                            case WavePci:
                                                {
                                                    CPortPinWavePci *pin = (CPortPinWavePci *)(PinEntry->PinData);

                                                    if( pin )
                                                    {
                                                        dprintf("          Miniport Stream: 0x%x\n",pin->Stream);
                                                        dprintf("          Stream State:    %s\n", TranslateKsState(pin->m_DeviceState));
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin ID:          0x%x\n",pin->Id);
                                                            dprintf("          Commanded State: %s\n", TranslateKsState(pin->CommandedState));
                                                            dprintf("          Suspended:       %s\n", pin->m_Suspended ? "TRUE" : "FALSE");
                                                        }
                                                        //dprintf("          Dataflow:        %s\n",TranslateKsDataFlow( pin->DataFlow ) );
                                                        dprintf("          Data Format:     0x%x\n",pin->DataFormat);
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin Desc:        0x%x\n",pin->Descriptor);                                                           
                                                        }
                                                        if( Flags.Verbose )
                                                        {
                                                            dprintf("          Service Group:   0x%x\n",pin->ServiceGroup);
                                                            dprintf("          Dma Channel:     0x%x\n",pin->DmaChannel);
                                                            dprintf("          Irp Stream:      0x%x\n",pin->m_IrpStream);
                                                        }
                                                    }
                                                }
                                                break;

                                            case Midi:
                                                {
                                                    CPortPinMidi *pin = (CPortPinMidi *)(PinEntry->PinData);

                                                    if( pin )
                                                    {
                                                        dprintf("          Miniport Stream: 0x%x\n",pin->m_Stream);
                                                        dprintf("          Stream State:    %s\n", TranslateKsState(pin->m_DeviceState));
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin ID:          0x%x\n",pin->m_Id);
                                                            dprintf("          Commanded State: %s\n", TranslateKsState(pin->m_CommandedState));
                                                            dprintf("          Suspended:       %s\n", pin->m_Suspended ? "TRUE" : "FALSE");
                                                        }
                                                        dprintf("          Dataflow:        %s\n",TranslateKsDataFlow( pin->m_DataFlow ) );
                                                        dprintf("          Data Format:     0x%x\n",pin->m_DataFormat);
                                                        if( Flags.Verbose && Flags.ReallyVerbose )
                                                        {
                                                            dprintf("          Pin Desc:        0x%x\n",pin->m_Descriptor);                                                           
                                                        }
                                                        if( Flags.Verbose )
                                                        {
                                                            dprintf("          Service Group:   0x%x\n",pin->m_ServiceGroup);
                                                            dprintf("          Irp Stream:      0x%x\n",pin->m_IrpStream);
                                                        }
                                                    }
                                                }
                                                break;

                                            default:
                                                break;
                                        }

                                    }

                                } else
                                {
                                    dprintf("        No Pin Instances:\n");      
                                }
                            }
                        }   
                    }
                }
            }
        }
    }

    return;
}

/**********************************************************************
 * PCKD_FreeDeviceData
 **********************************************************************
 * Description:
 *      This routine cleans up and frees the subdevice list.
 * Arguments:
 *      PLIST_ENTRY         SubdeviceList
 *
 * Return Value:
 *      None
 */
VOID
PCKD_FreeDeviceData
(
    PLIST_ENTRY         SubdeviceList
)
{
    PLIST_ENTRY             SubdeviceListEntry;
    PLIST_ENTRY             FilterListEntry;
    PLIST_ENTRY             PinListEntry;
    PCKD_SUBDEVICE_ENTRY    *SubdeviceEntry;
    PCKD_FILTER_ENTRY       *FilterEntry;
    PCKD_PIN_ENTRY          *PinEntry;

    if( !IsListEmpty( SubdeviceList ) )
    {
        SubdeviceListEntry = RemoveHeadList( SubdeviceList );

        while( SubdeviceListEntry )
        {
            SubdeviceEntry = (PCKD_SUBDEVICE_ENTRY *) SubdeviceListEntry;

            // see if we have filters in the filter list
            if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
            {
                FilterListEntry = RemoveHeadList( &(SubdeviceEntry->Port.FilterList) );

                while( FilterListEntry )
                {
                    FilterEntry = (PCKD_FILTER_ENTRY *)FilterListEntry;

                    // see if we have pins in the pin list
                    if( !IsListEmpty( &(FilterEntry->PinList) ) )
                    {
                        PinListEntry = RemoveHeadList( &(FilterEntry->PinList) );

                        while( PinListEntry )
                        {
                            PinEntry = (PCKD_PIN_ENTRY *)PinListEntry;

                            // free the pin data
                            if( PinEntry->PinData )
                            {
                                LocalFree( PinEntry->PinData );
                            }

                            // free the irp stream data
                            if( PinEntry->IrpStreamData )
                            {
                                LocalFree( PinEntry->IrpStreamData );
                            }

                            // free up any irps in the irp list
                            while( !IsListEmpty( &(PinEntry->IrpList) ) )
                            {
                                PCKD_IRP_ENTRY *IrpEntry = (PCKD_IRP_ENTRY *)RemoveTailList(&(PinEntry->IrpList));
                                LocalFree( IrpEntry );
                            }

                            // free the pin entry
                            LocalFree( PinEntry );

                            // get the next pin
                            if( !IsListEmpty( &(FilterEntry->PinList) ) )
                            {
                                PinListEntry = RemoveTailList( &(FilterEntry->PinList) );
                            } else
                            {
                                PinListEntry = NULL;
                            }
                        }
                    }

                    // free the filter data
                    if( FilterEntry->FilterData )
                    {
                        LocalFree( FilterEntry->FilterData );
                    }

                    // free the filter entry
                    LocalFree( FilterEntry );

                    // get the next filter
                    if( !IsListEmpty( &(SubdeviceEntry->Port.FilterList) ) )
                    {
                        FilterListEntry = RemoveTailList( &(SubdeviceEntry->Port.FilterList) );
                    } else
                    {
                        FilterListEntry = NULL;
                    }
                }
            }

            // free the port data
            if( SubdeviceEntry->Port.PortData )
            {
                LocalFree( SubdeviceEntry->Port.PortData );
            }

            // free the unicode string buffer
            LocalFree( SubdeviceEntry->CreateItem.ObjectClass.Buffer );

            // free the subdevice entry
            LocalFree( SubdeviceEntry );

            // on to the next subdevice
            if( !IsListEmpty( SubdeviceList ) )
            {
                SubdeviceListEntry = RemoveTailList( SubdeviceList );
            } else
            {
                SubdeviceListEntry = NULL;
            }
        }
    }

    return;
}

/**********************************************************************
 * PCKD_AcquireIrpStreamData
 **********************************************************************
 * Description:
 *      This routine acquires irp stream irp queue data.
 * Arguments:
 *      PCKD_PIN_ENTRY  *CurrentPinEntry
 *      CIrpStream      *RemoteIrpStream,
 *      CIrpStream      *LocalIrpStream
 *
 * Return Value:
 *      None
 */
VOID
PCKD_AcquireIrpStreamData
(
    PVOID           PinEntry,
    CIrpStream     *RemoteIrpStream,
    CIrpStream     *LocalIrpStream
)
{
    ULONG           QueueType;
    PLIST_ENTRY     Flink;
    PLIST_ENTRY     TempListEntry;
    PIRP            pIrp;
    PCKD_IRP_ENTRY *IrpEntry;
    ULONG           Offset;
    ULONG           Result;
    PCKD_PIN_ENTRY *CurrentPinEntry;

    CurrentPinEntry = (PCKD_PIN_ENTRY *)PinEntry;

    // processs the queues
    for( QueueType = MAPPED_QUEUE; QueueType < MAX_QUEUES; QueueType++ )
    {
        switch( QueueType )
        {
            case PRELOCK_QUEUE:
                Offset = FIELD_OFFSET(CIrpStream,PreLockQueue);
                Flink = LocalIrpStream->PreLockQueue.Flink;
                break;
            case LOCKED_QUEUE:
                Offset = FIELD_OFFSET(CIrpStream,LockedQueue);
                Flink = LocalIrpStream->LockedQueue.Flink;
                break;
            case MAPPED_QUEUE:
                Offset = FIELD_OFFSET(CIrpStream,MappedQueue);
                Flink = LocalIrpStream->MappedQueue.Flink;
                break;
            default:
                Flink = 0;
                break;
        }

        // walk the list (note we can't use IsListEmpty)
        while( (Flink) && (Flink != (PLIST_ENTRY)((PBYTE)RemoteIrpStream + Offset)))
        {
            // get the irp pointer
            pIrp = CONTAINING_RECORD( Flink, IRP, Tail.Overlay.ListEntry );
    
            // allocate an irp entry
            IrpEntry = (PCKD_IRP_ENTRY *)LocalAlloc( LPTR, sizeof(PCKD_IRP_ENTRY) );
            if( IrpEntry )
            {
                // initialize the irp entry
                IrpEntry->QueueType = QueueType;
                IrpEntry->Irp = pIrp;
    
                // add the irp entry to the pin entry
                InsertTailList( &(CurrentPinEntry->IrpList),
                                &(IrpEntry->ListEntry) );
    
            } else
            {
                dprintf("** Unable to allocate irp entry\n");
            }
    
            // allocate list entry storage
            TempListEntry = (PLIST_ENTRY)LocalAlloc( LPTR, sizeof(LIST_ENTRY) );
            if( TempListEntry )
            {
                // read in the next list entry
                if( !ReadMemory( (ULONG)Flink,
                                 TempListEntry,
                                 sizeof(LIST_ENTRY),
                                 &Result ) )
                {
                    dprintf("** Unable to read temp list entry\n");
                    LocalFree(TempListEntry);
                    break;
                }
    
                // update FLINK
                Flink = TempListEntry->Flink;
    
                // free the temp list entry
                LocalFree( TempListEntry );
            } else
            {
                dprintf("** Unable to allocate temp list entry\n");
                break;
            }                                                
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\power.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    power.c

Abstract:

    WinDbg Extension Api

Revision History:

--*/

// podev - dump power relevent data (and other data) about a device object
// polist [arg] - if no arg, dump data about powerirpseriallist
//                  if arg, show entries in serialist that refer to that device object
// podevnode - dump inverted tree and inclusion %
// podevnode <any> - dump normal pnp tree, used only for testing with inverted tree
// postate - dump state statistics

#include "precomp.h"
#pragma hdrstop

VOID
popDumpDeviceName(
    ULONG64  DeviceAddress
    );

__inline
ULONG64
GetAddress(
    IN ULONG64 Base,
    IN PCHAR Type,
    IN PCHAR Field)
{
    ULONG Offset;

    GetFieldOffset(Type, Field, &Offset);
    return(Base + Offset);
}


typedef struct {
    ULONG   Flags;
    PUCHAR  String;
} DEFBITS, *PDEFBITS;


DEFBITS ActFlags[] = {
        POWER_ACTION_QUERY_ALLOWED,     "QueryApps",
        POWER_ACTION_UI_ALLOWED,        "UIAllowed",
        POWER_ACTION_OVERRIDE_APPS,     "OverrideApps",
        POWER_ACTION_DISABLE_WAKES,     "DisableWakes",
        POWER_ACTION_CRITICAL,          "Critical",
        0, NULL
        };

PUCHAR rgPowerNotifyOrder[PO_ORDER_MAXIMUM+1] = {
    "Non-Paged, PnP, Video",
    "Non-Paged, PnP",
    "Non-Paged, Root-Enum, Video",
    "Non-Paged, Root-Enum",
    "Paged, PnP, Video",
    "Paged, PnP",
    "Paged, Root-Enum, Video",
    "Paged, Root-Enum"
    };


static UCHAR Buffer[50];



VOID
poDumpDevice(
    ULONG64 DeviceAddress
    );


DECLARE_API( podev )
/*++

Routine Description:

    Dump the power relevent fields of a device object.

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64 deviceToDump;

    deviceToDump = GetExpression(args);
    dprintf("Device object is for:\n");
    poDumpDevice(deviceToDump);
    return S_OK;
}


VOID
poDumpDevice(
    ULONG64 DeviceAddress
    )

/*++

Routine Description:

    Displays the driver name for the device object if possible, and
    then displays power relevent fields.

Arguments:

    DeviceAddress - address of device object to dump.

Return Value:

    None

--*/

{
    ULONG                      result;
    ULONG                      i;
    PUCHAR                     buffer;
    UNICODE_STRING             unicodeString;
    ULONG64                    nextEntry;
    ULONG64                    queueAddress;
    ULONG64                    irp;
    ULONG64                    pObjectHeader;
    ULONG64                    pNameInfo;
    ULONG                      rmr;
    ULONG                      Type;
    ULONG                      Flags;
    ULONG64                    Temp, DeviceObjectExtension, Dope;
    USHORT                     Length;


    if (GetFieldValue(DeviceAddress,
                     "nt!_DEVICE_OBJECT",
                      "Type",
                      Type)) {
        dprintf("%08p: Could not read device object\n", DeviceAddress);
        return;
    }

    if (Type != IO_TYPE_DEVICE) {
        dprintf("%08p: is not a device object\n", DeviceAddress);
        return;
    }

    //
    // Dump the device name if present.
    //

    pObjectHeader = KD_OBJECT_TO_OBJECT_HEADER(DeviceAddress);
    if (GetFieldValue(pObjectHeader,
                      "nt!_OBJECT_HEADER",
                      "Type",
                      Temp)) {
        ULONG64 pName;

        KD_OBJECT_HEADER_TO_NAME_INFO( pObjectHeader, &pNameInfo );
        if (GetFieldValue(pNameInfo,
                          "nt!_OBJECT_HEADER_NAME_INFO",
                          "Name.Length",
                          Length)) {
            if (Length > 0x1000) // sanity check
            {
                Length = 0x1000;
            }
            buffer = LocalAlloc(LPTR, Length);
            if (buffer != NULL) {
                unicodeString.MaximumLength = Length;
                unicodeString.Length = Length;
                unicodeString.Buffer = (PWSTR)buffer;
                GetFieldValue(pNameInfo,
                              "nt!_OBJECT_HEADER_NAME_INFO",
                              "Name.Buffer",
                              pName);
                if (ReadMemory(pName,
                               buffer,
                               unicodeString.Length,
                               &result) && (result == unicodeString.Length)) {
                    unicodeString.Buffer[(unicodeString.Length/sizeof(WCHAR))-1] = 0;
                    dprintf(" %wZ", &unicodeString);
                }
                LocalFree(buffer);
            }
        }
    }

    //
    // Dump Irps related to driver.
    //

    InitTypeRead(DeviceAddress, nt!_DEVICE_OBJECT);
    dprintf("  DriverObject %08lx\n", ReadField(DriverObject));
    dprintf("Current Irp %08lx RefCount %d Type %08lx ",
            ReadField(CurrentIrp),
            ReadField(ReferenceCount),
            ReadField(DeviceType));
    if (ReadField(AttachedDevice)) {
        dprintf("AttachedDev %08p ", ReadField(AttachedDevice));
    }
    if (ReadField(Vpb)) {
        dprintf("Vpb %08p ", ReadField(Vpb));
    }

    dprintf("DevFlags %08lx", (Flags = (ULONG) ReadField(Flags)));
    if (Flags & DO_POWER_PAGABLE) dprintf("  DO_POWER_PAGABLE");
    if (Flags & DO_POWER_INRUSH) dprintf(" DO_POWER_INRUSH");
    if (Flags & DO_POWER_NOOP) dprintf(" DO_POWER_NOOP");
    dprintf("\n");
    DeviceObjectExtension = ReadField(DeviceObjectExtension);

    if (ReadField(DeviceQueue.Busy)) {
        ULONG Off;

        GetFieldOffset("nt!_DEVICE_OBJECT", "DeviceQueue.DeviceListHead", &Off);
        nextEntry = ReadField(DeviceQueue.DeviceListHead.Flink);

        if (nextEntry == DeviceAddress + Off) {
            dprintf("Device queue is busy -- Queue empty\n");
        } else {
            ULONG Qoffset, IrpOffset;

            dprintf("DeviceQueue: ");
            i = 0;

            GetFieldOffset("nt!_DEVICE_OBJECT", "DeviceListEntry", &Qoffset);
            GetFieldOffset("nt!_IRP", "Tail.Overlay.DeviceQueueEntry", &IrpOffset);
            while ( nextEntry != ( DeviceAddress + Off )) {
                queueAddress = (nextEntry - Qoffset);
                if (GetFieldValue(queueAddress,
                                 "nt!_KDEVICE_QUEUE_ENTRY",
                                 "DeviceListEntry.Flink",
                                  nextEntry)) {
                    dprintf("%08p: Could not read queue entry\n", DeviceAddress);
                    return;
                }

//                nextEntry = queueEntry.DeviceListEntry.Flink;

                irp = (queueAddress - IrpOffset);

                dprintf("%08p%s",
                        irp,
                        (i & 0x03) == 0x03 ? "\n\t     " : " ");
                if (CheckControlC()) {
                    break;
                }
            }
            dprintf("\n");
        }
    } else {
        dprintf("Device queue is not busy.\n");
    }

    dprintf("Device Object Extension: %08p:\n", DeviceObjectExtension);
    if (GetFieldValue(DeviceObjectExtension,
                      "nt!_DEVOBJ_EXTENSION",
                      "PowerFlags",
                      Flags)) {
        dprintf("Could not read Device Object Extension %p\n", DeviceObjectExtension);
        return;
    }
    dprintf("PowerFlags: %08lx =>", Flags);

#define PopGetDoSystemPowerState(Flags) \
    (Flags & POPF_SYSTEM_STATE)

#define PopGetDoDevicePowerState(Flags) \
    ((Flags & POPF_DEVICE_STATE) >> 4)


    dprintf("SystemState=%1x", PopGetDoSystemPowerState(Flags) );
    dprintf(" DeviceState=%lx", PopGetDoDevicePowerState(Flags) );
    if (Flags & POPF_SYSTEM_ACTIVE) dprintf(" syact");
    if (Flags & POPF_SYSTEM_PENDING) dprintf(" sypnd");
    if (Flags & POPF_DEVICE_ACTIVE) dprintf(" dvact");
    if (Flags & POPF_DEVICE_PENDING) dprintf(" dvpnd");

    GetFieldValue(DeviceObjectExtension,"nt!_DEVOBJ_EXTENSION","Dope",Dope);
    dprintf("\nDope: %08lx:\n", Dope);
    if (Dope != 0) {
        rmr = GetFieldValue(Dope, "nt!_DEVICE_OBJECT_POWER_EXTENSION",
                            "DeviceType", Type);
        if (!rmr) {
            InitTypeRead(Dope, nt!_DEVICE_OBJECT_POWER_EXTENSION);

            dprintf("IdleCount: %08p  ConIdlTime: %08p  PerfIdlTime: %08p\n",
                ReadField(IdleCount), ReadField(ConservationIdleTime), ReadField(PerformanceIdleTime));
            dprintf("NotifySourceList fl:%08p bl:%08p\n",
                ReadField(NotifySourceList.Flink), ReadField(NotifySourceList.Blink));
            dprintf("NotifyTargetList fl:%08p bl:%08p\n",
                ReadField(NotifyTargetList.Flink), ReadField(NotifyTargetList.Blink));
            dprintf("PowerChannelSummary TotalCount: %08p  D0Count: %08p\n",
                ReadField(PowerChannelSummary.TotalCount), ReadField(PowerChannelSummary.D0Count));

            dprintf("PowerChannelSummary NotifyList fl:%08p bl:%08p\n",
                ReadField(PowerChannelSummary.NotifyList.Flink),
                ReadField(PowerChannelSummary.NotifyList.Blink)
                );
        }
    }
    return;
}


VOID
poDumpList(
    ULONG64 DeviceAddress
    );


DECLARE_API( polist )
/*++

Routine Description:

    Dump the irp serial list, unless a devobj address is given,
    in which case dump the irps in the serial list that point to
    that device object

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64 deviceToDump;

    deviceToDump = 0;
    deviceToDump = GetExpression(args);
    if (deviceToDump == 0) {
        dprintf("All entries in Power Irp Serial List\n");
    } else {
        dprintf("Entries in Power Irp Serial List for: %08p:\n", deviceToDump);
    }
    if (!IsPtr64()) {
        deviceToDump = (ULONG64) (LONG64) (LONG) deviceToDump;
    }
    poDumpList(deviceToDump);
    return S_OK;
}


VOID
poDumpList(
    ULONG64 DeviceAddress
    )

/*++

Routine Description:

Arguments:

    DeviceAddress - address of device object to dump.

Return Value:

    None

--*/

{
    ULONG64 listhead, irpa, iosla, p;
    ULONG   isll, result;
    ULONG   IrpOffset;

    isll = GetUlongValue("nt!PopIrpSerialListLength");
    dprintf("PopIrpSerialListLength = %d\n", isll);

    listhead = GetExpression("nt!PopIrpSerialList");
    GetFieldOffset("nt!_IRP", "Tail.Overlay.DeviceQueueEntry", &IrpOffset);

    for (p = GetPointerFromAddress( listhead );
         (p != listhead) && p;
         p = GetPointerFromAddress( p))
    {
        ULONG64 DeviceObject, CurrentStackLocation;
        irpa =  p - IrpOffset;

        if (GetFieldValue(irpa, "nt!_IRP", "Tail.Overlay.CurrentStackLocation", CurrentStackLocation))
        {
            dprintf("Cannot read Irp: %08p\n", irpa);
            return;
        }

        iosla = CurrentStackLocation + DBG_PTR_SIZE;

        if (GetFieldValue(iosla, "nt!_IO_STACK_LOCATION", "DeviceObject", DeviceObject) )
        {
            dprintf("Cannot read Io Stk Loc: %08p\n", iosla);
            return;
        }

        InitTypeRead(iosla, nt!_IO_STACK_LOCATION);
        if ((DeviceAddress == 0) || (DeviceAddress == DeviceObject)) {
            dprintf("Irp:%08p DevObj:%08p ", irpa, DeviceObject);
            dprintf("Ctx:%08p ", ReadField(Parameters.Power.SystemContext));
            if (ReadField(Parameters.Power.SystemContext) & POP_INRUSH_CONTEXT) {
                dprintf("inrush ");
            } else {
                dprintf("       ");
            }

            if (ReadField(Parameters.Power.Type) == SystemPowerState) {
                dprintf("sysirp ");
                dprintf("S%d\n", (LONG)(ReadField(Parameters.Power.State.SystemState)) - (LONG)PowerSystemWorking);
            } else {
                dprintf("devirp ");
                dprintf("D%d\n", (LONG)(ReadField(Parameters.Power.State.DeviceState)) - (LONG)PowerDeviceD0);
            }
        }
        if (CheckControlC())
        {
            break;
        }
    }
    return;
}


VOID
poDumpRequestedList(
    ULONG64 DeviceAddress
    );


DECLARE_API( poreqlist )
/*++

Routine Description:

    Dump the irp serial list, unless a devobj address is given,
    in which case dump the irps in the serial list that point to
    that device object

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64 deviceToDump;

    deviceToDump = GetExpression(args);
    if (deviceToDump == 0) {
        dprintf("All active Power Irps from PoRequestPowerIrp\n");
    } else {
        dprintf("Active Power Irps from PoRequestPowerIrp for: %08p:\n",
                deviceToDump);
    }
    poDumpRequestedList(deviceToDump);

    return S_OK;
}

VOID
poDumpRequestedList (
    ULONG64 DeviceAddress
    )
/*++

Routine Description:

    Dump PopRequestedIrps List, "A list of all the power irps created from
    PoReqestPowerIrp.

Arguments:

    DeviceAddress - optional address to which requested power IRPs were sent

--*/
{
    BOOL    blocked = FALSE;
    ULONG64 listhead;
    ULONG64 p, spAddr, irpAddr;
    ULONG   result;
    ULONG   Off;

    dprintf("PopReqestedPowerIrpList\n");

    listhead = GetExpression("nt!PopRequestedIrps");

    GetFieldOffset("nt!_IO_STACK_LOCATION", "Parameters.Others.Argument1", &Off);
    dprintf("FieldOffset = %p\n",Off);
    for (p = GetPointerFromAddress( listhead );
         p != listhead;
         p = GetPointerFromAddress( p ))
    {
        ULONG64 CurrentStackLocation;
        ULONG MajorFunction;

        //
        // Reguested list is a double list of stack locations
        //
        spAddr = p - Off;
        if (GetFieldValue(spAddr, "nt!_IO_STACK_LOCATION",
                          "Parameters.Others.Argument3", irpAddr)) {

            dprintf("Cannot read 1st stack Location: %08p\n", spAddr);
            return;
        }

        //
        // The 3rd argument of which has the pointer to the irp itself
        //
        if (GetFieldValue(irpAddr, "nt!_IRP", "Tail.Overlay.CurrentStackLocation", CurrentStackLocation))
        {
            dprintf("Cannot read Irp: %08p\n", irpAddr);
            return;
        }
        dprintf ("Irp %08p ", irpAddr);

        //
        // Assume the if the IRP is in this list that it has a valid
        // current stack location
        //
        spAddr = CurrentStackLocation;

        if (GetFieldValue(spAddr, "nt!_IO_STACK_LOCATION", "MajorFunction", MajorFunction) )
        {
            dprintf("Cannot read current stack location: %08p\n", spAddr);
            return;
        }

        //
        // Check to see if the irp is blocked
        //
        blocked = FALSE;
        if (MajorFunction != IRP_MJ_POWER) {

            //
            // Irp is blocked. The next stack location is the real one
            //
            blocked = TRUE;
            spAddr = CurrentStackLocation + DBG_PTR_SIZE;
            if (GetFieldValue(spAddr, "nt!_IO_STACK_LOCATION", "MajorFunction", MajorFunction) )
            {
                dprintf("Cannot read current stack location: %08p\n", spAddr);
                return;
            }

        }

        if ((DeviceAddress == 0) || (DeviceAddress == ReadField(DeviceObject))) {

            ULONG   MinorFunction = 0;
            ULONG64 DeviceObject = 0;
            ULONG64 SystemContext = 0;
            ULONG64 Temp = 0;
            UCHAR   IOStack[] = "nt!_IO_STACK_LOCATION";

            GetFieldValue(spAddr,IOStack, "DeviceObject", DeviceObject);
            GetFieldValue(spAddr,IOStack, "Parameters.Power.SystemContext", SystemContext);
            GetFieldValue(spAddr,IOStack, "MinorFunction", MinorFunction);

            dprintf("DevObj %08p", DeviceObject);
            DumpDevice(DeviceObject,0, FALSE);
            dprintf(" Ctx %08p ", SystemContext);
            if ((SystemContext & POP_INRUSH_CONTEXT) == POP_INRUSH_CONTEXT) {

                dprintf("* ");
            } else {
                dprintf("  ");
            }

            switch (MinorFunction) {
            case IRP_MN_QUERY_POWER:
                dprintf ("Query Power ");
                goto PoDumpRequestedListPowerPrint;
            case IRP_MN_SET_POWER:
                dprintf ("Set Power ");
PoDumpRequestedListPowerPrint:
                GetFieldValue(spAddr, IOStack, "Parameters.Power.Type",Temp);
                if ((ULONG) Temp == SystemPowerState) {
                    GetFieldValue(spAddr, IOStack, "Parameters.Power.State.SystemState", Temp);
                    dprintf("S%d ", (LONG)Temp - (LONG)PowerSystemWorking);
                } else {
                    GetFieldValue(spAddr, IOStack, "Parameters.Power.State.DeviceState", Temp);
                    dprintf("D%d ", (LONG)Temp - (LONG)PowerDeviceD0);
                }
                GetFieldValue(spAddr,IOStack,"Parameters.Power.ShutdownType", Temp);
                dprintf ("ShutdownType %x", (LONG) Temp);
                break;

            case IRP_MN_WAIT_WAKE:
                GetFieldValue(spAddr, IOStack, "Parameters.WaitWake.PowerState", Temp);
                dprintf ("Wait Wake S%d", (LONG)Temp - (LONG)PowerSystemWorking);
                break;

            case IRP_MN_POWER_SEQUENCE:
                dprintf ("Power Sequence Irp");
                break;
            }
            if (blocked) {

                dprintf(" [blocked]");

            }
            dprintf("\n");
        }
    }
    return;
}

VOID poDumpNodePower();

DECLARE_API( ponode )
/*++

Routine Description:

    If an argument is present, dump the devnode list in pnp order.
    (used only for testing)

    Otherwise dump the devnode inverted stack.
    (po enumeration order)

Arguments:

    args - flag

Return Value:

    None

--*/

{
    ULONG flag;

    dprintf("Dump Inverted DevNode Tree (power order)\n");
    poDumpNodePower();
    return S_OK;
}

VOID
poDumpNodePower(
    )
/*++

Routine Description:

    Dump the devnode tree in power order.

Arguments:

Return Value:

    None

--*/
{
#if 0
    LONG    level, SizeOfLE, LevelOff, pdo_off;
    ULONG64 parray, listhead, effaddr, pdo, devNodeAddr, limit;

    level = GetUlongValue("nt!IopMaxDeviceNodeLevel");
    parray = GetExpression("nt!IopDeviceNodeStack");

    dprintf("Max level = %5d\n", level);
    dprintf("IopDeviceNodeStack %08p\n", parray);
    parray = GetPointerFromAddress(parray);
    dprintf("*IopDeviceNodeStack %08p\n", parray);

    dprintf("Level  ListHead  DevNode   PDO\n");
    dprintf("-----  --------  --------  --------\n");

    SizeOfLE = GetTypeSize("nt!_LIST_ENTRY");
    GetFieldOffset("nt!_DEVICE_NODE", "LevelList", &LevelOff);
    GetFieldOffset("nt!_DEVICE_NODE", "PhysicalDeviceObject", &pdo_off);
    for ( ; level >= 0; level--) {

        effaddr = (level * SizeOfLE) + parray;
        listhead = GetPointerFromAddress( effaddr);

        dprintf("%5d  %08lx\n", level, listhead);

        if (listhead) {

            limit = 0;
            for (effaddr = GetPointerFromAddress(listhead);
                 effaddr != listhead;
                 effaddr = GetPointerFromAddress(effaddr))
            {
                devNodeAddr = (effaddr - LevelOff);

                pdo = GetPointerFromAddress((devNodeAddr+pdo_off));

                dprintf("                 %08p  %08p  ", devNodeAddr, pdo);
                popDumpDeviceName(pdo);
                dprintf("\n");
            }
        }
    }
#endif
}


VOID
popDumpDeviceName(
    ULONG64  DeviceAddress
    )
{
    ULONG                      result;


    PUCHAR                     buffer;
    UNICODE_STRING             unicodeString;
    ULONG64                    pObjectHeader;
    ULONG64                    pNameInfo;
    ULONG                      Type;
    ULONG                      Flags;
    ULONG64                    Temp;
    USHORT                     Length;


    if (GetFieldValue(DeviceAddress, "nt!_DEVICE_OBJECT", "Type", Type)) {
        dprintf("%08p: Could not read device object\n", DeviceAddress);
        return;
    }

    if (Type != IO_TYPE_DEVICE) {
        dprintf("%08p: is not a device object\n", DeviceAddress);
        return;
    }

    //
    // Dump the device name if present.
    //

    pObjectHeader = KD_OBJECT_TO_OBJECT_HEADER(DeviceAddress);
    if (GetFieldValue(pObjectHeader, "nt!_OBJECT_HEADER", "Type", Temp)) {
        ULONG64 pName;

        KD_OBJECT_HEADER_TO_NAME_INFO( pObjectHeader, &pNameInfo );
        if (GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO",
                          "Name.Length",
                          Length)) {
            if (Length > 0x1000) // sanity check
            {
                Length = 0x1000;
            }
            buffer = LocalAlloc(LPTR, Length);
            if (buffer != NULL) {
                unicodeString.MaximumLength = Length;
                unicodeString.Length = Length;
                unicodeString.Buffer = (PWSTR)buffer;
                GetFieldValue(pNameInfo,
                              "nt!_OBJECT_HEADER_NAME_INFO",
                              "Name.Buffer",
                              pName);
                if (ReadMemory(pName,
                               buffer,
                               unicodeString.Length,
                               &result) && (result == unicodeString.Length)) {
                    unicodeString.Buffer[(unicodeString.Length/sizeof(WCHAR))-1] = 0;
                    dprintf(" %wZ", &unicodeString);
                }
                LocalFree(buffer);
            }
        }
    }
    return;
}

PUCHAR
PowerAction(
    IN POWER_ACTION     Action
    )
{
    switch (Action) {
        case PowerActionNone:           return "None";
        case PowerActionReserved:       return "Reserved";
        case PowerActionSleep:          return "Sleep";
        case PowerActionHibernate:      return "Hibernate";
        case PowerActionShutdown:       return "Shutdown";
        case PowerActionShutdownReset:  return "ShutdownReset";
        case PowerActionShutdownOff:    return "ShutdownOff";
        case PowerActionWarmEject:      return "WarmEject";
    }

    return "???";
}

PUCHAR
SystemState(
    SYSTEM_POWER_STATE  State
    )
{
    switch (State) {
        case PowerSystemUnspecified:    return "Unspecified";
        case PowerSystemWorking:        return "Working";
        case PowerSystemSleeping1:      return "Sleeping1";
        case PowerSystemSleeping2:      return "Sleeping2";
        case PowerSystemSleeping3:      return "Sleeping3";
        case PowerSystemHibernate:      return "Hibernate";
        case PowerSystemShutdown:       return "Shutdown";
    }

    sprintf (Buffer, "State=%x", State);
    return Buffer;
}

PUCHAR
PoIrpMinor (
    UCHAR   IrpMinor
    )
{
    switch (IrpMinor) {
        case IRP_MN_QUERY_POWER:    return "QueryPower";
        case IRP_MN_SET_POWER:      return "SetPower";
    }

    return "??";
}



PUCHAR
TF (
    BOOLEAN Flag
    )
{
    switch (Flag) {
        case TRUE:    return "TRUE";
        case FALSE:   return "FALSE";
    }

    sprintf (Buffer, "%x", Flag);
    return Buffer;
}




PWCHAR
DumpDoName (
    IN ULONG64  Str
    )
{
    static  WCHAR   Name[50];

    memset (Name, 0, sizeof(Name));
    ReadMemory (Str, Name, sizeof(Name), NULL);
    Name[sizeof(Name)-1] = 0;
    return Name;
}

PUCHAR
DumpQueueHead (
    IN ULONG64  StrucAddr,
    IN ULONG64  Struc,
    IN ULONG    Offset
    )
{
    ULONG64     Head, Flink, Blink;
    ULONG64     Va;

    Head = Struc + Offset;
    Va   = StrucAddr + Offset;

    GetFieldValue(Head, "nt!_LIST_ENTRY", "Flink", Flink);
    GetFieldValue(Head, "nt!_LIST_ENTRY", "Blink", Blink);
    if (Flink == Va  &&  Blink == Va) {
        sprintf (Buffer, "Head:%08I64lx Empty", UNEXTEND64(Va));
    } else {
        sprintf (Buffer, "Head:%08I64lx F:%08I64lx B:%08I64lx", UNEXTEND64(Va), UNEXTEND64(Flink), UNEXTEND64(Blink));
    }

    return Buffer;
}


VOID
DumpDevicePowerIrp (
    IN PUCHAR  Desc,
    IN ULONG64 StrucAddr,
    IN ULONG64 Head,
    IN ULONG   Offset
    )
{
    ULONG64               Va;
    ULONG64               Link;
    ULONG64               Addr;
    ULONG       Off;

    GetFieldOffset("nt!_POP_DEVICE_SYS_STATE", "Head", &Off);
    Va = (StrucAddr + Off + Offset);
    Link = GetPointerFromAddress(Head + Offset);

    if (Link == Va) {
        return ;
    }

    dprintf ("\n%s:\n", Desc);

    while (Link != Va) {
        ULONG64 Irp, Notify;

        Addr = Link - Offset;
        if (GetFieldValue(Addr, "nt!_POP_DEVICE_POWER_IRP", "Irp", Irp)) {
            dprintf ("Could not power irp\n");
            break;
        }
        GetFieldValue(Addr, "nt!_POP_DEVICE_SYS_STATE", "Notify", Notify);
        dprintf ("  Irp: %08p  Notify %08p\n", Irp, Notify);

        Link = GetPointerFromAddress(Addr + Offset);
    }
}

VOID
poDumpOldNotifyList(
    VOID
    )
{
    BOOLEAN             GdiOff;
    UCHAR               LastOrder;
    ULONG               PartOffset, NoLists, SizeOfLE, Off, HeadOff;
    ULONG64             DevState, Notify;
    LONG                i;
    ULONG64             ListHead;
    ULONG64             Link;

    dprintf("  NoLists........: %p\n",   (NoLists = (ULONG) ReadField(Order.NoLists)));
    SizeOfLE = GetTypeSize("nt!_LIST_ENTRY");
    GdiOff = FALSE;
    LastOrder = 0xff;
    Notify = ReadField(Order.Notify);
    for (i=NoLists-1; i >= 0; i--) {
        ListHead = Notify + i*SizeOfLE;
        if (GetFieldValue(ListHead, "nt!_LIST_ENTRY", "Flink", Link)) {
            dprintf ("Could not read list head\n");
            break;
        }

        while (Link != ListHead) {
            UCHAR OrderLevel;

            if (GetFieldValue(Link, "nt!_PO_DEVICE_NOTIFY", "OrderLevel", OrderLevel)) {
                dprintf ("Could not read link\n");
                break;
            }

            if (LastOrder != OrderLevel) {
                LastOrder = OrderLevel;
                dprintf ("     %x   %s",
                    LastOrder,
                    LastOrder <= PO_ORDER_MAXIMUM ? rgPowerNotifyOrder[LastOrder] : ""
                    );

                if (!GdiOff && OrderLevel <= PO_ORDER_GDI_NOTIFICATION) {
                    GdiOff = TRUE;
                    dprintf (", GdiOff\n");
                } else {
                    dprintf ("\n");
                }
            }

            InitTypeRead(Link, nt!_PO_DEVICE_NOTIFY);
            dprintf ("  %02x %x:%x %08x %c",
                i,
                OrderLevel,
                (ULONG) ReadField(NodeLevel),
                Link,
                ((UCHAR) ReadField(WakeNeeded) ? 'w' : ' ')
                );

            dprintf (" %ws\t", DumpDoName (ReadField(DriverName)));
            dprintf (" %ws\n", DumpDoName (ReadField(DeviceName)));

            Link = ReadField(Link.Flink);

            if (CheckControlC()) {
                return;
            }
        }
    }
}

ULONG
DumpNotifyCallback(
    PFIELD_INFO pAddrInfo,
    PVOID Context
    )
{
    if (CheckControlC()) {return 0;}

    InitTypeRead(pAddrInfo->address, nt!_PO_DEVICE_NOTIFY);
    dprintf("   %c %08p: %08p %ws\t",
            ReadField(WakeNeeded) ? 'w' : ' ',
            pAddrInfo->address,
            ReadField(Node),
            DumpDoName(ReadField(DriverName)));
    dprintf("%ws\n",DumpDoName(ReadField(DeviceName)));
            
    return(0);
}

VOID
poDumpNewNotifyList(
    IN ULONG64 DevState
    )
{
    BOOLEAN             GdiOff;
    UCHAR               LastOrder;
    ULONG               PartOffset, NoLists, SizeOfLE, Off, HeadOff;
    ULONG64             Level, Notify;
    LONG                i,j;
    ULONG64             ListHead;
    ULONG64             Link;
    ULONG               LevelOffset;
    ULONG               SizeOfLevel;
    CHAR                FlinkBuff[32];
    PCHAR               NotifyList[] = {"WaitSleep",
                                        "ReadySleep",
                                        "Pending",  
                                        "Complete", 
                                        "ReadyS0",  
                                        "WaitS0"};

    SizeOfLevel = GetTypeSize("nt!_PO_NOTIFY_ORDER_LEVEL");
    GdiOff = FALSE;
    if (GetFieldOffset("nt!_POP_DEVICE_SYS_STATE",
                       "Order.OrderLevel",
                       &LevelOffset)) {
        dprintf("Couldn't get field offset for Order.OrderLevel.");
        return;
    }
    for (i=PO_ORDER_MAXIMUM;i>=0;i--) {
        if (CheckControlC()) {return;}
        Level = DevState + LevelOffset + i*SizeOfLevel;
        InitTypeRead(Level, nt!_PO_NOTIFY_ORDER_LEVEL);
        if (ReadField(DeviceCount)) {
            dprintf("Level %d (%08p) %d/%d\t%s\n",
                    i,
                    Level,
                    (ULONG)ReadField(ActiveCount),
                    (ULONG)ReadField(DeviceCount),
                    rgPowerNotifyOrder[i]);

            for (j=0;j<sizeof(NotifyList)/sizeof(PCHAR);j++) {
                if (CheckControlC()) {return;}
                sprintf(FlinkBuff, "%s.Flink",NotifyList[j]);
                if (GetFieldValue(Level,
                                  "nt!_PO_NOTIFY_ORDER_LEVEL",
                                  FlinkBuff,
                                  Link)) {
                    dprintf("couldn't get field value for PO_NOTIFY_ORDER_LEVEL.%s\n",FlinkBuff);
                    return;
                }
                if (Link != GetAddress(Level, "nt!_PO_NOTIFY_ORDER_LEVEL", FlinkBuff)) {
                    dprintf("  %s:\n",NotifyList[j]);
                    ListType("_PO_DEVICE_NOTIFY",
                             Link,
                             1,
                             "Link.Flink",
                             NULL,
                             DumpNotifyCallback);
                }
            }
        }
    }
}

VOID
PoDevState (
    VOID
    )
/*++

Routine Description:

    Dumps the current power action structure

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64             addr;
    LONG                i;
    ULONG64             ListHead;
    ULONG64             Link;
    ULONG64             DevState, Notify;
    BOOLEAN             GdiOff;
    UCHAR               IrpMinor;
    ULONG               PartOffset, NoLists, SizeOfLE, Off, HeadOff;

    addr = GetExpression( "nt!PopAction" );
    if (!addr) {
        dprintf("Error retrieving address of PopAction\n");
        return;
    }

    if (GetFieldValue(addr, "nt!POP_POWER_ACTION", "DevState", DevState)) {
        dprintf("Error reading PopAction\n");
        return;
    }

    if (!DevState) {
        dprintf("No Device State allocated on PopAction\n");
        return;
    }

    if (GetFieldValue(DevState, "nt!_POP_DEVICE_SYS_STATE", "IrpMinor", IrpMinor)) {
        dprintf("Error reading device state structure\n");
        return;
    }

    GetFieldOffset("nt!_POP_DEVICE_SYS_STATE","PresentIrpQueue", &Off);
    InitTypeRead(DevState, nt!_POP_DEVICE_SYS_STATE);
    dprintf ("PopAction.DevState %08x\n", DevState);
    dprintf("  Irp minor......: %s\n",   PoIrpMinor (IrpMinor));
    dprintf("  System State...: %s\n",   SystemState((ULONG) ReadField(SystemState)));
    dprintf("  Worker thread..: %08p\n", ReadField(Thread));
    dprintf("  Status.........: %x\n",   (ULONG) ReadField(Status));
    dprintf("  Waking.........: %s\n",   TF (((UCHAR) ReadField(Waking))) );
    dprintf("  Cancelled......: %s\n",   TF (((UCHAR) ReadField(Cancelled))) );
    dprintf("  Ignore errors..: %s\n",   TF (((UCHAR) ReadField(IgnoreErrors))) );
    dprintf("  Ignore not imp.: %s\n",   TF (((UCHAR) ReadField(IgnoreNotImplemented))) );
    dprintf("  Wait any.......: %s\n",   TF (((UCHAR) ReadField(WaitAny))) );
    dprintf("  Wait all.......: %s\n",   TF (((UCHAR) ReadField(WaitAll))) );
    dprintf("  Present Irp Q..: %s\n",
        DumpQueueHead (DevState, DevState, Off)
        );

    dprintf("\n");
    dprintf("Order:\n");
    dprintf("  DevNode Seq....: %x\n",   (ULONG) ReadField(Order.DevNodeSequence));
    if (ReadField(Order.NoLists)) {
        poDumpOldNotifyList();
    } else {
        poDumpNewNotifyList(DevState);
    }

    //
    // Dump device notification list order
    //


    //
    // Dump device power irps
    //


    GetFieldOffset("nt!_POP_DEVICE_SYS_STATE","Head", &HeadOff);
    GetFieldOffset("nt!_POP_DEVICE_POWER_IRP", "Pending", &Off);
    DumpDevicePowerIrp ("Pending irps",   DevState, DevState+HeadOff, Off);
    GetFieldOffset("nt!_POP_DEVICE_POWER_IRP", "Complete", &Off);
    DumpDevicePowerIrp ("Completed irps", DevState, DevState+HeadOff, Off);
    GetFieldOffset("nt!_POP_DEVICE_POWER_IRP", "Abort", &Off);
    DumpDevicePowerIrp ("Abort irps",     DevState, DevState+HeadOff, Off);
    GetFieldOffset("nt!_POP_DEVICE_POWER_IRP", "Failed", &Off);
    DumpDevicePowerIrp ("Failed irps",    DevState, DevState+HeadOff, Off);
    dprintf("\n");
}


DECLARE_API( poaction )
/*++

Routine Description:

    Dumps the current power action structure

Arguments:

    args - the location of the device object of interest

Return Value:

    None

--*/

{
    ULONG64                 addr;
    ULONG                   i;
    UCHAR                   c, State, Updates;
    ULONG                   Flags;

    addr = GetExpression( "nt!PopAction" );
    if (!addr) {
        dprintf("Error retrieving address of PopAction\n");
        return E_INVALIDARG;
    }

    if (GetFieldValue(addr, "nt!POP_POWER_ACTION", "State", State)) {
        dprintf("Error reading PopAction\n");
        return E_INVALIDARG;
    }

    InitTypeRead(addr, nt!POP_POWER_ACTION);
    dprintf("PopAction: %08x\n", addr);

    dprintf("  State..........: %x ",  State);
    switch (State) {
        case PO_ACT_IDLE:               dprintf ("- Idle\n");             break;
        case PO_ACT_NEW_REQUEST:        dprintf ("- New request\n");      break;
        case PO_ACT_CALLOUT:            dprintf ("- Winlogon callout\n"); break;
        case PO_ACT_SET_SYSTEM_STATE:   dprintf ("- Set System State\n"); break;
        default:                        dprintf ("\n"); break;
    }

    dprintf("  Updates........: %x ",  (Updates = (UCHAR) ReadField(Updates)));
    if (Updates & PO_PM_USER)        dprintf(" user ");
    if (Updates & PO_PM_REISSUE)     dprintf(" reissue ");
    if (Updates & PO_PM_SETSTATE)    dprintf(" setstate ");
    if (ReadField(Shutdown))                    dprintf(" SHUTDOWN-set ");
    dprintf("\n");

    dprintf("  Action.........: %s\n", PowerAction((ULONG) ReadField(Action)));
    dprintf("  Lightest State.: %s\n", SystemState((ULONG) ReadField(LightestState)));
    dprintf("  Flags..........: %x", (Flags = (ULONG) ReadField(Flags)));

    c = ' ';
    for (i=0; ActFlags[i].Flags; i++) {
        if (Flags & ActFlags[i].Flags) {
            dprintf ("%c%s", c, ActFlags[i].String);
            c = '|';
        }
    }
    dprintf("\n");

    dprintf("  Irp minor......: %s\n", PoIrpMinor ((UCHAR)ReadField(IrpMinor)));
    dprintf("  System State...: %s\n", SystemState((ULONG) ReadField(SystemState)));
    dprintf("  Hiber Context..: %08p\n", ReadField(HiberContext));

    if (ReadField(DevState)) {
        dprintf ("\n");
        PoDevState ();
    }

    dprintf("\n");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
// This is a 64 bit aware debugger extension
#define KDEXT_64BIT
#include <wdbgexts.h>


#include <dbgeng.h>

#include "extsfns.h"
#include "session.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#ifndef EXTENSION_API
#define EXTENSION_API( name )  \
HRESULT _EFN_##name
#endif // EXTENSION_API

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL2       g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS2       g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

extern ULONG64  STeip;
extern ULONG64  STebp;
extern ULONG64  STesp;
extern ULONG64  EXPRLastDump;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

#ifdef DEFINE_GUID
#undef DEFINE_GUID
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

//
// Flag definitions used by extensions
//
#include "extflags.h"


#define ADDRESS_NOT_VALID 0
#define ADDRESS_VALID 1
#define ADDRESS_TRANSITION 2


//#define POOL_TYPE_AND_QUOTA_MASK (15)



#define MAXULONG64_PTR (~((ULONG64)0))
#define MAXLONG64_PTR  ((LONG64)(MAXULONG64_PTR >> 1))
#define MINLONG64_PTR  (~MAXLONG64_PTR)

#define POOL_BIG_TABLE_ENTRY_FREE   0x1

//
// macros to crack the ControllerId field of the socket info structure
//
#define PcmciaClassFromControllerType(type) (((type) & 0xff))
#define PcmciaModelFromControllerType(type) (((type) >> 8) & 0x3ffff)
#define PcmciaRevisionFromControllerType(type) ((type) >> 26)

#ifdef PAGE_SIZE
#undef PAGE_SIZE
#endif

#define DBG_PTR_SIZE      (IsPtr64() ? 8 : 4)
#define UNEXTEND64(p)    (IsPtr64() ? p : (ULONG64) (ULONG) p)

extern ULONG PageSize;
extern ULONG PageShift;
extern ULONG BuildNo;
extern ULONG PoolBlockShift;
extern BOOL  NewPool;
#define _KB (PageSize/1024)

#define POOL_BLOCK_SHIFT_OLD ((PageSize == 0x4000)  ? 6 : (((PageSize == 0x2000) || ((BuildNo < 2257) && (PageSize == 0x1000))) ? 5 : 4))
#define POOL_BLOCK_SHIFT_LAB1_2402 ((PageSize == 0x4000)  ? 5 : (((PageSize == 0x2000)) ? 4 : (IsPtr64() ? 4 : 3)))

#define POOL_BLOCK_SHIFT   PoolBlockShift

#define PAGE_ALIGN64(Va) ((ULONG64)((Va) & ~((ULONG64) (PageSize - 1))))

#define GetBits(from, pos, num)  ((from >> pos) & (((ULONG64) ~0) >> (sizeof(ULONG64)*8 - num)))


extern ULONG64 PaeEnabled;
extern ULONG TargetMachine;
extern ULONG TargetIsDump;
extern BOOL  IsLocalKd;

typedef struct _MMPFNENTRY {
    ULONG Modified : 1;
    ULONG ReadInProgress : 1;
    ULONG WriteInProgress : 1;
    ULONG PrototypePte: 1;
    ULONG PageColor : 3;
    ULONG ParityError : 1;
    ULONG PageLocation : 3;
    ULONG RemovalRequested : 1;
    ULONG CacheAttribute : 2;
    ULONG Rom : 1;
    ULONG LockCharged : 1;
    ULONG DontUse : 16; //overlays USHORT for reference count field.
} MMPFNENTRY;


typedef struct {
    BOOL    Valid;
    CHAR    Type[MAX_PATH];
    ULONG64 Module;
    ULONG   TypeId;
    ULONG   Size;
} CachedType;

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;

__inline
ULONG64
KD_OBJECT_TO_OBJECT_HEADER(
    ULONG64  o
    )
{
    static ULONG Off=0, GotOff=0;
    if (!GotOff &&
        !GetFieldOffset("nt!_OBJECT_HEADER", "Body", &Off)) {
        GotOff = TRUE;
    } else if (!GotOff){
        return 0;
    }
    return o - Off;
}

__inline
ULONG64
KD_OBJECT_HEADER_TO_OBJECT(
    ULONG64  o
    )
{
    static ULONG Off=0, GotOff=0;
    if (!GotOff &&
        !GetFieldOffset("nt!_OBJECT_HEADER", "Body", &Off)) {
        GotOff = TRUE;
    } else if (!GotOff){
        return 0;
    }
    return o + Off;
}

__inline
VOID
KD_OBJECT_HEADER_TO_QUOTA_INFO(
    ULONG64 oh,
    PULONG64 pOutH
    )
{
    ULONG QuotaInfoOffset=0;
    GetFieldValue(oh, "nt!_OBJECT_HEADER", "QuotaInfoOffset", QuotaInfoOffset);
    *pOutH = (QuotaInfoOffset == 0 ? 0 : ((oh) - QuotaInfoOffset));
}


__inline
VOID
KD_OBJECT_HEADER_TO_HANDLE_INFO (
    ULONG64 oh,
    PULONG64 pOutH
    )
{
    ULONG HandleInfoOffset=0;
    GetFieldValue(oh, "nt!_OBJECT_HEADER", "HandleInfoOffset", HandleInfoOffset);
    *pOutH = (HandleInfoOffset == 0 ? 0 : ((oh) - HandleInfoOffset));
}

__inline
VOID
KD_OBJECT_HEADER_TO_NAME_INFO(
    ULONG64  oh,
    PULONG64 pOutH
    )
{
    ULONG NameInfoOffset=0;
    GetFieldValue(oh, "nt!_OBJECT_HEADER", "NameInfoOffset", NameInfoOffset);
    *pOutH = (NameInfoOffset == 0 ? 0 : ((oh) - NameInfoOffset));
}

__inline
VOID
KD_OBJECT_HEADER_TO_CREATOR_INFO(
    ULONG64  oh,
    PULONG64 pOutH
    )
{
    ULONG Flags=0;
    GetFieldValue(oh, "_OBJECT_HEADER", "Flags", Flags);
    *pOutH = ((Flags & OB_FLAG_CREATOR_INFO) == 0 ? 0 : ((oh) - GetTypeSize("_OBJECT_HEADER_CREATOR_INFO")));
}



//-----------------------------------------------------------------------------------------
//
//  prototypes for internal non-exported support functions
//
//-----------------------------------------------------------------------------------------

//
// get data from DebuggerData or GetExpression as appropriate
//

char ___SillyString[];
extern KDDEBUGGER_DATA64 KdDebuggerData;

#define GetNtDebuggerData(NAME)                                      \
     (HaveDebuggerData()? (GetDebuggerData(KDBG_TAG,                 \
                                           &KdDebuggerData,          \
                                           sizeof(KdDebuggerData)),  \
                           KdDebuggerData.NAME):                     \
                         GetExpression( "nt!" #NAME ))

#define GetNtDebuggerDataValue(NAME)                                     \
    (HaveDebuggerData()?                                                 \
        GetUlongFromAddress((GetDebuggerData(KDBG_TAG,                   \
                                             &KdDebuggerData,            \
                                             sizeof(KdDebuggerData)),    \
                             KdDebuggerData.NAME)                        \
                            ):                                           \
        GetUlongValue( "nt!" #NAME ))


//
// This is used to read pointer values from address.
//

#define GetNtDebuggerDataPtrValue(NAME)                                     \
    (HaveDebuggerData()?                                                 \
        GetPointerFromAddress((GetDebuggerData(KDBG_TAG,                   \
                                             &KdDebuggerData,            \
                                             sizeof(KdDebuggerData)),    \
                             KdDebuggerData.NAME)                        \
                            ):                                           \
        GetPointerValue( "nt!" #NAME ))

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;


extern BOOL
HaveDebuggerData(
    VOID
    );

BOOL
ReadPcr(
    USHORT  Processor,
    PVOID   Pcr,
    PULONG  AddressOfPcr,
    HANDLE  hThread
    );

ULONG
GetUlongFromAddress (
    ULONG64 Location
    );

BYTE
GetByteFromAddress (
    ULONG64 Location
    );

ULONG
GetUlongValue (
    PCHAR String
    );

BYTE
GetByteValue (
    PCHAR String
    );

ULONG64
GetGlobalFromAddress (
    ULONG64 Location,
    ULONG   Size
    );

ULONG64
GetGlobalValue (
    PCHAR  String
    );

HRESULT
GetGlobalEx(
    PCHAR String,
    PVOID OutValue,
    ULONG OutSize
    );

#define GetGlobal( _String, _OutValue ) \
    GetGlobalEx( (_String), &(_OutValue), sizeof(_OutValue) )

BOOLEAN
ReadMemoryUncached (
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesRead
    );

BOOLEAN
WriteMemoryUncached (
    ULONG64 Offset,
    PVOID Buffer,
    ULONG BufferSize,
    PULONG BytesWritten
    );

/////////////////////////////////////////////
//
//  KdExts.c
//
/////////////////////////////////////////////


BOOL
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    );

HRESULT
ExecuteCommand(
    IN PDEBUG_CLIENT Client,
    IN PSTR Command
    );

HRESULT
GetExtensionFunction(
    IN PCSTR FunctionName,
    IN FARPROC *Function
    );

void ExtOut(PCSTR Format, ...);
void ExtErr(PCSTR Format, ...);
void ExtWarn(PCSTR Format, ...);
void ExtVerb(PCSTR Format, ...);


/////////////////////////////////////////////
//
//  CritSec.c
//
/////////////////////////////////////////////

PLIST_ENTRY
DumpCritSec(
    HANDLE  hCurrentProcess,
    DWORD   dwAddrCritSec,
    BOOLEAN bDumpIfUnowned
    );



/////////////////////////////////////////////
//
//  Device.c
//
/////////////////////////////////////////////

VOID
DumpDevice(
    ULONG64 DeviceAddress,
    ULONG   FieldWidth,
    BOOLEAN FullDetail
    );

HRESULT
GetDevObjInfo(
    IN ULONG64 DeviceObject,
    OUT PDEBUG_DEVICE_OBJECT_INFO pDevObjInfo
    );

/////////////////////////////////////////////
//
// Devnode.c
//
/////////////////////////////////////////////

typedef struct _FLAG_NAME {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

VOID
DumpDeviceCapabilities(
    ULONG64 caps
    );

VOID
DumpFlags(
         ULONG Depth,
         LPSTR FlagDescription,
         ULONG Flags,
         PFLAG_NAME FlagTable
         );

VOID
xdprintf(
        ULONG Depth,
        PCHAR S,
        ...
        );

BOOLEAN
xReadMemory (
            ULONG64 S,
            PVOID D,
            ULONG Len
            );

/////////////////////////////////////////////
//
//  Driver.c
//
/////////////////////////////////////////////

VOID
DumpDriver(
    ULONG64 DriverAddress,
    ULONG   FieldWidth,
    ULONG   Flags
    );

HRESULT
GetDrvObjInfo(
    IN ULONG64 DriverObject,
    OUT PDEBUG_DRIVER_OBJECT_INFO pDrvObjInfo);

/////////////////////////////////////////////
//
//  irp.c
//
/////////////////////////////////////////////

HRESULT
GetIrpInfo(
    ULONG64 Irp,
    PDEBUG_IRP_INFO pIrp
    );

/////////////////////////////////////////////
//
//  lock.c
//
/////////////////////////////////////////////

VOID
DumpStaticFastMutex (
    IN PCHAR Name
    );


/////////////////////////////////////////////
//
//  memory.c
//
/////////////////////////////////////////////

VOID
MemoryUsage (
    IN ULONG64 PfnStart,
    IN ULONG64 LowPage,
    IN ULONG64 HighPage,
    IN ULONG IgnoreInvalidFrames
    );



/////////////////////////////////////////////
//
//  Object.c
//
/////////////////////////////////////////////
extern ULONG64 EXPRLastDump;

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType

    // end_wdm
    ,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    // begin_wdm

    } POOL_TYPE;

typedef BOOLEAN (*ENUM_TYPE_ROUTINE)(
    IN ULONG64          pObjectHeader,
    IN PVOID            Parameter
    );

//
// Object Table Entry Structure
//
typedef struct _OBJECT_TABLE_ENTRY {
    ULONG       NonPagedObjectHeader;
    ACCESS_MASK GrantedAccess;
} OBJECT_TABLE_ENTRY, *POBJECT_TABLE_ENTRY;
#define LOG_OBJECT_TABLE_ENTRY_SIZE 1

BOOLEAN
FetchObjectManagerVariables(
    BOOLEAN ForceReload
    );

ULONG64
FindObjectByName(
    IN PUCHAR  Path,
    IN ULONG64 RootObject
    );

ULONG64
FindObjectType(
    IN PUCHAR TypeName
    );

BOOLEAN
DumpObject(
    IN char     *Pad,
    IN ULONG64  Object,
//    IN POBJECT_HEADER OptObjectHeader OPTIONAL,
    IN ULONG    Flags
    );

BOOLEAN
WalkObjectsByType(
    IN PUCHAR               ObjectTypeName,
    IN ENUM_TYPE_ROUTINE    EnumRoutine,
    IN PVOID                Parameter
    );

BOOLEAN
CaptureObjectName(
    IN ULONG64          pObjectHeader,
//    IN POBJECT_HEADER   ObjectHeader,
    IN PWSTR            Buffer,
    IN ULONG            BufferSize
    );

VOID
DumpObjectName(
   ULONG64 ObjectAddress
   );


/////////////////////////////////////////////
//
//  pcr.c
//
/////////////////////////////////////////////
BOOL
ReadTargetPcr (
    OUT PULONG64 PPcr,
    IN ULONG     Processor
    );


/////////////////////////////////////////////
//
//  Pool.c
//
/////////////////////////////////////////////


typedef
BOOLEAN
(WINAPI *POOLFILTER) (
    PCHAR   Tag,
    PCHAR   Filter,
    ULONG   Flags,
    ULONG64 PoolHeader,
    ULONG64 BlockSize,
    ULONG64 Data,
    PVOID   Context
    );


void SearchPool(
    ULONG   TagName,
    ULONG   Flags,
    ULONG64 RestartAddr,
    POOLFILTER Filter,
    PVOID   Context
    );

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    );

LOGICAL
PoolInitializeGlobals(void);

HRESULT
ListPoolPage(
    ULONG64 PoolPageToDump,
    ULONG   Flags,
    PDEBUG_POOL_DATA PoolData
    );

PSTR
GetPoolTagDescription(
    IN ULONG PoolTag
    );

void
PrintPoolRegion(
    ULONG64 Pool
    );

PRTL_BITMAP
GetBitmap(
         ULONG64 pBitmap
         );
ULONG64
GetNextResidentAddress (
    ULONG64 VirtualAddress,
    ULONG64 MaximumVirtualAddress
    );

/////////////////////////////////////////////
//
//  Process.c
//
/////////////////////////////////////////////

extern CHAR *WaitReasonList[];

BOOL
DumpProcess(
   IN char * pad,
   IN ULONG64 RealProcessBase,
   IN ULONG Flags,
   IN OPTIONAL PCHAR ImageFileName
   );

BOOL
DumpThread (
    IN ULONG Processor,
    IN char *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG64 Flags
    );

BOOL
DumpThreadEx (
    IN ULONG Processor,
    IN char *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG Flags,
    IN PDEBUG_CLIENT pDbgClient
    );

VOID
dumpSymbolicAddress(
    ULONG64 Address,
    PCHAR   Buffer,
    BOOL    AlwaysShowHex
    );

BOOLEAN
FetchProcessStructureVariables(
    VOID
    );

BOOL
GetProcessSessionId(
    ULONG64 Process,
    PULONG SessionId
    );

BOOL
GetProcessHead(
    PULONG64 Head,
    PULONG64 First
    );

ULONG
GetAddressState(
    IN ULONG64 VirtualAddress
    );

typedef struct _PROCESS_COMMIT_USAGE {
    UCHAR ImageFileName[ 16 ];
    ULONG64 ClientId;
    ULONG64 ProcessAddress;
    ULONG64 CommitCharge;
    ULONG64 NumberOfPrivatePages;
    ULONG64 NumberOfLockedPages;
} PROCESS_COMMIT_USAGE, *PPROCESS_COMMIT_USAGE;


PPROCESS_COMMIT_USAGE
GetProcessCommit (
    PULONG64 TotalCommitCharge,
    PULONG   NumberOfProcesses
    );

VOID
DumpMmThreads (
    VOID
    );


PSTR
GetThreadWaitReasonName(
    ULONG dwWatiReason
    );

/////////////////////////////////////////////
//
//  pte.c
//
/////////////////////////////////////////////


ULONG
DbgGetValid(
    ULONG64 Pte
    );

ULONG64
DbgGetPdeAddress(
    IN ULONG64 VirtualAddress
    );

ULONG64
DbgGetPteAddress(
    IN ULONG64 VirtualAddress
    );

ULONG64
DbgGetFrameNumber(
    ULONG64 Pte
    );

ULONG64
DbgGetSubsectionAddress(
    IN ULONG64 Pte
    );

ULONG64
DbgGetVirtualAddressMappedByPte(
    IN ULONG64 Pte
    );

ULONG
MiGetSysPteListDelimiter (
    VOID
    );

BOOL
Mi_Is_Physical_Address (
    ULONG64 VirtualAddress
    );

ULONG
MiConvertPhysicalToPfn (
    IN ULONG64 VirtualAddress
    );

/////////////////////////////////////////////
//
//  Registry.c
//
/////////////////////////////////////////////
USHORT
GetKcbName(
    ULONG64 KcbAddr,
    PWCHAR  NameBuffer,
    ULONG   BufferSize
);


/////////////////////////////////////////////
//
//  sel.c
//
/////////////////////////////////////////////
// X86 only

//
//  LDT descriptor entry
//

typedef struct _LDT_ENTRY_X86 {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY_X86, *PLDT_ENTRY_X86;

typedef struct _DESCRIPTOR_TABLE_ENTRY_X86 {
    ULONG Selector;
    LDT_ENTRY_X86 Descriptor;
} DESCRIPTOR_TABLE_ENTRY_X86, *PDESCRIPTOR_TABLE_ENTRY_X86;

NTSTATUS
LookupSelector(
    IN USHORT Processor,
    IN OUT PDESCRIPTOR_TABLE_ENTRY_X86 pDescriptorTableEntry
    );

/////////////////////////////////////////////
//
//  trap.cpp
//
/////////////////////////////////////////////

// IA64 only

typedef enum _DISPLAY_MODE {
    DISPLAY_MIN     = 0,
    DISPLAY_DEFAULT = DISPLAY_MIN,
    DISPLAY_MED     = 1,
    DISPLAY_MAX     = 2,
    DISPLAY_FULL    = DISPLAY_MAX
} DISPLAY_MODE;

typedef struct _EM_REG_FIELD  {
   const    char   *SubName;
   const    char   *Name;
   unsigned long    Length;
   unsigned long    Shift;
} EM_REG_FIELD, *PEM_REG_FIELD;

VOID
DisplayFullEmRegField(
    ULONG64      EmRegValue,
    EM_REG_FIELD EmRegFields[],
    ULONG        Field
    );

VOID
DisplayFullEmReg(
    IN ULONG64      Val,
    IN EM_REG_FIELD EmRegFields[],
    IN DISPLAY_MODE DisplayMode
    );

/////////////////////////////////////////////
//
//  Util.c
//
/////////////////////////////////////////////

typedef VOID
(*PDUMP_SPLAY_NODE_FN)(
    ULONG64 RemoteAddress,
    ULONG   Level
    );

ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    );

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

ULONG
GetBitFieldOffset (
   IN LPSTR     Type,
   IN LPSTR     Field,
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   );

ULONG
GetFieldOffsetEx ( // returns Offset and Size...
   IN LPSTR     Type,
   IN LPSTR     Field,
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   );

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    );

VOID
DumpUnicode(
    UNICODE_STRING u
    );

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    );


ULONG64
GetPointerValue (
    PCHAR String
    );

BOOLEAN
IsHexNumber(
   const char *szExpression
   );

BOOLEAN
IsDecNumber(
   const char *szExpression
   );

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    );

ULONG64
UtilStringToUlong64 (
    UCHAR *String
    );

#define ENUM_NAME(val)            {val, #val}

typedef struct _ENUM_NAME {
   ULONG        EnumVal;
   const char * Name;
} ENUM_NAME, *PENUM_NAME;

const char *
getEnumName(
        ULONG       EnumVal,
        PENUM_NAME EnumTable
        );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\psr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ia64 psr

Abstract:

    KD Extension Api

Author:

    Thierry Fevrier (v-thief)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ia64.h"


//
// EmPspFields: EM register fields for the Processor State Parameter.
//

EM_REG_FIELD EmPspFields[] = {
        { "rv",  "reserved0"   , 0x2, 0 },
        { "rz",  "Rendez-vous successful"  , 0x1, 2 },
        { "ra",  "Rendez-vous attempted"  , 0x1, 3 },
        { "me",  "Distinct Multiple errors"  , 0x1, 4 },
        { "mn",  "Min-state Save Area registered"  , 0x1, 5 },
        { "sy",  "Storage integrity synchronized"  , 0x1, 6 },
        { "co",  "Continuable"  , 0x1, 7 },
        { "ci",  "Machine Check isolated"  , 0x1, 8 },
        { "us",  "Uncontained Storage damage"  , 0x1, 9 },
        { "hd",  "Hardware damage"  , 0x1, 10 },
        { "tl",  "Trap lost"  , 0x1, 11 },
        { "mi",  "More Information"  , 0x1, 12 },
        { "pi",  "Precise Instruction pointer"  , 0x1, 13 },
        { "pm",  "Precise Min-state Save Area"  , 0x1, 14 },
        { "dy",  "Processor Dynamic State valid"  , 0x1, 15 },
        { "in",  "INIT interruption"  , 0x1, 16 },
        { "rs",  "RSE valid"  , 0x1, 17 },
        { "cm",  "Machine Check corrected"  , 0x1, 18 },
        { "ex",  "Machine Check expected"  , 0x1, 19 },
        { "cr",  "Control Registers valid"  , 0x1, 20 },
        { "pc",  "Performance Counters valid"  , 0x1, 21 },
        { "dr",  "Debug Registers valid"  , 0x1, 22 },
        { "tr",  "Translation Registers valid"  , 0x1, 23 },
        { "rr",  "Region Registers valid"  , 0x1, 24 },
        { "ar",  "Application Registers valid"  , 0x1, 25 },
        { "br",  "Branch Registers valid"  , 0x1, 26 },
        { "pr",  "Predicate Registers valid"  , 0x1, 27 },
        { "fp",  "Floating-Point Registers valid"  , 0x1, 28 },
        { "b1",  "Preserved Bank 1 General Registers valid"  , 0x1, 29 },
        { "b0",  "Preserved Bank 0 General Registers valid"  , 0x1, 30 },
        { "gr",  "General Registers valid"  , 0x1, 31 },
        { "dsize",  "Processor Dynamic State size"  , 0x10, 32 },
        { "rv",  "reserved1"  , 0xB, 48 },
        { "cc",  "Cache Check"  , 0x1, 59 },
        { "tc",  "TLB   Check"  , 0x1, 60 },
        { "bc",  "Bus   Check"  , 0x1, 61 },
        { "rc",  "Register File Check"  , 0x1, 62 },
        { "uc",  "Micro-Architectural Check"  , 0x1, 63 }
};

VOID
DisplayPspIA64(
    IN const PCHAR         Header,
    IN       EM_PSP        EmPsp,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( EM_PSPToULong64(EmPsp), EmPspFields, DisplayMode );
    }
    else   {
       dprintf(
            "gr b0 b1 fp pr br ar rr tr dr pc cr ex cm rs in dy pm pi mi tl hd us ci co sy mn me ra rz\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x\n\t\t"
            "uc rc bc tc cc dsize\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x     %I64x\n",
            EmPsp.gr,
            EmPsp.b0,
            EmPsp.b1,
            EmPsp.fp,
            EmPsp.pr,
            EmPsp.br,
            EmPsp.ar,
            EmPsp.rr,
            EmPsp.tr,
            EmPsp.dr,
            EmPsp.pc,
            EmPsp.cr,
            EmPsp.ex,
            EmPsp.cm,
            EmPsp.rs,
            EmPsp.in,
            EmPsp.dy,
            EmPsp.pm,
            EmPsp.pi,
            EmPsp.mi,
            EmPsp.tl,
            EmPsp.hd,
            EmPsp.us,
            EmPsp.ci,
            EmPsp.co,
            EmPsp.sy,
            EmPsp.mn,
            EmPsp.me,
            EmPsp.ra,
            EmPsp.rz,
            EmPsp.uc,
            EmPsp.rc,
            EmPsp.bc,
            EmPsp.tc,
            EmPsp.cc,
            EmPsp.dsize
            );
    }
    return;
} // DisplayPspIA64()

DECLARE_API( psp )

/*++

Routine Description:

    Dumps an IA64 Processor State Parameter

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     pspValue;
    ULONG       result;
    ULONG       flags = 0;

    char       *header;

    INIT_API();

    pspValue = (ULONG64)0;
    flags = 0;
    if ( GetExpressionEx( args, &pspValue, &args ) )    {
        if ( args && *args )    {
            flags = (ULONG) GetExpression( args );
        }
    }

    header = (flags > DISPLAY_MIN) ? NULL : "\tpsp:\t";
    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!psp not implemented for this architecture.\n");
    }
    else
    {
        DisplayPspIA64( header, ULong64ToEM_PSP(pspValue), flags );
    }

    EXIT_API();

    return S_OK;

} // !psp

#define PROCESSOR_MINSTATE_SAVE_AREA_FORMAT_IA64 \
             "\tGRNats         : 0x%I64x\n" \
             "\tGR1            : 0x%I64x\n" \
             "\tGR2            : 0x%I64x\n" \
             "\tGR3            : 0x%I64x\n" \
             "\tGR4            : 0x%I64x\n" \
             "\tGR5            : 0x%I64x\n" \
             "\tGR6            : 0x%I64x\n" \
             "\tGR7            : 0x%I64x\n" \
             "\tGR8            : 0x%I64x\n" \
             "\tGR9            : 0x%I64x\n" \
             "\tGR10           : 0x%I64x\n" \
             "\tGR11           : 0x%I64x\n" \
             "\tGR12           : 0x%I64x\n" \
             "\tGR13           : 0x%I64x\n" \
             "\tGR14           : 0x%I64x\n" \
             "\tGR15           : 0x%I64x\n" \
             "\tBank0GR16      : 0x%I64x\n" \
             "\tBank0GR17      : 0x%I64x\n" \
             "\tBank0GR18      : 0x%I64x\n" \
             "\tBank0GR19      : 0x%I64x\n" \
             "\tBank0GR20      : 0x%I64x\n" \
             "\tBank0GR21      : 0x%I64x\n" \
             "\tBank0GR22      : 0x%I64x\n" \
             "\tBank0GR23      : 0x%I64x\n" \
             "\tBank0GR24      : 0x%I64x\n" \
             "\tBank0GR25      : 0x%I64x\n" \
             "\tBank0GR26      : 0x%I64x\n" \
             "\tBank0GR27      : 0x%I64x\n" \
             "\tBank0GR28      : 0x%I64x\n" \
             "\tBank0GR29      : 0x%I64x\n" \
             "\tBank0GR30      : 0x%I64x\n" \
             "\tBank0GR31      : 0x%I64x\n" \
             "\tBank1GR16      : 0x%I64x\n" \
             "\tBank1GR17      : 0x%I64x\n" \
             "\tBank1GR18      : 0x%I64x\n" \
             "\tBank1GR19      : 0x%I64x\n" \
             "\tBank1GR20      : 0x%I64x\n" \
             "\tBank1GR21      : 0x%I64x\n" \
             "\tBank1GR22      : 0x%I64x\n" \
             "\tBank1GR23      : 0x%I64x\n" \
             "\tBank1GR24      : 0x%I64x\n" \
             "\tBank1GR25      : 0x%I64x\n" \
             "\tBank1GR26      : 0x%I64x\n" \
             "\tBank1GR27      : 0x%I64x\n" \
             "\tBank1GR28      : 0x%I64x\n" \
             "\tBank1GR29      : 0x%I64x\n" \
             "\tBank1GR30      : 0x%I64x\n" \
             "\tBank1GR31      : 0x%I64x\n" \
             "\tPreds          : 0x%I64x\n" \
             "\tBR0            : 0x%I64x\n" \
             "\tRSC            : 0x%I64x\n" \
             "\tIIP            : 0x%I64x\n" \
             "\tIPSR           : 0x%I64x\n" \
             "\tIFS            : 0x%I64x\n" \
             "\tXIP            : 0x%I64x\n" \
             "\tXPSR           : 0x%I64x\n" \
             "\tXFS            : 0x%I64x\n\n"

VOID
DisplayProcessorMinStateSaveArea(
    ULONG64 Pmssa
    )
{
    ULONG pmssaSize;

    pmssaSize = GetTypeSize("hal!_PROCESSOR_MINSTATE_SAVE_AREA");
    dprintf("\tProcessor MinState Save Area @ 0x%I64x\n", Pmssa );
    if ( pmssaSize )    {
        CHAR cmd[MAX_PATH];
        sprintf(cmd, "dt -o -r hal!_PROCESSOR_MINSTATE_SAVE_AREA 0x%I64x", Pmssa);
        ExecCommand(cmd);
    }
    else  {
            dprintf("Failed to get hal!_PROCESSOR_MINSTATE_SAVE_AREA type size\n" );
    }

    return;

} // DisplayProcessorMinStateSaveArea()

DECLARE_API( pmssa )

/*++

Routine Description:

    Dumps memory address as an IA64 Processor Min-State Save Area.

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     pmssaValue;
    ULONG       result;

    char       *header;

    pmssaValue = GetExpression(args);
    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!pmssa not implemented for this architecture.\n");
    }
    else
    {
        if ( pmssaValue )   {
            DisplayProcessorMinStateSaveArea( pmssaValue );
        }
        else {
            dprintf("usage: pmssa <address>\n");
        }
    }

    return S_OK;

} // !pmssa

#define PROCESSOR_CONTROL_REGISTERS_FORMAT_IA64 \
    "\tDCR    : 0x%I64x\n" \
    "\tITM    : 0x%I64x\n" \
    "\tIVA    : 0x%I64x\n" \
    "\tCR3    : 0x%I64x\n" \
    "\tCR4    : 0x%I64x\n" \
    "\tCR5    : 0x%I64x\n" \
    "\tCR6    : 0x%I64x\n" \
    "\tCR7    : 0x%I64x\n" \
    "\tPTA    : 0x%I64x\n" \
    "\tGPTA   : 0x%I64x\n" \
    "\tCR10   : 0x%I64x\n" \
    "\tCR11   : 0x%I64x\n" \
    "\tCR12   : 0x%I64x\n" \
    "\tCR13   : 0x%I64x\n" \
    "\tCR14   : 0x%I64x\n" \
    "\tCR15   : 0x%I64x\n" \
    "\tIPSR   : 0x%I64x\n" \
    "\tISR    : 0x%I64x\n" \
    "\tCR18   : 0x%I64x\n" \
    "\tIIP    : 0x%I64x\n" \
    "\tIFA    : 0x%I64x\n" \
    "\tITIR   : 0x%I64x\n" \
    "\tIFS    : 0x%I64x\n" \
    "\tIIM    : 0x%I64x\n" \
    "\tIHA    : 0x%I64x\n" \
    "\tCR26   : 0x%I64x\n" \
    "\tCR27   : 0x%I64x\n" \
    "\tCR28   : 0x%I64x\n" \
    "\tCR29   : 0x%I64x\n" \
    "\tCR30   : 0x%I64x\n" \
    "\tCR31   : 0x%I64x\n" \
    "\tCR32   : 0x%I64x\n" \
    "\tCR33   : 0x%I64x\n" \
    "\tCR34   : 0x%I64x\n" \
    "\tCR35   : 0x%I64x\n" \
    "\tCR36   : 0x%I64x\n" \
    "\tCR37   : 0x%I64x\n" \
    "\tCR38   : 0x%I64x\n" \
    "\tCR39   : 0x%I64x\n" \
    "\tCR40   : 0x%I64x\n" \
    "\tCR41   : 0x%I64x\n" \
    "\tCR42   : 0x%I64x\n" \
    "\tCR43   : 0x%I64x\n" \
    "\tCR44   : 0x%I64x\n" \
    "\tCR45   : 0x%I64x\n" \
    "\tCR46   : 0x%I64x\n" \
    "\tCR47   : 0x%I64x\n" \
    "\tCR48   : 0x%I64x\n" \
    "\tCR49   : 0x%I64x\n" \
    "\tCR50   : 0x%I64x\n" \
    "\tCR51   : 0x%I64x\n" \
    "\tCR52   : 0x%I64x\n" \
    "\tCR53   : 0x%I64x\n" \
    "\tCR54   : 0x%I64x\n" \
    "\tCR55   : 0x%I64x\n" \
    "\tCR56   : 0x%I64x\n" \
    "\tCR57   : 0x%I64x\n" \
    "\tCR58   : 0x%I64x\n" \
    "\tCR59   : 0x%I64x\n" \
    "\tCR60   : 0x%I64x\n" \
    "\tCR61   : 0x%I64x\n" \
    "\tCR62   : 0x%I64x\n" \
    "\tCR63   : 0x%I64x\n" \
    "\tLID    : 0x%I64x\n" \
    "\tIVR    : 0x%I64x\n" \
    "\tTPR    : 0x%I64x\n" \
    "\tEOI    : 0x%I64x\n" \
    "\tIRR0   : 0x%I64x\n" \
    "\tIRR1   : 0x%I64x\n" \
    "\tIRR2   : 0x%I64x\n" \
    "\tIRR3   : 0x%I64x\n" \
    "\tITV    : 0x%I64x\n" \
    "\tPMV    : 0x%I64x\n" \
    "\tCMCV   : 0x%I64x\n" \
    "\tCR75   : 0x%I64x\n" \
    "\tCR76   : 0x%I64x\n" \
    "\tCR77   : 0x%I64x\n" \
    "\tCR78   : 0x%I64x\n" \
    "\tCR79   : 0x%I64x\n" \
    "\tLRR0   : 0x%I64x\n" \
    "\tLRR1   : 0x%I64x\n" \
    "\tCR82   : 0x%I64x\n" \
    "\tCR83   : 0x%I64x\n" \
    "\tCR84   : 0x%I64x\n" \
    "\tCR85   : 0x%I64x\n" \
    "\tCR86   : 0x%I64x\n" \
    "\tCR87   : 0x%I64x\n" \
    "\tCR88   : 0x%I64x\n" \
    "\tCR89   : 0x%I64x\n" \
    "\tCR90   : 0x%I64x\n" \
    "\tCR91   : 0x%I64x\n" \
    "\tCR92   : 0x%I64x\n" \
    "\tCR93   : 0x%I64x\n" \
    "\tCR94   : 0x%I64x\n" \
    "\tCR95   : 0x%I64x\n" \
    "\tCR96   : 0x%I64x\n" \
    "\tCR97   : 0x%I64x\n" \
    "\tCR98   : 0x%I64x\n" \
    "\tCR99   : 0x%I64x\n" \
    "\tCR100  : 0x%I64x\n" \
    "\tCR101  : 0x%I64x\n" \
    "\tCR102  : 0x%I64x\n" \
    "\tCR103  : 0x%I64x\n" \
    "\tCR104  : 0x%I64x\n" \
    "\tCR105  : 0x%I64x\n" \
    "\tCR106  : 0x%I64x\n" \
    "\tCR107  : 0x%I64x\n" \
    "\tCR108  : 0x%I64x\n" \
    "\tCR109  : 0x%I64x\n" \
    "\tCR110  : 0x%I64x\n" \
    "\tCR111  : 0x%I64x\n" \
    "\tCR112  : 0x%I64x\n" \
    "\tCR113  : 0x%I64x\n" \
    "\tCR114  : 0x%I64x\n" \
    "\tCR115  : 0x%I64x\n" \
    "\tCR116  : 0x%I64x\n" \
    "\tCR117  : 0x%I64x\n" \
    "\tCR118  : 0x%I64x\n" \
    "\tCR119  : 0x%I64x\n" \
    "\tCR120  : 0x%I64x\n" \
    "\tCR121  : 0x%I64x\n" \
    "\tCR122  : 0x%I64x\n" \
    "\tCR123  : 0x%I64x\n" \
    "\tCR124  : 0x%I64x\n" \
    "\tCR125  : 0x%I64x\n" \
    "\tCR126  : 0x%I64x\n" \
    "\tCR127  : 0x%I64x\n"

VOID
DisplayProcessorControlRegisters(
    ULONG64 Pcrs
    )
{
    ULONG pcrsSize;

    pcrsSize = GetTypeSize("hal!_PROCESSOR_CONTROL_REGISTERS");
    dprintf("\tProcessor Control Registers File @ 0x%I64x\n", Pcrs );
    if ( pcrsSize )    {
        CHAR cmd[MAX_PATH];
        sprintf(cmd, "dt -o -r hal!_PROCESSOR_CONTROL_REGISTERS 0x%I64x", Pcrs);
        ExecCommand(cmd);
    }
    else  {
        PROCESSOR_CONTROL_REGISTERS_IA64 controlRegisters;
        ULONG bytesRead = 0;
        pcrsSize = sizeof(controlRegisters);
        ReadMemory( Pcrs, &controlRegisters, pcrsSize, &bytesRead );
        if ( bytesRead >= pcrsSize  ) {
            dprintf( PROCESSOR_CONTROL_REGISTERS_FORMAT_IA64,
                    controlRegisters.DCR,
                    controlRegisters.ITM,
                    controlRegisters.IVA,
                    controlRegisters.CR3,
                    controlRegisters.CR4,
                    controlRegisters.CR5,
                    controlRegisters.CR6,
                    controlRegisters.CR7,
                    controlRegisters.PTA,
                    controlRegisters.GPTA,
                    controlRegisters.CR10,
                    controlRegisters.CR11,
                    controlRegisters.CR12,
                    controlRegisters.CR13,
                    controlRegisters.CR14,
                    controlRegisters.CR15,
                    controlRegisters.IPSR,
                    controlRegisters.ISR,
                    controlRegisters.CR18,
                    controlRegisters.IIP,
                    controlRegisters.IFA,
                    controlRegisters.ITIR,
                    controlRegisters.IFS,
                    controlRegisters.IIM,
                    controlRegisters.IHA,
                    controlRegisters.CR26,
                    controlRegisters.CR27,
                    controlRegisters.CR28,
                    controlRegisters.CR29,
                    controlRegisters.CR30,
                    controlRegisters.CR31,
                    controlRegisters.CR32,
                    controlRegisters.CR33,
                    controlRegisters.CR34,
                    controlRegisters.CR35,
                    controlRegisters.CR36,
                    controlRegisters.CR37,
                    controlRegisters.CR38,
                    controlRegisters.CR39,
                    controlRegisters.CR40,
                    controlRegisters.CR41,
                    controlRegisters.CR42,
                    controlRegisters.CR43,
                    controlRegisters.CR44,
                    controlRegisters.CR45,
                    controlRegisters.CR46,
                    controlRegisters.CR47,
                    controlRegisters.CR48,
                    controlRegisters.CR49,
                    controlRegisters.CR50,
                    controlRegisters.CR51,
                    controlRegisters.CR52,
                    controlRegisters.CR53,
                    controlRegisters.CR54,
                    controlRegisters.CR55,
                    controlRegisters.CR56,
                    controlRegisters.CR57,
                    controlRegisters.CR58,
                    controlRegisters.CR59,
                    controlRegisters.CR60,
                    controlRegisters.CR61,
                    controlRegisters.CR62,
                    controlRegisters.CR63,
                    controlRegisters.LID,
                    controlRegisters.IVR,
                    controlRegisters.TPR,
                    controlRegisters.EOI,
                    controlRegisters.IRR0,
                    controlRegisters.IRR1,
                    controlRegisters.IRR2,
                    controlRegisters.IRR3,
                    controlRegisters.ITV,
                    controlRegisters.PMV,
                    controlRegisters.CMCV,
                    controlRegisters.CR75,
                    controlRegisters.CR76,
                    controlRegisters.CR77,
                    controlRegisters.CR78,
                    controlRegisters.CR79,
                    controlRegisters.LRR0,
                    controlRegisters.LRR1,
                    controlRegisters.CR82,
                    controlRegisters.CR83,
                    controlRegisters.CR84,
                    controlRegisters.CR85,
                    controlRegisters.CR86,
                    controlRegisters.CR87,
                    controlRegisters.CR88,
                    controlRegisters.CR89,
                    controlRegisters.CR90,
                    controlRegisters.CR91,
                    controlRegisters.CR92,
                    controlRegisters.CR93,
                    controlRegisters.CR94,
                    controlRegisters.CR95,
                    controlRegisters.CR96,
                    controlRegisters.CR97,
                    controlRegisters.CR98,
                    controlRegisters.CR99,
                    controlRegisters.CR100,
                    controlRegisters.CR101,
                    controlRegisters.CR102,
                    controlRegisters.CR103,
                    controlRegisters.CR104,
                    controlRegisters.CR105,
                    controlRegisters.CR106,
                    controlRegisters.CR107,
                    controlRegisters.CR108,
                    controlRegisters.CR109,
                    controlRegisters.CR110,
                    controlRegisters.CR111,
                    controlRegisters.CR112,
                    controlRegisters.CR113,
                    controlRegisters.CR114,
                    controlRegisters.CR115,
                    controlRegisters.CR116,
                    controlRegisters.CR117,
                    controlRegisters.CR118,
                    controlRegisters.CR119,
                    controlRegisters.CR120,
                    controlRegisters.CR121,
                    controlRegisters.CR122,
                    controlRegisters.CR123,
                    controlRegisters.CR124,
                    controlRegisters.CR125,
                    controlRegisters.CR126,
                    controlRegisters.CR127
                      );
        }
        else {
            dprintf("Reading _PROCESSOR_CONTROL_REGISTERS directly from memory failed @ 0x%I64x.\n", Pcrs );
        }
    }

    return;

} // DisplayProcessorControlRegisters()

DECLARE_API( pcrs )

/*++

Routine Description:

    Dumps memory address as an IA64 Processor Control Registers file.

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     pcrsValue;
    ULONG       result;

    char       *header;

    pcrsValue = GetExpression(args);
    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!pcrs not implemented for this architecture.\n");
    }
    else
    {
        if ( pcrsValue )   {
            DisplayProcessorControlRegisters( pcrsValue );
        }
        else {
            dprintf("usage: pcrs <address>\n");
        }
    }

    return S_OK;

} // !pcrs

#define PROCESSOR_APPLICATION_REGISTERS_FORMAT_IA64 \
    "\tKR0       : 0x%I64x\n" \
    "\tKR1       : 0x%I64x\n" \
    "\tKR2       : 0x%I64x\n" \
    "\tKR3       : 0x%I64x\n" \
    "\tKR4       : 0x%I64x\n" \
    "\tKR5       : 0x%I64x\n" \
    "\tKR6       : 0x%I64x\n" \
    "\tKR7       : 0x%I64x\n" \
    "\tAR8       : 0x%I64x\n" \
    "\tAR9       : 0x%I64x\n" \
    "\tAR10      : 0x%I64x\n" \
    "\tAR11      : 0x%I64x\n" \
    "\tAR12      : 0x%I64x\n" \
    "\tAR13      : 0x%I64x\n" \
    "\tAR14      : 0x%I64x\n" \
    "\tAR15      : 0x%I64x\n" \
    "\tRSC       : 0x%I64x\n" \
    "\tBSP       : 0x%I64x\n" \
    "\tBSPSTORE  : 0x%I64x\n" \
    "\tRNAT      : 0x%I64x\n" \
    "\tAR20      : 0x%I64x\n" \
    "\tFCR       : 0x%I64x\n" \
    "\tAR22      : 0x%I64x\n" \
    "\tAR23      : 0x%I64x\n" \
    "\tEFLAG     : 0x%I64x\n" \
    "\tCSD       : 0x%I64x\n" \
    "\tSSD       : 0x%I64x\n" \
    "\tCFLG      : 0x%I64x\n" \
    "\tFSR       : 0x%I64x\n" \
    "\tFIR       : 0x%I64x\n" \
    "\tFDR       : 0x%I64x\n" \
    "\tAR31      : 0x%I64x\n" \
    "\tCCV       : 0x%I64x\n" \
    "\tAR33      : 0x%I64x\n" \
    "\tAR34      : 0x%I64x\n" \
    "\tAR35      : 0x%I64x\n" \
    "\tUNAT      : 0x%I64x\n" \
    "\tAR37      : 0x%I64x\n" \
    "\tAR38      : 0x%I64x\n" \
    "\tAR39      : 0x%I64x\n" \
    "\tFPSR      : 0x%I64x\n" \
    "\tAR41      : 0x%I64x\n" \
    "\tAR42      : 0x%I64x\n" \
    "\tAR43      : 0x%I64x\n" \
    "\tITC       : 0x%I64x\n" \
    "\tAR45      : 0x%I64x\n" \
    "\tAR46      : 0x%I64x\n" \
    "\tAR47      : 0x%I64x\n" \
    "\tAR48      : 0x%I64x\n" \
    "\tAR49      : 0x%I64x\n" \
    "\tAR50      : 0x%I64x\n" \
    "\tAR51      : 0x%I64x\n" \
    "\tAR52      : 0x%I64x\n" \
    "\tAR53      : 0x%I64x\n" \
    "\tAR54      : 0x%I64x\n" \
    "\tAR55      : 0x%I64x\n" \
    "\tAR56      : 0x%I64x\n" \
    "\tAR57      : 0x%I64x\n" \
    "\tAR58      : 0x%I64x\n" \
    "\tAR59      : 0x%I64x\n" \
    "\tAR60      : 0x%I64x\n" \
    "\tAR61      : 0x%I64x\n" \
    "\tAR62      : 0x%I64x\n" \
    "\tAR63      : 0x%I64x\n" \
    "\tPFS       : 0x%I64x\n" \
    "\tLC        : 0x%I64x\n" \
    "\tEC        : 0x%I64x\n" \
    "\tAR67      : 0x%I64x\n" \
    "\tAR68      : 0x%I64x\n" \
    "\tAR69      : 0x%I64x\n" \
    "\tAR70      : 0x%I64x\n" \
    "\tAR71      : 0x%I64x\n" \
    "\tAR72      : 0x%I64x\n" \
    "\tAR73      : 0x%I64x\n" \
    "\tAR74      : 0x%I64x\n" \
    "\tAR75      : 0x%I64x\n" \
    "\tAR76      : 0x%I64x\n" \
    "\tAR77      : 0x%I64x\n" \
    "\tAR78      : 0x%I64x\n" \
    "\tAR79      : 0x%I64x\n" \
    "\tAR80      : 0x%I64x\n" \
    "\tAR81      : 0x%I64x\n" \
    "\tAR82      : 0x%I64x\n" \
    "\tAR83      : 0x%I64x\n" \
    "\tAR84      : 0x%I64x\n" \
    "\tAR85      : 0x%I64x\n" \
    "\tAR86      : 0x%I64x\n" \
    "\tAR87      : 0x%I64x\n" \
    "\tAR88      : 0x%I64x\n" \
    "\tAR89      : 0x%I64x\n" \
    "\tAR90      : 0x%I64x\n" \
    "\tAR91      : 0x%I64x\n" \
    "\tAR92      : 0x%I64x\n" \
    "\tAR93      : 0x%I64x\n" \
    "\tAR94      : 0x%I64x\n" \
    "\tAR95      : 0x%I64x\n" \
    "\tAR96      : 0x%I64x\n" \
    "\tAR97      : 0x%I64x\n" \
    "\tAR98      : 0x%I64x\n" \
    "\tAR99      : 0x%I64x\n" \
    "\tAR100     : 0x%I64x\n" \
    "\tAR101     : 0x%I64x\n" \
    "\tAR102     : 0x%I64x\n" \
    "\tAR103     : 0x%I64x\n" \
    "\tAR104     : 0x%I64x\n" \
    "\tAR105     : 0x%I64x\n" \
    "\tAR106     : 0x%I64x\n" \
    "\tAR107     : 0x%I64x\n" \
    "\tAR108     : 0x%I64x\n" \
    "\tAR109     : 0x%I64x\n" \
    "\tAR110     : 0x%I64x\n" \
    "\tAR111     : 0x%I64x\n" \
    "\tAR112     : 0x%I64x\n" \
    "\tAR113     : 0x%I64x\n" \
    "\tAR114     : 0x%I64x\n" \
    "\tAR115     : 0x%I64x\n" \
    "\tAR116     : 0x%I64x\n" \
    "\tAR117     : 0x%I64x\n" \
    "\tAR118     : 0x%I64x\n" \
    "\tAR119     : 0x%I64x\n" \
    "\tAR120     : 0x%I64x\n" \
    "\tAR121     : 0x%I64x\n" \
    "\tAR122     : 0x%I64x\n" \
    "\tAR123     : 0x%I64x\n" \
    "\tAR124     : 0x%I64x\n" \
    "\tAR125     : 0x%I64x\n" \
    "\tAR126     : 0x%I64x\n" \
    "\tAR127     : 0x%I64x\n"

VOID
DisplayProcessorApplicationRegisters(
    ULONG64 Pars
    )
{
    ULONG parsSize;

    parsSize = GetTypeSize("hal!_PROCESSOR_APPLICATION_REGISTERS");
    dprintf("\tProcessor Application Registers File @ 0x%I64x\n", Pars );
    if ( parsSize )    {
        CHAR cmd[MAX_PATH];
        sprintf(cmd, "dt -o -r hal!_PROCESSOR_APPLICATION_REGISTERS 0x%I64x", Pars);
        ExecCommand(cmd);
    }
    else  {
        PROCESSOR_APPLICATION_REGISTERS_IA64 applicationRegisters;
        ULONG bytesRead = 0;
        parsSize = sizeof(applicationRegisters);
        ReadMemory( Pars, &applicationRegisters, parsSize, &bytesRead );
        if ( bytesRead >= parsSize  ) {
            dprintf( PROCESSOR_APPLICATION_REGISTERS_FORMAT_IA64,
                     applicationRegisters.KR0,
                     applicationRegisters.KR1,
                     applicationRegisters.KR2,
                     applicationRegisters.KR3,
                     applicationRegisters.KR4,
                     applicationRegisters.KR5,
                     applicationRegisters.KR6,
                     applicationRegisters.KR7,
                     applicationRegisters.AR8,
                     applicationRegisters.AR9,
                     applicationRegisters.AR10,
                     applicationRegisters.AR11,
                     applicationRegisters.AR12,
                     applicationRegisters.AR13,
                     applicationRegisters.AR14,
                     applicationRegisters.AR15,
                     applicationRegisters.RSC,
                     applicationRegisters.BSP,
                     applicationRegisters.BSPSTORE,
                     applicationRegisters.RNAT,
                     applicationRegisters.AR20,
                     applicationRegisters.FCR,
                     applicationRegisters.AR22,
                     applicationRegisters.AR23,
                     applicationRegisters.EFLAG,
                     applicationRegisters.CSD,
                     applicationRegisters.SSD,
                     applicationRegisters.CFLG,
                     applicationRegisters.FSR,
                     applicationRegisters.FIR,
                     applicationRegisters.FDR,
                     applicationRegisters.AR31,
                     applicationRegisters.CCV,
                     applicationRegisters.AR33,
                     applicationRegisters.AR34,
                     applicationRegisters.AR35,
                     applicationRegisters.UNAT,
                     applicationRegisters.AR37,
                     applicationRegisters.AR38,
                     applicationRegisters.AR39,
                     applicationRegisters.FPSR,
                     applicationRegisters.AR41,
                     applicationRegisters.AR42,
                     applicationRegisters.AR43,
                     applicationRegisters.ITC,
                     applicationRegisters.AR45,
                     applicationRegisters.AR46,
                     applicationRegisters.AR47,
                     applicationRegisters.AR48,
                     applicationRegisters.AR49,
                     applicationRegisters.AR50,
                     applicationRegisters.AR51,
                     applicationRegisters.AR52,
                     applicationRegisters.AR53,
                     applicationRegisters.AR54,
                     applicationRegisters.AR55,
                     applicationRegisters.AR56,
                     applicationRegisters.AR57,
                     applicationRegisters.AR58,
                     applicationRegisters.AR59,
                     applicationRegisters.AR60,
                     applicationRegisters.AR61,
                     applicationRegisters.AR62,
                     applicationRegisters.AR63,
                     applicationRegisters.PFS,
                     applicationRegisters.LC,
                     applicationRegisters.EC,
                     applicationRegisters.AR67,
                     applicationRegisters.AR68,
                     applicationRegisters.AR69,
                     applicationRegisters.AR70,
                     applicationRegisters.AR71,
                     applicationRegisters.AR72,
                     applicationRegisters.AR73,
                     applicationRegisters.AR74,
                     applicationRegisters.AR75,
                     applicationRegisters.AR76,
                     applicationRegisters.AR77,
                     applicationRegisters.AR78,
                     applicationRegisters.AR79,
                     applicationRegisters.AR80,
                     applicationRegisters.AR81,
                     applicationRegisters.AR82,
                     applicationRegisters.AR83,
                     applicationRegisters.AR84,
                     applicationRegisters.AR85,
                     applicationRegisters.AR86,
                     applicationRegisters.AR87,
                     applicationRegisters.AR88,
                     applicationRegisters.AR89,
                     applicationRegisters.AR90,
                     applicationRegisters.AR91,
                     applicationRegisters.AR92,
                     applicationRegisters.AR93,
                     applicationRegisters.AR94,
                     applicationRegisters.AR95,
                     applicationRegisters.AR96,
                     applicationRegisters.AR97,
                     applicationRegisters.AR98,
                     applicationRegisters.AR99,
                     applicationRegisters.AR100,
                     applicationRegisters.AR101,
                     applicationRegisters.AR102,
                     applicationRegisters.AR103,
                     applicationRegisters.AR104,
                     applicationRegisters.AR105,
                     applicationRegisters.AR106,
                     applicationRegisters.AR107,
                     applicationRegisters.AR108,
                     applicationRegisters.AR109,
                     applicationRegisters.AR110,
                     applicationRegisters.AR111,
                     applicationRegisters.AR112,
                     applicationRegisters.AR113,
                     applicationRegisters.AR114,
                     applicationRegisters.AR115,
                     applicationRegisters.AR116,
                     applicationRegisters.AR117,
                     applicationRegisters.AR118,
                     applicationRegisters.AR119,
                     applicationRegisters.AR120,
                     applicationRegisters.AR121,
                     applicationRegisters.AR122,
                     applicationRegisters.AR123,
                     applicationRegisters.AR124,
                     applicationRegisters.AR125,
                     applicationRegisters.AR126,
                     applicationRegisters.AR127
                      );
        }
        else {
            dprintf("Reading _PROCESSOR_APPLICATION_REGISTERS directly from memory failed @ 0x%I64x.\n", Pars );
        }
    }

    return;

} // DisplayProcessorApplicationRegisters()

DECLARE_API( pars )

/*++

Routine Description:

    Dumps memory address as an IA64 Processor Control Registers file.

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     parsValue;
    ULONG       result;

    char       *header;

    parsValue = GetExpression(args);
    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!pars not implemented for this architecture.\n");
    }
    else
    {
        if ( parsValue )   {
            DisplayProcessorApplicationRegisters( parsValue );
        }
        else {
            dprintf("usage: pars <address>\n");
        }
    }

    return S_OK;

} // !pars
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\process.cpp ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    process.c

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma)

    Using debugger type info.
--*/

#include "precomp.h"
#pragma hdrstop

typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady
    } KTHREAD_STATE;



extern ULONG64 STeip, STebp, STesp;
#if 0  //  MAKE IT BUILD
static PHANDLE_TABLE PspCidTable;
static HANDLE_TABLE CapturedPspCidTable;
#endif

ULONG64 ProcessLastDump;
ULONG64 ThreadLastDump;
ULONG   TotalProcessCommit;


CHAR * SecImpLevel[] = {
            "Anonymous",
            "Identification",
            "Impersonation",
            "Delegation" };

#define SecImpLevels(x) (x < sizeof( SecImpLevel ) / sizeof( PSTR ) ? \
                        SecImpLevel[ x ] : "Illegal Value" )

typedef BOOLEAN (WINAPI *PENUM_PROCESS_CALLBACK)(PVOID ProcessAddress, PVOID Process, PVOID ThreadAddress, PVOID Thread);

PSTR
GetThreadWaitReasonName(
    ULONG dwWatiReason
    )
{
    #define MAX_WAITREASONS 40
    static char WaitReasonDescs[MAX_WAITREASONS][50] = {0};

    if (dwWatiReason >= MAX_WAITREASONS)
    {
        return "Invalid WaitReason";
    } else if (WaitReasonDescs[dwWatiReason][0] != '\0')
    {
        return WaitReasonDescs[dwWatiReason];
    } else
    {
        ULONG wrTypeId;
        ULONG64 Module;
        CHAR Name[MAX_PATH];
        if (g_ExtSymbols->GetSymbolTypeId("nt!_KWAIT_REASON", &wrTypeId, &Module) == S_OK &&
            g_ExtSymbols->GetConstantName(Module, wrTypeId, dwWatiReason,
                                          Name, sizeof(Name), NULL) == S_OK)
        {
            StringCchCopy(WaitReasonDescs[dwWatiReason], sizeof(WaitReasonDescs[dwWatiReason]),
                          Name);
            return WaitReasonDescs[dwWatiReason];
        }
    }
    return "Unknown";
}

BOOLEAN
GetTheSystemTime (
    OUT PLARGE_INTEGER Time
    )
{
    BYTE               readTime[20]={0};
    PCHAR              SysTime;
    ULONG              err;

    ZeroMemory( Time, sizeof(*Time) );

    SysTime = "SystemTime";

    if (err = GetFieldValue(MM_SHARED_USER_DATA_VA, "nt!_KUSER_SHARED_DATA", SysTime, readTime)) {
        if (err == MEMORY_READ_ERROR) {
            dprintf( "unable to read memory @ %lx\n",
                     MM_SHARED_USER_DATA_VA);
        } else {
            dprintf("type nt!_KUSER_SHARED_DATA not found.\n");
        }
        return FALSE;
    }

    *Time = *(LARGE_INTEGER UNALIGNED *)&readTime[0];

    return TRUE;
}


VOID
dumpSymbolicAddress(
    ULONG64 Address,
    PCHAR   Buffer,
    BOOL    AlwaysShowHex
    )
{
    ULONG64 displacement;
    PCHAR s;

    Buffer[0] = '!';
    GetSymbol((ULONG64)Address, Buffer, &displacement);
    s = (PCHAR) Buffer + strlen( (PCHAR) Buffer );
    if (s == (PCHAR) Buffer) {
        sprintf( s, (IsPtr64() ? "0x%016I64x" : "0x%08x"), Address );
        }
    else {
        if (displacement != 0) {
            sprintf( s, (IsPtr64() ? "+0x%016I64x" : "+0x%08x"), displacement );
            }
        if (AlwaysShowHex) {
            sprintf( s, (IsPtr64() ? " (0x%016I64x)" : " (0x%08x)"), Address );
            }
        }

    return;
}

BOOL
GetProcessHead(PULONG64 Head, PULONG64 First)
{
    ULONG64 List_Flink = 0;

    *Head = GetNtDebuggerData( PsActiveProcessHead );
    if (!*Head) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(*Head, "nt!_LIST_ENTRY", "Flink", List_Flink)) {
        dprintf("Unable to read _LIST_ENTRY @ %p \n", *Head);
        return FALSE;
    }

    if (List_Flink == 0) {
        dprintf("NULL value in PsActiveProcess List\n");
        return FALSE;
    }

    *First = List_Flink;
    return TRUE;
}

ULONG64
LookupProcessByName(PCSTR Name, BOOL Verbose)
{
    ULONG64 ProcessHead, Process;
    ULONG64 ProcessNext;
    ULONG   Off;

    if (!GetProcessHead(&ProcessHead, &ProcessNext)) {
        return 0;
    }

    //
    // Walk through the list and find the process with the desired name.
    //

    if (GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &Off)) {
        dprintf("Unable to get EPROCESS.ActiveProcessLinks offset\n");
        return 0;
    }

    while (ProcessNext != 0 && ProcessNext != ProcessHead) {
        char ImageFileName[64];

        Process = ProcessNext - Off;

        if (GetFieldValue(Process, "nt!_EPROCESS", "ImageFileName",
                          ImageFileName)) {
            dprintf("Cannot read EPROCESS at %p\n", Process);
        } else {
            if (Verbose) {
                dprintf("  Checking process %s\n", ImageFileName);
            }

            if (!_strcmpi(Name, ImageFileName)) {
                return Process;
            }
        }

        if (!ReadPointer(ProcessNext, &ProcessNext)) {
            dprintf("Cannot read EPROCESS at %p\n", Process);
            return 0;
        }

        if (CheckControlC()) {
            return 0;
        }
    }

    return 0;
}

HRESULT
WaitForExceptionEvent(ULONG Code, ULONG FirstChance, ULONG64 Process)
{
    HRESULT Status;

    Status = g_ExtControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
    if (Status != S_OK) {
        dprintf("Unable to wait, 0x%X\n", Status);
        return Status;
    }

    //
    // Got some kind of event.  Make sure it's the right kind.
    //

    ULONG Type, ProcId, ThreadId;
    DEBUG_LAST_EVENT_INFO_EXCEPTION ExInfo;

    if ((Status = g_ExtControl->
         GetLastEventInformation(&Type, &ProcId, &ThreadId,
                                 &ExInfo, sizeof(ExInfo), NULL,
                                 NULL, 0, NULL)) != S_OK) {
        dprintf("Unable to get event information\n");
        return Status;
    }

    if (Type != DEBUG_EVENT_EXCEPTION ||
        (ULONG)ExInfo.ExceptionRecord.ExceptionCode != Code ||
        ExInfo.FirstChance != FirstChance) {
        dprintf("Unexpected event occurred\n");
        return E_UNEXPECTED;
    }

    if (Process) {
        ULONG Processor;
        ULONG64 EventProcess;

        if (!GetCurrentProcessor(g_ExtClient, &Processor, NULL)) {
            Processor = 0;
        }
        GetCurrentProcessAddr(Processor, 0, &EventProcess);
        if (EventProcess != Process) {
            dprintf("Event occurred in wrong process\n");
            return E_UNEXPECTED;
        }
    }

    return S_OK;
}

HRESULT
WaitForSingleStep(ULONG64 Process)
{
    HRESULT Status;

    Status = g_ExtControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
    if (Status != S_OK) {
        dprintf("Unable to wait, 0x%X\n", Status);
        return Status;
    }

    //
    // Got some kind of event.  Make sure it's the right kind.
    //

    ULONG Type, ProcId, ThreadId;

    if ((Status = g_ExtControl->
         GetLastEventInformation(&Type, &ProcId, &ThreadId,
                                 NULL, 0, NULL,
                                 NULL, 0, NULL)) != S_OK) {
        dprintf("Unable to get event information\n");
        return Status;
    }

    if (Type != 0) {
        dprintf("Unexpected event occurred\n");
        return E_UNEXPECTED;
    }

    if (Process) {
        ULONG Processor;
        ULONG64 EventProcess;

        if (!GetCurrentProcessor(g_ExtClient, &Processor, NULL)) {
            Processor = 0;
        }
        GetCurrentProcessAddr(Processor, 0, &EventProcess);
        if (EventProcess != Process) {
            dprintf("Event occurred in wrong process\n");
            return E_UNEXPECTED;
        }
    }

    return S_OK;
}

DECLARE_API( bpid )

/*++

Routine Description:

    Uses winlogon to cause a user-mode break in the given process.

Arguments:

    None.

Return Value:

    None.

--*/

{
    INIT_API();

    if (BuildNo < 2195) {
        dprintf("bpid only works on 2195 or above\n");
        goto Exit;
    }
    if (TargetMachine != IMAGE_FILE_MACHINE_I386 &&
        TargetMachine != IMAGE_FILE_MACHINE_IA64) {
        dprintf("bpid is only implemented for x86 and IA64\n");
        goto Exit;
    }

    BOOL StopInWinlogon;
    BOOL Verbose;
    BOOL WritePidToMemory;
    ULONG WhichGlobal;
    PSTR WhichGlobalName;

    StopInWinlogon = FALSE;
    Verbose = FALSE;
    WritePidToMemory = FALSE;
    WhichGlobal = 1;
    WhichGlobalName = "Breakin";

    for (;;)
    {
        while (*args == ' ' || *args == '\t')
        {
            args++;
        }

        if (*args == '-' || *args == '/')
        {
            switch(*++args)
            {
            case 'a':
                // Set g_AttachProcessId instead of
                // g_BreakinProcessId.
                WhichGlobal = 2;
                WhichGlobalName = "Attach";
                break;
            case 's':
                StopInWinlogon = TRUE;
                break;
            case 'v':
                Verbose = TRUE;
                break;
            case 'w':
                WritePidToMemory = TRUE;
                break;
            default:
                dprintf("Unknown option '%c'\n", *args);
                goto Exit;
            }

            args++;
        }
        else
        {
            break;
        }
    }

    ULONG64 Pid;

    if (!GetExpressionEx(args, &Pid, &args)) {
        dprintf("Usage: bpid <pid>\n");
        goto Exit;
    }

    ULONG64 Winlogon;
    ULONG64 WinlToken;

    dprintf("Finding winlogon...\n");
    Winlogon = LookupProcessByName("winlogon.exe", Verbose);
    if (Winlogon == 0) {
        dprintf("Unable to find winlogon\n");
        goto Exit;
    }
    if (GetFieldValue(Winlogon, "nt!_EPROCESS", "Token", WinlToken)) {
        dprintf("Unable to read winlogon process token\n");
        goto Exit;
    }
    // Low bits of the token value are flags.  Mask off to get pointer.
    if (IsPtr64()) {
        WinlToken &= ~15;
    } else {
        WinlToken = (ULONG64)(LONG64)(LONG)(WinlToken & ~7);
    }

    ULONG ExpOff;

    //
    // winlogon checks its token expiration time.  If it's
    // zero it breaks in and checks a few things, one of which is whether
    // it should inject a DebugBreak into a process.  First,
    // set the token expiration to zero so that winlogon breaks in.
    //

    if (GetFieldOffset("nt!_TOKEN", "ExpirationTime", &ExpOff)) {
        dprintf("Unable to get TOKEN.ExpirationTime offset\n");
        goto Exit;
    }

    WinlToken += ExpOff;

    ULONG64 Expiration, Zero;
    ULONG Done;

    // Save the expiration time.
    if (!ReadMemory(WinlToken, &Expiration, sizeof(Expiration), &Done) ||
        Done != sizeof(Expiration)) {
        dprintf("Unable to read token expiration\n");
        goto Exit;
    }

    // Zero it.
    Zero = 0;
    if (!WriteMemory(WinlToken, &Zero, sizeof(Zero), &Done) ||
        Done != sizeof(Zero)) {
        dprintf("Unable to write token expiration\n");
        goto Exit;
    }

    HRESULT Hr;

    // Get things running.
    if (g_ExtControl->SetExecutionStatus(DEBUG_STATUS_GO) != S_OK) {
        dprintf("Unable to go\n");
        goto RestoreExp;
    }

    // Wait for a breakin.
    dprintf("Waiting for winlogon to break.  "
            "This can take a couple of minutes...\n");
    Hr = WaitForExceptionEvent(STATUS_BREAKPOINT, TRUE, Winlogon);
    if (Hr != S_OK) {
        goto RestoreExp;
    }

    //
    // We broke into winlogon.
    // We need to set winlogon!g_[Breakin|Attach]ProcessId to
    // the process we want to break into.  Relying on symbols
    // is pretty fragile as the image header may be paged out
    // or the symbol path may be wrong.  Even if we had good symbols
    // the variable itself may not be paged in at this point.
    // The approach taken here is to single-step out to where
    // the global is checked and insert the value at that
    // point.  winlogon currently checks two globals after the
    // DebugBreak.  g_BreakinProcessId is the first one and
    // g_AttachProcessId is the second.
    //

    ULONG Steps;
    ULONG Globals;
    ULONG64 BpiAddr;
    ULONG64 UserProbeAddress;
    PSTR RegDst;

    dprintf("Stepping to g_%sProcessId check...\n", WhichGlobalName);
    Steps = 0;
    Globals = 0;
    UserProbeAddress = GetNtDebuggerDataPtrValue(MmUserProbeAddress);
    while (Globals < WhichGlobal)
    {
        if (CheckControlC()) {
            goto RestoreExp;
        }

        if (g_ExtControl->SetExecutionStatus(DEBUG_STATUS_STEP_OVER) != S_OK) {
            dprintf("Unable to start step\n");
            goto RestoreExp;
        }

        Hr = WaitForSingleStep(Winlogon);
        if (Hr != S_OK) {
            goto RestoreExp;
        }

        char DisStr[128];
        int DisStrLen;
        ULONG64 Pc;

        // Check whether this is a global load.
        if (g_ExtRegisters->GetInstructionOffset(&Pc) != S_OK ||
            g_ExtControl->Disassemble(Pc, 0, DisStr, sizeof(DisStr),
                                      NULL, &Pc) != S_OK) {
            dprintf("Unable to check step\n");
            goto RestoreExp;
        }

        // Remove newline at end.
        DisStrLen = strlen(DisStr);
        if (DisStrLen > 0 && DisStr[DisStrLen - 1] == '\n') {
            DisStr[--DisStrLen] = 0;
        }

        if (Verbose) {
            dprintf("  Step to '%s'\n", DisStr);
        }

        BpiAddr = 0;
        RegDst = NULL;

        PSTR OffStr;

        switch(TargetMachine) {
        case IMAGE_FILE_MACHINE_I386:
            if (strstr(DisStr, "mov") != NULL &&
                strstr(DisStr, " eax,[") != NULL &&
                DisStr[DisStrLen - 1] == ']' &&
                (OffStr = strchr(DisStr, '[')) != NULL) {

                RegDst = "eax";

                //
                // Found a load.  Parse the offset.
                //

                PSTR SymTailStr = strchr(OffStr + 1, '(');

                if (SymTailStr != NULL) {
                    // There's a symbol name in the reference.  We
                    // can't check the actual symbol name as symbols
                    // aren't necessarily correct, so just skip
                    // to the open paren.
                    OffStr = SymTailStr + 1;
                }

                for (;;) {
                    OffStr++;
                    if (*OffStr >= '0' && *OffStr <= '9') {
                        BpiAddr = BpiAddr * 16 + (*OffStr - '0');
                    } else if (*OffStr >= 'a' && *OffStr <= 'f') {
                        BpiAddr = BpiAddr * 16 + (*OffStr - 'a');
                    } else {
                        BpiAddr = (ULONG64)(LONG64)(LONG)BpiAddr;
                        break;
                    }
                }
                if (*OffStr != ']' && *OffStr != ')') {
                    BpiAddr = 0;
                }
            }
            break;

        case IMAGE_FILE_MACHINE_IA64:
            if (strstr(DisStr, "ld4") != NULL &&
                (OffStr = strchr(DisStr, '[')) != NULL) {

                // Extract destination register name.
                RegDst = OffStr - 1;
                if (*RegDst != '=') {
                    break;
                }
                *RegDst-- = 0;
                while (RegDst > DisStr && *RegDst != ' ') {
                    RegDst--;
                }
                if (*RegDst != ' ') {
                    break;
                }
                RegDst++;

                // Extract source register name and value.
                PSTR RegSrc = ++OffStr;
                while (*OffStr && *OffStr != ']') {
                    OffStr++;
                }
                if (*OffStr == ']') {
                    *OffStr = 0;

                    DEBUG_VALUE RegVal;
                    ULONG RegIdx;

                    if (g_ExtRegisters->GetIndexByName(RegSrc,
                                                       &RegIdx) == S_OK &&
                        g_ExtRegisters->GetValue(RegIdx, &RegVal) == S_OK &&
                        RegVal.Type == DEBUG_VALUE_INT64) {
                        BpiAddr = RegVal.I64;
                    }
                }
            }
            break;
        }

        if (RegDst != NULL &&
            BpiAddr >= 0x10000 && BpiAddr < UserProbeAddress) {
            // Looks like a reasonable global load.
            Globals++;
        }

        if (++Steps > 30) {
            dprintf("Unable to find g_%sProcessId load\n", WhichGlobalName);
            goto RestoreExp;
        }
    }

    //
    // We're at the mov eax,[g_BreakinProcessId] instruction.
    // Execute the instruction to accomplish two things:
    // 1. The page will be made available so we can write
    //    to it if we need to.
    // 2. If we don't want to write the actual memory we
    //    can just set eax to do a one-time break.
    //

    if (g_ExtControl->SetExecutionStatus(DEBUG_STATUS_STEP_OVER) != S_OK) {
        dprintf("Unable to start step\n");
        goto RestoreExp;
    }

    Hr = WaitForSingleStep(Winlogon);
    if (Hr != S_OK) {
        goto RestoreExp;
    }

    char RegCmd[64];

    //
    // Update the register and write memory if necessary.
    //

    sprintf(RegCmd, "r %s=0x0`%x", RegDst, (ULONG)Pid);
    if (g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE, RegCmd,
                              DEBUG_EXECUTE_NOT_LOGGED |
                              DEBUG_EXECUTE_NO_REPEAT) != S_OK) {
        goto RestoreExp;
    }

    if (WritePidToMemory) {
        if (!WriteMemory(BpiAddr, &Pid, sizeof(ULONG), &Done) ||
            Done != sizeof(ULONG)) {
            dprintf("Unable to write pid to g_%sProcessId, continuing\n",
                    WhichGlobalName);
        }
    }

    // Everything is set.  Resume execution and the break should
    // occur.
    dprintf("Break into process %x set.  "
            "The next break should be in the desired process.\n",
            (ULONG)Pid);

    if (!StopInWinlogon) {
        if (g_ExtControl->SetExecutionStatus(DEBUG_STATUS_GO) != S_OK) {
            dprintf("Unable to go\n");
        }
    } else {
        dprintf("Stopping in winlogon\n");
    }

 RestoreExp:
    if (!WriteMemory(WinlToken, &Expiration, sizeof(Expiration), &Done) ||
        Done != sizeof(Expiration)) {
        dprintf("Unable to restore token expiration\n");
    }

 Exit:
    EXIT_API();
    return S_OK;
}

LPWSTR
GetFullImageName(
    ULONG64 Process
    )
//
// retrives the actual image name for process, this is useful
// since EPROCESS.ImageName could be truncated
//
{
    static WCHAR s_ImageNameRead[MAX_PATH+1];
    ULONG64 ImageNameStr = 0;
    if (!GetFieldValue(Process, "nt!_EPROCESS", "SeAuditProcessCreationInfo.ImageFileName",
                       ImageNameStr) &&
        (ImageNameStr != 0))
    {
        ULONG Length, res;
        ULONG64 Buffer;

        if (!GetFieldValue(ImageNameStr, "nt!_OBJECT_NAME_INFORMATION", "Name.Length",
                           Length) &&
            !GetFieldValue(ImageNameStr, "nt!_OBJECT_NAME_INFORMATION", "Name.Buffer",
                           Buffer))
        {
            ZeroMemory(s_ImageNameRead, sizeof(s_ImageNameRead));

            if (Length > (sizeof(s_ImageNameRead)-sizeof(WCHAR)))
            {
                Length = sizeof(s_ImageNameRead) - sizeof(WCHAR);
            }
            if (ReadMemory(Buffer, s_ImageNameRead, Length, &res))
            {
                LPWSTR filename = wcsrchr(s_ImageNameRead, L'\\');
                if (filename)
                {
                    return (filename+1);
                }
            }

        }

    }
    return NULL;
}


BOOL
GetProcessSessionId(ULONG64 Process, PULONG SessionId)
{
    *SessionId = 0;

    if (BuildNo && BuildNo < 2280) {
        GetFieldValue(Process, "nt!_EPROCESS", "SessionId", *SessionId);
    } else {
        ULONG64 SessionPointer;

        if (GetFieldValue(Process, "nt!_EPROCESS", "Session", SessionPointer)) {
            return FALSE;
        }

        if (SessionPointer != 0) {
            if (GetFieldValue(SessionPointer, "nt!_MM_SESSION_SPACE",
                              "SessionId", *SessionId)) {
                // dprintf("Could not find Session Id at %p.\n", SessionPointer);
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL
DumpProcess(
   IN char * pad,
   IN ULONG64 RealProcessBase,
   IN ULONG Flags,
   IN OPTIONAL PCHAR ImageFileName
   )
{
    LARGE_INTEGER RunTime;
    BOOL LongAddrs = IsPtr64();
    TIME_FIELDS Times;
    ULONG TimeIncrement;
    LPWSTR FullImageName;
    STRING  string1, string2;
    ULONG64 ThreadListHead_Flink=0, ActiveProcessLinks_Flink=0;
    ULONG64 UniqueProcessId=0, Peb=0, InheritedFromUniqueProcessId=0, NumberOfHandles=0;
    ULONG64 ObjectTable=0, NumberOfPrivatePages=0, ModifiedPageCount=0, NumberOfLockedPages=0;
    ULONG64 NVads = 0;
    ULONG64 VadRoot=0, CloneRoot=0, DeviceMap=0, Token=0;
    ULONG64 CreateTime_QuadPart=0, Pcb_UserTime=0, Pcb_KernelTime=0;
    ULONG64 Vm_WorkingSetSize=0, Vm_MinimumWorkingSetSize=0, Vm_MaximumWorkingSetSize=0;
    ULONG64 Vm_PeakWorkingSetSize=0, VirtualSize=0, PeakVirtualSize=0, Vm_PageFaultCount=0;
    ULONG64 Vm_MemoryPriority=0, Pcb_BasePriority=0, CommitCharge=0, DebugPort=0, Job=0;
    ULONG  SessionId, Pcb_Header_Type=0;
    CHAR   Pcb_DirectoryTableBase[16]={0}, QuotaPoolUsage[32]={0}, ImageFileName_Read[32] = {0};
    TCHAR procType[] = "_EPROCESS";

    if (GetFieldValue(RealProcessBase, "nt!_EPROCESS", "UniqueProcessId", UniqueProcessId)) {
        dprintf("Could not find _EPROCESS type at %p.\n", RealProcessBase);
        return FALSE;
    }

    if (!GetProcessSessionId(RealProcessBase, &SessionId))
    {
        dprintf("Could not find Session Id for process.\n");
    }

    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Peb",                     Peb);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "InheritedFromUniqueProcessId",InheritedFromUniqueProcessId);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.DirectoryTableBase",  Pcb_DirectoryTableBase);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.Header.Type",         Pcb_Header_Type);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ObjectTable",             ObjectTable);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ImageFileName",           ImageFileName_Read);

    if (GetFieldValue(RealProcessBase, "nt!_EPROCESS", "NumberOfVads", NVads)) {
        if (GetFieldValue(RealProcessBase, "nt!_EPROCESS", "VadRoot.NumberGenericTableElements", NVads)) {
            dprintf ("failed for AVL nvads\n");
            return FALSE;
        }

        if (GetFieldValue(RealProcessBase, "nt!_EPROCESS", "VadRoot.BalancedRoot.RightChild", VadRoot)) {
            dprintf ("failed for new vadroot\n");
        }
    }
    else {
        GetFieldValue(RealProcessBase, "nt!_EPROCESS", "VadRoot",                 VadRoot);
    }

    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "CloneRoot",               CloneRoot);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "NumberOfPrivatePages",    NumberOfPrivatePages);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ModifiedPageCount",       ModifiedPageCount);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "NumberOfLockedPages",     NumberOfLockedPages);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "DeviceMap",               DeviceMap);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Token",                   Token);
    if (IsPtr64()) {
        Token = Token & ~(ULONG64)15;
    } else {
        Token = Token & ~(ULONG64)7;
    }
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "CreateTime.QuadPart",     CreateTime_QuadPart);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.UserTime",            Pcb_UserTime);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.KernelTime",          Pcb_KernelTime);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.WorkingSetSize",       Vm_WorkingSetSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.MinimumWorkingSetSize",Vm_MinimumWorkingSetSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.MaximumWorkingSetSize",Vm_MaximumWorkingSetSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.PeakWorkingSetSize",   Vm_PeakWorkingSetSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "VirtualSize",             VirtualSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "PeakVirtualSize",         PeakVirtualSize);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.PageFaultCount",       Vm_PageFaultCount);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Vm.MemoryPriority",       Vm_MemoryPriority);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.BasePriority",        Pcb_BasePriority);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "CommitCharge",            CommitCharge);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "DebugPort",               DebugPort);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Job",                     Job);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink",ThreadListHead_Flink);
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ActiveProcessLinks.Flink",ActiveProcessLinks_Flink);
    GetFieldValue(ObjectTable, "nt!_HANDLE_TABLE", "HandleCount",             NumberOfHandles);
    if (BuildNo < 2462) { // prior to XP Beta2
        GetFieldValue(RealProcessBase, "nt!_EPROCESS", "QuotaPoolUsage",      QuotaPoolUsage);
    } else {
        GetFieldValue(RealProcessBase, "nt!_EPROCESS", "QuotaUsage",          QuotaPoolUsage);
    }

    // dprintf( " Proc list Next:%I64x, ProceDump:%I64x, Head:%I64x...\n", Next, ProcessToDump, ProcessHead);


    if (Pcb_Header_Type != ProcessObject) {
        dprintf("TYPE mismatch for process object at %p\n", RealProcessBase);
        return FALSE;
    }

    //
    // Get the image file name
    //
    if (ImageFileName_Read[0] == 0 ) {
        strcpy(ImageFileName_Read,"System Process");
    }

    if (ImageFileName != NULL) {
        RtlInitString(&string1, ImageFileName);
        RtlInitString(&string2, ImageFileName_Read);
        if (RtlCompareString(&string1, &string2, TRUE) != 0) {
            return TRUE;
        }
    }

    dprintf("%sPROCESS %08p", pad, RealProcessBase);

    dprintf("%s%sSessionId: %u  Cid: %04I64x    Peb: %08I64x  ParentCid: %04I64x\n",
            (LongAddrs ? "\n    " : " "),
            (LongAddrs ? pad      : " "),
            SessionId,
            UniqueProcessId,
            Peb,
            InheritedFromUniqueProcessId
            );

    if (LongAddrs) {
        dprintf("%s    DirBase: %08I64lx  ObjectTable: %08p  TableSize: %3u.\n",
                pad,
                *((ULONG64 *) &Pcb_DirectoryTableBase[ 0 ]),
                ObjectTable,
                (ULONG) NumberOfHandles
                );
    } else {
        dprintf("%s    DirBase: %08lx  ObjectTable: %08p  TableSize: %3u.\n",
                pad,
                *((ULONG *) &Pcb_DirectoryTableBase[ 0 ]),
                ObjectTable,
                (ULONG) NumberOfHandles
                );
    }

    dprintf("%s    Image: ", pad);
    FullImageName = GetFullImageName(RealProcessBase);
    if (FullImageName != NULL && *FullImageName != 0)
    {
        dprintf("%ws\n", FullImageName);
    } else
    {
        dprintf("%s\n",ImageFileName_Read);
    }

    if (!(Flags & 1)) {
        dprintf("\n");
        return TRUE;
    }

    dprintf("%s    VadRoot %p Vads %I64ld Clone %1p Private %I64ld. Modified %I64ld. Locked %I64ld.\n",
            pad,
            VadRoot,
            NVads,
            CloneRoot,
            NumberOfPrivatePages,
            ModifiedPageCount,
            NumberOfLockedPages);

    dprintf("%s    DeviceMap %p\n", pad, DeviceMap );


    //
    // Primary token
    //

    dprintf("%s    Token                             %p\n", pad, Token);

    //
    // Get the time increment value which is used to compute runtime.
    //
    TimeIncrement = GetNtDebuggerDataValue( KeTimeIncrement );

    GetTheSystemTime (&RunTime);
    RunTime.QuadPart -= CreateTime_QuadPart;
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%s    ElapsedTime                     %3ld:%02ld:%02ld.%04ld\n",
            pad,
            Times.Hour,
            Times.Minute,
            Times.Second,
            Times.Milliseconds);

    RunTime.QuadPart = UInt32x32To64(Pcb_UserTime, TimeIncrement);
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%s    UserTime                        %3ld:%02ld:%02ld.%04ld\n",
            pad,
            Times.Hour,
            Times.Minute,
            Times.Second,
            Times.Milliseconds);

    RunTime.QuadPart = UInt32x32To64(Pcb_KernelTime, TimeIncrement);
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%s    KernelTime                      %3ld:%02ld:%02ld.%04ld\n",
            pad,
            Times.Hour,
            Times.Minute,
            Times.Second,
            Times.Milliseconds);

    if (!LongAddrs) {
        dprintf("%s    QuotaPoolUsage[PagedPool]         %ld\n", pad,*((ULONG *) &QuotaPoolUsage[PagedPool*4]) );
        dprintf("%s    QuotaPoolUsage[NonPagedPool]      %ld\n", pad,*((ULONG *) &QuotaPoolUsage[NonPagedPool*4])    );
    } else {
        dprintf("%s    QuotaPoolUsage[PagedPool]         %I64ld\n", pad,*((ULONG64 *) &QuotaPoolUsage[PagedPool*8]) );
        dprintf("%s    QuotaPoolUsage[NonPagedPool]      %I64ld\n", pad,*((ULONG64 *) &QuotaPoolUsage[NonPagedPool*8])    );
    }

    dprintf("%s    Working Set Sizes (now,min,max)  (%I64ld, %I64ld, %I64ld) (%I64ldKB, %I64ldKB, %I64ldKB)\n",
            pad,
            Vm_WorkingSetSize,
            Vm_MinimumWorkingSetSize,
            Vm_MaximumWorkingSetSize,
            _KB*Vm_WorkingSetSize,
            _KB*Vm_MinimumWorkingSetSize,
            _KB*Vm_MaximumWorkingSetSize
            );
    dprintf("%s    PeakWorkingSetSize                %I64ld\n", pad, Vm_PeakWorkingSetSize           );
    dprintf("%s    VirtualSize                       %I64ld Mb\n", pad, VirtualSize /(1024*1024)     );
    dprintf("%s    PeakVirtualSize                   %I64ld Mb\n", pad, PeakVirtualSize/(1024*1024)  );
    dprintf("%s    PageFaultCount                    %I64ld\n", pad, Vm_PageFaultCount               );
    dprintf("%s    MemoryPriority                    %s\n", pad, Vm_MemoryPriority ? "FOREGROUND" : "BACKGROUND" );
    dprintf("%s    BasePriority                      %I64ld\n", pad, Pcb_BasePriority);
    dprintf("%s    CommitCharge                      %I64ld\n", pad, CommitCharge                    );
    if ( DebugPort ) {
        dprintf("%s    DebugPort                         %p\n", pad, DebugPort );
    }
    if ( Job ) {
        dprintf("%s    Job                               %p\n", pad, Job );
    }


    dprintf("\n");

    //
    // If the object table is NULL, the process is being destroyed and
    // there are no threads
    //
    return (ObjectTable != 0) ? 1 : -1;

}


//
// This is to be called from .c file extensions which do not do INIT_API
// that is they do not set g_ExtControl needed for stacktrace in DumpThread
//
// It will set the globals needed to dump stacktrace and call DumpThread
//
BOOL
DumpThreadEx (
    IN ULONG Processor,
    IN char *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG Flags,
    IN PDEBUG_CLIENT pDbgClient
    )
{
    BOOL retval = FALSE;
    if (pDbgClient &&
        (ExtQuery(pDbgClient) == S_OK)) {
        retval = DumpThread(Processor, Pad, RealThreadBase, Flags);

        ExtRelease();
    }
    return retval;
}

BOOL
DumpThread (
    IN ULONG Processor,
    IN char *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG64 Flags
    )
{
#define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG64 Address;
    ULONG WaitOffset;
    ULONG64 Process;
    CHAR Buffer[256];
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG err;
    ULONG64 displacement;
    DEBUG_STACK_FRAME stk[MAX_STACK_FRAMES];
    BOOL LongAddrs = IsPtr64();
    ULONG Tcb_Alertable = 0, Tcb_Proc;
    ULONG64 ActiveImpersonationInfo=0, Cid_UniqueProcess=0, Cid_UniqueThread=0, ImpersonationInfo=0,
       ImpersonationInfo_ImpersonationLevel=0, ImpersonationInfo_Token=0, IrpList_Flink=0,
       IrpList_Blink=0, LpcReceivedMessageId=0, LpcReceivedMsgIdValid=0, LpcReplyMessage=0, LpcReplyMessageId=0,
       PerformanceCountHigh=0, PerformanceCountLow=0, StartAddress=0, Tcb_ApcState_Process=0,
       Tcb_BasePriority=0, Tcb_CallbackStack=0, Tcb_ContextSwitches=0, Tcb_DecrementCount=0, Tcb_EnableStackSwap=0,
       Tcb_FreezeCount=0, Tcb_Header_Type=0, Tcb_InitialStack=0, Tcb_KernelStack=0, Tcb_KernelStackResident=0,
       Tcb_KernelTime=0, Tcb_LargeStack=0, Tcb_NextProcessor=0, Tcb_Priority=0, Tcb_PriorityDecrement=0,
       Tcb_StackBase=0, Tcb_StackLimit=0, Tcb_State=0, Tcb_SuspendCount=0, Tcb_Teb=0, Tcb_UserTime=0,
       Tcb_WaitBlockList=0, Tcb_WaitMode=0, Tcb_WaitReason=0, Tcb_WaitTime=0,
       Tcb_Win32Thread=0, Win32StartAddress=0, ObpLUIDDeviceMapsEnabled=0;
    ULONG IrpListOffset;
    TCHAR threadTyp[] = "nt!_ETHREAD";

    if (!IsPtr64())
    {
        RealThreadBase = (ULONG64) (LONG64) (LONG) RealThreadBase;
    }

    if (GetFieldOffset(threadTyp, "IrpList", &IrpListOffset))
    {
        dprintf("Cannot find nt!_ETHREAD type.\n");
        return FALSE;
    }
    if (CheckControlC()) {
        return FALSE;
    }

    if (InitTypeRead(RealThreadBase, nt!_ETHREAD))
    {
        dprintf("%s*** Error in in reading nt!_ETHREAD @ %p\n", Pad, RealThreadBase);
        return FALSE;
    }

    Tcb_Header_Type = ReadField(Tcb.Header.Type);
    Cid_UniqueProcess = ReadField(Cid.UniqueProcess);
    Cid_UniqueThread = ReadField(Cid.UniqueThread);
    Tcb_Teb = ReadField(Tcb.Teb);
    Tcb_Win32Thread = ReadField(Tcb.Win32Thread);
    Tcb_State = ReadField(Tcb.State);
    Tcb_WaitReason = ReadField(Tcb.WaitReason);
    Tcb_WaitMode = ReadField(Tcb.WaitMode);
    Tcb_Alertable = (ULONG) ReadField(Tcb.Alertable);



    if (Tcb_Header_Type != ThreadObject) {
        dprintf("TYPE mismatch for thread object at %p\n",RealThreadBase);
        return FALSE;
    }

    dprintf("%sTHREAD %p  Cid %1p.%1p  Teb: %p %s%sWin32Thread: %p ",
            Pad, RealThreadBase,
            Cid_UniqueProcess,
            Cid_UniqueThread,
            Tcb_Teb,
            (LongAddrs ? "\n" : ""),
            (LongAddrs ? Pad  : ""),
            Tcb_Win32Thread);


    switch (Tcb_State) {
        case Initialized:
            dprintf("%s\n","INITIALIZED");break;
        case Ready:
            dprintf("%s\n","READY");break;
        case Running:
            dprintf("%s%s%s on processor %lx\n",
                    (!LongAddrs ? "\n" : ""),
                    (!LongAddrs ? Pad  : ""),
                    "RUNNING", Tcb_Proc = (ULONG) ReadField(Tcb.NextProcessor));
            break;
        case Standby:
            dprintf("%s\n","STANDBY");break;
        case Terminated:
            dprintf("%s\n","TERMINATED");break;
        case Waiting:
            dprintf("%s","WAIT");break;
        case Transition:
            dprintf("%s\n","TRANSITION");break;
        case DeferredReady:
            dprintf("%s\n","DEFERREDREADY");break;
    }

    if (!(Flags & 2)) {
        dprintf("\n");
        return TRUE;
    }

    Tcb_SuspendCount = ReadField(Tcb.SuspendCount);
    Tcb_FreezeCount = ReadField(Tcb.FreezeCount);
    Tcb_WaitBlockList = ReadField(Tcb.WaitBlockList);
    LpcReplyMessageId = ReadField(LpcReplyMessageId);
    LpcReplyMessage = ReadField(LpcReplyMessage);
    IrpList_Flink = ReadField(IrpList.Flink);
    IrpList_Blink = ReadField(IrpList.Blink);
    ActiveImpersonationInfo = ReadField(ActiveImpersonationInfo);
    ImpersonationInfo = ReadField(ImpersonationInfo);
    Tcb_ApcState_Process = ReadField(Tcb.ApcState.Process);
    Tcb_WaitTime = ReadField(Tcb.WaitTime);
    Tcb_ContextSwitches = ReadField(Tcb.ContextSwitches);
    Tcb_EnableStackSwap = ReadField(Tcb.EnableStackSwap);
    Tcb_LargeStack = ReadField(Tcb.LargeStack);
    Tcb_UserTime = ReadField(Tcb.UserTime);
    Tcb_KernelTime = ReadField(Tcb.KernelTime);
    PerformanceCountHigh = ReadField(PerformanceCountHigh);
    PerformanceCountLow = ReadField(PerformanceCountLow);
    StartAddress = ReadField(StartAddress);
    Win32StartAddress = ReadField(Win32StartAddress);
    LpcReceivedMsgIdValid = ReadField(LpcReceivedMsgIdValid);
    LpcReceivedMessageId = ReadField(LpcReceivedMessageId);
    Tcb_InitialStack = ReadField(Tcb.InitialStack);
    Tcb_KernelStack = ReadField(Tcb.KernelStack);
    Tcb_StackBase = ReadField(Tcb.StackBase);
    Tcb_StackLimit = ReadField(Tcb.StackLimit);
    Tcb_CallbackStack = ReadField(Tcb.CallbackStack);
    Tcb_Priority = ReadField(Tcb.Priority);
    Tcb_BasePriority = ReadField(Tcb.BasePriority);
    Tcb_PriorityDecrement = ReadField(Tcb.PriorityDecrement);
    Tcb_KernelStackResident = ReadField(Tcb.KernelStackResident);
    Tcb_NextProcessor = ReadField(Tcb.NextProcessor);
    if (BuildNo < 3648)
    {
        Tcb_DecrementCount = ReadField(Tcb.DecrementCount);
    }

    if (Tcb_State == Waiting) {
       ULONG64 WaitBlock_Object=0, WaitBlock_NextWaitBlock=0;

       dprintf(": (%s) %s %s\n",
            GetThreadWaitReasonName((ULONG)Tcb_WaitReason),
            (Tcb_WaitMode==0) ? "KernelMode" : "UserMode", Tcb_Alertable ? "Alertable" : "Non-Alertable");
        if ( Tcb_SuspendCount ) {
            dprintf("SuspendCount %lx\n",Tcb_SuspendCount);
        }
        if ( Tcb_FreezeCount ) {
            dprintf("FreezeCount %lx\n",Tcb_FreezeCount);
        }

        WaitOffset = (ULONG) (Tcb_WaitBlockList - RealThreadBase);

        if (err = GetFieldValue(Tcb_WaitBlockList, "nt!_KWAIT_BLOCK", "Object", WaitBlock_Object)) {
            dprintf("%sCannot read nt!_KWAIT_BLOCK at %p - error %lx\n", Pad, Tcb_WaitBlockList, err);
            goto BadWaitBlock;
        }

        GetFieldValue(Tcb_WaitBlockList, "nt!_KWAIT_BLOCK", "NextWaitBlock", WaitBlock_NextWaitBlock);

        do {
            TCHAR MutantListEntry[16]={0};
            ULONG64 OwnerThread=0, Header_Type=0;

            dprintf("%s    %p  ",Pad, WaitBlock_Object);

            GetFieldValue(WaitBlock_Object, "nt!_KMUTANT", "Header.Type", Header_Type);
            GetFieldValue(WaitBlock_Object, "nt!_KMUTANT", "MutantListEntry", MutantListEntry);
            GetFieldValue(WaitBlock_Object, "nt!_KMUTANT", "OwnerThread", OwnerThread);

            switch (Header_Type) {
                case EventNotificationObject:
                    dprintf("NotificationEvent\n");
                    break;
                case EventSynchronizationObject:
                    dprintf("SynchronizationEvent\n");
                    break;
                case SemaphoreObject:
                    dprintf("Semaphore Limit 0x%lx\n",
                             *((ULONG *) &MutantListEntry[0]));
                    break;
                case ThreadObject:
                    dprintf("Thread\n");
                    break;
                case TimerNotificationObject:
                    dprintf("NotificationTimer\n");
                    break;
                case TimerSynchronizationObject:
                    dprintf("SynchronizationTimer\n");
                    break;
                case EventPairObject:
                    dprintf("EventPair\n");
                    break;
                case ProcessObject:
                    dprintf("ProcessObject\n");
                    break;
                case MutantObject:
                    dprintf("Mutant - owning thread %lp\n",
                            OwnerThread);
                    break;
                default:
                    dprintf("Unknown\n");
                    // goto BadWaitBlock;
                    break;
            }

            if ( WaitBlock_NextWaitBlock == Tcb_WaitBlockList) {
                break;
                goto BadWaitBlock;
            }


            if (err = GetFieldValue(WaitBlock_NextWaitBlock, "nt!_KWAIT_BLOCK", "Object", WaitBlock_Object)) {
                dprintf("%sCannot read nt!_KWAIT_BLOCK at %p - error %lx\n", Pad, WaitBlock_NextWaitBlock, err);
                goto BadWaitBlock;
            }
            GetFieldValue(WaitBlock_NextWaitBlock, "nt!_KWAIT_BLOCK", "NextWaitBlock", WaitBlock_NextWaitBlock);

            if (CheckControlC()) {
                return FALSE;
            }
        } while ( TRUE );
    }

BadWaitBlock:
    if (!(Flags & 4)) {
        dprintf("\n");
        return TRUE;
    }


    if (LpcReplyMessageId != 0) {
        dprintf("%sWaiting for reply to LPC MessageId %08p:\n",Pad,LpcReplyMessageId);
    }

    if (LpcReplyMessage) {

        if (LpcReplyMessage & 1) {

            dprintf("%sCurrent LPC port %08lp\n",Pad, (LpcReplyMessage & ~((ULONG64)1)));

        } else {

            ULONG64 Entry_Flink, Entry_Blink;

            dprintf("%sPending LPC Reply Message:\n",Pad);
            Address = (ULONG64) LpcReplyMessage;

            GetFieldValue(Address, "nt!_LPCP_MESSAGE", "Entry.Flink", Entry_Flink);
            GetFieldValue(Address, "nt!_LPCP_MESSAGE", "Entry.Blink", Entry_Blink);

            dprintf("%s    %08lp: [%08lp,%08lp]\n",
                    Pad,
                    Address,
                    Entry_Blink,
                    Entry_Flink
                    );
        }
    }

    if (IrpList_Flink && (IrpList_Flink != IrpList_Blink ||
                          IrpList_Flink != (RealThreadBase + IrpListOffset))
       ) {

        ULONG64 IrpListHead = RealThreadBase + IrpListOffset;
        ULONG64 Next;
        ULONG Counter = 0;
        ULONG ThreadListEntryOffset;

        Next = IrpList_Flink;

        if (!GetFieldOffset("nt!_IRP", "ThreadListEntry", &ThreadListEntryOffset))
        {
           dprintf("%sIRP List:\n",Pad);
           while (Next && (Next != IrpListHead) && (Counter < 17)) {
               ULONG Irp_Type=0, Irp_Size=0, Irp_Flags=0;
               ULONG64 Irp_MdlAddress=0;

               Counter += 1;

               // subtract threadlistentry offset
               Address = Next - ThreadListEntryOffset;
               Next=0;

               if (GetFieldValue(Address, "nt!_IRP", "Type", Irp_Type))
               {
                   dprintf("%s    Unable to read nt!_IRP @ %p\n", Pad, Address);
                   break;
               }
               GetFieldValue(Address, "nt!_IRP", "Size",          Irp_Size);
               GetFieldValue(Address, "nt!_IRP", "Flags",         Irp_Flags);
               GetFieldValue(Address, "nt!_IRP", "MdlAddress",    Irp_MdlAddress);
               GetFieldValue(Address, "nt!_IRP", "ThreadListEntry.Flink",  Next);

               dprintf("%s    %08p: (%04x,%04x) Flags: %08lx  Mdl: %08lp\n",
                       Pad,Address,Irp_Type,Irp_Size,Irp_Flags,Irp_MdlAddress);

           }
        }
    }

    //
    // Impersonation information
    //

    if (ActiveImpersonationInfo) {
        InitTypeRead(ImpersonationInfo, nt!_PS_IMPERSONATION_INFORMATION);
        ImpersonationInfo_Token = ReadField(Token);
        ImpersonationInfo_ImpersonationLevel = ReadField(ImpersonationLevel);

        if (ImpersonationInfo_Token) {
            dprintf("%sImpersonation token:  %p (Level %s)\n",
                        Pad, ImpersonationInfo_Token,
                        SecImpLevels( ImpersonationInfo_ImpersonationLevel ) );
        }
        else
        {
            dprintf("%sUnable to read Impersonation Information at %x\n",
                        Pad, ImpersonationInfo );
        }
    } else {
        dprintf("%sNot impersonating\n", Pad);
    }

    //
    // DeviceMap information
    //

    // check to see if per-LUID devicemaps are turned on
    ULONG64 ObpLUIDDeviceMapsEnabledAddress;

    ObpLUIDDeviceMapsEnabledAddress = GetExpression("nt!ObpLUIDDeviceMapsEnabled");
    if (ObpLUIDDeviceMapsEnabledAddress) {
        ObpLUIDDeviceMapsEnabled = GetUlongFromAddress(ObpLUIDDeviceMapsEnabled);
    } else {
        ObpLUIDDeviceMapsEnabled = 0;
    }

    if (((ULONG)ObpLUIDDeviceMapsEnabled) != 0) {

        //
        // If we're impersonating, get the DeviceMap information
        // from the token.
        //

        if (ActiveImpersonationInfo) {
            ImpersonationInfo_Token = ReadField(Token);

            // get the LUID from the token
            ULONG64 AuthenticationId = 0;
            GetFieldValue(ImpersonationInfo_Token,
                "nt!_TOKEN",
                "AuthenticationId",
                AuthenticationId);

            // find the devmap directory object
            UCHAR Path[64];
            ULONG64 DeviceMapDirectory = 0;
            sprintf((PCHAR)Path, "\\Sessions\\0\\DosDevices\\%08x-%08x",
                (ULONG)((AuthenticationId >> 32) & 0xffffffff),
                (ULONG)(AuthenticationId & 0xffffffff)
                );
            DeviceMapDirectory = FindObjectByName(Path, 0);

            if(DeviceMapDirectory != 0) {

                // get the device map itself
                ULONG64 DeviceMap = 0;
                GetFieldValue(DeviceMapDirectory,
                    "nt!_OBJECT_DIRECTORY",
                    "DeviceMap",
                    DeviceMap);

                if(DeviceMap != 0) {
                    dprintf("%sDeviceMap %p\n", Pad, DeviceMap);
                }
            }


        //
        // Else, we're not impersonating, so just return the
        // DeviceMap from our parent process.
        //

        } else if (Tcb_ApcState_Process != 0) {
            // get the devicemap from the process
            ULONG64 DeviceMap = 0;
            GetFieldValue(Tcb_ApcState_Process,
                "nt!_EPROCESS",
                "DeviceMap",
                DeviceMap);

            if (DeviceMap != 0) {
                dprintf("%sDeviceMap %p\n", Pad, DeviceMap);
            }
        }
    }


    // Process = CONTAINING_RECORD(Tcb_ApcState_Process,EPROCESS,Pcb);
    // Pcb is the 1st element
    Process = Tcb_ApcState_Process;
    dprintf("%sOwning Process %lp\n", Pad, Process);

    GetTheSystemTime (&RunTime);

    dprintf("%sWaitTime (ticks)          %ld\n",
              Pad,
              Tcb_WaitTime);

    dprintf("%sContext Switch Count      %ld",
              Pad,
              Tcb_ContextSwitches);

    if (!Tcb_EnableStackSwap) {
        dprintf("  NoStackSwap");
    } else {
        dprintf("             ");
    }

    if (Tcb_LargeStack) {
        dprintf("    LargeStack");
    }

    dprintf ("\n");

    //
    // Get the time increment value which is used to compute runtime.
    //
    TimeIncrement = GetNtDebuggerDataValue( KeTimeIncrement );

    RunTime.QuadPart = UInt32x32To64(Tcb_UserTime, TimeIncrement);
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%sUserTime                %3ld:%02ld:%02ld.%04ld\n",
              Pad,
              Times.Hour,
              Times.Minute,
              Times.Second,
              Times.Milliseconds);

    RunTime.QuadPart = UInt32x32To64(Tcb_KernelTime, TimeIncrement);
    RtlTimeToElapsedTimeFields ( &RunTime, &Times);
    dprintf("%sKernelTime              %3ld:%02ld:%02ld.%04ld\n",
              Pad,
              Times.Hour,
              Times.Minute,
              Times.Second,
              Times.Milliseconds);

    if (PerformanceCountHigh != 0) {
        dprintf("%sPerfCounterHigh         0x%lx %08lx\n",
                Pad,
                PerformanceCountHigh,
                PerformanceCountHigh);
    } else if (PerformanceCountLow != 0) {
        dprintf("%sPerfCounter             %lu\n",Pad,PerformanceCountLow);
    }

    dumpSymbolicAddress(StartAddress, Buffer, TRUE);
    dprintf("%sStart Address %s\n",
        Pad,
        Buffer
        );

    if (Win32StartAddress)
        if (LpcReceivedMsgIdValid)
            {
            dprintf("%sLPC Server thread working on message Id %x\n",
                Pad,
                LpcReceivedMessageId
                );
            }
        else
            {
            dumpSymbolicAddress(Win32StartAddress, Buffer, TRUE);
            dprintf("%sWin32 Start Address %s\n",
                Pad,
                Buffer
                );
            }
    dprintf("%sStack Init %lp Current %lp%s%sBase %lp Limit %lp Call %lp\n",
        Pad,
        Tcb_InitialStack,
        Tcb_KernelStack,
        (LongAddrs ? "\n" : ""),
        (LongAddrs ? Pad  : " " ),
        Tcb_StackBase,
        Tcb_StackLimit,
        Tcb_CallbackStack
        );

    if (BuildNo < 3648)
    {
        dprintf("%sPriority %I64ld BasePriority %I64ld PriorityDecrement %I64ld DecrementCount %I64ld\n",
                Pad,
                Tcb_Priority,
                Tcb_BasePriority,
                Tcb_PriorityDecrement,
                Tcb_DecrementCount
                );
    } else
    {
        dprintf("%sPriority %I64ld BasePriority %I64ld PriorityDecrement %I64ld\n",
            Pad,
            Tcb_Priority,
            Tcb_BasePriority,
            Tcb_PriorityDecrement
            );
    }

    if (!Tcb_KernelStackResident) {
        dprintf("%sKernel stack not resident.\n", Pad);
//        dprintf("\n");
//        return TRUE;
        // Try getting the stack even in this case - this might still be paged in
    }

    if (// (Tcb_State == Running && Processor == Tcb_Proc) || // Set thread context for everything
        Ioctl(IG_SET_THREAD, &RealThreadBase, sizeof(ULONG64))) {
        g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES, &frames );

        if (frames) {
            ULONG OutFlags;

            OutFlags = (DEBUG_STACK_COLUMN_NAMES | DEBUG_STACK_FUNCTION_INFO |
                        DEBUG_STACK_FRAME_ADDRESSES | DEBUG_STACK_SOURCE_LINE);

            if (!(Flags & 0x8))
            {
                OutFlags |= DEBUG_STACK_ARGUMENTS;
            }

    //        if (Flags & 0x10)
    //        {
    //            OutFlags |= DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY;
    //        }

            g_ExtClient->SetOutputLinePrefix(Pad);
            g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_AMBIENT, stk, frames, OutFlags);
            g_ExtClient->SetOutputLinePrefix(NULL);
        }
    }

    dprintf("\n");
    return TRUE;
}


/**

   Routine to get address of the record containing a field on a debugee machine.
   Returns size of the type on success.

ULONG
GetContainingRecord (
   IN OUT PULONG64 pAddr,
   IN LPSTR        Type,
   IN LPSTR        Field
   )
{
   ULONG64 off;
   ULONG sz;

   sz = GetFieldOffset(Type, Field, &off);
   *pAddr -= off;
   return sz;
}
 **/

typedef struct THREAD_LIST_DUMP {
    ULONG dwProcessor;
    LPSTR pad;
    ULONG Flags;
} THREAD_LIST_DUMP;

ULONG
ThreadListCallback (
    PFIELD_INFO   NextThrd,
    PVOID         Context
    )
{
    THREAD_LIST_DUMP *Thread = (THREAD_LIST_DUMP *) Context;

    return (!DumpThread(Thread->dwProcessor, Thread->pad, NextThrd->address, Thread->Flags));
}

typedef struct PROCESS_DUMP_CONTEXT {
    ULONG   dwProcessor;
    PCHAR   Pad;
    ULONG   Flag;
    PCHAR   ImageFileName;
    BOOL    DumpCid;
    ULONG64 Cid;
    ULONG   SessionId;
} PROCESS_DUMP_CONTEXT;

ULONG
ProcessListCallback(
    PFIELD_INFO   listElement,
    PVOID         Context
    )
{
    PROCESS_DUMP_CONTEXT *ProcDumpInfo = (PROCESS_DUMP_CONTEXT *) Context;
    // address field contains the address of this process
    ULONG64    ProcAddress=listElement->address;
    ULONG ret;

    //
    // Dump the process for which this routine is called
    //
    if (ProcDumpInfo->DumpCid) {
        ULONG64 UniqId;

        GetFieldValue(ProcAddress, "nt!_EPROCESS", "UniqueProcessId", UniqId);

        if (UniqId != ProcDumpInfo->Cid) {
            return FALSE;
        }
    }

    // Limit dump to a single session if so requested.
    if (ProcDumpInfo->SessionId != -1) {
        ULONG SessionId;

        if (!GetProcessSessionId(ProcAddress, &SessionId) ||
            SessionId != ProcDumpInfo->SessionId) {
            return FALSE;
        }
    }

    if (ret = DumpProcess(ProcDumpInfo->Pad, listElement->address, ProcDumpInfo->Flag, ProcDumpInfo->ImageFileName)) {
        ULONG64 ProcFlink=0;
        if ((ProcDumpInfo->Flag & 6) && ret != -1) {
            //
            // Dump the threads
            //
            ULONG64 ThreadListHead_Flink=0;
            THREAD_LIST_DUMP Context = {ProcDumpInfo->dwProcessor, "        ", ProcDumpInfo->Flag};


            GetFieldValue(ProcAddress, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink", ThreadListHead_Flink);

            // dprintf("Listing threads, threadlist.flnik %p\n", ThreadListHead_Flink);

            // dprintf("Dumping threads from %I64x to %I64x + %x.\n", Next, RealProcessBase , ThreadListHeadOffset);
            ListType("nt!_ETHREAD", ThreadListHead_Flink, 1, "Tcb.ThreadListEntry.Flink", (PVOID) &Context, &ThreadListCallback);

            if (CheckControlC()) {
                return TRUE;
            }

        }
        if (CheckControlC()) {
            return TRUE;
        }

        GetFieldValue(ProcAddress, "nt!_EPROCESS", "ActiveProcessLinks.Flink", ProcFlink);
        // dprintf("Next proc flink %p, this addr %p\n", ProcFlink, listElement->address);
        return FALSE;
    }
    return TRUE;
}

DECLARE_API( process )

/*++

Routine Description:

    Dumps the active process list.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64 ProcessToDump;
    ULONG Flags = -1;
    ULONG64 Next;
    ULONG64 ProcessHead;
    ULONG64 Process;
    ULONG64 UserProbeAddress;
    PCHAR ImageFileName;
    CHAR  Buf[256];
    ULONG64 ActiveProcessLinksOffset=0;
    ULONG64 UniqueProcessId=0;
    PROCESS_DUMP_CONTEXT Proc={0, "", Flags, NULL, 0, 0};
    ULONG   dwProcessor=0;
    HANDLE  hCurrentThread=NULL;
    ULONG64 Expr;

    INIT_API();

    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }

    Proc.dwProcessor = dwProcessor;
    ProcessToDump = (ULONG64) -1;

    Proc.SessionId = -1;
    for (;;) {
        while (*args == ' ' || *args == '\t') {
            args++;
        }
        if (*args == '/') {

            switch(*(++args)) {
            case 's':
                args++;
                if (!GetExpressionEx(args, &Expr, &args)) {
                    dprintf("Invalid argument to /s\n");
                } else {
                    Proc.SessionId = (ULONG)Expr;
                }
                break;
            default:
                dprintf("Unknown option '%c'\n", *args);
                args++;
                break;
            }

        } else {
            break;
        }
    }

    RtlZeroMemory(Buf, 256);

    if (GetExpressionEx(args,&ProcessToDump, &args)) {
        if (sscanf(args, "%lx %255s", &Flags, Buf) != 2) {
            Buf[0] = 0;
        }
    }

    if (Buf[0] != '\0') {
        Proc.ImageFileName = Buf;
        ImageFileName      = Buf;
    } else {
        ImageFileName = NULL;
    }


    if (ProcessToDump == (ULONG64) -1) {
        GetCurrentProcessAddr( dwProcessor, 0, &ProcessToDump );
        if (ProcessToDump == 0) {
            dprintf("Unable to get current process pointer.\n");
            goto processExit;
        }
        if (Flags == -1) {
            Flags = 3;
        }
    }

    if (!IsPtr64()) {
        ProcessToDump = (ULONG64) (LONG64) (LONG) ProcessToDump;
    }

    if ((ProcessToDump == 0) &&  (ImageFileName == NULL)) {
        dprintf("**** NT ACTIVE PROCESS DUMP ****\n");
        if (Flags == -1) {
            Flags = 3;
        }
    }

    UserProbeAddress = GetNtDebuggerDataPtrValue(MmUserProbeAddress);

    if (!GetExpression("NT!PsActiveProcessHead")) {
        dprintf("NT symbols are incorrect, please fix symbols\n");
        goto processExit;
    }

    if (ProcessToDump < UserProbeAddress) {
        if (!GetProcessHead(&ProcessHead, &Next)) {
            goto processExit;
        }

        if (ProcessToDump != 0) {
            dprintf("Searching for Process with Cid == %I64lx\n", ProcessToDump);
            Proc.Cid = ProcessToDump; Proc.DumpCid = TRUE;
        }
    }
    else {
        Next = 0;
        ProcessHead = 1;
    }

    Proc.Flag = Flags;

    if (Next != 0) {
        //
        // Dump the process List
        //

        ListType("nt!_EPROCESS", Next, 1, "ActiveProcessLinks.Flink", &Proc, &ProcessListCallback);
        goto processExit;
    }
    else {
        Process = ProcessToDump;
    }

#if 0
    dprintf("Next: %I64x, \tProcess: %I64x, \n\tProcHead: %I64x\n",
            Next, Process, ProcessHead);
#endif

    if (GetFieldValue(Process, "nt!_EPROCESS", "UniqueProcessId", UniqueProcessId)) {
        dprintf("Error in reading nt!_EPROCESS at %p\n", Process);
        goto processExit;
    }

    if (ProcessToDump < UserProbeAddress && ProcessToDump == UniqueProcessId ||
        ProcessToDump >= UserProbeAddress && ProcessToDump == Process
        ) {
        FIELD_INFO dummyForCallback = {(PUCHAR) "", NULL, 0, 0, Process, NULL};

        ProcessListCallback(&dummyForCallback, &Proc);

        goto processExit;
    }
processExit:

    EXIT_API();
    return S_OK;
}

typedef struct _THREAD_FIND {
    ULONG64  StackPointer;
    ULONG    Cid;
    ULONG64  Thread;
} THREAD_FIND, *PTHREAD_FIND;

ULONG
FindThreadCallback(
    PFIELD_INFO  pAddrInfo,
    PVOID        Context
    )
{
    ULONG64 stackBaseValue=0, stackLimitValue=0;
    ULONG64 thread = pAddrInfo->address;
    THREAD_FIND *pThreadInfo = (THREAD_FIND *) Context;

    dprintf("Now checking thread 0x%p\r", thread);

    if (pThreadInfo->Cid != 0)
    {
        ULONG64 UniqueThread;

        if (!GetFieldValue(thread, "nt!_ETHREAD", "Cid.UniqueThread", UniqueThread))
        {
            if (UniqueThread == pThreadInfo->Cid)
            {
                pThreadInfo->Thread = thread;
                return TRUE;
            }
        }

    } else if (pThreadInfo->StackPointer != 0)
    {
        //
        // We need two values from the thread structure: the kernel thread
        // base and the kernel thread limit.
        //

        if (GetFieldValue(thread, "nt!_ETHREAD", "Tcb.StackBase",  stackBaseValue))
        {
            dprintf("Unable to get value of stack base of thread(0x%08p)\n",
                     thread);
            return TRUE;
        }

        if (pThreadInfo->StackPointer <= stackBaseValue)
        {

            if (GetFieldValue(thread, "nt!_ETHREAD", "Tcb.StackLimit", stackLimitValue))
            {
                dprintf("Unable to get value of stack limit\n");
                return TRUE;
            }
            if (pThreadInfo->StackPointer >  stackLimitValue)
            {

                //
                // We have found our thread.
                //

                pThreadInfo->Thread = thread;
                return TRUE;
            }
        }
    }


    //
    // Look at the next thread
    //

    return FALSE;  // Continue list
}

ULONG64
FindThreadInProcess(
    PTHREAD_FIND pFindThreadParam,
    ULONG64 Process
    )
{
    LIST_ENTRY64 listValue={0};

    //
    //  Read the ThreadListHead within Process structure
    //

    GetFieldValue(Process, "nt!_EPROCESS", "ThreadListHead.Flink", listValue.Flink);
    GetFieldValue(Process, "nt!_EPROCESS", "ThreadListHead.Blink", listValue.Blink);

    //
    // Go through thread list, and try to find thread
    //
    ListType("nt!_ETHREAD", listValue.Flink, 1, "ThreadListEntry.Flink", (PVOID) pFindThreadParam, &FindThreadCallback);

    return pFindThreadParam->Thread;
}

ULONG64
FindThreadFromStackPointerThisProcess(
    ULONG64 StackPointer,
    ULONG64 Process
    )
{
    LIST_ENTRY64 listValue={0};
    THREAD_FIND ThreadFindContext = {0};

    ThreadFindContext.StackPointer = StackPointer;
    ThreadFindContext.Thread = 0;

    //
    //  Read the ThreadListHead within Process structure
    //

    GetFieldValue(Process, "nt!_EPROCESS", "ThreadListHead.Flink", listValue.Flink);
    GetFieldValue(Process, "nt!_EPROCESS", "ThreadListHead.Blink", listValue.Blink);

    //
    // Go through thread list, and try to find thread
    //
    ListType("nt!_ETHREAD", listValue.Flink, 1, "ThreadListEntry.Flink", (PVOID) &ThreadFindContext, &FindThreadCallback);

    return ThreadFindContext.Thread;
}



ULONG64
FindThread(
    PTHREAD_FIND pFindThreadParam
    )
{
    ULONG64 processHead;
    ULONG64   list;
    LIST_ENTRY64 listValue={0};
    ULONG64    next;
    ULONG64   process=0;
    ULONG64   thread;
    ULONG   ActiveProcessLinksOffset=0;

    //
    // First check the idle process, which is not included in the PS
    // process list.
    //


    process = GetExpression( "NT!KeIdleProcess" );
    if (process != 0) {

        if (ReadPointer( process,
                     &process)) {

            thread = FindThreadInProcess( pFindThreadParam,
                                          process );

            if (thread != 0) {
                return thread;
            }
        }
    }

    //
    // Now check the PS process list.
    //

    list = GetNtDebuggerData( PsActiveProcessHead );
    if (list == 0) {
        dprintf("Unable to get address of PsActiveProcessHead\n");
        return 0;
    }

    if (!ReadPointer( list,
                 &listValue.Flink)) {
        dprintf("Unable to read @ %p\n", list);
        return 0;
    }

    next = listValue.Flink;
    processHead = list;

    //
    // Get Offset of ProcessLinks
    //
    GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActiveProcessLinksOffset);

    while (next != processHead) {

        if (CheckControlC()) {
            return 0;
        }

        //
        // Derive a pointer to the process structure
        //

        process = next - ActiveProcessLinksOffset;

        thread = FindThreadInProcess( pFindThreadParam,
                                      process );
        if (thread != 0) {

            //
            // We have found the thread which matches pFindThreadParam parameters
            //

            return thread;
        }

        //
        // Get a pointer to the next process
        //

        if (!ReadPointer(next, &listValue.Flink) ||
            !listValue.Flink)
        {
            dprintf("Unable to read next process from process list\n");
            return 0;
        }
        next = listValue.Flink;
    }

    return 0;
}

DECLARE_API( thread )

/*++

Routine Description:

    Dumps the specified thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64     Address, Tcb_Header_Type=0;
    ULONG64       Flags;
    ULONG64     Thread;
    ULONG64     UserProbeAddress;
    ULONG       dwProcessor;
    HANDLE      hCurrentThread;
    CHAR        Token[100];
    BOOL        DumpByCid = FALSE;
    THREAD_FIND ThreadFind = {0};


    INIT_API();

    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }

    while ((*args == ' ' || *args == '\t') && *args != '-') ++args;
    if (*args == '-')
    {
        ++args;
        switch (*args)
        {
        case 't':
            {
                DumpByCid = TRUE;
                break;
            }
        default:
            {
                dprintf("Bad argument -%s\n", args);
                goto threadExit;
            }
        }
        ++args;
    }


    if (!GetExpressionEx(args, &Address, &args))
    {
        Address = (ULONG64)-1;
    }

    if (!GetExpressionEx(args, &Flags, &args))
    {
        Flags = 6;
    }

    if (Address == (ULONG64)-1) {
        GetCurrentThreadAddr( dwProcessor, &Address );
    }

    UserProbeAddress = GetNtDebuggerDataPtrValue(MmUserProbeAddress);

    Thread = Address;

    if (DumpByCid)
    {
        ThreadFind.Cid = (ULONG) Address;
        dprintf("Looking for thread Cid = %p ...\n", ThreadFind.Cid);
        Thread = FindThread(&ThreadFind);
    }

    if (GetFieldValue(Thread, "nt!_ETHREAD", "Tcb.Header.Type", Tcb_Header_Type)) {
        dprintf("%08lp: Unable to get thread contents\n", Thread );
        goto threadExit;
    }

    if (Tcb_Header_Type != ThreadObject &&
        Address > UserProbeAddress) {

        ULONG64 stackThread;

        //
        // What was passed in was not a thread.  Maybe it was a kernel stack
        // pointer.  Search the thread stack ranges to find out.
        //

        dprintf("%p is not a thread object, interpreting as stack value...\n",Address);
        ThreadFind.StackPointer = Address;
        ThreadFind.Cid = 0;
        stackThread = FindThread( &ThreadFind );
        if (stackThread != 0) {
            Thread = stackThread;
        }
    }

    DumpThread (dwProcessor,"", Thread, Flags);
    EXPRLastDump = Thread;
    ThreadLastDump = Thread;

threadExit:

    EXIT_API();
    return S_OK;

}

DECLARE_API( processfields )

/*++

Routine Description:

    Displays the field offsets for EPROCESS type.

Arguments:

    None.

Return Value:

    None.

--*/

{

    dprintf(" EPROCESS structure offsets: (use 'dt nt!_EPROCESS')\n\n");
    return S_OK;
}


DECLARE_API( threadfields )

/*++

Routine Description:

    Displays the field offsets for ETHREAD type.

Arguments:

    None.

Return Value:

    None.

--*/

{

    dprintf(" ETHREAD structure offsets: (use 'dt ETHREAD')\n\n");
    return S_OK;

}


//+---------------------------------------------------------------------------
//
//  Function:   GetHandleTableAddress
//
//  Synopsis:   Return the address of the handle table given a thread handle
//
//  Arguments:  [Processor]      -- processor number
//              [hCurrentThread] -- thread handle
//
//  Returns:    address of handle table or null
//
//  History:    9-23-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG64 GetHandleTableAddress(
    USHORT Processor,
    HANDLE hCurrentThread
    )
{
    ULONG64   pThread;
    ULONG64   pProcess = 0, pObjTable;

    GetCurrentThreadAddr( Processor, &pThread );
    if (pThread) {
        GetCurrentProcessAddr( Processor, pThread, &pProcess );
    }

    if (pProcess) {
        if (GetFieldValue(pProcess, "nt!_EPROCESS", "ObjectTable", pObjTable) ) {
            dprintf("%08p: Unable to read _EPROCESS\n", pProcess );
            return 0;
        }

        return  pObjTable;
    } else
    {
        return 0;
    }
} // GetHandleTableAddress


#if 0

BOOLEAN
FetchProcessStructureVariables(
    VOID
    )
{
    ULONG Result;
    ULONG64 t;

    static BOOLEAN HavePspVariables = FALSE;

    if (HavePspVariables) {
        return TRUE;
    }

    t=GetNtDebuggerData( PspCidTable );
    PspCidTable = (PHANDLE_TABLE) t;
    if ( !PspCidTable ||
         !ReadMemory((DWORD)PspCidTable,
                     &PspCidTable,
                     sizeof(PspCidTable),
                     &Result) ) {
        dprintf("%08lx: Unable to get value of PspCidTable\n",PspCidTable);
        return FALSE;
    }

    HavePspVariables = TRUE;
    return TRUE;
}


PVOID
LookupUniqueId(
    HANDLE UniqueId
    )
{
    return NULL;
}

#endif

int
__cdecl
CmpFunc(
    const void *pszElem1,
    const void *pszElem2
    )
{
    PPROCESS_COMMIT_USAGE p1, p2;

    p1 = (PPROCESS_COMMIT_USAGE)pszElem1;
    p2 = (PPROCESS_COMMIT_USAGE)pszElem2;
    if (p2->CommitCharge == p1->CommitCharge) {
        ((char*)p2->ClientId - (char*)p1->ClientId);
    }
    return  (ULONG) (p2->CommitCharge - p1->CommitCharge);
}

PPROCESS_COMMIT_USAGE
GetProcessCommit (
    PULONG64 TotalCommitCharge,
    PULONG   NumberOfProcesses
    )
{
    PPROCESS_COMMIT_USAGE p, oldp;
    ULONG n;
    ULONG64 Next;
    ULONG64 ProcessHead;
    ULONG64 Process;
    ULONG64 Total;
    ULONG   Result;
    ULONG   ActiveProcessLinksOffset;

    *TotalCommitCharge = 0;
    *NumberOfProcesses = 0;

    // Get the offset of ActiveProcessLinks in _EPROCESS
    if (GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActiveProcessLinksOffset)) {
       return NULL;
    }

    Total = 0;

    n = 0;
    p = (PPROCESS_COMMIT_USAGE) HeapAlloc( GetProcessHeap(), 0, 1 );
    if (p == NULL) {
        dprintf("Unable to allocate memory\n");
        return NULL;
    }

    ProcessHead = GetNtDebuggerData( PsActiveProcessHead );
    if (!ProcessHead) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        HeapFree(GetProcessHeap(), 0, p);
        return NULL;
    }

    if (GetFieldValue( ProcessHead, "nt!_LIST_ENTRY", "Flink", Next ) ||
        !Next)
    {
        dprintf("Unable to read/NULL value _LIST_ENTRY @ %p\n", ProcessHead);
        HeapFree(GetProcessHeap(), 0, p);
        return NULL;
    }

    while(Next != ProcessHead) {
        ULONG64 CommitCharge=0, NumberOfPrivatePages=0, NumberOfLockedPages=0;
        Process = Next - ActiveProcessLinksOffset;

        if (GetFieldValue( Process, "nt!_EPROCESS", "CommitCharge", CommitCharge )) {
            dprintf("Unable to read _EPROCESS at %p\n",Process);
            HeapFree(GetProcessHeap(), 0, p);
            return NULL;
        }

        Total += CommitCharge;

        n += 1;
        oldp = p;
        p = (PPROCESS_COMMIT_USAGE) HeapReAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, oldp, n * sizeof( *p ) );
        if (p == NULL) {

            HeapFree(GetProcessHeap(), 0, oldp);
            dprintf("Unable to allocate memory\n");
            return NULL;
        }

        p[n-1].ProcessAddress = Process;
        GetFieldValue( Process, "nt!_EPROCESS", "ImageFileName",
                       p[ n-1 ].ImageFileName );
        GetFieldValue( Process, "nt!_EPROCESS", "NumberOfPrivatePages",
                       p[ n-1 ].NumberOfPrivatePages );
        GetFieldValue( Process, "nt!_EPROCESS", "NumberOfLockedPages",
                       p[ n-1 ].NumberOfLockedPages );
        GetFieldValue( Process, "nt!_EPROCESS", "UniqueProcessId",
                       p[ n-1 ].ClientId );
        p[ n-1 ].CommitCharge = CommitCharge;

        GetFieldValue(Process, "nt!_EPROCESS", "ActiveProcessLinks.Flink", Next);

        if (CheckControlC()) {
            HeapFree(GetProcessHeap(), 0, p);
            return NULL;
        }
    }

    qsort( p, n, sizeof( *p ), CmpFunc );

    *TotalCommitCharge = Total;
    *NumberOfProcesses = n;
    return p;
}

BOOL
DumpJob(
    ULONG64 RealJobBase,
    ULONG   Flags
    )
{
    ULONG64 ProcessListHead_Flink=0, TotalPageFaultCount=0, TotalProcesses=0, ActiveProcesses=0,
       TotalTerminatedProcesses=0, LimitFlags=0, MinimumWorkingSetSize=0,
       MaximumWorkingSetSize=0, ActiveProcessLimit=0, PriorityClass=0,
       UIRestrictionsClass=0, SecurityLimitFlags=0, Token=0, Filter=0;
    ULONG64 Filter_SidCount=0, Filter_Sids=0, Filter_SidsLength=0, Filter_GroupCount=0,
       Filter_Groups=0, Filter_GroupsLength=0, Filter_PrivilegeCount=0, Filter_Privileges=0,
       Filter_PrivilegesLength=0;
    ULONG ProcessListHeadOffset;

    GetFieldValue(RealJobBase, "nt!_EJOB", "ActiveProcesses",          ActiveProcesses);
    GetFieldValue(RealJobBase, "nt!_EJOB", "ActiveProcessLimit",       ActiveProcessLimit);
    GetFieldValue(RealJobBase, "nt!_EJOB", "Filter",                   Filter);
    GetFieldValue(RealJobBase, "nt!_EJOB", "LimitFlags",               LimitFlags);
    GetFieldValue(RealJobBase, "nt!_EJOB", "MinimumWorkingSetSize",    MinimumWorkingSetSize);
    GetFieldValue(RealJobBase, "nt!_EJOB", "MaximumWorkingSetSize",    MaximumWorkingSetSize);
    GetFieldValue(RealJobBase, "nt!_EJOB", "PriorityClass",            PriorityClass);
    GetFieldValue(RealJobBase, "nt!_EJOB", "ProcessListHead.Flink",    ProcessListHead_Flink);
    GetFieldValue(RealJobBase, "nt!_EJOB", "SecurityLimitFlags",       SecurityLimitFlags);
    GetFieldValue(RealJobBase, "nt!_EJOB", "Token",                    Token);
    GetFieldValue(RealJobBase, "nt!_EJOB", "TotalPageFaultCount",      TotalPageFaultCount);
    GetFieldValue(RealJobBase, "nt!_EJOB", "TotalProcesses",           TotalProcesses);
    GetFieldValue(RealJobBase, "nt!_EJOB", "TotalTerminatedProcesses", TotalTerminatedProcesses);
    GetFieldValue(RealJobBase, "nt!_EJOB", "UIRestrictionsClass",      UIRestrictionsClass);

    if (GetFieldOffset("_EJOB", "ProcessListHead", &ProcessListHeadOffset)) {
       dprintf("Can't read job at %p\n", RealJobBase);
    }
    if ( Flags & 1 )
    {
        dprintf("Job at %p\n", RealJobBase );
        dprintf("  TotalPageFaultCount      %x\n", TotalPageFaultCount );
        dprintf("  TotalProcesses           %x\n", TotalProcesses );
        dprintf("  ActiveProcesses          %x\n", ActiveProcesses );
        dprintf("  TotalTerminatedProcesses %x\n", TotalTerminatedProcesses );

        dprintf("  LimitFlags               %x\n", LimitFlags );
        dprintf("  MinimumWorkingSetSize    %I64x\n", MinimumWorkingSetSize );
        dprintf("  MaximumWorkingSetSize    %I64x\n", MaximumWorkingSetSize );
        dprintf("  ActiveProcessLimit       %x\n", ActiveProcessLimit );
        dprintf("  PriorityClass            %x\n", PriorityClass );

        dprintf("  UIRestrictionsClass      %x\n", UIRestrictionsClass );

        dprintf("  SecurityLimitFlags       %x\n", SecurityLimitFlags );
        dprintf("  Token                    %p\n", Token );
        if ( Filter )
        {
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedSidCount",        Filter_SidCount );
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedSids",            Filter_Sids );
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedSidsLength",      Filter_SidsLength);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedGroupCount",      Filter_GroupCount);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedGroups",          Filter_Groups);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedGroupsLength",    Filter_GroupsLength);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedPrivilegeCount",  Filter_PrivilegeCount);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedPrivileges",      Filter_Privileges);
            GetFieldValue(Filter, "nt!_PS_JOB_TOKEN_FILTER", "CapturedPrivilegesLength",Filter_PrivilegesLength);

            dprintf("  Filter\n");
            dprintf("    CapturedSidCount       %I64x\n", Filter_SidCount );
            dprintf("    CapturedSids           %p\n", Filter_Sids );
            dprintf("    CapturedSidsLength     %I64x\n", Filter_SidsLength );
            dprintf("    CapturedGroupCount     %I64x\n", Filter_GroupCount );
            dprintf("    CapturedGroups         %p\n", Filter_Groups );
            dprintf("    CapturedGroupsLength   %I64x\n", Filter_GroupsLength );
            dprintf("    CapturedPrivCount      %I64x\n", Filter_PrivilegeCount );
            dprintf("    CapturedPrivs          %p\n", Filter_Privileges );
            dprintf("    CapturedPrivLength     %I64x\n", Filter_PrivilegesLength );
        }

    }

    if ( Flags & 2 )
    {
        //
        // Walk the process list for all the processes in the job
        //

        ULONG64 Scan, End;
        ULONG   offset ;
        ULONG64 ProcessBase, NextPrc=0 ;

        dprintf("  Processes assigned to this job:\n" );

        Scan = ProcessListHead_Flink ;
        End = ProcessListHeadOffset + RealJobBase;

        if (!GetFieldOffset("nt!_EPROCESS", "JobLinks", &offset)) {
            while ( Scan != End )
                {
                ProcessBase = Scan - offset;

                DumpProcess( "    ", ProcessBase, 0, NULL);

                if (!GetFieldValue(ProcessBase, "nt!_EPROCESS", "JobLinks.Flink", NextPrc)) {
                    Scan = NextPrc;
                } else {
                    Scan = End;
                }
            }
        }
    }
    return TRUE ;
}

DECLARE_API( job )

/*++

Routine Description:

    Dumps the specified thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG64     Address, JobAddress=0;
    ULONG       Flags;
    ULONG       dwProcessor;
    HANDLE      hCurrentThread;

    INIT_API();

    if (!GetCurrentProcessor(Client, &dwProcessor, &hCurrentThread)) {
        dwProcessor = 0;
        hCurrentThread = 0;
    }

    Address = 0;
    Flags = 1;
    if (GetExpressionEx(args,&Address,&args)) {
        Flags = (ULONG) GetExpression(args);
        if (!Flags) {
            Flags = 1;
        }
    }

    if (Address == 0) {

        GetCurrentProcessAddr( dwProcessor, 0, &Address );
        if (Address == 0) {
            dprintf("Unable to get current process pointer.\n");
            goto jobExit;
        }

        if (GetFieldValue(Address, "nt!_EPROCESS", "Job", JobAddress)) {
           dprintf("%08p: Unable to get process contents\n", Address );
           goto jobExit;
        }
        Address = JobAddress;
        if ( Address == 0 )
        {
            dprintf("Process not part of a job.\n" );
            goto jobExit;
        }
    }


    DumpJob( Address, Flags );

jobExit:

    EXIT_API();
    return S_OK;

}

DECLARE_API( running )

/*++

Routine Description:

    This routine dumps lists the running threads in the system.

Arguments:

    -i include idle processors
    -t print stack trace for each processor

Return Value:

    None.

--*/

{
#define LOCK_ENTRIES 16
    ULONG64 Address;
    ULONG64 ActiveProcessors = 0;
    ULONG64 IdleProcessors = 0;
    ULONG   i;
    ULONG64 j;
    ULONG   l;
    ULONG   n;
    ULONG64 Prcb;
    ULONG64 CurrentThread;
    ULONG64 NextThread;
    ULONG64 KiProcessorBlock;
    ULONG   SizeofPointer;
    ULONG   SizeofLockEntry;
    ULONG   LockQueueOffset;
    UCHAR   LockState[LOCK_ENTRIES+1];
    ULONG64 Lock;
    BOOLEAN DoIdle = FALSE;
    BOOLEAN DoTrace = FALSE;
    char *  PointerPadd = "";
    UCHAR   c;
    BOOLEAN ParseError = FALSE;
    BOOLEAN DashSeen = FALSE;
    CHAR    TraceCommand[5];

    INIT_API();

    //
    // Parse arguments.
    //
    // Allow -t and/or -i, allow to be run together, "-" is not required.
    //

    while (((c = *args++) != '\0') && (ParseError == FALSE)) {
        switch (c) {
        case '-':
            if (DashSeen) {
                ParseError = TRUE;
                break;
            }
            DashSeen = TRUE;
            break;
        case 't':
        case 'T':
            if (DoTrace) {
                ParseError = TRUE;
                break;
            }
            DoTrace = TRUE;
            break;
        case 'i':
        case 'I':
            if (DoIdle) {
                ParseError = TRUE;
                break;
            }
            DoIdle = TRUE;
            break;
        case ' ':
        case '\t':
            DashSeen = FALSE;
            break;
        default:
            ParseError = TRUE;
            break;
        }
    }

    if (ParseError) {
        dprintf("usage: !running [-t] [-i]\n");
        goto runningExit;
    }


    //
    // Get KeActiveProcessors and KiIdleSummary.
    //

    Address = GetExpression("nt!KeActiveProcessors");
    if (!Address) {
        dprintf("Could not get processor configuration, exiting.\n");
        goto runningExit;
    }

    if (!ReadPointer(Address, &ActiveProcessors) || (ActiveProcessors == 0)) {
        dprintf("Unable to get active processor set.  Cannot continue.\n");
        goto runningExit;
    }

    Address = GetExpression("nt!KiIdleSummary");
    if ((Address == 0) ||
        (!ReadPointer(Address, &IdleProcessors))) {
        dprintf("Could not get idle processor set, exiting.\n");
        goto runningExit;
    }

    dprintf("\n");
    dprintf("System Processors %I64x (affinity mask)\n", ActiveProcessors);
    dprintf("  Idle Processors %I64x\n", IdleProcessors);

    if (ActiveProcessors == IdleProcessors) {
        dprintf("All processors idle.\n");
        if (!DoIdle) {
            goto runningExit;
        }
    }

    //
    // Get the address of KiProcessorBlock which is an array of pointers
    // to the PRCB for each processor.
    //

    KiProcessorBlock = GetExpression("nt!KiProcessorBlock");
    if (KiProcessorBlock == 0) {
        dprintf("Could not get address of KiProcessorBlock, exiting.\n");
        goto runningExit;
    }

    //
    // Is the target 64 bits or 32?
    //

    SizeofPointer = DBG_PTR_SIZE;
    if ((SizeofPointer != 8) && (SizeofPointer != 4)) {
        dprintf("Could not determine size of pointer on target system.\n");
        goto runningExit;
    }

    //
    // Get the size of a Prcb->LockQueue entry, and the offset to the
    // LockQueue in the PRCB.
    //

    SizeofLockEntry = GetTypeSize("nt!KSPIN_LOCK_QUEUE");
    if (!SizeofLockEntry) {
        dprintf("Could not determine size of KSPIN_LOCK_QUEUE on target.\n");
        goto runningExit;
    }
    GetFieldOffset("nt!_KPRCB", "LockQueue", &LockQueueOffset);
    if (!LockQueueOffset) {
        dprintf("Couldn't determine offset of LockQueue field in KPRCB.\n");
        goto runningExit;
    }

    //
    // Print header.   If 64 bit target, add 8 blanks spacing.
    //

    if (SizeofPointer == 8) {
        PointerPadd = "        ";
    }

    dprintf("\n     Prcb    %s", PointerPadd);
    dprintf("  Current %s", PointerPadd);
    dprintf("  Next    %s", PointerPadd);
    dprintf("\n");

    //
    // Put terminating NULL in lock state string.
    //

    LockState[LOCK_ENTRIES] = '\0';

    //
    // For each processor in the system.
    //

    for (i = 0, j = 1; ActiveProcessors; i++, j <<= 1UI64) {

        //
        // Does this processor exist?
        //

        if ((ActiveProcessors & j) != 0) {

            //
            // Remove it from the list of processors to be examined.
            //

            ActiveProcessors ^= j;

            //
            // If not listing idle processors, skip this guy if it's idle.
            //

            if ((DoIdle == FALSE) &&
                (IdleProcessors & j)) {
                continue;
            }

            //
            // Get the PRCB for this processor, then get the CurrentThread
            // and NextThread fields.
            //

            if ((!ReadPointer(KiProcessorBlock + (i * SizeofPointer), &Prcb)) ||
                (Prcb == 0)) {
                dprintf("Couldn't get PRCB for processor %d.\n", i);
                goto runningExit;
            }

            GetFieldValue(Prcb, "nt!_KPRCB", "CurrentThread", CurrentThread);
            GetFieldValue(Prcb, "nt!_KPRCB", "NextThread", NextThread);

            //
            // For each queued spinlock in the PRCB, summarize state.
            //

            Address = Prcb + LockQueueOffset;
            for (l = 0; l < LOCK_ENTRIES; l++) {
                GetFieldValue(Address + (l * SizeofLockEntry),
                              "nt!KSPIN_LOCK_QUEUE",
                              "Lock",
                              Lock);
                n = (ULONG)(Lock & 0x3);
                switch (n) {
                case  0: LockState[l] = '.'; break;
                case  1: LockState[l] = 'W'; break;
                case  2: LockState[l] = 'O'; break;
                default: LockState[l] = '?'; break;
                }
            }

            if (SizeofPointer == 4) {

                //
                // Trim sign extended addresses.
                //

                Prcb          &= 0xffffffff;
                CurrentThread &= 0xffffffff;
                NextThread    &= 0xffffffff;
            }
            dprintf("%3d  %I64x  %I64x  ",
                    i,
                    Prcb,
                    CurrentThread);
            if (NextThread) {
                dprintf("%I64x  ", NextThread);
            } else {
                dprintf("          %s", PointerPadd);
            }
            dprintf("%s", LockState);
            dprintf("\n");
            if (DoTrace) {
                dprintf("\n");
                sprintf(TraceCommand, "%dk", i);
                ExecuteCommand(Client, TraceCommand);
                dprintf("\n");
            }
        }
    }
    if (!DoTrace) {
        dprintf("\n");
    }

runningExit:

    EXIT_API();
    return S_OK;
}

ULONG64 ZombieCount;
ULONG64 ZombiePool;
ULONG64 ZombieCommit;
ULONG64 ZombieResidentAvailable;

#define BLOB_LONGS 32

BOOLEAN WINAPI
CheckForZombieProcess(
    IN PCHAR Tag,
    IN PCHAR Filter,
    IN ULONG Flags,
    IN ULONG64 PoolHeader,
    IN ULONG64 BlockSize,
    IN ULONG64 Data,
    IN PVOID Context
    )
{
    ULONG           result;
  //  EPROCESS        ProcessContents;
    ULONG64         Process;
    ULONG64         KProcess;
    //OBJECT_HEADER   ObjectHeaderContents;
    ULONG64         ObjectHeader;
    ULONG64         Blob[BLOB_LONGS];
    ULONG           i;
    ULONG           PoolIndex, PoolBlockSize, SizeOfKprocess;
    ULONG           HandleCount, PointerCount;
    ULONG64         UniqueProcessId;

    UNREFERENCED_PARAMETER (Flags);
    UNREFERENCED_PARAMETER (BlockSize);
    UNREFERENCED_PARAMETER (Context);

    if (PoolHeader == 0) {
        return FALSE;
    }

    if (GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex) ||
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", PoolBlockSize)) {
        dprintf("Cannot read nt!_POOL_HEADER at %p.\n", PoolHeader);
        return FALSE;
    }

    if ((PoolIndex & 0x80) == 0) {
        return FALSE;
    }

    if (!CheckSingleFilter (Tag, Filter)) {
        return FALSE;
    }

    if ((PoolBlockSize << POOL_BLOCK_SHIFT) < sizeof(Blob)) {
        return FALSE;
    }

    //
    // There must be a better way to find the object header given the start
    // of a pool block ?
    //

    if (!ReadMemory (Data,
                     &Blob[0],
                     sizeof(Blob),
                     &result)) {
        dprintf ("Could not read process blob at %p\n", Data);
        return FALSE;
    }
    SizeOfKprocess = GetTypeSize("nt!_KPROCESS");
    for (i = 0; i < BLOB_LONGS; i += 1) {
        ULONG Type, Size;

        GetFieldValue(Data + i*sizeof(ULONG), "nt!_KPROCESS",  "Header.Type", Type);
        GetFieldValue(Data + i*sizeof(ULONG), "nt!_KPROCESS",  "Header.Size", Size);
        if ((Type == ProcessObject) &&
            (Size == SizeOfKprocess / sizeof(LONG))) {

            break;
        }
    }

    if (i == BLOB_LONGS) {
        return FALSE;
    }

    ObjectHeader = KD_OBJECT_TO_OBJECT_HEADER (Data + i*sizeof(LONG));
    Process = Data + i*sizeof(LONG);

    if (GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "HandleCount",HandleCount) ||
        GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "PointerCount",PointerCount) ) {
        dprintf ("Could not read process object header at %p\n", ObjectHeader);
        return FALSE;
    }


    if (GetFieldValue( Process,
                      "nt!_EPROCESS",
                       "UniqueProcessId",
                       UniqueProcessId)) {

        dprintf ("Could not read process data at %p\n", Process);
        return FALSE;
    }

    //
    // Skip the system process and the idle process.
    //

    if ((UniqueProcessId == 0) ||
        (UniqueProcessId == 8)) {
        return FALSE;
    }

    //
    // Display any terminated process regardless of object pointer/handle
    // counts.  This is so leaked process handles don't result in processes
    // not getting displayed when they should.
    //
    // A nulled object table with a non-zero create time indicates a process
    // that has finished creation.
    //

    InitTypeRead(Process, nt!_EPROCESS);
    if ((ReadField(ObjectTable) == 0) &&
        (ReadField(CreateTime.QuadPart) != 0)) {

        dprintf ("HandleCount: %u  PointerCount: %u\n",
                HandleCount, PointerCount);
        DumpProcess ("", Process, 0, NULL);

        ZombieCount += 1;
        ZombiePool += ((ULONG64) PoolBlockSize << POOL_BLOCK_SHIFT);
        ZombieCommit += (7 * PageSize);               // MM_PROCESS_COMMIT_CHARGE
        ZombieResidentAvailable += (9 * PageSize);    // MM_PROCESS_CREATE_CHARGE
    }

    return TRUE;
}

BOOLEAN WINAPI
CheckForZombieThread(
    IN PCHAR Tag,
    IN PCHAR Filter,
    IN ULONG Flags,
    IN ULONG64 PoolHeader,
    IN ULONG64 BlockSize,
    IN ULONG64 Data,
    IN PVOID Context
    )
{
    ULONG           result;
    ULONG64         Thread;
    ULONG64         KThread;
    ULONG64         ObjectHeader;
    ULONG           Blob[BLOB_LONGS];
    ULONG           i;
    ULONG64         StackBase;
    ULONG64         StackLimit;
    ULONG           PoolIndex, PoolBlockSize, SizeOfKthread;
    ULONG           HandleCount, PointerCount;

    UNREFERENCED_PARAMETER (Flags);
    UNREFERENCED_PARAMETER (BlockSize);
    UNREFERENCED_PARAMETER (Context);

    if (PoolHeader == 0) {
        return FALSE;
    }

    if (GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex) ||
        GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "BlockSize", PoolBlockSize)) {
        dprintf("Cannot read POOL_HEADER at %p.\n", PoolHeader);
        return FALSE;
    }

    if ((PoolIndex & 0x80) == 0) {
        return FALSE;
    }

    if (!CheckSingleFilter (Tag, Filter)) {
        return FALSE;
    }

    if ((PoolBlockSize << POOL_BLOCK_SHIFT) < sizeof(Blob)) {
        return FALSE;
    }

    //
    // There must be a better way to find the object header given the start
    // of a pool block ?
    //

    if (!ReadMemory ((ULONG) Data,
                    &Blob[0],
                    sizeof(Blob),
                    &result)) {
        dprintf ("Could not read process blob at %p\n", Data);
        return FALSE;
    }
    SizeOfKthread = GetTypeSize("nt!_KTHREAD");
    for (i = 0; i < BLOB_LONGS; i += 1) {
        ULONG Type, Size;

        GetFieldValue(Data + i*sizeof(ULONG), "nt!_KTHREAD",  "Header.Type", Type);
        GetFieldValue(Data + i*sizeof(ULONG), "nt!_KTHREAD",  "Header.Size", Size);
        if ((Type == ThreadObject) &&
            (Size == SizeOfKthread / sizeof(LONG))) {

            break;
        }
    }

    if (i == BLOB_LONGS) {
        return FALSE;
    }

    ObjectHeader = KD_OBJECT_TO_OBJECT_HEADER (Data + i*sizeof(LONG));
    Thread = Data + i*sizeof(LONG);

    if (GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "HandleCount",HandleCount) ||
        GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "PointerCount",PointerCount) ) {
        dprintf ("Could not read process object header at %p\n", ObjectHeader);
        return FALSE;
    }

    if (GetFieldValue( Thread,
                       "nt!_ETHREAD",
                       "Tcb.StackLimit",
                       StackLimit)) {

        dprintf ("Could not read thread data at %p\n", Thread);
        return FALSE;
    }

    InitTypeRead(Thread, KTHREAD);

    if ((ULONG) ReadField(State) != Terminated) {
        return FALSE;
    }

    ZombieCount += 1;

    ZombiePool += ((ULONG64) PoolBlockSize << POOL_BLOCK_SHIFT);
    ZombieCommit += (ReadField(StackBase) - StackLimit);

    StackBase = (ReadField(StackBase) - 1);

    dprintf ("HandleCount: %u  PointerCount: %u\n",
            HandleCount, PointerCount);
    DumpThread (0, "", Thread, 7);


    while (StackBase >= StackLimit) {
        if (GetAddressState(StackBase) == ADDRESS_VALID) {
            ZombieResidentAvailable += PageSize;
        }
        StackBase = (StackBase - PageSize);
    }

    return TRUE;
}

DECLARE_API( zombies )

/*++

Routine Description:

    Finds zombie processes and threads in non-paged pool.

Arguments:

    None.

Return Value:

    None.

--*/


{
    ULONG       Flags;
    ULONG64     RestartAddress;
    ULONG       TagName;
    ULONG64     ZombieProcessCount;
    ULONG64     ZombieProcessPool;
    ULONG64     ZombieProcessCommit;
    ULONG64     ZombieProcessResidentAvailable;
    ULONG64     tmp;

    INIT_API();
    Flags = 1;
    RestartAddress = 0;

    if (GetExpressionEx(args,&tmp, &args)) {
        RestartAddress = GetExpression(args);
        Flags = (ULONG) tmp;
    }

    if ((Flags & 0x3) == 0) {
        dprintf("Invalid parameter for !zombies\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if (Flags & 0x1) {

        dprintf("Looking for zombie processes...");

        TagName = '?orP';

        ZombieCount = 0;
        ZombiePool = 0;
        ZombieCommit = 0;
        ZombieResidentAvailable = 0;

        SearchPool (TagName, 0, RestartAddress, &CheckForZombieProcess, NULL);
        SearchPool (TagName, 2, RestartAddress, &CheckForZombieProcess, NULL);

        ZombieProcessCount = ZombieCount;
        ZombieProcessPool = ZombiePool;
        ZombieProcessCommit = ZombieCommit;
        ZombieProcessResidentAvailable = ZombieResidentAvailable;
    }

    if (Flags & 0x2) {

        dprintf("Looking for zombie threads...");

        TagName = '?rhT';

        ZombieCount = 0;
        ZombiePool = 0;
        ZombieCommit = 0;
        ZombieResidentAvailable = 0;

        SearchPool (TagName, 0, RestartAddress, &CheckForZombieThread, NULL);
        SearchPool (TagName, 2, RestartAddress, &CheckForZombieThread, NULL);

    }

    //
    // Print summary statistics last so they don't get lost on screen scroll.
    //

    if (Flags & 0x1) {
        if (ZombieProcessCount == 0) {
            dprintf ("\n\n************ NO zombie processes found ***********\n");
        }
        else {
            dprintf ("\n\n************ %d zombie processes found ***********\n", ZombieProcessCount);
            dprintf ("       Resident page cost : %8ld Kb\n",
                ZombieProcessResidentAvailable / 1024);
            dprintf ("       Commit cost :        %8ld Kb\n",
                ZombieProcessCommit / 1024);
            dprintf ("       Pool cost :          %8ld bytes\n",
                ZombieProcessPool);
        }
        dprintf ("\n");
    }

    if (Flags & 0x2) {
        if (ZombieCount == 0) {
            dprintf ("\n\n************ NO zombie threads found ***********\n");
        }
        else {
            dprintf ("\n\n************ %d zombie threads found ***********\n", ZombieCount);
            dprintf ("       Resident page cost : %8ld Kb\n",
                ZombieResidentAvailable / 1024);
            dprintf ("       Commit cost :        %8ld Kb\n",
                ZombieCommit / 1024);
            dprintf ("       Pool cost :          %8ld bytes\n",
                ZombiePool);
        }
    }

    EXIT_API();
    return S_OK;
}

VOID
DumpMmThreads (
    VOID
    )

/*++

Routine Description:

    Finds and dumps the interesting memory management threads.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG   i;
    ULONG   MemoryMaker;
    ULONG64 ProcessToDump;
    ULONG   Flags;
    ULONG64 Next;
    ULONG64 ProcessHead;
    ULONG64 Process;
    ULONG64 Thread;
    CHAR    Buf[256];
    STRING  string1, string2;
    ULONG64 InterestingThreads[4];
    ULONG   ActvOffset, PcbThListOffset, TcbThListOffset;

    ProcessToDump = (ULONG64) -1;
    Flags = 0xFFFFFFFF;

    ProcessHead = GetNtDebuggerData( PsActiveProcessHead );
    if (!ProcessHead) {
        dprintf("Unable to get value of PsActiveProcessHead\n");
        return;
    }

    if (GetFieldValue( ProcessHead, "nt!_LIST_ENTRY", "Flink", Next )) {
        dprintf("Unable to read nt!_LIST_ENTRY @ %p\n", ProcessHead);
        return;
    }

    if (Next == 0) {
        dprintf("PsActiveProcessHead is NULL!\n");
        return;
    }
    InterestingThreads[0] = GetExpression ("nt!MiModifiedPageWriter");
    InterestingThreads[1] = GetExpression ("nt!MiMappedPageWriter");
    InterestingThreads[2] = GetExpression ("nt!MiDereferenceSegmentThread");
    InterestingThreads[3] = GetExpression ("nt!KeBalanceSetManager");

    RtlInitString(&string1, "System");
    GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActvOffset);
    GetFieldOffset("nt!_EPROCESS", "Pcb.ThreadListHead", &PcbThListOffset);
    GetFieldOffset("nt!_KTHREAD",  "ThreadListEntry",    &TcbThListOffset);

    while(Next != ProcessHead) {

        Process = Next - ActvOffset;

        if (GetFieldValue( Process, "nt!_EPROCESS", "ImageFileName", Buf )) {
            dprintf("Unable to read _EPROCESS at %p\n",Process);
            return;
        }

        // strcpy((PCHAR)Buf,(PCHAR)ProcessContents.ImageFileName);
        RtlInitString(&string2, (PCSZ) Buf);

        if (RtlCompareString(&string1, &string2, TRUE) == 0) {

            //
            // Find the threads.
            //

            GetFieldValue( Process, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink", Next);

            while ( Next != Process + PcbThListOffset) {
                ULONG64 StartAddress;

                Thread = Next - TcbThListOffset;
                if (GetFieldValue(Thread,
                                  "nt!_ETHREAD",
                                  "StartAddress",
                                  StartAddress)) {
                    dprintf("Unable to read _ETHREAD at %p\n",Thread);
                    break;
                }

                if (GetFieldValue(Thread,
                                  "nt!_ETHREAD",
                                  "MemoryMaker",
                                  MemoryMaker)) {

                    for (i = 0; i < 4; i += 1) {
                        if (StartAddress == InterestingThreads[i]) {
                            DumpThread (0,"        ", Thread, 7);
                            break;
                        }
                    }
                }
                else if (MemoryMaker & 0x1) {
                    DumpThread (0,"        ", Thread, 7);
                }


                GetFieldValue(Thread, "nt!_KTHREAD","ThreadListEntry.Flink", Next);

                if (CheckControlC()) {
                    return;
                }
            }
            dprintf("\n");
            break;
        }


        GetFieldValue( Process, "nt!_EPROCESS", "ActiveProcessLinks.Flink", Next);

        if (CheckControlC()) {
            return;
        }
    }
    return;
}

HRESULT
DumpApc(
    PCHAR Pad,
    ULONG64 Kapc
    )
{
    CHAR Buffer[MAX_PATH];
    ULONG64 KernelRoutine;
    ULONG64 RundownRoutine;
    ULONG64 disp;
    if (InitTypeRead(Kapc, nt!_KAPC))
    {
        dprintf("%sCannot read nt!_KAPC @ %p\n", Kapc);
        return E_FAIL;
    }

    dprintf("%sKAPC @ %p\n", Pad, Kapc);
    dprintf("%s  Type           %lx\n", Pad, ReadField(Type));
    KernelRoutine = ReadField(KernelRoutine);
    GetSymbol(KernelRoutine, Buffer, &disp);
    dprintf("%s  KernelRoutine  %p %s+%I64lx\n", Pad, KernelRoutine, Buffer, disp);

    RundownRoutine = ReadField(RundownRoutine);
    GetSymbol(RundownRoutine, Buffer, &disp);
    dprintf("%s  RundownRoutine %p %s+%I64lx\n", Pad, RundownRoutine, Buffer, disp);

    return S_OK;
}

HRESULT
EnumerateThreadApcs(
    PCHAR Pad,
    ULONG64 Thread
    )
{
    ULONG   Header_Type;
    ULONG   ApcStateIndex;
    ULONG   ApcListHeadOffset;
    ULONG   KapcListOffset;
    ULONG64 ApcListHead;
    ULONG64 Flink;

    if (InitTypeRead(Thread, nt!_KTHREAD))
    {
        dprintf("%sCannot read nt!_KTHREAD @ %p\n", Thread);
        return E_FAIL;
    }

    Header_Type = (ULONG) ReadField(Header.Type);

    if (Header_Type != ThreadObject)
    {
        dprintf("TYPE mismatch for thread object at %p\n",Thread);
        return FALSE;
    }

    Flink = ReadField(ApcState.ApcListHead.Flink);
    ApcStateIndex = (ULONG) ReadField(ApcStateIndex);

    GetFieldOffset("nt!_KTHREAD", "ApcState.ApcListHead", &ApcListHeadOffset);

    if (GetFieldOffset("nt!_KAPC", "ApcListEntry", &KapcListOffset))
    {
        dprintf("%sCannot find nt!_KAPC.ApcListEntry\n");
        return E_FAIL;
    }

    ApcListHead = Thread+ApcListHeadOffset;

    if (!strlen(Pad) ||
        (Flink && (ApcListHead != Flink)))
    {
        dprintf("%sThread %p ApcStateIndex %lx ApcListHead %p\n",
                Pad, Thread, ApcStateIndex, ApcListHead);
    } else
    {
        dprintf("%sThread %p\r",
                Pad, Thread, ApcStateIndex, ApcListHead);
    }

    while (Flink && (ApcListHead != Flink))
    {
        ULONG64 Next;
        CHAR Pad2[20];

        if (!ReadPointer(Flink, &Next))
        {
            break;
        }
        if (CheckControlC())
        {
            return E_FAIL;
        }
        StringCchCopy(Pad2, sizeof(Pad2), Pad);
        StringCchCat(Pad2, sizeof(Pad2), "    ");
        if (DumpApc(Pad2, Flink - KapcListOffset) != S_OK)
        {
            break;
        }
        Flink = Next;
    }
    return S_OK;
}

ULONG
ThrdApcsCallback(
    PFIELD_INFO listElement,
    PVOID Context
    )
{
    ULONG64 Thread = listElement->address;

    if (FAILED(EnumerateThreadApcs("    ", Thread)))
    {
        return TRUE;
    }
    return FALSE;
}

HRESULT
EnumerateProcApcs(
    PCHAR Pad,
    ULONG64 Process
    )
{
    ULONG64 ThreadListHead_Flink=0;
    ULONG64 Pcb_Header_Type;
    ULONG64 Next;
    CHAR    ImageFileName[20];

    GetFieldValue(Process, "nt!_EPROCESS", "Pcb.Header.Type",         Pcb_Header_Type);
    if (Pcb_Header_Type != ProcessObject)
    {
        dprintf("TYPE mismatch for process object at %p\n", Pad, Process);
        return S_FALSE;
    }

    GetFieldValue(Process, "nt!_EPROCESS", "ImageFileName", ImageFileName);
    dprintf("%sProcess %p %s\n", Pad, Process, ImageFileName);

    if (GetFieldValue(Process, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink", ThreadListHead_Flink))
    {
        return S_FALSE;
    }

    if (!ReadPointer(ThreadListHead_Flink, &Next) ||
        (Next == ThreadListHead_Flink))
    {
        return S_OK;
    }
    if (ListType("nt!_ETHREAD", ThreadListHead_Flink, 1,
                 "Tcb.ThreadListEntry.Flink", (PVOID) Pad, &ThrdApcsCallback))
    {
        return E_FAIL;
    }
    return S_OK;

}

ULONG
ProcApcsCallback(
    PFIELD_INFO listElement,
    PVOID Context
    )
{
    ULONG64 Process=listElement->address;

    if (FAILED(EnumerateProcApcs("", Process)))
    {
        return TRUE;
    }
    return FALSE;
}

HRESULT
EnumerateAllApcs(
    void
    )
{
    ULONG64     ProcessHead, Next;

    if (!GetProcessHead(&ProcessHead, &Next))
    {
        return E_FAIL;
    }

    ListType("nt!_EPROCESS", Next, 1, "ActiveProcessLinks.Flink", NULL, &ProcApcsCallback);

    return S_OK;
}

DECLARE_API( apc )
{
    HRESULT Hr;
    ULONG64 Process = 0;
    ULONG64 Thread  = 0;
    ULONG64 Kapc    = 0;
    INIT_API();

    while (*args && ((*args == ' ') || (*args == '\t'))) ++args;

    if (!_strnicmp(args, "proc", 4))
    {
        while (*args && (*args != ' ') && (*args != '\t')) ++args;
        Process = GetExpression(args);
        EnumerateProcApcs("", Process);
    }
    else if (!_strnicmp(args, "thre", 4))
    {
        while (*args && (*args != ' ') && (*args != '\t')) ++args;
        Thread = GetExpression(args);
        EnumerateThreadApcs("", Thread);
    } else if (*args)
    {
        if (!isxdigit(*args))
        {
            dprintf("Usage !apc [Proc <process>]|[Thre <thread]|[<kapc>]\n\n");
            EXIT_API();
            return S_OK;
        }
        Kapc = GetExpression(args);
        DumpApc("", Kapc);
    } else
    {
        dprintf("*** Enumerating APCs in all processes\n");
        EnumerateAllApcs();
    }
    // erase any leftover output from \r printing
    dprintf("                                       \n");
    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\pte.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pte.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (LouP) 15-Feb-1992

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "i386.h"
#include "ia64.h"
#include "amd64.h"

ULONG64 MmNonPagedPoolEnd=0;
ULONG64 MmSubsectionBase=0;

ULONG64 KiIA64VaSignedFill;
ULONG64 KiIA64PtaBase;
ULONG64 KiIA64PtaSign;

ULONG
DbgGetPageFileHigh(
    ULONG64 Pte
    );

////////////////////////////////////////////////////////////////////////////////
//
// I386
//
////////////////////////////////////////////////////////////////////////////////

#define PaeGetPdeAddressX86(va)   ((ULONG64) (LONG64) (LONG) (PDE_BASE_X86 + ((ULONG64)  (((ULONG)(va)) >> 21) << 3)))

#define MiGetPdeAddressX86(va)  ((ULONG64) (LONG64) (LONG) (( (ULONG64)  (((ULONG)(va)) >> 22) << 2) + PDE_BASE_X86))

#define PaeGetVirtualAddressMappedByPteX86(PTE) ((ULONG64) (LONG64) (LONG) ((PTE) << 9))

#define PaeGetPteAddressX86(va)   ((ULONG64)(PTE_BASE_X86 + ( (ULONG64) ( ((ULONG)(va)) >> 12) << 3)))

#define PaeGetPteOffsetX86(va)   ((((ULONG) (va)) >> 12) & 0x1ff)

#define MiGetPteAddressX86(va)  (( (ULONG64) (((ULONG) (va)) >> 12) << 2) + PTE_BASE_X86)

#define MiGetPteOffsetX86(va)   ((((ULONG) (va)) >> 12) & 0x3ff)

#define MiGetVirtualAddressMappedByPteX86(PTE) ((ULONG64) (LONG64) (LONG) ((PTE) << 10))


////////////////////////////////////////////////////////////////////////////////
//
// AMD64
//
////////////////////////////////////////////////////////////////////////////////

#define AMD64_VA_MASK     (((ULONG64)1 << AMD64_VA_BITS) - 1)

#define MiGetPteAddressAMD64(va)  ((((((ULONG64)(va) & AMD64_VA_MASK) >> PTI_SHIFT_AMD64) << PTE_SHIFT_AMD64) + PTE_BASE_AMD64))

#define MiGetPdeAddressAMD64(va)  ((((((ULONG64)(va) & AMD64_VA_MASK) >> PDI_SHIFT_AMD64) << PTE_SHIFT_AMD64) + PDE_BASE_AMD64))

#define MiGetPpeAddressAMD64(va)  ((((((ULONG64)(va) & AMD64_VA_MASK) >> PPI_SHIFT_AMD64) << PTE_SHIFT_AMD64) + PPE_BASE_AMD64))

#define MiGetPxeAddressAMD64(va)  ((((((ULONG64)(va) & AMD64_VA_MASK) >> PXI_SHIFT_AMD64) << PTE_SHIFT_AMD64) + PXE_BASE_AMD64))

#define MiGetPteOffsetAMD64(va)   ((((ULONG_PTR) (va)) >> 12) & 0x3ff)

#define MiGetVirtualAddressMappedByPteAMD64(PTE) \
    ((ULONG64)((LONG64)(((LONG64)(PTE) - PTE_BASE_AMD64) << (PAGE_SHIFT_AMD64 + AMD64_VA_SHIFT - PTE_SHIFT_AMD64)) >> AMD64_VA_SHIFT))





////////////////////////////////////////////////////////////////////////////////
//
// IA64
//
////////////////////////////////////////////////////////////////////////////////
//
// MiGetPdeAddress returns the address of the PTE which maps the
// given virtual address.  Note we must redefine some of the MM
// macros here because they cast values to pointers which does not work
// on systems where pointers are only 32 bits.
//

#define MiGetPteOffsetIA64(va)   ((((ULONG_PTR) (va)) >> 13) & 0x3ff)

VOID
DbgGetPteBaseIA64(
    VOID
    )
{
    ULONG64 PtaValue;
    ULONG i;

    if (KiIA64PtaBase != 0) {

        return;

    }

    if (g_ExtData == NULL ||
        g_ExtData->lpVtbl->
        ReadProcessorSystemData(g_ExtData, 0,
                                DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET,
                                &PtaValue, sizeof(PtaValue), NULL) != S_OK) {
        PtaValue = (ULONG64) GetExpression("@pta");
    }

    KiIA64PtaBase = PtaValue & ~0xffffUI64;
    
    KiIA64VaSignedFill = 
        (KiIA64PtaBase << (PAGE_SHIFT_IA64 - PTE_SHIFT_IA64)) & ~VRN_MASK_IA64;

    KiIA64PtaSign = KiIA64PtaBase;

    for (i = 0; i < 64; i += 1) {

        KiIA64PtaSign >>= 1;

        if (KiIA64PtaSign & 1) {
            KiIA64PtaSign = (ULONG64)1 << i;
            break;
        }
    }
}

ULONG64
MiGetPteAddressIA64 (
    IN ULONG64 Va
    )
{

    DbgGetPteBaseIA64();

    if (((((ULONG64)(Va)) & PDE_TBASE_IA64) == PDE_TBASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_TBASE_IA64)) < PageSize)) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    return (ULONG64) (((((ULONG64)(Va)) & VRN_MASK_IA64)) |
             ((((((ULONG64)(Va)) >> PTI_SHIFT_IA64) << PTE_SHIFT_IA64) & (~(PTE_BASE_IA64|VRN_MASK_IA64))) + PTE_BASE_IA64));
}

ULONG64
MiGetPdeAddressIA64 (
    IN ULONG64 Va
    )
{
    DbgGetPteBaseIA64();

    if (((((ULONG64)(Va)) & PDE_BASE_IA64) == PDE_BASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_BASE_IA64)) < ((ULONG64)1 << PDI_SHIFT_IA64))) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    if (((((ULONG64)(Va)) & PDE_TBASE_IA64) == PDE_TBASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_TBASE_IA64)) < PageSize)) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    return (ULONG64) (((((ULONG64)(Va)) & VRN_MASK_IA64)) |
             ((((((ULONG64)(Va)) >> PDI_SHIFT_IA64) << PTE_SHIFT_IA64) & (~(PDE_BASE_IA64|VRN_MASK_IA64))) + PDE_BASE_IA64));
}

ULONG64
MiGetPpeAddressIA64 (
    IN ULONG64 Va
    )
{
    DbgGetPteBaseIA64();

    if ((((ULONG64)(Va) & PTE_BASE_IA64) == PTE_BASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PTE_BASE_IA64)) < ((ULONG64)1 << PDI1_SHIFT_IA64))) {

        return (ULONG64) (((ULONG64)Va & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    if (((((ULONG64)(Va)) & PDE_BASE_IA64) == PDE_BASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_BASE_IA64)) < ((ULONG64)1 << PDI_SHIFT_IA64))) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    if (((((ULONG64)(Va)) & PDE_TBASE_IA64) == PDE_TBASE_IA64) &&
        ((((ULONG64)(Va)) & ~(VRN_MASK_IA64|PDE_TBASE_IA64)) < PageSize)) {

        return (ULONG64) ((((ULONG64)(Va)) & VRN_MASK_IA64) |
                         (PDE_TBASE_IA64 + PageSize - GetTypeSize("nt!_MMPTE")));
    }

    return (ULONG64) (((((ULONG64)(Va)) & VRN_MASK_IA64)) |
              ((((((ULONG64)(Va)) >> PDI1_SHIFT_IA64) << PTE_SHIFT_IA64) &
                (~(PDE_TBASE_IA64|VRN_MASK_IA64))) + PDE_TBASE_IA64));
}

ULONG64
MiGetVirtualAddressMappedByPteIA64(
    IN ULONG64 PTE
    ) 
{
    DbgGetPteBaseIA64();

    return (((ULONG64)(PTE) & PTA_SIGN_IA64) ?
            (ULONG64)(((ULONG64)(PTE) & VRN_MASK_IA64) | VA_FILL_IA64 | 
                      (((ULONG64)(PTE)-PTE_BASE_IA64) << (PAGE_SHIFT_IA64 - PTE_SHIFT_IA64))) : 
            (ULONG64)(((ULONG64)(PTE) & VRN_MASK_IA64) | (((ULONG64)(PTE)-PTE_BASE_IA64) << (PAGE_SHIFT_IA64 - PTE_SHIFT_IA64))));

}

#define MiGetSubsectionAddress(lpte)                              \
    (((lpte)->u.Subsect.WhichPool == 1) ?                              \
     ((ULONG64)((ULONG64)MmSubsectionBase +    \
                    ((ULONG64)(lpte)->u.Subsect.SubsectionAddress))) \
     : \
     ((ULONG64)((ULONG64)MM_NONPAGED_POOL_END -    \
                    ((ULONG64)(lpte)->u.Subsect.SubsectionAddress))))

#define MiPteToProto(lpte) \
            ((ULONG64) ((ULONG64)((lpte)->u.Proto.ProtoAddress) + MmProtopte_Base))


////////////////////////////////////////////////////////////////////////////////
//
// AMD64
//
////////////////////////////////////////////////////////////////////////////////

VOID
DbgPrintProtection (
    ULONG Protection
    )
{
    if (Protection == 0) {
        dprintf("0");
        return;
    }

    dprintf ("%x - ", Protection);

    if (Protection == MM_NOACCESS) {
        dprintf("No Access");
    } else if (Protection == MM_DECOMMIT) {
        dprintf("Decommitted");
    } else {
        switch (Protection & 7) {
        case MM_READONLY: dprintf("Readonly"); break;
        case MM_EXECUTE: dprintf("Execute"); break;
        case MM_EXECUTE_READ: dprintf("ExecuteRead"); break;
        case MM_READWRITE: dprintf("ReadWrite"); break;
        case MM_WRITECOPY: dprintf("ReadWriteCopy"); break;
        case MM_EXECUTE_READWRITE: dprintf("ReadWriteExecute"); break;
        case MM_EXECUTE_WRITECOPY: dprintf("ReadWriteCopyExecute "); break;
        default: ;    
        }
        if (Protection & MM_NOCACHE) {
            dprintf(" UC");
        }
        if (Protection & MM_GUARD_PAGE) {
            dprintf(" G");
        }
    }
}

ULONG64
DbgPteLookupNeeded (
    VOID
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            return MI_PTE_LOOKUP_NEEDED_X86;

        case IMAGE_FILE_MACHINE_AMD64:
            return MI_PTE_LOOKUP_NEEDED_AMD64;
            break;

        case IMAGE_FILE_MACHINE_IA64:
            return MI_PTE_LOOKUP_NEEDED_IA64;

        default:
            break;
    }

    return 0;
}

LOGICAL
DbgPteIsDemandZero (
    ULONG64 CurrentPte
    )
{
    ULONG Protection = 0;
    ULONG64 CurrentPteContents = 0;
    
    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);
    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Soft.Protection", Protection);

    //
    // The caller has already ensured that the valid, prototype & transition
    // bits in the PTE are all zero.
    //

    if (DbgGetPageFileHigh (CurrentPte) != 0) {
        return FALSE;
    }

    if ((Protection != 0) &&
        (Protection != MM_NOACCESS) &&
        (Protection != MM_DECOMMIT)) {

        return TRUE;
    }

    return FALSE;
}

#define PMMPTEx ULONG64

#define PACKET_MAX_SIZE 4000

typedef struct _SYS_PTE_LIST {
    ULONG64 Next;
    ULONG64 Previous;
    ULONG64 Value;
    ULONG Count;
} SYS_PTE_LIST, *PSYS_PTE_LIST;

ULONG
MiGetSysPteListDelimiter (
    VOID
    )

/*++

Routine Description:

    The platform-specific system PTE list delimiter is returned.

Arguments:

    None.

--*/

{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            if (PaeEnabled) {
                return 0xFFFFFFFF;
            }
            return 0xFFFFF;

        case IMAGE_FILE_MACHINE_AMD64:
            return 0xFFFFFFFF;

        case IMAGE_FILE_MACHINE_IA64:
            return 0xFFFFFFFF;

        default:
            break;
    }

    return 0;
}


ULONG64
MiGetFreeCountFromPteList (
    IN ULONG64 Pte
    )

/*++

Routine Description:

    The specified PTE points to a free list header in the
    system PTE pool. It returns the number of free entries
    in this block.

Arguments:

    Pte - the PTE to examine.

--*/

{
    ULONG OneEntry;
    ULONG64 NextEntry;


    GetFieldValue(Pte, "nt!MMPTE", "u.List.OneEntry", OneEntry);
    GetFieldValue(Pte + GetTypeSize("nt!_MMPTE"), "nt!MMPTE", "u.List.NextEntry",NextEntry);
    
    return (( OneEntry) ?
                1 :
                NextEntry);
}

DECLARE_API( sysptes )

/*++

Routine Description:

     Dumps system PTEs.

Arguments:

    args - Flags

Return Value:

    None

--*/

{
    ULONG   ExtraPtesUnleashed;
    ULONG   TotalNumberOfSystemPtes;
    ULONG64 NonPagedSystemStart;
    ULONG64 ExtraResourceStart;
    ULONG64 ExtraPteStart;
    ULONG   NumberOfExtraPtes;
    ULONG   PteListDelimiter;
    ULONG   result;
    ULONG64 nextfreepte;
    ULONG   Flags;
    ULONG64 next;
    ULONG64 Pte;
    ULONG64 IndexBase;
    ULONG64 PteBase;
    ULONG64 PteArrayReal;
    ULONG64 PteEnd;
    ULONG64 IndexBias;
    ULONG64 FreeStart;
    ULONG   NumberOfSystemPtes;
    ULONG64 PageCount;
    ULONG64 free;
    ULONG64 totalFree;
    ULONG64 largeFree;
    ULONG   i;
    ULONG64 Flink;
    ULONG64 PteHeaderAddress;
    ULONG   FreeSysPteListBySize[MM_SYS_PTE_TABLES_MAX];
    ULONG   SysPteIndex [MM_SYS_PTE_TABLES_MAX];
    ULONG   PteSize;
    PVOID   PteData;
    CHAR Buffer[256];
    ULONG64 displacement;

    INIT_API();

    PteData = NULL;

    Flags = (ULONG) GetExpression(args);


    if (Flags & 8) {

        //
        // Dump the nonpaged pool expansion free PTE list only.
        //

        IndexBias    = GetPointerValue ("nt!MmSystemPteBase");
    
        PteSize = GetTypeSize ("nt!_MMPTE");

        i           = 0;
        totalFree   = 0;
        largeFree   = 0;
    
        PteData = LocalAlloc (LMEM_FIXED, PteSize * 2);
        if (!PteData) {
            dprintf("Unable to malloc PTE data\n");
            EXIT_API();
            return E_INVALIDARG;
        }
    
        FreeStart = GetExpression ("nt!MmFirstFreeSystemPte") + PteSize;
    
        if ( !ReadMemory( FreeStart,
                          PteData,
                          PteSize,
                          &result) ) {
            dprintf("%08p: Unable to get MmFirstFreeSystemPte\n",FreeStart);
            LocalFree(PteData);
            EXIT_API();
            return E_INVALIDARG;
        }
    
        GetFieldValue(FreeStart, "nt!_MMPTE", "u.List.NextEntry", next);
        if (!next)
        {
            dprintf("NULL nt!_MMPTE.u.List.NextEntry @ %p\n", FreeStart);
            return E_FAIL;
        }
        FreeStart = next;

        PteListDelimiter = MiGetSysPteListDelimiter ();
    
        while (next != PteListDelimiter) {
    
            if ( CheckControlC() ) {
                goto Bail;
            }

            nextfreepte = IndexBias + next * PteSize;

            if ( !ReadMemory( nextfreepte,
                              PteData,
                              PteSize * 2,
                              &result) ) {
                dprintf("%16I64X: Unable to get nonpaged PTE\n", nextfreepte);
                break;
            }

            free = MiGetFreeCountFromPteList (nextfreepte);
    
            if (Flags & 1) {
                dprintf("      free ptes: %8p   number free: %5I64ld.\n",
                        nextfreepte,
                        free);
            }

            if (free > largeFree) {
                largeFree = free;
            }

            totalFree += free;
            i += 1;
    
            if (GetFieldValue(nextfreepte, "nt!_MMPTE", "u.List.NextEntry", next))
            {
                dprintf("Cannot read nt!_MMPTE @ %p\n", nextfreepte);
                break;
            }
            // next = MiGetNextFromPteList ((PMMPTE)PteData);
        }
        dprintf("\n  free blocks: %ld   total free: %I64ld    largest free block: %I64ld\n\n",
                i, totalFree, largeFree);
    
        LocalFree(PteData);
        EXIT_API();
        return E_INVALIDARG;
    }

    if (Flags & 4) {

        PteHeaderAddress = GetExpression( "nt!MiPteHeader" );
    
        if ( GetFieldValue( PteHeaderAddress,
                            "nt!_SYSPTES_HEADER",
                            "Count",
                            NumberOfSystemPtes) ) {
                dprintf("%08p: Unable to get System PTE lock consumer information\n",
                    PteHeaderAddress);
        }
        else {
            dprintf("\n0x%x System PTEs allocated to mapping locked pages\n\n",
                NumberOfSystemPtes);

            dprintf("VA       MDL     PageCount  Caller/CallersCaller\n");

            //
            // Dump the MDL and PTE addresses and 2 callers.
            //
            GetFieldValue( PteHeaderAddress,"SYSPTES_HEADER","ListHead.Flink", Flink);

            for (PageCount = 0; PageCount < (ULONG64) NumberOfSystemPtes; ) {
                ULONG64 Count;

                if (Flink == PteHeaderAddress) {
                    dprintf("early finish (%I64u) during syspte tracker dumping\n",
                        PageCount);
                    break;
                }

                if ( CheckControlC() ) {
                    break;
                }

                if ( GetFieldValue( Flink,
                                    "nt!_PTE_TRACKER",
                                    "Count",
                                    Count) ) {
                        dprintf("%08p: Unable to get System PTE individual lock consumer information\n",
                            Flink);
                        break;
                }

                InitTypeRead(Flink, nt!_PTE_TRACKER);
                dprintf("%8p %8p %8I64lx ",
                    ReadField(SystemVa),
                    ReadField(Mdl),
                    Count);

                Buffer[0] = '!';
                Flink = ReadField(ListEntry.Flink);
                GetSymbol (ReadField(CallingAddress),
                           (PCHAR)Buffer,
                           &displacement);
        
                dprintf("%s", Buffer);
                if (displacement) {
                    dprintf( "+0x%1p", displacement );
                }
                dprintf("/");

                Buffer[0] = '!';
                GetSymbol (ReadField(CallersCaller),
                           (PCHAR)Buffer,
                           &displacement);
        
                dprintf("%s", Buffer);
                if (displacement) {
                    dprintf( "+0x%1p", displacement );
                }
        
                dprintf("\n");

                PageCount += Count;
            }
        }
    
        if ((Flags & ~4) == 0) {

            //
            // no other flags specified, so just return.
            //

            EXIT_API();
            return E_INVALIDARG;
        }
    }

    dprintf("\nSystem PTE Information\n");

    PteBase      = GetPointerValue ("nt!MmSystemPtesStart");
    PteEnd       = GetPointerValue ("nt!MmSystemPtesEnd");
    IndexBias    = GetPointerValue ("nt!MmSystemPteBase");
    NumberOfSystemPtes   = GetUlongValue ("nt!MmNumberOfSystemPtes");
    NonPagedSystemStart = GetPointerValue ("nt!MmNonPagedSystemStart");

    PteSize = GetTypeSize ("nt!_MMPTE");

    NumberOfExtraPtes = 0;

    //
    // The system PTEs may exist in 2 separate virtual address ranges.
    //
    // See if there are extra resources, if so then see if they are being
    // used for system PTEs (as opposed to system cache, etc).
    //

    ExtraPtesUnleashed = 0;
    ExtraPtesUnleashed = GetUlongValue ("nt!MiAddPtesCount");

    if (ExtraPtesUnleashed != 0) {
        ExtraResourceStart = GetExpression ("nt!MiExtraResourceStart"); 

        if (ExtraResourceStart != 0) {

            NumberOfExtraPtes = GetUlongValue ("nt!MiExtraPtes1");

            if (NumberOfExtraPtes != 0) {

                if (!ReadPointer(ExtraResourceStart,&ExtraPteStart)) {
                    dprintf("%016I64X: Unable to read PTE start\n",ExtraResourceStart);
                    goto Bail;
                }
            }
        }
    }

    TotalNumberOfSystemPtes = (ULONG) (NumberOfSystemPtes + NumberOfExtraPtes);

    dprintf("  Total System Ptes %ld\n", TotalNumberOfSystemPtes);

    free = GetExpression( "nt!MmSysPteIndex" );

    if ( !ReadMemory( free,
                      &SysPteIndex[0],
                      sizeof(ULONG) * MM_SYS_PTE_TABLES_MAX,
                      &result) ) {
        dprintf("%08p: Unable to get PTE index\n",free);
        goto Bail;
    }

    free = GetExpression( "nt!MmSysPteListBySizeCount" );

    if ( !ReadMemory( free,
                      &FreeSysPteListBySize[0],
                      sizeof (FreeSysPteListBySize),
                      &result) ) {
        dprintf("%08p: Unable to get free PTE index\n",free);
        goto Bail;
    }

    for (i = 0; i < MM_SYS_PTE_TABLES_MAX; i += 1 ) {
        dprintf("     SysPtes list of size %ld has %ld free\n",
            SysPteIndex[i],
            FreeSysPteListBySize[i]);
    }

    dprintf(" \n");

    dprintf("    starting PTE: %p\n", PteBase);
    dprintf("    ending PTE:   %p\n", PteEnd);

    PteArrayReal = PteBase; 

    dprintf("\n");

    //
    // Walk the free list.
    //

    IndexBase = (PteBase - IndexBias) / PteSize;

    totalFree   = 0;
    i           = 0;
    largeFree   = 0;

    FreeStart = GetExpression ("nt!MmFirstFreeSystemPte");

    if ( GetFieldValue( FreeStart, "nt!_MMPTE", "u.List.NextEntry", next) ) {
        dprintf("%08p: Unable to get MmFirstFreeSystemPte\n",FreeStart);
        goto Bail;
    }

    if (!next)
    {
        dprintf("NULL nt!_MMPTE.u.List.NextEntry @ %p\n", FreeStart);
        return E_FAIL;
    }
    FreeStart = next;

    PteListDelimiter = MiGetSysPteListDelimiter ();

    while (next != PteListDelimiter) {

        if ( CheckControlC() ) {
            goto Bail;
        }

        free = MiGetFreeCountFromPteList ((PteArrayReal + (next - IndexBase)* PteSize));

        if (Flags & 1) {
            dprintf("      free ptes: %8p   number free: %5I64ld.\n",
                    PteBase + (next - IndexBase) * PteSize,
                    free);
        }
        if (free > largeFree) {
            largeFree = free;
        }
        totalFree += free;
        i += 1;

        if (GetFieldValue ((PteArrayReal + (next - IndexBase) * PteSize),
                           "nt!_MMPTE", "u.List.NextEntry", next))
        {
            dprintf("Cannot read nt!_MMPTE @%p\n", (PteArrayReal + (next - IndexBase) * PteSize));
            break;
        }
    }

    dprintf("\n  free blocks: %ld   total free: %I64ld    largest free block: %I64ld\n\n",
                i, totalFree, largeFree);

Bail:

    EXIT_API();
    return S_OK;
}


ULONG64
DbgGetFrameNumber(
    ULONG64 Pte
    ) 
{
    ULONG   Valid=0;
    ULONG   Prototype=0;
    ULONG   Transition=0;
    ULONG64 PageFrameNumber=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Valid", Valid);
    if (Valid) {
        GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.PageFrameNumber", PageFrameNumber);
    }
    else {
        GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.Prototype", Prototype);
        if (Prototype == 0) {
            GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.Transition", Transition);
            if (Transition == 1) {
                GetFieldValue(Pte, "_MMPTE", "u.Trans.PageFrameNumber", PageFrameNumber);
            }
            else {
                // Must be pagefile or demand zero.
                GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.PageFileHigh", PageFrameNumber);
            }
        }
    }

    return PageFrameNumber;
}


ULONG
DbgGetOwner(
    ULONG64 Pte
    ) 
{
    ULONG Owner=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Owner", Owner);

    return Owner;
}


ULONG
DbgGetValid(
    ULONG64 Pte
    ) 
{
    ULONG Valid=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Valid", Valid);

    return Valid;
}

ULONG
DbgGetDirty(
    ULONG64 Pte
    ) 
{
    ULONG Dirty=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Dirty", Dirty);

    return Dirty;
}


ULONG
DbgGetAccessed(
    ULONG64 Pte
    ) 
{
    ULONG Accessed=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Accessed", Accessed);

    return Accessed;
}


ULONG
DbgGetWrite(
    ULONG64 Pte
    ) 
{
    ULONG Write=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Write", Write);

    return Write;
}


ULONG
DbgGetExecute(
    ULONG64 Pte
    ) 
{
    ULONG Execute=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Execute", Execute);

    return Execute;
}


ULONG
DbgGetSplit(
    ULONG64 Pte
    ) 
{
    ULONG64 Pte_Long;
    ULONG Split=0;

    if (TargetMachine == IMAGE_FILE_MACHINE_IA64) {
        GetFieldValue(Pte, "nt!_MMPTE", "u.Long", Pte_Long);
        if (Pte_Long & 0x1) {
            GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.Cache", Split);
        }
        else {
            GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.SplitPermissions", Split);
        }
    }

    if (Split == 1) {
        return 1;
    }

    return 0;
}

ULONG
DbgGetCopyOnWrite(
    ULONG64 Pte
    ) 
{
    ULONG CopyOnWrite=0;

    GetFieldValue(Pte, "nt!_MMPTE", "u.Hard.CopyOnWrite", CopyOnWrite);

    return CopyOnWrite;
}


ULONG
DbgGetPageFileHigh(
    ULONG64 Pte
    )
{
    ULONG64 PageFileHigh=0;
    
    GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.PageFileHigh", PageFileHigh);
    return (ULONG) PageFileHigh;
}

ULONG
DbgGetPageFileLow(
    ULONG64 Pte
    )
{
    ULONG PageFileLow=0;
    
    GetFieldValue(Pte, "nt!_MMPTE", "u.Soft.PageFileLow", PageFileLow);
    return PageFileLow;
}

ULONG64
DbgPteToProto(
    ULONG64 lpte
    )
{
    ULONG64 PteLong=0;
    ULONG64 ProtoAddress=0;
                
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        GetFieldValue(lpte, "nt!_MMPTE", "u.Proto.ProtoAddress",ProtoAddress);
        return ProtoAddress;
    }

    if (PaeEnabled) {
        GetFieldValue(lpte, "nt!_MMPTE", "u.Proto.ProtoAddress",ProtoAddress);
        return ProtoAddress;
    }

    GetFieldValue(lpte, "nt!_MMPTE", "u.Long", PteLong);

    ProtoAddress = (((ULONG)PteLong >> 11) << 9) + (((ULONG)PteLong << 24) >> 23) + 0xE1000000;

    return ProtoAddress;
}

ULONG64
DbgGetSubsectionAddress(
    IN ULONG64 Pte
    )
{
    ULONG64 PteLong=0;
    ULONG64 SubsectionAddress=0;

    if (PaeEnabled && 
        (TargetMachine == IMAGE_FILE_MACHINE_I386)) {

        GetFieldValue(Pte, "nt!_MMPTE", "u.Subsect.SubsectionAddress", SubsectionAddress);
        return SubsectionAddress;
    }

    MmSubsectionBase = GetNtDebuggerDataPtrValue(MmSubsectionBase);
    GetFieldValue(Pte, "nt!_MMPTE", "u.Long", PteLong);

    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{

        if (!MmNonPagedPoolEnd) {
            MmNonPagedPoolEnd = GetNtDebuggerDataPtrValue(MmNonPagedPoolEnd);
        }

        SubsectionAddress = 
            ((PteLong & 0x80000000) ? 
             (((ULONG) MmSubsectionBase + (((PteLong & 0x7ffff800) >> 4) |
                                   ((PteLong<<2) & 0x78)))) 
             : 
            (((ULONG) MmNonPagedPoolEnd - ((((PteLong)>>11)<<7) | 
                                   ((PteLong<<2) & 0x78)))));

        SubsectionAddress = (ULONG64) (LONG64) (LONG) SubsectionAddress;
        break;
    }
    case IMAGE_FILE_MACHINE_AMD64: {

        LONG64 SignedSubsectionAddress;

        GetFieldValue(Pte, "nt!_MMPTE", "u.Subsect.SubsectionAddress", SignedSubsectionAddress);
        if (SignedSubsectionAddress & 0x0000800000000000) {
            SignedSubsectionAddress |= 0xFFFF800000000000;
        }

        SubsectionAddress = (ULONG64) SignedSubsectionAddress;
        break;
                                   }
    case IMAGE_FILE_MACHINE_IA64: {
        ULONG64 WhichPool=0, SubsectionAddress2=0;

        GetFieldValue(Pte, "nt!_MMPTE", "u.Subsect.SubsectionAddress", SubsectionAddress2);
        GetFieldValue(Pte, "nt!_MMPTE", "u.Subsect.WhichPool", WhichPool);

        if (!MmNonPagedPoolEnd) {
            MmNonPagedPoolEnd = GetNtDebuggerDataPtrValue(MmNonPagedPoolEnd);
        }

        SubsectionAddress =
            ((WhichPool == 1) ? 
             ((MmSubsectionBase + (SubsectionAddress2))) 
             : 
            ((MmNonPagedPoolEnd -
                    (SubsectionAddress2))));
        break;
    }
    default:
        return FALSE;
    } /* switch */
    return SubsectionAddress;
}

ULONG64
DbgGetPdeAddress(
    IN ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            if (PaeEnabled) {
                return PaeGetPdeAddressX86 (VirtualAddress);
            }
            return MiGetPdeAddressX86(VirtualAddress);

        case IMAGE_FILE_MACHINE_AMD64:
            return MiGetPdeAddressAMD64(VirtualAddress);

        case IMAGE_FILE_MACHINE_IA64:
            return MiGetPdeAddressIA64(VirtualAddress);

        default:
            break;
    }
    return 0;
}

ULONG64
DbgGetPpeAddress(
    IN ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_AMD64:
            return MiGetPpeAddressAMD64(VirtualAddress);

        case IMAGE_FILE_MACHINE_IA64:
            return MiGetPpeAddressIA64(VirtualAddress);

        default:
            break;
    }

    return 0;
}

ULONG64
DbgGetPxeAddress(
    IN ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_AMD64:
            return MiGetPxeAddressAMD64(VirtualAddress);

        default:
            break;
    }

    return 0;
}

ULONG64
DbgGetVirtualAddressMappedByPte(
    IN ULONG64 Pte
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            if (PaeEnabled) {
                return PaeGetVirtualAddressMappedByPteX86(Pte);
            }
            return MiGetVirtualAddressMappedByPteX86 (Pte);

        case IMAGE_FILE_MACHINE_AMD64:
            return MiGetVirtualAddressMappedByPteAMD64 (Pte);

        case IMAGE_FILE_MACHINE_IA64:
            return MiGetVirtualAddressMappedByPteIA64 (Pte);

        default:
            break;
    }

    return 0;
}


ULONG64
DbgGetPteAddress(
    IN ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        if (PaeEnabled) {
            return PaeGetPteAddressX86 (VirtualAddress);
        }
        return MiGetPteAddressX86(VirtualAddress);
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return MiGetPteAddressAMD64(VirtualAddress);
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MiGetPteAddressIA64(VirtualAddress);
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG
DbgGetPteOffset(
    IN ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        if (PaeEnabled) {
            return PaeGetPteOffsetX86 (VirtualAddress);
        }
        return MiGetPteOffsetX86(VirtualAddress);
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return (ULONG) MiGetPteOffsetIA64(VirtualAddress);
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return (ULONG) MiGetPteOffsetAMD64(VirtualAddress);
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

BOOL
Mi_Is_Physical_Address (
    ULONG64 VirtualAddress
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_IA64: {
        return MI_IS_PHYSICAL_ADDRESS_IA64(VirtualAddress);

    }
    case IMAGE_FILE_MACHINE_I386:{
        ULONG64 Addr;
        ULONG LongVal;
        Addr = DbgGetPdeAddress(VirtualAddress);
        GetFieldValue(Addr, "nt!_MMPTE", "u.Long", LongVal);
        return  ((LongVal & 0x81) == 0x81);
    }

    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG
MiConvertPhysicalToPfn (
    IN ULONG64 VirtualAddress
    )
//
// Routine Description:
//
//    This macro converts a physical address (see MI_IS_PHYSICAL_ADDRESS)
//    to its corresponding physical frame number.
//
// Arguments
//
//    VA - Supplies a pointer to the physical address.
//
// Return Value:
//
//    Returns the PFN for the page.
//
//--
{
    ULONG64 Addr;
    ULONG Pfn;
    Addr = DbgGetPdeAddress(VirtualAddress);
    GetFieldValue(Addr, "nt!_MMPTE", "u.Hard.PageFrameNumber", Pfn);

    return Pfn + DbgGetPteOffset(VirtualAddress);

}



ULONG
DBG_GET_PAGE_SHIFT (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return PAGE_SHIFT_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return PAGE_SHIFT_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return PAGE_SHIFT_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG64
DBG_GET_MM_SESSION_SPACE_DEFAULT (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_SESSION_SPACE_DEFAULT_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return MM_SESSION_SPACE_DEFAULT_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_SESSION_SPACE_DEFAULT_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG
GET_MM_PTE_VALID_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_VALID_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return MM_PTE_VALID_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_VALID_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GET_MM_PTE_LARGE_PAGE_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_LARGE_PAGE_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_LARGE_PAGE_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_LARGE_PAGE_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GET_MM_PTE_TRANSITION_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_TRANSITION_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_TRANSITION_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_TRANSITION_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GET_MM_PTE_PROTOTYPE_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_PROTOTYPE_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_PROTOTYPE_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_PROTOTYPE_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GET_MM_PTE_PROTECTION_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_PROTECTION_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_PROTECTION_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_PROTECTION_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG
GET_MM_PTE_PAGEFILE_MASK (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return MM_PTE_PAGEFILE_MASK_X86;
    }
    case IMAGE_FILE_MACHINE_AMD64:{
        return MM_PTE_PAGEFILE_MASK_AMD64;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return MM_PTE_PAGEFILE_MASK_IA64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG64
GET_PTE_TOP (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return PTE_TOP_X86;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        return PDE_TOP_IA64;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return PTE_TOP_AMD64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}

ULONG64
GET_PDE_TOP (
    VOID
    )
{
    return GET_PTE_TOP();
}


ULONG64
GET_PTE_BASE (
    VOID
    )
{
    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:{
        return PTE_BASE_X86;
    }
    case IMAGE_FILE_MACHINE_IA64: {
        DbgGetPteBaseIA64();
        return PTE_BASE_IA64;
    }
    case IMAGE_FILE_MACHINE_AMD64: {
        return PTE_BASE_AMD64;
    }
    default:
        return FALSE;
    } /* switch */
    return FALSE;
}


ULONG
GetAddressState(
    IN ULONG64 VirtualAddress
    )

{
    ULONG64 Address;
    ULONG   result;
    ULONG64 Pte;
    ULONG64 Pde;
    ULONG   PdeContents;
    ULONG   PteContents;

    if (Mi_Is_Physical_Address (VirtualAddress)) {
        return ADDRESS_VALID;
    }
    Address = VirtualAddress;

    Pde = DbgGetPdeAddress (VirtualAddress);
    Pte = DbgGetPteAddress (VirtualAddress);

    if ( !ReadMemory( Pde,
                      &PdeContents,
                      sizeof(ULONG),
                      &result) ) {
        dprintf("%08p: Unable to get PDE\n",Pde);
        return ADDRESS_NOT_VALID;
    }

    if (PdeContents & GET_MM_PTE_VALID_MASK()) {
        if (PdeContents & GET_MM_PTE_LARGE_PAGE_MASK()) {
            return ADDRESS_VALID;
        }
        if ( !ReadMemory( Pte,
                          &PteContents,
                          sizeof(ULONG),
                          &result) ) {
            dprintf("%08p: Unable to get PTE\n",Pte);
            return ADDRESS_NOT_VALID;
        }
        if (PteContents & GET_MM_PTE_VALID_MASK()) {
            return ADDRESS_VALID;
        }
        if (PteContents & GET_MM_PTE_TRANSITION_MASK()) {
            if (!(PteContents & GET_MM_PTE_PROTOTYPE_MASK())) {
                return ADDRESS_TRANSITION;
            }
        }
    }
    return ADDRESS_NOT_VALID;
}

VOID
DbgDisplayInvalidPte (
    ULONG64 CurrentPte,
    ULONG64 flags,
    PCHAR Indent
    )
{
    ULONG Transition = 0;
    ULONG Protection = 0;
    ULONG PrototypeBit = 0;
    ULONG64  CurrentPteContents;
    ULONG   PteSize;

    PteSize = GetTypeSize ("nt!_MMPTE");

    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);
    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Soft.Prototype", PrototypeBit);

    dprintf("%s not valid\n", Indent);
    GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Soft.Protection", Protection);
    GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Soft.Transition", Transition);

    if (PrototypeBit) {
        if (DbgGetPageFileHigh (CurrentPte) == DbgPteLookupNeeded ()) {
            dprintf("%s Proto: VAD\n", Indent);
            dprintf("%s Protect: ", Indent);
            DbgPrintProtection (Protection);
        }
        else if (flags) {
            if (PteSize == 4) {
                dprintf("%s Subsection: %08I64X\n",
                    Indent,
                    DbgGetSubsectionAddress (CurrentPte));
            }
            else {
                dprintf("%s Subsection: %016I64X\n",
                    Indent,
                    DbgGetSubsectionAddress (CurrentPte));
            }
            dprintf("%s Protect: ", Indent);
            DbgPrintProtection (Protection);
        }
        else {
            if (PteSize == 4) {
                dprintf("%s Proto: %08I64X\n",
                    Indent,
                    DbgPteToProto (CurrentPte));
            }
            else {
                dprintf("%s Proto: %016I64X\n",
                    Indent,
                    DbgPteToProto (CurrentPte));
            }
        }
    } else if (Transition) {
        dprintf("%s Transition: %x\n",
                    Indent,
                    (ULONG) DbgGetFrameNumber (CurrentPte));
        dprintf("%s Protect: ", Indent);
        DbgPrintProtection (Protection);

    } else if (CurrentPteContents != 0) {

        if (DbgPteIsDemandZero (CurrentPte)) {
            dprintf("%s DemandZero\n", Indent);
        }
        else {
            dprintf("%s PageFile: %2lx\n",
                    Indent,
                    DbgGetPageFileLow (CurrentPte));
            dprintf("%s Offset: %lx\n", Indent, DbgGetPageFileHigh (CurrentPte));
        }
        dprintf("%s Protect: ", Indent);
        DbgPrintProtection (Protection);
    }

    if (DbgGetSplit(CurrentPte)) {
        dprintf(" Split");
    }

    dprintf ("\n");
}

VOID
DbgDisplayValidPte (
    ULONG64 Pte
    )
{
    ULONG64 Pte_Long;

    if (Pte == 0) {
        return;
    }

    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
        case IMAGE_FILE_MACHINE_AMD64:

            GetFieldValue(Pte, "nt!_MMPTE", "u.Long", Pte_Long);
            dprintf("pfn %x %c%c%c%c%c%c%c%c%cV",
                        (ULONG) DbgGetFrameNumber(Pte),
                        DbgGetCopyOnWrite(Pte) ? 'C' : '-',
                        Pte_Long & 0x100 ? 'G' : '-',
                        Pte_Long & 0x80 ? 'L' : '-',
                        DbgGetDirty(Pte) ? 'D' : '-',
                        DbgGetAccessed(Pte) ? 'A' : '-',
                        Pte_Long & 0x10 ? 'N' : '-',
                        Pte_Long & 0x8 ? 'T' : '-',
                        DbgGetOwner(Pte) ? 'U' : 'K',
                        Pte_Long & 0x2 ? 'W' : 'R');
            break;

        case IMAGE_FILE_MACHINE_IA64:

            dprintf("pfn %x %c%c%c%c%c%c%cV",
                        (ULONG) DbgGetFrameNumber(Pte),
                        DbgGetExecute(Pte) ? 'E' : '-',
                        DbgGetSplit(Pte) ? 'S' : '-',
                        DbgGetCopyOnWrite(Pte) ? 'C' : '-',
                        DbgGetDirty(Pte) ? 'D' : '-',
                        DbgGetAccessed(Pte) ? 'A' : '-',
                        DbgGetOwner(Pte) ? 'U' : 'K',
                        DbgGetWrite(Pte) ? 'W' : 'R');

            break;

        default:
            break;
    }
}

LOGICAL
DbgAddressSelfMapped (
    ULONG64 Address
    )
{
    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            if ((Address >= GET_PTE_BASE()) && (Address < GET_PTE_TOP())) {
                return TRUE;
            }
            break;

        case IMAGE_FILE_MACHINE_IA64:

            DbgGetPteBaseIA64();
    
            if (((Address & PTE_BASE_IA64) == PTE_BASE_IA64) &&
                ((Address & ~(VRN_MASK_IA64|PTE_BASE_IA64)) < ((ULONG64)1 << PDI1_SHIFT_IA64))) {
                return TRUE;
            }
            else if (((Address & PDE_BASE_IA64) == PDE_BASE_IA64) &&
                ((Address & ~(VRN_MASK_IA64|PDE_BASE_IA64)) < ((ULONG64)1 << PDI_SHIFT_IA64))) {
                return TRUE;
            }
            else if (((Address & PDE_TBASE_IA64) == PDE_TBASE_IA64) &&
                ((Address & ~(VRN_MASK_IA64|PDE_TBASE_IA64)) < PageSize)) {
                return TRUE;
            }

            break;

        case IMAGE_FILE_MACHINE_AMD64:
            if ((Address >= PTE_BASE_AMD64) && (Address <= PTE_TOP_AMD64)) {
                return TRUE;
            }
            break;

        default:
            break;
    }

    return FALSE;
}

LOGICAL
DbgAddressSuperPaged (
    IN ULONG64 Address,
    OUT PULONG64 PhysicalFrame
    )
{
    UCHAR SuperPageEnabled;
    ULONG64 Kseg0Start;
    ULONG64 Kseg0StartFrame;
    ULONG64 Kseg0End;

    SuperPageEnabled = (UCHAR) GetUlongValue ("nt!MiKseg0Mapping");

    if ((SuperPageEnabled & 0x1) == 0) {
        return FALSE;
    }

    Kseg0StartFrame = GetPointerValue ("nt!MiKseg0StartFrame");
    Kseg0Start = GetPointerValue ("nt!MiKseg0Start");
    Kseg0End = GetPointerValue ("nt!MiKseg0End");

    if ((Address < Kseg0Start) || (Address > Kseg0End + PageSize)) {
        return FALSE;
    }

    *PhysicalFrame = (Address - Kseg0Start) / PageSize + Kseg0StartFrame;
    return TRUE;
}

VOID
DumpPte (
    ULONG64 Address,
    ULONG64 flags
    )
{
    PCHAR Indent;
    ULONG   Levels;
    ULONG64 PageFrameIndex;
    ULONG64 Pte;
    ULONG64 Pde;
    ULONG64 Ppe;
    ULONG64 Pxe;
    ULONG64 CurrentPte;
    ULONG64 CurrentPteContents;
    ULONG   ValidBit;
    ULONG64 Pde_Long=0;
    ULONG64 Pte_Long=0;
    ULONG64 Ppe_Long=0;
    ULONG64 Pxe_Long=0;
    ULONG   PteSize;

    PteSize = GetTypeSize ("nt!_MMPTE");

    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
            Levels = 2;
            break;

        case IMAGE_FILE_MACHINE_IA64:
            if (DbgAddressSuperPaged (Address, &PageFrameIndex)) {
                Ppe = DbgGetPpeAddress (Address);
                Pde = DbgGetPdeAddress (Address);
                Pte = DbgGetPteAddress (Address);
                dprintf("                                 VA %016p\n", Address);

                //
                // Print the calculated PPE/PDE/PTE addresses (but not the
                // contents) for debugging Mm large page problems.
                //

                dprintf("PPE at %016P    PDE at %016P    PTE at %016P\n",
                    Ppe, Pde, Pte);
                dprintf("LARGE PAGE pfn %016p\n", PageFrameIndex);
                return;
            }
            Levels = 3;
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            Levels = 4;
            break;

        default:
            dprintf("Not implemented for this platform\n");
            return;
            break;
    }

    if (DbgAddressSelfMapped (Address)) {

        if (!flags) {

            //
            // The address is the address of a PTE, rather than
            // a virtual address.  Don't get the corresponding
            // PTE contents, use this address as the PTE.
            //

            Address = DbgGetVirtualAddressMappedByPte (Address);
        }
    }

    if (!flags) {
        Pxe = DbgGetPxeAddress (Address);
        Ppe = DbgGetPpeAddress (Address);
        Pde = DbgGetPdeAddress (Address);
        Pte = DbgGetPteAddress (Address);
    } else {
        Pxe = Address;
        Ppe = Address;
        Pde = Address;
        Pte = Address;
    }

    if (Levels >= 3) {
        dprintf("                                 VA %016p\n", Address);
    }
    else {
        dprintf("               VA %08p\n", Address);
    }

    if (Levels == 4) {
       dprintf("PXE @ %016P     PPE at %016P    PDE at %016P    PTE at %016P\n",
            Pxe, Ppe, Pde, Pte);
    }
    else if (Levels == 3) {
       dprintf("PPE at %016P    PDE at %016P    PTE at %016P\n",
            Ppe, Pde, Pte);
    }
    else {
       if (PteSize == 4) {
            dprintf("PDE at   %08P        PTE at %08P\n", Pde, Pte);
       }
       else {
            dprintf("PDE at %016P    PTE at %016P\n", Pde, Pte);
       }
    }

    //
    // Decode the PXE.
    //

    if (Levels >= 4) {

        CurrentPte = Pxe;

        if (GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Hard.Valid", ValidBit)) {
            dprintf("Unable to get PXE %I64X\n", CurrentPte);
            return;
        }

        GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);

        Pxe_Long = CurrentPteContents;

        if (ValidBit == 0) {

            dprintf("contains %016I64X        unavailable\n", Pxe_Long);
            Indent = "";

            if (CurrentPteContents != 0) {
                DbgDisplayInvalidPte (CurrentPte, flags, Indent);
            }
            else {
                dprintf ("\n");
            }
            return;
        }
    }


    //
    // Decode the PPE.
    //

    if (Levels >= 3) {

        CurrentPte = Ppe;

        if (GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Hard.Valid", ValidBit)) {
            dprintf("Unable to get PPE %I64X\n", CurrentPte);
            return;
        }

        GetFieldValue (CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);

        Ppe_Long = CurrentPteContents;

        if (ValidBit == 0) {

            if (Levels >= 4) {
                dprintf("contains %016I64X  contains %016I64X\n",
                            Pxe_Long, Ppe_Long);
                Indent = "                   ";
                DbgDisplayValidPte (Pxe);
            }
            else {
                dprintf("contains %016I64X\n",
                            Ppe_Long);
                Indent = "";
            }
        
            if (CurrentPteContents != 0) {
                DbgDisplayInvalidPte (CurrentPte, flags, Indent);
            }
            else {
                dprintf ("\n");
            }
            return;
        }
    }
    


    //
    // Decode the PDE.
    //


    CurrentPte = Pde;

    if ( GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Hard.Valid", ValidBit) ) {
        dprintf("Unable to get PDE %I64X\n", CurrentPte);
        return;
    }

    GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);

    Pde_Long = CurrentPteContents;

    if (ValidBit == 0) {

        if (Levels >= 4) {
            dprintf("contains %016I64X  contains %016I64X  contains %016I64X\n",
                Pxe_Long, Ppe_Long, Pde_Long);
            DbgDisplayValidPte (Pxe);
            dprintf ("        ");
            DbgDisplayValidPte (Ppe);
            Indent = "                                            ";
        }
        else if (Levels == 3) {
            dprintf("contains %016I64X  contains %016I64X\n",
                Ppe_Long, Pde_Long);
            DbgDisplayValidPte (Ppe);
            Indent = "                   ";
        }
        else {
            if (PteSize == 4) {
                dprintf("contains %08I64X\n", Pde_Long);
            }
            else {
                dprintf("contains %016I64X\n", Pde_Long);
            }

            Indent = "";
        }
        
        if (CurrentPteContents != 0) {
            DbgDisplayInvalidPte (CurrentPte, flags, Indent);
        }
        else {
            dprintf ("\n");
        }
        return;
    }

    //
    // Decode the PTE and print everything out.
    //

    if (Pde_Long & GET_MM_PTE_LARGE_PAGE_MASK()) {
        CurrentPteContents = 0;
    }
    else {

        CurrentPte = Pte;

        if ( GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Hard.Valid", ValidBit) ) {
            dprintf("Unable to get PTE %I64X\n", CurrentPte);
            return;
        }

        GetFieldValue(CurrentPte, "nt!_MMPTE", "u.Long", CurrentPteContents);
    }

    Pte_Long = CurrentPteContents;

    //
    // Print the raw values.
    //

    if (Levels == 4) {
        dprintf("contains %016I64X  contains %016I64X  contains %016I64X  contains %016I64X\n",
            Pxe_Long, Ppe_Long, Pde_Long, Pte_Long);
        Indent = "                                                         ";
        DbgDisplayValidPte (Pxe);
        dprintf ("        ");
        DbgDisplayValidPte (Ppe);
        dprintf ("        ");
        DbgDisplayValidPte (Pde);
        dprintf ("        ");
    }
    else if (Levels == 3) {
        dprintf("contains %016I64X  contains %016I64X  contains %016I64X\n",
            Ppe_Long, Pde_Long, Pte_Long);
        Indent = "                                                        ";
        DbgDisplayValidPte (Ppe);
        dprintf ("            ");
        DbgDisplayValidPte (Pde);
        dprintf ("            ");
    }
    else {
        if (PteSize == 4) {
            dprintf("contains %08I64X      contains %08I64X\n", Pde_Long, Pte_Long);
            Indent = "                      ";
        }
        else {
            dprintf("contains %016I64X  contains %016I64X\n", Pde_Long, Pte_Long);
            Indent = "                      ";
        }
        DbgDisplayValidPte (Pde);
        dprintf ("    ");
    }

    if (Pde_Long & GET_MM_PTE_LARGE_PAGE_MASK()) {
        PageFrameIndex = DbgGetFrameNumber(Pde);
        switch (TargetMachine) { 

            case IMAGE_FILE_MACHINE_I386:
                if (PaeEnabled) {
                    PageFrameIndex += PaeGetPteOffsetX86 (Address);
                }
                else {
                    PageFrameIndex += MiGetPteOffsetX86 (Address);
                }
                break;

            case IMAGE_FILE_MACHINE_AMD64:
                PageFrameIndex += MiGetPteOffsetAMD64 (Address);
                break;

            case IMAGE_FILE_MACHINE_IA64:
                PageFrameIndex += MiGetPteOffsetIA64 (Address);
                break;
        }
        dprintf ("LARGE PAGE %x\n", PageFrameIndex);
    }
    else if (ValidBit != 0) {
        DbgDisplayValidPte (Pte);
        dprintf ("\n");
    }
    else {
        if (CurrentPteContents != 0) {
            DbgDisplayInvalidPte (CurrentPte, flags, Indent);
        }
        else {
            dprintf ("\n");
        }
    }

    dprintf ("\n");

    return;
}

DECLARE_API( pte )

/*++

Routine Description:

     Displays the corresponding PDE and PTE.

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64 Address = 0;
    ULONG64 flags = 0;
    ULONG   flags2 = 0;

    INIT_API();

    if (GetExpressionEx(args,&Address, &args)) {
        if (GetExpressionEx(args,&flags, &args)) {
            flags2  = (ULONG) GetExpression(args);
        }
    }

    switch (TargetMachine) { 
    case IMAGE_FILE_MACHINE_I386:
        Address = (ULONG64) (LONG64) (LONG) Address;
        DumpPte (Address, flags);
        break;
    case IMAGE_FILE_MACHINE_IA64:
        DumpPte (Address, flags);
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        DumpPte (Address, flags);
        break;
    default:
        dprintf("Unknown platform %d\n",TargetMachine);
        break;
    }

    EXIT_API();
    return S_OK;
}


BOOLEAN
GetPhysicalAddress (
    IN ULONG64 Address,
    OUT PULONG64 PhysAddress
    )

/*++

Routine Description:

    Retrieves the physical address corresponding to the supplied virtual
    address.

Arguments:

    Va - Supplies the virtual address for which the PTE address is sought.

    PhysAddress - Supplies a pointer to caller-supplied memory which is to
                  contain the physical address.

Return Value:
    
    TRUE - The supplied Va is valid and it's physical address was placed
           in *PhysAddress.

    FALSE - The supplied Va does not correspond to a valid address.

--*/

{
    ULONG     ValidBit;
    ULONG     LargePageBit;
    ULONG     PageFrameIndex;
    ULONG64   PteAddress, PteContents;

    switch (TargetMachine) { 

        case IMAGE_FILE_MACHINE_I386:
        case IMAGE_FILE_MACHINE_AMD64:
            PteAddress = DbgGetPdeAddress (Address);

            if (GetFieldValue (PteAddress, "nt!_MMPTE", "u.Hard.Valid", ValidBit) ) {
                dprintf("Unable to get PDE %I64X\n", PteAddress);
                return FALSE;
            }

            if (ValidBit == 0) {
                return FALSE;
            }

            if (GetFieldValue(PteAddress, "nt!_MMPTE", "u.Long", PteContents)) {
                dprintf("Unable to get PDE %I64X\n", PteAddress);
                return FALSE;
            }

            if ((PteContents & GET_MM_PTE_LARGE_PAGE_MASK()) == 0) {
                break;
            }

            PageFrameIndex = (ULONG) DbgGetFrameNumber (PteAddress);

            switch (TargetMachine) { 

                case IMAGE_FILE_MACHINE_I386:
                    if (PaeEnabled) {
                        PageFrameIndex += PaeGetPteOffsetX86 (Address);
                    }
                    else {
                        PageFrameIndex += MiGetPteOffsetX86 (Address);
                    }
                    break;

                case IMAGE_FILE_MACHINE_AMD64:
                    PageFrameIndex += (ULONG) MiGetPteOffsetAMD64 (Address);
                    break;

                case IMAGE_FILE_MACHINE_IA64:
                    PageFrameIndex += (ULONG) MiGetPteOffsetIA64 (Address);
                    break;
            }

            *PhysAddress =
                (((ULONG64) PageFrameIndex << DBG_GET_PAGE_SHIFT ()) | (Address & 0xFFF));

            return TRUE;

        default:
            break;
    }

    PteAddress = DbgGetPteAddress (Address);

    if (GetFieldValue (PteAddress, "nt!_MMPTE", "u.Hard.Valid", ValidBit) ) {
        dprintf("Unable to get PTE %I64X\n", PteAddress);
        return FALSE;
    }

    if (ValidBit == 0) {
        return FALSE;
    }

    GetFieldValue (PteAddress, "nt!_MMPTE", "u.Long", PteContents);

    *PhysAddress =
        ((DbgGetFrameNumber(PteAddress) << DBG_GET_PAGE_SHIFT ()) | (Address & 0xFFF));

    return TRUE;
}


typedef struct _BPENTRY {
    ULONG64 VirtualAddress;
    ULONG64 PhysicalAddress;
    ULONG Flags;
    ULONG Contents;
} BPENTRY, *PBPENTRY;

#define PHYSICAL_BP_TABLE_SIZE 16

#define PBP_BYTE_POSITION       0x03
#define PBP_INUSE               0x04
#define PBP_ENABLED             0x08

BPENTRY PhysicalBreakpointTable[PHYSICAL_BP_TABLE_SIZE];


#define MAX_FORMAT_STRINGS 8
LPSTR
FormatAddr64(
    ULONG64 addr
    )
{
    static CHAR strings[MAX_FORMAT_STRINGS][18];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS) {
        next = 0;
    }
    if (addr >> 32) {
        sprintf(string, "%08x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    } else {
        sprintf(string, "%08x", (ULONG)addr);
    }
    return string;
}


DECLARE_API( ubl )
{
    int i;

    INIT_API();
    UNREFERENCED_PARAMETER (args);

    for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
        if (PhysicalBreakpointTable[i].Flags & PBP_INUSE) {
            dprintf("%2d: %c %s (%s) %d %02x",
                    i,
                    (PhysicalBreakpointTable[i].Flags & PBP_ENABLED) ? 'e' : 'd',
                    FormatAddr64(PhysicalBreakpointTable[i].VirtualAddress),
                    FormatAddr64(PhysicalBreakpointTable[i].PhysicalAddress),
                    (PhysicalBreakpointTable[i].Flags & PBP_BYTE_POSITION),
                    PhysicalBreakpointTable[i].Contents
                    );
        }
    }

    EXIT_API();
    return S_OK;
}

void
PbpEnable(
    int n
    )
{
    PBPENTRY Pbp = PhysicalBreakpointTable + n;
    ULONG mask;
    ULONG Data;
    ULONG cb=0;

    mask = 0xff << (8 * (Pbp->Flags & PBP_BYTE_POSITION));
    Data = (Pbp->Contents & ~mask) | (0xcccccccc & mask);

    WritePhysical(Pbp->PhysicalAddress, &Data, 4, &cb);

    if (cb == 4) {
        Pbp->Flags |= PBP_ENABLED;
    }
}

void
PbpDisable(
    int n
    )
{
    PBPENTRY Pbp = PhysicalBreakpointTable + n;
    ULONG cb;

    WritePhysical(Pbp->PhysicalAddress, &Pbp->Contents, 4, &cb);

    if (cb == 4) {
        Pbp->Flags &= ~PBP_ENABLED;
    }
}

void
PbpClear(
    int n
    )
{
    PBPENTRY Pbp = PhysicalBreakpointTable + n;
    ULONG cb;

    WritePhysical(Pbp->PhysicalAddress, &Pbp->Contents, 4, &cb);

    if (cb == 4) {
        Pbp->Flags = 0;
    }
}


DECLARE_API( ubc )
{
    int i;
    int n;

    INIT_API();

    if (*args == '*') {
        //
        // clear them all
        //

        for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
            if (PhysicalBreakpointTable[i].Flags & PBP_INUSE) {
                PbpClear(i);
            }
        }
        EXIT_API();
        return E_INVALIDARG;
    }

    n = sscanf(args,"%d",&i);

    if (n != 1 || i < 0 || i >= PHYSICAL_BP_TABLE_SIZE) {
        dprintf("!ubc: bad breakpoint number\n");
        EXIT_API();
        return  E_INVALIDARG;
    }

    if ( !(PhysicalBreakpointTable[i].Flags & PBP_INUSE)) {
        dprintf("!ubc: breakpoint number %d not set\n", i);
        EXIT_API();
        return E_INVALIDARG;
    }

    PbpClear(i);

    EXIT_API();
    return S_OK;
}

DECLARE_API( ube )
{
    int i;
    int n;

    INIT_API();

    if (*args == '*') {
        //
        // enable them all
        //

        for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
            if (PhysicalBreakpointTable[i].Flags & PBP_INUSE) {
                PbpEnable(i);
            }
        }
        EXIT_API();
        return E_INVALIDARG;
    }

    n = sscanf(args,"%d",&i);

    if (n != 1 || i < 0 || i >= PHYSICAL_BP_TABLE_SIZE) {
        dprintf("!ube: bad breakpoint number\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if ( !(PhysicalBreakpointTable[i].Flags & PBP_INUSE)) {
        dprintf("!ube: breakpoint number %d not set\n", i);
        EXIT_API();
        return E_INVALIDARG;
    }

    PbpEnable(i);

    EXIT_API();
    return S_OK;
}

DECLARE_API( ubd )
{
    int i;
    int n;

    INIT_API();

    if (*args == '*') {
        //
        // disable them all
        //

        for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
            if (PhysicalBreakpointTable[i].Flags & PBP_INUSE) {
                PbpDisable(i);
            }
        }
        EXIT_API();
        return E_INVALIDARG;
    }

    n = sscanf(args,"%d",&i);

    if (n != 1 || i < 0 || i >= PHYSICAL_BP_TABLE_SIZE) {
        dprintf("!ubd: bad breakpoint number\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if ( !(PhysicalBreakpointTable[i].Flags & PBP_INUSE)) {
        dprintf("!ubd: breakpoint number %d not set\n", i);
        EXIT_API();
        return E_INVALIDARG;
    }

    PbpDisable(i);

    EXIT_API();
    return S_OK;
}

DECLARE_API( ubp )
{
    ULONG64 Address;
    ULONG   result;
    ULONG PageShift;
    PMMPTEx  Pte;
    PMMPTEx  Pde;
    ULONG64 PdeContents;
    ULONG64 PteContents;
    PBPENTRY Pbp = NULL;
    ULONG cb;
    int i;
    ULONG64 PhysicalAddress;

    static BOOL DoWarning = TRUE;

    INIT_API();

    if (DoWarning) {
        DoWarning = FALSE;
        dprintf("This command is VERY DANGEROUS, and may crash your system!\n");
        dprintf("If you don't know what you are doing, enter \"!ubc *\" now!\n\n");
    }

    for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
        if (!(PhysicalBreakpointTable[i].Flags & PBP_INUSE)) {
            Pbp = PhysicalBreakpointTable + i;
            break;
        }
    }

    if (!Pbp) {
        dprintf("!ubp: breakpoint table is full!\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    Address = GetExpression(args);

    if ((Address >= GET_PTE_BASE()) && (Address < GET_PDE_TOP())) {

        //
        // The address is the address of a PTE, rather than
        // a virtual address.
        //

        dprintf("!ubp: cannot set a breakpoint on a PTE\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    Pde = DbgGetPdeAddress (Address);
    Pte = DbgGetPteAddress (Address);

    if ( !ReadMemory( (DWORD)Pde,
                      &PdeContents,
                      sizeof(ULONG),
                      &result) ) {
        dprintf("!ubp: %08lx: Unable to get PDE\n",Pde);
        EXIT_API();
        return E_INVALIDARG;
    }

    if (!(PdeContents & 0x1)) {
        dprintf("!ubp: no valid PTE\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if (PdeContents & GET_MM_PTE_LARGE_PAGE_MASK()) {
        dprintf("!ubp: not supported for large page\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    if ( GetFieldValue( Pte, "nt!_MMPTE", "u.Long", PteContents) ) {
        dprintf("!ubp: %08p: Unable to get PTE (PDE = %08p)\n",Pte, Pde);
        EXIT_API();
        return E_INVALIDARG;
    }

    if (!(PteContents & 1)) {
        dprintf("!ubp: no valid PTE\n");
        EXIT_API();
        return E_INVALIDARG;
    }

    PageShift = DBG_GET_PAGE_SHIFT ();
    PhysicalAddress = ((DbgGetFrameNumber (PteContents)) << PageShift);
    PhysicalAddress &= ~((1 << PageShift) - 1);
    PhysicalAddress |= (Address & ~((1 << PageShift) - 1));
    PhysicalAddress &= ~3;

    for (i = 0; i < PHYSICAL_BP_TABLE_SIZE; i++) {
        if (PhysicalBreakpointTable[i].PhysicalAddress == PhysicalAddress) {
            dprintf("!ubp: cannot set two breakpoints in the same word\n");
            EXIT_API();
            return E_INVALIDARG;
        }
    }

    ReadPhysical(PhysicalAddress, &Pbp->Contents, 4, &cb);

    if (cb != 4) {
        dprintf("!ubp: unable to read physical at 0x%08x\n", PhysicalAddress);
        EXIT_API();
        return E_INVALIDARG;
    }

    Pbp->VirtualAddress = Address;
    Pbp->PhysicalAddress = PhysicalAddress;
    Pbp->Flags = PBP_INUSE | ((ULONG) Address & 3);

    PbpEnable((int)(Pbp - PhysicalBreakpointTable));

    EXIT_API();
    return S_OK;
}

DECLARE_API( halpte )
{

#define HAL_VA_START_X86    0xffffffffffd00000
    
    ULONG64 virtAddr = HAL_VA_START_X86;
    ULONG64 pteAddr;
    ULONG64 pteContents;
    ULONG  count = 0;

    INIT_API();
    UNREFERENCED_PARAMETER (args);

    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("X86 only API\n");
        EXIT_API();
        return E_UNEXPECTED;
    }
    dprintf("\n\nDumping HAL PTE ranges\n\n");
    
    while (virtAddr < 0xffffffffffffe000) {

        pteAddr = DbgGetPteAddress(virtAddr);

        if (!InitTypeRead(pteAddr, nt!_MMPTE)) {

            if (pteContents = ReadField(u.Long)) {

                dprintf("[%03x] %p -> %I64x\n", 
                        count++, 
                        virtAddr, 
                        pteContents & (ULONG64) ~0xFFF);
            }
        }

        virtAddr += PageSize;
    }

    EXIT_API();
    return S_OK;
}



#if defined(ALT_4K)

#undef MiGetAltPteAddress

#define MiGetAltPteAddress(VA) \
      ((ULONG64) (ALT4KB_PERMISSION_TABLE_START + \
                     ((((ULONG64) (VA)) >> PAGE_4K_SHIFT) << ALT_PTE_SHIFT)))

#endif // defined(ALT_4K)

//
// Limit the IA32 subsystem to a 2GB virtual address space.
// This means "Large Address Aware" apps are not supported in emulation mode.
//

#define _MAX_WOW64_ADDRESS       (0x00000000080000000UI64)


DECLARE_API( ate )

/*++

Routine Description:

     Displays the correnponding ATE.

Arguments:

     Args - Address Flags

Return Value:

     None

--*/
{
#if defined(ALT_4K)
    ULONG64 Address;
    ULONG flags;
    ULONG Result;
    ULONG64 PointerAte;
    ULONG64 Process;
    ULONG     AltTable[(_MAX_WOW64_ADDRESS >> PTI_SHIFT)/32];
    ULONG64 *Wow64Process; 
    

    if (GetExpressionEx(args,&Address, &args)) {
        flags  = (ULONG) GetExpression(args);
    }

    Address = Address & ~((ULONG64)PageSize - 1);
    
    PointerAte = MiGetAltPteAddress(Address);

    if ( InitTypeRead( PointerAte,
                       nt!_MMPTE) ) {
        dprintf("Unable to get ATE %p\n", PointerAte);
        return E_INVALIDARG;
    }
        
    dprintf("%016I64X: %016I64X  ", PointerAte, ReadField(u.Long));

    dprintf("PTE off: %08I64X  protect: ",
            ReadField(u.Alt.PteOffset));

    DbgPrintProtection((ULONG) ReadField(u.Alt.Protection));

    dprintf("  %c%c%c%c%c%c%c%c%c%c\n",
            ReadField(u.Alt.Commit) ? 'V' : '-',
            ReadField(u.Alt.Accessed) ? '-' : 'G',
            ReadField(u.Alt.Execute) ? 'E' : '-',
            ReadField(u.Alt.Write) ? 'W' : 'R',
            ReadField(u.Alt.Lock) ? 'L' : '-',
            ReadField(u.Alt.FillZero) ? 'Z' : '-',
            ReadField(u.Alt.NoAccess) ? 'N' : '-',
            ReadField(u.Alt.CopyOnWrite) ? 'C' : '-',
            ReadField(u.Alt.PteIndirect) ? 'I' : '-',
            ReadField(u.Alt.Private) ? 'P' : '-');

#else

    UNREFERENCED_PARAMETER (args);
    UNREFERENCED_PARAMETER (Client);

#endif // defined(ALT_4K)

    return S_OK;
}
 
DECLARE_API( pte2va )

/*++

Routine Description:

     Displays the correnponding ATE.

Arguments:

     Args - Address Flags

Return Value:

     None

--*/
{
    ULONG64 Address=0;
    ULONG flags=0;
    
    UNREFERENCED_PARAMETER (Client);

    if (GetExpressionEx(args,&Address, &args)) {
        flags  = (ULONG) GetExpression(args);
    }

    Address = DbgGetVirtualAddressMappedByPte(Address);

    dprintf("%p \n", Address);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\ptov.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ptov.c

Abstract:

    Kernel debugger extension for dumping all physical to
    virtual translations for a given process.

Author:

    John Vert (jvert) 25-Jul-1995

Revision History:

--*/
#include "precomp.h"

BOOL
ReadPhysicalPage(
    IN ULONG64 PageNumber,
    OUT PVOID Buffer
    );


DECLARE_API( ptov )

/*++

Routine Description:

    Dumps all physical to virtual translations for a given process

Arguments:

    args - supplies physical address of PDE

Return Value:

    None.

--*/

{
    ULONG64 PdeAddress=0;
    ULONG ActualRead;
    PCHAR PageDirectory;
    PCHAR PageTable;
    ULONG i,j;
    ULONG64 VirtualPage=0;
    ULONG SizeOfHwPte;
    ULONG Flags = 1;
    ULONG ValidOff, ValidSize, PfnOff, PfnSz;
    HRESULT Hr = S_OK;

    if (sscanf(args, "%I64lx %lx", &PdeAddress, &Flags) < 1 || PdeAddress == 0) {
        dprintf("usage: ptov PFNOfPDE\n");
        return E_INVALIDARG;
    }

    if (PageSize == 0){
        dprintf("Cpuld not get PageSize\n");
        return E_INVALIDARG;
    }
    PageDirectory = LocalAlloc(LMEM_FIXED, PageSize);
    if (PageDirectory == NULL) {
        dprintf("Couldn't allocate %d bytes for page directory\n",PageSize);
        return E_OUTOFMEMORY;
    }
    PageTable = LocalAlloc(LMEM_FIXED, PageSize);
    if (PageTable == NULL) {
        dprintf("Couldn't allocate %d bytes for page table\n",PageSize);
        LocalFree(PageDirectory);
        return E_OUTOFMEMORY;
    }

    SizeOfHwPte = GetTypeSize("nt!HARDWARE_PTE");
    GetBitFieldOffset("nt!HARDWARE_PTE", "Valid", &ValidOff, &ValidSize);
    GetBitFieldOffset("nt!HARDWARE_PTE", "PageFrameNumber", &PfnOff, &PfnSz);
    __try {
        if (ReadPhysicalPage(PdeAddress,PageDirectory)) {
            for (i=0;i<PageSize/SizeOfHwPte;i++) {
                ULONG64 thisPageDir;
                ULONG64 PageFrameNumber;

                if (SizeOfHwPte == 4) {
                    thisPageDir = *((PULONG)PageDirectory + i);
                } else {
                    thisPageDir = *((PULONG64)PageDirectory + i);
                }

                if (CheckControlC()) {
                    Hr = E_ABORT;
                    __leave;
                }

                PageFrameNumber = GetBits(thisPageDir, PfnOff, PfnSz);

                if (((thisPageDir >> ValidOff) & 1) &&
                    ReadPhysicalPage(PageFrameNumber,PageTable)) {

                    for (j=0;j<PageSize/SizeOfHwPte;j++) {
                        ULONG64 thisPageTable;

                        if (SizeOfHwPte == 4) {
                            thisPageTable = *((PULONG)PageTable + j);
                        } else {
                            thisPageTable = *((PULONG64)PageTable + j);
                        }

                        if ( CheckControlC() ) {
                            Hr = E_INVALIDARG;
                            __leave;
                        }
                        if ((thisPageTable >> ValidOff) & 1) {
                            dprintf("%I64lx %I64lx\n",GetBits(thisPageTable, PfnOff, PfnSz)*PageSize,VirtualPage);
                        }
                        VirtualPage+=PageSize;
                    }
                } else {
                    VirtualPage += PageSize * (PageSize/SizeOfHwPte);
                }
            }
        }
    } __finally {
        LocalFree(PageDirectory);
        LocalFree(PageTable);
    }
    return Hr;
}

ULONG
DBG_GET_PAGE_SHIFT (
    VOID
    );

BOOL
ReadPhysicalPage(
    IN ULONG64 PageNumber,
    OUT PVOID Buffer
    )
{
    ULONG i;
    ULONG64 Address;

    //
    // do the read 1k at a time to avoid overflowing the packet maximum.
    //
    Address = PageNumber << DBG_GET_PAGE_SHIFT();
    if (!IsPtr64()) {
//        Address = (ULONG64) (LONG64) (LONG) Address;
    }
//    dprintf("Pg no %I64lx shft by %d, PhyAddr %I64lx\n", PageNumber, DBG_GET_PAGE_SHIFT(), Address);
    for (i=0; i<PageSize/1024; i++) {
        ULONG ActualRead = 0;
        ReadPhysical(Address, Buffer, 1024, &ActualRead);
        if (ActualRead != 1024) {
            dprintf("physical read at %p failed\n",Address);
            return(FALSE);
        }
        Address += 1024;
        Buffer = (PVOID)((PUCHAR)Buffer + 1024);
    }
    return(TRUE);
}


ULONG64
DBG_GET_MM_SESSION_SPACE_DEFAULT (
    VOID
    );


DECLARE_API( vtop )

/*++

Routine Description:

    Dumps the virtual to physical translation for a page

Arguments:

    args - supplies physical address of PDE

Return Value:

    None.

--*/

{
    ULONG ActualRead;
    ULONG i,j;
    PUCHAR PageDirectory;
    PUCHAR PageTable;
    ULONG64 PdeAddress = 0;
    ULONG64 VirtualPage= 0;//DBG_GET_MM_SESSION_SPACE_DEFAULT();
    ULONG PageShift,SizeOfHwPte;
    ULONG ValidOff, ValidSize, PfnOff, PfnSz, TransOff, TransSize;
    HRESULT Hr;

    if (!sscanf(args,"%I64lx %I64lx", &PdeAddress,&VirtualPage)) {
        // Do not use GetExpression - physical addresses
        //        VirtualPage = GetExpression(args);
        PdeAddress = 0;
        VirtualPage = 0;
    }

    if (!(SizeOfHwPte = GetTypeSize("nt!HARDWARE_PTE")) ) {
        dprintf("Cannot find HARDWARE_PTE\n");
        return E_INVALIDARG;
    }

    PageShift = DBG_GET_PAGE_SHIFT();
    if ((PdeAddress == 0) && (VirtualPage == 0)) {
        dprintf("usage: vtop PFNOfPDE VA\n");
        return E_INVALIDARG;
    } else if (VirtualPage)
    {
        ULONG64 Process;

        Process = GetExpression("@$proc");

        if (GetFieldValue(Process, "nt!_KPROCESS", "DirectoryTableBase[0]", PdeAddress) != S_OK)
        {
            dprintf("Cannot read DirectoryTableBase for currect process\n");
            return E_FAIL;
        }

    }

    // Common mistake, typed in full 32 bit address, not pfn
    if( PdeAddress & ~((1 << (32-PageShift)) - 1) ) {
        PdeAddress >>= PageShift;
    }

    PageDirectory = LocalAlloc(LMEM_FIXED, PageSize);
    if (PageDirectory == NULL) {
        dprintf("Couldn't allocate %d bytes for page directory\n",PageSize);
        return E_INVALIDARG;
    }
    PageTable = LocalAlloc(LMEM_FIXED, PageSize);
    if (PageTable == NULL) {
        dprintf("Couldn't allocate %d bytes for page table\n",PageSize);
        LocalFree(PageDirectory);
        return E_INVALIDARG;
    }

    __try {
        i =(ULONG) ( VirtualPage / (PageSize*(PageSize/ SizeOfHwPte)));
        j = (ULONG) ((VirtualPage % (PageSize*(PageSize/ SizeOfHwPte))) / PageSize);

        dprintf("Pdi %x Pti %x\n",i,j);
        GetBitFieldOffset("nt!_MMPTE", "u.Soft.Transition", &TransOff, &TransSize);
        GetBitFieldOffset("nt!HARDWARE_PTE", "Valid", &ValidOff, &ValidSize);
        GetBitFieldOffset("nt!HARDWARE_PTE", "PageFrameNumber", &PfnOff, &PfnSz);

        if (ReadPhysicalPage(PdeAddress,PageDirectory)) {
            ULONG64 thisPageDir;

            if (SizeOfHwPte == 4) {
                thisPageDir = *((PULONG)PageDirectory + i);
            } else {
                thisPageDir = *((PULONG64)PageDirectory + i);
            }

            if (CheckControlC()) {
                Hr = E_INVALIDARG;
                __leave;
            }

            if ((thisPageDir >> ValidOff) & 1) {
                ULONG64 PageFrameNumber;
                ULONG64 thisPageTable;

                PageFrameNumber = GetBits(thisPageDir, PfnOff, PfnSz);

                if (!ReadPhysicalPage(PageFrameNumber,PageTable)) {
                    Hr =  E_INVALIDARG;
                    __leave;
                }

                if (SizeOfHwPte == 4) {
                    thisPageTable = *((PULONG)PageTable + j);
                } else {
                    thisPageTable = *((PULONG64)PageTable + j);
                }

                if ((thisPageTable >> ValidOff) & 1) {
                    dprintf("%08I64lx %08I64lx pfn(%05I64lx)\n",
                            VirtualPage,
                            GetBits(thisPageTable, PfnOff, PfnSz)*PageSize,
                            GetBits(thisPageTable, PfnOff, PfnSz)
                            );
                }
                else {

                    if ((thisPageTable >> TransOff) & 1) {
                        dprintf("%08I64lx Transition %08I64lx (%05I64lx)\n",
                                VirtualPage,
                                GetBits(thisPageTable, PfnOff, PfnSz)*PageSize,
                                GetBits(thisPageTable, PfnOff, PfnSz)
                                );
                    }
                    else {
                        dprintf("%08I64lx Not present (%p)\n",VirtualPage,thisPageTable);
                    }
                }
            }
            else {
                dprintf("PageDirectory Entry %u not valid, try another process\n",i);
        }
    }
    } __finally {
        LocalFree(PageDirectory);
        LocalFree(PageTable);
    }
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\registry.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regext.c

Abstract:

    Kernel debugger extensions useful for the registry

Author:

    John Vert (jvert) 7-Sep-1993

Environment:

    Loaded as a kernel debugger extension

Revision History:

    John Vert (jvert) 7-Sep-1993
        created

    Dragos C. Sambotin (dragoss) 05-May-2000
        updated to support new registry layout
        enhanced with new commands

--*/


#include "precomp.h"
#pragma hdrstop

ULONG TotalPages;
ULONG TotalPresentPages;
PCHAR pc;

BOOLEAN  SavePages;
BOOLEAN  RestorePages;
HANDLE   TempFile;
ULONG64  gHiveListAddr;

static ULONG DirectoryOffset, TableOffset, BlockAddrOffset, PtrSize, ULongSize, HMapSize, GotOnce = FALSE;

void
poolDumpHive(
    IN ULONG64 Hive
    );

VOID
poolDumpMap(
    IN ULONG   Length,
    IN ULONG64 Map
    );


void
dumpHiveFromFile(
    HANDLE hFile
    );

void 
regdumppool(
            LPSTR args
           )
/*++

Routine Description:

    Goes through all the paged pool allocated to registry space and
    determines which pages are present and which are not.

    Called as:

        !regpool [s|r]

        s Save list of registry pages to temporary file
        r Restore list of registry pages from temp. file

Arguments:

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.

Return Value:

    None.

--*/

{
    ULONG64 pCmpHiveListHead;
    ULONG64 pNextHiveList;
    ULONG64 pHiveListEntry;
    ULONG BytesRead;
    ULONG64 CmHive;
    BYTE HiveList[1024];
    CHAR            Dummy1[ 256 ],Dummy2[64];

    if (!sscanf(args,"%255s %255s",Dummy1,Dummy2)) {
        Dummy2[0] = 0;
    }

    if (toupper(Dummy2[0])=='S') {
        SavePages = TRUE;
    } else {
        SavePages = FALSE;
    }
    if (toupper(Dummy2[0])=='R') {
        RestorePages = TRUE;
    } else {
        RestorePages = FALSE;
    }

    //
    // Go get the hivelist.
    //
    // memset(HiveList,0,sizeof(HiveList));
    pHiveListEntry = GetExpression("nt!CmpMachineHiveList");
    gHiveListAddr = pHiveListEntry;
    if (pHiveListEntry != 0) {
        // Kd caches hive list
        ReadMemory(pHiveListEntry,
                   HiveList,
                   8 * GetTypeSize("_HIVE_LIST_ENTRY"),
                   &BytesRead);
    }

    //
    // First go and get the hivelisthead
    //
    pCmpHiveListHead = GetExpression("nt!CmpHiveListHead");
    if (pCmpHiveListHead==0) {
        dprintf("CmpHiveListHead couldn't be read\n");
        return;
    }

    

    if (!ReadPointer(pCmpHiveListHead, &pNextHiveList)) {
        dprintf("Couldn't read first Flink (%p) of CmpHiveList\n",
                pCmpHiveListHead);
        return;
    }

    TotalPages = TotalPresentPages = 0;

    if (SavePages || RestorePages) {
        TempFile = CreateFile( "regext.dat",
                               GENERIC_READ | GENERIC_WRITE,
                               0,
                               NULL,
                               OPEN_ALWAYS,
                               0,
                               NULL
                             );
        if (TempFile == INVALID_HANDLE_VALUE) {
            dprintf("Couldn't open regext.dat\n");
            return;
        }
    }

    if (RestorePages) {
        dumpHiveFromFile(TempFile);
    } else {
        ULONG HiveListOffset;
        FIELD_INFO offField = {"HiveList", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
        SYM_DUMP_PARAM TypeSym ={                                                     
            sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
            NULL, NULL, NULL, 1, &offField
        };
        
        // Get The offset
        if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
           return;
        }
        HiveListOffset = (ULONG) offField.address;
        
        
        
        while (pNextHiveList != pCmpHiveListHead) {
            CmHive = pNextHiveList - HiveListOffset;
            
            poolDumpHive(CmHive);

            if (GetFieldValue(pNextHiveList, "nt!_LIST_ENTRY", "Flink", pNextHiveList)) {
                dprintf("Couldn't read Flink (%p) of %p\n",
                          pCmpHiveListHead,pNextHiveList);
                break;
            }

            if (CheckControlC()) {
                return;
            }
        }
    }

    dprintf("Total pages present = %d / %d\n",
            TotalPresentPages,
            TotalPages);

    if (SavePages || RestorePages) {
        CloseHandle( TempFile );
    }
}

BOOLEAN
GetHiveMaps(
    ULONG64 pHive,
    ULONG64 *pStableMap,
    ULONG   *pStableLength,
    ULONG64 *pVolatileMap,
    ULONG   *pVolatileLength
    )
{
    ULONG   BytesRead;
    ULONG Stable_Length=0, Volatile_Length=0;
    ULONG64 Stable_Map=0, Volatile_Map=0;
    ULONG StorageOffset, DUAL_Size;
    FIELD_INFO offField = {"Hive.Storage", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Hive.Storage in _CMHIVE
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        dprintf("Cannot find _CMHIVE type.\n");
        return FALSE;
    }
    
    StorageOffset = (ULONG) offField.address;

    DUAL_Size = GetTypeSize("_DUAL");
    GetFieldValue(pHive + StorageOffset + Stable*DUAL_Size, "_DUAL", "Length", Stable_Length);
    GetFieldValue(pHive + StorageOffset + Volatile*DUAL_Size, "_DUAL", "Length", Volatile_Length);
    GetFieldValue(pHive + StorageOffset + Stable*DUAL_Size, "_DUAL", "Map", Stable_Map);
    GetFieldValue(pHive + StorageOffset + Volatile*DUAL_Size, "_DUAL", "Map", Volatile_Map);

    (*pStableMap) = Stable_Map;
    (*pStableLength) = Stable_Length;
    (*pVolatileMap) = Volatile_Map;
    (*pVolatileLength) = Volatile_Length;
    return TRUE;
}

BOOLEAN 
USE_OLD_CELL(
    ULONG64     pHive
             ) 
{
    ULONG                   Version;
    
    if(!GetFieldValue(pHive, "nt!_CMHIVE", "Hive.Version", Version)) {
        return (Version==1);
    }
    return FALSE;
}

ULONG64
MyHvpGetCellPaged(
    ULONG64     pHive,
    ULONG       Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for hives with full maps.
    It is the normal version of the routine.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    ULONG           Type;
    ULONG           Table;
    ULONG           Block;
    ULONG           Offset;
    ULONG           Stable_Length=0, Volatile_Length=0;
    ULONG64         Stable_Map=0, Volatile_Map=0;
    ULONG64         MapTable;
    ULONG64         Map;
    ULONG64         MapEntryAddress, BlockAddress=0;
    ULONG64       lRez;
    ULONG64       pcell;

    if(!GetHiveMaps(pHive,&Stable_Map,&Stable_Length,&Volatile_Map,&Volatile_Length) ) {
        return 0;
    }

    
    Type = ((ULONG)((Cell & HCELL_TYPE_MASK) >> HCELL_TYPE_SHIFT));
    Table = (Cell & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT;
    Block = (Cell & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT;
    Offset = (Cell & HCELL_OFFSET_MASK);

    if( Type == 0 ) {
        Map = Stable_Map;
    } else {
        Map = Volatile_Map;
    }

    dprintf("Map = %p Type = %lx Table = %lx Block = %lx Offset = %lx\n",Map,Type,Table,Block,Offset);

    if (!ReadPointer(Map + DirectoryOffset + Table*PtrSize,
                 &MapTable))
        return 0;

    dprintf("MapTable     = %p \n",MapTable);

    MapEntryAddress = MapTable + Block * HMapSize + BlockAddrOffset;
    if (!ReadPointer(MapEntryAddress, &BlockAddress)) {
        dprintf("  can't read HMAP_ENTRY at %p\n",
                  MapEntryAddress);
        return 0;
    }

    dprintf("BlockAddress = %p \n\n",BlockAddress);

    pcell = ((ULONG64)(BlockAddress) + Offset);
    lRez = (ULONG64)pcell; 
    if (USE_OLD_CELL(pHive)) {
        return lRez + ULongSize + ULongSize;
        //return (struct _CELL_DATA *)&(hcell.u.OldCell.u.UserData);
    } else {
        return lRez + ULongSize;
        //return (struct _CELL_DATA *)&(hcell.u.NewCell.u.UserData);
    }
    return 0;
}

ULONG64
MyHvpGetCellFlat(
    ULONG64     pHive,
    ULONG       Cell
    )
/*++

Routine Description:

    Returns the memory address for the specified Cell.  Will never
    return failure, but may assert.  Use HvIsCellAllocated to check
    validity of Cell.

    This routine should never be called directly, always call it
    via the HvGetCell() macro.

    This routine provides GetCell support for read only hives with
    single allocation flat images.  Such hives do not have cell
    maps ("page tables"), instead, we compute addresses by
    arithmetic against the base image address.

    Such hives cannot have volatile cells.

Arguments:

    Hive - supplies a pointer to the hive control structure for the
            hive of interest

    Cell - supplies HCELL_INDEX of cell to return address for

Return Value:

    Address of Cell in memory.  Assert or BugCheck if error.

--*/
{
    ULONG64     BaseBlock;
    ULONG64   lRez;

    if (GetFieldValue(pHive, "nt!_CMHIVE", "Hive.BaseBlock", BaseBlock)) {
        dprintf("\tCan't CMHIVE Read from %p\n",pHive);
        return 0;
    }

    

    //
    // Address is base of Hive image + Cell
    //
    lRez = (ULONG64)BaseBlock + HBLOCK_SIZE + Cell;
    if (USE_OLD_CELL(pHive)) {
        return lRez + ULongSize + ULongSize;
        //return (struct _CELL_DATA *)&(pcell->u.OldCell.u.UserData);
    } else {
        return lRez + ULongSize;
        //return (struct _CELL_DATA *)&(pcell->u.NewCell.u.UserData);
    }
    return 0;
}

void
poolDumpHive(
    IN ULONG64 pHive
    )
{
    ULONG   BytesRead;
    WCHAR   FileName[HBASE_NAME_ALLOC/2 + 1];
    CHAR    buf[512];
    ULONG   cb;
    ULONG Stable_Length=0, Volatile_Length=0;
    ULONG64 Stable_Map=0, Volatile_Map=0;
    ULONG64 BaseBlock;
    ULONG StorageOffset, DUAL_Size;
    FIELD_INFO offField = {"Hive.Storage", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Hive.Storage in _CMHIVE
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        dprintf("Cannot find _CMHIVE type.\n");
        return ;
    }
    
    StorageOffset = (ULONG) offField.address;

    dprintf("\ndumping hive at %p ",pHive);
    
    if (GetFieldValue(pHive, "nt!_CMHIVE", "Hive.BaseBlock", BaseBlock)) {
        dprintf("\tCan't CMHIVE Read from %p\n",pHive);
        return;
    }

    if (GetFieldValue( BaseBlock, "_HBASE_BLOCK", "FileName", FileName )) {
        wcscpy(FileName, L"UNKNOWN");
    } else {
        if (FileName[0]==L'\0') {
            wcscpy(FileName, L"NONAME");
        } else {
            FileName[HBASE_NAME_ALLOC/2]=L'\0';
        }
    }

    dprintf("(%ws)\n",FileName);

    DUAL_Size = GetTypeSize("_DUAL");
    GetFieldValue(pHive + StorageOffset + Stable*DUAL_Size, "_DUAL", "Length", Stable_Length);
    GetFieldValue(pHive + StorageOffset + Volatile*DUAL_Size, "_DUAL", "Length", Volatile_Length);
    GetFieldValue(pHive + StorageOffset + Stable*DUAL_Size, "_DUAL", "Map", Stable_Map);
    GetFieldValue(pHive + StorageOffset + Volatile*DUAL_Size, "_DUAL", "Map", Volatile_Map);
    
    dprintf("  Stable Length = %lx\n",Stable_Length);
    if (SavePages) {
        sprintf(buf,
                "%ws %d %d\n",
                FileName,
                Stable_Length,
                Volatile_Length);
        WriteFile( TempFile, buf, strlen(buf), &cb, NULL );
    }
    poolDumpMap(Stable_Length, Stable_Map);

    dprintf("  Volatile Length = %lx\n",Volatile_Length);
    poolDumpMap(Volatile_Length, Volatile_Map);

}


VOID
poolDumpMap(
    IN ULONG   Length,
    IN ULONG64 Map
    )
{
    ULONG Tables;
    ULONG MapSlots;
    ULONG i;
    ULONG BytesRead;
    ULONG64 MapTable;
    ULONG Garbage;
    ULONG Present=0;
    CHAR    buf[512];
    ULONG   cb;
    
    // Get the offsets
    if (!GotOnce) {
        if (GetFieldOffset("_HMAP_DIRECTORY", "Directory", &DirectoryOffset)){
            return;
        }
        if (GetFieldOffset("_HMAP_ENTRY", "BlockAddress", &BlockAddrOffset)) {
            return;
        }
        if (GetFieldOffset("_HMAP_TABLE", "Table", &TableOffset)) {
            return;
        }
        PtrSize = DBG_PTR_SIZE;
        ULongSize = sizeof(ULONG); // This doesn't change with target GetTypeSize("ULONG");
        HMapSize = GetTypeSize("_HMAP_ENTRY");
        GotOnce = TRUE;
    }

    if (Length==0) {
        return;
    }

    MapSlots = Length / HBLOCK_SIZE;
    Tables = 1+ ((MapSlots-1) / HTABLE_SLOTS);

    //
    // read in map directory
    //
//    ReadMemory((DWORD)Map,
//             &MapDirectory,
//             Tables * sizeof(PHMAP_TABLE),
//             &BytesRead);
/*    if (BytesRead < (Tables * sizeof(PHMAP_TABLE))) {
        dprintf("Only read %lx/%lx bytes from %lx\n",
                  BytesRead,
                  Tables * sizeof(PHMAP_TABLE),
                  Map);
        return;

    }*/

    //
    // check out each map entry
    //
    for (i=0; i<MapSlots; i++) {
        ULONG64 MapEntryAddress, BlockAddress=0;

        if (!ReadPointer(Map + DirectoryOffset + (i/HTABLE_SLOTS)*PtrSize,
                     &MapTable))
            return;

        MapEntryAddress = MapTable + TableOffset + (i%HTABLE_SLOTS) * HMapSize;
        if (!ReadPointer(MapEntryAddress, &BlockAddress)) {
            dprintf("  can't read HMAP_ENTRY at %p\n",
                      MapEntryAddress);
        }

        if (SavePages) {
            sprintf(buf, "%I64lx\n",UNEXTEND64(BlockAddress));
            WriteFile( TempFile, buf, strlen(buf), &cb, NULL );
            dprintf("%s",buf);
        }

        //
        // probe the HBLOCK
        //
        ReadMemory( BlockAddress,
                    &Garbage,
                    sizeof(ULONG),
                    &BytesRead);
        if (BytesRead > 0) {
            ++Present;
        }
        if (CheckControlC()) {
            return;
        }
    }
    dprintf("  %d/%d pages present\n",
              Present,
              MapSlots);

    TotalPages += MapSlots;
    TotalPresentPages += Present;

}


void
dumpHiveFromFile(
    HANDLE hFile
    )

/*++

Routine Description:

    Takes a list of the registry hives and pages from a file and
    checks to see how many of the pages are in memory.

    The format of the file is as follows
       hivename stablelength volatilelength
       stable page address
       stable page address
            .
            .
            .
       volatile page address
       volatile page address
            .
            .
            .
       hivename stablelength volatilelength
            .
            .
            .


Arguments:

    File - Supplies a file.

Return Value:

    None.

--*/

{
#if 0
    CHAR Hivename[33];
    ULONG StableLength;
    ULONG VolatileLength;
    ULONG64 Page;
    ULONG NumFields;
    ULONG Garbage;
    ULONG Present;
    ULONG Total;
    ULONG BytesRead;
    BYTE  buf[512];

    while (!feof(File)) {
        NumFields = fscanf(File,"%s %d %d\n",
                            Hivename,
                            &StableLength,
                            &VolatileLength);
        if (NumFields != 3) {
            dprintf("fscanf returned %d\n",NumFields);
            return;
        }

        dprintf("\ndumping hive %s\n",Hivename);
        dprintf("  Stable Length = %lx\n",StableLength);
        Present = 0;
        Total = 0;
        while (StableLength > 0) {
            fscanf(File, "%I64lx\n",&Page);
            ReadMemory((DWORD)Page,
                        &Garbage,
                        sizeof(ULONG),
                        &BytesRead);
            if (BytesRead > 0) {
                ++Present;
            }
            ++Total;
            StableLength -= HBLOCK_SIZE;
        }
        if (Total > 0) {
            dprintf("  %d/%d stable pages present\n",
                      Present,Total);
        }
        TotalPages += Total;
        TotalPresentPages += Present;

        dprintf("  Volatile Length = %lx\n",VolatileLength);
        Present = 0;
        Total = 0;
        while (VolatileLength > 0) {
            fscanf(File, "%lx\n",&Page);
            ReadMemory(Page,
                       &Garbage,
                       sizeof(ULONG),
                       &BytesRead);
            if (BytesRead > 0) {
                ++Present;
            }
            ++Total;
            VolatileLength -= HBLOCK_SIZE;
        }
        if (Total > 0) {
            dprintf("  %d/%d volatile pages present\n",
                      Present,Total);
        }

        TotalPages += Total;
        TotalPresentPages += Present;
    }
#endif //0
}

USHORT
GetKcbName(
    ULONG64 KcbAddr,
    PWCHAR  NameBuffer,
    ULONG   BufferSize
)
/*++

Routine Description:

    Takes a kcb and dump its complete name.

Arguments:

    KcbAddr - Address of key control block.

    NameBuffer - The Name buffer to fill in the name.

    BufferSize - Size of Buffer.
Return Value:

    Size of Name String.

--*/
{
    WCHAR Name[ 256 ];
    ULONG64 TmpKcbAddr;
    ULONG64 NameBlockAddr;
    DWORD   BytesRead;
    ULONG   Length;
    ULONG   TotalLength;
    ULONG   size;
    ULONG   i;
    ULONG   BeginPosition;
    ULONG   NameOffset;
    WCHAR  *w1, *w2;
    WCHAR  *BufferEnd;
    UCHAR  *u2;

    //
    // Calculate the total string length.
    //
    TotalLength = 0;
    TmpKcbAddr = KcbAddr;
    //    dprintf("Kcb %p ", KcbAddr);
    while (TmpKcbAddr) {
        ULONG Compressed=0, NameLength=0;

        if (GetFieldValue(TmpKcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "NameBlock", NameBlockAddr)) {
            dprintf("Cannot find CM_KEY_CONTROL_BLOCK type.\n");
            return 0;
        }

        if (GetFieldValue(NameBlockAddr, "nt!_CM_NAME_CONTROL_BLOCK", "Compressed", Compressed) ||
            GetFieldValue(NameBlockAddr, "nt!_CM_NAME_CONTROL_BLOCK", "NameLength", NameLength)) {
            dprintf("Cannot find type _CM_NAME_CONTROL_BLOCK.\n");
            return 0;
        }

        if (Compressed) {
            Length = NameLength * sizeof(WCHAR);
        } else {
            Length = NameLength;
        }
        TotalLength += Length;

        //
        // Add the sapce for OBJ_NAME_PATH_SEPARATOR;
        //
        TotalLength += sizeof(WCHAR);

        GetFieldValue(TmpKcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "ParentKcb", TmpKcbAddr);

        if (CheckControlC()) {
            return 0;
        }
    }

    BufferEnd = &(NameBuffer[BufferSize/sizeof(WCHAR) - 1]);
    if (TotalLength < BufferSize) {
        NameBuffer[TotalLength/sizeof(WCHAR)] =  UNICODE_NULL;
    } else {
        *BufferEnd = UNICODE_NULL;
    }

    //
    // Now fill the name into the buffer.
    //
    TmpKcbAddr = KcbAddr;
    BeginPosition = TotalLength;
    GetFieldOffset("nt!_CM_NAME_CONTROL_BLOCK", "Name", &NameOffset);

    while (TmpKcbAddr) {
        ULONG NameLength=0, Compressed=0;
        //
        // Read the information.
        //
        if (GetFieldValue(TmpKcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "NameBlock", NameBlockAddr)) {
            dprintf("Cannot find CM_KEY_CONTROL_BLOCK type.\n");
            return 0;
        }

        if (GetFieldValue(NameBlockAddr, "nt!_CM_NAME_CONTROL_BLOCK", "Compressed", Compressed) ||
            GetFieldValue(NameBlockAddr, "nt!_CM_NAME_CONTROL_BLOCK", "NameLength", NameLength)) {
            dprintf("Cannot find type _CM_NAME_CONTROL_BLOCK.\n");
            return 0;
        }

        if (NameLength > sizeof(Name)) {
            NameLength = sizeof(Name);
        }

        ReadMemory(NameBlockAddr +  NameOffset,// FIELD_OFFSET(CM_NAME_CONTROL_BLOCK, Name),
                   Name,
                   NameLength,
                   &BytesRead);

        if (BytesRead < NameLength) {
            dprintf("Could not read Name BUFFER: 5\n");
            return (0);
        }
        
        //
        // Calculate the begin position of each subkey. Then fill in the char.
        //
        if (Compressed) {
            BeginPosition -= (NameLength + 1) * sizeof(WCHAR);
            w1 = &(NameBuffer[BeginPosition/sizeof(WCHAR)]);
            if (w1 < BufferEnd) {
               *w1 = OBJ_NAME_PATH_SEPARATOR;
            }
            w1++;
   
            u2 = (UCHAR *) &(Name[0]);
   
            for (i=0; i<NameLength; i++) {
                if (w1 < BufferEnd) {
                    *w1 = (WCHAR)(*u2);
                } else {
                    break;
                }
                w1++;
                u2++;
            }
        } else {
            BeginPosition -= (NameLength + sizeof(WCHAR));
            w1 = &(NameBuffer[BeginPosition/sizeof(WCHAR)]);
            if (w1 < BufferEnd) {
                *w1 = OBJ_NAME_PATH_SEPARATOR;
            }
            w1++;
   
            w2 = Name;
   
            for (i=0; i<NameLength; i=i+sizeof(WCHAR)) {
                if (w1 < BufferEnd) {
                    *w1 = *w2;
                } else {
                    break;
                }
                w1++;
                w2++;
            }
        }
        GetFieldValue(TmpKcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "ParentKcb", TmpKcbAddr);
    }
    //    dprintf("\n%5d, %ws\n", TotalLength, NameBuffer);
    return ((USHORT) TotalLength);

}

#define CMP_CELL_CACHED_MASK  1

#define CMP_IS_CELL_CACHED(Cell) ((ULONG64) (Cell) & CMP_CELL_CACHED_MASK)
#define CMP_GET_CACHED_ADDRESS(Cell) (((ULONG64) (Cell)) & ~CMP_CELL_CACHED_MASK)

void 
regkcb(
                LPSTR args
                  )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !regkcb KCB_Address

Arguments:

    args - Supplies the address of the KCB.

Return Value:

    .

--*/

{
    WCHAR           KeyName[ 256 ];
    ULONG64         KcbAddr, ParentKcbAddr, KeyHiveAddr, IndexHintAddr,RealKcb;
    DWORD           BytesRead;
    ULONG           ExtFlags, Delete, Flags, KeyCell, KcbMaxNameLen, KcbMaxValueNameLen,KcbMaxValueDataLen,SubKeyCount,ValueCount;
    ULONG           ValueCacheOffset,i,CellIndex;
    ULONG64         ValueList,ValueAddr,CellData;
    USHORT          RefCount, TotalLevels;
    SHORT           DelayedCloseIndex;
    LARGE_INTEGER   KcbLastWriteTime;
    CHAR            Dummy[ 256 ];
    ULONG           KeyBodyListHeadOffset;

    if (sscanf(args,"%255s %lX",Dummy,&KcbAddr)) {
        KcbAddr = GetExpression(args + strlen(Dummy));
    }

    if (GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "ExtFlags", ExtFlags) ||
        GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "Flags", Flags) ||
        GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "Delete", Delete) ||
        GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "RefCount", RefCount) ||
        GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "ParentKcb", ParentKcbAddr) ||
        GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "KeyHive", KeyHiveAddr) ||
        GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "KeyCell", KeyCell) ||
        GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "TotalLevels", TotalLevels) ||
        GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "DelayedCloseIndex", DelayedCloseIndex)
        ) {
        dprintf("Could not read Kcb\n");
        return;
    }
    
    if(GetKcbName(KcbAddr, KeyName, sizeof(KeyName))) {
        dprintf("Key              : %ws\n", KeyName);
    } else {
        dprintf("Could not read key name\n");
        return;
    }

    dprintf("RefCount         : %lx\n", RefCount);
    dprintf("Flags            :");
    if (Delete) {
        dprintf(" Deleted,");
    }
    if (Flags & KEY_COMP_NAME) {
        dprintf(" CompressedName,");
    }
    if (Flags & KEY_PREDEF_HANDLE) {
        dprintf(" PredefinedHandle,");
    }
    if (Flags & KEY_SYM_LINK) {
        dprintf(" SymbolicLink,");
    }
    if (Flags & KEY_NO_DELETE) {
        dprintf(" NoDelete,");
    }
    if (Flags & KEY_HIVE_EXIT) {
        dprintf(" HiveExit,");
    }
    if (Flags & KEY_HIVE_ENTRY) {
        dprintf(" HiveEntry,");
    }
    if (Flags & KEY_VOLATILE) {
        dprintf(" Volatile");
    } else {
        dprintf(" Stable");
    }

    dprintf("\n");

    dprintf("ExtFlags         :");
    if (ExtFlags & CM_KCB_KEY_NON_EXIST) {
        dprintf(" Fake,");
    }
    if (ExtFlags & CM_KCB_SYM_LINK_FOUND) {
        dprintf(" SymbolicLinkFound,");
    }
    if (ExtFlags & CM_KCB_NO_DELAY_CLOSE) {
        dprintf(" NoDelayClose,");
    }
    if (ExtFlags & CM_KCB_INVALID_CACHED_INFO) {
        dprintf(" InvalidCachedInfo,");
    }
    if (ExtFlags & CM_KCB_NO_SUBKEY) {
        dprintf(" NoSubKey,");
    }
    if (ExtFlags & CM_KCB_SUBKEY_ONE) {
        dprintf(" SubKeyOne,");
    }
    if (ExtFlags & CM_KCB_SUBKEY_HINT) {
        dprintf(" SubKeyHint");
    }
    dprintf("\n");

    dprintf("Parent           : 0x%p\n", ParentKcbAddr);
    dprintf("KeyHive          : 0x%p\n", KeyHiveAddr);
    dprintf("KeyCell          : 0x%lx [cell index]\n", KeyCell);
    dprintf("TotalLevels      : %u\n", TotalLevels);
    dprintf("DelayedCloseIndex: %d\n", DelayedCloseIndex);

    if(!GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "KcbMaxNameLen", KcbMaxNameLen)) {
        dprintf("MaxNameLen       : 0x%lx\n", KcbMaxNameLen);
    }
    if(!GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "KcbMaxValueNameLen", KcbMaxValueNameLen)) {
        dprintf("MaxValueNameLen  : 0x%lx\n", KcbMaxValueNameLen);
    }
    if(!GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "KcbMaxValueDataLen", KcbMaxValueDataLen)) {
        dprintf("MaxValueDataLen  : 0x%lx\n", KcbMaxValueDataLen);
    }
    if(!GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "KcbLastWriteTime", KcbLastWriteTime)) {
        dprintf("LastWriteTime    : 0x%8lx:0x%8lx\n", KcbLastWriteTime.HighPart,KcbLastWriteTime.LowPart);
    }

    if( !GetFieldOffset("nt!_CM_KEY_CONTROL_BLOCK", "KeyBodyListHead", &KeyBodyListHeadOffset) ) {
        ParentKcbAddr = KcbAddr + KeyBodyListHeadOffset;

        dprintf("KeyBodyListHead  : ");
        if (!GetFieldValue(ParentKcbAddr, "nt!_LIST_ENTRY", "Flink", KeyHiveAddr)) {
            dprintf("0x%p ", KeyHiveAddr);
        }
        if (!GetFieldValue(ParentKcbAddr, "nt!_LIST_ENTRY", "Blink", KeyHiveAddr)) {
            dprintf("0x%p", KeyHiveAddr);
        }
        dprintf("\n");
    }    
    if(!(Flags&KEY_HIVE_ENTRY)) {
        dprintf("SubKeyCount      : ");
        if( !(ExtFlags & CM_KCB_INVALID_CACHED_INFO) ) {
            if (ExtFlags & CM_KCB_NO_SUBKEY ) {
                dprintf("0");
            } else if (ExtFlags & CM_KCB_SUBKEY_ONE ) {
                dprintf("1");
            } else if (ExtFlags & CM_KCB_SUBKEY_HINT ) {
                if( !GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "IndexHint", IndexHintAddr) ) {
                    if( !GetFieldValue(IndexHintAddr, "CM_INDEX_HINT_BLOCK", "Count", SubKeyCount) ) {
                        dprintf("%lu",SubKeyCount);
                    }
                }
            } else {
                if( !GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", "SubKeyCount", SubKeyCount) ) {
                    dprintf("%lu",SubKeyCount);
                }
            }
        } else {
            dprintf("hint not valid");
        }
        dprintf("\n");
    }

    GetFieldOffset("nt!_CM_KEY_CONTROL_BLOCK", "ValueCache", &ValueCacheOffset);
    if( ExtFlags & CM_KCB_SYM_LINK_FOUND ) {
        if(!GetFieldValue(KcbAddr + ValueCacheOffset, "nt!_CACHED_CHILD_LIST", "RealKcb", RealKcb)) {
            dprintf("RealKcb          : 0x%p\n", RealKcb);
        }
    } else {
        if(!GetFieldValue(KcbAddr + ValueCacheOffset, "nt!_CACHED_CHILD_LIST", "Count", ValueCount)) {
            dprintf("ValueCache.Count : %lu\n", ValueCount);
            if(!GetFieldValue(KcbAddr + ValueCacheOffset, "nt!_CACHED_CHILD_LIST", "ValueList", ValueList)) {
                if (CMP_IS_CELL_CACHED(ValueList)) {
                    ValueList = CMP_GET_CACHED_ADDRESS(ValueList);
                    if(!GetFieldValue(ValueList, "nt!_CM_CACHED_VALUE_INDEX", "CellIndex", CellIndex) ) {
                        
                        dprintf("ValueList        : 0x%lx\n", CellIndex);

                        GetFieldOffset("nt!_CM_CACHED_VALUE_INDEX", "Data.CellData", &ValueCacheOffset);
                        ValueList += ValueCacheOffset;
                        for (i = 0; i < ValueCount; i++) {
                        
                            dprintf("    ValueList[%2lu] = ",i);

                            ReadMemory(ValueList + i*PtrSize, &ValueAddr, PtrSize, &BytesRead);
                            if (BytesRead < PtrSize) {
                                dprintf("Couldn't read memory\n");
                            } else {
                                dprintf("  0x%p\n",ValueAddr);
                            }

                            if (CheckControlC()) {
                                break;
                            }
                        }
                    }

                } else {
                    dprintf("ValueCache.List  : 0x%p\n", ValueList);
                }
            }
        }
    }

}

//
// Miscelaneous Hash routines
//
ULONG CmpHashTableSize = 0;
#define RNDM_CONSTANT   314159269    /* default value for "scrambling constant" */
#define RNDM_PRIME     1000000007    /* prime number, also used for scrambling  */

#define HASH_KEY(_convkey_) ((RNDM_CONSTANT * (_convkey_)) % RNDM_PRIME)

#define GET_HASH_INDEX(Key) HASH_KEY(Key) % CmpHashTableSize
#define GET_HASH_ENTRY(Table, Key) Table[GET_HASH_INDEX(Key)]


void 
regopenkeys(
                LPSTR args,
                LPSTR subkey
                  )

/*++

Routine Description:

    Dumps the registry hash table

    Called as:

        !openkeys <HiveAddr|0>

Arguments:

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.

Return Value:

    None.

--*/

{
    DWORD64 TableSizeAddr;
    DWORD64 HashTableAddr;
    ULONG64 HashTable;
    DWORD i;
    ULONG64 KcbAddr;
    WCHAR KeyName[ 256 ];
    ULONG64 HashEntryAddr;
    DWORD BytesRead;
    ULONG KeyHashOffset;
    BOOLEAN First;
    ULONG64 TargetHive = 0;
    CHAR        Dummy[ 256 ];
    ULONG ConvKey = 0;
    ULONG j,Count;
    ULONG SearchedIndex;
    WCHAR FullKeyName[ 512 ];

    TableSizeAddr = GetExpression("nt!CmpHashTableSize");
    if (TableSizeAddr == 0) {
        dprintf("Couldn't find address of CmpHashTableSize\n");
        return;
    }

    HashTableAddr = GetExpression("nt!CmpCacheTable");
    if (HashTableAddr == 0) {
        dprintf("Couldn't find address of CmpCacheTable\n");
        return;
    }
    ReadMemory(TableSizeAddr, &CmpHashTableSize, sizeof(CmpHashTableSize), &BytesRead);
    if (BytesRead < sizeof(CmpHashTableSize)) {
        dprintf("Couldn't get CmpHashTableSize from %08p\n",TableSizeAddr);
        return;
    }
    
    if (!ReadPointer(HashTableAddr, &HashTable) || !HashTable) {
        dprintf("Couldn't get CmpCacheTable from %08p\n",HashTableAddr);
        return;
    }

    if( subkey == NULL ) {

        if (sscanf(args,"%255s %lX",Dummy,&TargetHive)) {
            TargetHive = GetExpression(args + strlen(Dummy));
        }

        i=0;
        SearchedIndex = CmpHashTableSize - 1;
    } else {
        for( Count=0;subkey[Count];Count++) {
            FullKeyName[Count] = (WCHAR)subkey[Count];
            if( FullKeyName[Count] != OBJ_NAME_PATH_SEPARATOR ) {
                ConvKey = 37 * ConvKey + (ULONG) RtlUpcaseUnicodeChar(FullKeyName[Count]);
            }
        }
        FullKeyName[Count] = UNICODE_NULL;
        SearchedIndex = GET_HASH_INDEX(ConvKey);
        i=SearchedIndex;
     }

    
    GetFieldOffset("nt!_CM_KEY_CONTROL_BLOCK", "KeyHash", &KeyHashOffset);
    
    for (; i<=SearchedIndex; i++) {
        if (CheckControlC()) {
            return;
        }
        
        if (!ReadPointer(HashTable + i*PtrSize,&HashEntryAddr)) {
            dprintf("Couldn't get HashEntryAddr from %08p\n", HashTable + i*PtrSize);
            continue;
        }
        if (HashEntryAddr != 0) {
            First = TRUE;
            while (HashEntryAddr != 0) {
#define KcbFld(F) GetFieldValue(KcbAddr, "nt!_CM_KEY_CONTROL_BLOCK", #F, F)
                ULONG64 KeyHive, NextHash;
                ULONG   KeyCell, Flags, ExtFlags;
                
                KcbAddr = HashEntryAddr - KeyHashOffset;
                if (KcbFld(ConvKey)) {
                    dprintf("Couldn't get HashEntry from %08lx\n", HashEntryAddr);
                    break;
                } 
                
                KcbFld(KeyHive); KcbFld(KeyCell);
                KcbFld(Flags);   KcbFld(ExtFlags); KcbFld(NextHash);
        
                if( subkey == NULL ) {
                    if( (TargetHive == 0) || ((ULONG64)TargetHive == (ULONG64)KeyHive) ) {
                        if( !First ) {
                            dprintf("\t");
                        } else {
                            dprintf("Index %x: ",i);
                        }
                        dprintf("\t %08lx kcb=%p cell=%08lx f=%04lx%04lx ",
                                ConvKey,
                                KcbAddr,
                                KeyCell,
                                Flags,
                                ExtFlags);
                        First = FALSE;
                        if (GetKcbName(KcbAddr, KeyName, sizeof(KeyName))) {
                            dprintf("%ws\n", KeyName);
                        }
                    }
                } else {
                    //
                    // findkcb case
                    //
                        if (GetKcbName(KcbAddr, KeyName, sizeof(KeyName))) {
                            for(j=0;KeyName[j] != UNICODE_NULL;j++);
                            if( (j == Count) && (_wcsnicmp(FullKeyName,KeyName,Count) == 0) ) {
                                dprintf("\nFound KCB = %p :: %ws\n\n",KcbAddr,KeyName);
                                return;
                            }
                        }

                }
                HashEntryAddr = NextHash;
                if (CheckControlC()) {
                    return;
                }
#undef KcbFld
            }
        }
    }
    if( subkey != NULL ) {
        dprintf("\nSorry <%ws> is not cached \n\n",FullKeyName);
    }

}

void 
regcellindex(
                LPSTR args
                  )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !cellindex HiveAddr HCELL_INDEX 

Arguments:

    args - Supplies the address of the HCELL_INDEX.

Return Value:

    .

--*/

{
    ULONG64     HiveAddr;
    ULONG       IdxAddr;
    ULONG64   pcell;
    BOOLEAN     Flat;
    CHAR        Dummy[ 256 ];

    if (sscanf(args,"%255s %lX %lx",Dummy,&HiveAddr,&IdxAddr)) {
       if (GetExpressionEx(args + strlen(Dummy), &HiveAddr, &args)) {
           IdxAddr = (ULONG) GetExpression(args);
       }
    }

    if(!GetFieldValue(HiveAddr, "nt!_HHIVE", "Flat", Flat) ){
        if(Flat) {
            pcell = MyHvpGetCellFlat(HiveAddr,IdxAddr);
        } else {
            pcell = MyHvpGetCellPaged(HiveAddr,IdxAddr);
        }

        dprintf("pcell:  %p\n",pcell);
    } else {
        dprintf("could not read hive\n");
    }
}

void 
reghashindex (
            LPSTR args
           )
/*++

Routine Description:

    display the index for the convkey

    Called as:

        !hashindex conv_key

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG       ConvKey;
    CHAR        Dummy[ 256 ];
    DWORD64     TableSizeAddr;
    DWORD64     HashTableAddr;
    ULONG64     HashTable;
    DWORD       BytesRead;
    ULONG       Index;

    if (!sscanf(args,"%255s %lx",Dummy,&ConvKey)) {
        ConvKey = 0;
    }

    TableSizeAddr = GetExpression("nt!CmpHashTableSize");
    if (TableSizeAddr == 0) {
        dprintf("Couldn't find address of CmpHashTableSize\n");
        return;
    }

    ReadMemory(TableSizeAddr, &CmpHashTableSize, sizeof(CmpHashTableSize), &BytesRead);
    if (BytesRead < sizeof(CmpHashTableSize)) {
        dprintf("Couldn't get CmpHashTableSize from %08p\n",TableSizeAddr);
        return;
    }
    
    HashTableAddr = GetExpression("nt!CmpCacheTable");
    if (HashTableAddr == 0) {
        dprintf("Couldn't find address of CmpCacheTable\n");
        return ;
    }
    if (!ReadPointer(HashTableAddr, &HashTable)) {
        dprintf("Couldn't get CmpCacheTable from %08p\n",HashTableAddr);
        return;
    } else {
        dprintf("CmpCacheTable = %p\n\n",HashTable);
    }

    Index = GET_HASH_INDEX(ConvKey);
    HashTable += Index*PtrSize;
    dprintf("Hash Index[%8lx] : %lx\n",ConvKey,Index);
    dprintf("Hash Entry[%8lx] : %p\n",ConvKey,HashTable);
}

void 
regknode(
            LPSTR args
           )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !knode KNode_Address

Arguments:

    args - Supplies the address of the CM_KEY_NODE.

Return Value:

    .

--*/

{
    char            KeyName[ 256 ];
    ULONG64         KnodeAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    USHORT          Signature,Flags,NameLength;
    LARGE_INTEGER   LastWriteTime;
    ULONG           Parent,MaxNameLen,MaxClassLen,MaxValueNameLen,MaxValueDataLen,Security,Class;
    ULONG           KeyNameOffset,Count,ValueList;
    ULONG           SubKeys[4];  

    if (sscanf(args,"%255s %lX",Dummy,&KnodeAddr)) {

        KnodeAddr = GetExpression(args + strlen(Dummy));
    }

    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "Signature", Signature) ) {
        if( Signature == CM_KEY_NODE_SIGNATURE) {
            dprintf("Signature: CM_KEY_NODE_SIGNATURE (kn)\n");
        } else if(Signature == CM_LINK_NODE_SIGNATURE) {
            dprintf("Signature: CM_LINK_NODE_SIGNATURE (kl)\n");
        } else {
            dprintf("Invalid Signature %u\n",Signature);
        }
    }

    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "NameLength", NameLength) ) {
        GetFieldOffset("CM_KEY_NODE", "Name", &KeyNameOffset);
        if (NameLength >= sizeof(KeyName))
        {
            NameLength = sizeof(KeyName)-1;
        }
        if( !ReadMemory(KnodeAddr + KeyNameOffset,
                   KeyName,
                   NameLength,
                   &BytesRead) ) {
            dprintf("Could not read KeyName\n");
        } else {
            KeyName[NameLength] = '\0';
            dprintf("Name                 : %s\n", KeyName);
        }
    }
    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "Parent", Parent) ) {
        dprintf("ParentCell           : 0x%lx\n", Parent);
    }
    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "Security", Security) ) {
        dprintf("Security             : 0x%lx [cell index]\n", Security);
    }
    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "Class", Class) ) {
        dprintf("Class                : 0x%lx [cell index]\n", Class);
    }
    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "Flags", Flags) ) {
        dprintf("Flags                : 0x%lx\n", Flags);
    }
    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "MaxNameLen", MaxNameLen) ) {
        dprintf("MaxNameLen           : 0x%lx\n", MaxNameLen);
    }
    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "MaxClassLen", MaxClassLen) ) {
        dprintf("MaxClassLen          : 0x%lx\n", MaxClassLen);
    }
    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "MaxValueNameLen", MaxValueNameLen) ) {
        dprintf("MaxValueNameLen      : 0x%lx\n", MaxValueNameLen);
    }
    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "MaxValueDataLen", MaxValueDataLen) ) {
        dprintf("MaxValueDataLen      : 0x%lx\n", MaxValueDataLen);
    }
    if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "LastWriteTime", LastWriteTime) ) {
        dprintf("LastWriteTime        : 0x%8lx:0x%8lx\n", LastWriteTime.HighPart,LastWriteTime.LowPart);
    }

    if(!(Flags&KEY_HIVE_ENTRY)) {
        GetFieldOffset("nt!_CM_KEY_NODE", "SubKeyCounts", &KeyNameOffset);
        if( !ReadMemory(KnodeAddr + KeyNameOffset,
                   SubKeys,
                   sizeof(SubKeys),
                   &BytesRead) ) {
            dprintf("Could not read SubKey Info\n");
        } else {
            dprintf("SubKeyCount[Stable  ]: 0x%lx\n", SubKeys[0]);
            dprintf("SubKeyLists[Stable  ]: 0x%lx\n", SubKeys[2]);
            dprintf("SubKeyCount[Volatile]: 0x%lx\n", SubKeys[1]);
            dprintf("SubKeyLists[Volatile]: 0x%lx\n", SubKeys[3]);
        }
        if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "ValueList.Count", Count)) {
            dprintf("ValueList.Count      : 0x%lx\n", Count);
            if (!GetFieldValue(KnodeAddr, "nt!_CM_KEY_NODE", "ValueList.List", ValueList)) {
                dprintf("ValueList.List       : 0x%lx\n", ValueList);
            }
        }

    }
}

void 
regkbody(
            LPSTR args
           )
/*++

Routine Description:

    displays a CM_KEY_BODY

    Called as:

        !kbody KBody_Address

Arguments:

    args - Supplies the address of the CM_KEY_BODY.
    
Return Value:

    .

--*/

{
    ULONG64         KbodyAddr,KeyControlBlock,NotifyBlock,Process,KeyBodyList,CallerAddress;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           Type,Offset,Callers,i;

    if (sscanf(args,"%255s %lX",Dummy,&KbodyAddr)) {

        KbodyAddr = GetExpression(args+ strlen(Dummy));
    }


    if (!GetFieldValue(KbodyAddr, "nt!_CM_KEY_BODY", "Type", Type) ) {
        if( Type == KEY_BODY_TYPE) {
            dprintf("Type        : KEY_BODY_TYPE\n");
        } else {
            dprintf("Invalid Type %lx\n",Type);
            return;
        }
    }
    if (!GetFieldValue(KbodyAddr, "nt!_CM_KEY_BODY", "KeyControlBlock", KeyControlBlock) ) {
        dprintf("KCB         : %p\n", KeyControlBlock);
    }
    if (!GetFieldValue(KbodyAddr, "nt!_CM_KEY_BODY", "NotifyBlock", NotifyBlock) ) {
        dprintf("NotifyBlock : %p\n", NotifyBlock);
    }
    if (!GetFieldValue(KbodyAddr, "nt!_CM_KEY_BODY", "Process", Process) ) {
        dprintf("Process     : %p\n", Process);
    }
    if (!GetFieldValue(KbodyAddr, "nt!_CM_KEY_BODY", "KeyBodyList", KeyBodyList) ) {
        GetFieldOffset("CM_KEY_BODY", "KeyBodyList", &Offset);

        dprintf("KeyBodyList : ");
        if (!GetFieldValue(KbodyAddr + Offset, "nt!_LIST_ENTRY", "Flink", KeyBodyList)) {
            dprintf("0x%p ", KeyBodyList);
        }
        if (!GetFieldValue(KbodyAddr + Offset, "nt!_LIST_ENTRY", "Blink", KeyBodyList)) {
            dprintf("0x%p", KeyBodyList);
        }
        dprintf("\n");
    }
    if (!GetFieldValue(KbodyAddr, "nt!_CM_KEY_BODY", "Callers", Callers) ) {
        GetFieldOffset("nt!_CM_KEY_BODY", "CallerAddress", &Offset);
        if( Callers ) {
            dprintf("Callers Stack: ");
        }
        for(i = 0;i< Callers;i++) {
            dprintf("[%lu] ",i);
            if( !ReadMemory(KbodyAddr + Offset + i*PtrSize,
                       &CallerAddress,
                       sizeof(CallerAddress),
                       &BytesRead) ) {
                dprintf("Could not memory\n");
            } else {
                dprintf("  %p\n", CallerAddress);
            }            
        }
    }

}


void 
regkvalue(
            LPSTR args
           )
/*++

Routine Description:

    Dumps the name when given a KCB address

    Called as:

        !kvalue KValue_Address

Arguments:

    args - Supplies the address of the CM_KEY_NODE.

Return Value:

    .

--*/

{
    char            ValName[ 256 ];
    ULONG64         KvalAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           Offset,DataLength,Data,Type;
    USHORT          Signature,Flags,NameLength;

    if (sscanf(args,"%255s %lX",Dummy,&KvalAddr)) {

        KvalAddr = GetExpression(args+ strlen(Dummy));
    }

    if (!GetFieldValue(KvalAddr, "nt!_CM_KEY_VALUE", "Signature", Signature) ) {
        if( Signature == CM_KEY_VALUE_SIGNATURE) {
            dprintf("Signature: CM_KEY_VALUE_SIGNATURE (kv)\n");
        } else {
            dprintf("Invalid Signature %lx\n",Signature);
        }
    }

    if (!GetFieldValue(KvalAddr, "nt!_CM_KEY_VALUE", "Flags", Flags) ) {
        if( (Flags & VALUE_COMP_NAME) &&
            !GetFieldValue(KvalAddr, "nt!_CM_KEY_VALUE", "NameLength", NameLength)
            ) {
            if (NameLength >= sizeof(ValName))
            {
                NameLength = sizeof(ValName) -1;
            }
            GetFieldOffset("nt!_CM_KEY_VALUE", "Name", &Offset);
            ReadMemory(KvalAddr + Offset,
                       ValName,
                       NameLength,
                       &BytesRead);
            ValName[NameLength] = '\0';
            dprintf("Name      : %s {compressed}\n", ValName);
        }
    }

    if (!GetFieldValue(KvalAddr, "nt!_CM_KEY_VALUE", "DataLength", DataLength) ) {
        dprintf("DataLength: %lx\n", DataLength);
    }
    if (!GetFieldValue(KvalAddr, "nt!_CM_KEY_VALUE", "Data", Data) ) {
        dprintf("Data      : %lx  [cell index]\n", Data);
    }
    if (!GetFieldValue(KvalAddr, "nt!_CM_KEY_VALUE", "Type", Type) ) {
        dprintf("Type      : %lx\n", Type);
    }

}

void 
regbaseblock(
            LPSTR args
           )
/*++

Routine Description:

    displays the base block structure

    Called as:

        !baseblock HiveAddress

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    WCHAR           FileName[HBASE_NAME_ALLOC/sizeof(WCHAR) + 1];
    ULONG64         BaseBlock,HiveAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           Work;
    LARGE_INTEGER   TimeStamp;

    if (sscanf(args,"%255s %lX",Dummy,&HiveAddr)) {

        HiveAddr = GetExpression(args+ strlen(Dummy));
    }

    if (GetFieldValue(HiveAddr, "nt!_CMHIVE", "Hive.BaseBlock", BaseBlock)) {
        dprintf("\tCan't CMHIVE Read from %p\n",HiveAddr);
        return;
    }

    if (GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "FileName", FileName )) {
        wcscpy(FileName, L"UNKNOWN");
    } else {
        if (FileName[0]==L'\0') {
            wcscpy(FileName, L"NONAME");
        } else {
            FileName[HBASE_NAME_ALLOC/sizeof(WCHAR)]=L'\0';
        }
    }
    dprintf("FileName :  %ws\n",FileName);

    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "Signature", Work )) {
        if( Work == HBASE_BLOCK_SIGNATURE ) {
            dprintf("Signature:  HBASE_BLOCK_SIGNATURE\n");
        } else {
            dprintf("Signature:  %lx\n",Work);
        }
    }

    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "Sequence1", Work )) {
        dprintf("Sequence1:  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "Sequence2", Work )) {
        dprintf("Sequence2:  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "TimeStamp", TimeStamp )) {
        dprintf("TimeStamp:  %lx %lx\n",TimeStamp.HighPart,TimeStamp.LowPart);
    }
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "Major", Work )) {
        dprintf("Major    :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "Minor", Work )) {
        dprintf("Minor    :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "Type", Work )) {
        switch(Work) {
        case HFILE_TYPE_PRIMARY:
            dprintf("Type     :  HFILE_TYPE_PRIMARY\n");
            break;
        case HFILE_TYPE_LOG:
            dprintf("Type     :  HFILE_TYPE_LOG\n");
            break;
        case HFILE_TYPE_EXTERNAL:
            dprintf("Type     :  HFILE_TYPE_EXTERNAL\n");
            break;
        default:
            dprintf("Type     :  %lx\n",Work);
            break;

        }
    }
    
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "Format", Work )) {
        if( Work == HBASE_FORMAT_MEMORY ) {
            dprintf("Format   :  HBASE_FORMAT_MEMORY\n");
        } else {
            dprintf("Format   :  %lx\n",Work);
        }
    }
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "RootCell", Work )) {
        dprintf("RootCell :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "Length", Work )) {
        dprintf("Length   :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "Cluster", Work )) {
        dprintf("Cluster  :  %lx\n",Work);
    }
    if(!GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "CheckSum", Work )) {
        dprintf("CheckSum :  %lx\n",Work);
    }
}

void 
reghivelist(
           )
/*++

Routine Description:

    dumps all the hives in the system

    Called as:

        !hivelist 

Arguments:

Return Value:

    .

--*/

{
    ULONG64 pCmpHiveListHead;
    ULONG64 pNextHiveList;
    ULONG BytesRead, WorkVar;
    ULONG64 CmHive;
    USHORT  Count;
    ULONG HiveListOffset;
    FIELD_INFO offField = {"HiveList", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    ULONG           Stable_Length=0, Volatile_Length=0;
    ULONG64         Stable_Map=0, Volatile_Map=0;
    WCHAR           FileName[HBASE_NAME_ALLOC/sizeof(WCHAR) + 1];
    ULONG64         BaseBlock;


    //
    // First go and get the hivelisthead
    //
    pCmpHiveListHead = GetExpression("nt!CmpHiveListHead");
    if (pCmpHiveListHead==0) {
        dprintf("CmpHiveListHead couldn't be read\n");
        return;
    }

    

    if (!ReadPointer(pCmpHiveListHead, &pNextHiveList)) {
        dprintf("Couldn't read first Flink (%p) of CmpHiveList\n",
                pCmpHiveListHead);
        return;
    }

    TotalPages = TotalPresentPages = 0;

    // Get The offset
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return;
    }
    HiveListOffset = (ULONG) offField.address;
    
    dprintf("-------------------------------------------------------------------------------------------------------------\n");
    dprintf("| HiveAddr |Stable Length|Stable Map|Volatile Length|Volatile Map|MappedViews|PinnedViews|U(Cnt)| BaseBlock | FileName \n");
    dprintf("-------------------------------------------------------------------------------------------------------------\n");
    while (pNextHiveList != pCmpHiveListHead) {

        if (CheckControlC()) {
            break;
        }

        CmHive = pNextHiveList - HiveListOffset;
        

        if(!GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.Signature", WorkVar)) {
            if( WorkVar != HHIVE_SIGNATURE ) {
                dprintf("Invalid Hive signature:  %lx\n",WorkVar);
                break;
            }
        }
        dprintf("| %p ",CmHive);
        

        if(!GetHiveMaps(CmHive,&Stable_Map,&Stable_Length,&Volatile_Map,&Volatile_Length) ) {
            break;
        }

        dprintf("|   %8lx  ",Stable_Length);
        dprintf("| %p ",Stable_Map);
        dprintf("|   %8lx    ",Volatile_Length);
        dprintf("|  %p  ",Volatile_Map);
        if (!GetFieldValue(CmHive, "nt!_CMHIVE", "MappedViews", Count)) {
            dprintf("| %8u  ",Count);
        }
        if (!GetFieldValue(CmHive, "nt!_CMHIVE", "PinnedViews", Count)) {
            dprintf("| %8u  ",Count);
        }
        if (!GetFieldValue(CmHive, "nt!_CMHIVE", "UseCount", WorkVar)) {
            dprintf("| %5u",WorkVar);
        }
        if (GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.BaseBlock", BaseBlock)) {
            dprintf("\tCan't CMHIVE Read from %p\n",CmHive);
            continue;
        }
        dprintf("| %p  |",BaseBlock);

        if (GetFieldValue( BaseBlock, "nt!_HBASE_BLOCK", "FileName", FileName )) {
            wcscpy(FileName, L"<UNKNOWN>");
        } else {
            if (FileName[0]==L'\0') {
                wcscpy(FileName, L"<NONAME>");
            } else {
                FileName[HBASE_NAME_ALLOC/sizeof(WCHAR)]=L'\0';
            }
        }
        dprintf(" %ws\n",FileName);

        if (GetFieldValue(pNextHiveList, "nt!_LIST_ENTRY", "Flink", pNextHiveList)) {
            dprintf("Couldn't read Flink (%p) of %p\n",
                      pCmpHiveListHead,pNextHiveList);
            break;
        }

    }
    dprintf("-------------------------------------------------------------------------------------------------------------\n");
 
    dprintf("\n");

}

void 
regviewlist(
            LPSTR args
           )
/*++

Routine Description:

    dumps all the views mapped/pinned for the specified hive

    Called as:

        !viewlist <HiveAddr>

Arguments:

    args - hive.
    
Return Value:

    .

--*/

{
    ULONG64         CmHive,PinViewListHead,LRUViewListHead,Flink,Blink,ViewAddr,Address;
    ULONG64         List1,List2;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,OffsetPinned,OffsetMapped,OffsetPinnedHead,OffsetMappedHead;
    USHORT          MappedViews,PinnedViews;

    
    if (sscanf(args,"%255s %lX",Dummy,&CmHive)) {

        CmHive = GetExpression(args+ strlen(Dummy));
    }

    if(!GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }

    if (GetFieldValue(CmHive, "nt!_CMHIVE", "MappedViews", MappedViews) ||
        GetFieldValue(CmHive, "nt!_CMHIVE", "PinnedViews", PinnedViews) ||
        GetFieldOffset("nt!_CMHIVE", "PinViewListHead", &OffsetPinnedHead) ||
        GetFieldOffset("nt!_CMHIVE", "LRUViewListHead", &OffsetMappedHead) ||
        GetFieldOffset("nt!_CM_VIEW_OF_FILE", "PinViewList", &OffsetPinned) ||
        GetFieldOffset("nt!_CM_VIEW_OF_FILE", "LRUViewList", &OffsetMapped)
        ) {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }

    PinViewListHead = CmHive + OffsetPinnedHead;
    LRUViewListHead = CmHive + OffsetMappedHead;
    if ( !GetFieldValue(PinViewListHead, "nt!_LIST_ENTRY", "Flink", Flink) &&
         !GetFieldValue(PinViewListHead, "nt!_LIST_ENTRY", "Blink", Blink)
         ) {
        dprintf("%4u  Pinned Views ; PinViewListHead = %p %p\n",PinnedViews,Flink,Blink);
        if( PinnedViews ) {
            dprintf("--------------------------------------------------------------------------------------------------------------\n");
            dprintf("| ViewAddr |FileOffset|   Size   |ViewAddress|   Bcb    |    LRUViewList     |    PinViewList     | UseCount |\n");
            dprintf("--------------------------------------------------------------------------------------------------------------\n");

            
            for(;PinnedViews;PinnedViews--) {
                if (CheckControlC()) {
                    break;
                }

                ViewAddr = Flink;
                ViewAddr -= OffsetPinned;
                
                dprintf("| %p ",ViewAddr);

                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "FileOffset", WorkVar) ) {
                    dprintf("| %8lx ",WorkVar);
                }
                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "Size", WorkVar) ) {
                    dprintf("| %8lx ",WorkVar);
                }
                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "ViewAddress", Address) ) {
                    dprintf("| %p  ",Address);
                }
                if( Address == 0 ) {
                    dprintf("could not read memory - paged out\n");
                    break;
                }
                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "Bcb", Address) ) {
                    dprintf("| %p ",Address);
                }


                if( !GetFieldValue(ViewAddr + OffsetMapped, "nt!_LIST_ENTRY", "Flink", List1) ) {
                    dprintf("| %p",List1);
                }
                if( !GetFieldValue(ViewAddr + OffsetMapped, "nt!_LIST_ENTRY", "Blink", List2) ) {
                    dprintf("  %p ",List2);
                }

                if( !GetFieldValue(ViewAddr + OffsetPinned, "nt!_LIST_ENTRY", "Flink", Flink) ) {
                    dprintf("| %p",Flink);
                }
                if( !GetFieldValue(ViewAddr + OffsetPinned, "nt!_LIST_ENTRY", "Blink", Blink) ) {
                    dprintf("  %p |",Blink);
                }

                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "UseCount", WorkVar) ) {
                    dprintf(" %8lx |\n",WorkVar);
                }
                
            }
            dprintf("--------------------------------------------------------------------------------------------------------------\n");
        }
    }

    dprintf("\n");
    if ( !GetFieldValue(LRUViewListHead, "nt!_LIST_ENTRY", "Flink", Flink) &&
         !GetFieldValue(LRUViewListHead, "nt!_LIST_ENTRY", "Blink", Blink)
         ) {
        dprintf("%4u  Mapped Views ; LRUViewListHead = %p %p\n",MappedViews,Flink,Blink);
        if( MappedViews ) {
            dprintf("--------------------------------------------------------------------------------------------------------------\n");
            dprintf("| ViewAddr |FileOffset|   Size   |ViewAddress|   Bcb    |    LRUViewList     |    PinViewList     | UseCount |\n");
            dprintf("--------------------------------------------------------------------------------------------------------------\n");

            
            for(;MappedViews;MappedViews--) {
                if (CheckControlC()) {
                    break;
                }
                ViewAddr = Flink;
                ViewAddr -= OffsetMapped;
                
                dprintf("| %p ",ViewAddr);

                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "FileOffset", WorkVar) ) {
                    dprintf("| %8lx ",WorkVar);
                }
                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "Size", WorkVar) ) {
                    dprintf("| %8lx ",WorkVar);
                }
                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "ViewAddress", Address) ) {
                    dprintf("| %p  ",Address);
                }
                if( Address == 0 ) {
                    dprintf("could not read memory - paged out\n");
                    break;
                }
                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "Bcb", Address) ) {
                    dprintf("| %p ",Address);
                }


                if( !GetFieldValue(ViewAddr + OffsetMapped, "nt!_LIST_ENTRY", "Flink", Flink) ) {
                    dprintf("| %p",Flink);
                }
                if( !GetFieldValue(ViewAddr + OffsetMapped, "nt!_LIST_ENTRY", "Blink", Blink) ) {
                    dprintf("  %p ",Blink);
                }

                if( !GetFieldValue(ViewAddr + OffsetPinned, "nt!_LIST_ENTRY", "Flink", List1) ) {
                    dprintf("| %p",List1);
                }
                if( !GetFieldValue(ViewAddr + OffsetPinned, "nt!_LIST_ENTRY", "Blink", List2) ) {
                    dprintf("  %p |",List2);
                }

                if( !GetFieldValue(ViewAddr, "nt!_CM_VIEW_OF_FILE", "UseCount", WorkVar) ) {
                    dprintf(" %8lx |\n",WorkVar);
                }
                
            }
            dprintf("--------------------------------------------------------------------------------------------------------------\n");
        }
    }
    dprintf("\n");

}

void 
regfreebins(
            LPSTR args
           )
/*++

Routine Description:

    dumps all the free bins for the specified hive

    Called as:

        !freebins <HiveAddr>

Arguments:

    args - hive.
    
Return Value:

    .

--*/

{
    ULONG64         CmHive,AnchorAddr,BinAddr,Flink,Blink;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,OffsetFreeBins,Offset;
    ULONG           DUAL_Size,StorageOffset;
    FIELD_INFO offField = {"Hive.Storage", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    USHORT      Nr = 0;

    if (sscanf(args,"%255s %lX",Dummy,&CmHive)) {

        CmHive = GetExpression(args+ strlen(Dummy));
    }

    if(!GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }
    
    // Get the offset of Hive.Storage in _CMHIVE
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        dprintf("Cannot find _CMHIVE type.\n");
        return;
    }
    
    StorageOffset = (ULONG) offField.address;
    DUAL_Size = GetTypeSize("_DUAL");

    GetFieldOffset("nt!_FREE_HBIN", "ListEntry", &Offset);
    GetFieldOffset("_DUAL", "FreeBins", &OffsetFreeBins);

    dprintf("Stable Storage ... \n");

    dprintf("-------------------------------------------------------------------\n");
    dprintf("| Address  |FileOffset|   Size   |   Flags  |   Flink  |   Blink  |\n");
    dprintf("-------------------------------------------------------------------\n");
    Nr = 0;

    AnchorAddr = CmHive + StorageOffset + OffsetFreeBins;

    if ( !GetFieldValue(AnchorAddr, "nt!_LIST_ENTRY", "Flink", Flink) &&
         !GetFieldValue(AnchorAddr, "nt!_LIST_ENTRY", "Blink", Blink)
         ) {
        while((ULONG64)Flink != (ULONG64)AnchorAddr ) {
            if (CheckControlC()) {
                break;
            }
            BinAddr = Flink - Offset;
            dprintf("| %p ",BinAddr);

            if(!GetFieldValue(BinAddr, "nt!_FREE_HBIN", "FileOffset", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }
            if(!GetFieldValue(BinAddr, "nt!_FREE_HBIN", "Size", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }
            if(!GetFieldValue(BinAddr, "nt!_FREE_HBIN", "Flags", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }

            if( !GetFieldValue(BinAddr + Offset, "nt!_LIST_ENTRY", "Flink", Flink) ) {
                dprintf("| %p ",Flink);
            }
            if( !GetFieldValue(BinAddr + Offset, "nt!_LIST_ENTRY", "Blink", Blink) ) {
                dprintf("| %p |\n",Blink);
            }
            
            Nr++;
        }
        
    }

    dprintf("-------------------------------------------------------------------\n");

    dprintf("%4u  FreeBins\n",Nr);

    dprintf("\n");

    dprintf("Volatile Storage ... \n");

    dprintf("-------------------------------------------------------------------\n");
    dprintf("| Address  |FileOffset|   Size   |   Flags  |   Flink  |   Blink  |\n");
    dprintf("-------------------------------------------------------------------\n");

    AnchorAddr = CmHive + StorageOffset + DUAL_Size + OffsetFreeBins;
    Nr = 0;

    if ( !GetFieldValue(AnchorAddr, "nt!_LIST_ENTRY", "Flink", Flink) &&
         !GetFieldValue(AnchorAddr, "nt!_LIST_ENTRY", "Blink", Blink)
         ) {
        while((ULONG64)Flink != (ULONG64)AnchorAddr ) {
            if (CheckControlC()) {
                break;
            }
            BinAddr = Flink - Offset;
            dprintf("| %p ",BinAddr);

            if(!GetFieldValue(BinAddr, "nt!_FREE_HBIN", "FileOffset", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }
            if(!GetFieldValue(BinAddr, "nt!_FREE_HBIN", "Size", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }
            if(!GetFieldValue(BinAddr, "nt!_FREE_HBIN", "Flags", WorkVar)) {
                dprintf("| %8lx ",WorkVar);
            }

            if( !GetFieldValue(BinAddr + Offset, "nt!_LIST_ENTRY", "Flink", Flink) ) {
                dprintf("| %p ",Flink);
            }
            if( !GetFieldValue(BinAddr + Offset, "nt!_LIST_ENTRY", "Blink", Blink) ) {
                dprintf("| %p |\n",Blink);
            }
            
            Nr++;
        }
        
    }

    dprintf("-------------------------------------------------------------------\n");

    dprintf("%4u  FreeBins\n",Nr);

    dprintf("\n");
}

void 
regdirtyvector(
            LPSTR args
           )
/*++

Routine Description:

    displays the dirty vector of the hive

    Called as:

        !dirtyvector <HiveAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG64         CmHive,BufferAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,SizeOfBitMap,i;
    ULONG           BitsPerULONG;
    ULONG           BitsPerBlock;
    ULONG           DirtyBuffer;
    ULONG           Mask;

    if (sscanf(args,"%255s %lX",Dummy,&CmHive)) {

        CmHive = GetExpression(args+ strlen(Dummy));
    }

    if(!GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }

    dprintf("HSECTOR_SIZE = %lx\n",HSECTOR_SIZE);
    dprintf("HBLOCK_SIZE  = %lx\n",HBLOCK_SIZE);
    dprintf("PAGE_SIZE    = %lx\n",PageSize);
    dprintf("\n");

    if(!GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.DirtyAlloc", WorkVar)) {
        dprintf("DirtyAlloc      = :  0x%lx\n",WorkVar);
    }
    if(!GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.DirtyCount", WorkVar)) {
        dprintf("DirtyCount      = :  0x%lx\n",WorkVar);
    }
    if(!GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.DirtyVector.Buffer", BufferAddr)) {
        dprintf("Buffer          = :  0x%p\n",BufferAddr);
    }
    dprintf("\n");
    
    if(GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.DirtyVector.SizeOfBitMap", SizeOfBitMap)) {
        return;
    }

    BitsPerULONG = 8*ULongSize;
    BitsPerBlock = HBLOCK_SIZE / HSECTOR_SIZE;

    dprintf("   Address                       32k                                       32k");
    for(i=0;i<SizeOfBitMap;i++) {
        if (CheckControlC()) {
            break;
        }
        if( !(i%(2*BitsPerULONG ) ) ){
            dprintf("\n 0x%8lx  ",i*HSECTOR_SIZE);
        }

        if( !(i%BitsPerBlock) ) {
            dprintf(" ");
        }
        if( !(i%BitsPerULONG) ) {
            //
            // fetch in a new DWORD
            //
            if( !ReadMemory(BufferAddr,
                        &DirtyBuffer,
                        sizeof(DirtyBuffer),
                        &BytesRead)) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,BufferAddr);
                return;
            }
            BufferAddr += ULongSize;
            dprintf("\t");
        }

        Mask = ((DirtyBuffer >> (i%BitsPerULONG)) & 0x1);
        //Mask <<= (BitsPerULONG - (i%BitsPerULONG) - 1);
        //Mask &= DirtyBuffer;
        dprintf("%s",Mask?"1":"0");
    }
    dprintf("\n\n");
    
}

CCHAR CmKDFindFirstSetLeft[256] = {
        0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};

#define CmKDComputeIndex(Index, Size)                                   \
    {                                                                   \
        Index = (Size >> HHIVE_FREE_DISPLAY_SHIFT) - 1;                 \
        if (Index >= HHIVE_LINEAR_INDEX ) {                             \
                                                                        \
            /*                                                          \
            ** Too big for the linear lists, compute the exponential    \
            ** list.                                                    \
            */                                                          \
                                                                        \
            if (Index > 255) {                                          \
                /*                                                      \
                ** Too big for all the lists, use the last index.       \
                */                                                      \
                Index = HHIVE_FREE_DISPLAY_SIZE-1;                      \
            } else {                                                    \
                Index = CmKDFindFirstSetLeft[Index] +                   \
                        HHIVE_FREE_DISPLAY_BIAS;                        \
            }                                                           \
        }                                                               \
    }

void 
regfreecells(
            LPSTR args
           )
/*++

Routine Description:

    displays the free cells map in a bin

    Called as:

        !freecells <BinAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG64         BinAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,FileOffset,Size,BinHeaderSize;
    ULONG           NrOfCellsPerIndex;
    ULONG           NrOfCellsTotal;
    ULONG           TotalFreeSize;
    ULONG           Index;
    ULONG           CurrIndex,Offset;
    LONG            Current;

    if (sscanf(args,"%255s %lX",Dummy,&BinAddr)) {

        BinAddr = GetExpression(args+ strlen(Dummy));
    }

    if(!GetFieldValue(BinAddr, "nt!_HBIN", "Signature", WorkVar)) {
        if( WorkVar != HBIN_SIGNATURE ) {
            dprintf("\tInvalid Bin signature %lx \n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read bin at %p\n",BinAddr);
        return;
    }

    if(GetFieldValue(BinAddr, "nt!_HBIN", "FileOffset", FileOffset) ||
       GetFieldValue(BinAddr, "nt!_HBIN", "Size", Size)
        ) {
        dprintf("Could not read bin at %p\n",BinAddr);
    }
    
    BinHeaderSize = GetTypeSize("nt!_HBIN");
    dprintf("Bin Offset = 0x%lx  Size = 0x%lx\n",FileOffset,Size);

    NrOfCellsTotal = 0;
    TotalFreeSize = 0;

    for(CurrIndex = 0;CurrIndex<HHIVE_FREE_DISPLAY_SIZE;CurrIndex++) {
        dprintf("\n FreeDisplay[%2lu] :: ",CurrIndex);

        NrOfCellsPerIndex = 0;
        Offset = BinHeaderSize;
        while( Offset < Size ) {
            if (CheckControlC()) {
                break;
            }
            if( !ReadMemory(BinAddr + Offset,
                        &Current,
                        sizeof(Current),
                        &BytesRead) ) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,BinAddr + Offset);
                return;
            }
        
            if(Current>0) {
                //
                // free cell
                //
                CmKDComputeIndex(Index, Current);
                if( Index == CurrIndex ) {
                    //
                    // dum it here as this is the right index
                    //
                    NrOfCellsTotal++;
                    NrOfCellsPerIndex++;
                    TotalFreeSize += Current;
                    dprintf("    %lx [%lx]",Offset,Current);
                    if( !(NrOfCellsPerIndex % 8) && ((Offset + Current) < Size) ) {
                        dprintf("\n");
                    }
                }
            } else {
                Current *= -1;
            }
            Offset += Current;
        }
    }    

    dprintf("\nTotal: FreeCells = %lu, FreeSpace = 0x%lx BinUsage = %.2f%%\n",NrOfCellsTotal,TotalFreeSize,
                (float)(((float)(Size-BinHeaderSize-TotalFreeSize)/(float)(Size-BinHeaderSize))*100.00)
             );

}

void 
regfreehints(
            LPSTR args
           )
/*++

Routine Description:

    displays the freehints information for the hive

    Called as:

        !freehints <HiveAddr> <StorageCount> <DisplayCount>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG64         CmHive,BufferAddr;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar;
    ULONG           Mask;
    ULONG           BitsPerULONG;
    ULONG           BitsPerBlock;
    ULONG           BitsPerLine;
    ULONG           Stable_Length=0, Volatile_Length=0;
    ULONG64         Stable_Map=0, Volatile_Map=0;
    ULONG           DisplayCount;
    ULONG           StorageCount;
    ULONG           SizeOfBitmap;
    ULONG           i;
    FIELD_INFO offField = {"Hive.Storage", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "_CMHIVE", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    ULONG           DUAL_Size,StorageOffset,RTL_BITMAP_Size,OffsetFreeDisplay;
    ULONG64         DirtyBufferAddr;
    ULONG           DirtyBuffer;

    if (sscanf(args,"%255s %lX",Dummy,&CmHive)) {
        if  (GetExpressionEx(args+ strlen(Dummy), &CmHive, &args)) {
            if (!sscanf(args,"%lu %lu",&StorageCount,&DisplayCount)) {
                StorageCount = DisplayCount = 0;
            }
        }
    }

    if(!GetFieldValue(CmHive, "nt!_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    } else {
        dprintf("Could not read hive at %p\n",CmHive);
        return;
    }
    
    dprintf("HSECTOR_SIZE = %lx\n",HSECTOR_SIZE);
    dprintf("HBLOCK_SIZE  = %lx\n",HBLOCK_SIZE);
    dprintf("PAGE_SIZE    = %lx\n",PageSize);
    dprintf("\n");

    BitsPerULONG = 8*ULongSize;
    BitsPerBlock = 0x10000 / HBLOCK_SIZE; // 64k blocks
    BitsPerLine  = 0x40000 / HBLOCK_SIZE; // 256k lines (vicinity reasons)
    
    if(!GetHiveMaps(CmHive,&Stable_Map,&Stable_Length,&Volatile_Map,&Volatile_Length) ) {
        return;
    }

    if( StorageCount == 0 ) {
        SizeOfBitmap = Stable_Length / HBLOCK_SIZE;
    } else {
        SizeOfBitmap = Volatile_Length / HBLOCK_SIZE;
    }

    // Get the offset of Hive.FreeDisplay in _CMHIVE
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        dprintf("Cannot find _CMHIVE type.\n");
        return;
    }
    
    StorageOffset = (ULONG) offField.address;
    DUAL_Size = GetTypeSize("_DUAL");
    RTL_BITMAP_Size = GetTypeSize("nt!_RTL_BITMAP");
    dprintf("bitmap size = %lu\n",RTL_BITMAP_Size);
    GetFieldOffset("_DUAL", "FreeDisplay", &OffsetFreeDisplay);

    BufferAddr = CmHive + StorageOffset + DUAL_Size * StorageCount + OffsetFreeDisplay + DisplayCount * RTL_BITMAP_Size;
    if(GetFieldValue(BufferAddr, "nt!_RTL_BITMAP", "Buffer", DirtyBufferAddr) ) {
        dprintf("Cannot read bitmap address\n");
        return;
    }

    dprintf("Storage = %s , FreeDisplay[%lu]: \n",StorageCount?"Volatile":"Stable",DisplayCount);
    
    dprintf("\n%8s    %16s %16s %16s %16s","Address","64K (0x10000)","64K (0x10000)","64K (0x10000)","64K (0x10000)");

    for(i=0;i<SizeOfBitmap;i++) {
        if (CheckControlC()) {
            break;
        }
        if( !(i%BitsPerLine) ){
            dprintf("\n 0x%8lx  ",i*HBLOCK_SIZE);
        }

        if( !(i%BitsPerBlock) ) {
            dprintf(" ");
        }
        if( !(i%BitsPerULONG) ) {
            //
            // fetch in a new DWORD
            //
            if( !ReadMemory(DirtyBufferAddr,
                        &DirtyBuffer,
                        sizeof(DirtyBuffer),
                        &BytesRead) ) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,DirtyBufferAddr);
                return;
            }
            DirtyBufferAddr += ULongSize;
        }

        Mask = ((DirtyBuffer >> (i%BitsPerULONG)) & 0x1);
        //Mask <<= (BitsPerULONG - (i%BitsPerULONG) - 1);
        //Mask &= DirtyBuffer;
        dprintf("%s",Mask?"1":"0");
    }

    dprintf("\n\n");

}

void 
regseccache(
            LPSTR args
           )
/*++

Routine Description:

    displays the base block structure

    Called as:

        !seccache <HiveAddr>

Arguments:

    args - convkey.
    
Return Value:

    .

--*/

{
    ULONG64         HiveAddr,SecCache;
    DWORD           BytesRead;
    CHAR            Dummy[ 256 ];
    ULONG           WorkVar,i,Cell;
    LONG            WorkHint;
    ULONG           CacheEntrySize = GetTypeSize("_CM_KEY_SECURITY_CACHE_ENTRY");
    ULONG64         CachedSec;

    if (sscanf(args,"%255s %lX",Dummy,&HiveAddr)) {
        HiveAddr = GetExpression(args + strlen(Dummy));
    }

    if(!GetFieldValue(HiveAddr, "nt!_CMHIVE", "Hive.Signature", WorkVar)) {
        if( WorkVar != HHIVE_SIGNATURE ) {
            dprintf("Invalid Hive signature:  %lx\n",WorkVar);
            return;
        }
    }
    if (!GetFieldValue(HiveAddr, "nt!_CMHIVE", "SecurityCacheSize", WorkVar)) {
        dprintf("SecurityCacheSize = :  0x%lx\n",WorkVar);
    }
    if (!GetFieldValue(HiveAddr, "nt!_CMHIVE", "SecurityCount", WorkVar)) {
        dprintf("SecurityCount     = :  0x%lx\n",WorkVar);
    }
    if (!GetFieldValue(HiveAddr, "nt!_CMHIVE", "SecurityHitHint", WorkHint)) {
        dprintf("SecurityHitHint   = :  0x%lx\n",WorkHint);
    }

    if (!GetFieldValue(HiveAddr, "nt!_CMHIVE", "SecurityCache", SecCache)) {
        dprintf("SecurityCache     = :  0x%p\n\n",SecCache);
        dprintf("[Entry No.]  [Security Cell] [Security Cache]\n");

        for( i=0;i<WorkVar;i++) {
            if (CheckControlC()) {
                break;
            }

            if (GetFieldValue(SecCache + i*CacheEntrySize, "nt!_CM_KEY_SECURITY_CACHE_ENTRY", "Cell", Cell)) {
                continue;
            }
            if (GetFieldValue(SecCache + i*CacheEntrySize, "nt!_CM_KEY_SECURITY_CACHE_ENTRY", "CachedSecurity", CachedSec)) {
                continue;
            }
            dprintf("%[%8lu]    0x%8lx       ",i,Cell);
			dprintf("0x%p\n",CachedSec);
        }
    }
}


void ParseArgs(
                LPSTR args,
                LPSTR Dummy,
                ULONG SizeOfDummy
               )
{
    ULONG i =0;    
    while( (args[i]!= 0) && (args[i] != ' ')  && (i < SizeOfDummy-1) ) {
        Dummy[i] = args[i];
        i++;
    }
    Dummy[i] = 0;
}

void ParseKcbNameInArg(
                LPSTR args,
                LPSTR KcbName
               )
{
    ULONG i =0;    
    ULONG j =0;
    while( (args[i]!= 0) && (args[i] != ' ') ) {
        i++;
    }
    while( args[i] == ' ' ) {
        i++;
    }
    while( args[i]!= 0 ) {
        KcbName[j] = args[i];
        i++;j++;
    }
    KcbName[j] = 0;
}

DECLARE_API( reg )
/*++

Routine Description:

    Dispatch point for all registry extensions

    Called as:

        !reg <command> <params>

Arguments:

    args - Supplies the address of the HCELL_INDEX.

Return Value:

    .

--*/

{
    CHAR        Dummy[ 512 ];

    ParseArgs((LPSTR)args,(LPSTR)Dummy, sizeof(Dummy));

    // Get the offsets
    if (!GotOnce) {
        if (GetFieldOffset("_HMAP_DIRECTORY", "Directory", &DirectoryOffset)){
            return E_INVALIDARG;
        }
        if (GetFieldOffset("_HMAP_ENTRY", "BlockAddress", &BlockAddrOffset)) {
            return E_INVALIDARG;
        }
        if (GetFieldOffset("_HMAP_TABLE", "Table", &TableOffset)) {
            return E_INVALIDARG;
        }
        PtrSize = DBG_PTR_SIZE;
        ULongSize = sizeof(ULONG); // 
        HMapSize = GetTypeSize("_HMAP_ENTRY");

        GotOnce = TRUE;
    }

    dprintf("\n");
    if (!strcmp(Dummy, "kcb")) {
        regkcb((LPSTR)args);
    } else if (!strcmp(Dummy, "cellindex")) {
        regcellindex((LPSTR)args);
    } else if( !strcmp(Dummy, "hashindex")) {
        reghashindex((LPSTR)args);
    } else if( !strcmp(Dummy, "openkeys")) {
        regopenkeys((LPSTR)args,NULL);
    } else if( !strcmp(Dummy, "knode")) {
        regknode((LPSTR)args);
    } else if( !strcmp(Dummy, "kbody")) {
        regkbody((LPSTR)args);
    } else if( !strcmp(Dummy, "kvalue")) {
        regkvalue((LPSTR)args);
    } else if( !strcmp(Dummy, "baseblock")) {
        regbaseblock((LPSTR)args);
    } else if( !strcmp(Dummy, "findkcb")) {
        ParseKcbNameInArg((LPSTR)args,(LPSTR)Dummy);
        regopenkeys((LPSTR)args,(LPSTR)Dummy);
    } else if( !strcmp(Dummy, "hivelist")) {
        reghivelist();
    } else if( !strcmp(Dummy, "seccache")) {
        regseccache((LPSTR)args);
    } else if( !strcmp(Dummy, "viewlist")) {
        regviewlist((LPSTR)args);
    } else if( !strcmp(Dummy, "freebins")) {
        regfreebins((LPSTR)args);
    } else if( !strcmp(Dummy, "dirtyvector")) {
        regdirtyvector((LPSTR)args);
    } else if( !strcmp(Dummy, "freecells")) {
        regfreecells((LPSTR)args);
    } else if( !strcmp(Dummy, "freehints")) {
        regfreehints((LPSTR)args);
    } else if( !strcmp(Dummy, "dumppool")) {
        regdumppool((LPSTR)args);
    } else {
        // dump general usage
        dprintf("reg <command>  <params>       - Registry extensions\n");
        dprintf("    kcb        <Address>      - Dump registry key-control-blocks\n");
        dprintf("    knode      <Address>      - Dump registry key-node struct\n");
        dprintf("    kbody      <Address>      - Dump registry key-body struct\n");
        dprintf("    kvalue     <Address>      - Dump registry key-value struct\n");
        dprintf("    baseblock  <HiveAddr>     - Dump the baseblock for the specified hive\n");
        dprintf("    seccache   <HiveAddr>     - Dump the security cache for the specified hive\n");
        dprintf("    hashindex  <conv_key>     - Find the hash entry given a Kcb ConvKey\n");
        dprintf("    openkeys   <HiveAddr|0>   - Dump the keys opened inside the specified hive\n");
        dprintf("    findkcb    <FullKeyPath>  - Find the kcb for the corresponding path\n");
        dprintf("    hivelist                  - Displays the list of the hives in the system\n");
        dprintf("    viewlist   <HiveAddr>     - Dump the pinned/mapped view list for the specified hive\n");
        dprintf("    freebins   <HiveAddr>     - Dump the free bins for the specified hive\n");
        dprintf("    freecells <BinAddr>       - Dump the free cells in the specified bin\n");
        dprintf("    dirtyvector<HiveAddr>     - Dump the dirty vector for the specified hive\n");
        dprintf("    cellindex  <HiveAddr> <cellindex> - Finds the VA for a specified cell index\n");
        dprintf("    freehints  <HiveAddr> <Storage> <Display> - Dumps freehint info\n");
        dprintf("    dumppool   [s|r]          - Dump registry allocated paged pool\n");
        dprintf("       s - Save list of registry pages to temporary file\n");
        dprintf("       r - Restore list of registry pages from temp. file\n");
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\ready.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ready.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:
    Jamie Hankins (a-jamhan) 20-Oct-1997 Added CheckControlC to loop.

--*/

#include "precomp.h"
#pragma hdrstop

HRESULT
DumpReadyList(
    ULONG dwProcessor,
    ULONG Flags
    )
/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{

    ULONG64 DispatcherReadyListHead;
    ULONG HighestProcessor;
    LONG i;
    ULONG Index;
    ULONG ListEntrySize;
    ULONG MaximumProcessors;
    ULONG64 MemoryAddress;
    ULONG64 ProcessorBlock[64];
    ULONG PtrSize = DBG_PTR_SIZE;
    ULONG ReadyListHeadOffset;
    ULONG result;
    BOOLEAN ThreadDumped = FALSE;
    ULONG WaitListOpffset;

    //
    // Get number of processors.
    //

    MaximumProcessors = GetByteValue("nt!KeNumberProcessors");

    //
    // Get address of processor block array and read entire array.
    //

    MemoryAddress = GetExpression("nt!KiProcessorBlock");
    if (MemoryAddress == 0) {
        dprintf("Unable to read processor block array\n");
        return E_INVALIDARG;
    }

    HighestProcessor = 0;
    for (Index = 0; Index < MaximumProcessors; Index += 1) { 
        if (!ReadPointer(MemoryAddress + Index * PtrSize, &ProcessorBlock[Index])) {
            dprintf("Unable to read processor block array\n");
            return E_INVALIDARG;
        }

        if (ProcessorBlock[Index] != 0) {
            HighestProcessor = Index;
        }
    } 

    //
    // Get ready list head offset.
    //

    if (GetFieldOffset("nt!_KPRCB", "DispatcherReadyListHead", &ReadyListHeadOffset)) {
        dprintf("Unable to read KPRCB.DispatcherReadyListHead offset.\n");
        return E_INVALIDARG;
    }

    //
    // Scan the ready list for each processor.
    //

    for (Index = 0; Index <= HighestProcessor; Index += 1)
    {
        DispatcherReadyListHead = ProcessorBlock[Index];
        if ( DispatcherReadyListHead )
        {
            DispatcherReadyListHead += ReadyListHeadOffset;

            ListEntrySize = GetTypeSize("nt!_LIST_ENTRY");
            if (ListEntrySize == 0) {
                ListEntrySize = DBG_PTR_SIZE * 2;
            }
    
            GetFieldOffset("nt!_ETHREAD", "Tcb.WaitListEntry", &WaitListOpffset);
    
            for (i = MAXIMUM_PRIORITY-1; i >= 0 ; i -= 1 ) {
                ULONG64 Flink, Blink;
    
                if ( GetFieldValue( DispatcherReadyListHead + i*ListEntrySize,
                                    "nt!_LIST_ENTRY",
                                    "Flink",
                                    Flink) ) {
    
                    dprintf(
                        "Could not read contents of DispatcherReadyListHead at %08p [%ld]\n",
                        (DispatcherReadyListHead + i * ListEntrySize), i);
    
                    return E_INVALIDARG;
                }
    
                if (Flink != DispatcherReadyListHead+i*ListEntrySize) {
                    ULONG64 ThreadEntry, ThreadFlink;
    
                    dprintf("Ready Threads at priority %ld on processor %d\n", i, Index);
    
                    for (ThreadEntry = Flink ;
                         ThreadEntry != DispatcherReadyListHead+i*ListEntrySize ;
                         ThreadEntry = ThreadFlink ) {
                        ULONG64 ThreadBaseAddress = (ThreadEntry - WaitListOpffset);
    
                        if ( GetFieldValue( ThreadBaseAddress,
                                            "nt!_ETHREAD",
                                            "Tcb.WaitListEntry.Flink",
                                            ThreadFlink) ) {
                            dprintf("Could not read contents of thread %p\n", ThreadBaseAddress);
                        }
    
                        if(CheckControlC()) {
                            return E_INVALIDARG;
                        }
    
                        DumpThread(dwProcessor,"    ", ThreadBaseAddress, Flags);
                        ThreadDumped = TRUE;
    
                    }
                } else {
                    GetFieldValue( DispatcherReadyListHead + i*ListEntrySize,
                                   "nt!_LIST_ENTRY",
                                   "Blink",
                                   Blink);
                    if (Flink != Blink) {
                        dprintf("Ready linked list may to be corrupt...\n");
                    }
                }
            }
    
            if (!ThreadDumped) {
                dprintf("No threads in READY state\n");
            }

        } else {
            dprintf("Could not determine address of DispatcherReadyListHead\n");
            return E_INVALIDARG;
        }
    }

    return S_OK;
}


HRESULT
DumpReadyList_3598(
    ULONG dwProcessor,
    ULONG Flags
    )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64     KiDispatcherReadyListHead;
    ULONG       ListEntrySize, WaitListOpffset;
    ULONG       result;
    LONG        i;
    BOOLEAN     ThreadDumped = FALSE;

    KiDispatcherReadyListHead = GetExpression( "nt!KiDispatcherReadyListHead" );
    if ( KiDispatcherReadyListHead ) {

        ListEntrySize = GetTypeSize("nt!_LIST_ENTRY");
        if (ListEntrySize == 0) {
            ListEntrySize = DBG_PTR_SIZE * 2;
        }
        GetFieldOffset("nt!_ETHREAD", "Tcb.WaitListEntry", &WaitListOpffset);

        for (i = MAXIMUM_PRIORITY-1; i >= 0 ; i -= 1 ) {
            ULONG64 Flink, Blink;

            if ( GetFieldValue( KiDispatcherReadyListHead + i*ListEntrySize,
                                "nt!_LIST_ENTRY",
                                "Flink",
                                Flink) ) {
                dprintf(
                    "Could not read contents of KiDispatcherReadyListHead at %08p [%ld]\n",
                    (KiDispatcherReadyListHead + i * ListEntrySize), i
                    );
                return E_INVALIDARG;
            }

            if (Flink != KiDispatcherReadyListHead+i*ListEntrySize) {
                ULONG64 ThreadEntry, ThreadFlink;

                dprintf("Ready Threads at priority %ld\n", i);

                for (ThreadEntry = Flink ;
                     ThreadEntry != KiDispatcherReadyListHead+i*ListEntrySize ;
                     ThreadEntry = ThreadFlink ) {
                    ULONG64 ThreadBaseAddress = (ThreadEntry - WaitListOpffset);

                    if ( GetFieldValue( ThreadBaseAddress,
                                        "nt!_ETHREAD",
                                        "Tcb.WaitListEntry.Flink",
                                        ThreadFlink) ) {
                        dprintf("Could not read contents of thread %p\n", ThreadBaseAddress);
                    }

                    if(CheckControlC()) {
                        return E_INVALIDARG;
                    }

                    DumpThread(dwProcessor,"    ", ThreadBaseAddress, Flags);
                    ThreadDumped = TRUE;

                }
            } else {
                GetFieldValue( KiDispatcherReadyListHead + i*ListEntrySize,
                               "nt!_LIST_ENTRY",
                               "Blink",
                               Blink);
                if (Flink != Blink) {
                    dprintf("Ready linked list may to be corrupt...\n");
                }
            }
        }

        if (!ThreadDumped) {
            dprintf("No threads in READY state\n");
        }
    } else {
        dprintf("Could not determine address of KiDispatcherReadyListHead\n");
        return E_INVALIDARG;
    }
    return S_OK;
}


DECLARE_API( ready )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{

    DWORD       Flags;
    ULONG       dwProcessor=0;

    INIT_API();
    GetCurrentProcessor(Client, &dwProcessor, NULL);

    Flags = (ULONG)GetExpression(args);
    
    if (BuildNo <= 3598)
    {
        DumpReadyList_3598(dwProcessor, Flags);
    } else
    {
        DumpReadyList(dwProcessor, Flags);
    }

    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\qlocks.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    qlocks.c

Abstract:

    WinDbg Extension Api

Author:

    David N. Cutler (davec) 25-Sep-1999

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define queued lock data.
//

#define NUMBER_PROCESSORS 32
#define NUMBER_PROCESSORS_X86  32
#define NUMBER_PROCESSORS_IA64 64

#if (NUMBER_PROCESSORS_IA64 < MAXIMUM_PROCESSORS)
#error "Update NUMBER_PROCESSORS definition"
#endif

UCHAR Key[NUMBER_PROCESSORS];

#define KEY_CORRUPT         255
#define KEY_OWNER           254
#define KEY_NOTHING         253

typedef struct KSPIN_LOCK_QUEUE_READ {
    ULONG64 Next;
    ULONG64 Lock;
} KSPIN_LOCK_QUEUE_READ;

KSPIN_LOCK_QUEUE_READ LockQueue[NUMBER_PROCESSORS_IA64][LockQueueMaximumLock];

ULONG64 ProcessorBlock[NUMBER_PROCESSORS_IA64];

ULONG64 SpinLock[LockQueueMaximumLock];

typedef struct _LOCK_NAME {
    KSPIN_LOCK_QUEUE_NUMBER Number;
    PCHAR Name;
} LOCK_NAME, *PLOCK_NAME;

LOCK_NAME LockName[] = {
    { LockQueueDispatcherLock,    "KE   - Dispatcher   " },
    { LockQueueUnusedSpare1,      "     - Unused Spare " },
    { LockQueuePfnLock,           "MM   - PFN          " },
    { LockQueueSystemSpaceLock,   "MM   - System Space " },
    { LockQueueVacbLock,          "CC   - Vacb         " },
    { LockQueueMasterLock,        "CC   - Master       " },
    { LockQueueNonPagedPoolLock,  "EX   - NonPagedPool " },
    { LockQueueIoCancelLock,      "IO   - Cancel       " },
    { LockQueueWorkQueueLock,     "EX   - WorkQueue    " },
    { LockQueueIoVpbLock,         "IO   - Vpb          " },
    { LockQueueIoDatabaseLock,    "IO   - Database     " },
    { LockQueueIoCompletionLock,  "IO   - Completion   " },
    { LockQueueNtfsStructLock,    "NTFS - Struct       " },
    { LockQueueAfdWorkQueueLock,  "AFD  - WorkQueue    " },
    { LockQueueBcbLock,           "CC   - Bcb          " },
    { LockQueueMmNonPagedPoolLock,"MM   - MM NonPagedPool " },
    { LockQueueMaximumLock,       NULL                   },
};

//
// Define forward referenced prototypes.
//

ULONG
ProcessorIndex (
    ULONG64 LockAddress,
    ULONG   LockIndex
    );

DECLARE_API( qlocks )

/*++

Routine Description:

    Dump kernel mode queued spinlock status.

Arguments:

    None.

Return Value:

    None.

--*/

{

    BOOL Corrupt;
    ULONG HighestProcessor;
    ULONG Index;
    KSPIN_LOCK_QUEUE_READ *LockOwner;
    ULONG Last;
    ULONG Loop;
    ULONG64 MemoryAddress;
    ULONG Number;
    ULONG Result;
    CHAR Sequence;
    ULONG LockQueueOffset;
    ULONG Processor;
    ULONG PtrSize = DBG_PTR_SIZE;
    ULONG SizeOfQ = GetTypeSize("nt!KSPIN_LOCK_QUEUE");
    ULONG MaximumProcessors;


    MaximumProcessors = (UCHAR) GetUlongValue("NT!KeNumberProcessors");
//        IsPtr64() ? NUMBER_PROCESSORS_IA64 : NUMBER_PROCESSORS_X86;

    //
    // Get address of processor block array and read entire array.
    //

    MemoryAddress = GetExpression("nt!KiProcessorBlock");
    if (MemoryAddress == 0) {

        //
        // Either the processor block address is zero or the processor
        // block array could not be read.
        //

        dprintf("Unable to read processor block array\n");
        return E_INVALIDARG;
    }

    HighestProcessor = 0;
    for (Index = 0; Index < MaximumProcessors; Index++) { 
        
        if (!ReadPointer(MemoryAddress + Index*PtrSize, &ProcessorBlock[Index])) {
            dprintf("Unable to read processor block array\n");
            return E_INVALIDARG;
        }

        if (ProcessorBlock[Index] != 0) {
            HighestProcessor = Index;
        }
    } 

    if (GetFieldOffset("nt!_KPRCB", "LockQueue", &LockQueueOffset)) {
        dprintf("Unable to read KPRCB.LockQueue offset.\n");
        return E_INVALIDARG;
    }

    //
    // Read the lock queue information for each processor.
    //

    for (Index = 0; Index < MaximumProcessors; Index += 1) {
        RtlZeroMemory(&LockQueue[Index][0],
                      sizeof(KSPIN_LOCK_QUEUE_READ) * LockQueueMaximumLock);

        if (ProcessorBlock[Index] != 0) {
            ULONG j;

            for (j = 0; j < LockQueueMaximumLock; j++) { 
                if (GetFieldValue(ProcessorBlock[Index] + LockQueueOffset + j * SizeOfQ,
                                  "nt!KSPIN_LOCK_QUEUE",
                                  "Next",
                                  LockQueue[Index][j].Next)) {

                    //
                    // Lock queue information could not be read for the respective
                    // processor.
                    //

                    dprintf("Unable to read lock queue information for processor %d @ %p\n",
                            Index, ProcessorBlock[Index]);

                    return E_INVALIDARG;
                }

                GetFieldValue(ProcessorBlock[Index] + LockQueueOffset + j * SizeOfQ,
                              "nt!KSPIN_LOCK_QUEUE",
                              "Lock",
                              LockQueue[Index][j].Lock);
            }
        }
    }

    //
    // Read the spin lock information for each queued lock.
    //

    for (Index = 0; Index < LockQueueMaximumLock; Index += 1) {
        SpinLock[Index] = 0;
        if (LockQueue[0][Index].Lock != 0) {
            if (GetFieldValue(LockQueue[0][Index].Lock & ~(LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER),
                              "nt!PVOID", // KSPIN_LOCK == ULONG_PTR, this would sign-extens it
                              NULL,
                              SpinLock[Index])) {

                //
                // Spin lock information could not be read for the respective
                // queued lock.
                //

                dprintf("Unable to read spin lock information for queued lock %d\n",
                        Index);

                return E_INVALIDARG;
            }
        }
    }

    //
    // Verify that the kernel spin lock array is not corrupt. Each entry in
    // this array should either be zero or contain the address of the correct
    // lock queue entry in one of the processor control blocks.
    //

    Corrupt = FALSE;
    for (Index = 0; Index < LockQueueMaximumLock && (LockName[Index].Name != NULL); Index += 1) {
        if (SpinLock[Index] != 0) {
            if (ProcessorIndex(SpinLock[Index], Index) == 0) {
                Corrupt = TRUE;
                dprintf("Kernel spin lock %s is corrupt.\n", LockName[Index].Name);
            }
        }
    }

    //
    // Verify that all lock queue entries are not corrupt. Each lock queue
    // entry should either have a next field of NULL or contain the address
    // of the correct lock queue entry in one of the processor control blocks.
    //

    for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
        for (Index = 0; Index < LockQueueMaximumLock; Index += 1) {
            if (LockQueue[Loop][Index].Next != 0) {
                if (ProcessorIndex(LockQueue[Loop][Index].Next, Index) == 0) {
                    Corrupt = TRUE;
                    dprintf("Lock entry %d for processor %d is corrupt\n",
                            Index,
                            Loop);
                }
            }
        }
    }

    if (Corrupt != FALSE) {
        return E_INVALIDARG;
    }

    //
    // Output key information and headings.
    //

    dprintf("Key: O = Owner, 1-n = Wait order, blank = not owned/waiting, C = Corrupt\n\n");
    dprintf("                       Processor Number\n");
    dprintf("    Lock Name       ");
    for (Index = 0; Index <= HighestProcessor; Index++) {
        dprintf("%3d", Index);
    }
    dprintf("\n\n");

    //
    // Process each queued lock and output owner information.
    //

    for (Index = 0; Index < LockQueueMaximumLock && (LockName[Index].Name != NULL); Index += 1) {

        if (Index != (ULONG) LockName[Index].Number) {
            dprintf("ERROR: extension bug: name array does not match queued lock list!\n");
            break;
        }

        dprintf("%s", LockName[Index].Name);

        //
        // If the lock is owned, then find the owner and any waiters. Output
        // the owner and waiters in order.
        //
        // If the lock is not owned, then check the consistency of lock queue
        // entries. They should all contain next pointer of NULL and both the
        // owner and wait flags should be clear.
        //

        RtlFillMemory(&Key[0], NUMBER_PROCESSORS, KEY_NOTHING);
        if (SpinLock[Index] != 0) {
            LockOwner = NULL;
            for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
                if (LockQueue[Loop][Index].Lock & LOCK_QUEUE_OWNER) {
                    LockOwner = &LockQueue[Loop][Index];
                    break;
                }
            }

            //
            // If the lock owner was not found, then assume that the kernel
            // spin lock points to the owner and the owner bit has not been
            // set yet. Otherwise, fill out the owner/wait key array.
            //

            if (LockOwner == NULL) {
                Number = ProcessorIndex(SpinLock[Index], Index);
                Key[Number - 1] = KEY_OWNER;

                //
                // The owner processor has been determined by the kernel
                // spin lock address. Check to determine if any of the
                // lock queue entries are corrupt and fill in the key
                // array accordingly. A corrupt lock queue entry is one
                // that has a non NULL next field or one of the owner or
                // wait flags is set.
                //

                for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
                    if ((LockQueue[Loop][Index].Next != 0) ||
                        (LockQueue[Loop][Index].Lock & (LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER))) {
                        Key[Loop] = KEY_CORRUPT;
                    }
                }

            } else {

                //
                // The lock owner was found. Attempt to construct the wait
                // chain.
                //

                Key[Loop] = KEY_OWNER;
                Last = Loop;
                Sequence = 0;
                while (LockOwner->Next != 0) {
                    Number = ProcessorIndex(LockOwner->Next, Index);
                    if (Key[Number - 1] == KEY_NOTHING) {
                        Last = Number - 1;
                        Sequence += 1;
                        Key[Last] = Sequence;
                        LockOwner = &LockQueue[Last][Index];

                    } else {

                        //
                        // The wait chain loops back on itself. Mark the
                        // entry as corrupt and scan the other entries to
                        // detemine if they are also corrupt.
                        //

                        Key[Last] = KEY_CORRUPT;
                        for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
                            if ((LockQueue[Loop][Index].Next != 0) ||
                                (LockQueue[Loop][Index].Lock & (LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER))) {
                                if (Key[Loop] == KEY_NOTHING) {
                                    Key[Loop] = KEY_CORRUPT;
                                }
                            }
                        }

                        break;
                    }
                }

                //
                // If the lock owner next field is NULL, then the wait
                // search ended normally. Check to determine if the kernel
                // spin lock points to the last entry in the queue.
                //

                if (LockOwner->Next == 0) {
                    Number = ProcessorIndex(SpinLock[Index], Index);
                    if (Last != (Number - 1)) {
                        Sequence += 1;
                        Key[Number - 1] = Sequence;
                    }
                }
            }

        } else {

            //
            // The kernel spin lock is not owned. Check to determine if any
            // of the lock queue entries are corrupt and fill in the key
            // array accordingly. A corrupt entry is one that has a non NULL
            // next field or one of the owner or wait flags is set.
            //

            for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
                if ((LockQueue[Loop][Index].Next != 0) ||
                    (LockQueue[Loop][Index].Lock & (LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER))) {
                    Key[Loop] = KEY_CORRUPT;
                }
            }
        }

        for (Processor = 0; Processor <= HighestProcessor; Processor++) {
            switch (Key[Processor]) {
            case KEY_CORRUPT:
                dprintf("  C");
                break;
            case KEY_OWNER:
                dprintf("  O");
                break;
            case KEY_NOTHING:
                dprintf("   ");
                break;
            default:
                dprintf("%3d", Key[Processor]);
                break;
            }
        }
        dprintf("\n");
    }

    dprintf("\n");
    return S_OK;
}

ULONG
ProcessorIndex (
    ULONG64 LockAddress,
    ULONG   LockIndex
    )

/*++

Routine Description:

    This function computes the processor number of the respective processor
    given a lock queue address and the lock queue index.

Arguments:

    LockQueue - Supplies a lock queue address in target memory.

Return Value:

    Zero is returned if a matching processor is not found. Otherwise, the
    processor number plus one is returned.

--*/

{

    ULONG64 LockBase;
    ULONG Loop;
    ULONG SizeOfKprcb = GetTypeSize("nt!_KPRCB");
    ULONG SizeOfQ = GetTypeSize("nt!KSPIN_LOCK_QUEUE");
    ULONG LockQueueOffset;

    if (GetFieldOffset("nt!_KPRCB", "LockQueue", &LockQueueOffset)) {
        dprintf("Unable to read KPRCB type.\n");
        return 0;
    }

    //
    // Attempt to find the lock address in one of the processor control
    // blocks.
    //

    for (Loop = 0; Loop < NUMBER_PROCESSORS; Loop += 1) {
        if ((LockAddress >= ProcessorBlock[Loop]) &&
            (LockAddress < ProcessorBlock[Loop] + SizeOfKprcb)) {
            LockBase = ProcessorBlock[Loop] + LockQueueOffset;
            if (LockAddress == (LockBase + SizeOfQ * LockIndex)) {
                return Loop + 1;
            }
        }
    }

    return 0;
}

PUCHAR QueuedLockName[] = {
    "DispatcherLock",
    "SpareUsedLock",
    "PfnLock",
    "SystemSpaceLock",
    "VacbLock",
    "MasterLock",
    "NonPagedPoolLock",
    "IoCancelLock",
    "WorkQueueLock",
    "IoVpbLock",
    "IoDatabaseLock",
    "IoCompletionLock",
    "NtfsStructLock",
    "AfdWorkQueueLock",
    "BcbLock",
    "MmNonPagedPoolLock"
};

DECLARE_API( qlockperf )

/*++

Routine Description:

    Displays queued spin lock performance data (if present).

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // The following structure is used to accumulate data about each
    // acquire/release pair for a lock.
    //

    typedef struct {
        union {
            ULONGLONG   Key;
            struct {
                ULONG_PTR Releaser;
                ULONG_PTR Acquirer;
            };
        };
        ULONGLONG   Time;
        ULONGLONG   WaitTime;
        ULONG       Count;
        ULONG       Waiters;
        ULONG       Depth;
        ULONG       IncreasedDepth;
        ULONG       Clean;
    } QLOCKDATA, *PQLOCKDATA;

    //
    // House keeping data for each lock.
    //

    typedef struct {

        //
        // The following fields are used to keep data from acquire
        // to release.
        //

        ULONGLONG   AcquireTime;
        ULONGLONG   WaitToAcquire;
        ULONG_PTR   AcquirePoint;
        BOOLEAN     Clean;

        //
        // Remaining fields accumulate global stats for this lock.
        //

        ULONG       Count;
        ULONG       Pairs;
        ULONG       FailedTry;
        UCHAR       MaxDepth;
        UCHAR       PreviousDepth;
        ULONG       NoWait;
    } QLOCKHOUSE, *PQLOCKHOUSE;


    ULONG64     TargetHouse;
    ULONG64     TargetLog;
    PQLOCKHOUSE LockHome;
    PQLOCKDATA  LockData;
    QLOCKDATA   TempEntry;
    ULONG       LogEntrySize;
    ULONG       LogSize;
    ULONG       HouseEntrySize;
    ULONG       HouseSize;
    ULONG       NumberOfLocks;
    ULONG       LockIndex;
    ULONG       i, j;
    ULONG       MaxEntriesPerLock;
    ULONG       HighIndex;
    ULONGLONG   HighTime;
    ULONGLONG   TotalHoldTime;
    ULONG       PercentageHeld;
    ULONG64 AcquiredAddress;
    ULONG64 ReleasedAddress;
    UCHAR AcquirePoint[MAX_PATH];
    UCHAR ReleasePoint[MAX_PATH];
    ULONG64 AcquireOffset;
    ULONG64 ReleaseOffset;
    BOOLEAN Verbose = FALSE;
    BOOLEAN Columnar = FALSE;
    BOOLEAN Interesting = FALSE;
    ULONG LockLow, LockHigh;

    //
    // First, see if we can do anything useful.
    //
    // For the moment, this is x86 only.
    //

    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("Sorry, don't know how to gather queued spinlock performance\n"
                "data on anything but an x86.\n");
        return E_INVALIDARG;
    }

    //
    // Parse arguments.
    //
    
    if (strstr(args, "?")) {

        //
        // Has asked for usage information.   Give them the options
        // and an explanation of the output.
        //

        dprintf("usage: qlockperf [-v] [n]\n"
                "       -v  indicates verbose output (see below).\n"
                "       -c  verbose columnar output.\n"
                "       -ci verbose columnar output, no totals.\n"
                "       n  supplies the lock number (default is all)\n\n"
                "Verbose output includes details of each lock acquire and\n"
                "release pair.   Two lines per pair.\n\n"
                "Line 1: ppp A symbolic_address R symbolic_address\n"
                "        ppp    percentage, this pair for this lock (overall)\n"
                "        A      Acquire point\n"
                "        R      Release point\n\n"
                "Line 2:\n"
                "        HT     Hold Time total (average)\n"
                "               This is the time from acquire to release.\n"
                "        WT     Wait Time total (average)\n"
                "               This is the time waiting to acquire.\n"
                "        C      Count\n"
                "               Number of times this pair occured.\n"
                "        CA     Clean Acquires (percentage)\n"
                "               Number of times acquire did not wait.\n"
                "        WC     Waiter Count\n"
                "               Number of processors waiting for this\n"
                "               lock at release.\n"
                "        avD    Average number of waiters (at release).\n"
                "        ID     Increased Depth\n"
                "               Number of times the queue length increased\n"
                "               while the lock was held in this pair.\n"
                );
        return E_INVALIDARG;
    }

    if (strstr(args, "-c")) {
        Verbose = TRUE;
        Columnar = TRUE;
    }

    if (strstr(args, "-ci")) {
        Interesting = TRUE;
    }

    if (strstr(args, "-v")) {
        Verbose = TRUE;
    }

    LockLow = 0;
    LockHigh = 999;

    for (i = 0; args[i]; i++) {
        if ((args[i] >= '0') && (args[i] <= '9')) {
            LockLow = (ULONG)GetExpression(&args[i]);
            LockHigh = LockLow;
        }
    }
   
    TargetHouse = GetExpression("nt!KiQueuedSpinLockHouse");

    //
    // Checking for control C after the first operation that might
    // cause symbol load in case the user has bad symbols and is
    // trying to get out.
    //

    if (CheckControlC()) {
        return E_ABORT;
    }

    TargetLog      = GetExpression("nt!KiQueuedSpinLockLog");
    LogEntrySize   = GetTypeSize("nt!QLOCKDATA");
    LogSize        = GetTypeSize("nt!KiQueuedSpinLockLog");
    HouseEntrySize = GetTypeSize("nt!QLOCKHOUSE");
    HouseSize      = GetTypeSize("nt!KiQueuedSpinLockHouse");

    if (!(TargetHouse &&
          TargetLog &&
          LogEntrySize &&
          LogSize &&
          HouseEntrySize &&
          HouseSize)) {
        dprintf("Sorry, can't find required system data, perhaps this kernel\n"
                "was not built with QLOCK_STAT_GATHER defined?\n");
        return E_INVALIDARG;
    }

    if ((LogEntrySize != sizeof(QLOCKDATA)) ||
        (HouseEntrySize != sizeof(QLOCKHOUSE))) {
        dprintf("Structure sizes in the kernel and debugger extension don't\n"
                "match.  This extension needs to be rebuild to match the\n"
                "running system.\n");
        return E_INVALIDARG;
    }

    NumberOfLocks = HouseSize / HouseEntrySize;
    MaxEntriesPerLock = LogSize / LogEntrySize / NumberOfLocks;
    dprintf("Kernel build with %d PRCB queued spinlocks\n", NumberOfLocks);
    dprintf("(maximum log entries per lock = %d)\n", MaxEntriesPerLock);

    if (LockHigh >= NumberOfLocks) {
        if (LockLow == LockHigh) {
            dprintf("User requested lock %d, system has only %d locks, quitting.\n",
                    LockLow,
                    NumberOfLocks);
            return E_INVALIDARG;
        }
        LockHigh = NumberOfLocks - 1;
    }

    if (NumberOfLocks > 16) {

        //
        // I don't believe it.
        //

        dprintf("The number of locks doesn't seem reasonable, giving up.\n");
        return E_INVALIDARG;
    }

    if (CheckControlC()) {
        return E_ABORT;
    }

    //
    // Allocate space to process the data for one lock at a time.
    //

    LockHome = LocalAlloc(LPTR, sizeof(*LockHome));
    LockData = LocalAlloc(LPTR, sizeof(*LockData) * MaxEntriesPerLock);

    if (!(LockHome && LockData)) {
        dprintf("Couldn't allocate memory for local copies of kernel data.\n"
                "unable to continue.\n");
        goto outtahere;
    }

    for (LockIndex = LockLow; LockIndex <= LockHigh; LockIndex++) {
        if ((!ReadMemory(TargetHouse + (LockIndex * sizeof(QLOCKHOUSE)),
                         LockHome,
                         sizeof(QLOCKHOUSE),
                         &i)) || (i < sizeof(QLOCKHOUSE))) {
            dprintf("unable to read data for lock %d, quitting\n",
                    LockIndex);
            return E_INVALIDARG;
        }

        if (CheckControlC()) {
            goto outtahere;
        }

        if (LockHome->Pairs == 0) {
            continue;
        }
        dprintf("\nLock %d %s\n", LockIndex, QueuedLockName[LockIndex]);
        dprintf("  Acquires %d (%d pairs)\n", LockHome->Count, LockHome->Pairs);
        dprintf("  Failed Tries %d\n", LockHome->FailedTry);
        dprintf("  Maximum Depth (at release) %d\n", LockHome->MaxDepth);
        dprintf("  No Waiters (at acquire) %d (%d%%)\n",
                LockHome->NoWait,
                LockHome->NoWait * 100 / LockHome->Count);

        //
        // Change the following to a parameter saying we want the
        // details.
        //

        if (Verbose) {
            ULONG Entries = LockHome->Pairs;
            PQLOCKDATA Entry;

            if (Entries > MaxEntriesPerLock)
            {
                Entries = MaxEntriesPerLock;
            }

            if ((!ReadMemory(TargetLog + (LockIndex * MaxEntriesPerLock * sizeof(QLOCKDATA)),
                             LockData,
                             Entries * sizeof(QLOCKDATA),
                             &i)) || (i < (Entries * sizeof(QLOCKDATA)))) {
                dprintf("unable to read data for lock %d, quitting\n",
                        LockIndex);
                return E_INVALIDARG;
            }

            if (CheckControlC()) {
                goto outtahere;
            }

            //
            // Sort table into longest duration.
            //

            TotalHoldTime = 0;
            for (i = 0; i < (Entries - 1); i++) {
                HighTime = LockData[i].Time;
                HighIndex = i;
                for (j = i + 1; j < Entries; j++) {
                    if (LockData[j].Time > HighTime) {
                        HighIndex = j;
                        HighTime = LockData[j].Time;
                    }
                }
                if (HighIndex != i) {

                    //
                    // Swap entries.
                    //

                    TempEntry = LockData[i];
                    LockData[i] = LockData[HighIndex];
                    LockData[HighIndex] = TempEntry;
                }
                TotalHoldTime += LockData[i].Time;
            }
            TotalHoldTime += LockData[Entries-1].Time;
            dprintf("  Total time held %I64ld\n", TotalHoldTime);

            //
            // Print something!
            //

            if (Interesting) {
                dprintf("\n     Average  Average     Count   %% Av.  %%\n"
                        "  %%     Hold     Wait            0w Dp Con\n");
            } else if (Columnar) {
                dprintf("\n                   Total  Average               Total  Average     Count     Clean   %%   Waiters Av Increased   %%\n"
                        "  %%                 Hold     Hold                Wait     Wait                      0w           Dp           Con\n");
            }
            for (i = 0; i < Entries; i++) {

                if (CheckControlC()) {
                    goto outtahere;
                }

                Entry = &LockData[i];

                //
                // Sign extend if necessary.
                //
            
                if (!IsPtr64()) {
                    AcquiredAddress = (ULONG64)(LONG64)(LONG)Entry->Acquirer;
                    ReleasedAddress = (ULONG64)(LONG64)(LONG)Entry->Releaser;
                }

                //
                // Lookup the symbolic addresses.
                //

                GetSymbol(AcquiredAddress, AcquirePoint, &AcquireOffset);
                GetSymbol(ReleasedAddress, ReleasePoint, &ReleaseOffset);

                PercentageHeld = (ULONG)(Entry->Time * 100 / TotalHoldTime);

                if (Interesting) {
                    dprintf("%3d%9d%9d%10d%4d%3d%4d %s+0x%x  %s+0x%x\n",
                            PercentageHeld,
                            (ULONG)(Entry->Time / Entry->Count),
                            (ULONG)(Entry->WaitTime / Entry->Count),
                            Entry->Count,
                            Entry->Clean * 100 / Entry->Count,
                            Entry->Depth / Entry->Count,
                            Entry->IncreasedDepth * 100 / Entry->Count,
                            AcquirePoint, (ULONG)AcquireOffset,
                            ReleasePoint, (ULONG)ReleaseOffset);

                } else if (Columnar) {
                    dprintf("%3d %20I64ld%9d%20I64ld%9d",
                            PercentageHeld,
                            Entry->Time,
                            (ULONG)(Entry->Time / Entry->Count),
                            Entry->WaitTime,
                            (ULONG)(Entry->WaitTime / Entry->Count));
                    dprintf("%10d%10d%4d%10d%3d%10d%4d %s+0x%x  %s+0x%x\n",
                            Entry->Count,
                            Entry->Clean,
                            Entry->Clean * 100 / Entry->Count,
                            Entry->Waiters,
                            Entry->Depth / Entry->Count,
                            Entry->IncreasedDepth,
                            Entry->IncreasedDepth * 100 / Entry->Count,
                            AcquirePoint, (ULONG)AcquireOffset,
                            ReleasePoint, (ULONG)ReleaseOffset);

                } else {
                    dprintf("%3d A %s+0x%x R %s+0x%x\n", 
                            PercentageHeld,
                            AcquirePoint, (ULONG)AcquireOffset,
                            ReleasePoint, (ULONG)ReleaseOffset);
                    dprintf("   HT %I64ld (av %I64ld), WT %I64ld (av %I64ld), C %d, CA %d (%d%%) WC %d, (avD %d) ID %d (%d%%)\n",
                            Entry->Time,
                            Entry->Time / Entry->Count,
                            Entry->WaitTime,
                            Entry->WaitTime / Entry->Count,
                            Entry->Count,
                            Entry->Clean,
                            Entry->Clean * 100 / Entry->Count,
                            Entry->Waiters,
                            Entry->Depth / Entry->Count,
                            Entry->IncreasedDepth,
                            Entry->IncreasedDepth * 100 / Entry->Count);
                    dprintf("\n");
                }
            }
        }
    }

outtahere:
    if (LockHome) {
        LocalFree(LockHome);
    }
    if (LockData) {
        LocalFree(LockData);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\queue.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       queue.c
//
//  Contents:   Extension to dump the ExWorkerQueues
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:
//
//  History:    5-04-1998   benl   Created
//
//----------------------------------------------------------------------------


#include "precomp.h"
#pragma hdrstop



//+---------------------------------------------------------------------------
//
//  Function:   DumpQueue
//
//  Synopsis: Dumps a KQUEUE from its address
//
//  Arguments:  [iAddress] -- address of queue
//
//  Returns:
//
//  History:    4-29-1998   benl   Created
//
//  Notes: Assumes the items on the queue are of WORK_QUEUE_ITEM form
//         If this ever extended to dump arbitrary queues that assumption
//         will have to be dropped
//
//----------------------------------------------------------------------------

VOID DumpQueue(ULONG64 iAddress, ULONG dwProcessor, ULONG Flags)
{
    DWORD           dwRead;
    UCHAR           szSymbol[0x100];
    ULONG64         dwDisp;
    ULONG64         iNextAddr;
    ULONG64         iThread;
    ULONG64         pThread;
    ULONG           CurrentCount, MaximumCount, Off;
    ULONG           queueOffset;

    if (GetFieldValue(iAddress, "nt!_KQUEUE", "CurrentCount", CurrentCount))
    {
        dprintf("ReadMemory for queue at %p failed\n", iAddress );
        return;
    }
    GetFieldValue(iAddress, "nt!_KQUEUE", "MaximumCount",MaximumCount);
//    dprintf("EntryListHead: 0x%x 0x%x\n", Queue.EntryListHead.Flink,
//            Queue.EntryListHead.Blink);
    dprintf("( current = %u", CurrentCount);
    dprintf(" maximum = %u )\n", MaximumCount);

    if (CurrentCount >= MaximumCount) {
        
        dprintf("WARNING: active threads = maximum active threads in the queue. No new\n"
                "  workitems schedulable in this queue until they finish or block.\n");
    }

    //print threads
    GetFieldValue(iAddress, "nt!_KQUEUE", "ThreadListHead.Flink", iThread);
    GetFieldOffset("nt!_KQUEUE", "ThreadListHead", &Off);
    GetFieldOffset("nt!_KTHREAD", "QueueListEntry", &queueOffset);
    while (iThread != iAddress + Off)
    {
        ULONG64 Flink;

        if (GetFieldValue(iThread, "nt!_LIST_ENTRY", "Flink", Flink))
        {
            dprintf("ReadMemory for threadqueuelist at %p failed\n", iThread);
            return;
        }

        pThread = iThread - queueOffset;

        DumpThread( dwProcessor, "", pThread, Flags);
        
        if (CheckControlC())
        {
            return;
        }
        iThread = (Flink);
    }
    dprintf("\n");

    //print queued items
    GetFieldValue(iAddress, "nt!_KQUEUE", "EntryListHead.Flink", iNextAddr);
    GetFieldOffset("nt!_KQUEUE", "EntryListHead", &Off);
    while (iNextAddr != iAddress + Off)
    {
        ULONG64 WorkerRoutine, Parameter;
        iThread = 0;

        if (GetFieldValue(iNextAddr, "nt!_WORK_QUEUE_ITEM", "WorkerRoutine",WorkerRoutine))
        {
            dprintf("ReadMemory for entry at %p failed\n", iNextAddr);
            return;
        }

        //try to get the function name
        GetSymbol(WorkerRoutine, szSymbol, &dwDisp);
        GetFieldValue(iNextAddr, "nt!_WORK_QUEUE_ITEM", "Parameter",Parameter);
        if (dwDisp) {
            dprintf("PENDING: WorkerRoutine %s+0x%p (%p) Parameter %p\n",
                    szSymbol, WorkerRoutine, dwDisp, Parameter);
        } else {
            dprintf("PENDING: WorkerRoutine %s (%p) Parameter %p\n",
                    szSymbol, WorkerRoutine, Parameter);
        }

        if (CheckControlC())
        {
            return;
        }

        GetFieldValue(iNextAddr, "nt!_WORK_QUEUE_ITEM", "List.Flink", iNextAddr);
    }

    if (!iThread) {
        dprintf("\n");
    }

} // DumpQueue


//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API
//
//  Synopsis:   Dump the ExWorkerQueues
//
//  Arguments:  [dexqueue] --
//
//  Returns:
//
//  History:    4-29-1998   benl   Created
//
//  Notes: Symbols better be correct or this will print garbage
//
//----------------------------------------------------------------------------

DECLARE_API(exqueue)
{
    ULONG64   iExQueue;
    ULONG Flags = 0;
    ULONG n;
    ULONG dwProcessor=0;
    
    INIT_API();
    GetCurrentProcessor(Client, &dwProcessor, NULL);

    //
    //  Flags == 2 apes the default behavior of just printing out thread state.
    //
    
    if (args) {
        Flags = (ULONG)GetExpression(args);
     }

    iExQueue = GetExpression("NT!ExWorkerQueue");
    dprintf("Dumping ExWorkerQueue: %P\n\n", iExQueue);
    if (iExQueue)
    {
        if (!(Flags & 0xf0) || (Flags & 0x10)) {
            dprintf("**** Critical WorkQueue");
            DumpQueue(iExQueue, dwProcessor, Flags & 0xf);
        }
        if (!(Flags & 0xf0) || (Flags & 0x20)) {
            dprintf("**** Delayed WorkQueue");
            DumpQueue(iExQueue + GetTypeSize("nt!_EX_WORK_QUEUE"), dwProcessor, Flags & 0xf);
        }
        if (!(Flags & 0xf0) || (Flags & 0x40)) {
            dprintf("**** HyperCritical WorkQueue");
            DumpQueue(iExQueue + 2 * GetTypeSize("nt!_EX_WORK_QUEUE"), dwProcessor, Flags & 0xf);
        }
    }

    EXIT_API();
    return S_OK;
} // DECLARE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\session.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    session.hxx

Abstract:

    This file declares routines to handle sessions.

Author:

    Jason Hartman (JasonHa) 2000-12-21

Environment:

    User Mode

--*/

#ifndef _SESSION_H_
#define _SESSION_H_


#define CURRENT_SESSION -1
#define DEFAULT_SESSION -2
#define INVALID_SESSION -3

typedef HRESULT (* PoolFilterFunc)(
    ULONG64 PoolAddr,
    ULONG TagFilter,
    ULONG64 PoolHeader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    );


typedef struct _ALLOCATION_STATS {
    ULONG AllocatedPages;
    ULONG LargePages;
    ULONG LargeAllocs;
    ULONG FreePages;
    ULONG ExpansionPages;
    ULONG Allocated;                // Number of allocated entries
    ULONG AllocatedSize;            // Size in Pool Blocks
    ULONG Free;                     // Number of free entries
    ULONG FreeSize;                 // Size in Pool Blocks
    ULONG Indeterminate;            // Number of entries with interdeterminable alloc/free status
    ULONG IndeterminateSize;        // Size in Pool Blocks
} ALLOCATION_STATS, *PALLOCATION_STATS;


extern ULONG   SessionId;
extern CHAR    SessionStr[16];


void SessionInit(PDEBUG_CLIENT Client);
void SessionExit();


HRESULT
GetSessionPhysicalAddress(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG64 VirtAddr,
    PULONG64 PhysAddr
    );


HRESULT
GetCurrentSession(
    PULONG64 CurSessionSpace,
    PULONG CurSessionId
    );


HRESULT
GetSessionSpace(
    ULONG Session,
    PULONG64 SessionSpace,
    PULONG64 SessionProcess
    );



#define SEARCH_POOL_NONPAGED        0x0001
#define SEARCH_POOL_PAGED           0x0002
#define SEARCH_POOL_LARGE_ONLY      0x0004
#define SEARCH_POOL_PRINT_LARGE     0x0008
#define SEARCH_POOL_PRINT_UNREAD    0x0010

#define INVALID_UNIQUE_STATE    0

HRESULT
SearchSessionPool(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG TagName,
    FLONG Flags,
    ULONG64 RestartAddr,
    PoolFilterFunc Filter,
    PALLOCATION_STATS AllocStats,
    PVOID Context
    );


#endif  _SESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\remlock.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    remlock.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Peter Wieland
    Kenneth Ray

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "precomp.h"
//#include <nt.h>
//#include <ntos.h>
//#include <io.h>

//
// From remlock.h
//
#define IO_REMOVE_LOCK_SIG     'COLR'

/*
typedef struct FULL_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
} FULL_REMOVE_LOCK;
*/
typedef union _REMLOCK_FLAGS {

    struct {
        ULONG   Checked: 1;
        ULONG   Filler: 31;
    };

    ULONG Raw;

} REMLOCK_FLAGS;



DECLARE_API ( remlock )

/*++

Routine Description:

   Dump a remove lock structure

--*/
{
    ULONG64 memLoc=0;
    UCHAR   buffer[256];
    ULONG   result;
    ULONG64 blockLoc;
    UCHAR   allocateTag[8];
    REMLOCK_FLAGS flags;
//    FULL_REMOVE_LOCK fullLock;
//    IO_REMOVE_LOCK_DBG_BLOCK dbgLock;
//    IO_REMOVE_LOCK_COMMON_BLOCK commonLock;
//    IO_REMOVE_LOCK_TRACKING_BLOCK  block;
    ULONG64 pDbgLock = 0;
    ULONG64 pCommonLock;
    ULONG64 pBlock;
    ULONG   IoCount, Removed, Signature;
    
    buffer[0] = '\0';

    if (!*args) {
        memLoc = EXPRLastDump;
    } else {
        if (GetExpressionEx(args, &memLoc, &args)) {
            if (StringCchCopy(buffer, sizeof(buffer), args) != S_OK)
            {
                buffer[0] = 0;
            }
        }
    }

    flags.Raw = 0;
    if ('\0' != buffer[0]) {
        flags.Raw = (ULONG) GetExpression(buffer);
    }

    dprintf ("Dump Remove Lock: %I64x %x ", memLoc, flags.Raw);

    if (flags.Checked) {
        ULONG Sz = GetTypeSize("IO_REMOVE_LOCK_COMMON_BLOCK");

        dprintf ("as Checked\n");

        pCommonLock = memLoc; pDbgLock = memLoc + Sz;

        if (GetFieldValue (pCommonLock, "IO_REMOVE_LOCK_COMMON_BLOCK", 
                           "Removed", Removed) ||
            GetFieldValue (pDbgLock, "IO_REMOVE_LOCK_DBG_BLOCK", 
                           "Signature", Signature)) {
            dprintf ("Could not read memLock extension\n");
            return E_INVALIDARG;
        }

        if (IO_REMOVE_LOCK_SIG != Signature) {
            dprintf ("Signature does not match that of a remove lock\n");
            return E_INVALIDARG;
        }

    } else {
        dprintf ("as Free\n");
        pCommonLock = memLoc;
        if (GetFieldValue (memLoc, "IO_REMOVE_LOCK_COMMON_BLOCK", 
                           "Removed", Removed)) {
            dprintf ("Could not read memLock extension\n");
            return E_INVALIDARG;
        }
    }


    GetFieldValue (pCommonLock, "IO_REMOVE_LOCK_COMMON_BLOCK", "IoCount", IoCount);
    dprintf ("IsRemoved %x, IoCount %x\n", Removed, IoCount);

    if (flags.Checked && pDbgLock) { // checked
        SYM_DUMP_PARAM sym = { 0 };

        sym.sName = (PUCHAR) "PCHAR";
        sym.size = sizeof(sym);

        InitTypeRead(pDbgLock, IO_REMOVE_LOCK_DBG_BLOCK);
        allocateTag [4] = '\0';
        * (PULONG) allocateTag = (ULONG) ReadField(AllocateTag);

        dprintf ("HighWatermark %x, MaxLockedTicks %I64x, AllocateTag %s \n",
                 (ULONG) ReadField(HighWatermark),
                 ReadField(MaxLockedTicks),
                 allocateTag);

        blockLoc = ReadField(Blocks);
        while (blockLoc) {
            ULONG offset = 0;

            InitTypeRead(blockLoc, _IO_REMOVE_LOCK_TRACKING_BLOCK);

            dprintf ("Block Tag %p Line %d TimeLock %I64d\n",
                     ReadField(Tag),
                     (ULONG) ReadField(Line),
                     ReadField(TimeLocked));

            //
            // Using ReadField(File) returns the wrong pointer.  I need a pointer
            // to the pointer value, so we must use the field offset
            //
            if (!GetFieldOffset("_IO_REMOVE_LOCK_TRACKING_BLOCK", "File", &offset)) {
                dprintf("   File ");
                sym.addr = blockLoc + offset; 
                Ioctl(IG_DUMP_SYMBOL_INFO, &sym, sym.size);
            }

            blockLoc = ReadField(Link);
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\session.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    session.cxx

Abstract:

    This file contains the routines to handle session.

Author:

    Jason Hartman (JasonHa) 2000-09-28

Environment:

    User Mode

--*/

#include "precomp.h"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//
// Special defines
//

// ddk\inc\ntddk.h:
#define PROTECTED_POOL          0x80000000

// base\ntos\inc\pool.h:
#define POOL_QUOTA_MASK         8


// Information about how to handle a process listing
// and status about how it was handled.
class CProcessListing
{
public:
    IN ULONG m_cListLimit;
    IN OUT ULONG m_cTotal;
    IN OUT ULONG m_cProcessed;
    IN OUT ULONG64 m_oStartProcess;
    OUT ULONG64 m_oLastProcess;

public:
    CProcessListing(ULONG cListLimit = -1) {
        m_cListLimit = cListLimit;
        m_cTotal = 0;
        m_cProcessed = 0;
        m_oStartProcess = 0;
        m_oLastProcess = 0;
    }

    void PrepareForNextListing()
    {
        m_oStartProcess = m_oLastProcess;
    }

    BOOL Unprocessed()
    {
        return (m_cTotal > m_cProcessed);
    }
};


#define SESSION_SEARCH_LIMIT    50

ULONG   SessionId = CURRENT_SESSION;
CHAR    SessionStr[16] = "CURRENT";

CachedType  HwPte = { FALSE, "NT!HARDWARE_PTE", 0, 0, 0 };

#define NUM_CACHED_SESSIONS 8

struct {
    BOOL    Valid;
    ULONG64 SessionSpaceAddr;
    ULONG64 SessionProcess;
} CachedSession[NUM_CACHED_SESSIONS+1] = { { 0, 0 } };
ULONG ExtraCachedSessionId;

#define NUM_CACHED_DIR_BASES    8

struct {
    BOOL    Valid;
    ULONG64 PageDirBase;
} CachedDirBase[NUM_CACHED_DIR_BASES+1] = { { FALSE, 0} };


struct {
    BOOL    Valid;
    ULONG64 PhysAddr;
    ULONG64 Data;
} CachedPhysAddr[2] = { { 0, 0, 0} };

class BitFieldInfo {
public:
    BitFieldInfo() { Valid = FALSE; };
    BitFieldInfo(ULONG InitBitPos, ULONG InitBits) {
        Valid = Compose(InitBitPos, InitBits);
    }

    BOOL Compose(ULONG CBitPos, ULONG CBits)
    {
        BitPos = CBitPos;
        Bits = CBits;
        Mask = (((((ULONG64) 1) << Bits) - 1) << BitPos);
        return TRUE;
    }

    BOOL    Valid;
    ULONG   BitPos;
    ULONG   Bits;
    ULONG64 Mask;
};

BitFieldInfo *MMPTEValid = NULL;
BitFieldInfo *MMPTEProto = NULL;
BitFieldInfo *MMPTETrans = NULL;
BitFieldInfo *MMPTEX86LargePage = NULL;
BitFieldInfo *MMPTEpfn = NULL;

HRESULT
GetBitMap(
    PDEBUG_CLIENT Client,
    ULONG64 pBitMap,
    PRTL_BITMAP *pBitMapOut
    );

HRESULT
FreeBitMap(
    PRTL_BITMAP pBitMap
    );

HRESULT
OutputSessionProcesses(
    PDEBUG_CLIENT Client,
    ULONG Session,
    PCSTR args,
    CProcessListing *pProcessListing
    );


/**************************************************************************\
*
* Routine Name:
*
*   SessionInit
*
* Routine Description:
*
*   Initialize or reinitialize information to be read from symbols files
*
* Arguments:
*
*   Client - PDEBUG_CLIENT
*
* Return Value:
*
*   none
*
\**************************************************************************/

void SessionInit(PDEBUG_CLIENT Client)
{
    for (int s = 0; s < sizeof(CachedSession)/sizeof(CachedSession[0]); s++)
    {
        CachedSession[s].Valid = FALSE;
    }
    ExtraCachedSessionId = INVALID_SESSION;

    for (int s = 0; s < sizeof(CachedDirBase)/sizeof(CachedDirBase[0]); s++)
    {
        CachedDirBase[s].Valid = INVALID_UNIQUE_STATE;
    }

    if (MMPTEValid != NULL) MMPTEValid->Valid = FALSE;
    if (MMPTEProto != NULL) MMPTEProto->Valid = FALSE;
    if (MMPTETrans != NULL) MMPTETrans->Valid = FALSE;
    if (MMPTEX86LargePage != NULL) MMPTEX86LargePage->Valid = FALSE;
    if (MMPTEpfn != NULL) MMPTEpfn->Valid = FALSE;

    CachedPhysAddr[0].Valid = FALSE;
    CachedPhysAddr[1].Valid = FALSE;

    return;
}


/**************************************************************************\
*
* Routine Name:
*
*   SessionExit
*
* Routine Description:
*
*   Clean up any outstanding allocations or references
*
* Arguments:
*
*   none
*
* Return Value:
*
*   none
*
\**************************************************************************/

void SessionExit()
{
    if (MMPTEValid != NULL)
    {
        delete MMPTEValid;
        MMPTEValid = NULL;
    }

    if (MMPTEProto != NULL)
    {
        delete MMPTEProto;
        MMPTEProto = NULL;
    }

    if (MMPTETrans != NULL)
    {
        delete MMPTETrans;
        MMPTETrans = NULL;
    }

    if (MMPTEX86LargePage != NULL)
    {
        delete MMPTEX86LargePage;
        MMPTEX86LargePage = NULL;
    }

    if (MMPTEpfn != NULL)
    {
        delete MMPTEpfn;
        MMPTEpfn = NULL;
    }

    return;
}

#if 0
/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEValid
*
* Routine Description:
*
*   Extract Valid value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEValid(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 Valid
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTEValid == NULL)
    {
        MMPTEValid = new BitFieldInfo;
    }

    if (MMPTEValid == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEValid->Valid)
    {
        hr = S_OK;
    }
    else
    {
        ULONG        VaildOffset, ValidBits;

        if (GetBitFieldOffset("nt!HARDWARE_PTE", "Valid", &VaildOffset, &ValidBits) == S_OK)
        {
            MMPTEValid->Valid = MMPTEValid->Compose(VaildOffset, ValidBits);
            hr = MMPTEValid->Valid ? S_OK : S_FALSE;
        }
    }

    if (Valid != NULL)
    {
        if (hr == S_OK)
        {
            *Valid = (MMPTE64 & MMPTEValid->Mask) >> MMPTEValid->BitPos;
        }
        else
        {
            *Valid = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEProto
*
* Routine Description:
*
*   Extract Prototype value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEProto(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 Proto
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTEProto == NULL)
    {
        MMPTEProto = new BitFieldInfo;
    }

    if (MMPTEProto == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEProto->Valid)
    {
        hr = S_OK;
    }
    else
    {
        ULONG       ProtoOffset, ProtoBits;

        if (GetBitFieldOffset("nt!MMPTE_PROTOTYPE", "Prototype", &ProtoOffset, &ProtoBits) == S_OK)
        {
            MMPTEProto->Valid = MMPTEProto->Compose(ProtoOffset, ProtoBits);
            hr = MMPTEProto->Valid ? S_OK : S_FALSE;
        }
    }

    if (Proto != NULL)
    {
        if (hr == S_OK)
        {
            *Proto = (MMPTE64 & MMPTEProto->Mask) >> MMPTEProto->BitPos;
        }
        else
        {
            *Proto = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTETrans
*
* Routine Description:
*
*   Extract Transition value from MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTETrans(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 Trans
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTETrans == NULL)
    {
        MMPTETrans = new BitFieldInfo;
    }

    if (MMPTETrans == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTETrans->Valid)
    {
        hr = S_OK;
    }
    else
    {
        ULONG       TransOffset, TransBits;

        if (GetBitFieldOffset("nt!MMPTE_PROTOTYPE", "Transition", &TransOffset, &TransBits) == S_OK)
        {
            MMPTETrans->Valid = MMPTETrans->Compose(TransOffset, TransBits);

            hr = MMPTETrans->Valid ? S_OK : S_FALSE;
        }
    }

    if (Trans != NULL)
    {
        if (hr == S_OK)
        {
            *Trans = (MMPTE64 & MMPTETrans->Mask) >> MMPTETrans->BitPos;
        }
        else
        {
            *Trans = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEX86LargePage
*
* Routine Description:
*
*   Extract LargePage value from X86 MMPTE
*
\**************************************************************************/

HRESULT
GetMMPTEX86LargePage(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 X86LargePage
    )
{
    HRESULT hr = S_FALSE;

    if (TargetMachine != IMAGE_FILE_MACHINE_I386)
    {
        if (X86LargePage != NULL) *X86LargePage = 0;
        return hr;
    }

    if (MMPTEX86LargePage == NULL)
    {
        MMPTEX86LargePage = new BitFieldInfo;
    }

    if (MMPTEX86LargePage == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEX86LargePage->Valid)
    {
        hr = S_OK;
    }
    else
    {
        ULONG      LrPgOffset, LrPgBits;

        if (GetBitFieldOffset("nt!HARDWARE_PTE", "LargePage", &LrPgOffset, &LrPgBits) == S_OK)
        {
            MMPTEX86LargePage->Valid = MMPTEX86LargePage->Compose(LrPgOffset, LrPgBits);
            hr = MMPTEX86LargePage->Valid ? S_OK : S_FALSE;
        }
    }

    if (X86LargePage != NULL)
    {
        if (hr == S_OK)
        {
            *X86LargePage = (MMPTE64 & MMPTEX86LargePage->Mask) >> MMPTEX86LargePage->BitPos;
        }
        else
        {
            *X86LargePage = 0;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Routine Name:
*
*   GetMMPTEpfn
*
* Routine Description:
*
*   Extract Page Frame Number value from MMPTE
*
\**************************************************************************/
#define GET_BITS_UNSHIFTED      1
HRESULT
GetMMPTEpfn(
    PDEBUG_CLIENT Client,
    ULONG64 MMPTE64,
    PULONG64 pfn,
    FLONG Flags
    )
{
    HRESULT hr = S_FALSE;

    if (MMPTEpfn == NULL)
    {
        MMPTEpfn = new BitFieldInfo;
    }

    if (MMPTEpfn == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else if (MMPTEpfn->Valid)
    {
        hr = S_OK;
    }
    else
    {
        ULONG          pfnPosition, pfnBits;

        if (GetBitFieldOffset("nt!HARDWARE_PTE", "PageFrameNumber", &pfnPosition, &pfnBits) == S_OK)
        {
            MMPTEpfn->Valid = MMPTEpfn->Compose(pfnPosition, pfnBits);
            hr = MMPTEpfn->Valid ? S_OK : S_FALSE;
        }
    }

    if (pfn != NULL)
    {
        if (hr == S_OK)
        {
            *pfn = (MMPTE64 & MMPTEpfn->Mask);
            if (!(Flags & GET_BITS_UNSHIFTED))
            {
                *pfn >>= MMPTEpfn->BitPos;
            }
        }
        else
        {
            *pfn = 0;
        }
    }

    return hr;
}
#endif // 0
// Copied from nt\base\ntos\rtl\bitmap.c

static CONST ULONG FillMaskUlong[] = {
    0x00000000, 0x00000001, 0x00000003, 0x00000007,
    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
    0xffffffff
};

ULONG
OSCompat_RtlFindLastBackwardRunClear (
    IN PRTL_BITMAP BitMapHeader,
    IN ULONG FromIndex,
    IN PULONG StartingRunIndex
    )
{
    ULONG Start;
    ULONG End;
    PULONG PHunk;
    ULONG Hunk;

    //
    //  Take care of the boundary case of the null bitmap
    //

    if (BitMapHeader->SizeOfBitMap == 0) {

        *StartingRunIndex = FromIndex;
        return 0;
    }

    //
    //  Scan backwards for the first clear bit
    //

    End = FromIndex;

    //
    //  Build pointer to the ULONG word in the bitmap
    //  containing the End bit, then read in the bitmap
    //  hunk. Set the rest of the bits in this word, NOT
    //  inclusive of the FromIndex bit.
    //

    PHunk = BitMapHeader->Buffer + (End / 32);
    Hunk = *PHunk | ~FillMaskUlong[(End % 32) + 1];

    //
    //  If the first subword is set then we can proceed to
    //  take big steps in the bitmap since we are now ULONG
    //  aligned in the search
    //

    if (Hunk == (ULONG)~0) {

        //
        //  Adjust the pointers backwards
        //

        End -= (End % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)~0) break;

            PHunk--;
            End -= 32;
        }
    }

    //
    //  Bitwise search backward for the clear bit
    //

    while ((End != MAXULONG) && (RtlCheckBit( BitMapHeader, End ) == 1)) { End -= 1; }

    //
    //  Scan backwards for the first set bit
    //

    Start = End;

    //
    //  We know that the clear bit was in the last word we looked at,
    //  so continue from there to find the next set bit, clearing the
    //  previous bits in the word.
    //

    Hunk = *PHunk & FillMaskUlong[Start % 32];

    //
    //  If the subword is unset then we can proceed in big steps
    //

    if (Hunk == (ULONG)0) {

        //
        //  Adjust the pointers backward
        //

        Start -= (Start % 32) + 1;
        PHunk--;

        while ( PHunk > BitMapHeader->Buffer ) {

            //
            //  Stop at first word with set bits
            //

            if (*PHunk != (ULONG)0) break;

            PHunk--;
            Start -= 32;
        }
    }

    //
    //  Bitwise search backward for the set bit
    //

    while ((Start != MAXULONG) && (RtlCheckBit( BitMapHeader, Start ) == 0)) { Start -= 1; }

    //
    //  Compute the index and return the length
    //

    *StartingRunIndex = Start + 1;
    return (End - Start);
}

HRESULT
GetSessionNumbers(
    IN PDEBUG_CLIENT Client,
    OUT PULONG CurrentSession,
    OUT PULONG DefaultSession,
    OUT PULONG TotalSessions,
    OUT PRTL_BITMAP *SessionList
    )
{
    HRESULT hr = S_FALSE;

    if (CurrentSession != NULL)
    {
        ULONG Processor;
        ULONG64 Process=0;

        Process = GetExpression("@$Proc");

        if (!Process || !GetProcessSessionId(Process,  CurrentSession))
        {
            *CurrentSession = INVALID_SESSION;
        } else
        {
            hr = S_OK;
        }
    }

    if (DefaultSession != NULL)
    {
        *DefaultSession = SessionId;
        hr = S_OK;
    }

    if ((TotalSessions != NULL) ||
        (SessionList != NULL))
    {
        ULONG   SessionCount = 0;
        PRTL_BITMAP SessionListBitMap = NULL;
        ULONG64 SessionIdListPointerAddr = 0;
        ULONG64 SessionIdListAddr = 0;

        PDEBUG_SYMBOLS      Symbols;
        PDEBUG_DATA_SPACES  Data;

        if (TotalSessions)
        {
            *TotalSessions = 0;
        }
        if (SessionList)
        {
            *SessionList = NULL;
        }

        if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&Symbols)) != S_OK)
        {
            return hr;
        }

        if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&Data)) != S_OK)
        {
            Symbols->Release();
            return hr;
        }

        CHAR PointerName[] = "NT!MiSessionIdBitmap";
        hr = Symbols->GetOffsetByName(PointerName, &SessionIdListPointerAddr);
        if (hr != S_OK)
        {
            ExtErr("Unable to locate %s\n", PointerName);
        }
        else
        {
            hr = Data->ReadPointersVirtual(1, SessionIdListPointerAddr, &SessionIdListAddr);

            if ((hr == S_OK) && (SessionIdListAddr != 0))
            {
                hr = GetBitMap(Client, SessionIdListAddr, &SessionListBitMap);

                if (hr == S_OK)
                {
                    SessionCount = RtlNumberOfSetBits(SessionListBitMap);
                }
            } else
            {
                ExtErr("Unable to read MiSessionIdBitmap @ %p\n", SessionIdListPointerAddr);
            }
        }

        if (TotalSessions)
        {
            *TotalSessions = SessionCount;
        }

        // Free or return BitMap
        if (SessionListBitMap)
        {
            if (SessionList)
            {
                *SessionList = SessionListBitMap;
            }
            else
            {
                FreeBitMap(SessionListBitMap);
            }
        }

        Data->Release();
        Symbols->Release();
    }

    return hr;
}


HRESULT
SetDefaultSession(
    IN PDEBUG_CLIENT Client,
    IN ULONG NewSession,
    OUT OPTIONAL PULONG OldSession
    )
{
    HRESULT hr = S_FALSE;
    ULONG64 SessionProcess;
    ULONG   PrevSession;

    GetSessionNumbers(Client, NULL, &PrevSession, NULL, NULL);

    if (OldSession)
    {
        *OldSession = PrevSession;
    }
    if ((NewSession == CURRENT_SESSION) ||
        (GetSessionSpace(NewSession, NULL, &SessionProcess) == S_OK))
    {
        if (GetProcessSessionId(SessionProcess, &SessionId) &&
            (SessionId != PrevSession))
        {
            CHAR SetImplicitProcess[100];

            hr = StringCbPrintfA(SetImplicitProcess, sizeof(SetImplicitProcess),
                                 ".process %p", SessionProcess);
            if (hr == S_OK)
            {
                hr = g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,
                                           SetImplicitProcess, DEBUG_EXECUTE_DEFAULT );
            }
            if (SessionId == CURRENT_SESSION)
            {
                strcpy(SessionStr, "CURRENT");
            }
            else
            {
                _ultoa(SessionId, SessionStr, 10);
            }

        }

        hr = S_OK;
    }

    return hr;
}

typedef (WINAPI* PENUM_SESSION_CB)(ULONG64 Process, ULONG SessionId, PVOID Context);

BOOL
EnumerateSessionProcesses(
    IN ULONG Session,
    IN PVOID Context,
    IN PENUM_SESSION_CB Callback
    )
{
    ULONG TotalSessions;
    ULONG WsListEntryOffset;
    ULONG SessionOffset;
    ULONG SessionProcessLinksOffset;
    ULONG64 MiSessionWsList;
    ULONG64 SessionWsListStart;
    ULONG64 Next;
    ULONG64 SessionSpace;
    ULONG SessionId;

    MiSessionWsList = GetExpression("nt!MiSessionWsList");
    if (!MiSessionWsList || !ReadPointer(MiSessionWsList, &SessionWsListStart))
    {
        dprintf("Cannot get nt!MiSessionWsList\n");
        return FALSE;
    }

    if (GetFieldOffset("nt!_MM_SESSION_SPACE", "WsListEntry", &WsListEntryOffset) ||
        GetFieldOffset("nt!_MM_SESSION_SPACE", "Session", &SessionOffset))
    {
        dprintf("Cannot find nt!_MM_SESSION_SPACE type.\n");
        return FALSE;
    }

    if (GetFieldOffset("nt!_EPROCESS", "SessionProcessLinks", &SessionProcessLinksOffset))
    {
        dprintf("Cannot find nt!_EPROCESS type.\n");
        return FALSE;
    }

    SessionSpace = SessionWsListStart-WsListEntryOffset;

    do
    {
        if (GetFieldValue(SessionSpace, "nt!_MM_SESSION_SPACE", "SessionId", SessionId) ||
            !ReadPointer(SessionSpace+WsListEntryOffset, &Next) ||
            InitTypeRead(SessionSpace, nt!_MM_SESSION_SPACE) )
        {
            dprintf("Cannot read nt!_MM_SESSION_SPACE @ %p\n", SessionSpace);
            return FALSE;
        }

        if (CheckControlC())
        {
            break;
        }

        if (Session == SessionId || Session == -1)
        {
            ULONG64 SessionProcessList = ReadField(ProcessList.Flink);
            ULONG64 NextProcess = 0;
            ULONG64 Process;
            CHAR    ImageFileName[64];

            Process = SessionProcessList - SessionProcessLinksOffset;
            if (!ReadPointer(SessionProcessList, &NextProcess))
            {
                dprintf("Cannot read memory SessionProcessLinks for rocess %p\n", Process);
                NextProcess = 0;
                break;
            }
            while (NextProcess && NextProcess != SessionProcessList)
            {
                if (CheckControlC())
                {
                    break;
                }

                (*Callback)(Process, SessionId, Context);

                Process = NextProcess - SessionProcessLinksOffset;
                if (!ReadPointer(NextProcess, &NextProcess))
                {
                    dprintf("Cannot read memory SessionProcessLinks for rocess %p\n", Process);
                    break;
                }
            }
        }
        SessionSpace = Next - WsListEntryOffset;
    } while (Next && (Next != MiSessionWsList));
    return TRUE;
}


BOOL
DumpSessionInfo(
    IN ULONG Flags,
    IN ULONG SessionIdToDump,
    IN PCHAR ProcessName
    )
{
    ULONG TotalSessions;
    ULONG WsListEntryOffset;
    ULONG SessionOffset;
    ULONG SessionProcessLinksOffset;
    ULONG64 MiSessionWsList;
    ULONG64 SessionWsListStart;
    ULONG64 Next;
    ULONG64 SessionSpace;
    ULONG CurrentSessionId;
    PCHAR Pad = "    ";

    if (SessionIdToDump == DEFAULT_SESSION)
    {
        SessionId = SessionId;
    }

    if (!(Flags & 1) && (SessionIdToDump == CURRENT_SESSION))
    {
        GetCurrentSession(&SessionSpace, &SessionIdToDump);
    }

    if (SessionIdToDump != -1)
    {
        dprintf("Dumping Session %lx\n", SessionIdToDump);
        Pad = "";
    }
    else
    {
        PRTL_BITMAP pSessionIdBitmap;
        ULONG Id;

        pSessionIdBitmap = GetBitmap(GetPointerValue("nt!MiSessionIdBitmap"));

        TotalSessions = 0;
        if (pSessionIdBitmap)
        {
            for (Id = 0; Id < pSessionIdBitmap->SizeOfBitMap; ++Id)
            {
                if (RtlCheckBit(pSessionIdBitmap, Id))
                {
                    TotalSessions++;
                }
            }
            HeapFree( GetProcessHeap(), 0, pSessionIdBitmap );
        }

        if (TotalSessions)
        {
            dprintf("Total sessions : %lx\n", TotalSessions);
        } else
        {
            // GetPointerValue already printed error, We might still be able to get
            // MiSessionWsList so continue
        }
    }

    MiSessionWsList = GetExpression("nt!MiSessionWsList");
    if (!MiSessionWsList || !ReadPointer(MiSessionWsList, &SessionWsListStart))
    {
        dprintf("Cannot get nt!MiSessionWsList\n");
        return FALSE;
    }

    if (GetFieldOffset("nt!_MM_SESSION_SPACE", "WsListEntry", &WsListEntryOffset) ||
        GetFieldOffset("nt!_MM_SESSION_SPACE", "Session", &SessionOffset))
    {
        dprintf("Cannot find nt!_MM_SESSION_SPACE type.\n");
        return FALSE;
    }

    if (GetFieldOffset("nt!_EPROCESS", "SessionProcessLinks", &SessionProcessLinksOffset))
    {
        dprintf("Cannot find nt!_EPROCESS type.\n");
        return FALSE;
    }

    SessionSpace = SessionWsListStart-WsListEntryOffset;

    do
    {
        if (GetFieldValue(SessionSpace, "nt!_MM_SESSION_SPACE", "SessionId", CurrentSessionId) ||
            !ReadPointer(SessionSpace+WsListEntryOffset, &Next) ||
            InitTypeRead(SessionSpace, nt!_MM_SESSION_SPACE) )
        {
            dprintf("Cannot read nt!_MM_SESSION_SPACE @ %p\n", SessionSpace);
            return FALSE;
        }

        if (CheckControlC())
        {
            break;
        }

        if (SessionIdToDump == CurrentSessionId || SessionIdToDump == -1)
        {
            // Dump Session
            dprintf("\n");
            if (SessionIdToDump == -1)
            {
                dprintf("%sSession           %lx\n", Pad, CurrentSessionId);
            }
            dprintf("%s_MM_SESSION_SPACE %p\n", Pad, SessionSpace);
            dprintf("%s_MMSESSION        %p\n", Pad, SessionSpace+SessionOffset);
            if (Flags & 2)
            {
                // Dump Process in the session
                ULONG64 SessionProcessList = ReadField(ProcessList.Flink);
                ULONG64 NextProcess = 0;
                ULONG64 Process;
                CHAR    ImageFileName[64];

                Process = SessionProcessList - SessionProcessLinksOffset;
                if (!ReadPointer(SessionProcessList, &NextProcess))
                {
                    dprintf("Cannot read memory SessionProcessLinks for rocess %p\n", Process);
                    NextProcess = 0;
                    break;
                }
                while (NextProcess && NextProcess != SessionProcessList)
                {
                    if (CheckControlC())
                    {
                        break;
                    }

                    ZeroMemory(ImageFileName, sizeof(ImageFileName));

                    if (ProcessName && *ProcessName)
                    {
                        if (!GetFieldValue(Process, "nt!_EPROCESS", "ImageFileName", ImageFileName) &&
                            !_stricmp(ImageFileName, ProcessName))
                        {
                            DumpProcess(Pad, Process, Flags >> 2, NULL);
                        }
                    } else
                    {
                        DumpProcess(Pad, Process, Flags >> 2, NULL);
                    }

                    Process = NextProcess - SessionProcessLinksOffset;
                    if (!ReadPointer(NextProcess, &NextProcess))
                    {
                        dprintf("Cannot read memory SessionProcessLinks for rocess %p\n", Process);
                        break;
                    }
                }
            }
        }
        SessionSpace = Next - WsListEntryOffset;
    } while (Next && (Next != MiSessionWsList));
    return TRUE;
}


HRESULT
GetCurrentSession(
    PULONG64 CurSessionSpace,
    PULONG CurSessionId
    )
{
    static DEBUG_VALUE  LastSessionSpace = { 0, DEBUG_VALUE_INVALID };
    static DEBUG_VALUE  LastSessionId = { INVALID_SESSION, DEBUG_VALUE_INVALID };
    ULONG64             SessionSpaceAddr;
    HRESULT             hr = S_OK;
    ULONG               CurrentSession;

    if (CurSessionSpace != NULL) *CurSessionSpace = 0;
    if (CurSessionId != NULL) *CurSessionId = INVALID_SESSION;

    // Get the current session space
    if (LastSessionSpace.Type == DEBUG_VALUE_INVALID)
    {
        ULONG               Processor;
        ULONG64             Process=0, Start;
        ULONG               SessionProcessLinksOffset;

        // Get current process
        Process = GetExpression("@$Proc");
        Start = 0;
        GetFieldOffset("nt!_EPROCESS", "SessionProcessLinks", &SessionProcessLinksOffset);

        hr = S_FALSE;
        if (!GetProcessSessionId(Process,  &CurrentSession))
        {
            hr = E_FAIL;
        } else
        {
            hr = GetFieldValue(Process, "nt!_EPROCESS", "Session", SessionSpaceAddr);
        }
        if ((hr != S_OK) || (SessionSpaceAddr == 0))
        {
            // This process doesn't belong to a session, look for a process is 0 session
            hr = GetSessionSpace(0, &SessionSpaceAddr, NULL);
        }
    }

    if (hr == S_OK)
    {
        if (CurSessionSpace != NULL) *CurSessionSpace = SessionSpaceAddr;
        if (CurSessionId != NULL) *CurSessionId = CurrentSession;
    }

    return hr;
}

HRESULT
GetSessionSpace(
    ULONG Session,
    PULONG64 pSessionSpace,
    PULONG64 pSessionProcess
    )
{
    ULONG TotalSessions;
    ULONG WsListEntryOffset;
    ULONG SessionOffset;
    ULONG64 MiSessionWsList;
    ULONG64 SessionWsListStart;
    ULONG64 Next;
    ULONG64 SessionSpace;
    ULONG SessionIdLookup;
    HRESULT hr;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if (Session == CURRENT_SESSION)
    {
        ULONG64 CurSessionSpace;
        ULONG   CurSessionId;

        hr = GetCurrentSession(&SessionSpace, &SessionIdLookup);
        if (hr == S_OK)
        {
            if (pSessionSpace)
            {
                *pSessionSpace = SessionSpace;
            }
            return hr;
        }
    }
    else
    {
        if (Session < NUM_CACHED_SESSIONS)
        {
            if (CachedSession[Session].Valid &&
                CachedSession[Session].SessionSpaceAddr != 0)
            {
                if (pSessionSpace != NULL) *pSessionSpace = CachedSession[Session].SessionSpaceAddr;
                if (pSessionProcess != NULL) *pSessionProcess = CachedSession[Session].SessionProcess;
                return S_OK;
            }
        }
        else if (ExtraCachedSessionId != INVALID_SESSION &&
                 Session == ExtraCachedSessionId)
        {
            if (CachedSession[NUM_CACHED_SESSIONS].Valid &&
                CachedSession[NUM_CACHED_SESSIONS].SessionSpaceAddr != 0)
            {
                if (pSessionSpace != NULL) *pSessionSpace = CachedSession[NUM_CACHED_SESSIONS].SessionSpaceAddr;
                if (pSessionProcess != NULL) *pSessionProcess = CachedSession[NUM_CACHED_SESSIONS].SessionProcess;
                return S_OK;
            }
        }

    }

    MiSessionWsList = GetExpression("nt!MiSessionWsList");
    if (!MiSessionWsList || !ReadPointer(MiSessionWsList, &SessionWsListStart))
    {
        dprintf("Cannot get nt!MiSessionWsList\n");
        return FALSE;
    }

    if (GetFieldOffset("nt!_MM_SESSION_SPACE", "WsListEntry", &WsListEntryOffset) ||
        GetFieldOffset("nt!_MM_SESSION_SPACE", "Session", &SessionOffset))
    {
        dprintf("Cannot find nt!_MM_SESSION_SPACE type.\n");
        return FALSE;
    }

    SessionSpace = SessionWsListStart-WsListEntryOffset;

    do
    {
        if (GetFieldValue(SessionSpace, "nt!_MM_SESSION_SPACE", "SessionId", SessionIdLookup) ||
            !ReadPointer(SessionSpace+WsListEntryOffset, &Next) ||
            InitTypeRead(SessionSpace, nt!_MM_SESSION_SPACE) )
        {
            dprintf("Cannot read nt!_MM_SESSION_SPACE @ %p\n", SessionSpace);
            return FALSE;
        }

        if (CheckControlC())
        {
            break;
        }

        if (Session == SessionIdLookup)
        {
            ULONG   SessionProcessLinksOffset;
            ULONG64 SessionProcessList = ReadField(ProcessList.Flink);

            if (pSessionSpace)
            {
                *pSessionSpace = SessionSpace;
            }
            ExtVerb("Session %ld lookup found Session @ 0x%p.\n",
                    Session, SessionSpace);

            if (GetFieldOffset("nt!_EPROCESS", "SessionProcessLinks", &SessionProcessLinksOffset))
            {
                dprintf("Cannot find nt!_EPROCESS type.\n");
                return E_FAIL;
            }

            if (Session < NUM_CACHED_SESSIONS)
            {
                CachedSession[Session].Valid            = TRUE;
                CachedSession[Session].SessionSpaceAddr = SessionSpace;
                CachedSession[Session].SessionProcess   = SessionProcessList - SessionProcessLinksOffset;
            }
            else
            {
                ExtraCachedSessionId = Session;
                CachedSession[NUM_CACHED_SESSIONS].Valid            = TRUE;
                CachedSession[NUM_CACHED_SESSIONS].SessionSpaceAddr = SessionSpace;
                CachedSession[NUM_CACHED_SESSIONS].SessionProcess   = SessionProcessList - SessionProcessLinksOffset;
            }

            if (pSessionProcess)
            {
                *pSessionProcess = SessionProcessList - SessionProcessLinksOffset;
            }
            return S_OK;
        }
        SessionSpace = Next - WsListEntryOffset;
    } while (Next && (Next != MiSessionWsList));
    return E_FAIL;
}

HRESULT
GetSessionDirBase(
    PDEBUG_CLIENT Client,
    ULONG Session,
    PULONG64 PageDirBase
    )
{
    HRESULT             hr = S_FALSE;
    ULONG64             SessionSpaceOffset;
    ULONG64             Process = -1;
    ULONG               SessionIdCheck;
    ULONG64             dvPageDirBase;
    CHAR                szCommand[MAX_PATH];

    static ULONG        LastSession = -2;
    static ULONG64      LastSessionPageDirBase = 0;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if (Session == LastSession &&
        LastSessionPageDirBase != 0)
    {
        *PageDirBase = LastSessionPageDirBase;
        return S_OK;
    }

    *PageDirBase = 0;

    if ((hr == GetSessionSpace(Session, &SessionSpaceOffset, NULL)) == S_OK)
    {
        ULONG         SessionProcessLinksOffset;

        if ((hr = GetFieldOffset("nt!_EPROCESS", "SessionProcessLinks", &SessionProcessLinksOffset)) == S_OK)
        {
            dprintf("Cannot find nt!_EPROCESS type.\n");
            return E_FAIL;
        }

        ULONG64         SessionProcessListAddr;

        if (GetFieldValue(SessionSpaceOffset, "nt!_MM_SESSION_SPACE",
                          "ProcessList.Flink", SessionProcessListAddr) == S_OK)
        {

            Process = SessionProcessListAddr - SessionProcessLinksOffset;
        } else
        {
            dprintf("Cannot read nt!_MM_SESSION_SPACE @ %p\n", SessionSpaceOffset);
            return E_FAIL;
        }
    }
    else
    {
        dprintf("GetSessionSpace returned HRESULT 0x%lx.\n", hr);
    }


    if (GetFieldValue(Process, "nt!_KPROCESS", "DirectoryTableBase[0]", dvPageDirBase) == S_OK &&
        GetProcessSessionId(Process,  &SessionIdCheck) == S_OK)
    {
        *PageDirBase = dvPageDirBase;

        if (Session != CURRENT_SESSION &&
            Session != SessionIdCheck)
        {
            hr = S_FALSE;
        }
        else
        {
            LastSession = Session;
            LastSessionPageDirBase = dvPageDirBase;
        }
    }

    return hr;
}


#if 0
HRESULT
ReadPageTableEntry(
    PDEBUG_DATA_SPACES Data,
    ULONG64 PageTableBase,
    ULONG64 PageTableIndex,
    PULONG64 PageTableEntry
    )
{
    HRESULT hr;
    ULONG64 PhysAddr = PageTableBase + PageTableIndex * HwPte.Size;
    ULONG   BytesRead;


    *PageTableEntry = 0;

    if (CachedPhysAddr[0].Valid &&
        CachedPhysAddr[0].PhysAddr == PhysAddr)
    {
        *PageTableEntry = CachedPhysAddr[0].Data;
        return S_OK;
    }
    else if (CachedPhysAddr[1].Valid &&
             CachedPhysAddr[1].PhysAddr == PhysAddr)
    {
        *PageTableEntry = CachedPhysAddr[1].Data;
        return S_OK;
    }

    hr = Data->ReadPhysical(PhysAddr,
                            PageTableEntry,
                            HwPte.Size,
                            &BytesRead);

    if (hr == S_OK)
    {
        if (BytesRead < HwPte.Size)
        {
            hr = S_FALSE;
        }
        else
        {
            static CacheToggle = 1;

            CacheToggle = (CacheToggle+1) % 2;

            CachedPhysAddr[CacheToggle].Valid    = TRUE;
            CachedPhysAddr[CacheToggle].PhysAddr = *PageTableEntry;
        }
    }

    return hr;
}


HRESULT
GetPageFrameNumber(
    PDEBUG_CLIENT Client,
    PDEBUG_DATA_SPACES Data,
    ULONG64 PageTableBase,
    ULONG64 PageTableIndex,
    PULONG64 PageFrameNumber,
    PBOOL Large
    )
{
    HRESULT hr;
    ULONG64 PageTableEntry;
    ULONG64 Valid, Proto, Trans, LargePage;
    ULONG64 pfn;

    if ((hr = ReadPageTableEntry(Data, PageTableBase, PageTableIndex, &PageTableEntry)) == S_OK)
    {
        if ((hr = GetMMPTEValid(Client, PageTableEntry, &Valid)) == S_OK)
        {
            if (Valid)
            {
                hr = GetMMPTEpfn(Client, PageTableEntry, PageFrameNumber, GET_BITS_UNSHIFTED);

                if (hr == S_OK)
                {
                    if (GetMMPTEX86LargePage(Client, PageTableEntry, &LargePage) == S_OK &&
                        LargePage != 0)
                    {
                        // Large pages map 4MB of space - there shouldn't
                        //  be any bits set below that.
                        if (*PageFrameNumber & (4*1024*1024 - 1))
                        {
#if DBG
                            DbgPrint("Found large X86 page with bad frame number.\n");
                            DbgBreakPoint();
#endif
                        }

                        if (Large == NULL)
                        {
#if DBG
                            DbgPrint("Unexpected large X86 page found.\n");
                            DbgBreakPoint();
#endif
                        }
                        else
                        {
                            *Large = TRUE;
                        }
                    }
                    else if (Large != NULL)
                    {
                        *Large = FALSE;
                    }
                }
            }
            else
            {
                if ((hr = GetMMPTEProto(Client, PageTableEntry, &Proto)) == S_OK &&
                    (hr = GetMMPTETrans(Client, PageTableEntry, &Trans)) == S_OK)
                {
                    if (Proto == 0 && Trans == 1)
                    {
                        hr = GetMMPTEpfn(Client, PageTableEntry, PageFrameNumber, GET_BITS_UNSHIFTED);
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
            }
        }
    }

    return hr;
}

HRESULT
GetNextResidentPage(
    PDEBUG_CLIENT Client,
    ULONG64 PageDirBase,
    ULONG64 VirtAddrStart,
    ULONG64 VirtAddrLimit,
    PULONG64 VirtPage,
    PULONG64 PhysPage
    )
{
    HRESULT             hr;
    BOOL                Interrupted = FALSE;
    PDEBUG_CONTROL      Control = NULL;
    PDEBUG_DATA_SPACES  Data = NULL;
    ULONG64             PageDirIndex;
    ULONG64             PageTableIndex;
    ULONG64             PageDirIndexLimit;
    ULONG64             PageTableIndexLimit;
    ULONG64             PageTableBase;
    BOOL                LargePage;
    ULONG64             TempAddr;

    if (VirtPage == NULL) VirtPage = &TempAddr;
    if (PhysPage == NULL) PhysPage = &TempAddr;

    *VirtPage = 0;
    *PhysPage = 0;

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) == S_OK &&
        (hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&Control)) == S_OK)
    {
        if (!HwPte.Valid)
        {
            PDEBUG_SYMBOLS  Symbols;

            if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                             (void **)&Symbols)) == S_OK)
            {
                if ((hr = Symbols->GetSymbolTypeId(HwPte.Type, &HwPte.TypeId, &HwPte.Module)) == S_OK &&
                    (hr = Symbols->GetTypeSize(HwPte.Module, HwPte.TypeId, &HwPte.Size)) == S_OK &&
                    HwPte.Size != 0)
                {
                    HwPte.Valid = TRUE;
                }
                else if (hr == S_OK)
                {
                    hr = E_FAIL;
                }

                Symbols->Release();
            }
        }

        if (HwPte.Valid)
        {
            ULONG   TableEntries = PageSize / HwPte.Size;
            ULONG64 Addr;

            *VirtPage = PAGE_ALIGN64(VirtAddrStart);

            Addr = VirtAddrStart >> PageShift;
            PageTableIndex = Addr % TableEntries;
            PageDirIndex = (Addr / TableEntries) % TableEntries;

            Addr = VirtAddrLimit >> PageShift;
            PageTableIndexLimit = Addr % TableEntries;
            PageDirIndexLimit = (Addr / TableEntries) % TableEntries;

            if (VirtAddrLimit & (PageSize-1))
            {
                PageTableIndexLimit++;
            }

            hr = S_FALSE;

            while (PageDirIndex < PageDirIndexLimit && hr != S_OK)
            {
                if ((hr = GetPageFrameNumber(Client, Data,
                                             PageDirBase, PageDirIndex,
                                             &PageTableBase, &LargePage)) == S_OK)
                {
                    if (LargePage)
                    {
                        *PhysPage = PageTableBase;
                    }
                    else
                    {
                        do
                        {
                            if ((hr = GetPageFrameNumber(Client, Data,
                                                         PageTableBase, PageTableIndex,
                                                         PhysPage, NULL)) != S_OK)
                            {
                                hr = Control->GetInterrupt();

                                if (hr == S_OK)
                                {
                                    Interrupted = TRUE;
                                    Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                                }
                                else
                                {
                                    PageTableIndex++;
                                    *VirtPage += PageSize;
                                }
                            }
                        } while (PageTableIndex < TableEntries && hr != S_OK);
                    }
                }
                else
                {
                    *VirtPage += PageSize * (TableEntries - PageTableIndex);
                }

                if (hr != S_OK)
                {
                    hr = Control->GetInterrupt();

                    if (hr == S_OK)
                    {
                        Interrupted = TRUE;
                        Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                    }
                    else
                    {
                        PageTableIndex = 0;
                        PageDirIndex++;
                    }
                }
            }

            if (PageDirIndex == PageDirIndexLimit &&
                PageTableIndex < PageTableIndexLimit &&
                hr != S_OK)
            {
                if ((hr = GetPageFrameNumber(Client, Data,
                                             PageDirBase, PageDirIndex,
                                             &PageTableBase, &LargePage)) == S_OK)
                {
                    if (LargePage)
                    {
                        *PhysPage = PageTableBase;
                    }
                    else
                    {
                        do
                        {
                            if ((hr = GetPageFrameNumber(Client, Data,
                                                         PageTableBase, PageTableIndex,
                                                         PhysPage, NULL)) != S_OK)
                            {
                                hr = Control->GetInterrupt();

                                if (hr == S_OK)
                                {
                                    Interrupted = TRUE;
                                    Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                                }
                                else
                                {
                                    PageTableIndex++;
                                    *VirtPage += PageSize;
                                }
                            }
                        } while (PageTableIndex < PageTableIndexLimit && hr != S_OK);
                    }
                }
            }
        }

    }

    if (Control != NULL) Control->Release();
    if (Data != NULL) Data->Release();

    return ((Interrupted) ? E_ABORT : hr);
}


HRESULT
GetNextResidentAddress(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG64 VirtAddrStart,
    ULONG64 VirtAddrLimit,
    PULONG64 VirtAddr,
    PULONG64 PhysAddr
    )
{
    if (Client == NULL) return E_INVALIDARG;

    HRESULT hr = S_OK;
    ULONG64 PageDirBase;

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }


    if (Session < NUM_CACHED_DIR_BASES &&
        CachedDirBase[Session].Valid)
    {
        PageDirBase = CachedDirBase[Session].PageDirBase;
    }
    else if (SessionId == CURRENT_SESSION &&
             CachedDirBase[NUM_CACHED_DIR_BASES].Valid)
    {
        PageDirBase = CachedDirBase[NUM_CACHED_DIR_BASES].PageDirBase;
    }
    else
    {
        DEBUG_VALUE         SessionIdCheck;
        DEBUG_VALUE         dvPageDirBase;
        BOOL                ShortProcessList = (Session == CURRENT_SESSION);
        ULONG               Processor;
        ULONG64             Process=0;
        ULONG64             ProcessListHead = 0;
        ULONG64             ProcessListNext = 0;
        ULONG               ActiveProcessLinksOff;
        ULONG               CurrentSession;

        if (!GetCurrentProcessor(g_ExtClient, &Processor, NULL))
        {
            Processor = 0;
        }
        GetCurrentProcessAddr(Processor, 0, &Process);
        GetProcessHead(&ProcessListHead, &ProcessListNext);
        if (GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActiveProcessLinksOff))
        {
            dprintf("Unable to get EPROCESS.ActiveProcessLinks offset\n");
            hr = E_FAIL;;
            ProcessListNext = 0;
        }
        hr = S_FALSE;

        while ((ProcessListNext != ProcessListHead) && ProcessListNext &&
               (hr != S_OK))
        {
            if (!ShortProcessList)
            {
                Process = ProcessListNext - ActiveProcessLinksOff;

                if (!ReadPointer(ProcessListNext, &ProcessListNext))
                {
                    dprintf("Cannot read EPROCESS at %p\n", Process);
                    hr = E_FAIL;
                    break;
                }

                if (CheckControlC())
                {
                    hr = E_FAIL;
                    break;
                }
            }

            if (!GetProcessSessionId(Process,  &CurrentSession))
            {
                hr = E_FAIL;
                break;
            }
            GetFieldValue(Process, "nt!_KPROCESS", "DirectoryTableBase[0]", PageDirBase);

            if (!IsPtr64())
            {
                PageDirBase = (ULONG64) (LONG64) (LONG) PageDirBase;
            }

            if ((Session == CurrentSession) || ShortProcessList)
            {
                hr = S_OK;

                if (Session < NUM_CACHED_DIR_BASES)
                {
                    CachedDirBase[Session].Valid       = TRUE;
                    CachedDirBase[Session].PageDirBase = PageDirBase;
                }
                else if (Session == CURRENT_SESSION)
                {
                    CachedDirBase[NUM_CACHED_DIR_BASES].Valid       = TRUE;
                    CachedDirBase[NUM_CACHED_DIR_BASES].PageDirBase = PageDirBase;
                }
            }
        }
    }

    if (hr == S_OK)
    {
        hr = GetNextResidentPage(Client,
                                 PageDirBase,
                                 VirtAddrStart,
                                 VirtAddrLimit,
                                 VirtAddr,
                                 PhysAddr);
    }
    else
    {
        ExtVerb("Page Directory Base lookup failed.\n");
    }

    return hr;
}
#endif

DECLARE_API( dss )

/*++

Routine Description:

    Dumps the session space structure

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Result;
    ULONG64 MmSessionSpace;
    ULONG64 MmSessionSpacePtr = 0;
    ULONG64 Wsle;

    MmSessionSpacePtr = GetExpression(args);

    if( MmSessionSpacePtr == 0 ) {
        MmSessionSpacePtr = GetExpression("nt!MmSessionSpace");
        if( !MmSessionSpacePtr ) {
            dprintf("Unable to get address of MmSessionSpace\n");
            return E_INVALIDARG;
        }

        if (!ReadPointer( MmSessionSpacePtr, &MmSessionSpace)) {
            dprintf("Unable to get value of MmSessionSpace\n");
            return E_INVALIDARG;
        }
    } else {
        MmSessionSpace = MmSessionSpacePtr;
    }

    dprintf("MM_SESSION_SPACE at 0x%p\n",
        MmSessionSpace
    );

    if (GetFieldValue(MmSessionSpace, "MM_SESSION_SPACE", "Wsle", Wsle)) {
        dprintf("Unable to get value of MM_SESSION_SPACE at 0x%p\n",MmSessionSpace);
        return E_INVALIDARG;
    }

    GetFieldOffset("MM_SESSION_SPACE", "PageTables", &Result);
    dprintf("&PageTables %p\n",
            MmSessionSpace + Result
            );

    GetFieldOffset("MM_SESSION_SPACE", "PagedPoolInfo", &Result);
    dprintf("&MM_PAGED_POOL_INFO %x\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "Vm", &Result);
    dprintf("&MMSUPPORT %p\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "Wsle", &Result);
    dprintf("&PMMWSLE %p\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "Session", &Result);
    dprintf("&MMSESSION %p\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "WorkingSetLockOwner", &Result);
    dprintf("&WorkingSetLockOwner %p\n",
            MmSessionSpace + Result
    );

    GetFieldOffset("MM_SESSION_SPACE", "PagedPool", &Result);
    dprintf("&POOL_DESCRIPTOR %p\n",
            MmSessionSpace + Result
    );

    return S_OK;
}


DECLARE_API( session )
{
    INIT_API();

    HRESULT hr;
    ULONG   NewSession = CURRENT_SESSION;
    ULONG   CurrentSession = INVALID_SESSION;
    ULONG   SessionCount = 0;
    BOOL    SetSession = FALSE;
    PRTL_BITMAP SessionList = NULL;
    DEBUG_VALUE DebugValue;
    ULONG   Remainder;

    while (*args && isspace(*args)) args++;
    if (args[0] == '-' || args[0] == '/')
    {
        if (args[1] == '?')
        {
            ExtOut("session displays number of sessions on machine and\n"
                   " the default SessionId used by session related extensions.\n"
                   "\n"
                   "Usage: session [ [-s] SessionId]\n"
                   "    -s - sets default session used for session extensions\n"
                   "Note: Use !sprocess to dump session process\n");

            EXIT_API();
            return S_OK;
        } else if (args[1] == 's')
        {
            args+=2;
            SetSession = TRUE;
        }
    }

    hr = g_ExtControl->Evaluate(args, DEBUG_VALUE_INT32, &DebugValue, &Remainder);
    if (hr == S_OK)
    {
        args += Remainder;
    }
    if (GetSessionNumbers(Client, &CurrentSession, NULL, &SessionCount, &SessionList) == S_OK)
    {
        if (SessionCount != 0)
        {
            ExtOut("Sessions on machine: %lu\n", SessionCount);

            // If a session wasn't specified,
            // list valid sessions (up to a point).
            if (hr != S_OK)
            {
                ULONG SessionLimit = SessionList->SizeOfBitMap;

                ExtOut("Valid Sessions:");

                for (ULONG CheckSession = 0; CheckSession <= SessionLimit; CheckSession++)
                {
                    if (RtlCheckBit(SessionList, CheckSession)
                        /*GetSessionSpace(Client, CheckSession, NULL) == S_OK*/)
                    {
                        ExtOut(" %lu", CheckSession);
                        SessionCount--;
                        if (SessionCount == 0) break;
                    }

                    if (g_ExtControl->GetInterrupt() == S_OK)
                    {
                        ExtWarn("\n  User aborted.\n");
                        break;
                    }
                }

                if (SessionCount > 0)
                {
                    ExtOut(" ...?");
                }
                ExtOut("\n");
            }
        }
        else if (SessionList)
        {
            ExtOut("There are ZERO session on machine.\n");
        }
        else
        {
            ExtErr("Couldn't determine number of sessions.\n");
        }

        if (SessionList)
        {
            FreeBitMap(SessionList);
        }

        if (CurrentSession != INVALID_SESSION)
        {
            ExtVerb("Running session: %lu\n", CurrentSession);
        }
    }

    if ((hr == S_OK) && SetSession)
    {
        NewSession = DebugValue.I32;

        ExtVerb("Previous Default Session: %s\n", SessionStr);

        if (SetDefaultSession(Client, NewSession, NULL) != S_OK)
        {
            ExtErr("Couldn't set Session %lu.\n", NewSession);
        }
        ExtOut("Using session %s", SessionStr);
    }

    if (SessionId == CURRENT_SESSION)
    {
        if (CurrentSession != INVALID_SESSION)
        {
            ExtOut("Current Session %d", CurrentSession);
        }
        else
        {
            ExtOut("Error in reading current session");
        }
    }
    ExtOut("\n");

    EXIT_API();
    return S_OK;
}


DECLARE_API( svtop )
{
    INIT_API();

    HRESULT     hr;
    DEBUG_VALUE SessVirtAddr;
    ULONG64     PhysAddr;

    if (S_OK == g_ExtControl->Evaluate(args, DEBUG_VALUE_INT64, &SessVirtAddr, NULL))
    {
        ExtOut("Use !vtop 0 %p\n", SessVirtAddr.I64);
    }
    else
    {
        ExtOut("Use !vtop 0 VirtualAddress\n");
    }

    EXIT_API();
    return S_OK;
}


DECLARE_API( sprocess )
{
    INIT_API();

    HRESULT     hr;
    DEBUG_VALUE Session;
    ULONG       RemainingArgIndex;
    DEBUG_VALUE Flag;

    while (*args && isspace(*args)) args++;
    if (args[0] == '-' && args[1] == '?')
    {
        ExtOut("sprocess is like !process, but for the SessionId specified.\n"
               "\n"
               "Usage: sprocess [SessionId [Flags]]\n"
               "    SessionId - specifies which session to dump.\n"
               "              Special SessionId values:\n"
               "               -1 - current session\n"
               "    Flags - see !process help\n");

        EXIT_API();
        return S_OK;
    }

    ULONG       OldRadix;
    g_ExtControl->GetRadix(&OldRadix);
    g_ExtControl->SetRadix(10);
    hr = g_ExtControl->Evaluate(args, DEBUG_VALUE_INT32, &Session, &RemainingArgIndex);
    g_ExtControl->SetRadix(OldRadix);

    Flag.I32 = 0;

    if (hr != S_OK)
    {
        Session.I32 = SessionId;
        hr = S_OK;
    }
    else
    {
        args += RemainingArgIndex;
        hr = g_ExtControl->Evaluate(args, DEBUG_VALUE_INT32, &Flag, &RemainingArgIndex);
        if (hr == S_OK)
        {
            args += RemainingArgIndex;
        }
    }

    Flag.I32 = (Flag.I32 << 2) | 2;
    while (*args && *args == ' ') ++args;

    hr = DumpSessionInfo(Flag.I32, Session.I32, (PCHAR) (*args ? args : NULL));

    EXIT_API();
    return hr;
}

HRESULT
SearchLinkedList(
    PDEBUG_CLIENT   Client,
    ULONG64         StartAddr,
    ULONG64         NextLinkOffset,
    ULONG64         SearchAddr,
    PULONG          LinksTraversed
    )
{
    if (LinksTraversed != NULL)
    {
        *LinksTraversed = 0;
    }

    INIT_API();

    HRESULT hr = S_OK;
    ULONG64 PhysAddr;
    ULONG64 NextAddr = StartAddr;
    ULONG   LinkCount = 0;
    ULONG   PointerSize;
    ULONG   BytesRead;

    PointerSize = (g_ExtControl->IsPointer64Bit() == S_OK) ? 8 : 4;

    do
    {
        if ((hr = g_ExtData->ReadVirtual(NextLinkOffset + NextLinkOffset,
                                         &NextAddr,
                                         PointerSize,
                                         &BytesRead)) == S_OK)
        {
            if (BytesRead == PointerSize)
            {
                LinkCount++;
                if (PointerSize != 8)
                {
                    NextAddr = DEBUG_EXTEND64(NextAddr);
                }
                ExtVerb("NextAddr: %p\n", NextAddr);
            }
            else
            {
                hr = S_FALSE;
            }
        }
    } while (hr == S_OK &&
             NextAddr != SearchAddr &&
             NextAddr != 0 &&
             LinkCount < 4 &&
             NextAddr != StartAddr);

    if (LinksTraversed != NULL)
    {
        *LinksTraversed = LinkCount;
    }

    // Did we really find SearchAddr?
    if (hr == S_OK &&
        NextAddr != SearchAddr)
    {
        hr = S_FALSE;
    }

    EXIT_API();
    return hr;
}


DECLARE_API( walklist )
{
    INIT_API();

    HRESULT     hr;
    BOOL        NeedHelp = FALSE;
    BOOL        SearchSessions = FALSE;
    DEBUG_VALUE StartAddr;
    DEBUG_VALUE OffsetToNextField = { -1, DEBUG_VALUE_INVALID };//FIELD_OFFSET(Win32PoolHead, pNext);
    DEBUG_VALUE SearchAddr;
    ULONG       NextArg;
    ULONG       SessionCount;
    ULONG       Session = 0;
    ULONG       OldDefSession;
    ULONG       LinksToDest = 0;

    while (*args && isspace(*args)) args++;

    while (args[0] == '-' && !NeedHelp)
    {
        if (tolower(args[1]) == 'a' && isspace(args[2]))
        {
            SearchSessions = TRUE;
            args += 2;
            while (*args && isspace(*args)) args++;
        }
        else if (tolower(args[1]) == 'o' &&
                 GetExpressionEx(args+2,
                                 &OffsetToNextField.I64, &args) == TRUE)
        {
            while (*args && isspace(*args)) args++;
        }
        else
        {
            NeedHelp = TRUE;
        }
    }

    if (!NeedHelp &&
        S_OK == g_ExtControl->Evaluate(args, DEBUG_VALUE_INT64, &StartAddr, &NextArg))
    {
        args += NextArg;
        if (S_OK != g_ExtControl->Evaluate(args, DEBUG_VALUE_INT64, &SearchAddr, &NextArg))
        {
            SearchAddr.I64 = 0;
        }

        if (OffsetToNextField.Type == DEBUG_VALUE_INVALID)
        {
            ExtWarn("Assuming next field's offset is +8.\n");
            OffsetToNextField.I64 = 8;
        }
        else
        {
            ExtOut("Using field at offset +0x%I64u for next.\n", OffsetToNextField.I64);
        }

        if (SearchSessions &&
            GetSessionNumbers(Client, NULL, &OldDefSession, &SessionCount, NULL) == S_OK &&
            SessionCount > 0)
        {
            ExtOut("Searching all sessions lists @ %p for %p\n", StartAddr.I64, SearchAddr.I64);

            do
            {
                while (SetDefaultSession(Client, Session, NULL) != S_OK &&
                       Session <= SESSION_SEARCH_LIMIT)
                {
                    Session++;
                }

                if (Session <= SESSION_SEARCH_LIMIT)
                {
                    if ((hr = SearchLinkedList(Client, StartAddr.I64, OffsetToNextField.I64, SearchAddr.I64, &LinksToDest)) == S_OK)
                    {
                        ExtOut("Session %lu: Found %p after walking %lu linked list entries.\n", Session, SearchAddr.I64, LinksToDest);
                    }
                    else
                    {
                        ExtOut("Session %lu: Couldn't find %p after walking %lu linked list entries.\n", Session, SearchAddr.I64, LinksToDest);
                    }

                    Session++;
                    SessionCount--;
                }
            } while (SessionCount > 0 && Session <= SESSION_SEARCH_LIMIT);

            if (SessionCount)
            {
                ExtErr("%lu sessions beyond session %lu were not searched.\n",
                       SessionCount, SESSION_SEARCH_LIMIT);
            }

            SetDefaultSession(Client, OldDefSession, NULL);
        }
        else
        {
            ExtOut("Searching Session %s list @ %p for %p\n", SessionStr, StartAddr.I64, SearchAddr.I64);

            if ((hr = SearchLinkedList(Client, StartAddr.I64, OffsetToNextField.I64, SearchAddr.I64, &LinksToDest)) == S_OK)
            {
                ExtOut("Found %p after walking %lu linked list entries.\n", SearchAddr.I64, LinksToDest);
            }
            else
            {
                ExtOut("Couldn't find %p after walking %lu linked list entries.\n", SearchAddr.I64, LinksToDest);
            }
        }
    }
    else
    {
        NeedHelp = TRUE;
    }

    if (NeedHelp)
    {
        ExtOut("Usage: walklist [-a] StartAddress [SearchAddr]\n");
    }

    EXIT_API();
    return S_OK;
}


HRESULT
GetBitMap(
    PDEBUG_CLIENT Client,
    ULONG64 pBitMap,
    PRTL_BITMAP *pBitMapOut
    )
{
    HRESULT     hr;
    PRTL_BITMAP p;
    ULONG       Size;
    ULONG64     Buffer;
    ULONG       BufferLen;
    ULONG       BytesRead = 0;


    *pBitMapOut = NULL;

    if ((GetFieldValue(pBitMap, "nt!_RTL_BITMAP", "SizeOfBitMap", Size) == S_OK) &&
        (GetFieldValue(pBitMap, "nt!_RTL_BITMAP", "Buffer", Buffer) == S_OK))
    {
        PDEBUG_DATA_SPACES  Data;

        if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&Data)) == S_OK)
        {
            BufferLen = (Size + 7) / 8;

#if DBG
            ExtVerb("Reading RTL_BITMAP @ 0x%p:\n"
                    "  SizeOfBitMap: %lu\n"
                    "  Buffer: 0x%p\n"
                    "   Length in bytes: 0x%lx\n",
                    pBitMap,
                    Size,
                    Buffer,
                    BufferLen);
#endif

            p = (PRTL_BITMAP) HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) + BufferLen );

            if (p != NULL)
            {
                RtlInitializeBitMap(p, (PULONG)(p + 1), Size);
                hr = Data->ReadVirtual(Buffer, p->Buffer, BufferLen, &BytesRead);

                if (hr != S_OK)
                {
                    ExtErr("Error reading bitmap contents @ 0x%p\n", Buffer);
                }
                else if (BytesRead < BufferLen)
                {
                    ExtErr("Error reading bitmap contents @ 0x%p\n", Buffer + BytesRead);
                    hr = E_FAIL;
                }

                if (hr != S_OK)
                {
                    HeapFree( GetProcessHeap(), 0, p );
                    p = NULL;
                }
                else
                {
                    *pBitMapOut = p;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            Data->Release();
        }
        else
        {
            ExtErr("Error setting up debugger interface.\n");
        }
    }
    else
    {
        ExtErr("Error reading bitmap header @ 0x%p.\n", pBitMap);
    }

    return hr;
}


HRESULT
FreeBitMap(
    PRTL_BITMAP pBitMap
    )
{
    return (HeapFree( GetProcessHeap(), 0, pBitMap) ? S_OK : S_FALSE);
}


HRESULT
CheckSingleFilter(
    PUCHAR Tag,
    PUCHAR Filter
    )
{
    ULONG i;
    UCHAR tc;
    UCHAR fc;

    for ( i = 0; i < 4; i++ )
    {
        tc = (UCHAR) *Tag++;
        fc = (UCHAR) *Filter++;
        if ( fc == '*' ) return S_OK;
        if ( fc == '?' ) continue;
        if (i == 3 && (tc & ~(PROTECTED_POOL >> 24)) == fc) continue;
        if ( tc != fc ) return S_FALSE;
    }

    return S_OK;
}


HRESULT
AccumAllFilter(
    ULONG64 PoolAddr,
    ULONG TagFilter,
    ULONG64 PoolHeader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT             hr;
    DEBUG_VALUE         PoolType;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)Context;

    if (AllocStatsAccum == NULL)
    {
        return E_INVALIDARG;
    }

    hr = GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolType", PoolType.I32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            AllocStatsAccum->Free++;
            AllocStatsAccum->FreeSize += BlockSize;
        }
        else
        {
            DEBUG_VALUE PoolIndex;

            if (!NewPool)
            {
                hr = GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex.I32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    AllocStatsAccum->Allocated++;
                    AllocStatsAccum->AllocatedSize += BlockSize;

                    if (AllocStatsAccum->Allocated % 100 == 0)
                    {
                        ExtOut(".");

                        if (AllocStatsAccum->Allocated % 8000 == 0)
                        {
                            ExtOut("\n");
                        }
                    }
                }
                else
                {
                    AllocStatsAccum->Free++;
                    AllocStatsAccum->FreeSize += BlockSize;
                }
            }
            else
            {
                AllocStatsAccum->Indeterminate++;
                AllocStatsAccum->IndeterminateSize += BlockSize;
            }
        }
    }
    else
    {
        AllocStatsAccum->Indeterminate++;
        AllocStatsAccum->IndeterminateSize += BlockSize;
    }

    return hr;
}

HRESULT
CheckPrintAndAccumFilter(
    ULONG64 PoolAddr,
    ULONG TagFilter,
    ULONG64 PoolHeader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT             hr;
    DEBUG_VALUE         PoolType;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)Context;

    if (CheckSingleFilter(Tag->RawBytes, (PUCHAR)&TagFilter) != S_OK)
    {
        return S_FALSE;
    }

    ExtOut("0x%p size: %5lx ",//previous size: %4lx ",
           PoolAddr,
           BlockSize << POOL_BLOCK_SHIFT/*,
                   PreviousSize << POOL_BLOCK_SHIFT*/);

    hr = GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolType", PoolType.I32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            //
            // "Free " with a space after it before the parentheses means
            // it's been freed to a (pool manager internal) lookaside list.
            // We used to print "Lookaside" but that just confused driver
            // writers because they didn't know if this meant in use or not
            // and many would say "but I don't use lookaside lists - the
            // extension or kernel is broken".
            //
            // "Free" with no space after it before the parentheses means
            // it is not on a pool manager internal lookaside list and is
            // instead on the regular pool manager internal flink/blink
            // chains.
            //
            // Note to anyone using the pool package, these 2 terms are
            // equivalent.  The fine distinction is only for those actually
            // writing pool internal code.
            //
            ExtOut(" (Free)");
            ExtOut("      %c%c%c%c\n",
                   Tag->RawBytes[0],
                   Tag->RawBytes[1],
                   Tag->RawBytes[2],
                   Tag->RawBytes[3]
                   );

            if (AllocStatsAccum != NULL)
            {
                AllocStatsAccum->Free++;
                AllocStatsAccum->FreeSize += BlockSize;
            }
        }
        else
        {
            DEBUG_VALUE PoolIndex;
            DEBUG_VALUE ProcessBilled;

            if (!NewPool)
            {
                hr = GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex.I32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    ExtOut(" (Allocated)");

                    if (AllocStatsAccum != NULL)
                    {
                        AllocStatsAccum->Allocated++;
                        AllocStatsAccum->AllocatedSize += BlockSize;
                    }
                }
                else
                {
                    //
                    // "Free " with a space after it before the parentheses means
                    // it's been freed to a (pool manager internal) lookaside list.
                    // We used to print "Lookaside" but that just confused driver
                    // writers because they didn't know if this meant in use or not
                    // and many would say "but I don't use lookaside lists - the
                    // extension or kernel is broken".
                    //
                    // "Free" with no space after it before the parentheses means
                    // it is not on a pool manager internal lookaside list and is
                    // instead on the regular pool manager internal flink/blink
                    // chains.
                    //
                    // Note to anyone using the pool package, these 2 terms are
                    // equivalent.  The fine distinction is only for those actually
                    // writing pool internal code.
                    //
                    ExtOut(" (Free )    ");

                    if (AllocStatsAccum != NULL)
                    {
                        AllocStatsAccum->Free++;
                        AllocStatsAccum->FreeSize += BlockSize;
                    }
                }
            }
            else
            {
                ExtOut(" (?)        ");

                if (AllocStatsAccum != NULL)
                {
                    AllocStatsAccum->Indeterminate++;
                    AllocStatsAccum->IndeterminateSize += BlockSize;
                }
            }

            if (!(PoolType.I32 & POOL_QUOTA_MASK) ||
                bQuotaWithTag)
            {
                ExtOut(" %c%c%c%c%s",
                       Tag->RawBytes[0],
                       Tag->RawBytes[1],
                       Tag->RawBytes[2],
                       (Tag->RawBytes[3] & ~(PROTECTED_POOL >> 24)),
                       ((Tag->I32 & PROTECTED_POOL) ? " (Protected)" : "")
                       );

            }

            if (PoolType.I32 & POOL_QUOTA_MASK &&
                GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "ProcessBilled", ProcessBilled.I64) == S_OK &&
                ProcessBilled.I64 != 0)
            {
                ExtOut(" Process: 0x%p\n", ProcessBilled.I64);
            }
            else
            {
                ExtOut("\n");
            }
        }
    }
    else
    {
        ExtErr(" Couldn't determine PoolType\n");

        if (AllocStatsAccum != NULL)
        {
            AllocStatsAccum->Indeterminate++;
            AllocStatsAccum->IndeterminateSize += BlockSize;
        }
    }

    return hr;
}


typedef struct _TAG_BUCKET : public ALLOCATION_STATS {
    ULONG Tag;
    _TAG_BUCKET *pNextTag;
} TAG_BUCKET, *PTAG_BUCKET;

typedef enum {
    AllocatedPool,
    FreePool,
    IndeterminatePool,
} PoolType;

class AccumTagUsage : public ALLOCATION_STATS {
public:
    AccumTagUsage(ULONG TagFilter);
    ~AccumTagUsage();

    HRESULT Valid();
    HRESULT Add(ULONG Tag, PoolType Type, ULONG Size);
    HRESULT OutputResults(BOOL TagSort);
    void Reset();

private:
    ULONG GetHashIndex(ULONG Tag);
    PTAG_BUCKET GetBucket(ULONG Tag);
    ULONG SetTagFilter(ULONG TagFilter);

    static const HashBitmaskLimit = 10;     // For little-endian, must <= 16

    HANDLE      hHeap;
    ULONG       Buckets;
    PTAG_BUCKET *Bucket;   // Array of buckets

#if BIG_ENDIAN
    ULONG       HighMask;
    ULONG       HighShift;
    ULONG       LowMask;
    ULONG       LowShift;
#else
    ULONG       HighShiftLeft;
    ULONG       HighShiftRight;
    ULONG       LowShiftRight;
    ULONG       LowMask;
#endif
};


AccumTagUsage::AccumTagUsage(
    ULONG TagFilter
    )
{
    hHeap = GetProcessHeap();
    Buckets = SetTagFilter(TagFilter);
    if (Buckets != 0)
    {
        Bucket = (PTAG_BUCKET *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, Buckets*sizeof(*Bucket));
        Reset();
    }
    else
    {
        Bucket = NULL;
    }
}


AccumTagUsage::~AccumTagUsage()
{
    PTAG_BUCKET pB, pBNext;
    ULONG       i;

    if (Bucket != NULL)
    {
        for (i = 0; i < Buckets; i++)
        {
            pB = Bucket[i];
            while (pB != NULL)
            {
                pBNext = pB->pNextTag;
                HeapFree(hHeap, 0, pB);
                pB = pBNext;
            }
        }

        HeapFree(hHeap, 0, Bucket);
    }
}


HRESULT
AccumTagUsage::Valid()
{
    return ((Bucket != NULL) ? S_OK : S_FALSE);
}


HRESULT
AccumTagUsage::Add(
    ULONG Tag,
    PoolType Type,
    ULONG Size
    )
{
    PTAG_BUCKET pBucket = GetBucket(Tag);

    if (pBucket == NULL) return E_FAIL;

    switch (Type)
    {
        case AllocatedPool:
            pBucket->Allocated++;
            pBucket->AllocatedSize += Size;
            break;
        case FreePool:
            pBucket->Free++;
            pBucket->FreeSize += Size;
            break;
        case IndeterminatePool:
        default:
            pBucket->Indeterminate++;
            pBucket->IndeterminateSize += Size;
            break;
    }

    return S_OK;
}


HRESULT
AccumTagUsage::OutputResults(
    BOOL AllocSort
    )
{
    HRESULT     hr;
    PTAG_BUCKET pB, pBNext;
    ULONG       i;

    if (Bucket == NULL)
    {
        ExtOut(" No results\n");
    }
    else
    {
        CHAR        szNormal[] = "%4.4s %8lu %12I64u  %8lu %12I64u\n";
        CHAR        szShowIndeterminate[] = "%4.4s %8lu %12I64u  %8lu %12I64u  %8lu %12I64u\n";
        PSZ         pszOutFormat = szNormal;

        ExtOut("\n"
               " %I64u bytes in %lu allocated pages\n"
               " %I64u bytes in %lu large allocations\n"
               " %I64u bytes in %lu free pages\n"
               " %I64u bytes available in %lu expansion pages\n",
               ((ULONG64) AllocatedPages) << PageShift,
               AllocatedPages,
               ((ULONG64) LargePages) << PageShift,
               LargeAllocs,
               ((ULONG64) FreePages) << PageShift,
               FreePages,
               ((ULONG64) ExpansionPages) << PageShift,
               ExpansionPages);

        ExtOut("\nTag    Allocs        Bytes     Freed        Bytes");
        if (Indeterminate != 0)
        {
            ExtOut(" Unknown        Bytes");
            pszOutFormat = szShowIndeterminate;
        }
        ExtOut("\n");

        if (AllocSort)
        {
            ExtWarn("  Sorting by allocation size isn't supported.\n");
        }
        //else
        {
            // Output results sorted by Tag (natural storage order)

            for (i = 0; i < Buckets; i++)
            {
                for (pB = Bucket[i]; pB != NULL; pB = pB->pNextTag)
                {
                    if (pB->Allocated)
                    {
                        ExtOut(pszOutFormat,
                               &pB->Tag,
                               pB->Allocated, ((ULONG64)pB->AllocatedSize) << POOL_BLOCK_SHIFT,
                               pB->Free, ((ULONG64)pB->FreeSize) << POOL_BLOCK_SHIFT,
                               pB->Indeterminate, ((ULONG64)pB->IndeterminateSize) << POOL_BLOCK_SHIFT
                               );
                    }
                }
            }
        }

        ExtOut("-------------------------------------------------------------------------------\n");
        ExtOut(pszOutFormat,
               "Ttl:",
               Allocated, ((ULONG64)AllocatedSize) << POOL_BLOCK_SHIFT,
               Free, ((ULONG64)FreeSize) << POOL_BLOCK_SHIFT,
               Indeterminate, ((ULONG64)IndeterminateSize) << POOL_BLOCK_SHIFT
               );
    }

    return S_OK;
}


void
AccumTagUsage::Reset()
{
    PTAG_BUCKET pB, pBNext;
    ULONG       i;

    AllocatedPages = 0;
    LargePages = 0;
    LargeAllocs = 0;
    FreePages = 0;
    ExpansionPages = 0;

    Allocated = 0;
    AllocatedSize = 0;
    Free = 0;
    FreeSize = 0;
    Indeterminate = 0;
    IndeterminateSize = 0;

    if (Bucket != NULL)
    {
        for (i = 0; i < Buckets; i++)
        {
            pB = Bucket[i];
            if (pB != NULL)
            {
                do
                {
                    pBNext = pB->pNextTag;
                    HeapFree(hHeap, 0, pB);
                    pB = pBNext;
                } while (pB != NULL);

                Bucket[i] = NULL;
            }
        }
    }
}


ULONG
AccumTagUsage::GetHashIndex(
    ULONG Tag
    )
{
#if BIG_ENDIAN
    return (((Tag & HighMask) >> HighShift) | ((Tag & LowMask) >> LowShift));
#else
    return ((((Tag << HighShiftLeft) >> HighShiftRight) & ~LowMask) | ((Tag >> LowShiftRight) & LowMask));
#endif
}


PTAG_BUCKET
AccumTagUsage::GetBucket(
    ULONG Tag
    )
{
    ULONG       Index = GetHashIndex(Tag);
    PTAG_BUCKET pB = Bucket[Index];

    if (pB == NULL ||
#if BIG_ENDIAN
        pB->Tag > Tag
#else
        strncmp((char *)&pB->Tag, (char *)&Tag, 4) > 0
#endif
        )
    {
        pB = (PTAG_BUCKET)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(TAG_BUCKET));

        if (pB != NULL)
        {
            pB->Tag = Tag;
            pB->pNextTag = Bucket[Index];
            Bucket[Index] = pB;
        }
    }
    else
    {
        while (pB->pNextTag != NULL)
        {
            if (
#if BIG_ENDIAN
                pB->pNextTag->Tag > Tag
#else
                strncmp((char *)&pB->pNextTag->Tag, (char *)&Tag, 4) > 0
#endif
                )
            {
                break;
            }

            pB = pB->pNextTag;
        }

        if (pB->Tag != Tag)
        {
            PTAG_BUCKET pBPrev = pB;

            pB = (PTAG_BUCKET)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(TAG_BUCKET));

            if (pB != NULL)
            {
                pB->Tag = Tag;
                pB->pNextTag = pBPrev->pNextTag;
                pBPrev->pNextTag = pB;
            }
        }
    }

    return pB;
}


ULONG
AccumTagUsage::SetTagFilter(
    ULONG TagFilter
    )
{
    ULONG NumBuckets;
    UCHAR *Filter = (UCHAR *)&TagFilter;
    ULONG i;
    ULONG HighMaskBits, LowMaskBits;
    UCHAR fc;

#if BIG_ENDIAN

    ULONG Mask = 0;
    ULONG MaskBits = 0;

    if (Filter[0] == '*')
    {
        Mask = -1;
        MaskBits = 32;
    }
    else
    {
        for ( i = 0; i < 32; i += 8 )
        {
            Mask <<= 8;
            fc = *Filter++;

            if ( fc == '*' )
            {
                Mask |= ((1 << i) - 1);
                MaskBits += 32 - i;
                break;
            }

            if ( fc == '?' )
            {
                Mask |= 0xFF;
                MaskBits += 8;
            }
        }
    }

    if (MaskBits > HashBitmaskLimit)
    {
        MaskBits = HashBitmaskLimit;
    }

    NumBuckets = (1 << MaskBits);

    for (HighShift = 32, HighMaskBits = 0;
         HighShift > 0 && HighMaskBits < MaskBits;
         HighShift--)
    {
        if (Mask & (1 << (HighShift-1)))
        {
            HighMaskBits++;
        }
        else if (HighMaskBits)
        {
            break;
        }
    }

    HighMask = Mask & ~((1 << HighShift) - 1);
    Mask &= ~HighMask;
    MaskBits -= HighMaskBits;
    HighShift -= MaskBits;

    for (LowShift = HighShift, LowMaskBits = 0;
         LowShift > 0 && LowMaskBits < MaskBits;
         LowShift--)
    {
        if (Mask & (1 << (LowShift-1)))
        {
            LowMaskBits++;
        }
        else if (LowMaskBits)
        {
            break;
        }
    }

    LowMask = Mask & ~((1 << LowShift) - 1);

#else

    HighMaskBits = 0;
    LowMaskBits = 0;

    HighShiftLeft = 32;
    HighShiftRight = 32;
    LowShiftRight = 32;
    LowMask = 0;

    for ( i = 0; i < 32; i += 8 )
    {
        fc = *Filter++;

        if ( fc == '*' )
        {
            if (HighMaskBits == 0)
            {
                HighMaskBits = min(8, HashBitmaskLimit);
                HighShiftLeft = 32 - HighMaskBits - i;
                HighShiftRight = 32 - HighMaskBits;

                LowMaskBits = ((HighShiftLeft != 0) ?
                               min(8, HashBitmaskLimit - HighMaskBits) :
                               0);
                HighShiftRight -= LowMaskBits;
                LowShiftRight = (8 - LowMaskBits) + HighMaskBits + i;
                LowMask = (1 << LowMaskBits) - 1;
            }
            else
            {
                LowMaskBits = min(8, HashBitmaskLimit - HighMaskBits);
                HighShiftRight -= LowMaskBits;
                LowShiftRight = (8 - LowMaskBits) + i;
                LowMask = (1 << LowMaskBits) - 1;
            }
            break;
        }

        if ( fc == '?' )
        {
            if (HighMaskBits == 0)
            {
                HighMaskBits = min(8, HashBitmaskLimit);
                HighShiftLeft = 32 - HighMaskBits - i;
                HighShiftRight = 32 - HighMaskBits;
            }
            else
            {
                LowMaskBits = min(8, HashBitmaskLimit - HighMaskBits);
                HighShiftRight -= LowMaskBits;
                LowShiftRight = (8 - LowMaskBits) + i;
                LowMask = (1 << LowMaskBits) - 1;
                break;
            }
        }
    }

    NumBuckets = 1 << (HighMaskBits + LowMaskBits);

#endif

    if (NumBuckets-1 != GetHashIndex(-1))
    {
        DbgPrint("AccumTagUsage::SetTagFilter: Invalid hash was generated.\n");
        NumBuckets = 0;
    }

    return NumBuckets;
}


HRESULT
AccumTagUsageFilter(
    ULONG64 PoolAddr,
    ULONG TagFilter,
    ULONG64 PoolHeader,
    PDEBUG_VALUE Tag,
    ULONG BlockSize,
    BOOL bQuotaWithTag,
    PVOID Context
    )
{
    HRESULT         hr;
    DEBUG_VALUE     PoolType;
    AccumTagUsage  *atu = (AccumTagUsage *)Context;
    PALLOCATION_STATS   AllocStatsAccum = (PALLOCATION_STATS)atu;

    if (CheckSingleFilter(Tag->RawBytes, (PUCHAR)&TagFilter) != S_OK)
    {
        return S_FALSE;
    }

    hr = GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolType", PoolType.I32);

    if (hr == S_OK)
    {
        if (PoolType.I32 == 0)
        {
            hr = atu->Add(Tag->I32, FreePool, BlockSize);
            AllocStatsAccum->Free++;
            AllocStatsAccum->FreeSize += BlockSize;
        }
        else
        {
            DEBUG_VALUE PoolIndex;

            if (!(PoolType.I32 & POOL_QUOTA_MASK) ||
                bQuotaWithTag)
            {
                Tag->I32 &= ~PROTECTED_POOL;
            }
            else if (PoolType.I32 & POOL_QUOTA_MASK)
            {
                Tag->I32 = 'CORP';
            }

            if (!NewPool)
            {
                hr = GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolIndex", PoolIndex.I32);
            }

            if (hr == S_OK)
            {
                if (NewPool ? (PoolType.I32 & 0x04) : (PoolIndex.I32 & 0x80))
                {
                    hr = atu->Add(Tag->I32, AllocatedPool, BlockSize);
                    AllocStatsAccum->Allocated++;
                    AllocStatsAccum->AllocatedSize += BlockSize;

                    if (AllocStatsAccum->Allocated % 100 == 0)
                    {
                        ExtOut(".");

                        if (AllocStatsAccum->Allocated % 8000 == 0)
                        {
                            ExtOut("\n");
                        }
                    }
                }
                else
                {
                    hr = atu->Add(Tag->I32, FreePool, BlockSize);
                    AllocStatsAccum->Free++;
                    AllocStatsAccum->FreeSize += BlockSize;
                }
            }
            else
            {
                hr = atu->Add(Tag->I32, IndeterminatePool, BlockSize);
                AllocStatsAccum->Indeterminate++;
                AllocStatsAccum->IndeterminateSize += BlockSize;
            }
        }
    }
    else
    {
        AllocStatsAccum->Indeterminate++;
        AllocStatsAccum->IndeterminateSize += BlockSize;
    }

    return hr;
}


HRESULT
SearchSessionPool(
    PDEBUG_CLIENT Client,
    ULONG Session,
    ULONG TagName,
    FLONG Flags,
    ULONG64 RestartAddr,
    PoolFilterFunc Filter,
    PALLOCATION_STATS AllocStats,
    PVOID Context
    )
/*++

Routine Description:

    Engine to search session pool.

Arguments:

    TagName - Supplies the tag to search for.

    Flags - Supplies 0 if a nonpaged pool search is desired.
            Supplies 1 if a paged pool search is desired.

    RestartAddr - Supplies the address to restart the search from.

    Filter - Supplies the filter routine to use.

    Context - Supplies the user defined context blob.

Return Value:

    HRESULT

--*/
{
    HRESULT     hr;

    PDEBUG_SYMBOLS      Symbols;
    PDEBUG_DATA_SPACES  Data;

    LOGICAL     PhysicallyContiguous;
    ULONG       PoolBlockSize;
    ULONG64     PoolHeader;
    ULONG64     PoolPage;
    ULONG64     StartPage;
    ULONG64     Pool;
    ULONG       Previous;
    ULONG64     PoolStart;
    ULONG64     PoolStartPage;
    ULONG64     PoolPteAddress;
    ULONG64     PoolEnd;
    BOOL        PageReadFailed;
    ULONG64     PagesRead;
    ULONG64     PageReadFailures;
    ULONG64     PageReadFailuresAtEnd;
    ULONG64     LastPageRead;

    ULONG       PoolTypeFlags = Flags & (SEARCH_POOL_NONPAGED | SEARCH_POOL_PAGED);

    ULONG64     NTModuleBase;
    ULONG       PoolHeadTypeID;
    ULONG       SessionHeadTypeID;
    ULONG       HdrSize;

    ULONG64 SessionSpace;

    if ((hr = Client->QueryInterface(__uuidof(IDebugSymbols),
                                     (void **)&Symbols)) != S_OK)
    {
        return hr;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                     (void **)&Data)) != S_OK)
    {
        Symbols->Release();
        return hr;
    }

    if (Session == DEFAULT_SESSION)
    {
        Session = SessionId;
    }

    if ((hr = Symbols->GetSymbolTypeId("NT!_POOL_HEADER", &PoolHeadTypeID, &NTModuleBase)) == S_OK &&
        (hr = Symbols->GetTypeSize(NTModuleBase, PoolHeadTypeID, & HdrSize)) == S_OK &&
        (hr = GetSessionSpace(Session, &SessionSpace, NULL)) == S_OK)
    {
        ULONG           PoolTagOffset, ProcessBilledOffset;
        BOOL            bQuotaWithTag;

        ULONG           ReadSessionId;
        ULONG64         PagedPoolInfo;

        ULONG64         NonPagedPoolBytes;
        ULONG64         NonPagedPoolAllocations;
        ULONG64         NonPagedPoolStart;
        ULONG64         NonPagedPoolEnd;

        ULONG64         PagedPoolPages;
        ULONG64         PagedPoolBytes;
        ULONG64         PagedPoolAllocations;
        ULONG64         PagedPoolStart;
        ULONG64         PagedPoolEnd;

        ULONG           SessionSpaceTypeID;
        ULONG           PagedPoolInfoOffset;

        BOOL                SearchingPaged = FALSE;
        PRTL_BITMAP         PagedPoolAllocationMap = NULL;
        PRTL_BITMAP         EndOfPagedPoolBitmap = NULL;
        ULONG               BusyStart;
        PRTL_BITMAP         PagedPoolLargeSessionAllocationMap = NULL;

        BOOL                Continue = TRUE;

        bQuotaWithTag = (Symbols->GetFieldOffset(NTModuleBase, PoolHeadTypeID, "PoolTag", &PoolTagOffset) == S_OK &&
                         Symbols->GetFieldOffset(NTModuleBase, PoolHeadTypeID, "ProcessBilled", &ProcessBilledOffset) == S_OK &&
                         PoolTagOffset != ProcessBilledOffset);

        // General parser setup and dump MM_SESSION_SPACE structure
        if ((hr = Symbols->GetTypeId(NTModuleBase, "MM_SESSION_SPACE", &SessionSpaceTypeID)) == S_OK &&
            (hr = GetFieldValue(SessionSpace, "nt!MM_SESSION_SPACE", "SessionId", ReadSessionId)) == S_OK &&
            (hr = Symbols->GetFieldOffset(NTModuleBase, SessionSpaceTypeID, "PagedPoolInfo", &PagedPoolInfoOffset)) == S_OK &&
            (InitTypeRead(SessionSpace, nt!MM_SESSION_SPACE) == S_OK)
            //          (hr = OutState.OutputTypeVirtual(SessionSpace + PagedPoolInfoOffset, "NT!_MM_PAGED_POOL_INFO", 0)) == S_OK
            )
        {
            ExtOut("Searching session %ld pool.\n", ReadSessionId);

            // Remaining type output goes to PoolHead reader
        }
        else
        {
            ExtErr("Error getting basic session pool information.\n");
        }

        while (hr == S_OK && Continue)
        {
            ExtOut("\n");

            if (PoolTypeFlags & SEARCH_POOL_NONPAGED)
            {
                NonPagedPoolBytes = ReadField(NonPagedPoolBytes);// NOFIELD
                NonPagedPoolAllocations = ReadField(NonPagedPoolAllocations);// NOFIELD
                if (NonPagedPoolBytes != 0 &&
                    NonPagedPoolAllocations != 0)
                {
                    ExtOut("NonPaged pool: %I64u bytes in %I64u allocations\n",
                                  NonPagedPoolBytes, NonPagedPoolAllocations);
                }

                ExtOut(" NonPaged pool range reader isn't implemented.\n");

                PoolStart = 0;
                PoolEnd = 0;
                SearchingPaged = FALSE;
            }
            else
            {

                PagedPoolBytes = ReadField(PagedPoolBytes); // NOFIELD
                PagedPoolAllocations = ReadField(PagedPoolAllocations); // NOFIELD
                if (PagedPoolBytes != 0 &&
                    PagedPoolAllocations != 0)
                {
                    ExtOut("Paged pool: %I64u bytes in %I64u allocations\n",
                                  PagedPoolBytes, PagedPoolAllocations);

                    PagedPoolPages = ReadField(AllocatedPagedPool); // NOFIELD
                    if (PagedPoolPages != 0)
                    {
                        ExtOut(" Paged Pool Info: %I64u pages allocated\n",
                               PagedPoolPages);
                    }
                }

                PagedPoolStart = ReadField(PagedPoolStart);
                PagedPoolEnd = ReadField(PagedPoolEnd);
                if (PagedPoolStart == 0 || PagedPoolEnd == 0)
                {
                    ExtErr(" Couldn't get PagedPool range.\n");
                }
                else
                {
                    PoolStart = PagedPoolStart;
                    PoolEnd = PagedPoolEnd;
                    SearchingPaged = TRUE;

                    ULONG64     PagedBitMap, EndOfPagedBitMap;

                    PagedBitMap = ReadField(PagedPoolInfo.PagedPoolAllocationMap);
                    EndOfPagedBitMap = ReadField(PagedPoolInfo.EndOfPagedPoolBitmap);

                    if (GetBitMap(Client, PagedBitMap, &PagedPoolAllocationMap) == S_OK &&
                        GetBitMap(Client, EndOfPagedBitMap, &EndOfPagedPoolBitmap) == S_OK)
                    {
                        ULONG   PositionAfterLastAlloc;
                        ULONG   AllocBits;
                        ULONG   UnusedBusyBits;

                        if (RtlCheckBit(EndOfPagedPoolBitmap, EndOfPagedPoolBitmap->SizeOfBitMap - 1))
                        {
                            BusyStart = PagedPoolAllocationMap->SizeOfBitMap;
                            UnusedBusyBits = 0;
                        }
                        else
                        {
                            OSCompat_RtlFindLastBackwardRunClear(
                                EndOfPagedPoolBitmap,
                                EndOfPagedPoolBitmap->SizeOfBitMap - 1,
                                &PositionAfterLastAlloc);

                            BusyStart = RtlFindSetBits(PagedPoolAllocationMap, 1, PositionAfterLastAlloc);
                            if (BusyStart < PositionAfterLastAlloc || BusyStart == -1)
                            {
                                BusyStart = PagedPoolAllocationMap->SizeOfBitMap;
                                UnusedBusyBits = 0;
                            }
                            else
                            {
                                UnusedBusyBits = PagedPoolAllocationMap->SizeOfBitMap - BusyStart;
                            }
                        }

                        AllocBits = RtlNumberOfSetBits(PagedPoolAllocationMap) - UnusedBusyBits;

                        AllocStats->AllocatedPages += AllocBits;
                        AllocStats->FreePages += (BusyStart - AllocBits);
                        AllocStats->ExpansionPages += UnusedBusyBits;


                        PagedBitMap = ReadField(PagedPoolInfo.PagedPoolLargeSessionAllocationMap); // NOFIELD
                        if (PagedBitMap != 0 &&
                            GetBitMap(Client, PagedBitMap, &PagedPoolLargeSessionAllocationMap) == S_OK)
                        {
                            ULONG AllocStart, AllocEnd;
                            ULONG LargeAllocs = RtlNumberOfSetBits(PagedPoolLargeSessionAllocationMap);

                            AllocStats->LargeAllocs += LargeAllocs;

                            AllocStart = 0;
                            AllocEnd = -1;

                            while (LargeAllocs > 0)
                            {
                                AllocStart = RtlFindSetBits(PagedPoolLargeSessionAllocationMap, 1, AllocStart);
                                if (AllocStart >= AllocEnd+1 && AllocStart != -1)
                                {
                                    AllocEnd = RtlFindSetBits(EndOfPagedPoolBitmap, 1, AllocStart);
                                    if (AllocEnd >= AllocStart && AllocEnd != -1)
                                    {
                                        AllocStats->LargePages += AllocEnd - AllocStart + 1;
                                        AllocStart++;
                                        LargeAllocs--;
                                    }
                                    else
                                    {
                                        ExtWarn(" Warning Large Pool Allocation Map or End Of Pool Map is invalid.\n");
                                        break;
                                    }
                                }
                                else
                                {
                                    ExtWarn(" Warning Large Pool Allocation Map is invalid.\n");
                                    break;
                                }
                            }

                            if (LargeAllocs != 0)
                            {
                                ExtWarn(" %lu large allocations weren't calculated.\n", LargeAllocs);
                                AllocStats->LargeAllocs -= LargeAllocs;
                            }
                        }
                    }
                }
            }

            if (hr == S_OK)
            {
                ExtOut("Searching %s pool (0x%p : 0x%p) for Tag: %c%c%c%c\r\n\n",
                       ((PoolTypeFlags & SEARCH_POOL_NONPAGED) ? "NonPaged" : "Paged"),
                       PoolStart,
                       PoolEnd,
                       TagName,
                       TagName >> 8,
                       TagName >> 16,
                       TagName >> 24);

                PageReadFailed = FALSE;
                PoolStartPage = PAGE_ALIGN64(PoolStart);
                PoolPage = PoolStart;
                PagesRead = 0;
                PageReadFailures = 0;
                PageReadFailuresAtEnd = 0;
                LastPageRead = PAGE_ALIGN64(PoolPage);

                while (PoolPage < PoolEnd && hr == S_OK)
                {
                    Pool        = PAGE_ALIGN64(PoolPage);
                    StartPage   = Pool;
                    Previous    = 0;

                    if (Session != CURRENT_SESSION)
                    {
                        ExtOut("Currently only searching the current session is supported.\n");
                        PoolPage = PoolEnd;
                        break;
                    }

                    if (CheckControlC())
                    {
                        ExtOut("\n...terminating - searched pool to 0x%p\n",
                                      Pool-1);
                        hr = E_ABORT;
                        break;
                    }

                    if (SearchingPaged)
                    {
                        if (PagedPoolAllocationMap != NULL)
                        {
                            ULONG   StartPosition, EndPosition;

                            StartPosition = (ULONG)((Pool - PoolStartPage) >> PageShift);
                            EndPosition = RtlFindSetBits(EndOfPagedPoolBitmap, 1, StartPosition);
                            if (EndPosition < StartPosition) EndPosition = -1;

                            if (!RtlCheckBit(PagedPoolAllocationMap, StartPosition))
                            {
                                if (PageReadFailed)
                                {
                                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                    {
                                        ExtWarn(" to 0x%p\n", StartPage-1);
                                    }

                                    PageReadFailures += (StartPage - LastPageRead) >> PageShift;
                                    LastPageRead = StartPage;
                                    PageReadFailed = FALSE;
                                }

                                if (EndPosition == -1)
                                {
                                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                    {
                                        ExtWarn("No remaining pool allocations from 0x%p to 0x%p.\n", Pool, PoolEnd);
                                    }

                                    PoolPage = PoolEnd;
                                }
                                else
                                {
                                    PoolPage = PoolStartPage + (((ULONG64)EndPosition + 1) << PageShift);
                                }

                                continue;
                            }
                            else if (EndOfPagedPoolBitmap != NULL)
                            {
                                if (PagedPoolLargeSessionAllocationMap != NULL &&
                                    RtlCheckBit(PagedPoolLargeSessionAllocationMap, StartPosition))
                                {
                                    if (EndPosition == -1)
                                    {
                                        ExtWarn("No end to large pool allocation @ 0x%p found.\n", Pool);
                                        PoolPage = PoolEnd;
                                    }
                                    else
                                    {
                                        EndPosition++;

                                        if (PageReadFailed)
                                        {
                                            if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                            {
                                                ExtWarn(" to 0x%p\n", StartPage-1);
                                            }

                                            PageReadFailures += (StartPage - LastPageRead) >> PageShift;
                                            LastPageRead = StartPage;
                                            PageReadFailed = FALSE;
                                        }

                                        PoolPage = PoolStartPage + (((ULONG64)EndPosition) << PageShift);

                                        if (Flags & SEARCH_POOL_PRINT_LARGE)
                                        {
                                            ExtOut("0x%p size: %5I64x  %s UNTAGGED Large\n",
                                                   StartPage,
                                                   PoolPage - StartPage,
                                                   ((RtlAreBitsSet(PagedPoolAllocationMap, StartPosition, EndPosition - StartPosition)) ?
                                                    "(Allocated)" :
                                                ((RtlAreBitsClear(PagedPoolAllocationMap, StartPosition, EndPosition - StartPosition)) ?
                                                 "(! Free !) " :
                                                "(!! Partially Allocated !!)"))
                                                   );
                                        }

                                        if (Flags & SEARCH_POOL_LARGE_ONLY)
                                        {
                                            // Quickly locate next large allocation
                                            StartPosition = RtlFindSetBits(PagedPoolLargeSessionAllocationMap, 1, EndPosition);

                                            if (StartPosition < EndPosition || StartPosition == -1)
                                            {
                                                ExtVerb(" No large allocations found after 0x%p\n", PoolPage-1);
                                                PoolPage = PoolEnd;
                                            }
                                            else
                                            {
                                                PoolPage = PoolStartPage + (((ULONG64)StartPosition) << PageShift);
                                            }
                                        }
                                    }

                                    continue;
                                }
                                else if (EndPosition == -1)
                                {
                                    if (PageReadFailed)
                                    {
                                        if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                        {
                                            ExtWarn(" to 0x%p\n", StartPage-1);
                                        }

                                        PageReadFailures += (StartPage - LastPageRead) >> PageShift;
                                        LastPageRead = StartPage;
                                        PageReadFailed = FALSE;
                                    }

                                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                    {
                                        ExtWarn("No remaining pool allocations from 0x%p to 0x%p.\n", Pool, PoolEnd);
                                    }

                                    PoolPage = PoolEnd;

                                    continue;
                                }
                                else if (StartPosition >= BusyStart)
                                {
                                    ExtWarn("Found end of allocation at %lu within expansion pages starting at %lu.\n",
                                            EndPosition, BusyStart);
                                }
                            }
                        }
                    }

                    if (Flags & SEARCH_POOL_LARGE_ONLY)
                    {
                        ExtErr(" Unable to identify large pages.  Terminating search at 0x%p.\n", StartPage);
                        PoolPage = PoolEnd;
                        hr = E_FAIL;
                        continue;
                    }

                    // Search page for small allocations
                    while (PAGE_ALIGN64(Pool) == StartPage && hr == S_OK)
                    {
                        DEBUG_VALUE HdrPoolTag, BlockSize, PreviousSize, AllocatorBackTraceIndex, PoolTagHash;
                        ULONG PoolType;


                        if ((hr = GetFieldValue(Pool, "nt!_POOL_HEADER", "PoolTag", HdrPoolTag.I32)) != S_OK)
                        {
                            if (hr != S_OK)
                            {
                                PSTR    psz;

                                ExtErr("Type read error %lx @ 0x%p.\n", hr, Pool);

                                ExtWarn("Failed to read an allocated page @ 0x%p.\n", StartPage);

                                if (hr == MEMORY_READ_ERROR)
                                {
                                    hr = S_OK;
                                }
                                else
                                {
                                    ExtOut("\n...terminating - searched pool to 0x%p\n",
                                           Pool);
                                    hr = E_ABORT;
                                }

                                if (hr == E_ABORT)
                                {
                                    break;
                                }
                            }

                            if (!PageReadFailed)
                            {
                                if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                {
                                    ExtWarn(" Couldn't read pool from 0x%p", Pool);
                                }

                                PagesRead += (StartPage - LastPageRead) / PageSize;
                                LastPageRead = StartPage;
                                PageReadFailed = TRUE;
                            }
#if 0
                            if ((hr = GetNextResidentAddress(Client,
                                                             Session,
                                                             StartPage + PageSize,
                                                             PoolEnd,
                                                             &PoolPage,
                                                             NULL)) != S_OK)
#endif
                            if ((PoolPage = GetNextResidentAddress(StartPage + PageSize,
                                                                   PoolEnd)) == 0)
                            {
                                if (hr != E_ABORT)
                                {
                                    hr = S_OK;
                                }

                                if (Flags & SEARCH_POOL_PRINT_UNREAD)
                                {
                                    ExtWarn(" to 0x%p.\n", PoolEnd);
                                    ExtWarn("No remaining resident page found.\n");
                                }

                                PageReadFailuresAtEnd = (PoolEnd - LastPageRead) / PageSize;
                                PageReadFailures += PageReadFailuresAtEnd;
                                LastPageRead = PoolEnd;
                                PageReadFailed = FALSE;

                                PoolPage = PoolEnd;
                            }

                            break;
                        }

                        if (PageReadFailed)
                        {
                            if (Flags & SEARCH_POOL_PRINT_UNREAD)
                            {
                                ExtWarn(" to 0x%p\n", StartPage-1);
                            }

                            PageReadFailures += (StartPage - LastPageRead) / PageSize;
                            LastPageRead = StartPage;
                            PageReadFailed = FALSE;
                        }

                        if (GetFieldValue(Pool, "nt!_POOL_HEADER", "BlockSize", BlockSize.I32) != S_OK)
                        {
                            ExtErr("Error reading BlockSize @ 0x%p.\n", Pool);
                            break;
                        }

                        if ((BlockSize.I32 << POOL_BLOCK_SHIFT) > PageSize)//POOL_PAGE_SIZE)
                        {
                            ExtVerb("Bad allocation size @ 0x%p, too large\n", Pool);
                            break;
                        }

                        if (BlockSize.I32 == 0)
                        {
                            ExtVerb("Bad allocation size @ 0x%p, zero is invalid\n", Pool);
                            break;
                        }

                        if (GetFieldValue(Pool, "nt!_POOL_HEADER", "PreviousSize", PreviousSize.I32) != S_OK ||
                            PreviousSize.I32 != Previous)
                        {
                            ExtVerb("Bad previous allocation size @ 0x%p, last size was 0x%lx\n", Pool, Previous);
                            break;
                        }

                        Filter(Pool,
                               TagName,
                               Pool,
                               &HdrPoolTag,
                               BlockSize.I32,
                               bQuotaWithTag,
                               Context
                               );

                        Previous = BlockSize.I32;
                        Pool += (Previous << POOL_BLOCK_SHIFT);

                        if ( CheckControlC())
                        {
                            ExtOut("\n...terminating - searched pool to 0x%p\n",
                                   PoolPage-1);
                            hr = E_ABORT;
                        }
                    }

                    if (hr == S_OK)
                    {
                        PoolPage = (PoolPage + PageSize);
                    }
                }

                if (PageReadFailed)
                {
                    if (Flags & SEARCH_POOL_PRINT_UNREAD)
                    {
                        ExtWarn(" to 0x%p\n", StartPage-1);
                    }

                    PageReadFailuresAtEnd = (PoolPage - LastPageRead) / PageSize;
                    PageReadFailures += PageReadFailuresAtEnd;
                    PageReadFailed = FALSE;
                }
                else
                {
                    PagesRead += (PoolPage - LastPageRead) / PageSize;
                }

                ExtOut(" Pages Read: %I64d\n"
                       "   Failures: %I64d  (%I64d at end of search)\n",
                       PagesRead, PageReadFailures, PageReadFailuresAtEnd);
            }

            if (PoolTypeFlags == (SEARCH_POOL_NONPAGED | SEARCH_POOL_PAGED))
            {
                PoolTypeFlags = SEARCH_POOL_PAGED;
            }
            else
            {
                Continue = FALSE;
            }
        }

        if (PagedPoolAllocationMap != NULL) FreeBitMap(PagedPoolAllocationMap);
        if (EndOfPagedPoolBitmap != NULL) FreeBitMap(EndOfPagedPoolBitmap);
        if (PagedPoolLargeSessionAllocationMap != NULL) FreeBitMap(PagedPoolLargeSessionAllocationMap);
    }

    return hr;
}


HRESULT
GetTagFilter(
    PDEBUG_CLIENT Client,
    PCSTR *pArgs,
    PDEBUG_VALUE TagFilter
    )
{
    HRESULT hr;

    PCSTR   args;
    PCSTR   TagArg;

    ULONG   TagLen;
    CHAR    TagEnd;
    ULONG   WildCardPos;


    TagArg = args = *pArgs;
    TagFilter->Type = DEBUG_VALUE_INVALID;

    do
    {
        args++;
    } while (*args != '\0' && !isspace(*args));

    while (isspace(*args)) args++;

    if (TagArg[0] == '0' && TagArg[1] == 'x')
    {
        TagFilter->I64 = GetExpression(TagArg);
    }
    else
    {
        if (TagArg[0] == '`' || TagArg[0] == '\'' || TagArg[0] == '\"')
        {
            TagEnd = TagArg[0];
            TagArg++;
            args = TagArg;

            while (args - TagArg < 4 &&
                   *args != '\0' &&
                   *args != TagEnd)
            {
                args++;
            }
            TagLen = (ULONG)(args - TagArg);
            if (*args == TagEnd) args++;
            while (isspace(*args)) args++;
        }
        else
        {
            TagLen = (ULONG)(args - TagArg);
            TagEnd = '\0';
        }

        if (TagLen == 0 ||
            (TagLen < 4 &&
             TagArg[TagLen-1] != '*'
            ) ||
            (TagLen >= 4 &&
             TagArg[4] != '\0' &&
             !isspace(TagArg[4]) &&
             (TagArg[4] != TagEnd || (TagArg[5] != '\0' && !isspace(TagArg[5])))
            )
           )
        {
            ExtErr(" Invalid Tag filter.\n");
            hr = E_INVALIDARG;
        }
        else
        {
            hr = S_OK;

            for (WildCardPos = 0; WildCardPos < TagLen; WildCardPos++)
            {
                if (TagArg[WildCardPos] == '*')
                {
                    ULONG NewTagLen = WildCardPos + 1;
                    if (NewTagLen < TagLen)
                    {
                        ExtWarn(" Ignoring %lu characters after * in Tag.\n",
                                       TagLen - NewTagLen);
                    }
                    TagLen = NewTagLen;
                    // loop will terminate
                }
            }

            if (TagLen < 4)
            {
                TagFilter->I32 = '    ';
                while (TagLen-- > 0)
                {
                    TagFilter->RawBytes[TagLen] = TagArg[TagLen];
                }
            }
            else
            {
                TagFilter->I32 = TagArg[0] | (TagArg[1] << 8) | (TagArg[2] << 16) | (TagArg[3] << 24);
            }
            TagFilter->Type = DEBUG_VALUE_INT32;
        }
    }

    if (hr == S_OK)
    {
        *pArgs = args;
    }

    return hr;
}


HRESULT
OutputAllocStats(
    PALLOCATION_STATS AllocStats,
    BOOL PartialResults
    )
{
    ExtOut("\n"
           " %I64u bytes in %lu allocated pages\n"
           " %I64u bytes in %lu large allocations\n"
           " %I64u bytes in %lu free pages\n"
           " %I64u bytes available in %lu expansion pages\n"
           "\n"
           "%s found (small allocations only): %lu\n"
           "  Allocated: %I64u bytes in %lu entries\n"
           "  Free: %I64u bytes in %lu entries\n"
           "  Undetermined: %I64u bytes in %lu entries\n",
           ((ULONG64) AllocStats->AllocatedPages) << PageShift,
           AllocStats->AllocatedPages,
           ((ULONG64) AllocStats->LargePages) << PageShift,
           AllocStats->LargeAllocs,
           ((ULONG64) AllocStats->FreePages) << PageShift,
           AllocStats->FreePages,
           ((ULONG64) AllocStats->ExpansionPages) << PageShift,
           AllocStats->ExpansionPages,
           ((PartialResults) ? "PARTIAL entries" : "Entries"),
           AllocStats->Allocated + AllocStats->Free + AllocStats->Indeterminate,
           ((ULONG64)AllocStats->AllocatedSize) << POOL_BLOCK_SHIFT,
           AllocStats->Allocated,
           ((ULONG64)AllocStats->FreeSize) << POOL_BLOCK_SHIFT,
           AllocStats->Free,
           ((ULONG64)AllocStats->IndeterminateSize) << POOL_BLOCK_SHIFT,
           AllocStats->Indeterminate
           );
    return S_OK;
}


DECLARE_API( spoolfind )
{
    HRESULT         hr = S_OK;

    INIT_API(  );

    BOOL            BadArg = FALSE;
    ULONG           RemainingArgIndex;

    DEBUG_VALUE     TagName = { 0, DEBUG_VALUE_INVALID };

    FLONG           Flags = 0;
    DEBUG_VALUE     Session = { DEFAULT_SESSION, DEBUG_VALUE_INVALID };

    while (isspace(*args)) args++;

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'f':
                        Flags |= SEARCH_POOL_PRINT_UNREAD;
                        args++;
                        break;

                    case 'l':
                        Flags |= SEARCH_POOL_PRINT_LARGE;
                        args++;
                        break;

                    case 'n':
                        Flags |= SEARCH_POOL_NONPAGED;
                        args++;
                        break;

                    case 'p':
                        Flags |= SEARCH_POOL_PAGED;
                        args++;
                        break;

                    case 's':
                        if (Session.Type != DEBUG_VALUE_INVALID)
                        {
                            ExtErr("Session argument specified multiple times.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            args++;
                            hr = GetExpressionEx(args, &Session.I64, &args);
                            if (hr == FALSE)
                            {
                                ExtErr("Invalid Session.\n");
                            }
                        }
                        break;

                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (TagName.Type == DEBUG_VALUE_INVALID)
            {
                hr = GetTagFilter(Client, &args, &TagName);
            }
            else
            {
                ExtErr("Unrecognized argument @ %s\n", args);
                BadArg = TRUE;
            }
        }
    }

    if (!BadArg && hr == S_OK)
    {
        if (TagName.Type == DEBUG_VALUE_INVALID)
        {
            if (Flags & SEARCH_POOL_PRINT_LARGE)
            {
                TagName.I32 = '   *';
                Flags |= SEARCH_POOL_LARGE_ONLY;
            }
            else
            {
                ExtErr("Missing Tag.\n");
                hr = E_INVALIDARG;
            }
        }
    }

    if (BadArg || hr != S_OK)
    {
        if (*args == '?')
        {
            ExtOut("spoolfind is like !kdexts.poolfind, but for the SessionId specified.\n"
                          "\n");
        }

        ExtOut("Usage: spoolfind [-lnpf] [-s SessionId] Tag\n"
               "    -f - show read failure ranges\n"
               "    -l - show large allocations\n"
               "    -n - show non-paged pool\n"
               "    -p - show paged pool\n"
               "\n"
               "    Tag - Pool tag to search for\n"
               "            Can be 4 character string or\n"
               "             hex value in 0xXXXX format\n"
               "\n"
               "    SessionId - session to dump\n"
               "            Special SessionId values:\n"
               "             -1 - current session\n"
               "             -2 - last !session SessionId (default)\n"
               );
    }
    else
    {
        ALLOCATION_STATS    AllocStats = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

        if ((Flags & (SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED)) == 0)
        {
            Flags |= SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED;
        }

        if (Session.Type == DEBUG_VALUE_INVALID)
        {
            Session.I32 = DEFAULT_SESSION;
        }

        hr = SearchSessionPool(Client,
                               Session.I32, TagName.I32, Flags,
                               0,
                               CheckPrintAndAccumFilter, &AllocStats, &AllocStats);

        if (hr == S_OK || hr == E_ABORT)
        {
            OutputAllocStats(&AllocStats, (hr != S_OK));
        }
        else
        {
            ExtWarn("SearchSessionPool returned %lx\n", hr);
        }
    }

    return hr;
}


DECLARE_API( spoolsum )
{
    HRESULT             hr = S_OK;

    INIT_API( );

    ULONG               RemainingArgIndex;

    FLONG               Flags = 0;
    DEBUG_VALUE         Session = { DEFAULT_SESSION, DEBUG_VALUE_INVALID };

    while (isspace(*args)) args++;

    while (hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            if (*args == '\0' || isspace(*args)) hr = E_INVALIDARG;

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'f':
                        Flags |= SEARCH_POOL_PRINT_UNREAD;
                        args++;
                        break;

                    case 'n':
                        Flags |= SEARCH_POOL_NONPAGED;
                        args++;
                        break;

                    case 'p':
                        Flags |= SEARCH_POOL_PAGED;
                        args++;
                        break;

                    case 's':
                        if (Session.Type != DEBUG_VALUE_INVALID)
                        {
                            ExtErr("Session argument specified multiple times.\n");
                            hr = E_INVALIDARG;
                        }
                        else
                        {
                            args++;
                            hr = GetExpressionEx(args, &Session.I64, &args);
                            if (hr == FALSE)
                            {
                                ExtErr("Invalid Session.\n");
                            }
                        }
                        break;

                    default:
                        hr = E_INVALIDARG;
                        break;
                }

                if (hr != S_OK) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (Session.Type == DEBUG_VALUE_INVALID)
            {
                hr = GetExpressionEx(args, &Session.I64, &args);
                if (hr == FALSE)
                {
                    ExtErr("Invalid Session.\n");
                }
            }
            else
            {
                ExtErr("Unrecognized argument @ %s\n", args);
                hr = E_INVALIDARG;
            }
        }
    }

    if (hr != S_OK)
    {
        if (*args == '?')
        {
            ExtOut("spoolsum summarizes session pool information for SessionId specified.\n"
                          "\n");
            hr = S_OK;
        }

        ExtOut("Usage: spoolsum [-fnp] [[-s] SessionId]\n"
               "    f - show read failure ranges\n"
               "    n - show non-paged pool\n"
               "    p - show paged pool (Default)\n"
               "\n"
               "    SessionId - session to dump\n"
               "            Special SessionId values:\n"
               "             -1 - current session\n"
               "             -2 - last !session SessionId (default)\n"
               );
    }
    else
    {
        ALLOCATION_STATS    AllocStats = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

        if ((Flags & (SEARCH_POOL_PAGED | SEARCH_POOL_NONPAGED)) == 0)
        {
            Flags |= SEARCH_POOL_PAGED;
        }

        hr = SearchSessionPool(Client,
                               DEFAULT_SESSION, '   *', Flags,
                               0,
                               AccumAllFilter, &AllocStats, &AllocStats);

        if (hr == S_OK || hr == E_ABORT)
        {
            OutputAllocStats(&AllocStats, (hr != S_OK));
        }
        else
        {
            ExtWarn("SearchSessionPool returned %lx\n", hr);
        }
    }

    return hr;
}


DECLARE_API( spoolused )
{
    HRESULT         hr = S_OK;

    INIT_API( );

    BOOL            BadArg = FALSE;
    ULONG           RemainingArgIndex;

    DEBUG_VALUE     TagName = { 0, DEBUG_VALUE_INVALID };

    BOOL            NonPagedUsage = FALSE;
    BOOL            PagedUsage = FALSE;
    BOOL            AllocSort = FALSE;
    DEBUG_VALUE     Session = { DEFAULT_SESSION, DEBUG_VALUE_INVALID };

    while (isspace(*args)) args++;

    while (!BadArg && hr == S_OK)
    {
        while (isspace(*args)) args++;

        if (*args == '-')
        {
            // Process switches

            args++;
            BadArg = (*args == '\0' || isspace(*args));

            while (*args != '\0' && !isspace(*args))
            {
                switch (tolower(*args))
                {
                    case 'a':
                        AllocSort = TRUE;
                        args++;
                        break;

                    case 'n':
                        NonPagedUsage = TRUE;
                        args++;
                        break;

                    case 'p':
                        PagedUsage = TRUE;
                        args++;
                        break;

                    case 's':
                        if (Session.Type != DEBUG_VALUE_INVALID)
                        {
                            ExtErr("Session argument specified multiple times.\n");
                            BadArg = TRUE;
                        }
                        else
                        {
                            args++;
                            hr = GetExpressionEx(args, &Session.I64, &args);
                            if (hr == FALSE)
                            {
                                ExtErr("Invalid Session.\n");
                            }
                        }
                        break;

                    default:
                        BadArg = TRUE;
                        break;
                }

                if (BadArg) break;
            }
        }
        else
        {
            if (*args == '\0') break;

            if (TagName.Type == DEBUG_VALUE_INVALID)
            {
                hr = GetTagFilter(Client, &args, &TagName);
            }
            else
            {
                ExtErr("Unrecognized argument @ %s\n", args);
                BadArg = TRUE;
            }
        }
    }

    if (BadArg || hr != S_OK)
    {
        if (*args == '?')
        {
            ExtOut("spoolused is like !kdexts.poolused, but for the SessionId specified.\n"
                          "\n");
        }

        ExtOut("Usage: spoolused [-anp] [-s SessionId] [Tag]\n"
               "    -a - sort by allocation size (Not Implemented)\n"
               "    -n - show non-paged pool\n"
               "    -p - show paged pool\n"
               "\n"
               "    SessionId - session to dump\n"
               "            Special SessionId values:\n"
               "             -1 - current session\n"
               "             -2 - last !session SessionId (default)\n"
               "\n"
               "    Tag - Pool tag filter\n"
               "            Can be 4 character string or\n"
               "             hex value in 0xXXXX format\n"
               );
    }
    else
    {
        if (!NonPagedUsage && !PagedUsage)
        {
            NonPagedUsage = TRUE;
            PagedUsage = TRUE;
        }

        if (Session.Type == DEBUG_VALUE_INVALID)
        {
            Session.I32 = DEFAULT_SESSION;
        }

        if (TagName.Type == DEBUG_VALUE_INVALID)
        {
            TagName.I32 = '   *';
        }

        AccumTagUsage   atu(TagName.I32);

        if (atu.Valid() != S_OK)
        {
            ExtErr("Error: failed to prepare tag usage reader.\n");
            hr = E_FAIL;
        }

        if (hr == S_OK && NonPagedUsage)
        {
            hr = SearchSessionPool(Client,
                                   Session.I32, TagName.I32, SEARCH_POOL_NONPAGED,
                                   0,
                                   AccumTagUsageFilter, &atu, &atu);

            if (hr == S_OK || hr == E_ABORT)
            {
                atu.OutputResults(AllocSort);
            }
            else
            {
                ExtWarn("SearchSessionPool returned %lx\n", hr);
            }
        }

        if (hr == S_OK && PagedUsage)
        {
            if (NonPagedUsage) atu.Reset();

            hr = SearchSessionPool(Client,
                                   Session.I32, TagName.I32, SEARCH_POOL_PAGED,
                                   0,
                                   AccumTagUsageFilter, &atu, &atu);

            if (hr == S_OK || hr == E_ABORT)
            {
                atu.OutputResults(AllocSort);
            }
            else
            {
                ExtWarn("SearchSessionPool returned %lx\n", hr);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\srb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    srb.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


PCHAR SrbFunctionTable[] =
{
 "SRB_FUNCTION_EXECUTE_SCSI",       // 0x00
 "SRB_FUNCTION_CLAIM_DEVICE",       // 0x01
 "SRB_FUNCTION_IO_CONTROL",         // 0x02
 "SRB_FUNCTION_RECEIVE_EVENT",      // 0x03
 "SRB_FUNCTION_RELEASE_QUEUE",      // 0x04
 "SRB_FUNCTION_ATTACH_DEVICE",      // 0x05
 "SRB_FUNCTION_RELEASE_DEVICE",     // 0x06
 "SRB_FUNCTION_SHUTDOWN",           // 0x07
 "SRB_FUNCTION_FLUSH",              // 0x08
 "??9",                             // 0x09
 "??a",                             // 0x0a
 "??b",                             // 0x0b
 "??c",                             // 0x0c
 "??d",                             // 0x0d
 "??e",                             // 0x0e
 "??f",                             // 0x0f
 "SRB_FUNCTION_ABORT_COMMAND",      // 0x10
 "SRB_FUNCTION_RELEASE_RECOVERY",   // 0x11
 "SRB_FUNCTION_RESET_BUS",          // 0x12
 "SRB_FUNCTION_RESET_DEVICE",       // 0x13
 "SRB_FUNCTION_TERMINATE_IO",       // 0x14
 "SRB_FUNCTION_FLUSH_QUEUE",        // 0x15
 "SRB_FUNCTION_REMOVE_DEVICE",      // 0x16
 "SRB_FUNCTION_WMI",                // 0x17
 "SRB_FUNCTION_LOCK_QUEUE",         // 0x18
 "SRB_FUNCTION_UNLOCK_QUEUE"        // 0x19
};

#define SRB_COMMAND_MAX 0x19


DECLARE_API( srb )

/*++

Routine Description:

    Dumps the specified SCSI request block.

Arguments:

    Ascii bits for address.

Return Value:

    None.

--*/

{
    PUCHAR              buffer;
    PCHAR               functionName;
    UCHAR               i;
    ULONG64             srbToDump=0;
    ULONG               SrbFlags, Function, SrbStatus, CdbLength;

    srbToDump = GetExpression(args);
    if (GetFieldValue( srbToDump, 
                       "SCSI_REQUEST_BLOCK",
                       "SrbFlags",
                       SrbFlags)) {
        dprintf("%08p: Could not read Srb\n", srbToDump);
        return E_INVALIDARG;
    }

    if (SrbFlags & SRB_FLAGS_ALLOCATED_FROM_ZONE) {
        dprintf("Srb %08p is from zone\n", srbToDump);
    }
    else {
        dprintf("Srb %08p is from pool\n", srbToDump);
    }

    InitTypeRead(srbToDump, nt!_SCSI_REQUEST_BLOCK);
    if ((Function = (ULONG) ReadField(Function)) > SRB_COMMAND_MAX) {
        functionName = "Unknown function";
    }
    else {
        functionName = SrbFunctionTable[Function];
    }

    dprintf("%s: Path %x, Tgt %x, Lun %x, Tag %x, SrbStat %x, ScsiStat %x\n",
            functionName,
            (ULONG) ReadField(PathId),
            (ULONG) ReadField(TargetId),
            (ULONG) ReadField(Lun),
            (ULONG) ReadField(QueueTag),
            (SrbStatus = (ULONG) ReadField(SrbStatus)),
            (ULONG) ReadField(ScsiStatus));

    dprintf("OrgRequest %08p SrbExtension %08p TimeOut %08lx SrbFlags %08lx\n",
            ReadField(OriginalRequest),
            ReadField(SrbExtension),
            (ULONG) ReadField(TimeOutValue),
            (ULONG) ReadField(SrbFlags));

    if (SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE) {
        dprintf("Queue Enable, ");
    }
    if (SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {
        dprintf("No Disconnect, ");
    }
    if (SrbFlags & SRB_FLAGS_DISABLE_SYNCH_TRANSFER) {
        dprintf("No Sync, ");
    }
    if (SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) {
        dprintf("Bypass Queue, ");
    }
    if (SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) {
        dprintf("Disable Sense, ");
    }
    if (SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) {
        dprintf("No freeze, ");
    }
    if (SrbFlags & SRB_FLAGS_ADAPTER_CACHE_ENABLE) {
        dprintf("Cache Enable, ");
    }
    if (SrbFlags & SRB_FLAGS_IS_ACTIVE) {
        dprintf("Is active, ");
    }

    if (Function == SRB_FUNCTION_EXECUTE_SCSI) {
        dprintf("\n%2d byte command with %s: ",
                (CdbLength=(ULONG) ReadField(CdbLength)),
                (SrbFlags & SRB_FLAGS_DATA_IN)  ? "data transfer in" :
                (SrbFlags & SRB_FLAGS_DATA_OUT) ? "data transfer out" :
                                                      "no data transfer");
        for (i = 0; i < CdbLength; i++) {
            CHAR Buff[20];
            sprintf(Buff, "Cdb[%d]", i);
            dprintf("%2x ", (ULONG) GetShortField(0, Buff, 0));
        }
    }
    dprintf("\n");

    if (SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        ULONG length = (ULONG) ReadField(SenseInfoBufferLength);
        ULONG64 SenseInfoBuffer;

        dprintf(" Autosense valid: ");

        if (length == 0) {
            dprintf("Sense info length is zero\n");
        } else if (length > 64) {
            dprintf("Length is too big 0x%x ", length);
            length = 64;
        }

        buffer = (PUCHAR)LocalAlloc(LPTR, length);
        if (buffer == NULL) {
            dprintf("Cannot alloc memory\n");
            return E_INVALIDARG;
        }

        if (!ReadMemory((SenseInfoBuffer = ReadField(SenseInfoBuffer)), 
                        buffer,
                        length, NULL )) {
            dprintf("%08p: Could not read sense info\n", SenseInfoBuffer);
            LocalFree(buffer);
            return  E_INVALIDARG;
        }

        for (i = 0; i < length; i++) {
            if(CheckControlC()) {
                dprintf("^C");
                break;
            }

            dprintf("%2x ", buffer[i]);
        }
        dprintf("\n");

        LocalFree(buffer);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\time.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    time.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

VOID
FileTimeToString(
    IN LARGE_INTEGER Time,
    IN BOOLEAN TimeZone,
    OUT PCHAR Buffer
    );

ULONG64
DumpKTimer(
    IN ULONG64 pTimer,
    IN ULONGLONG InterruptTimeOffset,
    IN OPTIONAL ULONG64 Blink
    )
{
    ULONG64         Displacement;
    CHAR            Buff[256];
    ULONG           Result;
    ULONG64         NextThread;
    LARGE_INTEGER   SystemTime;
    ULONG           Period, Off;
    LARGE_INTEGER   Due;
    ULONG64         Dpc, DeferredRoutine, WaitList_Flink, Timer_Flink, Timer_Blink;

    if ( GetFieldValue(pTimer, "nt!_KTIMER", "DueTime.QuadPart", Due.QuadPart) ) {
        dprintf("Unable to get contents of Timer @ %p\n", pTimer );
        return(0);
    }

    SystemTime.QuadPart = Due.QuadPart + InterruptTimeOffset;
    if (SystemTime.QuadPart < 0) {
        strcpy(Buff, "         NEVER         ");
    } else {
        FileTimeToString(SystemTime, FALSE, Buff);
    }

    GetFieldValue(pTimer, "nt!_KTIMER", "Period", Period);
    GetFieldValue(pTimer, "nt!_KTIMER", "Dpc", Dpc);
    GetFieldValue(pTimer, "nt!_KTIMER", "Header.WaitListHead.Flink", WaitList_Flink);
    GetFieldValue(pTimer, "nt!_KTIMER", "TimerListEntry.Flink", Timer_Flink);
    GetFieldValue(pTimer, "nt!_KTIMER", "TimerListEntry.Blink", Timer_Blink);

    dprintf("%c %08lx %08lx [%s]  ",
            (Period != 0) ? 'P' : ' ',
            Due.LowPart,
            Due.HighPart,
            Buff);

    if (Dpc != 0) {
        if (GetFieldValue(Dpc, "nt!_KDPC", "DeferredRoutine", DeferredRoutine)) {
            dprintf("Unable to get contents of DPC @ %p\n", Dpc);
            return(0);
        }
        // dprintf("p(%p)", DeferredRoutine);
        GetSymbol(DeferredRoutine,
                  Buff,
                  &Displacement);
        dprintf("%s",Buff);
        if (Displacement != 0) {
            dprintf("+%1p ", Displacement);
        } else {
            dprintf(" ");
        }
    }

    //
    // List all the threads
    //
    NextThread = WaitList_Flink;
    GetFieldOffset("nt!_KTIMER", "Header.WaitListHead", &Off);
    while (WaitList_Flink && (NextThread != pTimer+Off)) {
        ULONG64 Flink;
        ULONG64 Thread=0;

        if (GetFieldValue(NextThread, "nt!_KWAIT_BLOCK", "Thread", Thread)) {
            dprintf("Unable to get contents of waitblock @ %p\n", NextThread);
        } else {
            dprintf("thread %p ",Thread);
        }

        if (GetFieldValue(NextThread,
                          "nt!_LIST_ENTRY",
                          "Flink",
                          Flink)) {
            dprintf("Unable to read next WaitListEntry @ %p\n",NextThread);
            break;
        }
        NextThread = Flink;
    }

    dprintf("\n");

    if (Blink &&
        (Timer_Blink != Blink)) {
        dprintf("   Timer at %p has wrong Blink! (Blink %08p, should be %08p)\n",
                pTimer,
                Timer_Blink,
                Blink);
    }

    if (Timer_Flink == 0) {
        dprintf("   Timer at %p has been zeroed! (Flink %08p, Blink %08p)\n",
                pTimer,
                Timer_Flink,
                Timer_Blink);
    }

    return(Timer_Flink);

}



DECLARE_API( timer )

/*++

Routine Description:

    Dumps all timers in the system.

Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG           CurrentList;
    ULONG           Index;
    LARGE_INTEGER   InterruptTime;
    LARGE_INTEGER   SystemTime;
    ULONG           MaximumList;
    ULONG           MaximumSearchCount=0;
    ULONG           MaximumTimerCount;
    ULONG64         NextEntry;
    ULONG64         LastEntry;
    ULONG64         p;
    ULONG64         NextTimer;
    ULONG64         KeTickCount;
    ULONG64         KiMaximumSearchCount;
    ULONG           Result;
    ULONG64         TickCount=0;
    ULONG64         TimerTable;
    ULONG           TotalTimers;
    ULONG           KtimerOffset;
    ULONG           TimerListOffset;
    ULONG           WakeTimerListOffset;
    ULONG64         WakeTimerList;
    ULONG64         pETimer, Temp;
    ULONG64         SharedUserData;
    CHAR            Buffer[256];
    ULONGLONG       InterruptTimeOffset;
    UCHAR           TypName[]="_KUSER_SHARED_DATA";
    CHAR            SystemTime1[12]={0}, InterruptTime1[12]={0};
    FIELD_INFO offField = {"TimerListEntry", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={
        sizeof (SYM_DUMP_PARAM), "nt!_KTIMER", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };


    SharedUserData = MM_SHARED_USER_DATA_VA;
    //
    // Get the system time and print the header banner.
    //
    if (!GetFieldValue(SharedUserData, TypName, "SystemTime", SystemTime1) )
    {
        // For x86
        if (GetFieldValue(SharedUserData, TypName, "InterruptTime.High1Time", InterruptTime.HighPart) != S_OK ||
            GetFieldValue(SharedUserData, TypName, "InterruptTime.LowPart", InterruptTime.LowPart) != S_OK)
        {
            dprintf("Cannot get %s.InterruptTime parts @ %p\n", TypName, SharedUserData);
            return E_INVALIDARG;
        }

        if (GetFieldValue(SharedUserData, TypName, "SystemTime.High1Time", SystemTime.HighPart) != S_OK ||
            GetFieldValue(SharedUserData, TypName, "SystemTime.LowPart", SystemTime.LowPart) != S_OK)
        {
            dprintf("Cannot get %s.SystemTime parts @ %p\n", TypName, SharedUserData);
            return E_INVALIDARG;
        }
    }
    else if (!GetFieldValue(SharedUserData, TypName, "InterruptTime", InterruptTime1) ) {
        // For Alphas
        InterruptTime.QuadPart = *((PULONG64) &InterruptTime1[0]);
        SystemTime.QuadPart = *((PULONG64) &SystemTime1[0]);

    }
    else
    {
        dprintf("%08p: Unable to get shared data\n",SharedUserData);
        return E_INVALIDARG;
    }

    /*
#ifdef TARGET_ALPHA
    InterruptTime.QuadPart = SharedData.InterruptTime;
    SystemTime.QuadPart = SharedData.SystemTime;
#else
    InterruptTime.HighPart = SharedData.InterruptTime.High1Time;
    InterruptTime.LowPart = SharedData.InterruptTime.LowPart;
    SystemTime.HighPart = SharedData.SystemTime.High1Time;
    SystemTime.LowPart = SharedData.SystemTime.LowPart;
#endif
*/

    InterruptTimeOffset = SystemTime.QuadPart - InterruptTime.QuadPart;
    FileTimeToString(SystemTime, FALSE, Buffer);

    dprintf("Dump system timers\n\n");
    dprintf("Interrupt time: %08lx %08lx [%s]\n\n",
            InterruptTime.LowPart,
            InterruptTime.HighPart,
            Buffer);

    //
    // Get the address of the timer table list head array and scan each
    // list for timers.
    //

    dprintf("List Timer    Interrupt Low/High     Fire Time              DPC/thread\n");
    MaximumList = 0;

    TimerTable = GetExpression( "nt!KiTimerTableListHead" );
    if ( !TimerTable ) {
        dprintf("Unable to get value of KiTimerTableListHead\n");
        return E_INVALIDARG;
    }

    TotalTimers = 0;
    // Get The TimerListOffset in KTIMER offset
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        return E_INVALIDARG ;
    }
    TimerListOffset = (ULONG) offField.address;

    for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {

        //
        // Read the forward link in the next timer table list head.
        //

        if ( GetFieldValue(TimerTable, "nt!_LIST_ENTRY", "Flink", NextEntry)) {
            dprintf("Unable to get contents of next entry @ %p\n", TimerTable );
            continue;
        }

        //
        // Scan the current timer list and display the timer values.
        //

        LastEntry = TimerTable;
        CurrentList = 0;
        while (NextEntry != TimerTable) {
            CurrentList += 1;
            NextTimer = NextEntry - TimerListOffset; // CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            TotalTimers += 1;

            if (CurrentList == 1) {
                dprintf("%3ld %08p ", Index, NextTimer);
            } else {
                dprintf("    %08p ", NextTimer);
            }

            p = LastEntry;
            LastEntry = NextEntry;
            NextEntry = DumpKTimer(NextTimer, InterruptTimeOffset, p);
            if (NextEntry==0) {
                break;
            }

            if (CheckControlC()) {
                return E_INVALIDARG;
            }
        }

        TimerTable += GetTypeSize("nt!_LIST_ENTRY");
        if (CurrentList > MaximumList) {
            MaximumList = CurrentList;
        }
        if (CheckControlC()) {
            return E_INVALIDARG;
        }
    }

    dprintf("\n\nTotal Timers: %d, Maximum List: %d\n",
            TotalTimers,
            MaximumList);

    //
    // Get the current tick count and convert to the hand value.
    //

    KeTickCount =  GetExpression( "nt!KeTickCount" );
    if ( KeTickCount && !GetFieldValue(KeTickCount, "ULONG", NULL, TickCount)) {
        dprintf("Current Hand: %d", (ULONG) TickCount & (TIMER_TABLE_SIZE - 1));
    }

    //
    // Get the maximum search count if the target system is a checked
    // build and display the count.
    //

    KiMaximumSearchCount = GetExpression( "nt!KiMaximumSearchCount" );
    if ( KiMaximumSearchCount &&
         !GetFieldValue(KiMaximumSearchCount, "ULONG", NULL, Temp)) {
        MaximumSearchCount = (ULONG) Temp;
        dprintf(", Maximum Search: %d", MaximumSearchCount);
    }

    dprintf("\n\n");

    //
    // Dump the list of wakeable timers
    //
    dprintf("Wakeable timers:\n");
    WakeTimerList =  GetExpression("nt!ExpWakeTimerList");
    if (!WakeTimerList) {
        dprintf("Unable to get value of ExpWakeTimerList\n");
        return E_INVALIDARG;
    }

    // Get The WakeTimerLis tOffset in ETIMER
    TypeSym.sName = "_ETIMER";
    offField.fName = "WakeTimerListEntry";
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
        return  E_INVALIDARG;
    }
    TimerListOffset = (ULONG) offField.address;

    offField.fName = "KeTimer";
    Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size);
    KtimerOffset = (ULONG) offField.address;

    //
    // Read the forward link in the wake timer list
    //
    if (!ReadPointer(WakeTimerList,
                &NextEntry)) {
        dprintf("Unable to get contents of next entry @ %p\n",WakeTimerList);
        return E_INVALIDARG;
    }

    //
    // Scan the timer list and display the timer values.
    //
    while (NextEntry != WakeTimerList) {
        pETimer = NextEntry - TimerListOffset;

        dprintf("%08lx\t", pETimer + KtimerOffset);
        DumpKTimer(pETimer + KtimerOffset, InterruptTimeOffset, 0);


        GetFieldValue(pETimer, "_ETIMER", "WakeTimerListEntry.Flink", NextEntry);
//        NextEntry = ETimer.WakeTimerListEntry.Flink;

        if (CheckControlC()) {
            return E_INVALIDARG;
        }
    }
    dprintf("\n");

    return S_OK;
}

VOID
FileTimeToString(
    IN LARGE_INTEGER Time,
    IN BOOLEAN TimeZone,
    OUT PCHAR Buffer
    )
{
    TIME_FIELDS TimeFields;
    TIME_ZONE_INFORMATION TimeZoneInfo;
    PWCHAR pszTz;
    ULONGLONG TzBias;
    DWORD Result;

    //
    // Get the local (to the debugger) timezone bias
    //
    Result = GetTimeZoneInformation(&TimeZoneInfo);
    if (Result == 0xffffffff) {
        pszTz = L"UTC";
    } else {
        //
        // Bias is in minutes, convert to 100ns units
        //
        TzBias = (ULONGLONG)TimeZoneInfo.Bias * 60 * 10000000;
        switch (Result) {
            case TIME_ZONE_ID_UNKNOWN:
                pszTz = L"unknown";
                break;
            case TIME_ZONE_ID_STANDARD:
                pszTz = TimeZoneInfo.StandardName;
                break;
            case TIME_ZONE_ID_DAYLIGHT:
                pszTz = TimeZoneInfo.DaylightName;
                break;
        }

        Time.QuadPart -= TzBias;
    }

    RtlTimeToTimeFields(&Time, &TimeFields);
    if (TimeZone) {
        sprintf(Buffer, "%2d/%2d/%d %02d:%02d:%02d.%03d (%ws)",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds,
                pszTz);
    } else {
        sprintf(Buffer, "%2d/%2d/%d %02d:%02d:%02d.%03d",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds);
    }

}


DECLARE_API( filetime )

/*++

Routine Description:

    Reformats a 64-bit NT time (FILETIME) as something a human
    being can understand

Arguments:

    args - 64-bit filetime to reformat

Return Value:

    None

--*/

{
    LARGE_INTEGER Time;
    CHAR Buffer[256];

    Time.QuadPart = GetExpression(args);

    if (Time.QuadPart == 0) {
        dprintf("!filetime <64-bit FILETIME>\n");
    } else {
        FileTimeToString(Time,TRUE, Buffer);
        dprintf("%s\n",Buffer);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\stacks.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    stacks.c

Abstract:

    WinDbg Extension Api

Author:

    Adrian J. Oney (adriao) 07-28-1998

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition
    } KTHREAD_STATE;

typedef enum {

    NO_STACK_ACTION     = 0,
    SKIP_FRAME,
    SKIP_THREAD

} STACKS_ACTION, *PSTACKS_ACTION;

#define ETHREAD_NOT_READABLE    1
#define THREAD_VALID            2
#define FIRST_THREAD_VALID      3
#define NO_THREADS              4

struct _BLOCKER_TREE ;
typedef struct _BLOCKER_TREE BLOCKER_TREE, *PBLOCKER_TREE ;

BOOL
StacksValidateProcess(
    IN ULONG64 RealProcessBase
    );

BOOL
StacksValidateThread(
    IN ULONG64 RealThreadBase
    );

VOID StacksDumpProcessAndThread(
    IN ULONG64   RealProcessBase,
    IN ULONG     ThreadDesc,
    IN ULONG64   RealThreadBase,
    IN PBLOCKER_TREE BlockerTree,
    IN ULONG     Verbosity,
    IN char *    Filter
    );

VOID StacksGetThreadStateName(
    IN ULONG ThreadState,
    OUT PCHAR Dest,
    IN ULONG DestSize
    );

VOID
DumpThreadBlockageInfo (
    IN char   *pad,
    IN ULONG64 RealThreadBase,
    IN ULONG   Verbosity
    );

typedef enum {

    STACK_WALK_DUMP_STARTING = 0,
    STACK_WALK_DUMP_NOT_RESIDENT,
    STACK_WALK_DUMP_ENTRY,
    STACK_WALK_DUMP_FINISHED

} WALK_STAGE;

typedef struct {

    ULONG   Verbosity;
    BOOLEAN FirstEntry;
    char*   ThreadState;
    char*   ThreadBlocker;
    ULONG   ProcessCid;
    ULONG   ThreadCid;
    ULONG64 ThreadBlockerDisplacement;

} STACK_DUMP_CONTEXT, *PSTACK_DUMP_CONTEXT;

typedef BOOLEAN (*PFN_FRAME_WALK_CALLBACK)(
    IN WALK_STAGE   WalkStage,
    IN ULONG64      RealThreadBase,
    IN PVOID        Context,
    IN char *       Buffer,
    IN ULONG64      Offset
    );

VOID
ForEachFrameOnThread(
    IN ULONG64                 RealThreadBase,
    IN PFN_FRAME_WALK_CALLBACK Callback,
    IN PVOID                   Context
    );

BOOLEAN
StacksDumpStackCallback(
    IN WALK_STAGE   WalkStage,
    IN ULONG64      RealThreadBase,
    IN PVOID        Context,
    IN char *       Buffer,
    IN ULONG64      Offset
    );

extern ULONG64 STeip, STebp, STesp;
static ULONG64 PspCidTable;

ULONG64 ProcessLastDump;
ULONG64 ThreadLastDump;

ULONG TotalProcessCommit;

struct _BLOCKER_TREE {
   char const *Symbolic ;
   STACKS_ACTION Action ;
   PBLOCKER_TREE Child ;
   PBLOCKER_TREE Sibling ;
   PBLOCKER_TREE Parent ;
   BOOL Nested ;
} ;

VOID
AnalyzeThread(
    IN  ULONG64         RealThreadBase,
    IN  PBLOCKER_TREE   BlockerTree,
    IN  char *          Filter,
    OUT PCHAR           BlockSymbol,
    OUT ULONG64        *BlockDisplacement,
    OUT BOOLEAN        *SkipThread
    );

BOOL
BlockerTreeWalk(
   IN OUT PBLOCKER_TREE *blockerHead,
   IN char *szSymbolic,
   IN STACKS_ACTION Action
   );

PBLOCKER_TREE
BlockerTreeBuild(
   VOID
   ) ;

VOID
BlockerTreeFree(
   IN PBLOCKER_TREE BlockerTree
   ) ;

DECLARE_API( stacks )

/*++

Routine Description:

    Dumps the active process list.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Result;
    ULONG64 Next;
    ULONG64 NextThread;
    ULONG64 ProcessHead;
    ULONG64 Process;
    ULONG64 Thread;
    ULONG64 UserProbeAddress;
    ULONG Verbosity = 0, ThreadCount = 0;
    ULONG ActProcOffset, ThrdListOffset, ThrdEntryOffset;
    PBLOCKER_TREE blockerTree ;
    char szFilter[256];

    blockerTree = BlockerTreeBuild() ;

    if (sscanf(args, "%x %255s", &Verbosity, szFilter) < 2) {

        szFilter[0] = '\0';
    }

    dprintf("Proc.Thread  .Thread  ThreadState  Blocker\n") ;

    UserProbeAddress = GetNtDebuggerDataValue(MmUserProbeAddress);
    ProcessHead = GetNtDebuggerData( PsActiveProcessHead );
    if (!ProcessHead) {
        dprintf("Unable to get value of PsActiveProcessHead!\n");
        goto Exit;
    }

    if (GetFieldValue( ProcessHead, "nt!_LIST_ENTRY", "Flink", Next )) {
        dprintf("Unable to get value of PsActiveProcessHead.Flink\n");
        goto Exit ;
    }

    if (Next == 0) {
        dprintf("PsActiveProcessHead is NULL!\n");
        goto Exit;
    }

    GetFieldOffset("nt!_EPROCESS", "ActiveProcessLinks", &ActProcOffset);
    GetFieldOffset("nt!_EPROCESS", "Pcb.ThreadListHead", &ThrdListOffset);
    GetFieldOffset("nt!_KTHREAD",  "ThreadListEntry",    &ThrdEntryOffset);

    while(Next != ProcessHead) {
        ULONG64 FirstThread;

        Process = Next - ActProcOffset;

        if (GetFieldValue( Process, "nt!_EPROCESS", "Pcb.ThreadListHead.Flink", FirstThread )) {
            dprintf("Unable to read nt!_EPROCESS at %p\n",Process);
            goto Exit;
        }

        NextThread = FirstThread;
        if (!StacksValidateProcess(Process)) {

            dprintf("Process list damaged, or maybe symbols are incorrect?\n%p\n",Process);
            goto Exit;
        }

        if (NextThread == Process + ThrdListOffset) {

            StacksDumpProcessAndThread(Process, NO_THREADS, 0, blockerTree, Verbosity, szFilter) ;

        } else {

            while ( NextThread != Process + ThrdListOffset) {
                ULONG64 ThreadFlink;

                Thread = NextThread - ThrdEntryOffset;
                if (GetFieldValue(Thread,
                                  "nt!_ETHREAD",
                                  "Tcb.ThreadListEntry.Flink",
                                  ThreadFlink)) {

                    StacksDumpProcessAndThread(Process, ETHREAD_NOT_READABLE, 0, blockerTree, Verbosity, szFilter) ;

                    dprintf("Unable to read _ETHREAD at %lx\n",Thread);
                    break;
                }

                if (!StacksValidateThread(Thread)) {

                    StacksDumpProcessAndThread( Process, ETHREAD_NOT_READABLE, 0, blockerTree, Verbosity, szFilter) ;
                } else if (NextThread == FirstThread) {

                    ThreadCount++;
                    StacksDumpProcessAndThread(Process, FIRST_THREAD_VALID, Thread, blockerTree, Verbosity, szFilter) ;
                } else {

                    ThreadCount++;
                    StacksDumpProcessAndThread(Process, THREAD_VALID, Thread, blockerTree, Verbosity, szFilter) ;
                }

                NextThread = ThreadFlink;
                if (CheckControlC()) {
                    goto Exit;
                }
            }
        }

        EXPRLastDump = Process;
        ProcessLastDump = Process;
        dprintf("\n");
        GetFieldValue( Process, "nt!_EPROCESS", "ActiveProcessLinks.Flink", Next);

        if (CheckControlC()) {
            goto Exit;
        }
    }
Exit:
   BlockerTreeFree(blockerTree) ;
   dprintf("\nThreads Processed: %d\n", ThreadCount);
   return S_OK;
}

BOOL
StacksValidateProcess(
    IN ULONG64 RealProcessBase
    )
{
    ULONG Type;

    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "Pcb.Header.Type", Type);
    if (Type != ProcessObject) {
        dprintf("TYPE mismatch for process object at %p\n",RealProcessBase);
        return FALSE;
    }
    return TRUE ;
}

VOID StacksDumpProcessAndThread(
    IN ULONG64       RealProcessBase,
    IN ULONG         ThreadDesc,
    IN ULONG64       RealThreadBase,
    IN PBLOCKER_TREE BlockerTree,
    IN ULONG         Verbosity,
    IN char *        Filter
    )
{
    ULONG NumberOfHandles;
    ULONG Result;
    CHAR  Buf[512];
    CHAR  ThreadState[13] ;
    CHAR  ThreadBlocker[MAX_PATH] ;
    UINT  i ;
    ULONG64 ObjectTable, ThreadBlockerDisplacement;
    CHAR *ThreadStateName ;
    ULONG UniqueProcessCid;
    STACK_DUMP_CONTEXT dumpData;
    BOOLEAN SkipThread;

    NumberOfHandles = 0;
    GetFieldValue(RealProcessBase, "nt!_EPROCESS", "ImageFileName", Buf);

    InitTypeRead(RealProcessBase, nt!_EPROCESS);

    if (ObjectTable = ReadField(ObjectTable)) {
        GetFieldValue(ObjectTable, "nt!_HANDLE_TABLE", "HandleCount", NumberOfHandles);
    }

    if (Buf[0] == '\0' ) {
        if (StringCchCopy((char *)Buf, sizeof(Buf), "System Process") != S_OK)
        {
            // make PREfast happy
        }
    }

    UniqueProcessCid = (ULONG) ReadField(UniqueProcessId);

    if (!RealThreadBase) {

        switch(ThreadDesc) {

            case NO_THREADS:

                dprintf("                            [%p %s]\n", RealProcessBase, Buf) ;

                if ((Verbosity > 0) && (Filter[0] == '\0')) {
                    dprintf("%4lx.------  NOTHREADS\n",
                        UniqueProcessCid
                        );
                }

                break ;

            case ETHREAD_NOT_READABLE:

                dprintf("%4lx.------  NO ETHREAD DATA\n",
                    UniqueProcessCid
                    );

                break ;
        }

        return;
    }

    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    ASSERT(((ULONG) ReadField(Cid.UniqueProcess)) == UniqueProcessCid);

    StacksGetThreadStateName((ULONG) ReadField(Tcb.State), ThreadState, sizeof(ThreadState)) ;
    i=strlen(ThreadState) ;
    while(i<11) ThreadState[i++]=' ' ;
    ThreadState[i]='\0' ;

    AnalyzeThread(
        RealThreadBase,
        BlockerTree,
        Filter,
        ThreadBlocker,
        &ThreadBlockerDisplacement,
        &SkipThread
        );

    if (ThreadDesc == FIRST_THREAD_VALID) {

        dprintf("                            [%p %s]\n", RealProcessBase, Buf) ;
    }

    if (SkipThread && ((Verbosity == 0) || (Filter[0]))) {

        return;
    }

    dumpData.Verbosity = Verbosity;
    dumpData.ThreadState = ThreadState;
    dumpData.ThreadBlocker = ThreadBlocker;
    dumpData.ThreadBlockerDisplacement = ThreadBlockerDisplacement;
    dumpData.ProcessCid = UniqueProcessCid;
    dumpData.ThreadCid = (ULONG) ReadField(Cid.UniqueThread);

    ForEachFrameOnThread(
        RealThreadBase,
        StacksDumpStackCallback,
        (PVOID) &dumpData
        );
}

BOOLEAN
StacksDumpStackCallback(
    IN WALK_STAGE   WalkStage,
    IN ULONG64      RealThreadBase,
    IN PVOID        Context,
    IN char *       Buffer,
    IN ULONG64      Offset
    )
{
    PSTACK_DUMP_CONTEXT dumpData = (PSTACK_DUMP_CONTEXT) Context;

    switch(WalkStage) {

        case STACK_WALK_DUMP_STARTING:

            dprintf("%4lx.%06lx  %08p  %s",
                dumpData->ProcessCid,
                dumpData->ThreadCid,
                RealThreadBase,
                dumpData->ThreadState
                );

            dumpData->FirstEntry = TRUE;
            return TRUE;

        case STACK_WALK_DUMP_FINISHED:

            dumpData->FirstEntry = FALSE;
            dprintf("\n");
            return TRUE;

        case STACK_WALK_DUMP_NOT_RESIDENT:
        case STACK_WALK_DUMP_ENTRY:

            if (dumpData->FirstEntry) {

                dumpData->FirstEntry = FALSE;
            } else {

                dprintf("\n                                  ");
            }
            break;

        default:
            return FALSE;
    }

    if (WalkStage == STACK_WALK_DUMP_NOT_RESIDENT) {

        switch(dumpData->Verbosity) {

            case 0:
            case 1:
            case 2:
                dprintf("Stack paged out");
                break;
        }

        return FALSE;
    }

    switch(dumpData->Verbosity) {

        case 0:
        case 1:
            dprintf("%s", dumpData->ThreadBlocker);
            if (dumpData->ThreadBlockerDisplacement) {
                dprintf( "+0x%1p", dumpData->ThreadBlockerDisplacement );
            }
            dprintf("\n");
            return FALSE;

        case 2:
            dprintf("%s", Buffer);
            if (Offset) {
                dprintf( "+0x%1p", Offset );
            }
            break;
    }

    return TRUE;
}


VOID StacksGetThreadStateName(
    IN ULONG ThreadState,
    OUT PCHAR Dest,
    OUT ULONG DestSize
    )
{
    HRESULT Hr = S_OK;
    switch (ThreadState) {
        case Initialized: Hr = StringCchCopy(Dest, DestSize, "INITIALIZED"); break;
        case Ready:       Hr = StringCchCopy(Dest, DestSize, "READY"); break;
        case Running:     Hr = StringCchCopy(Dest, DestSize, "RUNNING"); break;
        case Standby:     Hr = StringCchCopy(Dest, DestSize, "STANDBY"); break;
        case Terminated:  Hr = StringCchCopy(Dest, DestSize, "TERMINATED"); break;
        case Waiting:     Hr = StringCchCopy(Dest, DestSize, "Blocked"); break;
        case Transition:  Hr = StringCchCopy(Dest, DestSize, "TRANSITION"); break;
        default:          Hr = StringCchCopy(Dest, DestSize, "????") ; break ;
    }
    if ((Hr != S_OK) && Dest)
    {
        Dest[0] = 0;
    }
}


BOOL
StacksValidateThread (
    IN ULONG64 RealThreadBase
    )
{
    ULONG Type;

    GetFieldValue(RealThreadBase, "nt!_ETHREAD", "Tcb.Header.Type", Type);
    if (Type != ThreadObject) {
        dprintf("TYPE mismatch for thread object at %p\n",RealThreadBase);
        return FALSE;
    }
    return TRUE ;
}


VOID
DumpThreadBlockageInfo (
    IN char   *Pad,
    IN ULONG64 RealThreadBase,
    IN ULONG   Verbosity
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG64 Address;
    ULONG Result;
    ULONG64 WaitBlock;
    ULONG WaitOffset;
    ULONG64 Process;
    CHAR Buffer[80];
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG displacement;
    ULONG64 WaitBlockList;
    ULONG   IrpOffset;

    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    if ((ULONG) ReadField(Tcb.State) == Waiting) {
        dprintf("%s (%s) %s %s\n",
            Pad,
            GetThreadWaitReasonName((ULONG) ReadField(Tcb.WaitReason)),
            ((ULONG) ReadField(Tcb.WaitMode)==KernelMode) ? "KernelMode" : "UserMode",(ULONG) ReadField(Tcb.Alertable) ? "Alertable" : "Non-Alertable");
        if ( ReadField(Tcb.SuspendCount) ) {
            dprintf("SuspendCount %lx\n",(ULONG) ReadField(Tcb.SuspendCount));
        }
        if ( ReadField(Tcb.FreezeCount) ) {
            dprintf("FreezeCount %lx\n",(ULONG) ReadField(Tcb.FreezeCount));
        }

        WaitBlockList = ReadField(Tcb.WaitBlockList);

        if (InitTypeRead(WaitBlockList,nt!KWAIT_BLOCK)) {
            dprintf("%sunable to get Wait object\n",Pad);
            goto BadWaitBlock;
        }

        do {
            ULONG64 Object, NextWaitBlock, OwnerThread;
            ULONG Limit;

            dprintf("%s    %lx  ",Pad, Object = ReadField(Object));
            NextWaitBlock = ReadField(NextWaitBlock);

            if (InitTypeRead(Object,nt!KMUTANT)) {

                dprintf("%sunable to get Wait object\n",Pad);
                break;
            }

            GetFieldValue(Object, "nt!KSEMAPHORE", "Limit", Limit);
            GetFieldValue(Object, "nt!KSEMAPHORE", "OwnerThread",OwnerThread);
            switch (ReadField(Header.Type)) {
                case EventNotificationObject:
                    dprintf("NotificationEvent\n");
                    break;
                case EventSynchronizationObject:
                    dprintf("SynchronizationEvent\n");
                    break;
                case SemaphoreObject:
                    dprintf("Semaphore Limit 0x%p\n",
                             Limit);
                    break;
                case ThreadObject:
                    dprintf("Thread\n");
                    break;
                case TimerNotificationObject:
                    dprintf("NotificationTimer\n");
                    break;
                case TimerSynchronizationObject:
                    dprintf("SynchronizationTimer\n");
                    break;
                case EventPairObject:
                    dprintf("EventPair\n");
                    break;
                case ProcessObject:
                    dprintf("ProcessObject\n");
                    break;
                case MutantObject:
                    dprintf("Mutant - owning thread %p\n",
                            OwnerThread);
                    break;
                default:
                    dprintf("Unknown\n");
                    break;
            }

            if (NextWaitBlock == WaitBlockList) {
                break;
            }

            if (InitTypeRead(NextWaitBlock,nt!KWAIT_BLOCK)) {
                dprintf("%sunable to get Wait object\n",Pad);
                break;
            }
        } while ( TRUE );
    }

BadWaitBlock:

    //
    // Re-intialize thread read
    //
    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    if ( ReadField(LpcReplyMessageId) != 0) {
        dprintf("%sWaiting for reply to LPC MessageId %08x:\n",Pad, (ULONG) ReadField(LpcReplyMessageId));
    }

    if (Address = ReadField(LpcReplyMessage)) {
        ULONG64 Entry_Flink, Entry_Blink;

        dprintf("%sPending LPC Reply Message:\n",Pad);

        if (GetFieldValue(Address, "nt!_LPCP_MESSAGE", "Entry.Blink", Entry_Blink)) {
            dprintf("unable to get LPC msg\n");
        } else {
            GetFieldValue(Address, "nt!_LPCP_MESSAGE", "Entry.Flink", Entry_Flink);
            dprintf("%s    %08p: [%08p,%08p]\n",
                    Pad, Address, Entry_Blink, Entry_Flink
                   );
        }
    }

    GetFieldOffset("nt!_ETHREAD", "IrpList", &IrpOffset);

    if (ReadField(IrpList.Flink) != ReadField(IrpList.Blink) ||
        ReadField(IrpList.Flink) != RealThreadBase + IrpOffset
       ) {

        ULONG64 IrpListHead = RealThreadBase + IrpOffset;
        ULONG64 Next;
        ULONG Counter = 0;
        ULONG IrpThrdOff;

        Next = ReadField(IrpList.Flink);

        GetFieldOffset("nt!_IRP", "ThreadListEntry", &IrpThrdOff);

        dprintf("%sIRP List:\n",Pad);
        while ((Next != IrpListHead) && (Counter < 17)) {
            ULONG Irp_Type=0, Irp_Size=0, Irp_Flags=0;
            ULONG64 Irp_MdlAddress=0;

            Counter += 1;

            Address = Next - IrpThrdOff;

            GetFieldValue(Address, "nt!_IRP", "Type",          Irp_Type);
            GetFieldValue(Address, "nt!_IRP", "Size",          Irp_Size);
            GetFieldValue(Address, "nt!_IRP", "Flags",         Irp_Flags);
            GetFieldValue(Address, "nt!_IRP", "MdlAddress",    Irp_MdlAddress);
            GetFieldValue(Address, "nt!_IRP", "ThreadListEntry.Flink",  Next);

            dprintf("%s    %08p: (%04x,%04x) Flags: %08lx  Mdl: %08lp\n",
                    Pad,Address,Irp_Type,Irp_Size,Irp_Flags,Irp_MdlAddress);

        }
    }

}

VOID
ForEachFrameOnThread(
    IN ULONG64                 RealThreadBase,
    IN PFN_FRAME_WALK_CALLBACK Callback,
    IN PVOID                   Context
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG Address;
    ULONG Result;
    CHAR Buffer[256];
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG64 displacement, tcb_KernelStackResident;
    EXTSTACKTRACE64 stk[MAX_STACK_FRAMES];

    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    tcb_KernelStackResident = ReadField(Tcb.KernelStackResident);

    if (!tcb_KernelStackResident) {

        if (Callback(STACK_WALK_DUMP_STARTING, RealThreadBase, Context, NULL, 0)) {

            Callback(STACK_WALK_DUMP_NOT_RESIDENT, RealThreadBase, Context, NULL, 0);
            Callback(STACK_WALK_DUMP_FINISHED, RealThreadBase, Context, NULL, 0);
        }

        return;
    }

    SetThreadForOperation64( &RealThreadBase );
    frames = StackTrace( 0, 0, 0, stk, MAX_STACK_FRAMES );


    if (!Callback(STACK_WALK_DUMP_STARTING, RealThreadBase, Context, NULL, 0)) {

        return;
    }

    for (i=0; i<frames; i++) {

        Buffer[0] = '!';
        GetSymbol(stk[i].ProgramCounter, Buffer, &displacement);

        if (!Callback(
            STACK_WALK_DUMP_ENTRY,
            RealThreadBase,
            Context,
            Buffer,
            displacement)) {

            return;
        }
    }

    Callback(STACK_WALK_DUMP_FINISHED, RealThreadBase, Context, NULL, 0);
}

VOID
AnalyzeThread(
    IN  ULONG64         RealThreadBase,
    IN  PBLOCKER_TREE   BlockerTree,
    IN  char *          Filter,
    OUT PCHAR           BlockBuffer,
    OUT ULONG64        *BlockerDisplacement,
    OUT BOOLEAN        *SkipThread
    )
{
    #define MAX_STACK_FRAMES  40
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    ULONG Address;
    ULONG Result;
    ULONG WaitOffset;
    ULONG KeTimeIncrement;
    ULONG TimeIncrement;
    ULONG frames = 0;
    ULONG i;
    ULONG64 displacement, tcb_KernelStackResident;
    PBLOCKER_TREE blockerCur ;
    EXTSTACKTRACE64 stk[MAX_STACK_FRAMES];
    BOOLEAN filterMatch, blockerMatch;
    CHAR  tempFrame[256], lcFilter[256], lcFrame[256];

    InitTypeRead(RealThreadBase, nt!_ETHREAD);

    tcb_KernelStackResident = ReadField(Tcb.KernelStackResident);

    if (!tcb_KernelStackResident) {

        *SkipThread = TRUE;
        *BlockerDisplacement = 0;
        BlockBuffer[0] = '\0';
        return;
    }

    SetThreadForOperation64( &RealThreadBase );
    frames = StackTrace( 0, 0, 0, stk, MAX_STACK_FRAMES );

    *SkipThread = FALSE;

    StringCchCopy(BlockBuffer, MAX_PATH, "<Unknown Blocker>");
    *BlockerDisplacement = 0;

    if (Filter[0]) {

        if (StringCchCopy(lcFilter, sizeof(lcFilter), Filter) == S_OK)
        {
            _strlwr(lcFilter);
        }
    }

    if (frames == 0) {

         strcpy(BlockBuffer, "?? Kernel stack not resident ??") ;
         *SkipThread = TRUE;
    } else {

        if (ReadField(Tcb.State) == Running) {

            GetSymbol(stk[0].ProgramCounter, BlockBuffer, &displacement);
            *BlockerDisplacement = displacement;

        } else {

            blockerMatch = FALSE;
            filterMatch = FALSE;

            for(i=0; i<frames; i++) {

                GetSymbol(stk[i].ProgramCounter, tempFrame, &displacement);
                if ((!filterMatch) && Filter[0]) {

                    if (StringCchCopy(lcFrame, sizeof(lcFrame), tempFrame) == S_OK)
                    {
                        _strlwr(lcFrame);
                    }
                    if (strstr(lcFrame, lcFilter)) {

                        filterMatch = TRUE;
                    }
                }

                blockerCur = BlockerTree;
                if ((!blockerMatch) &&
                    (!BlockerTreeWalk(&blockerCur, tempFrame, SKIP_FRAME))) {

                    blockerMatch = TRUE;
                    if (StringCchCopy(BlockBuffer, MAX_PATH,  tempFrame) == S_OK)
                    {
                        *BlockerDisplacement = displacement;
                    }
                    *BlockerDisplacement = displacement;
                    if (filterMatch || (Filter[0]=='\0')) {
                        break;
                    }
                }
            }

            blockerCur = BlockerTree;
            if (Filter[0]) {

                if (!filterMatch) {

                    *SkipThread = TRUE;
                }

            } else {

                if (BlockerTreeWalk(&blockerCur, BlockBuffer, SKIP_THREAD)) {

                    *SkipThread = TRUE;
                }
            }
        }
    }
}

#define BEGIN_TREE()
#define END_TREE()
#define DECLARE_ENTRY(foo, action) BlockerTreeDeclareEntry(foo, action)
#define BEGIN_LIST() BlockerTreeListBegin()
#define END_LIST() BlockerTreeListEnd()

PBLOCKER_TREE gpCurrentBlocker ;

VOID
BlockerTreeListBegin(
   VOID
   )
{
   //dprintf("Nest for %x\n", gpCurrentBlocker) ;
   ASSERT(!gpCurrentBlocker->Nested) ;
   gpCurrentBlocker->Nested = TRUE ;
}

VOID
BlockerTreeListEnd(
   VOID
   )
{
   //dprintf("Unnest for %x\n", gpCurrentBlocker) ;
   gpCurrentBlocker = gpCurrentBlocker->Parent ;
   ASSERT(gpCurrentBlocker->Nested) ;
   gpCurrentBlocker->Nested = FALSE ;
}

VOID
BlockerTreeDeclareEntry(
   const char      *szSymbolic,
   STACKS_ACTION    StacksAction
   )
{
   PBLOCKER_TREE blockerEntry ;

   blockerEntry = (PBLOCKER_TREE) malloc(sizeof(BLOCKER_TREE)) ;
   if (!blockerEntry) {
      return ;
   }

   memset(blockerEntry, 0, sizeof(BLOCKER_TREE)) ;
   blockerEntry->Symbolic = szSymbolic ;
   blockerEntry->Action = StacksAction;

   if (gpCurrentBlocker->Nested) {
      ASSERT(!gpCurrentBlocker->Child) ;
      //dprintf("Child %x for %x\n", blockerEntry, gpCurrentBlocker) ;
      blockerEntry->Parent = gpCurrentBlocker ;
      gpCurrentBlocker->Child = blockerEntry ;
   } else {
      ASSERT(!gpCurrentBlocker->Sibling) ;
      //dprintf("sibling %x for %x\n", blockerEntry, gpCurrentBlocker) ;
      blockerEntry->Parent = gpCurrentBlocker->Parent ;
      gpCurrentBlocker->Sibling = blockerEntry ;
   }
   gpCurrentBlocker = blockerEntry ;
}

PBLOCKER_TREE
BlockerTreeBuild(
   VOID
   )
{
   BLOCKER_TREE blockerHead ;

   memset(&blockerHead, 0, sizeof(BLOCKER_TREE)) ;

   gpCurrentBlocker = &blockerHead ;

   //
   // Generate the list...
   //
   #include "stacks.h"

   //
   // And return it.
   //
   return blockerHead.Sibling ;
}

VOID BlockerTreeFree(
   PBLOCKER_TREE BlockerHead
   )
{
   PBLOCKER_TREE blockerCur, blockerNext ;

   for(blockerCur = BlockerHead; blockerCur; blockerCur = blockerNext) {
      if (blockerCur->Child) {
         BlockerTreeFree(blockerCur->Child) ;
      }
      blockerNext = blockerCur->Sibling ;
      free(blockerCur) ;
   }
}

BOOL
BlockerTreeWalk(
   IN OUT PBLOCKER_TREE *blockerHead,
   IN char *szSymbolic,
   IN STACKS_ACTION Action
   )
{
   PBLOCKER_TREE blockerCur ;
   const char *blockString, *curString, *strptr;
   char szStringCopy[512];

   for(blockerCur = *blockerHead; blockerCur; blockerCur = blockerCur->Sibling) {

       if (Action != blockerCur->Action) {

           continue;
       }

       blockString = blockerCur->Symbolic;
       curString = szSymbolic;

       strptr = strstr(curString, "!.");
       if (strptr) {

           //
           // This must be an ia64 symbol. Replace the !. with a nice simple !
           //
           if (StringCchCopy(szStringCopy, sizeof(szStringCopy), curString) == S_OK)
           {
               if (StringCchCopy(szStringCopy + (strptr - curString) + 1,
                                 sizeof(szStringCopy) - (strptr - curString) + 1,
                                 strptr + 2) == S_OK)
               {
                   curString = szStringCopy;
               }
           }
       }

       //
       // Special case "Our Kernel of Many Names"
       //
       if (!_strnicmp(blockString, "nt!", 3)) {

           if ((!_strnicmp(curString, "ntoskrnl!", 9)) ||
               (!_strnicmp(curString, "ntkrnlmp!", 9)) ||
               (!_strnicmp(curString, "ntkrpamp!", 9)) ||
               (!_strnicmp(curString, "ntkrnlpa!", 9))) {

               blockString += 3;
               curString += 9;
           }
       }

       if (!_strcmpi(blockString, curString)) {
           *blockerHead = blockerCur->Child;
           return TRUE;
       }
   }
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\trap.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    trap.c

Abstract:

    WinDbg Extension Api

Revision History:

--*/

#include "precomp.h"
#include "i386.h"
#include "ia64.h"
#pragma hdrstop

extern ULONG64 STeip, STebp, STesp;
extern ULONG64 ThreadLastDump;



DECLARE_API( callback )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64         Address;
    ULONG           Flags;
    ULONG           result;
    ULONG64         Thread;
    ULONG64         prevCallout ;
    INT             calloutNum ;
    INT             whichCallout ;
    ULONG64         InitialStack;
    ULONG64         TrFr;
    ULONG           dwProcessor=0;
    
    GetCurrentProcessor(Client, &dwProcessor, NULL);

    Address = 0;
    whichCallout = 0 ;
    if (GetExpressionEx(args, &Address, &args)) {
        if (!sscanf(args, "%ld", &whichCallout)) {
            whichCallout = 0;
        }
    }

    if (Address == 0) {
        GetCurrentThreadAddr((USHORT)dwProcessor, &Address);
    }

    if (!DumpThreadEx(dwProcessor, "", Address, 0, Client))
        return E_INVALIDARG;

    GetFieldValue(Address, "ETHREAD", "Tcb.InitialStack", InitialStack);
    
    /*
     * now try and grab the contents of the stack
     */
    if (GetFieldValue(InitialStack, "KCALLOUT_FRAME", "TrFr", TrFr)) {
        dprintf("%08p: Unable to get callout frame\n", InitialStack);
        return E_INVALIDARG;
    }

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
        /*
         * Save eip, esp, ebp for quick backtrace from this callback in case
         * they gave us a bogus callout frame.
         */
        GetFieldValue(InitialStack, "KCALLOUT_FRAME", "Ret", STeip);
        STesp = (ULONG) InitialStack ;
        GetFieldValue(InitialStack, "KCALLOUT_FRAME", "Ebp", STebp);
    }

    /*
     * Print the callout chain
     */
    calloutNum = 0 ;
    prevCallout = InitialStack ;
    
    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
        dprintf("Callout#    ebp        esp        eip        trapframe\n") ;
    } else {
        dprintf("Callout#        esp        trapframe\n") ;
    }

    while (prevCallout) {

        if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
            ULONG Ret, Ebp;

            GetFieldValue(prevCallout, "KCALLOUT_FRAME", "Ebp", Ebp);
            GetFieldValue(prevCallout, "KCALLOUT_FRAME", "Ret", Ret);

            dprintf("  %3d       %08lx   %08p   %08lx   %08lx",
                    calloutNum, Ebp, prevCallout,
                    Ret, TrFr) ;
            if (calloutNum == whichCallout) {
                STeip = Ret ;
                STesp = (ULONG) prevCallout ;
                STebp = Ebp ;
                dprintf("   <-- !kb\n") ;
            }
            else
                dprintf("\n") ;
        } else {
            dprintf("  %3d       %08p   %08lx",
                    calloutNum, prevCallout, TrFr) ;
        }


        /*
         * advance to the next callout and try to read it
         */
        calloutNum++ ;

        GetFieldValue(prevCallout, "KCALLOUT_FRAME", "CbStk", prevCallout);
        
        if (GetFieldValue(prevCallout, "KCALLOUT_FRAME", "TrFr", TrFr)) {
            dprintf("%08p: Unable to get callout frame\n", prevCallout);
            return E_INVALIDARG;
        }
        
    }
    dprintf("\n") ;

    if (calloutNum <= whichCallout) {
        dprintf("#(%ld) is out of range.  Frame #0 selected.\n", calloutNum) ;
    }

    return S_OK;
}

DECLARE_API( kb )

/*++

--*/

{
    dprintf("\n");
    dprintf("    \"!kb\" is no longer necessary as using \"kb\" after a \".cxr\" or \".trap\"\n");
    dprintf("  command will give you the stack for the faulting thread.\n");
    dprintf("\n");
    dprintf("    Type \"!cxr\" or \"!trap\" for more help on this.\n");
    dprintf("\n");

    return S_OK;
}


DECLARE_API( kv )

/*++

--*/

{
    dprintf("\n");
    dprintf("    \"!kv\" is no longer necessary as using \"kv\" after a \".cxr\" or \".trap\"\n");
    dprintf("  command will give you the stack for the faulting thread.\n");
    dprintf("\n");
    dprintf("    Type \"!cxr\" or \"!trap\" for more help on this.\n");
    dprintf("\n");

    return S_OK;
}


#define HIGH(x) ((ULONG) ((x>>32) & 0xFFFFFFFF))
#define LOW(x) ((ULONG) (x & 0xFFFFFFFF))



VOID
DisplayFullEmRegField(
    ULONG64      EmRegValue,
    EM_REG_FIELD EmRegFields[],
    ULONG        Field
    )
{
   dprintf( "\n %3.3s : %I64x : %-s",  
            EmRegFields[Field].SubName,
            (EmRegValue >> EmRegFields[Field].Shift) & ((1 << EmRegFields[Field].Length) - 1),
            EmRegFields[Field].Name
          );
   return;
} // DisplayFullEmRegField()

VOID
DisplayFullEmReg(
    IN ULONG64      Val,
    IN EM_REG_FIELD EmRegFields[],
    IN DISPLAY_MODE DisplayMode
    )
{
    ULONG i, j;

    i = j = 0;
    if ( DisplayMode >= DISPLAY_MAX )   {
       while( j < EM_REG_BITS )   {
          DisplayFullEmRegField( Val, EmRegFields, i );
          j += EmRegFields[i].Length;
          i++;
       }
    }
    else  {
       while( j < EM_REG_BITS )   {
          if ( !strstr(EmRegFields[i].Name, "reserved" ) &&
               !strstr(EmRegFields[i].Name, "ignored"  ) ) {
             DisplayFullEmRegField( Val, EmRegFields, i );
          }
          j += EmRegFields[i].Length;
          i++;
       }
    }
    dprintf("\n");

    return;

} // DisplayFullEmReg()


#if 0

//
// ISR codes for General Exceptions: ISR{7:4}
//

#define ISR_ILLEGAL_OP     0        // Illegal operation fault
#define ISR_PRIV_OP        1        // Privileged operation fault
#define ISR_PRIV_REG       2        // Privileged register fault
#define ISR_RESVD_REG      3        // Reserved register/field fault
#define ISR_ILLEGAL_ISA    4        // Disabled instruction set transition fault
#define ISR_ILLEGAL_HAZARD 8        // Illegal hazard fault

//
// ISR codes for Nat Consumption Faults: ISR{7:4}
//

#define ISR_NAT_REG     1           // Nat Register Consumption fault
#define ISR_NAT_PAGE    2           // Nat Page Consumption fault

//
// For Traps ISR{4:0}
//

// FP trap
#define ISR_FP_TRAP    0
// Lower privilege transfer trap
#define ISR_LP_TRAP    1
// Taken branch trap
#define ISR_TB_TRAP    2
// Single step trap
#define ISR_SS_TRAP    3
// Unimplemented instruction address trap
#define ISR_UI_TRAP    4

ISR Settings for Non-Access Instructions
Instruction ISR fields
                     code{3:0} na r w
tpa                  0 1 0 0
fc                   1 1 1 0
probe                2 1 0 or 1 a 0 or 1 a
tak                  3 1 0 0
lfetch, lfetch.fault 4 1 1 0
probe.fault          5 1 0 or 1 a 0 or 1 a
a. Sets r or w or both to 1 depending on the probe form.

#endif // 0

EM_REG_FIELD EmIsrFields[] = {
        { "code",   "interruption Code"   , 0x10, 0 },   // 0-15
        { "vector", "IA32 exception vector number"  , 0x8, 16 },   // 16-23
        { "rv",     "reserved0", 0x8, 24  }, // 24-31
        { "x",      "eXecute exception", 0x1, 32 }, // 32
        { "w",      "Write exception", 0x1, 33 }, // 33
        { "r",      "Read exception", 0x1, 34 }, // 34
        { "na",     "Non-Access exception", 0x1, 35 }, // 35
        { "sp",     "Speculative load exception", 0x1, 36 }, // 36
        { "rs",     "Register Stack", 0x1, 37 }, // 37
        { "ir",     "Invalid Register frame", 0x1, 38 }, // 38
        { "ni",     "Nested Interruption", 0x1, 39 }, // 39
        { "so",     "IA32 Supervisor Override", 0x1, 40 }, // 40
        { "ei",     "Exception IA64 Instruction", 0x2, 41 }, // 41-42
        { "ed",     "Exception Deferral", 0x1, 43 }, // 43
        { "rv",     "reserved1", 0x14, 44 } // 44-63
};

VOID
DisplayIsrIA64( 
    IN const PCHAR         Header,
    IN       EM_ISR        EmIsr,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
        DisplayFullEmReg( EM_ISRToULong64(EmIsr), EmIsrFields, DisplayMode );
    }
    else   {
       dprintf(
            "ed ei so ni ir rs sp na r w x vector code\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x %1I64x %1I64x %1I64x      %I64x   %I64x\n",
            EmIsr.ed,
            EmIsr.ei,
            EmIsr.so,
            EmIsr.ni,
            EmIsr.ir,
            EmIsr.rs,
            EmIsr.sp,
            EmIsr.na,
            EmIsr.r,
            EmIsr.w,
            EmIsr.x,
            EmIsr.vector,
            EmIsr.code
            );
    }

    return;

} // DisplayIsrIA64()


DECLARE_API( isr )

/*++

Routine Description:



Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64     isrValue;
    ULONG       result;
    ULONG       flags = 0;
    char       *header;

    if (!GetExpressionEx(args,&isrValue, &args)) {
        dprintf("USAGE: !isr 0xValue [display_mode:0,1,2]\n");
        dprintf("USAGE: !isr @isr    [display_mode:0,1,2]\n");
        return E_INVALIDARG;
    } else {
        flags = (ULONG) GetExpression(args);
    }
    
    header = (flags > DISPLAY_MIN) ? NULL : "\tisr:\t";

    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!isr not implemented for this architecture.\n");
    }
    else
    {
        DisplayIsrIA64( header, ULong64ToEM_ISR(isrValue), (DISPLAY_MODE) flags );
    }

    return S_OK;
    
} // !isr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\tunnel.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Tunnel.c

Abstract:

    WinDbg Extension Api

Author:

    Dan Lovinger            2-Apr-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  printf is really expensive to iteratively call to do the indenting,
//  so we just build up some avaliable spaces to mangle as required
//

#define MIN(a,b) ((a) > (b) ? (b) : (a))

#define MAXINDENT  128
#define INDENTSTEP 2
#define MakeSpace(I)       Space[MIN((I)*INDENTSTEP, MAXINDENT)] = '\0'
#define RestoreSpace(I)    Space[MIN((I)*INDENTSTEP, MAXINDENT)] = ' '

CHAR    Space[MAXINDENT*INDENTSTEP + 1];

//#define SplitLI(LI) (LI).HighPart, (LI).LowPart
#define SplitLL(LL) (ULONG)((LL) >> 32), (ULONG)((LL) & 0xffffffff)

VOID
DumpTunnelNode (
    ULONG64 Node,
    ULONG Indent
    )
{
    WCHAR ShortNameStr[8+1+3] = {0};
    WCHAR LongNameStr[64] = {0};
    ULONG Flags;
    UNICODE_STRING ShortName, LongName;

    if (GetFieldValue(Node, "TUNNEL_NODE", "Flags", Flags)) {
        return;
    }

    InitTypeRead(Node, TUNNEL_NODE);
    
    ShortName.Length = (USHORT) ReadField(ShortName.Length);

    if (ShortName.Length >= sizeof(ShortNameStr))
    {
        ShortName.Length = sizeof(ShortNameStr) - sizeof(WCHAR);
    }
    
    LongName.Length = (USHORT) ReadField(LongName.Length);
    if (LongName.Length >= sizeof(LongNameStr))
    {
        LongName.Length = sizeof(LongNameStr) - sizeof(WCHAR);
    }

    //
    //  Grab the strings from the debugee
    //

    if (!ReadMemory(ReadField(ShortName.Buffer),
                    ShortNameStr,
                    ShortName.Length,
                    NULL)) {

        return;
    }

    if (!ReadMemory(ReadField(LongName.Buffer),
                    LongNameStr,
                    LongName.Length,
                    NULL)) {

        return;
    }

    //
    //  Modify the node in-place so we can use normal printing
    //

    LongName.Buffer = LongNameStr;
    ShortName.Buffer = ShortNameStr;

    MakeSpace(Indent);

    dprintf("%sNode @ %08x Cr %08x%08x DK %08x%08x [",
             Space,
             Node,
             SplitLL(ReadField(CreateTime)),
             SplitLL(ReadField(DirKey)));

    //
    //  Must be kept in sync with flag usage in fsrtl\tunnel.c
    //

    if (Flags & 0x1)
        dprintf("NLA");
    else
        dprintf("LA");

    if (Flags & 0x2)
        dprintf(" KYS");
    else
        dprintf(" KYL");

    dprintf("]\n");

    dprintf("%sP %08p R %08p L %08p Sfn/Lfn \"%wZ\"/\"%wZ\"\n",
            Space,
            ReadField(CacheLinks.Parent),
            ReadField(CacheLinks.RightChild),
            ReadField(CacheLinks.LeftChild),
            &ShortName,
            &LongName );

    dprintf("%sF %08p B %08p\n",
            Space,
            ReadField(ListLinks.Flink),
            ReadField(ListLinks.Blink));

    RestoreSpace(Indent);
}

VOID DumpTunnelNodeWrapper (
    ULONG64 pCacheLinks,
    ULONG Indent
    )
{
//    TUNNEL_NODE Node, *pNode;
    static ULONG Off=0;

    if (!Off) {
        GetFieldOffset("TUNNEL_NODE", "CacheLinks", &Off);
    }

    DumpTunnelNode(pCacheLinks - Off, Indent);
}

VOID
DumpTunnel (
    ULONG64 pTunnel
    )
{
    ULONG64 pLink, pHead, NodeFlink=0, TimerQueueFlink, pNode;
    ULONG   Indent = 0, EntryCount = 0, NumEntries, Offset, ListOffset;
    ULONG64 Cache; 

    if (GetFieldValue(pTunnel, "TUNNEL", "NumEntries", NumEntries)) {
        dprintf("Can't read TUNNEL at %p\n", pTunnel);
        return;
    }
    GetFieldValue(pTunnel, "TUNNEL", "Cache", Cache);
    GetFieldValue(pTunnel, "TUNNEL", "TimerQueue.Flink", TimerQueueFlink);
    pLink = TimerQueueFlink;
    GetFieldOffset("TUNNEL", "TimerQueue", &Offset);

    dprintf("Tunnel @ %08x\n"
            "NumEntries = %ld\n\n"
            "Splay Tree @ %08x\n",
            pTunnel,
            NumEntries,
            Cache);

    EntryCount = DumpSplayTree(Cache, DumpTunnelNodeWrapper);

    if (EntryCount != NumEntries) {

        dprintf("Tree count mismatch (%d not expected %d)\n", EntryCount, NumEntries);
    }

    GetFieldOffset("TUNNEL_NODE", "ListLinks", &ListOffset);

    for (EntryCount = 0,
         pHead = pTunnel + Offset,
         pLink = TimerQueueFlink;

         pLink != pHead;

         pLink = NodeFlink,
         EntryCount++) {


        pNode = pLink - ListOffset;
        if (pLink == TimerQueueFlink) {

            dprintf("\nTimer Queue @ %08x\n", pHead);
        }

        if (GetFieldValue(pNode, "TUNNEL_NODE",
                          "ListLinks.Flink", NodeFlink)) {
            dprintf("Can't read TUNNEL_NODE at %p\n", pNode);
            return;
        }

        DumpTunnelNode(pNode, 0);
    
        if ( CheckControlC() ) {

            return;
        }
    }

    if (EntryCount != NumEntries) {

        dprintf("Timer count mismatch (%d not expected %d)\n", EntryCount, NumEntries);
    }
}


DECLARE_API( tunnel )
/*++

Routine Description:

    Dump tunnel caches

Arguments:

    arg - <Address>

Return Value:

    None

--*/
{
    ULONG64 Tunnel = 0;

    RtlFillMemory(Space, sizeof(Space), ' ');

    Tunnel = GetExpression(args);

    if (Tunnel == 0) {

        //
        //  No args
        //

        return E_INVALIDARG;
    }

    DumpTunnel(Tunnel);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\stacks.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    stacks.h

Abstract:

    This file contains the stack walking scripts for !stacks

Author:

    Adrian J. Oney (adriao) 07-28-1998

Environment:

    User Mode.

Revision History:

--*/

//
// This tree describes a tree of functions that will be "drilled" through when
// !stacks is used to give a summary of what each thread is currently doing...
//
// SKIP_FRAME - The entry should be skipped if a thread is being examined to
//              determine what "really" is going on.
//
// SKIP_THREAD - The thread should be skipped if the symbol is found on the
//               stack immediately after SKIP_FRAME processing.
//
BEGIN_TREE();
  DECLARE_ENTRY("nt!KiSwapContext", SKIP_FRAME);
  DECLARE_ENTRY("nt!KiSwapThread", SKIP_FRAME);
  DECLARE_ENTRY("nt!KiSwapThreadExit", SKIP_FRAME);
  DECLARE_ENTRY("nt!KiSystemService", SKIP_FRAME);
  DECLARE_ENTRY("nt!KiSystemServiceCopyStart", SKIP_FRAME);     // amd64
  DECLARE_ENTRY("nt!KiServiceLinkage", SKIP_FRAME);             // amd64
  DECLARE_ENTRY("nt!_KiSystemService", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeRemoveQueue", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExpWaitForResource", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExAcquireResourceSharedLite", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExAcquireResourceExclusiveLite", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExpAcquireResourceExclusiveLite", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeWaitForSingleObject", SKIP_FRAME);
  DECLARE_ENTRY("nt!VerifierKeWaitForSingleObject", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtWaitForSingleObject", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeWaitForMultipleObjects", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtWaitForMultipleObjects", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtRemoveIoCompletion", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtReplyWaitReceivePort", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtReplyWaitReceivePortEx", SKIP_FRAME);
  DECLARE_ENTRY("nt!ZwReplyWaitReceivePort", SKIP_FRAME);
  DECLARE_ENTRY("nt!IopSynchronousServiceTail", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtRequestWaitReplyPort", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeDelayExecutionThread", SKIP_FRAME);
  DECLARE_ENTRY("nt!NtDelayExecution", SKIP_FRAME);
  DECLARE_ENTRY("nt!KiUnlockDispatcherDatabase", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeSetEvent", SKIP_FRAME);
  DECLARE_ENTRY("nt!KeInsertQueue", SKIP_FRAME);
  DECLARE_ENTRY("nt!ExQueueWorkItem", SKIP_FRAME);
  DECLARE_ENTRY("win32k!EnterCrit", SKIP_FRAME);
  DECLARE_ENTRY("win32k!SfnDWORD", SKIP_FRAME);

  DECLARE_ENTRY("nt!MmZeroPageThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!PspSystemThreadStartup", SKIP_THREAD);
  DECLARE_ENTRY("nt!ExpWorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!ExpWorkerThreadBalanceManager", SKIP_THREAD);
  DECLARE_ENTRY("nt!MiDereferenceSegmentThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!MiModifiedPageWriterWorker", SKIP_THREAD);
  DECLARE_ENTRY("nt!KeBalanceSetManager", SKIP_THREAD);
  DECLARE_ENTRY("nt!KeSwapProcessOrStack", SKIP_THREAD);
  DECLARE_ENTRY("nt!FsRtlWorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!SepRmCommandServerThread", SKIP_THREAD);
  DECLARE_ENTRY("nt!MiMappedPageWriter", SKIP_THREAD);
  DECLARE_ENTRY("nt!NtGetPlugPlayEvent", SKIP_THREAD);
  DECLARE_ENTRY("nt!PspReaper", SKIP_THREAD);
  DECLARE_ENTRY("nt!WmipLogger", SKIP_THREAD);
  DECLARE_ENTRY("srv!WorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("NDIS!ndisWorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("dmio!voliod_loop", SKIP_THREAD);
  DECLARE_ENTRY("raspptp!PacketWorkingThread", SKIP_THREAD);
  DECLARE_ENTRY("raspptp!MainPassiveLevelThread", SKIP_THREAD);
  DECLARE_ENTRY("rdpdr!RxpWorkerThreadDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("rdpdr!RxSpinUpRequestsDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("mrxdav!RxpWorkerThreadDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("mrxdav!RxSpinUpRequestsDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("mrxdav!RxWorkItemDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("mrxdav!MRxDAVContextTimerThread", SKIP_THREAD);
  DECLARE_ENTRY("rdbss!RxpWorkerThreadDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("rdbss!RxSpinUpRequestsDispatcher", SKIP_THREAD);
  DECLARE_ENTRY("rasacd!AcdNotificationRequestThread", SKIP_THREAD);
  DECLARE_ENTRY("win32k!RawInputThread", SKIP_THREAD);
  DECLARE_ENTRY("win32k!xxxSleepThread", SKIP_THREAD);
  DECLARE_ENTRY("redbook!RedBookSystemThread", SKIP_THREAD);
  DECLARE_ENTRY("USBPORT!USBPORT_WorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("ACPI!ACPIWorker", SKIP_THREAD);
  DECLARE_ENTRY("kmixer!MxPrivateWorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("irda!RxThread", SKIP_THREAD);
  DECLARE_ENTRY("irenum!WorkerThread", SKIP_THREAD);
  DECLARE_ENTRY("ltmdmntt!WriteRegistryThread", SKIP_THREAD);
  DECLARE_ENTRY("ltmdmntt!WakeupTimerThread", SKIP_THREAD);
  DECLARE_ENTRY("TDI!CTEpEventHandler", SKIP_THREAD);
  DECLARE_ENTRY("parport!P5FdoThread", SKIP_THREAD);
  DECLARE_ENTRY("parport!PptPdoThread", SKIP_THREAD);
  DECLARE_ENTRY("HTTP!UlpThreadPoolWorker", SKIP_THREAD);
  DECLARE_ENTRY("*SharedIntelSystemCall", SKIP_THREAD);
  DECLARE_ENTRY("*SharedUserSystemCall", SKIP_THREAD);
  DECLARE_ENTRY("SharedUserData!SystemCallStub", SKIP_THREAD);

END_TREE();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\thermal.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    thermal

Abstract:

    WinDbg Extension Api

Author:

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define TZ_LOOP             0x00000001
#define TZ_DUMP_INFO        0x00000002
#define TZ_NO_HEADER        0x80000000

PCHAR    DumpPowerStateMappings[10] = {
    "x", "0", "1", "2", "3", "4", "5", "?", "?", "?"
};

PCHAR    DumpPowerActionMappings[] = {
    "     None",
    " Reserved",
    "    Sleep",
    "Hibernate",
    " Shutdown",
    "    Reset",
    "      Off"
};

PCHAR   DumpDynamicThrottleMapping[] = {
    "    None",
    "Constant",
    " Degrade",
    "Adaptive",
    " Maximum"
};

PCHAR
DumpTimeInStandardForm(
    IN  ULONG64   CurrentTime
    )
/*++

Routine Description:

    Print the Kernel's view of time into something that a user can
    understand

Arguments:

    CurrentTime - Kernel's Idea of time

Return Value:

    None

--*/
{
    static  CHAR    TimeBuffer[256];
    ULONG           TimeIncrement;
    TIME_FIELDS     Times;
    LARGE_INTEGER   RunTime;

    TimeIncrement = GetNtDebuggerDataValue( KeTimeIncrement );
    RunTime.QuadPart = UInt32x32To64(CurrentTime, TimeIncrement);
    RtlTimeToElapsedTimeFields( &RunTime, &Times);
    if (Times.Hour) {
        sprintf(TimeBuffer,"%3ld:%02ld:%02ld.%03lds",
                Times.Hour,
                Times.Minute,
                Times.Second,
                Times.Milliseconds);
    } else if (Times.Minute) {
        sprintf(TimeBuffer,"%02ld:%02ld.%03lds",
                Times.Minute,
                Times.Second,
                Times.Milliseconds);
    } else {
        sprintf(TimeBuffer,"%02ld.%03lds",
                Times.Second,
                Times.Milliseconds);
    }
    return TimeBuffer;
}

PCHAR
DumpMicroSecondsInStandardForm(
    IN  ULONG64 CurrentTime
    )
{
    static CHAR     PerfBuffer[256];
    ULONG64         FreqAddr;
    LARGE_INTEGER   Freq;
    ULONG           Result;
    ULONG64         MicroSeconds;
    ULONG64         MilliSeconds;
    ULONG64         Seconds;
    ULONG64         Minutes;
    ULONG64         Hours;
    ULONG64         Days;

    MicroSeconds = CurrentTime;
    MilliSeconds = MicroSeconds / 1000;
    MicroSeconds = MicroSeconds % 1000;

    Seconds      = MilliSeconds / 1000;
    MilliSeconds = MilliSeconds % 1000;

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    Hours   = Minutes / 60;
    Minutes = Minutes % 60;

    Days  = Hours / 24;
    Hours = Hours % 24;

#if 0
    sprintf(PerfBuffer,"%02ld:%02ld:%02ld.%03ld.%03lds",
            (ULONG)Hours,
            (ULONG)Minutes,
            (ULONG)Seconds,
            (ULONG)MilliSeconds,
            (ULONG)MicroSeconds
            );
    return PerfBuffer;
#endif

    if (Hours) {
        sprintf(PerfBuffer,"%02ld:%02ld:%02ld.%03ld.%03lds",
                (ULONG)Hours,
                (ULONG)Minutes,
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else if (Minutes) {
        sprintf(PerfBuffer,"%02ld:%02ld.%03ld.%03lds",
                (ULONG)Minutes,
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else if (Seconds) {
        sprintf(PerfBuffer,"%02ld.%03ld.%03lds",
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else {
        sprintf(PerfBuffer,".%03ld.%03lds",
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    }
    return PerfBuffer;
}


PCHAR
DumpPerformanceCounterInStandardForm(
    IN  ULONG64 CurrentTime
    )
/*++

Routine Description:

    Print a performance counter's view of time into something that a
    user can understand

--*/
{
    static CHAR     PerfBuffer[256];
    ULONG64         FreqAddr;
    LARGE_INTEGER   Freq;
    ULONG           Result;
    ULONG64         MicroSeconds;
    ULONG64         MilliSeconds;
    ULONG64         Seconds;
    ULONG64         Minutes;
    ULONG64         Hours;
    ULONG64         Days;

    FreqAddr = GetExpression( "nt!KdPerformanceCounterRate" );
    if (!FreqAddr || !ReadMemory( FreqAddr, &Freq, sizeof(Freq), &Result) ) {
        sprintf(PerfBuffer,"<unknown rate>");
        return PerfBuffer;
    }


    MicroSeconds = (CurrentTime * 1000000L) / Freq.LowPart;
    MilliSeconds = MicroSeconds / 1000;
    MicroSeconds = MicroSeconds % 1000;

    Seconds      = MilliSeconds / 1000;
    MilliSeconds = MilliSeconds % 1000;

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    Hours   = Minutes / 60;
    Minutes = Minutes % 60;

    Days  = Hours / 24;
    Hours = Hours % 24;

#if 0
    sprintf(PerfBuffer,"%02ld:%02ld:%02ld.%03ld.%03lds",
            (ULONG)Hours,
            (ULONG)Minutes,
            (ULONG)Seconds,
            (ULONG)MilliSeconds,
            (ULONG)MicroSeconds
            );
    return PerfBuffer;
#endif

    if (Hours) {
        sprintf(PerfBuffer,"%02ld:%02ld:%02ld.%03ld.%03lds",
                (ULONG)Hours,
                (ULONG)Minutes,
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else if (Minutes) {
        sprintf(PerfBuffer,"%02ld:%02ld.%03ld.%03lds",
                (ULONG)Minutes,
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else if (Seconds) {
        sprintf(PerfBuffer,"%02ld.%03ld.%03lds",
                (ULONG)Seconds,
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    } else {
        sprintf(PerfBuffer,".%03ld.%03lds",
                (ULONG)MilliSeconds,
                (ULONG)MicroSeconds
                );
    }
    return PerfBuffer;
}

VOID
DumpTemperatureInKelvins(
    IN  ULONG                   Temperature
    )
/*++

Routine Description:

    Dumps the temperatures in Kelvins

Arguments:

    Temperature - What to dump in Kelvins

Return Value:

    None

--*/
{
    dprintf(" (%d.%dK)", (Temperature / 10), (Temperature % 10) );
}

VOID
DumpPowerActionPolicyBrief(
    IN  ULONG    Action,
    IN  ULONG    Flags,
    IN  ULONG    EventCode
    )
{
    dprintf("%s  Flags: %08lx   Event: %08lx  ",
            DumpPowerActionMappings[Action],
            Flags,
            EventCode
            );
    if (Flags & POWER_ACTION_QUERY_ALLOWED) {

        dprintf(" Query");

    }
    if (Flags & POWER_ACTION_UI_ALLOWED) {

        dprintf(" UI");

    }
    if (Flags & POWER_ACTION_OVERRIDE_APPS) {

        dprintf(" Override");

    }
    if (Flags & POWER_ACTION_LOCK_CONSOLE) {

        dprintf(" Lock");

    }
    if (Flags & POWER_ACTION_DISABLE_WAKES) {

        dprintf(" NoWakes");

    }
    if (Flags & POWER_ACTION_CRITICAL) {

        dprintf(" Critical");

    }

    if (EventCode & POWER_LEVEL_USER_NOTIFY_TEXT) {

        dprintf(" NotifyText");

    }
    if (EventCode & POWER_LEVEL_USER_NOTIFY_SOUND) {

        dprintf(" NotifySound");

    }
    if (EventCode & POWER_LEVEL_USER_NOTIFY_EXEC) {

        dprintf(" NotifyExec");

    }
    dprintf("\n");
}

VOID
DumpSystemPowerPolicy(
    IN  PCHAR                  Pad,
    IN  ULONG64                Address,
    IN  ULONG                  Flags
    )
/*++

Routine Description:

    System Power Policy change

Arguments:

Return Value:

--*/
{
    UCHAR   temp;

    InitTypeRead(Address, nt!_SYSTEM_POWER_POLICY);
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sSYSTEM_POWER_POLICY (R.%d) @ 0x%08p\n",
                Pad, (ULONG) ReadField(Revision), Address);

    }

    temp = (UCHAR) ReadField(DynamicThrottle);
    if (temp > PO_THROTTLE_MAXIMUM) {
        temp = PO_THROTTLE_MAXIMUM;
    }

    dprintf("%s  PowerButton:     ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(PowerButton.Action),
                                (ULONG) ReadField(PowerButton.Flags),
                                (ULONG) ReadField(PowerButton.EventCode));
    dprintf("%s  SleepButton:     ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(SleepButton.Action),
                                (ULONG) ReadField(SleepButton.Flags),
                                (ULONG) ReadField(SleepButton.EventCode));
    dprintf("%s  LidClose:        ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(LidClose.Action),
                                (ULONG) ReadField(LidClose.Flags),
                                (ULONG) ReadField(LidClose.EventCode));
    dprintf("%s  Idle:            ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(Idle.Action),
                                (ULONG) ReadField(Idle.Flags),
                                (ULONG) ReadField(Idle.EventCode));
    dprintf("%s  OverThrottled:   ", Pad);
    DumpPowerActionPolicyBrief( (ULONG) ReadField(OverThrottled.Action),
                                (ULONG) ReadField(OverThrottled.Flags),
                                (ULONG) ReadField(OverThrottled.EventCode));
    dprintf("%s  IdleTimeout:      %8lx  IdleSensitivity:        %d%%\n",
            Pad,
            (ULONG) ReadField(IdleTimeout),
            (ULONG) ReadField(IdleSensitivity));
    dprintf("%s  MinSleep:               S%s  MaxSleep:               S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(MinSleep)],
            DumpPowerStateMappings[(ULONG) ReadField(MaxSleep)]);
    dprintf("%s  LidOpenWake:            S%s  FastSleep:              S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(LidOpenWake)],
            DumpPowerStateMappings[(ULONG) ReadField(ReducedLatencySleep)]);
    dprintf("%s  WinLogonFlags:    %8lx  S4Timeout:        %8lx\n",
            Pad,
            (ULONG) ReadField(WinLogonFlags),
            (ULONG) ReadField(DozeS4Timeout));
    dprintf("%s  VideoTimeout:     %8d  VideoDim:               %2d\n",
            Pad,
            (ULONG) ReadField(VideoTimeout),
            (ULONG) ReadField(VideoDimDisplay));
    dprintf("%s  SpinTimeout:      %8lx  OptForPower:            %2d\n",
            Pad,
            (ULONG) ReadField(SpindownTimeout),
            (ULONG) ReadField(OptimizeForPower)
            );
    dprintf("%s  FanTolerance:         %4d%% ForcedThrottle:       %4d%%\n",
            Pad,
            (ULONG) ReadField(FanThrottleTolerance),
            (ULONG) ReadField(ForcedThrottle));
    dprintf("%s  MinThrottle:          %4d%% DyanmicThrottle:  %8s (%d)\n",
            Pad, (ULONG) ReadField(MinThrottle),
            DumpDynamicThrottleMapping[temp],
            temp
            );
}

DECLARE_API( popolicy )
/*++

Routine Description:

    Dumps the power policy

Arguments:

Return Value:

--*/
{
    ULONG64                     Address = 0;
    ULONG64                     PolicyAddress;
    ULONG                       Flags = 0;
    ULONG                       Result;

    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (!Address) {

        Address = GetExpression("nt!PopPolicy");
        if (!Address) {

            dprintf("Could not read PopPolicy\n");
            return E_INVALIDARG;

        }
        if (!ReadPointer(Address,
                    &PolicyAddress) ) {

            dprintf("Could not read PopPolicy at %p\n", Address );
            return E_INVALIDARG;

        }
        Address = PolicyAddress;

    }
    if (!Address) {

        dprintf("!popolicy [addr [flags]]\n");
        return E_INVALIDARG;

    }

    if (GetFieldValue( Address,
                       "nt!_SYSTEM_POWER_POLICY",
                       "Revision",
                       Result) ) {

        dprintf("Could not read PopPolicy at %p\n", Address );
        return E_INVALIDARG;

    }

    DumpSystemPowerPolicy( "", Address, Flags );
    return S_OK;
}

VOID
DumpProcessorPowerPolicy(
    IN  PCHAR                  Pad,
    IN  ULONG64                Address,
    IN  ULONG                  Flags
    )
/*++

Routine Description:

    Processor Power Policy change

Arguments:

Return Value:

--*/
{
    ULONG   i;
    ULONG   count;
    ULONG   offset;
    ULONG64 size;

    InitTypeRead(Address, nt!_PROCESSOR_POWER_POLICY);
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sPROCESSOR_POWER_POLICY %p (Rev .%d)\n",
                Pad,
                Address,
                (ULONG) ReadField(Revision)
                );

    }

    dprintf(
        "%s  DynamicThrottle:                %4d   PolicyCount:                 %8d\n",
        Pad,
        (ULONG) ReadField(DynamicThrottle),
        (ULONG) ReadField(PolicyCount)
        );

    GetFieldOffset("nt!_PROCESSOR_POWER_POLICY", "Policy", &offset);
    Address += offset;
    size = GetTypeSize("nt!_PROCESSOR_POWER_POLICY_INFO");
    count = (ULONG) ReadField(PolicyCount);
    if (count > 3) {

        count = 3;

    }

    //
    // Walk the PROCESSOR_POWER_POLICY_INFO structures
    //
    for (i = 0; i < count; i++) {

        InitTypeRead(Address, nt!_PROCESSOR_POWER_POLICY_INFO);
        dprintf(
            "\n%s  PROCESSOR_POWER_POLICY_INFO %p\n",
            Pad,
            Address
            );
        dprintf(
            "%s  PromotePercent:                 %4d%%  DemotePercent:             %4d%%\n",
            Pad,
            (ULONG) ReadField( PromotePercent ),
            (ULONG) ReadField( DemotePercent )
            );
        dprintf(
            "%s  AllowPromotion:                %5s   AllowDemotion:            %5s\n",
            Pad,
            ( (ULONG) ReadField( AllowPromotion ) ? " TRUE" : "FALSE"),
            ( (ULONG) ReadField( AllowDemotion) ? " TRUE" : "FALSE")
            );
        dprintf(
            "%s  TimeCheck:                %21s (%8p)\n",
            Pad,
            DumpMicroSecondsInStandardForm( ReadField( TimeCheck ) ),
            (ULONG) ReadField( TimeCheck )
            );
        dprintf(
            "%s  PromoteLimit:             %21s (%8p)\n",
            Pad,
            DumpMicroSecondsInStandardForm( ReadField( PromoteLimit ) ),
            (ULONG) ReadField( PromoteLimit )
            );
        dprintf(
            "%s  DemoteLimit:              %21s (%8p)\n",
            Pad,
            DumpMicroSecondsInStandardForm( ReadField( DemoteLimit ) ),
            (ULONG) ReadField( DemoteLimit )
            );
        Address += size;

    }

}

DECLARE_API( poprocpolicy )
/*++

Routine Description:

    Dumps the power policy

Arguments:

Return Value:

--*/
{
    ULONG64                     Address = 0;
    ULONG64                     PolicyAddress;
    ULONG                       Flags = 0;
    ULONG                       Result;

    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (!Address) {

        Address = GetExpression("nt!PopProcessorPolicy");
        if (!Address) {

            dprintf("Could not read PopProcessorPolicy\n");
            return E_INVALIDARG;

        }
        if (!ReadPointer(Address,&PolicyAddress) ) {

            dprintf("Could not read PopProcessorPolicy at %p\n", Address );
            return E_INVALIDARG;

        }
        Address = PolicyAddress;

    }
    if (!Address) {

        dprintf("!poprocpolicy [addr [flags]]\n");
        return E_INVALIDARG;

    }

    if (GetFieldValue( Address,"PROCESSOR_POWER_POLICY", "Revision", Result) ) {

        dprintf("Could not read PopProcessorPolicy at %p\n", Address );
        return E_INVALIDARG;

    }

    DumpProcessorPowerPolicy( "", Address, Flags );
    return S_OK;
}

VOID
DumpProcessorPowerState(
    IN  PCHAR                 Pad,
    IN  ULONG64               Address,
    IN  ULONG                 Flags
    )
/*++

Routine Description:

    Processor Power State dump

Arguments:

Return Value:

--*/
{
    ULONG   time;
    ULONG   temp;
    CHAR    FunctionName[256];
    ULONG64 Offset;

    InitTypeRead(Address, nt!_PROCESSOR_POWER_STATE);
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sPROCESSOR_POWER_STATE %p\n", Pad, Address );

    }

    dprintf(
        "%s  IdleState:          %16p   IdleHandlers:       %16p\n",
        Pad,
        ReadField(IdleState),
        ReadField(IdleHandlers)
        );
    dprintf(
        "%s  C1 Idle Transitions:        %8lx   C1 Idle Time:       %17s\n",
        Pad,
        (ULONG) ReadField( TotalIdleTransitions[0] ),
        DumpPerformanceCounterInStandardForm( ReadField( TotalIdleStateTime[0] ) )
        );
    dprintf(
        "%s  C2 Idle Transitions:        %8lx   C2 Idle Time:       %17s\n",
        Pad,
        (ULONG) ReadField( TotalIdleTransitions[1] ),
        DumpPerformanceCounterInStandardForm( ReadField( TotalIdleStateTime[1] ) )
        );
    dprintf(
        "%s  C3 Idle Transitions:        %8lx   C3 Idle Time:       %17s\n\n",
        Pad,
        (ULONG) ReadField( TotalIdleTransitions[2] ),
        DumpPerformanceCounterInStandardForm( ReadField( TotalIdleStateTime[2] ) )
        );
    dprintf(
        "%s  DebugDelta:         %16I64x   LastCheck:          %17s\n",
        Pad,
        ReadField(DebugDelta),
        DumpPerformanceCounterInStandardForm( ReadField( LastCheck ) )
        );
    dprintf(
        "%s  DebugCount:                 %8lx   IdleTime.Start:     %17s\n",
        Pad,
        (ULONG) ReadField(DebugCount),
        DumpPerformanceCounterInStandardForm( ReadField( IdleTimes.StartTime ) )
        );
    dprintf(
        "%s  PromotionCheck:             %8lx   IdleTime.End:       %17s\n",
        Pad,
        (ULONG) ReadField(PromotionCheck ),
        DumpPerformanceCounterInStandardForm( ReadField( IdleTimes.EndTime ) )
        );
    dprintf(
        "%s  IdleTime1:                  %8lx   Idle0LastTime:      %17s\n",
        Pad,
        (ULONG) ReadField(IdleTime1),
        DumpTimeInStandardForm( ReadField( Idle0LastTime ) )
        );
    dprintf(
        "%s  IdleTime2:                  %8lx   LastSystTime:       %17s\n",
        Pad,
        (ULONG) ReadField(IdleTime2),
        DumpTimeInStandardForm( ReadField( LastSysTime ) )
        );
    dprintf(
        "%s  CurrentThrottle:                %4d%%  Idle0KernelTimeLimit: %15s\n",
        Pad,
        (ULONG) ReadField(CurrentThrottle),
        DumpTimeInStandardForm( ReadField( Idle0KernelTimeLimit ) )
        );
    dprintf(
        "%s  CurrentThrottleIndex:           %4d   ThermalThrottleLimit:           %4d%%\n",
        Pad,
        (ULONG) ReadField(CurrentThrottleIndex),
        (ULONG) ReadField(ThermalThrottleLimit)
        );
    dprintf(
        "%s  KneeThrottleIndex:              %4d   ThermalThrottleIndex:           %4d\n",
        Pad,
        (ULONG) ReadField(KneeThrottleIndex),
        (ULONG) ReadField(ThermalThrottleIndex)
        );
    dprintf(
        "%s  ThrottleLimitIndex:             %4d   Flags:                      %8x\n",
        Pad,
        (ULONG) ReadField(ThrottleLimitIndex),
        (ULONG) ReadField(Flags)
        );
    dprintf(
        "%s  PerfStates:                 %8p   PerfStatesCount:                %4d\n",
        Pad,
        ReadField(PerfStates),
        (ULONG) ReadField(PerfStatesCount)
        );
    dprintf(
        "%s  ProcessorMinThrottle:           %4d%%  ProcessorMaxThrottle:           %4d%%\n",
        Pad,
        (ULONG) ReadField(ProcessorMinThrottle),
        (ULONG) ReadField(ProcessorMaxThrottle)
        );
    dprintf(
        "%s  PromotionCount:             %8d   DemotionCount:              %8d\n",
        Pad,
        (ULONG) ReadField( PromotionCount ),
        (ULONG) ReadField( DemotionCount )
        );
    dprintf(
        "%s  ErrorCount:                 %8d   RetryCount:                 %8d\n",
        Pad,
        (ULONG) ReadField(ErrorCount),
        (ULONG) ReadField(RetryCount)
        );
    dprintf(
        "%s  LastBusyPercentage:             %4d%%  LastC3Percentage:               %4d%%\n",
        Pad,
        (ULONG) ReadField( LastBusyPercentage ),
        (ULONG) ReadField( LastC3Percentage )
        );
    dprintf(
        "%s  LastAdjustedBusyPercent:        %4d%%\n",
        Pad,
        (ULONG) ReadField(LastAdjustedBusyPercentage)
        );
    dprintf("\n");
    GetSymbol(ReadField(IdleFunction), FunctionName, &Offset);
    dprintf(
        "%s  IdleFunction:            %50s\n",
        Pad,
        FunctionName
        );
    GetSymbol(ReadField(PerfSetThrottle), FunctionName, &Offset);
    dprintf(
        "%s  PerfSetThrottle:         %50s\n",
        Pad,
        FunctionName
        );
    dprintf(
        "%s  PreviousC3StateTime:      %21s (%16p)\n",
        Pad,
        DumpPerformanceCounterInStandardForm( ReadField( PreviousC3StateTime ) ),
        ReadField( PreviousC3StateTime )
        );
    dprintf(
        "%s  PerfSystemTime:           %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( ReadField(PerfSystemTime) ),
        ReadField( PerfSystemTime )
        );
    dprintf(
        "%s  PerfIdleTime:             %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( ReadField(PerfIdleTime) ),
        ReadField( PerfIdleTime )
        );
    dprintf(
        "%s  PerfTickCount:            %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( ReadField(PerfTickCount) ),
        ReadField( PerfTickCount )
        );

    //
    // At this point, go look at the corresponding PRCB to see what the
    // kernel and user times are
    //
    GetFieldOffset("nt!_KPRCB", "PowerState", &temp);
    Address -= temp;
    InitTypeRead( Address, _KPRCB );
    time = (ULONG) ReadField(UserTime) + (ULONG) ReadField(KernelTime);
    dprintf(
        "%s  CurrentSystemTime:        %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( time ),
        time
        );

    //
    // Read the Idle Thread to see what the current idle thread time is
    //
    Address = ReadField( IdleThread );
    InitTypeRead( Address, _KTHREAD );
    time = (ULONG) ReadField(KernelTime);
    dprintf(
        "%s  CurrentIdleTime:          %21s (%8x)\n",
        Pad,
        DumpTimeInStandardForm( time ),
        time
        );

}

DECLARE_API( poproc )
/*++

Routine Description:

    Dumps the Processor Power State

Arguments:

Return Value:

--*/
{
    ULONG64  Address = 0;
    ULONG64  Pkprcb;
    ULONG    Flags = 0;
    ULONG    processor;
    ULONG64  Result;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }

    if (Address == 0) {

        HRESULT Hr;

        INIT_API();

        GetCurrentProcessor(Client, &processor, NULL);

        Hr = g_ExtData->ReadProcessorSystemData(processor,
                                                DEBUG_DATA_KPRCB_OFFSET,
                                                &Pkprcb,
                                                sizeof(Pkprcb),
                                                NULL);


        if (Hr != S_OK)
        {
            dprintf("Cannot get PRCB address\n");
        }
        else
        {
            InitTypeRead(Pkprcb,nt!_KPRCB);
            Address = ReadField(PowerState);
            if (!Address)
            {
                dprintf("Unable to get PowerState from the PRCB at %p",Pkprcb);
                dprintf("poproc <address>\n");
                Hr = E_INVALIDARG;

            }
        }

        if (Hr != S_OK)
        {
            return Hr;
        }
    }

    if (GetFieldValue( Address,
                       "PROCESSOR_POWER_STATE",
                       "IdleTime1",
                       Result) ) {

        dprintf("Could not read PROCESSOR_POWER_STATE at %08p\n", Address );
        return E_INVALIDARG;

    }

    //
    // Dump the Trigger Information
    //
    DumpProcessorPowerState("", Address, Flags );

    return S_OK;
}

VOID
DumpPowerCapabilities(
    IN  PCHAR                      Pad,
    IN  ULONG64                    Address,
    IN  ULONG                      Flags
    )
/*++

Routine Description:

    Dumps the power capabilities

Arguments:

Return Value:

--*/
{
    InitTypeRead(Address, nt!SYSTEM_POWER_CAPABILITIES);
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sPopCapabilities @ 0x%08p\n", Pad, Address );

    }

    dprintf("%s  Misc Supported Features: ", Pad);
    if ((ULONG) ReadField(PowerButtonPresent)) {

        dprintf(" PwrButton");
    }
    if ((ULONG) ReadField(SleepButtonPresent)) {

        dprintf(" SlpButton");
    }
    if ((ULONG) ReadField(LidPresent)) {

        dprintf(" Lid");
    }
    if ((ULONG) ReadField(SystemS1)) {

        dprintf(" S1");
    }
    if ((ULONG) ReadField(SystemS2)) {

        dprintf(" S2");
    }
    if ((ULONG) ReadField(SystemS3)) {

        dprintf(" S3");
    }
    if ((ULONG) ReadField(SystemS4)) {

        dprintf(" S4");
    }
    if ((ULONG) ReadField(SystemS5)) {

        dprintf(" S5");
    }
    if ((ULONG) ReadField(HiberFilePresent)) {

        dprintf(" HiberFile");
    }
    if ((ULONG) ReadField(FullWake)) {

        dprintf(" FullWake");
    }
    if ((ULONG) ReadField(VideoDimPresent)) {

        dprintf(" VideoDim");
    }
    dprintf("\n");

    dprintf("%s  Processor Features:      ", Pad);
    if ((ULONG) ReadField(ThermalControl)) {

        dprintf(" Thermal");
    }
    if ((ULONG) ReadField(ProcessorThrottle)) {

        dprintf(" Throttle (MinThrottle = %d%%, Scale = %d%%)",
                (ULONG) ReadField(ProcessorMinThrottle),
                (ULONG) ReadField(ProcessorThrottleScale));

    }
    dprintf("\n");

    dprintf("%s  Disk Features:           ", Pad );
    if ((ULONG) ReadField(DiskSpinDown)) {

        dprintf(" SpinDown");
    }
    dprintf("\n");

    dprintf("%s  Battery Features:        ", Pad);
    if ((ULONG) ReadField(SystemBatteriesPresent)) {

        dprintf(" BatteriesPresent");

    }
    if ((ULONG) ReadField(BatteriesAreShortTerm)) {

        dprintf(" ShortTerm");
    }
    dprintf("\n");
    if ((ULONG) ReadField(SystemBatteriesPresent)) {

        dprintf("%s    Battery 0 - Capacity: %8lx  Granularity: %8lx\n",
                Pad,
                (ULONG) ReadField(BatteryScale[0].Capacity),
                (ULONG) ReadField(BatteryScale[0].Granularity)
                );
        dprintf("%s    Battery 1 - Capacity: %8lx  Granularity: %8lx\n",
                Pad,
                (ULONG) ReadField(BatteryScale[1].Capacity),
                (ULONG) ReadField(BatteryScale[1].Granularity)
                );
        dprintf("%s    Battery 2 - Capacity: %8lx  Granularity: %8lx\n",
                Pad,
                (ULONG) ReadField(BatteryScale[2].Capacity),
                (ULONG) ReadField(BatteryScale[2].Granularity)
                );

    }
    dprintf("%s  Wake Caps\n", Pad);
    dprintf("%s    Ac OnLine Wake:         S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(AcOnLineWake)]);
    dprintf("%s    Soft Lid Wake:          S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(SoftLidWake)]);
    dprintf("%s    RTC Wake:               S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(RtcWake)]);
    dprintf("%s    Min Device Wake:        S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(MinDeviceWakeState)]);
    dprintf("%s    Default Wake:           S%s\n",
            Pad,
            DumpPowerStateMappings[(ULONG) ReadField(DefaultLowLatencyWake)]);

}

DECLARE_API( pocaps )
/*++

Routine Description:

    Dumps the power capabilities

Arguments:

Return Value:

--*/
{
    ULONG64                     Address = 0;
    ULONG                       Flags = 0;
    ULONG                       Result;

    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (!Address) {

        Address = GetExpression("nt!PopCapabilities");
        if (!Address) {

            dprintf("Could not read PopCapabilities\n");
            return E_INVALIDARG;

        }

    }
    if (!Address) {

        dprintf("!pocaps [addr [flags]]\n");
        return E_INVALIDARG;

    }
    if (GetFieldValue(Address,
                      "nt!SYSTEM_POWER_CAPABILITIES",
                      "PowerButtonPresent",
                      Result) ) {

        dprintf("Could not read PopCapabilities at %08p\n", Address );
        return E_INVALIDARG;

    }
    DumpPowerCapabilities( "", Address, Flags );
    return S_OK;
}

VOID
DumpPopActionTrigger(
    IN  PCHAR              Pad,
    IN  ULONG64            Address,
    IN  ULONG              Flags
    )
/*++

--*/
{
    ULONG Type, PopFlags;

    InitTypeRead(Address, nt!_POP_ACTION_TRIGGER);

    //
    // Header line
    //
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sPOP_ACTION_TRIGGER @ 0x%08p\n", Pad, Address );

    }

    dprintf("%s  Type:  ", Pad);
    switch(Type = (ULONG) ReadField(Type)) {
    case PolicyDeviceSystemButton:
        dprintf("    SystemButton"); break;
    case PolicyDeviceThermalZone:
        dprintf("     ThermalZone"); break;
    case PolicyDeviceBattery:
        dprintf("         Battery"); break;
    case PolicyInitiatePowerActionAPI:
        dprintf("   InitActionAPI"); break;
    case PolicySetPowerStateAPI:
        dprintf("     SetStateAPI"); break;
    case PolicyImmediateDozeS4:
        dprintf("          DozeS4"); break;
    case PolicySystemIdle:
        dprintf("      SystemIdle"); break;
    default:
        dprintf("         Unknown"); break;
    }

    dprintf("  Flags:   %02x%02x%02x%02x",
            (ULONG) ReadField(Spare[2]),
            (ULONG) ReadField(Spare[1]),
            (ULONG) ReadField(Spare[0]),
            (PopFlags = (ULONG) ReadField(Flags)));
    if (PopFlags & PO_TRG_USER) {

        dprintf(" UserAction");

    }
    if (PopFlags & PO_TRG_SYSTEM) {

        dprintf(" SystemAction");

    }
    if (PopFlags & PO_TRG_SYNC) {

        dprintf(" Sync");

    }
    if (PopFlags & PO_TRG_SET) {

        dprintf(" Set");

    }
    dprintf("\n");

    if (Type != PolicyDeviceBattery) {

        dprintf("%s  Wait Trigger:  %08p\n", Pad, ReadField(Wait ));

    } else {

        dprintf("%s  BatteryLevel:  %08lx\n", Pad, (ULONG) ReadField(Battery.Level ));

    }

}

DECLARE_API( potrigger )
/*++

Routine Description:

    Dumps a Pop Action Trigger

Arguments:

Return Value:

--*/
{
    ULONG64             Address = 0;
    ULONG               Flags = 0;
    ULONG               Result;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (Address == 0) {

        dprintf("potrigger <address>\n");
        return E_INVALIDARG;

    }
    if (GetFieldValue(Address,
                      "nt!_POP_ACTION_TRIGGER",
                      "Type",
                      Result) ) {

        dprintf("Could not read POP_ACTION_TRIGGER at %08p\n", Address );
        return E_INVALIDARG;

    }

    //
    // Dump the Trigger Information
    //
    DumpPopActionTrigger("", Address, Flags );

    return S_OK;
}

VOID
DumpThermalZoneInformation(
    IN  PCHAR                  Pad,
    IN  ULONG64                Address,
    IN  ULONG                  Flags
    )
/*++

Routine Description:

    Displays the thermal zone information structure

Arguments:

Return Value:

--*/
{
    ULONG   i, Count;

    InitTypeRead(Address, nt!_THERMAL_INFORMATION);
    //
    // Header line
    //
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%sThermalInfo @ 0x%08p\n", Pad, Address );

    }

    //
    // First line
    //
    dprintf("%s  Stamp:         %08lx  Constant1:  %08lx  Constant2:  %08lx\n",
            Pad,
            (ULONG) ReadField(ThermalStamp),
            (ULONG) ReadField(ThermalConstant1),
            (ULONG) ReadField(ThermalConstant2));

    //
    // Second Line
    //
    dprintf("%s  Affinity:      %08lx  Period:     %08lx  ActiveCnt:  %08lx\n",
            Pad,
            (ULONG) ReadField(Processors),
            (ULONG) ReadField(SamplingPeriod),
            (ULONG) ReadField(ActiveTripPointCount ));

    //
    // Temperatures
    //
    dprintf("%s  Current Temperature:                 %08lx",
            Pad,
            (ULONG) ReadField(CurrentTemperature ));
    DumpTemperatureInKelvins((ULONG) ReadField(CurrentTemperature));
    dprintf("\n");
    dprintf("%s  Passive TripPoint Temperature:       %08lx",
            Pad,
            (ULONG) ReadField(PassiveTripPoint ));
    DumpTemperatureInKelvins((ULONG) ReadField(PassiveTripPoint));
    dprintf("\n");

    //
    // Active trip points
    //
    Count = (ULONG) ReadField(ActiveTripPointCount);
    for (i = 0; i < Count; i++) {
        CHAR Buff[40];
        ULONG Act;

        sprintf(Buff, "ActiveTripPoint[%d]", i);
        dprintf("%s  Active TripPoint Temperature %d:      %08lx",
                Pad,
                i,
                (Act = (ULONG) GetShortField(0, Buff, 0)));
        DumpTemperatureInKelvins(Act);
        dprintf("\n");

    }

    //
    // Dump critical temperatures
    //
    dprintf("%s  Critical TripPoint Temperature:      %08lx",
            Pad,
            (ULONG) ReadField(CriticalTripPoint ));
    DumpTemperatureInKelvins((ULONG) ReadField(CriticalTripPoint));
    dprintf("\n");

}

DECLARE_API( tzinfo )
/*++

Routine Description:

    Dumps the thermal zone information structure

Arguments:

Return Value:

--*/
{
//    THERMAL_INFORMATION ThermalInfo;
    ULONG64             Address = 0;
    ULONG               Flags = 0;
    ULONG               Result;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (Address == 0) {

        dprintf("tzinfo <address>\n");
        return E_INVALIDARG;

    }
    if (GetFieldValue(Address,
                      "nt!_THERMAL_INFORMATION",
                      "ThermalStamp",
                      Result) ) {

        dprintf("Could not read THERMAL_INFO at %08p\n", Address );
        return E_INVALIDARG;

    }

    //
    // Dump the thermal zone information
    //
    DumpThermalZoneInformation("", Address, Flags );

    return S_OK;
}

VOID
DumpThermalZone(
    IN  ULONG              Count,
    IN  PCHAR              Pad,
    IN  ULONG64            Address,
    IN  ULONG              Flags
    )
/*++

Routine Description:

    Dumps a thermal zone

--*/
{
    ULONG ThFlags, Off1, Off2, LastTemp;

    InitTypeRead(Address, NT!_POP_THERMAL_ZONE);
    //
    // Header line
    //
    if (!(Flags & TZ_NO_HEADER)) {

        dprintf("%s%d - ThermalZone @ 0x%08p\n", Pad, Count, Address );

    }

    //
    // First line
    //
    dprintf("%s  State:         ",Pad);
    switch ((ULONG) ReadField(State)) {
    case 1: dprintf("    Read"); break;
    case 2: dprintf("Set Mode"); break;
    case 3: dprintf("  Active"); break;
    default:dprintf("No State"); break;
    }
    dprintf("  Flags:               %08lx", (ThFlags = (ULONG) ReadField(Flags)));
    if (ThFlags & PO_TZ_THROTTLING) {
        dprintf(" Throttling");
    }
    if (ThFlags & PO_TZ_CLEANUP) {
        dprintf(" CleanUp");
    }
    dprintf("\n");

    //
    // Second Line
    //
    dprintf("%s  Mode:          ", Pad );
    switch((ULONG) ReadField(Mode)) {
    case 0: dprintf("  Active"); break;
    case 1: dprintf(" Passive"); break;
    default: dprintf(" Invalid"); break;
    }
    dprintf("  PendingMode:         ");
    switch((ULONG) ReadField(PendingMode)) {
    case 0: dprintf("  Active"); break;
    case 1: dprintf(" Passive"); break;
    default: dprintf(" Invalid"); break;
    }
    dprintf("\n");


    dprintf("%s  ActivePoint:   %08lx  PendingTrp:          %08lx\n",
            Pad, (ULONG) ReadField(ActivePoint), (ULONG) ReadField(PendingActivePoint ));
    dprintf("%s  SampleRate:    %08lx  LastTime:    %016I64x\n",
            Pad, (ULONG) ReadField(SampleRate), ReadField(LastTime ));
    GetFieldOffset("NT!_POP_THERMAL_ZONE", "PassiveTimer", &Off1);
    GetFieldOffset("NT!_POP_THERMAL_ZONE", "PassiveDpc", &Off2);
    dprintf("%s  Timer:         %08lx  Dpc:                 %08lx\n",
            Pad,
            Address + Off1,
            Address + Off2);
    GetFieldOffset("NT!_POP_THERMAL_ZONE", "OverThrottled", &Off1);
    dprintf("%s  OverThrottled: %08lx  Irp:                 %08p\n",
            Pad,
            Address + Off1,
            ReadField(Irp ));
    dprintf("%s  Throttle:      %08lx  LastTemp:            %08lx",
            Pad,
            (ULONG) ReadField(Throttle),
            (LastTemp = (ULONG) ReadField(LastTemp )));
    DumpTemperatureInKelvins( LastTemp );
    dprintf("\n");
    GetFieldOffset("NT!_POP_THERMAL_ZONE", "Info", &Off1);
    dprintf("%s  Thermal Info:  %08lx\n",
            Pad,
            Address + Off1);
    if (Flags & TZ_DUMP_INFO) {

        CHAR   buffer[80];

        //
        // Increase the buffer
        //
        sprintf(buffer,"  %s", Pad );

        //
        // Dump the thermal zone
        //
        DumpThermalZoneInformation(
            buffer,
            (Address + Off1),
            (Flags | TZ_NO_HEADER)
            );

    }
}


DECLARE_API( tz )
/*++

Routine Description:


Arguments:

    args -

Return Value:

    None

--*/

{
    ULONG64             Address = 0;
    ULONG               Count = 0;
    ULONG64             EndAddress = 0, Flink;
    ULONG               Flags = 0;
    ULONG               Result;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (Address == 0) {

        Address = GetExpression("nt!PopThermal");
        if (!Address) {

            dprintf("Could not read PopThermal\n");
            return E_INVALIDARG;

        }
        if (GetFieldValue(Address,
                          "nt!_LIST_ENTRY",
                          "Flink",
                          Flink) ) {

            dprintf("Could not read PopThermal at %08p\n", Address );
            return E_INVALIDARG;

        }
        if (Flink == Address) {

            dprintf("No Thermal Zones\n");
            return E_INVALIDARG;

        }

        Flags |= TZ_LOOP;
        EndAddress = Address;
        Address = Flink;

    } else {

        EndAddress = Address;

    }

    //
    // Now read the proper thermal zone
    //
    if (GetFieldValue(Address,
                      "nt!_LIST_ENTRY",
                      "Flink",
                      Flink) ) {

        dprintf("Could not read LIST_ENTRY at %08p\n", Address );
        return E_INVALIDARG;

    }

    //
    // Do we stop looping?
    //
    if (!(Flags & TZ_LOOP)) {

        EndAddress = Flink;

    }

    do {

        //
        // Read the thermal zone
        // Try both names for backward compatibility
        //
        if (GetFieldValue(Address, "NT!_POP_THERMAL_ZONE", "Link.Flink", Flink) &&
            GetFieldValue(Address, "NT!POP_THERMAL_ZONE", "Link.Flink", Flink)) {
            dprintf("Could not read THERMAL_ZONE at %08p\n", Address );
            return E_INVALIDARG;
        }

        //
        // Dump the zone
        //
        DumpThermalZone( Count, "", Address, Flags );

        //
        // Check for Control C
        //
        if (CheckControlC()) {
            return E_INVALIDARG;
        }

        //
        // Next
        //
        Address = Flink;
        Count++;

    } while (Address != EndAddress  );
    return S_OK;
}

VOID
DumpPopIdleHandler(
    IN  ULONG64                     Address,
    IN  ULONG                       Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    CHAR    FunctionName[256];
    ULONG64 Offset;

    if (InitTypeRead(Address,nt!_POP_IDLE_HANDLER)) {
        // If the new type name fails, use the old one
        InitTypeRead(Address,nt!POP_IDLE_HANDLER);
    }

    dprintf("PopIdleHandle[%d] - POP_IDLE_HANDLER %p\n",(ULONG)ReadField(State),Address);
    dprintf("  State:                      %8d   PromoteCount:               %8d\n",
            (ULONG)ReadField(State),
            (ULONG)ReadField(PromoteCount)
            );
    dprintf("  DemotePercent:              %8d%%  PromotePercent:            %8d%%\n",
            (ULONG)ReadField(DemotePercent),
            (ULONG)ReadField(PromotePercent)
            );
    dprintf("  Demote:                     %8d   Promote:                    %8d\n",
            (ULONG)ReadField(Demote),
            (ULONG)ReadField(Promote)
            );
    dprintf("\n");
    GetSymbol(ReadField(IdleFunction), FunctionName, &Offset);
    dprintf("  Function:           %27s  (%p)\n",
            FunctionName,
            ReadField(IdleFunction)
            );
    dprintf("  Latency:            %27s  (%8x)\n",
            DumpPerformanceCounterInStandardForm( (ULONG)ReadField(Latency) ),
            (ULONG)ReadField(Latency)
            );
    dprintf("  TimeCheck:          %27s  (%8x)\n",
            DumpPerformanceCounterInStandardForm( (ULONG)ReadField(TimeCheck) ),
            (ULONG)ReadField(TimeCheck)
            );
    dprintf("  PromoteLimit:       %27s  (%8x)\n",
            DumpPerformanceCounterInStandardForm( (ULONG)ReadField(PromoteLimit) ),
            (ULONG)ReadField(PromoteLimit)
            );
    dprintf("  DemoteLimit:        %27s  (%8x)\n",
            DumpPerformanceCounterInStandardForm( (ULONG)ReadField(DemoteLimit) ),
            (ULONG) ReadField(DemoteLimit)
            );
    dprintf("\n");

}

DECLARE_API( poidle )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG64             Address = 0;
    ULONG64             Pkprcb;
    ULONG64             PowerState;
    ULONG64             Size;
    ULONG               Loop = 3;
    ULONG               Flags = 0;
    ULONG               processor = 0;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }

    if (Address == 0) {

        HRESULT Hr;

        INIT_API();

        GetCurrentProcessor(Client, &processor, NULL);

        Hr = g_ExtData->ReadProcessorSystemData(processor,
                                                DEBUG_DATA_KPRCB_OFFSET,
                                                &Pkprcb,
                                                sizeof(Pkprcb),
                                                NULL);


        if (Hr != S_OK) {

            dprintf("Cannot get PRCB address\n");

        } else {

            InitTypeRead(Pkprcb,nt!_KPRCB);
            PowerState = ReadField(PowerState);
            if (!PowerState) {

                dprintf("Unable to get PowerState from the PRCB at %p",Pkprcb);
                dprintf("poproc <address>\n");
                Hr = E_INVALIDARG;

            }

        }
        if (Hr != S_OK){

            return Hr;

        }

        if (GetFieldValue( PowerState,
                           "PROCESSOR_POWER_STATE",
                           "IdleHandlers",
                           Address) ) {

            dprintf("Could not read PROCESSOR_POWER_STATE at %p\n", PowerState );
            return E_INVALIDARG;

        }

        Loop = 3;

    }

    //
    // We will need to know how large the structure is..
    //
    Size = GetTypeSize("nt!_POP_IDLE_HANDLER");
    if (!Size) {
        Size = GetTypeSize("nt!POP_IDLE_HANDLER");
    }

    do {

        DumpPopIdleHandler( Address, Flags );
        Address += Size;
        if (CheckControlC() || !Loop) {
            break;
        }
        Loop--;

    } while ( Loop );

    return S_OK;
}

VOID
DumpProcessorPerfState(
    IN  ULONG64                     Address,
    IN  ULONG                       Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG64 Value = 0;

    InitTypeRead(Address,nt!PROCESSOR_PERF_STATE);
    dprintf(
        "  Power:  %4dmW",
        (ULONG)ReadField(Power)
        );
    Value = ReadField(Flags);
    if (Value) {
        dprintf("  NonLinear\n");
    } else {
        dprintf("  Linear\n");
    }
    dprintf(
        "    Frequency:     %8d%% MinCapacity:   %8d%%\n",
        (ULONG)ReadField(PercentFrequency),
        (ULONG)ReadField(MinCapacity)
        );
    dprintf(
        "    IncreaseLevel: %8d%% DecreaseLevel: %8d%%\n",
        (ULONG)ReadField(IncreaseLevel),
        (ULONG)ReadField(DecreaseLevel)
        );
    dprintf(
        "    IncreaseCount: %8x  DecreaseCount: %8x\n",
        (ULONG)ReadField(IncreaseCount),
        (ULONG)ReadField(DecreaseCount)
        );
    dprintf(
        "    PerformanceTime: %21s (%8x)\n",
        DumpPerformanceCounterInStandardForm( ReadField(PerformanceTime) ),
        ReadField(PerformanceTime)
        );
    dprintf(
        "    IncreaseTime:    %21s (%8x)\n",
        DumpTimeInStandardForm( (ULONG) ReadField(IncreaseTime) ),
        ReadField(IncreaseTime)
        );
    dprintf(
        "    DecreaseTime:    %21s (%8x)\n",
        DumpTimeInStandardForm( (ULONG) ReadField(DecreaseTime) ),
        ReadField(DecreaseTime)
        );

}

DECLARE_API( poperf )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG64             Address = 0;
    ULONG64             Count = 1;
    ULONG64             Index;
    ULONG64             PolicyAddress;
    ULONG64             Size = 0;
    ULONG               Flags = 0;
    ULONG               Processor;
    ULONG               Prcb;

    //
    // Get address and flags
    //
    if (GetExpressionEx(args, &Address, &args)) {
        Flags = (ULONG) GetExpression(args);
    }
    if (Address == 0) {

        HRESULT Hr;

        INIT_API();

        //
        // Fetch them from the current processor's prcb
        //
        GetCurrentProcessor(Client, &Processor, NULL);

        Hr = g_ExtData->ReadProcessorSystemData(
            Processor,
            DEBUG_DATA_KPRCB_OFFSET,
            &Address,
            sizeof(Address),
            NULL
            );
        if (Hr != S_OK) {

            dprintf("Unable to get PRCB address\n");
            return Hr;

        }

        InitTypeRead(Address,nt!_KPRCB);
        PolicyAddress = ReadField(PowerState.PerfStates);
        Count         = ReadField(PowerState.PerfStatesCount);

        //
        // Remember what's the address we will use
        //
        Address = PolicyAddress;
        dprintf("Prcb.PowerState.PerfStates - %p (%d Levels)\n", Address, (ULONG) Count );

    } else {

        dprintf("PROCESSOR_PERF_STATE - %p\n",Address);

    }

    //
    // We will need to know how large the structure is..
    //
    Size = GetTypeSize("nt!PROCESSOR_PERF_STATE");

    //
    // Dump all the states
    //
    for (Index = 0; Index < Count; Index++, Address += Size) {

        DumpProcessorPerfState( Address, Flags );
        if (CheckControlC()) {
            break;
        }

    }

    //
    // Done
    //
    return S_OK;
}

DECLARE_API( whattime )
{
    ULONG64 Address = 0;

    //
    // Get address and flags
    //
    GetExpressionEx(args, &Address, &args);

    dprintf(
        "%d Ticks in Standard Time: %s\n",
        (ULONG) Address,
        DumpTimeInStandardForm( (ULONG) Address )
        );
    return S_OK;
}

DECLARE_API( whatperftime )
{
    ULONG64 Address = 0;

    //
    // Get address and flags
    //
    GetExpressionEx(args, &Address, &args);

    dprintf(
        "%ld Performance Counter in Standard Time: %s\n",
        (ULONG) Address,
        DumpPerformanceCounterInStandardForm( Address )
        );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\token.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    token.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 8-Nov-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


DECLARE_API( logonsession )

/*++

Routine Description

    This extension will dump all logon sessions in the system, or the specified session.

Arguments

    !logonsession LUID InfoLevel
    where luid is the session to dump (or 0 for all sessions) and levels are 1-4.

Return Value

    S_OK or E_INVALIDARG
--*/

{
    //
    // Arguments
    //

    ULONG64 LogonId = 0;
    ULONG   Level   = 0;
    BOOLEAN bAll    = FALSE;

    //
    // ntoskrnl globals
    //

    ULONG64 NtBuildNumber        = 0;
    ULONG64 SepLogonSessions     = 0;
    ULONG64 SepTokenLeakTracking = 0;

    //
    // for manipulating the LogonSessions tables
    //

    ULONG64 SessionList      = 0;
    ULONG64 CurrentSession   = 0;
    ULONG64 NextSession      = 0;

    //
    // for manipulating a particular session
    //

    ULONG64 TokenListHead    = 0;
    ULONG64 NextTokenLink    = 0;
    ULONG64 CurrentTokenLink = 0;
    ULONG64 Token            = 0;
    ULONG   References       = 0;
    ULONG   TokenCount       = 0;
    ULONG   SessionCount     = 0;
    LUID    SessionLuid      = {0};

    NTSTATUS Status          = STATUS_SUCCESS;
    BOOLEAN  Found           = FALSE;
    BOOLEAN  bChecked        = FALSE;
    LONG     PointerSize     = 0;

#define DUMP_TOKENS             0x1
#define DUMP_SOME_TOKEN_INFO    0x2
#define DUMP_LOTS_OF_TOKEN_INFO 0x3
#define DUMP_TONS_OF_TOKEN_INFO 0x4
#define VALID_SESSION_ADDRESS(x) (SepLogonSessions <= (x) && (x) <= (SepLogonSessions + 0xf * sizeof(ULONG_PTR)))

    if (strlen(args) < 1)
    {
        dprintf("usage: !logonsession LogonId [InfoLevel 1-4]\n");
        dprintf("\tuse LogonId = 0 to list all sessions\n");
        dprintf("\n\texample: \"!logonsession 3e7 1\" displays system session and all system tokens.\n");
        return E_INVALIDARG;
    }

    if (!GetExpressionEx(
            args,
            &LogonId,
            &args))
    {
       return E_INVALIDARG;
    }

    if (args && *args)
    {
        Level = (ULONG) GetExpression(args);
    }

    if (LogonId == 0)
    {
        bAll = TRUE;
        dprintf("\nDumping all logon sessions.\n\n");
    }
    else
    {
        dprintf("\nSearching for logon session with ID = 0x%x\n\n", LogonId);
    }

    //
    // read in relevant variables
    //

    SepLogonSessions = GetPointerValue("nt!SepLogonSessions");
    NtBuildNumber    = GetPointerValue("nt!NtBuildNumber");

    //
    // This is bad but I don't know the right way to figure this out.
    //

    if ((SepLogonSessions & 0xffffffff00000000) == 0xffffffff00000000)
    {
        PointerSize = 4;
    }
    else
    {
        PointerSize = 8;
    }

    //
    // See if this is a checked build.
    //

    if (((ULONG)NtBuildNumber & 0xF0000000) == 0xC0000000)
    {
        bChecked = TRUE;

        //
        // It is a checked build, so see the value of SepTokenLeakTracking (valid symbol only on chk)
        //

        SepTokenLeakTracking = GetPointerValue("nt!SepTokenLeakTracking");

        if (SepTokenLeakTracking)
        {
            dprintf("TokenLeakTracking is ON.  Use !tokenleak to view settings.\n\n");
        }
    }

    SessionList = SepLogonSessions;

    if (!bAll)
    {
        //
        // we want a particular index into the table
        //

        SessionList += PointerSize * (LogonId & 0xf);
    }

    //
    // SessionList currently points at the beginning of a list indexed in SepLogonSessions.
    // Dump it out, printing either all of the entries or only one with a matching LUID.
    //

    do
    {
        if (CheckControlC())
        {
            return S_OK;
        }

        CurrentSession = GetPointerFromAddress(SessionList);

        while (0 != CurrentSession)
        {
            if (CheckControlC())
            {
                return S_OK;
            }

            //
            // Get the LUID for the CurrentSession
            //

            GetFieldValue(CurrentSession, "SEP_LOGON_SESSION_REFERENCES", "LogonId", SessionLuid);

            //
            // if caller wants all sessions, or this one, print it.
            //

            if (bAll || SessionLuid.LowPart == LogonId)
            {
                Found = TRUE;
                GetFieldValue(CurrentSession, "SEP_LOGON_SESSION_REFERENCES", "ReferenceCount", References);

                if (bAll)
                {
                    dprintf("** Session %3d = 0x%x\n", SessionCount, CurrentSession);
                }
                else
                {
                    dprintf("** Session     = 0x%x\n", CurrentSession);
                }

                dprintf("   LogonId     = {0x%x 0x%x}\n", SessionLuid.LowPart, SessionLuid.HighPart);
                dprintf("   References  = %d\n", References);

                SessionCount++;

                //
                // If Level dictates then print out lots more stuff.
                //

                if (Level != 0)
                {
                    if (bChecked == FALSE)
                    {
                        dprintf("\nNo InfoLevels are valid on free builds.\n");
                    }
                    else
                    {
                        TokenCount = 0;

                        //
                        // retrieve the token list from the session
                        //

                        if (0 == GetFieldValue(
                                     CurrentSession,
                                     "SEP_LOGON_SESSION_REFERENCES",
                                     "TokenList",
                                     TokenListHead
                                     ))
                        {

                            CurrentTokenLink = TokenListHead;

                            do
                            {
                                if (CheckControlC())
                                {
                                    return S_OK;
                                }

                                GetFieldValue(
                                    CurrentTokenLink,
                                    "SEP_LOGON_SESSION_TOKEN",
                                    "Token",
                                    Token
                                    );

                                GetFieldValue(
                                    CurrentTokenLink,
                                    "SEP_LOGON_SESSION_TOKEN",
                                    "ListEntry",
                                    NextTokenLink
                                    );

                                if (NextTokenLink != TokenListHead)
                                {
                                    if (TokenCount == 0)
                                    {

                                        ULONG               DefaultOwnerIndex  = 0;
                                        ULONG64             UserAndGroups      = 0;
                                        UNICODE_STRING      SidString          = {0};
                                        ULONG64             SidAttr            = 0;
                                        ULONG64             pSid               = 0;
                                        ULONG               ActualRead         = 0;
                                        UCHAR               Buffer[256];

                                        GetFieldValue(Token, "nt!_TOKEN", "DefaultOwnerIndex", DefaultOwnerIndex);
                                        GetFieldValue(Token, "nt!_TOKEN", "UserAndGroups", UserAndGroups);

                                        SidAttr = UserAndGroups + (DefaultOwnerIndex * sizeof(SID_AND_ATTRIBUTES));

                                        GetFieldValue(SidAttr, "_SID_AND_ATTRIBUTES", "Sid", pSid);

                                        dprintf("   Usersid     = 0x%x ", pSid);

                                        ReadMemory(pSid, Buffer, sizeof(Buffer), &ActualRead);

                                        Status = RtlConvertSidToUnicodeString(&SidString, (PSID)Buffer, TRUE);

                                        if (NT_SUCCESS(Status))
                                        {
                                            dprintf("(%S)\n", SidString.Buffer);
                                            RtlFreeUnicodeString(&SidString);
                                        }
                                        else
                                        {
                                            dprintf("!! RtlConvertSidToUnicodeString failed 0x%x\n", Status);
                                        }

                                        dprintf("   Tokens:\n");
                                    }

                                    TokenCount++;
                                    CurrentTokenLink = NextTokenLink;
                                    dprintf("    0x%x ", Token);

                                    if (Level > DUMP_TOKENS)
                                    {
                                        UCHAR   ImageFileName[16];
                                        ULONG   BodyOffset   = 0;
                                        ULONG64 ProcessCid   = 0;
                                        ULONG64 ObjectHeader = 0;
                                        ULONG64 HandleCount  = 0;
                                        ULONG64 PointerCount = 0;

                                        GetFieldValue(Token, "nt!_TOKEN", "ImageFileName", ImageFileName);
                                        GetFieldValue(Token, "nt!_TOKEN", "ProcessCid", ProcessCid);

                                        dprintf(": %13s (%3x) ", ImageFileName, ProcessCid);

                                        GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset);
                                        ObjectHeader = Token - BodyOffset;
                                        GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "PointerCount", PointerCount);
                                        GetFieldValue(ObjectHeader, "nt!_OBJECT_HEADER", "HandleCount", HandleCount);

                                        dprintf(": HandleCount = 0x%I64x PointerCount = 0x%I64x ", HandleCount, PointerCount);
                                    }

                                    if (Level > DUMP_SOME_TOKEN_INFO)
                                    {

                                        ULONG CreateMethod = 0;

                                        GetFieldValue(Token, "nt!_TOKEN", "CreateMethod", CreateMethod);

                                        switch (CreateMethod)
                                        {
                                        case 0xD:
                                            dprintf(": SepDuplicateToken ");
                                            break;
                                        case 0xC:
                                            dprintf(": SepCreateToken    ");
                                            break;
                                        case 0xF:
                                            dprintf(": SepFilterToken    ");
                                            break;
                                        default:
                                            dprintf(": Unknown Method    ");
                                            break;
                                        }

                                        if (Level > DUMP_LOTS_OF_TOKEN_INFO)
                                        {
                                            ULONG TokenType          = 0;
                                            ULONG ImpersonationLevel = 0;
                                            ULONG SessionId          = 0;
                                            ULONG Count              = 0;

                                            GetFieldValue(Token, "nt!_TOKEN", "TokenType", TokenType);
                                            GetFieldValue(Token, "nt!_TOKEN", "ImpersonationLevel", ImpersonationLevel);
                                            GetFieldValue(Token, "nt!_TOKEN", "SessionId", SessionId);
                                            GetFieldValue(Token, "nt!_TOKEN", "Count", Count);

                                            dprintf(": Type %d ", TokenType);
                                            dprintf(": Level %d ", ImpersonationLevel);
                                            dprintf(": SessionId %d ", SessionId);
                                            if (SepTokenLeakTracking)
                                            {
                                                dprintf(": MethodCount = %3x ", Count);
                                            }

                                        }

                                    }
                                }

                                dprintf("\n");

                            } while (NextTokenLink != TokenListHead);

                            dprintf("    %d Tokens listed.\n\n", TokenCount);
                        }
                    }
                }
            }

            GetFieldValue(CurrentSession, "SEP_LOGON_SESSION_REFERENCES", "Next", NextSession);
            CurrentSession = NextSession;
        }

        if (bAll)
        {
            SessionList += sizeof(ULONG_PTR);
        }

    }
    while (bAll && VALID_SESSION_ADDRESS(SessionList));

    if (bAll)
    {
        dprintf("%d sessions in the system.\n", SessionCount);
    }

    if (!bAll && !Found)
    {
        dprintf("Session not found.\n");
    }

    return S_OK;
}

DECLARE_API( tokenleak )

/*++

Routine Description

    !tokenleak displays or sets the Se globals that facilitate tracking and finding token leaks.

Arguments

    usage: !tokenleak [1 | 0 ProcessCid BreakCount MethodWatch]
    where 1 activates and 0 disables token leak tracking
    where ProcessCid is Cid of process to monitor (in hex)
    where BreakCount specifies which numbered call to Method to break on (in hex)
    where MethodWatch specifies which token method to watch (C D or F)

--*/

{
    //
    // Nt Globals.
    //

    ULONG64 SepTokenLeakTracking    = 0;
    ULONG64 SepTokenLeakMethodWatch = 0;
    ULONG64 SepTokenLeakMethodCount = 0;
    ULONG64 SepTokenLeakBreakCount  = 0;
    ULONG64 SepTokenLeakProcessCid  = 0;

    ULONG64 SepTokenLeakTrackingAddr    = 0;
    ULONG64 SepTokenLeakMethodWatchAddr = 0;
    ULONG64 SepTokenLeakMethodCountAddr = 0;
    ULONG64 SepTokenLeakBreakCountAddr  = 0;
    ULONG64 SepTokenLeakProcessCidAddr  = 0;

    ULONG64 NtBuildNumber        = 0;
    BOOLEAN bModify              = TRUE;

    ULONG64 InputOn              = 0;
    ULONG64 InputCid             = 0;
    ULONG64 InputMethodWatch     = 0;
    ULONG64 InputBreakCount      = 0;

    if (strlen(args) < 1)
    {
        dprintf("usage: !tokenleak [1 | 0 ProcessCid BreakCount MethodWatch]\n");
        dprintf("\t where 1 activates and 0 disables token leak tracking\n");
        dprintf("\t where ProcessCid is Cid of process to monitor (in hex)\n");
        dprintf("\t where BreakCount specifies which numbered call to Method to break on (in hex)\n");
        dprintf("\t where MethodWatch specifies which token method to watch (C D or F)\n\n");
        bModify = FALSE;
    }

    NtBuildNumber = GetPointerValue("nt!NtBuildNumber");

    if (((ULONG)NtBuildNumber & 0xf0000000) == 0xF0000000)
    {
        dprintf("This extension only works on checked builds.\n");
        return S_OK;
    }

    if (bModify)
    {
        SepTokenLeakTrackingAddr    = GetExpression("SepTokenLeakTracking");
        SepTokenLeakMethodWatchAddr = GetExpression("SepTokenLeakMethodWatch");
        SepTokenLeakMethodCountAddr = GetExpression("SepTokenLeakMethodCount");
        SepTokenLeakBreakCountAddr  = GetExpression("SepTokenLeakBreakCount");
        SepTokenLeakProcessCidAddr  = GetExpression("SepTokenLeakProcessCid");

        if (!GetExpressionEx(
                args,
                &InputOn,
                &args))
        {
           return E_INVALIDARG;
        }

        WritePointer(SepTokenLeakTrackingAddr, InputOn);

        if (InputOn != 0)
        {
            dprintf("\nToken leak tracking is ON.\n\n");

            while (args && (*args == ' '))
            {
                args++;
            }

            if (!GetExpressionEx(
                    args,
                    &InputCid,
                    &args))
            {
               return E_INVALIDARG;
            }

            while (args && (*args == ' '))
            {
                args++;
            }

            if (!GetExpressionEx(
                    args,
                    &InputBreakCount,
                    &args))
            {
               return E_INVALIDARG;
            }

            while (args && (*args == ' '))
            {
                args++;
            }

            if (!GetExpressionEx(
                    args,
                    &InputMethodWatch,
                    &args))
            {
               return E_INVALIDARG;
            }

            WritePointer(SepTokenLeakProcessCidAddr, InputCid);
            WritePointer(SepTokenLeakBreakCountAddr, InputBreakCount);
            WritePointer(SepTokenLeakMethodCountAddr, 0);
            WritePointer(SepTokenLeakMethodWatchAddr, InputMethodWatch);
        }
    }

    //
    // Print out the current settings.
    //

    SepTokenLeakTracking    = GetPointerValue("SepTokenLeakTracking");
    SepTokenLeakMethodWatch = GetPointerValue("SepTokenLeakMethodWatch");
    SepTokenLeakMethodCount = GetPointerValue("SepTokenLeakMethodCount");
    SepTokenLeakBreakCount  = GetPointerValue("SepTokenLeakBreakCount");
    SepTokenLeakProcessCid  = GetPointerValue("SepTokenLeakProcessCid");

    if (SepTokenLeakTracking)
    {

        dprintf("  Currently watched method  = ");
        switch (SepTokenLeakMethodWatch)
        {
        case 0xD:
            dprintf("SepDuplicateToken\n");
            break;
        case 0xC:
            dprintf("SepCreateToken\n");
            break;
        case 0xF:
            dprintf("SepFilterToken\n");
            break;
        default:
            dprintf("???\n");
        }
        dprintf("  Currently watched process = 0x%x\n", SepTokenLeakProcessCid);
        dprintf("  Method call count         = 0x%x\n", SepTokenLeakMethodCount);
        dprintf("  Will break at count       = 0x%x\n", SepTokenLeakBreakCount);
    }
    else
    {
        dprintf("\nToken leak tracking is OFF\n");
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\util.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

ULONG
GetBitFieldOffset (
   IN LPSTR     Type,
   IN LPSTR     Field,
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   )
{
   FIELD_INFO flds = {
       Field, "", 0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_SIZE_IN_BITS,
       0, NULL};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), Type, DBG_DUMP_NO_PRINT, 0,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG Err, i=0;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   *pSize   = flds.size;
   return Err;
}

ULONG
GetFieldOffsetEx (
   IN LPSTR     Type,
   IN LPSTR     Field,
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   )
{
   FIELD_INFO flds = {
       Field, "", 0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0, NULL};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), Type, DBG_DUMP_NO_PRINT, 0,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG Err, i=0;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   *pSize   = flds.size;
   return Err;
} // GetFieldOffsetEx()

ULONG
GetUlongFromAddress (
    ULONG64 Location
    )
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory(Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG))) {
        dprintf("GetUlongFromAddress: unable to read from %p\n", Location);
        return 0;
    }

    return Value;
}

BYTE
GetByteFromAddress (
    ULONG64 Location
    )
{
    BYTE Value;
    ULONG result;

    if ((!ReadMemory(Location,&Value,sizeof(Value),&result)) ||
        (result < sizeof(Value))) {
        dprintf("GetByteFromAddress: unable to read from %p\n", Location);
        return 0;
    }

    return Value;
}

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    )
{
    ULONG64 Value;
    ULONG result;

    if (!ReadPointer( Location, &Value )) {
        dprintf( "GetPointerFromAddress: unable to read from %p\n", Location );
        return 0;
    }
    return Value;
}

ULONG
GetUlongValue (
    PCHAR String
    )
{
    ULONG64 Location;
    ULONG Value;
    ULONG result;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return GetUlongFromAddress( Location );
}

BYTE
GetByteValue (
    PCHAR String
    )
{
    ULONG64 Location;
    ULONG Value;
    ULONG result;

    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return GetByteFromAddress( Location );
}

ULONG64
GetPointerValue (
    PCHAR String
    )
{
    ULONG64 Location, Val=0;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    ReadPointer(Location, &Val);

    return Val;
}

ULONG64
GetGlobalFromAddress (
    ULONG64 Location,
    ULONG   Size
    )
{
    ULONG64 value;
    ULONG   result;

    value = 0;
    if (Size > sizeof(value))
    {
        Size = sizeof(value);
    }
    if ((!ReadMemory(Location,&value,Size,&result)) || (result < Size)) {
        dprintf("GetGlobalFromAddress: unable to read from %p\n", Location);
        return 0;
    }
    return value;
} // GetGlobalFromAddress()

ULONG64
GetGlobalValue (
    PCHAR  String
    )
{
    ULONG64 location;
    ULONG   size;

    location = GetExpression( String );
    if (!location) {
        dprintf("GetGlobalValue: unable to get %s\n",String);
        return 0;
    }
    size = GetTypeSize( String );
    if (!size)  {
        dprintf("GetGlobalValue: unable to get %s type size\n",String);
        return 0;
    }
    return GetGlobalFromAddress( location, size );
} // GetGlobalValue()

HRESULT
GetGlobalEx(
    PCHAR String,
    PVOID OutValue, 
    ULONG OutSize
    )
{
    ULONG64 location;
    ULONG   size;
    ULONG   result;

    ZeroMemory( OutValue, OutSize );
    location = GetExpression( String );
    if (!location) {
        return E_INVALIDARG;
    }
    size = GetTypeSize( String );
    if (!size)  {
        return E_INVALIDARG;
    }
    if ( size > OutSize )   {
        return E_OUTOFMEMORY;
    }
    if ((!ReadMemory(location,OutValue,size,&result)) || (result < size)) {
        return E_FAIL;
    }
    return S_OK;
} // GetGlobalEx()

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    )
{
    ULONG64 RightChild;
    if (Parent == pLinks) {

        return FALSE;
    }

    if (GetFieldValue(Parent, "RTL_SPLAY_LINKS", "RightChild", RightChild)) {

        return FALSE;
    }

    if (RightChild == pLinks) {

        return TRUE;
    }

    return FALSE;
}

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    )
{
    ULONG64 LeftChild;
    if (Parent == pLinks) {

        return FALSE;
    }

    if (GetFieldValue(Parent, "RTL_SPLAY_LINKS", "LeftChild", LeftChild)) {

        return FALSE;
    }

    if (LeftChild == pLinks) {

        return TRUE;
    }

    return FALSE;
}


ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    )
/*++
    Purpose:

        Perform an in-order iteration across a splay tree, calling a
        user supplied function with a pointer to each RTL_SPLAY_LINKS
        structure encountered in the tree, and the level in the tree
        at which it was encountered (zero based).

    Arguments:

        pSplayLinks     - pointer to root of a splay tree

        DumpNodeFn      - user supplied dumping function

   Returns:

        Count of nodes encountered in the tree.

   Notes:

        Errors reading memory do not terminate the iteration if more
        work is possible.

        Consumes the Control-C flag to terminate possible loops in
        corrupt structures.

--*/
{
    ULONG Level = 0;
    ULONG NodeCount = 0;

    if (pSplayLinks) {
        ULONG64 LeftChild, RightChild, Parent, Current;

        //
        //  Retrieve the root links, find the leftmost node in the tree
        //

        if (GetFieldValue(Current = pSplayLinks,
                          "RTL_SPLAY_LINKS",
                          "LeftChild",
                          LeftChild)) {

            return NodeCount;
        }

        while (LeftChild != 0) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            if (GetFieldValue(Current = LeftChild,
                              "RTL_SPLAY_LINKS",
                              "LeftChild",
                              LeftChild)) {

                //
                //  We can try to continue from this
                //

                break;
            }

            Level++;
        }

        while (TRUE) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            NodeCount++;
            pSplayLinks = Current;
            (*DumpNodeFn)(pSplayLinks, Level);

            /*
                first check to see if there is a right subtree to the input link
                if there is then the real successor is the left most node in
                the right subtree.  That is find and return P in the following diagram

                      Links
                         \
                          .
                         .
                        .
                       /
                      P
                       \
            */

            GetFieldValue(Current, "RTL_SPLAY_LINKS", "RightChild", RightChild);
            if (RightChild != 0) {

                if (GetFieldValue(Current = RightChild,
                                  "RTL_SPLAY_LINKS",
                                  "RightChild",
                                  RightChild)) {

                    //
                    //  We've failed to step through to a successor, so
                    //  there is no more to do
                    //

                    return NodeCount;
                }

                Level++;

                GetFieldValue(Current,"RTL_SPLAY_LINKS","LeftChild",LeftChild);
                while (LeftChild != 0) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    if (GetFieldValue(Current = LeftChild,
                                     "RTL_SPLAY_LINKS",
                                     "LeftChild",
                                     LeftChild)) {

                        //
                        //  We can continue from this
                        //

                        break;
                    }

                    Level++;
                }

            } else {

                /*
                    we do not have a right child so check to see if have a parent and if
                    so find the first ancestor that we are a left decendent of. That
                    is find and return P in the following diagram

                               P
                              /
                             .
                              .
                               .
                              Links
                */

                //
                //  If the IsLeft or IsRight functions fail to read through a parent
                //  pointer, then we will quickly exit through the break below
                //

                GetFieldValue(Current, "RTL_SPLAY_LINKS", "Parent", Parent);
                while (DbgRtlIsRightChild(Current, Parent)) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    Level--;
                    pSplayLinks = (Current = Parent);
                }

                GetFieldValue(Current, "RTL_SPLAY_LINKS", "Parent", Parent);
                if (!DbgRtlIsLeftChild(Current, Parent)) {

                    //
                    //  we do not have a real successor so we break out
                    //

                    break;

                } else {

                    Level--;
                    pSplayLinks = (Current = Parent);
                }
            }
        }
    }

    return NodeCount;
}

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    )
{
    UNICODE_STRING v;
    DWORD BytesRead;

    if (u.MaximumLength > 0x1000)
    {
        u.MaximumLength = 0x1000;
    }
//    dprintf("L %x, M %x, B %p ", u.Length, u.MaximumLength, u.Buffer);
    if ((u.Length <= u.MaximumLength) &&
        (u.Buffer) &&
        (u.Length > 0)) {

        v.Buffer = LocalAlloc(LPTR, u.MaximumLength+sizeof(WCHAR));
        if (v.Buffer != NULL) {
            v.MaximumLength = u.MaximumLength;
            v.Length = u.Length;
            if (ReadMemory(u.Buffer,
                           v.Buffer,
                           u.Length,
                           (PULONG) &u.Buffer)) {
                v.Buffer[v.MaximumLength/sizeof(WCHAR)] = 0;
                dprintf("%wZ", &v);
            } else {
                dprintf("<???>");
            }
            LocalFree(v.Buffer);

            return;
        }
    }
}

BOOLEAN
IsHexNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   for(;*szExpression; szExpression++) {

      if      ((*szExpression)< '0') { return FALSE ; }
      else if ((*szExpression)> 'f') { return FALSE ; }
      else if ((*szExpression)>='a') { continue ;     }
      else if ((*szExpression)> 'F') { return FALSE ; }
      else if ((*szExpression)<='9') { continue ;     }
      else if ((*szExpression)>='A') { continue ;     }
      else                           { return FALSE ; }
   }
   return TRUE ;
}


BOOLEAN
IsDecNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   while(*szExpression) {

      if      ((*szExpression)<'0') { return FALSE ; }
      else if ((*szExpression)>'9') { return FALSE ; }
      szExpression ++ ;
   }
   return TRUE ;
}

ULONG64
UtilStringToUlong64 (
    UCHAR *String
    )
{
    UCHAR LowDword[9], HighDword[9];

    ZeroMemory (HighDword, sizeof (HighDword));
    ZeroMemory (LowDword, sizeof (LowDword));

    if (strlen (String) > 8) {

        memcpy (LowDword, (void *) &String[strlen (String) - 8], 8);
        memcpy (HighDword, (void *) &String[0], strlen (String) - 8);

    } else {

        return strtoul (String, 0, 16);
    }

    return ((ULONG64) strtoul (HighDword, 0, 16) << 32) + strtoul (LowDword, 0, 16);
}

const char *
getEnumName(
        ULONG       EnumVal,
        PENUM_NAME EnumTable
        )
/*++

Routine Description:

    Gets the supplied enum value's name in string format

Arguments:

    EnumVal   -  Enum to be retrieved
    EnumTable -  Table in which the enum is looked up to find
                 the string to be retrieved (since we can't rely on the debugger)

Return Value:

None

--*/
{
   ULONG i;

   for (i=0; EnumTable[i].Name != NULL; i++) {
      if (EnumTable[i].EnumVal == EnumVal) {
         break;
      }
   }
   if (EnumTable[i].Name != NULL) {
      return EnumTable[i].Name;
   } else {
      return "Unknown ";
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\vad.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vad.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (loup) 12-Jun-1992

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

CHAR *ProtectString[] = {
                   "NO_ACCESS",
                   "READONLY",
                   "EXECUTE",
                   "EXECUTE_READ",
                   "READWRITE",
                   "WRITECOPY",
                   "EXECUTE_READWRITE",
                   "EXECUTE_WRITECOPY"
                   };


DECLARE_API( vad )

/*++

Routine Description:

    Dumps all vads for process.

Arguments:

    args - Address Flags

Return Value:

    None

--*/

{
    ULONG64 Next;
    ULONG64 VadToDump;
    ULONG64 ParentStored;
    ULONG64 First;
    ULONG64 Left;
    ULONG64 Prev;
    ULONG   Flags;
    ULONG   Done;
    ULONG   Level = 0;
    ULONG   Count = 0;
    ULONG   AverageLevel = 0;
    ULONG   MaxLevel = 0;
    ULONG   VadFlagsPrivateMemory=0, VadFlagsNoChange=0;
    ULONG   PhysicalMapping=0,ImageMap=0,NoChange=0,LargePages=0,MemCommit=0,PrivateMemory=0,Protection=0;
    ULONG64 StartingVpn=0, EndingVpn=0, Parent=0, LeftChild=0, RightChild=0;
    ULONG64 ControlArea=0, FirstPrototypePte=0, LastContiguousPte=0, CommitCharge=0;

    VadToDump = 0;
    Flags     = 0;

    if (GetExpressionEx(args, &VadToDump, &args)) {
        Flags = (ULONG) GetExpression(args);
    }

    if (VadToDump == 0) {
        dprintf("Specify the address of a VAD within the VAD tree\n");
        return E_INVALIDARG;
    }

    First = VadToDump;
    if (First == 0) {
        return E_INVALIDARG;
    }

#define ReadFirstVad(fld, var) GetFieldValue(First, (PUCHAR) "nt!_MMVAD", #fld, var)
#define ReadFirstVadShort(fld, var) GetFieldValue(First, (PUCHAR) "nt!_MMVAD_SHORT", #fld, var)

    if ( ReadFirstVadShort(u.VadFlags.PrivateMemory, VadFlagsPrivateMemory) ) {
        dprintf("%08p: Unable to get contents of VAD1\n",First );
        return E_INVALIDARG;
    }

    ReadFirstVadShort(u.VadFlags.NoChange, VadFlagsNoChange);
    ReadFirstVadShort(StartingVpn, StartingVpn);
    ReadFirstVadShort(EndingVpn, EndingVpn);

    if (ReadFirstVadShort(Parent, Parent)) {
        ReadFirstVadShort(u1.Parent, Parent);
    }

    ReadFirstVadShort(LeftChild, LeftChild);
    ReadFirstVadShort(RightChild, RightChild);
    ReadFirstVadShort(u.VadFlags.CommitCharge, CommitCharge);

    if (Flags == 1) {
        ULONG FileOffset=0;
        ULONG64 ListFlink=0, ListBlink=0, Banked=0;
        ULONG CopyOnWrite=0,Inherit=0,ExtendableFile=0,SecNoChange=0;
        ULONG OneSecured=0,MultipleSecured=0,ReadOnly=0,StoredInVad=0;

        //
        // Dump only this vad.
        //

        if ((VadFlagsPrivateMemory == 0) ||
            (VadFlagsNoChange == 1))  {
            if ( ReadFirstVad(ControlArea, ControlArea) ) {
                dprintf("%08p: Unable to get contents of VAD2\n",First );
                return E_INVALIDARG;
            }
            ReadFirstVad(FirstPrototypePte, FirstPrototypePte);
            ReadFirstVad(LastContiguousPte, LastContiguousPte);     
            ReadFirstVad(u2.VadFlags2.CopyOnWrite, CopyOnWrite);
            ReadFirstVad(u2.VadFlags2.Inherit, Inherit);
            ReadFirstVad(u2.VadFlags2.ExtendableFile, ExtendableFile);
            ReadFirstVad(u2.VadFlags2.SecNoChange, SecNoChange);
            ReadFirstVad(u2.VadFlags2.OneSecured, OneSecured);
            ReadFirstVad(u2.VadFlags2.MultipleSecured, MultipleSecured);
            ReadFirstVad(u2.VadFlags2.ReadOnly, ReadOnly);
            ReadFirstVad(u2.VadFlags2.StoredInVad, StoredInVad);
            ReadFirstVad(u2.VadFlags2.FileOffset, FileOffset);
            ReadFirstVad(u3.List.Flink, ListFlink);
            ReadFirstVad(u3.List.Blink, ListBlink);
            ReadFirstVad(u4.Banked, Banked);
        }
        
        ReadFirstVad(u.VadFlags.CommitCharge, CommitCharge);
        ReadFirstVad(u.VadFlags.PhysicalMapping, PhysicalMapping);
        ReadFirstVad(u.VadFlags.ImageMap, ImageMap);
        ReadFirstVad(u.VadFlags.Protection, Protection);
        ReadFirstVad(u.VadFlags.NoChange, NoChange);
        ReadFirstVad(u.VadFlags.LargePages, LargePages);
        ReadFirstVad(u.VadFlags.MemCommit, MemCommit);
        ReadFirstVad(u.VadFlags.PrivateMemory, PrivateMemory);

        dprintf("\nVAD @ %8p\n",VadToDump);
        dprintf("  Start VPN:      %8p  End VPN: %8p  Control Area:  %8p\n",
            StartingVpn,
            EndingVpn,
            ControlArea);
        dprintf("  First ProtoPte: %8p  Last PTE %8p  Commit Charge  %8lx (%ld.)\n",
            FirstPrototypePte,
            LastContiguousPte,
            (ULONG)CommitCharge,
            (ULONG)CommitCharge
            );
        dprintf("  Secured.Flink   %8p  Blink    %8p  Banked/Extend: %8p Offset %lx\n",
            ListFlink,
            ListBlink,
            Banked,
            FileOffset);

        dprintf("   ");

        if (PhysicalMapping) { dprintf("PhysicalMapping "); }
        if (ImageMap) { dprintf("ImageMap "); }
        Inherit ? dprintf("ViewShare ") : dprintf("ViewUnmap ");
        if (NoChange) { dprintf("NoChange "); }
        if (CopyOnWrite) { dprintf("CopyOnWrite "); }
        if (LargePages) { dprintf("LargePages "); }
        if (MemCommit) { dprintf("MemCommit "); }
        if (PrivateMemory) { dprintf("PrivateMemory "); }
        dprintf ("%s\n\n",ProtectString[Protection & 7]);

        if (ExtendableFile) { dprintf("ExtendableFile "); }
        if (SecNoChange) { dprintf("SecNoChange "); }
        if (OneSecured) { dprintf("OneSecured "); }
        if (MultipleSecured) { dprintf("MultipleSecured "); }
        if (ReadOnly) { dprintf("ReadOnly "); }
        if (StoredInVad) { dprintf("StoredInVad "); }
        dprintf ("\n\n");

        return E_INVALIDARG;
    }

    Prev = First;

    while (LeftChild != 0) {
        if ( CheckControlC() ) {
            return E_INVALIDARG;
        }
        Prev = First;
        First = LeftChild;
        Level += 1;
        if (Level > MaxLevel) {
            MaxLevel = Level;
        }

        if (Flags & 2) {
            dprintf("Reading LeftChild VAD %08p\n",First );
        }

        if ( ReadFirstVadShort(LeftChild, LeftChild) ) {
            dprintf("%08p %08p: Unable to get contents of VAD3\n", First, Prev);
            return E_INVALIDARG;
        }
    }

    ReadFirstVadShort(StartingVpn, StartingVpn);
    ReadFirstVadShort(EndingVpn, EndingVpn);

    if (ReadFirstVadShort(Parent, Parent)) {
        ReadFirstVadShort(u1.Parent, Parent);
        Parent &= ~0x3;
    }

    ReadFirstVadShort(RightChild, RightChild);
    ReadFirstVadShort(u.VadFlags.CommitCharge, CommitCharge);
    ReadFirstVadShort(u.VadFlags.PrivateMemory, PrivateMemory);
    ReadFirstVadShort(u.VadFlags.PhysicalMapping, PhysicalMapping);
    ReadFirstVadShort(u.VadFlags.ImageMap, ImageMap);
    ReadFirstVadShort(u.VadFlags.Protection, Protection);


    dprintf("VAD     level      start      end    commit\n");
    dprintf("%p (%2ld)   %8p %8p      %4ld %s %s %s\n",
            First,
            Level,
            StartingVpn,
            EndingVpn,
            (ULONG)CommitCharge,
            PrivateMemory ? "Private" : "Mapped ",
            ImageMap ? "Exe " :
                PhysicalMapping ? "Phys" : "    ",
            ProtectString[Protection & 7]
            );
    Count += 1;
    AverageLevel += Level;

    Next = First;
    while (Next != 0) {

        if ( CheckControlC() ) {
            return E_INVALIDARG;
        }

        if (RightChild == 0) {

            Done = TRUE;

            //
            // Pre-AVL vad trees were delimited by a parent pointer of NULL.
            //

            while ((ParentStored = Parent) != 0) {

                if ( CheckControlC() ) {
                    return E_INVALIDARG;
                }

                Level -= 1;

                //
                // Locate the first ancestor of this node of which this
                // node is the left child of and return that node as the
                // next element.
                //

                First = ParentStored & ~0x3;
                if ( ReadFirstVadShort( LeftChild, LeftChild) ||
                     (ReadFirstVadShort(Parent, Parent) &&
                     ReadFirstVadShort(u1.Parent, Parent)) ) {
                    dprintf("%08p %08p: Unable to get contents of VAD4\n",Parent, Prev);
                    return E_INVALIDARG;
                }
                Parent &= ~0x3;

                //
                // AVL vad trees are delimited by a parent pointer that equals
                // the current vad so check for that explicitly here so that
                // this same extension can work on both types of kernels.
                //

                if (Parent == First) {
                    break;
                }

                Prev = First;
                
                ReadFirstVadShort(StartingVpn, StartingVpn);
                ReadFirstVadShort(EndingVpn, EndingVpn);
                ReadFirstVadShort(RightChild, RightChild);
                ReadFirstVadShort(u.VadFlags.CommitCharge, CommitCharge);
                ReadFirstVadShort(u.VadFlags.PrivateMemory, PrivateMemory);
                ReadFirstVadShort(u.VadFlags.PhysicalMapping, PhysicalMapping);
                ReadFirstVadShort(u.VadFlags.ImageMap, ImageMap);
                ReadFirstVadShort(u.VadFlags.Protection, Protection);

                if (LeftChild == Next) {
                    Next = ParentStored;
                    
                    dprintf("%p (%2ld)   %8p %8p      %4ld %s %s %s\n",
                            Next,
                            Level,
                            StartingVpn,
                            EndingVpn,
                            (ULONG)CommitCharge,
                            PrivateMemory ? "Private" : "Mapped ",
                            ImageMap ? "Exe " :
                                PhysicalMapping ? "Phys" : "    ",
                            ProtectString[Protection & 7]
                           );
                    Done = FALSE;
                    Count += 1;
                    AverageLevel += Level;
                    break;
                }
                Next = ParentStored;
            }
            if (Done) {
                Next = 0;
                break;
            }
        } else {

            //
            // A right child exists, locate the left most child of that right child.
            //

            Next = RightChild;
            Level += 1;
            if (Level > MaxLevel) {
                MaxLevel = Level;
            }

            First = Next;

            if ( ReadFirstVadShort(LeftChild, LeftChild) ) {
                dprintf("%08p %08p: Unable to get contents of VAD5\n",Next, Prev);
                return E_INVALIDARG;
            }

            while ((Left = LeftChild) != 0) {
                if ( CheckControlC() ) {
                    return E_INVALIDARG;
                }
                Level += 1;
                if (Level > MaxLevel) {
                    MaxLevel = Level;
                }
                Next = Left;
                First = Next;
                if ( ReadFirstVadShort(LeftChild, LeftChild) ) {
                    dprintf("%08p %08p: Unable to get contents of VAD6\n",Next, Prev);
                    return E_INVALIDARG;
                }
                Prev = First;
            }

            ReadFirstVadShort(StartingVpn, StartingVpn);
            ReadFirstVadShort(EndingVpn, EndingVpn);
            if (ReadFirstVadShort(Parent, Parent)) {
                ReadFirstVadShort(u1.Parent, Parent);
                Parent &= ~0x3;
            }
            ReadFirstVadShort(RightChild, RightChild);
            ReadFirstVadShort(u.VadFlags.CommitCharge, CommitCharge);
            ReadFirstVadShort(u.VadFlags.PrivateMemory, PrivateMemory);
            ReadFirstVadShort(u.VadFlags.PhysicalMapping, PhysicalMapping);
            ReadFirstVadShort(u.VadFlags.ImageMap, ImageMap);
            ReadFirstVadShort(u.VadFlags.Protection, Protection);

            dprintf("%p (%2ld)   %8p %8p      %4ld %s %s %s\n",
                      Next,
                      Level,
                      StartingVpn,
                      EndingVpn,
                      (ULONG)CommitCharge,
                      PrivateMemory ? "Private" : "Mapped ",
                      ImageMap ? "Exe " :
                          PhysicalMapping ? "Phys" : "    ",
                      ProtectString[Protection & 7]
                   );
                    Count += 1;
                    AverageLevel += Level;
        }
    }
    dprintf("\nTotal VADs: %5ld  average level: %4ld  maximum depth: %ld\n",
            Count, 1+(AverageLevel/Count),MaxLevel);

#undef ReadFirstVad
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\vpb.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       vpb.c
//
//  Contents:   windbg extension to dump a Vpb
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:
//
//  History:    2-17-1998   benl   Created
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop



//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API(vpb)
//
//  Synopsis:   just print out the fields in the vpb (Volume Parameter Block)
//
//  Arguments:  address of vpb
//
//  Returns:
//
//  History:    2-17-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DECLARE_API( vpb )
{
    ULONG64 dwAddress;
    DWORD   dwRead, Flags;
    UCHAR   VolumeLabel[80]={0};

    //read in the vpb
    dwAddress = GetExpression(args);
    if (GetFieldValue(dwAddress, "VPB", "Flags", Flags))
    {
        dprintf("ReadMemory at 0x%p failed\n", dwAddress);
        return  E_INVALIDARG;
    }

    //now print some stuff
    dprintf("Vpb at 0x%p\n", dwAddress);
    dprintf("Flags: 0x%x ", Flags);
    if (Flags & VPB_MOUNTED) {
        dprintf("mounted ");
    }
    if (Flags & VPB_LOCKED) {
        dprintf("locked ");
    }

    if (Flags & VPB_PERSISTENT) {
        dprintf("persistent");
    }
    dprintf("\n");
    GetFieldValue(dwAddress, "VPB", "VolumeLabel", VolumeLabel);
    InitTypeRead(dwAddress, VPB);
    dprintf("DeviceObject: 0x%p\n", ReadField(DeviceObject));
    dprintf("RealDevice:   0x%p\n", ReadField(RealDevice));
    dprintf("RefCount: %d\n", (ULONG) ReadField(ReferenceCount));
    dprintf("Volume Label: %*s\n", (ULONG) ReadField(VolumeLabelLength), VolumeLabel);

    return S_OK;
} // DECLARE_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\wsle.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    wsle.c

Abstract:

    WinDbg Extension Api

Author:

    Lou Perazzoli (LouP) 14-Mar-1994

Environment:

    User Mode.

--*/


#include "precomp.h"
#pragma hdrstop

#define PACKET_MAX_SIZE 4000
#define NUMBER_OF_WSLE_TO_READ  1000 // ((PACKET_MAX_SIZE/sizeof(MMWSLE))-1)

USHORT
GetPfnRefCount(
    IN ULONG64 PageFrameNumber
    );

DECLARE_API( wsle )

/*++

Routine Description:

    Dumps all wsles for process.

Arguments:

    args - Address Flags

Return Value:

    None

--*/

{
    ULONG ValidCount;
    ULONG64 WsleLong;
    ULONG Result;
    ULONG Flags;
    ULONG index;
    ULONG64 WorkingSet;
    ULONG64 WsleBase;
    ULONG64 Va;
    ULONG64 Wsle;
    ULONG next;
    ULONG j;
    ULONG k;
    PCHAR WsleArray;
    ULONG64 WsleStart;
    ULONG ReadCount;
    ULONG result;
    ULONG found;
    ULONG64 PteAddress;
    ULONG SizeofWsle;
    ULONG64 HashTable;
    ULONG FirstFree, FirstDynamic, LastEntry, NextSlot, LastInitializedWsle;
    ULONG NonDirectCount, HashTableSize;
    PCHAR pc;

    Flags = 0;
    WorkingSet = 0;
    Flags = (ULONG) GetExpression(args);
    pc = strchr(args, ' ');
    WorkingSet = pc ? GetExpression(pc) : 0;

    if (WorkingSet == 0) {
        if (TargetMachine == IMAGE_FILE_MACHINE_I386) {
            WorkingSet = GetPointerValue("nt!MmWorkingSetList");
        }
        else if (TargetMachine == IMAGE_FILE_MACHINE_IA64) {
            WorkingSet = (ULONG64)0x6FC00a02000;
        }
        else if (TargetMachine == IMAGE_FILE_MACHINE_AMD64) {
            WorkingSet = (ULONG64)0xFFFFF70000082000;
        }
        else {
            dprintf ("No default WSL for target machine %x\n", TargetMachine);
            return E_INVALIDARG;
        }
    }

    if (GetTypeSize("nt!_MMWSL") == 0) {
        dprintf("Type MMWSL not found.\n");
        return E_INVALIDARG;
    }

    GetFieldValue(WorkingSet,"nt!_MMWSL","FirstDynamic", FirstDynamic);
    GetFieldValue(WorkingSet,"nt!_MMWSL","FirstFree", FirstFree);
    GetFieldValue(WorkingSet,"nt!_MMWSL","Wsle", Wsle);
    GetFieldValue(WorkingSet,"nt!_MMWSL","LastEntry", LastEntry);
    GetFieldValue(WorkingSet,"nt!_MMWSL","NextSlot", NextSlot);
    GetFieldValue(WorkingSet,"nt!_MMWSL","LastInitializedWsle", LastInitializedWsle);
    GetFieldValue(WorkingSet,"nt!_MMWSL","NonDirectCount", NonDirectCount);
    GetFieldValue(WorkingSet,"nt!_MMWSL","HashTableSize", HashTableSize);
    GetFieldValue(WorkingSet,"nt!_MMWSL","HashTable", HashTable);

    dprintf ("\nWorking Set @ %8p\n", WorkingSet);

    dprintf ("    FirstFree: %8lx  FirstDynamic:   %8lx\n",
        FirstFree,
        FirstDynamic);

    dprintf ("    LastEntry %8lx  NextSlot:  %8lx  LastInitialized %8lx\n",
        LastEntry,
        NextSlot,
        LastInitializedWsle);

    dprintf ("    NonDirect %8lx  HashTable: %8p  HashTableSize:  %8lx\n",
        NonDirectCount,
        HashTable,
        HashTableSize);

    if (Flags == 0) {
        return E_INVALIDARG;
    }

    SizeofWsle = GetTypeSize("nt!_MMWSLE");
    if (SizeofWsle == 0) {
        dprintf("Type _MMWSLE not found.\n");
        return E_INVALIDARG;
    }

    if (Flags & 0x3) {
        BOOL FirstTime = TRUE;

        //
        // Check free entries in the working set list.
        //

        WsleArray = VirtualAlloc (NULL,
                                  (LastInitializedWsle + 1) * SizeofWsle,
                                  MEM_RESERVE | MEM_COMMIT,
                                  PAGE_READWRITE);

        //
        // Copy the working set list over to the debugger.
        //

        if (WsleArray == NULL) {
            dprintf("Unable to get allocate memory of %ld bytes\n",
                       (LastInitializedWsle + 1) * SizeofWsle);
            return E_INVALIDARG;
        }

        WsleStart = Wsle;

        dprintf("\nReading the WSLE data...\n");

        for (j = 0;
             j <= LastInitializedWsle;
             j += NUMBER_OF_WSLE_TO_READ) {

            if ( CheckControlC() ) {
                VirtualFree (WsleArray,0,MEM_RELEASE);
                return E_INVALIDARG;
            }

            ReadCount = (LastInitializedWsle + 1 - j ) > NUMBER_OF_WSLE_TO_READ ?
                            NUMBER_OF_WSLE_TO_READ :
                            LastInitializedWsle + 1 - j;

            ReadCount *= SizeofWsle;

            //
            // Enough to read and forget - KD will cache the data
            //
            if ( !ReadMemory( WsleStart + j*SizeofWsle,
                              WsleArray + j*SizeofWsle,
                              ReadCount,
                              &result) ) {
                dprintf("Unable to get Wsle table block - "
                        "address %p - count %lu - page %lu\n",
                        WsleStart + j*SizeofWsle, ReadCount, j);
                VirtualFree (WsleArray,0,MEM_RELEASE);
                return E_INVALIDARG;
            }

            for (k=0; k<ReadCount/SizeofWsle; k++) {
                GetFieldValue(WsleStart + (j+k)*SizeofWsle, "nt!_MMWSLE", "u1.e1.Valid", WsleArray[j+k]);
            }

            dprintf(".");
        }
        dprintf("\r");

        if (Flags & 0x1) {

            //
            // Walk the array looking for bad free entries.
            //

            dprintf("\nVirtual Address           Age  Locked  ReferenceCount\n");

            for (j = 0;
                 j <= LastInitializedWsle;
                 j += 1) {
                ULONG Valid, Age, LockedInWs, LockedInMemory;
                ULONG64 WsleToread = WsleStart + j*SizeofWsle, Long;

                if ( CheckControlC() ) {
                    dprintf("j= %x\n",j);
                    VirtualFree (WsleArray,0,MEM_RELEASE);
                    return E_INVALIDARG;
                }


                GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.e1.Valid", Valid);

                if (Valid == 0) {

                    //
                    // Locate j in the array.
                    //

                    found = FALSE;
                    for (k = 0;
                         k <= LastInitializedWsle;
                         k += 1) {
                        ULONG k_Valid;
                        ULONG64 k_Long;

                        k_Valid = WsleArray[k];

                        if (k_Valid == 0) {
                            GetFieldValue(WsleStart + k*SizeofWsle, "nt!_MMWSLE", "u1.Long", k_Long);
                            if ((ULONG) (k_Long >> MM_FREE_WSLE_SHIFT) == j) {
                                found = TRUE;
#if 0
                                dprintf(" free entry located @ index %ld. %lx %ld. %lx\n",
                                    j, WsleArray[j].u1.Long,k,WsleArray[k]);
#endif
                                break;
                            }
                        }
                     }
                     if (!found) {

                         if (FirstFree == j) {
                             //        dprintf("first index found\n");
                         } else {

                             GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.VirtualAddress", Long);
                             dprintf(" free entry not located @ index %ld. %p\n",
                                     j, Long);
                         }
                     }
                }
                else {
                    ULONG PteValid;

                    GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.VirtualAddress", Long);
                    Va = Long;
                    PteAddress = DbgGetPteAddress (Va);

                    if (!GetFieldValue(PteAddress,
                                       "nt!_MMPTE",
                                       "u.Hard.Valid",
                                       PteValid) ) {

                        if (PteValid == 0) {
                            dprintf(" cannot find valid PTE for WS index %d, VA %p\n",
                                j, Long);
                        }
                        else {
                            ULONG64 PageFrameNumber;
                            USHORT ReferenceCount;

                            GetFieldValue( PteAddress,
                                           "nt!_MMPTE",
                                           "u.Hard.PageFrameNumber",
                                           PageFrameNumber);
                            ReferenceCount = GetPfnRefCount (PageFrameNumber);
                            GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.e1.Age", Age);
                            GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.e1.LockedInWs", LockedInWs);
                            GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.LockedInMemory", LockedInMemory);


                            dprintf("%16p         %2u %8ld %8ld\n",
                                    Long, Age,
                                (LockedInWs |
                                LockedInMemory) ? 1 : 0,
                                ReferenceCount);
                        }
                    }
                    else {
                        dprintf(" cannot find valid PDE for WS index %d, VA %p\n",
                            j, Long);
                    }
                }
            }
        }

        if (Flags & 0x2) {

            //
            // Walk the array to count how many valid entries are really there.
            //

            ValidCount = 0;

            for (j = 0;
                 j <= LastInitializedWsle;
                 j += 1) {

                ULONG Valid, Age, LockedInWs;
                ULONG64 WsleToread = WsleStart + j*SizeofWsle;

                if ( CheckControlC() ) {
                    dprintf("j= %x\n",j);
                    VirtualFree (WsleArray,0,MEM_RELEASE);
                    return E_INVALIDARG;
                }

                GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.e1.Valid", Valid);

                if (Valid == 1) {
                    ValidCount += 1;
                }
            }

            dprintf ("Valid WSLE entries = 0x%x\n", ValidCount);

            //
            // Walk the array to calculate which free entry really is the first one.
            //

            WsleLong = 0;

            for (j = 0;
                 j <= LastInitializedWsle;
                 j += 1) {

                ULONG Valid, Age, LockedInWs, LockedInMemory;
                ULONG64 WsleToread = WsleStart + j*SizeofWsle;

                if ( CheckControlC() ) {
                    dprintf("j= %x\n",j);
                    VirtualFree (WsleArray,0,MEM_RELEASE);
                    return E_INVALIDARG;
                }

                GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.Long", WsleLong);

                if (WsleLong == (ULONG)(WSLE_NULL_INDEX << 4)) {
                    dprintf ("found end @ wsle index 0x%x\n", j);
                    break;
                }
            }

            if (WsleLong == (ULONG)(WSLE_NULL_INDEX << 4)) {

                for (k = 0;
                     k <= LastInitializedWsle;
                     k += 1) {

                    ULONG Valid, Age, LockedInWs, LockedInMemory;
                    ULONG64 WsleToread = WsleStart + k*SizeofWsle;

                    if ( CheckControlC() ) {
                        dprintf("j= %x\n",k);
                        VirtualFree (WsleArray,0,MEM_RELEASE);
                        return E_INVALIDARG;
                    }

                    GetFieldValue(WsleToread, "nt!_MMWSLE", "u1.Long", WsleLong);

                    if (WsleLong == (ULONG) (j << 4)) {

                        //
                        // Writing any value that has any of the low 4
                        // bits ensures that a corrupt WSL chain won't cause
                        // us to infinitely recurse.
                        //

                        *(PULONG)(WsleArray + (k * SizeofWsle)) = (ULONG)-1;

                        j = k;
                        k = 0;
                        continue;
                    }
                }
                dprintf("Computed first free WSLE is index 0x%x\n", j);
            }
            else {
                dprintf("Cannot compute first free WSLE - no WSLE_NULL_INDEX\n");
            }
        }

        VirtualFree (WsleArray,0,MEM_RELEASE);

    } else {
        ULONG64 nextLong;

        next = FirstFree;
        WsleBase = Wsle;

        while (next != (ULONG) (WSLE_NULL_INDEX << 4)) {
            if (CheckControlC()) {
                return E_INVALIDARG;
            }

            if ( GetFieldValue( WsleBase + SizeofWsle*next,
                                 "nt!_MMWSLE",
                                 "u1.VirtualAddress",
                                 nextLong) ) {
                dprintf("%08p: Unable to get contents of wsle\n",
                        WsleBase+SizeofWsle*next );
                return E_INVALIDARG;
            }
            dprintf("index %8lx  value %8p\n", next, nextLong);
            next = (ULONG) (nextLong >> MM_FREE_WSLE_SHIFT);
        }
    }
    return S_OK;
}

typedef struct _MMSECTION_FLAGS {
    unsigned BeingDeleted : 1;
    unsigned BeingCreated : 1;
    unsigned BeingPurged : 1;
    unsigned NoModifiedWriting : 1;

    unsigned FailAllIo : 1;
    unsigned Image : 1;
    unsigned Based : 1;
    unsigned File : 1;

    unsigned Networked : 1;
    unsigned NoCache : 1;
    unsigned PhysicalMemory : 1;
    unsigned CopyOnWrite : 1;

    unsigned Reserve : 1;  // not a spare bit!
    unsigned Commit : 1;
    unsigned FloppyMedia : 1;
    unsigned WasPurged : 1;

    unsigned UserReference : 1;
    unsigned GlobalMemory : 1;
    unsigned DeleteOnClose : 1;
    unsigned FilePointerNull : 1;

    unsigned DebugSymbolsLoaded : 1;
    unsigned SetMappedFileIoComplete : 1;
    unsigned CollidedFlush : 1;
    unsigned NoChange : 1;

    unsigned HadUserReference : 1;
    unsigned ImageMappedInSystemSpace : 1;
    unsigned UserWritable : 1;
    unsigned Accessed : 1;

    unsigned GlobalOnlyPerSession : 1;
    unsigned Rom : 1;
    unsigned filler : 2;
} MMSECTION_FLAGS;

typedef struct _MMSUBSECTION_FLAGS {
    unsigned ReadOnly : 1;
    unsigned ReadWrite : 1;
    unsigned CopyOnWrite : 1;
    unsigned GlobalMemory: 1;
    unsigned Protection : 5;
    unsigned LargePages : 1;
    unsigned StartingSector4132 : 10;   // 2 ** (42+12) == 4MB*4GB == 16K TB
    unsigned SectorEndOffset : 12;
} MMSUBSECTION_FLAGS;

BOOLEAN WINAPI
CheckForCa (
        PCHAR Tag,
        PCHAR Filter,
        ULONG Flags,
        ULONG64 PoolHeader,
        ULONG64 BlockSize,
        ULONG64 Data,
        PVOID Context
        );

DECLARE_API( ca )

/*++

Routine Description:

    Dumps a control area.

Arguments:

    args - Address Flags

Return Value:

    None

--*/

{
    ULONG64 RestartAddr = 0;
    LARGE_INTEGER StartingSector;
    ULONG64 ControlAreaVa;
    ULONG64 SubsectionVa;
    ULONG ControlAreaSize;
    ULONG LargeControlAreaSize;
    ULONG SubsectionSize;
    ULONG SubsectionCount;
    ULONG64 Segment;
    ULONG64 FileObject;
    MMSECTION_FLAGS ControlAreaFlags;
    MMSUBSECTION_FLAGS SubsectionFlags;
    LOGICAL MappedDataFile;
    LOGICAL PrintedSomething;
    ULONG TagName;
    ULONG Flags;

    Flags = 0;
    Flags = (ULONG) GetExpression(args);

    if (Flags & 0x1) {

        TagName = '*CmM';

        SearchPool (TagName, 0, RestartAddr, &CheckForCa, NULL);
        SearchPool (TagName, 2, RestartAddr, &CheckForCa, NULL);
        return S_OK;
    }

    ControlAreaVa = GetExpression(args);

    dprintf("\n");
    dprintf("ControlArea @%08p\n", ControlAreaVa);

    ControlAreaSize = GetTypeSize("nt!_CONTROL_AREA");
    if (ControlAreaSize == 0) {
        dprintf("Type CONTROL_AREA not found.\n");
        return E_INVALIDARG;
    }

    InitTypeRead(ControlAreaVa, nt!_CONTROL_AREA);

    Segment = ReadField(Segment);
    FileObject = ReadField(FilePointer);

    dprintf ("  Segment:    %08p    Flink       %8p   Blink          %8p\n",
        Segment,
        ReadField(DereferenceList.Flink),
        ReadField(DereferenceList.Blink));

    dprintf ("  Section Ref %8lx    Pfn Ref     %8lx   Mapped Views   %8lx\n",
        (ULONG) ReadField(NumberOfSectionReferences),
        (ULONG) ReadField(NumberOfPfnReferences),
        (ULONG) ReadField(NumberOfMappedViews));

    dprintf ("  User Ref    %8lx    WaitForDel  %8p    Flush Count    %8lx\n",
        (ULONG) ReadField(NumberOfUserReferences),
        ReadField(WaitingForDeletion),
        (USHORT) ReadField(FlushInProgressCount));

    dprintf ("  File Object %08p    ModWriteCount%7lx   System Views   %8lx\n",
        FileObject,
        (USHORT) ReadField(ModifiedWriteCount),
        (USHORT) ReadField(NumberOfSystemCacheViews));

    GetFieldValue(ControlAreaVa, "nt!_CONTROL_AREA", "u.LongFlags", ControlAreaFlags);

    dprintf ("  Flags (%lx) ", ControlAreaFlags);

    if (ControlAreaFlags.BeingDeleted) { dprintf("BeingDeleted "); }
    if (ControlAreaFlags.BeingCreated) { dprintf("BeingCreated "); }
    if (ControlAreaFlags.BeingPurged) { dprintf("BeingPurged "); }
    if (ControlAreaFlags.NoModifiedWriting) { dprintf("NoModifiedWriting "); }

    if (ControlAreaFlags.FailAllIo) { dprintf("FailAllIo "); }
    if (ControlAreaFlags.Image) { dprintf("Image "); }
    if (ControlAreaFlags.Based) { dprintf("Based "); }
    if (ControlAreaFlags.File) { dprintf("File "); }

    if (ControlAreaFlags.Networked) { dprintf("Networked "); }
    if (ControlAreaFlags.NoCache) { dprintf("NoCache "); }
    if (ControlAreaFlags.PhysicalMemory) { dprintf("PhysicalMemory "); }
    if (ControlAreaFlags.CopyOnWrite) { dprintf("CopyOnWrite "); }

    if (ControlAreaFlags.Reserve) { dprintf("Reserve "); }
    if (ControlAreaFlags.Commit) { dprintf("Commit "); }
    if (ControlAreaFlags.FloppyMedia) { dprintf("FloppyMedia "); }
    if (ControlAreaFlags.WasPurged) { dprintf("WasPurged "); }

    if (ControlAreaFlags.UserReference) { dprintf("UserReference "); }
    if (ControlAreaFlags.GlobalMemory) { dprintf("GlobalMemory "); }
    if (ControlAreaFlags.DeleteOnClose) { dprintf("DeleteOnClose "); }
    if (ControlAreaFlags.FilePointerNull) { dprintf("FilePointerNull "); }

    if (ControlAreaFlags.DebugSymbolsLoaded) { dprintf("DebugSymbolsLoaded "); }
    if (ControlAreaFlags.SetMappedFileIoComplete) { dprintf("SetMappedFileIoComplete "); }
    if (ControlAreaFlags.CollidedFlush) { dprintf("CollidedFlush "); }
    if (ControlAreaFlags.NoChange) { dprintf("NoChange "); }

    if (ControlAreaFlags.HadUserReference) { dprintf("HadUserReference "); }
    if (ControlAreaFlags.ImageMappedInSystemSpace) { dprintf("ImageMappedInSystemSpace "); }
    if (ControlAreaFlags.UserWritable) { dprintf("UserWritable "); }
    if (ControlAreaFlags.Accessed) { dprintf("Accessed "); }

    if (ControlAreaFlags.GlobalOnlyPerSession) { dprintf("GlobalOnlyPerSession "); }
    if (ControlAreaFlags.Rom) { dprintf("Rom "); }
    dprintf ("\n\n");

    MappedDataFile = FALSE;

    //
    // Dump the file object's name if there is one and it's resident.
    //

    if (FileObject != 0) {
        ULONG64 FileNameLength;
        ULONG64 FileNameBuffer;
        PUCHAR tempbuffer;
        ULONG result;
        UNICODE_STRING unicodeString;

        if (GetTypeSize("nt!_FILE_OBJECT") == 0) {
            dprintf("Type FILE_OBJECT not found.\n");
            return E_INVALIDARG;
        }

        InitTypeRead(FileObject, nt!_FILE_OBJECT);

        FileNameBuffer = ReadField(FileName.Buffer);

        unicodeString.Length = (USHORT) ReadField(FileName.Length);

        if (unicodeString.Length > MAX_PATH)
        {
            unicodeString.Length = MAX_PATH;
        }
        tempbuffer = LocalAlloc(LPTR, unicodeString.Length + sizeof(WCHAR));

        if (!tempbuffer)
        {
            dprintf("LocalAlloc Failed\n");
        }
        else
        {
            unicodeString.Buffer = (PWSTR)tempbuffer;
            unicodeString.MaximumLength = unicodeString.Length;

            unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR)] = 0;
            if (FileNameBuffer == 0) {
                dprintf("\tNo Name for File\n");
            }
            else if (!ReadMemory ( FileNameBuffer,
                                   tempbuffer,
                                   unicodeString.Length,
                                   &result)) {
                dprintf("\tFile Name paged out\n");
            } else {
                dprintf("\tFile: %wZ\n", &unicodeString);
            }

            LocalFree(tempbuffer);
        }

        if (ControlAreaFlags.Image == 0) {
            MappedDataFile = TRUE;
        }
    }

    //
    // Dump the segment information.
    //

    dprintf("\nSegment @ %08p:\n", Segment);

    if (MappedDataFile == FALSE) {
        if (GetTypeSize("nt!_SEGMENT") == 0) {
            dprintf("Type SEGMENT not found.\n");
            return E_INVALIDARG;
        }
        InitTypeRead(Segment, nt!_SEGMENT);
    }
    else {
        if (GetTypeSize("nt!_MAPPED_FILE_SEGMENT") == 0) {
            dprintf("Type MAPPED_FILE_SEGMENT not found.\n");
            return E_INVALIDARG;
        }
        InitTypeRead(Segment, nt!_MAPPED_FILE_SEGMENT);
    }

    dprintf("   ControlArea  %08p  Total Ptes  %8lx  NonExtendPtes   %8lx\n",
        ReadField(ControlArea),
        (ULONG) ReadField(TotalNumberOfPtes),
        (ULONG) ReadField(NonExtendedPtes));


    if (ControlAreaVa != ReadField(ControlArea)) {
        dprintf("SEGMENT is corrupt - bad control area backlink.\n");
        return E_INVALIDARG;
    }

    dprintf("   WriteUserRef %8lx  SizeOfSegment  %I64x  PTE Template %I64X\n",
        (ULONG) ReadField(WritableUserReferences),
        ReadField(SizeOfSegment),
        ReadField(SegmentPteTemplate.u.Long));

    dprintf("   Committed    %8p  Extend Info %8p  Image Base   %8p\n",
        ReadField(NumberOfCommittedPages),
        ReadField(ExtendInfo),
        ReadField(SystemImageBase));

    dprintf("   Based Addr   %8p\n",
        ReadField(BasedAddress));

    if (MappedDataFile == FALSE) {

        if (ControlAreaFlags.Image == 1) {
            dprintf("   Image commit %8p  Image Info.  %8p",
                ReadField(u1.ImageCommitment),
                ReadField(u2.ImageInformation));
        }
        else {
            dprintf("   CreatingProcess %8p  FirstMappedVa  %8p",
                ReadField(u1.CreatingProcess),
                ReadField(u2.FirstMappedVa));
        }

        dprintf("   ProtoPtes   %08p\n",
            ReadField(PrototypePte));
    }

    //
    // Dump the subsection(s).
    //

    SubsectionSize = GetTypeSize("nt!_SUBSECTION");

    if (SubsectionSize == 0) {
        dprintf("Type SUBSECTION not found.\n");
        return E_INVALIDARG;
    }

    LargeControlAreaSize = GetTypeSize("nt!_LARGE_CONTROL_AREA");

    if (LargeControlAreaSize == 0) {
        dprintf("Type LARGE_CONTROL_AREA not found.\n");
        return E_INVALIDARG;
    }

    if (ControlAreaFlags.GlobalOnlyPerSession) {
        SubsectionVa = ControlAreaVa + LargeControlAreaSize;
    }
    else {
        SubsectionVa = ControlAreaVa + ControlAreaSize;
    }

    SubsectionCount = 0;

    do {
        if (CheckControlC()) {
            return E_INVALIDARG;
        }

        InitTypeRead(SubsectionVa, nt!_SUBSECTION);

        SubsectionCount += 1;
        dprintf("\nSubsection %ld. @ %8p\n", SubsectionCount, SubsectionVa);

        GetFieldValue(SubsectionVa, "nt!_SUBSECTION", "u.LongFlags", SubsectionFlags);
        StartingSector.LowPart = (ULONG)ReadField(StartingSector);
        StartingSector.HighPart = (LONG)SubsectionFlags.StartingSector4132;

        dprintf("   ControlArea: %08p  Starting Sector %I64X Number Of Sectors %lx\n",
            ReadField(ControlArea),
            StartingSector.QuadPart,
            (ULONG) ReadField(NumberOfFullSectors));

        dprintf("   Base Pte     %08p  Ptes In subsect %8lx Unused Ptes   %8lx\n",
            ReadField(SubsectionBase),
            (ULONG) ReadField(PtesInSubsection),
            (ULONG) ReadField(UnusedPtes));

        dprintf("   Flags        %8lx  Sector Offset   %8lx Protection    %8lx\n",
            SubsectionFlags,
            SubsectionFlags.SectorEndOffset,
            SubsectionFlags.Protection);


        PrintedSomething = FALSE;
        if (SubsectionFlags.ReadOnly) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("ReadOnly ");
        }
        if (SubsectionFlags.ReadWrite) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("ReadWrite");
        }
        if (SubsectionFlags.CopyOnWrite) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("CopyOnWrite ");
        }
        if (SubsectionFlags.GlobalMemory) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("GlobalMemory ");
        }
        if (SubsectionFlags.LargePages) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("Large Pages");
        }

        if (PrintedSomething == TRUE) {
            dprintf("\n");
        }

        if (MappedDataFile == TRUE) {
            InitTypeRead(SubsectionVa, nt!_MSUBSECTION);
            dprintf("   Flink        %08p  Blink      %08p      MappedViews %8x\n",
                ReadField(DereferenceList.Flink),
                ReadField(DereferenceList.Blink),
                (ULONG) ReadField(NumberOfMappedViews));

            dprintf("   SubsectionDataFlags %8x\n",
                (ULONG) ReadField(u2.LongFlags2));
        }

        SubsectionVa = ReadField(NextSubsection);

    } while (SubsectionVa != 0);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckForCa
//
//  Synopsis:   Matches pool chunk against a CA.
//
//  Arguments:  [Tag]            --
//              [Filter]         --
//              [Flags]          -- 0 nonpaged pool 1 paged pool 2 special pool
//              [PoolTrackTable] --
//              [PoolHeader]     --
//              [BlockSize]      --
//              [Data]           --
//
//----------------------------------------------------------------------------

BOOLEAN WINAPI
CheckForCa (
          PCHAR Tag,        // Tag of the current pool
          PCHAR Filter,     // MmCa or MmCi
          ULONG Flags,
          ULONG64 PoolHeader,
          ULONG64 BlockSize,
          ULONG64 Data,
          PVOID Context
          )
{
    ULONG TagToMatch;
    ULONG Result;
    ULONG PoolType, SizeOfIRP;
    LARGE_INTEGER StartingSector;
    ULONG64 ControlAreaVa;
    ULONG64 SubsectionVa;
    ULONG ControlAreaSize;
    ULONG LargeControlAreaSize;
    ULONG SubsectionSize;
    ULONG SubsectionCount;
    ULONG64 Segment;
    ULONG64 FileObject;
    MMSECTION_FLAGS ControlAreaFlags;
    MMSUBSECTION_FLAGS SubsectionFlags;
    LOGICAL MappedDataFile;
    LOGICAL PrintedSomething;
    ULONG TagName;

    if (Flags & 0x4) {
        return FALSE;
    }

    if (PoolHeader) {
        if (GetFieldValue(PoolHeader, "nt!_POOL_HEADER", "PoolType", PoolType)) {
            dprintf("Unable to read nt!_POOL_HEADER type.\n");
        }
        else {
            if ((PoolType & 0x4) == 0) {

                //
                // This pool allocation has been freed so ignore it.
                //

                return FALSE;
            }
        }
    }

    if (!CheckSingleFilter (Tag, Filter)) {
        return FALSE;
    }

    ControlAreaVa = Data;

    dprintf("\n");
    dprintf("ControlArea @%08p\n", ControlAreaVa);

    ControlAreaSize = GetTypeSize("nt!_CONTROL_AREA");
    if (ControlAreaSize == 0) {
        dprintf("Type CONTROL_AREA not found.\n");
        return FALSE;
    }

    InitTypeRead(ControlAreaVa, nt!_CONTROL_AREA);

    Segment = ReadField(Segment);
    FileObject = ReadField(FilePointer);

    dprintf ("  Segment:    %08p    Flink       %8p   Blink          %8p\n",
        Segment,
        ReadField(DereferenceList.Flink),
        ReadField(DereferenceList.Blink));

    dprintf ("  Section Ref %8lx    Pfn Ref     %8lx   Mapped Views   %8lx\n",
        (ULONG) ReadField(NumberOfSectionReferences),
        (ULONG) ReadField(NumberOfPfnReferences),
        (ULONG) ReadField(NumberOfMappedViews));

    dprintf ("  User Ref    %8lx    WaitForDel  %8p    Flush Count    %8lx\n",
        (ULONG) ReadField(NumberOfUserReferences),
        ReadField(WaitingForDeletion),
        (USHORT) ReadField(FlushInProgressCount));

    dprintf ("  File Object %08p    ModWriteCount%7lx   System Views   %8lx\n",
        FileObject,
        (USHORT) ReadField(ModifiedWriteCount),
        (USHORT) ReadField(NumberOfSystemCacheViews));

    GetFieldValue(ControlAreaVa, "nt!_CONTROL_AREA", "u.LongFlags", ControlAreaFlags);

    dprintf ("  Flags (%lx) ", ControlAreaFlags);

    if (ControlAreaFlags.BeingDeleted) { dprintf("BeingDeleted "); }
    if (ControlAreaFlags.BeingCreated) { dprintf("BeingCreated "); }
    if (ControlAreaFlags.BeingPurged) { dprintf("BeingPurged "); }
    if (ControlAreaFlags.NoModifiedWriting) { dprintf("NoModifiedWriting "); }

    if (ControlAreaFlags.FailAllIo) { dprintf("FailAllIo "); }
    if (ControlAreaFlags.Image) { dprintf("Image "); }
    if (ControlAreaFlags.Based) { dprintf("Based "); }
    if (ControlAreaFlags.File) { dprintf("File "); }

    if (ControlAreaFlags.Networked) { dprintf("Networked "); }
    if (ControlAreaFlags.NoCache) { dprintf("NoCache "); }
    if (ControlAreaFlags.PhysicalMemory) { dprintf("PhysicalMemory "); }
    if (ControlAreaFlags.CopyOnWrite) { dprintf("CopyOnWrite "); }

    if (ControlAreaFlags.Reserve) { dprintf("Reserve "); }
    if (ControlAreaFlags.Commit) { dprintf("Commit "); }
    if (ControlAreaFlags.FloppyMedia) { dprintf("FloppyMedia "); }
    if (ControlAreaFlags.WasPurged) { dprintf("WasPurged "); }

    if (ControlAreaFlags.UserReference) { dprintf("UserReference "); }
    if (ControlAreaFlags.GlobalMemory) { dprintf("GlobalMemory "); }
    if (ControlAreaFlags.DeleteOnClose) { dprintf("DeleteOnClose "); }
    if (ControlAreaFlags.FilePointerNull) { dprintf("FilePointerNull "); }

    if (ControlAreaFlags.DebugSymbolsLoaded) { dprintf("DebugSymbolsLoaded "); }
    if (ControlAreaFlags.SetMappedFileIoComplete) { dprintf("SetMappedFileIoComplete "); }
    if (ControlAreaFlags.CollidedFlush) { dprintf("CollidedFlush "); }
    if (ControlAreaFlags.NoChange) { dprintf("NoChange "); }

    if (ControlAreaFlags.HadUserReference) { dprintf("HadUserReference "); }
    if (ControlAreaFlags.ImageMappedInSystemSpace) { dprintf("ImageMappedInSystemSpace "); }
    if (ControlAreaFlags.UserWritable) { dprintf("UserWritable "); }
    if (ControlAreaFlags.Accessed) { dprintf("Accessed "); }

    if (ControlAreaFlags.GlobalOnlyPerSession) { dprintf("GlobalOnlyPerSession "); }
    if (ControlAreaFlags.Rom) { dprintf("Rom "); }
    dprintf ("\n\n");

    MappedDataFile = FALSE;

    //
    // Dump the file object's name if there is one and it's resident.
    //

    if (FileObject != 0) {
        ULONG64 FileNameLength;
        ULONG64 FileNameBuffer;
        PUCHAR tempbuffer;
        ULONG result;
        UNICODE_STRING unicodeString;

        if (GetTypeSize("nt!_FILE_OBJECT") == 0) {
            dprintf("Type FILE_OBJECT not found.\n");
            return FALSE;
        }

        InitTypeRead(FileObject, nt!_FILE_OBJECT);

        FileNameBuffer = ReadField(FileName.Buffer);

        unicodeString.Length = (USHORT) ReadField(FileName.Length);

        if (unicodeString.Length > MAX_PATH)
        {
            unicodeString.Length = MAX_PATH;
        }
        tempbuffer = LocalAlloc(LPTR, unicodeString.Length + sizeof(WCHAR));

        if (!tempbuffer)
        {
            dprintf("LocalAlloc Failed\n");
        }
        else
        {

            unicodeString.Buffer = (PWSTR)tempbuffer;
            unicodeString.MaximumLength = unicodeString.Length;
            unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR)] = 0;

            if (FileNameBuffer == 0) {
                dprintf("\tNo Name for File\n");
            }
            else if (!ReadMemory ( FileNameBuffer,
                                   tempbuffer,
                                   unicodeString.Length,
                                   &result)) {
                dprintf("\tFile Name paged out\n");
            } else {
                dprintf("\tFile: %wZ\n", &unicodeString);
            }

            LocalFree(tempbuffer);
        }

        if (ControlAreaFlags.Image == 0) {
            MappedDataFile = TRUE;
        }
    }

    //
    // Dump the segment information.
    //

    dprintf("\nSegment @ %08p:\n", Segment);

    if (MappedDataFile == FALSE) {
        if (GetTypeSize("nt!_SEGMENT") == 0) {
            dprintf("Type SEGMENT not found.\n");
            return FALSE;
        }
        InitTypeRead(Segment, nt!_SEGMENT);
    }
    else {
        if (GetTypeSize("nt!_MAPPED_FILE_SEGMENT") == 0) {
            dprintf("Type MAPPED_FILE_SEGMENT not found.\n");
            return FALSE;
        }
        InitTypeRead(Segment, nt!_MAPPED_FILE_SEGMENT);
    }

    dprintf("   ControlArea  %08p  Total Ptes  %8lx  NonExtendPtes   %8lx\n",
        ReadField(ControlArea),
        (ULONG) ReadField(TotalNumberOfPtes),
        (ULONG) ReadField(NonExtendedPtes));


    if (ControlAreaVa != ReadField(ControlArea)) {
        dprintf("SEGMENT is corrupt - bad control area backlink.\n");
        return FALSE;
    }

    dprintf("   WriteUserRef %8lx  SizeOfSegment  %I64x  PTE Template %I64X\n",
        (ULONG) ReadField(WritableUserReferences),
        ReadField(SizeOfSegment),
        ReadField(SegmentPteTemplate.u.Long));

    dprintf("   Committed    %8p  Extend Info %8p  Image Base   %8p\n",
        ReadField(NumberOfCommittedPages),
        ReadField(ExtendInfo),
        ReadField(SystemImageBase));

    dprintf("   Based Addr   %8p\n",
        ReadField(BasedAddress));

    if (MappedDataFile == FALSE) {

        if (ControlAreaFlags.Image == 1) {
            dprintf("   Image commit %8p  Image Info.  %8p",
                ReadField(ImageCommitment),
                ReadField(ImageInformation));
        }
        else {
            dprintf("   CreatingProcess %8p  FirstMappedVa  %8p",
                ReadField(u1.CreatingProcess),
                ReadField(u2.FirstMappedVa));
        }

        dprintf("   ProtoPtes   %08p\n",
            ReadField(PrototypePte));
    }

    //
    // Dump the subsection(s).
    //

    SubsectionSize = GetTypeSize("nt!_SUBSECTION");

    if (SubsectionSize == 0) {
        dprintf("Type SUBSECTION not found.\n");
        return FALSE;
    }

    LargeControlAreaSize = GetTypeSize("nt!_LARGE_CONTROL_AREA");

    if (LargeControlAreaSize == 0) {
        dprintf("Type LARGE_CONTROL_AREA not found.\n");
        return FALSE;
    }

    if (ControlAreaFlags.GlobalOnlyPerSession) {
        SubsectionVa = ControlAreaVa + LargeControlAreaSize;
    }
    else {
        SubsectionVa = ControlAreaVa + ControlAreaSize;
    }

    SubsectionCount = 0;

    do {
        if (CheckControlC()) {
            return FALSE;
        }

        InitTypeRead(SubsectionVa, nt!_SUBSECTION);

        SubsectionCount += 1;
        dprintf("\nSubsection %ld. @ %8p\n", SubsectionCount, SubsectionVa);

        GetFieldValue(SubsectionVa, "nt!_SUBSECTION", "u.LongFlags", SubsectionFlags);
        StartingSector.LowPart = (ULONG)ReadField(StartingSector);
        StartingSector.HighPart = (LONG)SubsectionFlags.StartingSector4132;

        dprintf("   ControlArea: %08p  Starting Sector %I64X Number Of Sectors %lx\n",
            ReadField(ControlArea),
            StartingSector.QuadPart,
            (ULONG) ReadField(NumberOfFullSectors));

        dprintf("   Base Pte     %08p  Ptes In subsect %8lx Unused Ptes   %8lx\n",
            ReadField(SubsectionBase),
            (ULONG) ReadField(PtesInSubsection),
            (ULONG) ReadField(UnusedPtes));

        dprintf("   Flags        %8lx  Sector Offset   %8lx Protection    %8lx\n",
            SubsectionFlags,
            SubsectionFlags.SectorEndOffset,
            SubsectionFlags.Protection);


        PrintedSomething = FALSE;
        if (SubsectionFlags.ReadOnly) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("ReadOnly ");
        }
        if (SubsectionFlags.ReadWrite) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("ReadWrite");
        }
        if (SubsectionFlags.CopyOnWrite) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("CopyOnWrite ");
        }
        if (SubsectionFlags.GlobalMemory) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("GlobalMemory ");
        }
        if (SubsectionFlags.LargePages) {
            if (PrintedSomething == FALSE) {
                dprintf("    ");
            }
            PrintedSomething = TRUE;
            dprintf("Large Pages");
        }

        if (PrintedSomething == TRUE) {
            dprintf("\n");
        }

        if (MappedDataFile == TRUE) {
            InitTypeRead(SubsectionVa, nt!_MSUBSECTION);
            dprintf("   Flink        %08p  Blink      %08p      MappedViews %8x\n",
                ReadField(DereferenceList.Flink),
                ReadField(DereferenceList.Blink),
                (ULONG) ReadField(NumberOfMappedViews));

            dprintf("   SubsectionDataFlags %8x\n",
                (ULONG) ReadField(u2.LongFlags2));
        }

        SubsectionVa = ReadField(NextSubsection);

    } while (SubsectionVa != 0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kernprof\kernprof.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   kernprof.c

Abstract:

    This module contains the implementation of a kernel profiler.

    It uses dbghelp for symbols and image information and
    creates profile objects for each modules it finds loaded
    when it starts.

Usage:
        See below

Author:

    Lou Perazzoli (loup) 29-Sep-1990

Envirnoment:



Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <..\pperf\pstat.h>


#define SYM_HANDLE INVALID_HANDLE_VALUE
#define DBG_PROFILE 0
#define MAX_BYTE_PER_LINE  72
#define MAX_PROFILE_COUNT  200
#define MAX_BUCKET_SHIFT 31        // 2GBytes
#define MAX_BUCKET_SIZE 0x80000000U

typedef struct _PROFILE_BLOCK {
    HANDLE      Handle[MAXIMUM_PROCESSORS];
    PVOID       ImageBase;
    PULONG      CodeStart;
    SIZE_T      CodeLength;
    PULONG      Buffer[MAXIMUM_PROCESSORS];
    ULONG       BufferSize;
    ULONG       BucketSize;
    LPSTR       ModuleName;
    ULONG       ModuleHitCount[MAXIMUM_PROCESSORS];
    BOOLEAN     SymbolsLoaded;
} PROFILE_BLOCK;

//
// This really should go into a header file but....
//
typedef struct _PROFILE_CONTROL_BLOCK {
        BOOLEAN Stop;
        char FileName[MAX_PATH];
} PROFILE_CONTROL_BLOCK;
typedef PROFILE_CONTROL_BLOCK * PPROFILE_CONTROL_BLOCK;
#define PRFEVENT_START_EVENT "PrfEventStartedEvent"
#define PRFEVENT_STOP_EVENT "PrfEventStopEvent"
#define PRFEVENT_SHARED_MEMORY "PrfEventSharedMemory"
//
// End header file
//

#define MAX_SYMNAME_SIZE  1024
CHAR symBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL ThisSymbol = (PIMAGEHLP_SYMBOL) symBuffer;

CHAR LastSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL LastSymbol = (PIMAGEHLP_SYMBOL) LastSymBuffer;



VOID
InitializeProfileSourceMapping (
    VOID
    );

NTSTATUS
InitializeKernelProfile(
    VOID
    );

NTSTATUS
RunEventLoop(
    VOID
    );

NTSTATUS
RunStdProfile(
    VOID
    );

NTSTATUS
StartProfile(
    VOID
    );

NTSTATUS
StopProfile(
    VOID
    );

NTSTATUS
AnalyzeProfile(
    ULONG Threshold,
    PSYSTEM_CONTEXT_SWITCH_INFORMATION StartContext,
    PSYSTEM_CONTEXT_SWITCH_INFORMATION StopContext
    );

VOID
OutputSymbolCount(
    IN ULONG CountAtSymbol,
    IN ULONG TotalCount,
    IN PROFILE_BLOCK *ProfileObject,
    IN PIMAGEHLP_SYMBOL SymbolInfo,
    IN ULONG Threshold,
    IN PULONG CounterStart,
    IN PULONG CounterStop,
    IN ULONG Va,
    IN ULONG BytesPerBucket
    );

#ifdef _ALPHA_
#define PAGE_SIZE 8192
#else
#define PAGE_SIZE 4096
#endif


FILE *fpOut = NULL;

PROFILE_BLOCK ProfileObject[MAX_PROFILE_COUNT];
DWORD *UserModeBuffer[MAXIMUM_PROCESSORS];

ULONG NumberOfProfileObjects = 0;
ULONG MaxProcessors = 1;
ULONG ProfileInterval = 10000;

CHAR SymbolSearchPathBuf[4096];
LPSTR lpSymbolSearchPath = SymbolSearchPathBuf;

// display flags
BOOLEAN    bDisplayAddress=FALSE;
BOOLEAN    bDisplayDensity=FALSE;
BOOLEAN    bDisplayCounters=FALSE;
BOOLEAN    bDisplayContextSwitch=FALSE;
BOOLEAN    bPerProcessor = FALSE;
BOOLEAN    bWaitForInput = FALSE;
BOOLEAN    bEventLoop = FALSE;
BOOLEAN    bPrintPercentages = FALSE;
BOOLEAN    Verbose = FALSE;

//
// Image name to perform kernel mode analysis upon.
//

#define IMAGE_NAME "\\SystemRoot\\system32\\ntoskrnl.exe"

HANDLE DoneEvent;
HANDLE DelayEvent;

KPROFILE_SOURCE ProfileSource = ProfileTime;
ULONG Seconds = (ULONG)-1;
ULONG Threshold = 100;
ULONG DelaySeconds = (ULONG)-1;

//
// define the mappings between arguments and KPROFILE_SOURCE types
//

typedef struct _PROFILE_SOURCE_MAPPING {
    PCHAR   ShortName;
    PCHAR   Description;
    KPROFILE_SOURCE Source;
} PROFILE_SOURCE_MAPPING, *PPROFILE_SOURCE_MAPPING;

#if defined(_ALPHA_)

PROFILE_SOURCE_MAPPING ProfileSourceMapping[] = {
    {"align", "", ProfileAlignmentFixup},
    {"totalissues", "", ProfileTotalIssues},
    {"pipelinedry", "", ProfilePipelineDry},
    {"loadinstructions", "", ProfileLoadInstructions},
    {"pipelinefrozen", "", ProfilePipelineFrozen},
    {"branchinstructions", "", ProfileBranchInstructions},
    {"totalnonissues", "", ProfileTotalNonissues},
    {"dcachemisses", "", ProfileDcacheMisses},
    {"icachemisses", "", ProfileIcacheMisses},
    {"branchmispredicts", "", ProfileBranchMispredictions},
    {"storeinstructions", "", ProfileStoreInstructions},
    {NULL,0}
    };

#elif defined(_X86_)

PPROFILE_SOURCE_MAPPING ProfileSourceMapping;

#else

PROFILE_SOURCE_MAPPING ProfileSourceMapping[] = {
    {NULL,0}
    };
#endif

BOOL
CtrlcH(
    DWORD dwCtrlType
    )
{
    if ( dwCtrlType == CTRL_C_EVENT ) {
        SetEvent(DoneEvent);
        return TRUE;
        }
    return FALSE;
}

void PrintUsage (void)
{
    fputs ("Kernel Profiler Usage:\n\n"
           "Kernprof [-acdpnrx] [-w <wait time>] [-s Source] [-t <low threshold>] [<sample time>]\n"
           "      -a           - display function address and length and bucket size\n"
           "      -c           - display individual counters\n"
           "      -d           - compute hit Density for each function\n"
//UNDOC    "      -e                 - use special event syncronization for start and stop\n"
           "      -f filename  - output file (Default stdout)\n"
           "      -i <interval in 100ns> (Default 10000)\n"
           "      -n           - print hit percentages\n"
           "      -p           - Per-processor profile objects\n"
           "      -r           - wait for a <RETURN> before starting collection\n"
           "      -s Source    - use Source instead of clock as profile source\n"
           "                     ? lists Sources\n"
           "      -t <low threshold> - Minimum number of counts to report.\n"
           "                     Defaults is 100\n"
           "      -v           - Display verbose symbol information\n"
           "      -w           - wait for <wait time> before starting collection\n"
           "      -x           - display context switch counters\n"
           "   <sample time>   - Specify, in seconds, how long to collect\n"
           "                     profile information.\n"
           "                     Default is wait until Ctrl-C\n\n"
#if defined (_ALPHA_)
           "Currently supported profile sources are 'align', 'totalissues', 'pipelinedry'\n"
           "  'loadinstructions', 'pipelinefrozen', 'branchinstructions', 'totalnonissues',\n"
           "  'dcachemisses', 'icachemisses', 'branchmispredicts', 'storeinstructions'\n"
#endif
            , stderr);
}

BOOL
SymbolCallbackFunction(
    HANDLE hProcess,	   //currently not used but required
    ULONG ActionCode,

#if defined(_WIN64)

    ULONG64 CallbackData,
    ULONG64 UserContext	   //currently not used but required

#else

    PVOID CallbackData,
    PVOID UserContext	   //currently not used but required

#endif // _WIN64

)
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD idsl;

    idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD) CallbackData;

    if(Verbose == TRUE){
       switch (ActionCode) {
           case CBA_DEBUG_INFO:
               printf("CBA_DEBUG_INFO: %s\n", (LPSTR)CallbackData);
               break;

           case CBA_DEFERRED_SYMBOL_LOAD_START:
               printf( "CBA_DEFERED: Loading symbols for %16s\n", idsl->FileName);
               break;

           case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
               printf( "*** Error: could not load symbols for %s\n", idsl->FileName );
               break;

           case CBA_SYMBOLS_UNLOADED:
              printf( "Symbols unloaded for %s\n", idsl->FileName);
              break;

           default:
              return FALSE;
       }
	}
       return FALSE;
}

__cdecl
main(
    int argc,
    char *argv[]
    )
{
    int j;
    NTSTATUS status;
    PPROFILE_SOURCE_MAPPING ProfileMapping;
    SYSTEM_INFO SystemInfo;
    fpOut = stdout;

    ThisSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    ThisSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
    LastSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    LastSymbol->MaxNameLength = MAX_SYMNAME_SIZE;

    //
    // Parse the input string.
    //

    DoneEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (argc > 1) {
        if (((argv[1][0] == '-') || (argv[1][0] == '/')) &&
            ((argv[1][1] == '?' ) ||
             (argv[1][1] == 'H') ||
             (argv[1][1] == 'H'))
            ) {

            PrintUsage();
            return ERROR_SUCCESS;
        }

        for (j = 1; j < argc; j++) {

            BOOLEAN NextArg;
            char *p;

            if (argv[j][0] == '-') {

                NextArg = FALSE;

                for (p = &argv[j][1] ; *p && !NextArg ; p++) {
                    switch (toupper(*p)) {
                        case 'A':
                            bDisplayAddress = TRUE;
                            break;

                        case 'C':
                            bDisplayCounters = TRUE;
                            break;

                        case 'D':
                            bDisplayDensity = TRUE;
                            break;

                        case 'E':
                            bEventLoop = TRUE;
                            break;

                        case 'F':
                            NextArg = TRUE;
                            fpOut = fopen(argv[++j], "w");
                            break;

                        case 'I':
                            NextArg = TRUE;
                            ProfileInterval = atoi(argv[++j]);
                            break;

                        case 'N':
                            bPrintPercentages = TRUE;
                            break;

                        case 'P':
                            GetSystemInfo(&SystemInfo);
                            MaxProcessors = SystemInfo.dwNumberOfProcessors;
                            bPerProcessor = TRUE;
                            break;

                        case 'R':
                            bWaitForInput = TRUE;
                            break;

                        case 'S':
                            NextArg = TRUE;
                            if (!ProfileSourceMapping) {
                                InitializeProfileSourceMapping();
                            }

                            if (!argv[j+1]) {
                                break;
                            }

                            if (argv[j+1][0] == '?') {
                                ProfileMapping = ProfileSourceMapping;
                                if (ProfileMapping) {
                                    fprintf (stderr, "kernprof: profile sources\n");
                                    while (ProfileMapping->ShortName != NULL) {
                                        fprintf (stderr, "  %-10s %s\n",
                                            ProfileMapping->ShortName,
                                            ProfileMapping->Description
                                            );
                                        ++ProfileMapping;
                                    }
                                } else {
                                    fprintf (stderr, "kernprof: no alternative profile sources\n");
                                }
                                return 0;
                            }

                            ProfileMapping = ProfileSourceMapping;
                            if (ProfileMapping) {
                                while (ProfileMapping->ShortName != NULL) {
                                    if (_stricmp(ProfileMapping->ShortName, argv[j+1])==0) {
                                        ProfileSource = ProfileMapping->Source;
                                        fprintf (stderr, "ProfileSource %x\n", ProfileMapping->Source);
                                        ++j;
                                        break;
                                    }
                                    ++ProfileMapping;
                                }
                            }
                            break;

                        case 'T':
                            NextArg = TRUE;
                            Threshold = atoi(argv[++j]);
                            break;

                        case 'V':
                            Verbose = TRUE;
                            break;

                        case 'W':
                            NextArg = TRUE;
                            DelaySeconds = atoi(argv[++j]);
                            DelayEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
                            break;

                        case 'X':
                            bDisplayContextSwitch = TRUE;
                            break;
                    }
                }
            } else {
                Seconds = atoi(argv[j]);
            }
        }
    }

	if(Verbose == TRUE){
        SymSetOptions( SYMOPT_UNDNAME | SYMOPT_CASE_INSENSITIVE | SYMOPT_OMAP_FIND_NEAREST | SYMOPT_DEBUG);
    }else{
        SymSetOptions( SYMOPT_UNDNAME | SYMOPT_CASE_INSENSITIVE | SYMOPT_OMAP_FIND_NEAREST);
    }

    SymInitialize( SYM_HANDLE, NULL, FALSE );

#if defined(_WIN64)

    SymRegisterCallback64(SYM_HANDLE, SymbolCallbackFunction, 0);

#else

    SymRegisterCallback(SYM_HANDLE, SymbolCallbackFunction, NULL);

#endif

    SymGetSearchPath( SYM_HANDLE, SymbolSearchPathBuf, sizeof(SymbolSearchPathBuf) );

    // Append Sysroot,System32 etc. to sympath to find the executable images
    // (this way the current dir and the sybol dirs will be searched first for privates) 
        
    strncat(lpSymbolSearchPath,
            ";%SystemRoot%\\System32;%SystemRoot%\\System32\\Drivers;%SystemRoot%",
            sizeof(SymbolSearchPathBuf)/sizeof(CHAR) - 1
            );

    SymSetSearchPath(SYM_HANDLE, lpSymbolSearchPath);
    SymGetSearchPath( SYM_HANDLE, SymbolSearchPathBuf, sizeof(SymbolSearchPathBuf) );
    
    printf("Symbol Path = %s\n", SymbolSearchPathBuf);
    printf("Loading Symbols, Please Wait...\n");

    if (bEventLoop || (DelaySeconds != -1)) {
        SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    }

    status = InitializeKernelProfile ();
    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "initialize failed status - %lx\n",status);
        return(status);
    }

    if (bEventLoop)
        RunEventLoop();
    else
        RunStdProfile();

    return STATUS_SUCCESS;
}

NTSTATUS
RunEventLoop()
{
    NTSTATUS status;
    SYSTEM_CONTEXT_SWITCH_INFORMATION StartContext;
    SYSTEM_CONTEXT_SWITCH_INFORMATION StopContext;
    HANDLE hStartedEvent = NULL;
    HANDLE hStopEvent = NULL;
    HANDLE hMap = NULL;
    PPROFILE_CONTROL_BLOCK pShared = NULL;

    // Create the events and shared memory
    hStartedEvent = CreateEvent (NULL, FALSE, FALSE, PRFEVENT_START_EVENT);
    if (hStartedEvent == NULL) {
        fprintf(stderr, "Failed to create started event - 0x%lx\n",
                GetLastError());
        return(GetLastError());
    }
    hStopEvent = CreateEvent (NULL, FALSE, FALSE, PRFEVENT_STOP_EVENT);
    if (hStopEvent == NULL) {
        fprintf(stderr, "Failed to create stop event - 0x%lx\n",
                GetLastError());
        return(GetLastError());
    }
    hMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE | SEC_COMMIT,
                                    0, sizeof(PROFILE_CONTROL_BLOCK),
                                    PRFEVENT_SHARED_MEMORY);
    if (hMap == NULL) {
        fprintf(stderr, "Failed to create the file mapping - 0x%lx\n",
                GetLastError());
        return(GetLastError());
    }
    pShared = (PPROFILE_CONTROL_BLOCK) MapViewOfFile(hMap, FILE_MAP_WRITE,
                                                0,0, sizeof(PROFILE_CONTROL_BLOCK));
    if (pShared == NULL) {
        fprintf(stderr, "Failed to map the shared memory view - 0x%lx\n",
                GetLastError());
        return(GetLastError());
    }

    // Wait for start i.e., the stop event
    WaitForSingleObject(hStopEvent, INFINITE);

    do {

        if (bDisplayContextSwitch) {
            NtQuerySystemInformation(SystemContextSwitchInformation,
                                 &StartContext,
                                 sizeof(StartContext),
                                 NULL);
        }

        status = StartProfile ();
        if (!NT_SUCCESS(status)) {
            fprintf(stderr, "start profile failed status - %lx\n",status);
            break;
        }

        // Signal started
        SetEvent(hStartedEvent);
        // Wait for stop
        WaitForSingleObject(hStopEvent, INFINITE);

        status = StopProfile ();
        if (!NT_SUCCESS(status)) {
            fprintf(stderr, "stop profile failed status - %lx\n",status);
            break;
        }

        if (bDisplayContextSwitch) {
            status = NtQuerySystemInformation(SystemContextSwitchInformation,
                                          &StopContext,
                                          sizeof(StopContext),
                                          NULL);
            if (!NT_SUCCESS(status)) {
                fprintf(stderr, "QuerySystemInformation for context switch information failed %08lx\n",status);
                bDisplayContextSwitch = FALSE;
            }
        }

        fpOut = fopen(pShared->FileName, "w");
        status = AnalyzeProfile (Threshold, &StartContext, &StopContext);
        fclose(fpOut);

        if (!NT_SUCCESS(status)) {
            fprintf(stderr, "analyze profile failed status - %lx\n",status);
        }
      
    }while( pShared->Stop == FALSE );

    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    UnmapViewOfFile((void*)pShared);
    CloseHandle(hMap);
    CloseHandle(hStopEvent);
    CloseHandle(hStartedEvent);
    return(status);
}


NTSTATUS
RunStdProfile()
{
    NTSTATUS status;
    SYSTEM_CONTEXT_SWITCH_INFORMATION StartContext;
    SYSTEM_CONTEXT_SWITCH_INFORMATION StopContext;

    SetConsoleCtrlHandler(CtrlcH,TRUE);

    if (DelaySeconds != -1) {
        fprintf(stderr, "starting profile after %d seconds\n",DelaySeconds);
        WaitForSingleObject(DelayEvent, DelaySeconds*1000);
    }

    if (bDisplayContextSwitch) {
        NtQuerySystemInformation(SystemContextSwitchInformation,
                                 &StartContext,
                                 sizeof(StartContext),
                                 NULL);
    }

    status = StartProfile ();
    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "start profile failed status - %lx\n",status);
        return(status);
    }

    if ( Seconds == -1 ) {
        fprintf(stderr, "delaying until ^C\n");
    } else {
        fprintf(stderr, "delaying for %ld seconds... "
                        "report on values with %ld hits\n",
                        Seconds,
                        Threshold
                        );
    }

    if ( Seconds ) {
        if ( Seconds != -1 ) {
            Seconds = Seconds * 1000;
        }
        if ( DoneEvent ) {
            WaitForSingleObject(DoneEvent,Seconds);
        }
        else {
            Sleep(Seconds);
        }
    }
    else {
        getchar();
    }

    fprintf (stderr, "end of delay\n");

    status = StopProfile ();
    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "stop profile failed status - %lx\n",status);
        return(status);
    }

    SetConsoleCtrlHandler(CtrlcH,FALSE);

    if (bDisplayContextSwitch) {
        status = NtQuerySystemInformation(SystemContextSwitchInformation,
                                          &StopContext,
                                          sizeof(StopContext),
                                          NULL);
        if (!NT_SUCCESS(status)) {
            fprintf(stderr, "QuerySystemInformation for context switch information failed %08lx\n",status);
            bDisplayContextSwitch = FALSE;
        }
    }

    if (DelaySeconds != -1) {
        SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    }
    status = AnalyzeProfile (Threshold, &StartContext, &StopContext);

    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "analyze profile failed status - %lx\n",status);
    }

    return(status);
}


VOID
InitializeProfileSourceMapping (
    VOID
    )
{
#if defined(_X86_)
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       buffer[400];
    ULONG                       i, j, Count;
    PEVENTID                    Event;
    HANDLE                      DriverHandle;

    //
    // Open PStat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        fprintf(stderr, "ERROR - Failed OpenFile in InitializeProfileSourceMapping\n"); 
        return ;
    }

    //
    // Initialize possible counters
    //

    // determine how many events there are

    Event = (PEVENTID) buffer;
    Count = 0;
    do {
        *((PULONG) buffer) = Count;
        Count += 1;

        status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    PSTAT_QUERY_EVENTS,
                    buffer,                 // input buffer
                    sizeof (buffer),
                    NULL,                   // output buffer
                    0
                    );
    } while (NT_SUCCESS(status));

    ProfileSourceMapping = malloc(sizeof(*ProfileSourceMapping) * Count);
    Count -= 1;
    for (i=0, j=0; i < Count; i++) {
        *((PULONG) buffer) = i;
        NtDeviceIoControlFile(
           DriverHandle,
           (HANDLE) NULL,          // event
           (PIO_APC_ROUTINE) NULL,
           (PVOID) NULL,
           &IOSB,
           PSTAT_QUERY_EVENTS,
           buffer,                 // input buffer
           sizeof (buffer),
           NULL,                   // output buffer
           0
           );

        if (Event->ProfileSource > ProfileTime) {
            ProfileSourceMapping[j].Source      = Event->ProfileSource;
            ProfileSourceMapping[j].ShortName   = _strdup ((PCHAR)Event->Buffer);
            ProfileSourceMapping[j].Description = _strdup ((PCHAR)(Event->Buffer + Event->DescriptionOffset));
            j++;
        }
    }

    ProfileSourceMapping[j].Source      = (KPROFILE_SOURCE) 0;
    ProfileSourceMapping[j].ShortName   = NULL;
    ProfileSourceMapping[j].Description = NULL;

    NtClose (DriverHandle);
#endif
}


NTSTATUS
InitializeKernelProfile (
    VOID
    )

/*++

Routine Description:

    This routine initializes profiling for the kernel for the
    current process.

Arguments:

    None.

Return Value:

    Returns the status of the last NtCreateProfile.

--*/

{
    ULONG i;
    ULONG ModuleNumber;
    SIZE_T ViewSize;
    PULONG CodeStart;
    ULONG CodeLength;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    QUOTA_LIMITS QuotaLimits;
    PVOID Buffer;
    DWORD Cells;
    ULONG BucketSize;
    WCHAR StringBuf[500];
    PCHAR ModuleInfoBuffer;
    ULONG ModuleInfoBufferLength;
    ULONG ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    BOOLEAN PreviousProfilePrivState;
    BOOLEAN PreviousQuotaPrivState;
    CHAR ImageName[256];
    HANDLE hFile;
    HANDLE hMap;
    PVOID MappedBase;
    PIMAGE_NT_HEADERS NtHeaders;


    CurrentProcessHandle = NtCurrentProcess();

    //
    // Locate system drivers.
    //
    ModuleInfoBufferLength = 0;
    ModuleInfoBuffer = NULL;
    do {
        status = NtQuerySystemInformation (SystemModuleInformation,
                                           ModuleInfoBuffer,
                                           ModuleInfoBufferLength,
                                           &ReturnedLength);
        if (NT_SUCCESS (status)) {
            break;
        }

        if (ModuleInfoBuffer != NULL) {
            RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
            ModuleInfoBuffer = NULL;
        }

        if (status == STATUS_INFO_LENGTH_MISMATCH && ReturnedLength > ModuleInfoBufferLength) {
            ModuleInfoBufferLength = ReturnedLength;            
            ModuleInfoBuffer = RtlAllocateHeap (RtlProcessHeap(), 0, ModuleInfoBufferLength);
            if (ModuleInfoBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else if (!NT_SUCCESS(status)) {
            fprintf(stderr, "query system info failed status - %lx\n",status);
            return(status);
        }
    
    }while( !NT_SUCCESS(status) );

    status = RtlAdjustPrivilege(
                 SE_SYSTEM_PROFILE_PRIVILEGE,
                 TRUE,              //Enable
                 FALSE,             //not impersonating
                 &PreviousProfilePrivState
                 );

    if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
        fprintf(stderr, "Enable system profile privilege failed - status 0x%lx\n",
                        status);
    }

    status = RtlAdjustPrivilege(
                 SE_INCREASE_QUOTA_PRIVILEGE,
                 TRUE,              //Enable
                 FALSE,             //not impersonating
                 &PreviousQuotaPrivState
                 );

    if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
        fprintf(stderr, "Unable to increase quota privilege (status=0x%lx)\n",
                        status);
    }


    Modules = (PRTL_PROCESS_MODULES)ModuleInfoBuffer;
    if(Modules != NULL){
        Module = &Modules->Modules[ 0 ];
    }else{
	    fprintf(stderr, "InitializeKernelProfile: ModuleInfoBuffer is NULL\n");
	    return (STATUS_UNSUCCESSFUL);
	} 
    for (ModuleNumber=0; ModuleNumber < Modules->NumberOfModules; ModuleNumber++,Module++) {

#if DBG_PROFILE
        fprintf(stderr, "module base %p\n",Module->ImageBase);
        fprintf(stderr, "module full path name: %s (%u)\n",
                Module->FullPathName,
                Module->OffsetToFileName);
#endif

        if (SymLoadModule(
                SYM_HANDLE,
                NULL,
                (PSTR)&Module->FullPathName[Module->OffsetToFileName],
                NULL,
                (ULONG_PTR)Module->ImageBase,
                Module->ImageSize
                )) {
            ProfileObject[NumberOfProfileObjects].SymbolsLoaded = TRUE;
            if (Verbose) {
                fprintf(stderr, "Symbols loaded: %p  %s\n",
                    Module->ImageBase,
                    &Module->FullPathName[Module->OffsetToFileName]
                    );
            }
        } else {
            ProfileObject[NumberOfProfileObjects].SymbolsLoaded = FALSE;
            if (Verbose) {
                fprintf(stderr, "*** Could not load symbols: %p  %s\n",
                    Module->ImageBase,
                    &Module->FullPathName[Module->OffsetToFileName]
                    );
            }
        }

        hFile = FindExecutableImage(
            (PSTR)&Module->FullPathName[Module->OffsetToFileName],
            lpSymbolSearchPath,
            ImageName
            );

        if (!hFile) {
            fprintf(stderr,
                   "WARNING - Could not find executable image for %s\n",
                   &Module->FullPathName[Module->OffsetToFileName]
                   );
            continue;
        }

        hMap = CreateFileMapping(
            hFile,
            NULL,
            PAGE_READONLY,
            0,
            0,
            NULL
            );
        if (!hMap) {
            CloseHandle( hFile );
            fprintf(stderr,
                   "ERROR - Could not Create File Mapping for %s\n",
                   &Module->FullPathName[Module->OffsetToFileName]
                   );
            continue;
        }

        MappedBase = MapViewOfFile(
            hMap,
            FILE_MAP_READ,
            0,
            0,
            0
            );
        if (!MappedBase) {
            CloseHandle( hMap );
            CloseHandle( hFile );
            fprintf(stderr,
                   "ERROR - Could not Map View of File for %s\n",
                   &Module->FullPathName[Module->OffsetToFileName]
                   );
            continue;
        }

        NtHeaders = ImageNtHeader( MappedBase );

        CodeLength = NtHeaders->OptionalHeader.SizeOfImage;

        CodeStart = (PULONG)Module->ImageBase;

        UnmapViewOfFile( MappedBase );
        CloseHandle( hMap );
        CloseHandle( hFile );

        if (CodeLength > 1024*512) {

            //
            // Just create a 512K byte buffer.
            //

            ViewSize = 1024 * 512;

        } else {
            ViewSize = CodeLength + PAGE_SIZE;
        }

        ProfileObject[NumberOfProfileObjects].CodeStart = CodeStart;
        ProfileObject[NumberOfProfileObjects].CodeLength = CodeLength;
        ProfileObject[NumberOfProfileObjects].ImageBase = Module->ImageBase;
        ProfileObject[NumberOfProfileObjects].ModuleName = _strdup((PCHAR)&Module->FullPathName[Module->OffsetToFileName]);

        for (i=0; i<MaxProcessors; i++) {

            Buffer = NULL;

            status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&Buffer,
                                              0,
                                              &ViewSize,
                                              MEM_RESERVE | MEM_COMMIT,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(status)) {
                fprintf (stderr, "alloc VM failed %lx\n",status);
                RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
                return(status);
            }

            //
            // Calculate the bucket size for the profile.
            //

            Cells = (DWORD)((CodeLength / (ViewSize >> 2)) >> 2);
            BucketSize = 2;

            while (Cells != 0) {
                Cells = Cells >> 1;
                BucketSize += 1;
            }

            ProfileObject[NumberOfProfileObjects].Buffer[i] = Buffer;
            ProfileObject[NumberOfProfileObjects].BufferSize = 1 + (CodeLength >> (BucketSize - 2));
            ProfileObject[NumberOfProfileObjects].BucketSize = BucketSize;

            //
            // Increase the working set to lock down a bigger buffer.
            //

            status = NtQueryInformationProcess (CurrentProcessHandle,
                                                ProcessQuotaLimits,
                                                &QuotaLimits,
                                                sizeof(QUOTA_LIMITS),
                                                NULL );

            if (!NT_SUCCESS(status)) {
                fprintf (stderr, "query process info failed %lx\n",status);
                RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
                return(status);
            }

            QuotaLimits.MaximumWorkingSetSize += ViewSize;
            QuotaLimits.MinimumWorkingSetSize += ViewSize;

            status = NtSetInformationProcess (CurrentProcessHandle,
                                          ProcessQuotaLimits,
                                          &QuotaLimits,
                                          sizeof(QUOTA_LIMITS));

#if DBG_PROFILE
            fprintf(stderr, "code start %p len %p, bucksize %lx buffer %p bsize %08x %s ",
                ProfileObject[NumberOfProfileObjects].CodeStart,
                ProfileObject[NumberOfProfileObjects].CodeLength,
                ProfileObject[NumberOfProfileObjects].BucketSize,
                ProfileObject[NumberOfProfileObjects].Buffer ,
                ProfileObject[NumberOfProfileObjects].BufferSize,
                ProfileObject[NumberOfProfileObjects].ModuleName
                );
#endif

            if (bPerProcessor) {
                status = NtCreateProfile (
                            &ProfileObject[NumberOfProfileObjects].Handle[i],
                            0,
                            ProfileObject[NumberOfProfileObjects].CodeStart,
                            ProfileObject[NumberOfProfileObjects].CodeLength,
                            ProfileObject[NumberOfProfileObjects].BucketSize,
                            ProfileObject[NumberOfProfileObjects].Buffer[i] ,
                            ProfileObject[NumberOfProfileObjects].BufferSize,
                            ProfileSource,
                            1 << i);
            } else {
                status = NtCreateProfile (
                            &ProfileObject[NumberOfProfileObjects].Handle[i],
                            0,
                            ProfileObject[NumberOfProfileObjects].CodeStart,
                            ProfileObject[NumberOfProfileObjects].CodeLength,
                            ProfileObject[NumberOfProfileObjects].BucketSize,
                            ProfileObject[NumberOfProfileObjects].Buffer[i] ,
                            ProfileObject[NumberOfProfileObjects].BufferSize,
                            ProfileSource,
                            (KAFFINITY)-1);
            }
#if DBG_PROFILE
            fprintf(stderr, "Handle= 0x%x\n", ProfileObject[NumberOfProfileObjects].Handle[i] );
#endif
            if (status != STATUS_SUCCESS) {
                fprintf(stderr, "create kernel profile %s failed - status %lx\n",
                    ProfileObject[NumberOfProfileObjects].ModuleName, status);
            }

        }

        NumberOfProfileObjects += 1;
        if (NumberOfProfileObjects == MAX_PROFILE_COUNT) {
            RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
            return STATUS_SUCCESS;
        }
    }

    if (NumberOfProfileObjects < MAX_PROFILE_COUNT) {
        //
        // Add in usermode object
        //      0x00000000 -> SystemRangeStart
        //
        ULONG_PTR SystemRangeStart;
        ULONG UserModeBucketCount;

        status = NtQuerySystemInformation(SystemRangeStartInformation,
                                          &SystemRangeStart,
                                          sizeof(SystemRangeStart),
                                          NULL);
        //
        // How many buckets to cover the range
        //
        UserModeBucketCount = (ULONG)(1 + ((SystemRangeStart - 1) / MAX_BUCKET_SIZE));

        if (!NT_SUCCESS(status)) {
            RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
            fprintf(stderr,
                    "ERROR - Add User Mode Object - NtQuerySystemInformation failed - status %lx\n",
                    status
                    );
            return status;
        }

        ProfileObject[NumberOfProfileObjects].SymbolsLoaded = FALSE;
        ProfileObject[NumberOfProfileObjects].CodeStart = 0;
        ProfileObject[NumberOfProfileObjects].CodeLength = SystemRangeStart;

        ProfileObject[NumberOfProfileObjects].ImageBase = 0;
        ProfileObject[NumberOfProfileObjects].ModuleName = "User Mode";
        ProfileObject[NumberOfProfileObjects].BufferSize = UserModeBucketCount * sizeof(DWORD);
        ProfileObject[NumberOfProfileObjects].BucketSize = MAX_BUCKET_SHIFT;
        for (i=0; i<MaxProcessors; i++) {
            UserModeBuffer[i] = HeapAlloc(GetProcessHeap(),
                                         HEAP_ZERO_MEMORY,
                                         ProfileObject[NumberOfProfileObjects].BufferSize);

            if (UserModeBuffer[i] == NULL) {
                RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
                fprintf (stderr, "ERROR - Add User Mode Object - HeapAlloc failed\n");
                return(STATUS_NO_MEMORY);
            }

            ProfileObject[NumberOfProfileObjects].Buffer[i] = UserModeBuffer[i];
            ProfileObject[NumberOfProfileObjects].Handle[i] = NULL;
#if DBG_PROFILE
            fprintf(stderr, "code start %p len %lx, bucksize %lx buffer %p bsize %lx\n",
                ProfileObject[NumberOfProfileObjects].CodeStart,
                ProfileObject[NumberOfProfileObjects].CodeLength,
                ProfileObject[NumberOfProfileObjects].BucketSize,
                ProfileObject[NumberOfProfileObjects].Buffer ,
                ProfileObject[NumberOfProfileObjects].BufferSize);
#endif

            if (bPerProcessor) {
                status = NtCreateProfile (
                            &ProfileObject[NumberOfProfileObjects].Handle[i],
                            0,
                            ProfileObject[NumberOfProfileObjects].CodeStart,
                            ProfileObject[NumberOfProfileObjects].CodeLength,
                            ProfileObject[NumberOfProfileObjects].BucketSize,
                            ProfileObject[NumberOfProfileObjects].Buffer[i] ,
                            ProfileObject[NumberOfProfileObjects].BufferSize,
                            ProfileSource,
                            1 << i);
            } else {
                status = NtCreateProfile (
                            &ProfileObject[NumberOfProfileObjects].Handle[i],
                            0,
                            ProfileObject[NumberOfProfileObjects].CodeStart,
                            ProfileObject[NumberOfProfileObjects].CodeLength,
                            ProfileObject[NumberOfProfileObjects].BucketSize,
                            ProfileObject[NumberOfProfileObjects].Buffer[i] ,
                            ProfileObject[NumberOfProfileObjects].BufferSize,
                            ProfileSource,
                            (KAFFINITY)-1);
            }

            if (status != STATUS_SUCCESS) {
                fprintf(stderr, "ERROR - User Mode Object - NtCreateProfile %s failed - status %lx\n",
                    ProfileObject[NumberOfProfileObjects].ModuleName, status);
            }
        }
        NumberOfProfileObjects += 1;
    }

    RtlFreeHeap (RtlProcessHeap (), 0,  ModuleInfoBuffer);
    return status;
}


NTSTATUS
StartProfile (
    VOID
    )
/*++

Routine Description:

    This routine starts all profile objects which have been initialized.

Arguments:

    None.

Return Value:

    Returns the status of the last NtStartProfile.

--*/

{
    ULONG Object;
    ULONG Processor;
    NTSTATUS status = STATUS_SUCCESS;
    
    NtSetIntervalProfile(ProfileInterval, ProfileSource);

    if (bWaitForInput) {
            fprintf(stderr, "Hit return to continue.\n");
            (void) getchar();
    }

    for (Object = 0; Object < NumberOfProfileObjects; Object++) {

        for (Processor = 0;Processor < MaxProcessors; Processor++) {

            status = NtStartProfile (ProfileObject[Object].Handle[Processor]);

            if (!NT_SUCCESS(status)) {
               if (status == STATUS_INVALID_HANDLE) {
               
               	   fprintf(stderr, "StartProfile Failed, status= %lx (STATUS_INVALID_HANDLE)\n", status);

               }else{
              
                   fprintf(stderr, "start profile %s failed - status %lx\n",
                           ProfileObject[Object].ModuleName, status);
			   }
               return status;
            }
        }
    }
    return status;
}


NTSTATUS
StopProfile (
    VOID
    )

/*++

Routine Description:

    This routine stops all profile objects which have been initialized.

Arguments:

    None.

Return Value:

    Returns the status of the last NtStopProfile.

--*/

{
    ULONG i;
    ULONG Processor;
    NTSTATUS status = STATUS_SUCCESS;

    for (i = 0; i < NumberOfProfileObjects; i++) {
        for (Processor=0; Processor < MaxProcessors; Processor++) {
            status = NtStopProfile (ProfileObject[i].Handle[Processor]);
            if (status != STATUS_SUCCESS) {
                fprintf(stderr, "stop profile %s failed - status %lx\n",
                                    ProfileObject[i].ModuleName,status);
                return status;
            }
        }
    }
    return status;
}


NTSTATUS
AnalyzeProfile (
    ULONG Threshold,
    PSYSTEM_CONTEXT_SWITCH_INFORMATION StartContext,
    PSYSTEM_CONTEXT_SWITCH_INFORMATION StopContext
    )

/*++

Routine Description:

    This routine does the analysis of all the profile buffers and
    correlates hits to the appropriate symbol table.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG CountAtSymbol;
    ULONG_PTR Va;
    int i;
    PULONG Counter;
    ULONG_PTR Displacement;
    ULONG Processor;
    ULONG TotalHits = 0;
    ULONG ProcessorTotalHits[MAXIMUM_PROCESSORS] = {0};
    PULONG BufferEnd;
    PULONG Buffer;
    PULONG pInitialCounter;
    ULONG OffsetVa = 0;
    ULONG BytesPerBucket;
    BOOLEAN UseLastSymbol = FALSE;


    for (i = 0; i < (int)NumberOfProfileObjects; i++) {
        for (Processor=0;Processor < MaxProcessors;Processor++) {
            NtStopProfile (ProfileObject[i].Handle[Processor]);
        }
    }
    if ((NumberOfProfileObjects == 1) &&
        (strstr((char *)&ProfileObject[0].ModuleName, "User Mode"))){
       fprintf(stderr,
              "WARNING - Only User Mode Counts Are Found\n" \
              "Make Sure You Have the latest DBGHELP.DLL and IMAGEHLP.DLL Installed\n"
              );
    }  
    for (Processor = 0; Processor < MaxProcessors; Processor++) {
        for (i = 0; i < (int)NumberOfProfileObjects; i++) {
            //
            // Sum the total number of cells written.
            //
            BufferEnd = ProfileObject[i].Buffer[Processor] + (
                        ProfileObject[i].BufferSize / sizeof(ULONG));
            Buffer = ProfileObject[i].Buffer[Processor];
            Counter = BufferEnd;

            ProfileObject[i].ModuleHitCount[Processor] = 0;
            while (Counter > Buffer) {
                Counter -= 1;
                ProfileObject[i].ModuleHitCount[Processor] += *Counter;
            }

            ProcessorTotalHits[Processor] += ProfileObject[i].ModuleHitCount[Processor];
        }
        if (bPerProcessor) {
            fprintf(fpOut, "Processor %d: %d Total hits\n",
                            Processor, ProcessorTotalHits[Processor]);
        }
        TotalHits += ProcessorTotalHits[Processor];
    }
    fprintf(fpOut, "%d Total hits\n",TotalHits);

    for (Processor = 0; Processor < MaxProcessors; Processor++) {
        if (bPerProcessor) {
            fprintf(fpOut, "\nPROCESSOR %d\n",Processor);
        }
        for (i = 0; i < (int)NumberOfProfileObjects; i++) {
            CountAtSymbol = 0;
            //
            // Sum the total number of cells written.
            //
            BufferEnd = ProfileObject[i].Buffer[Processor] + (
                        ProfileObject[i].BufferSize / sizeof(ULONG));
            Buffer = ProfileObject[i].Buffer[Processor];
            Counter = BufferEnd;

            if (ProfileObject[i].ModuleHitCount[Processor] < Threshold) {
                continue;
            }
            fprintf(fpOut, "\n%9d ",
                            ProfileObject[i].ModuleHitCount[Processor]);
            if (bPrintPercentages) {
                fprintf(fpOut, "%5.2f ",
                            (ProfileObject[i].ModuleHitCount[Processor] /
                             (double)ProcessorTotalHits[Processor]) * 100);
            }
            fprintf(fpOut, "%20s --Total Hits-- %s\n",
                            ProfileObject[i].ModuleName,
                            ((ProfileObject[i].SymbolsLoaded) ? "" :
                                                                "(NO SYMBOLS)")
                            );

            if (!ProfileObject[i].SymbolsLoaded) {
                RtlZeroMemory(ProfileObject[i].Buffer[Processor],
                                ProfileObject[i].BufferSize);
                continue;
            }
            BytesPerBucket = (1 << ProfileObject[i].BucketSize);

            pInitialCounter = Buffer;
            for ( Counter = Buffer; Counter < BufferEnd; Counter += 1 ) {
                if ( *Counter ) {
                    //
                    // Calculate the virtual address of the counter
                    //
                    Va = Counter - Buffer;                  // Calculate buckets #
                    Va = Va * BytesPerBucket;               // convert to bytes
                    Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart; // add in base address

                    if (SymGetSymFromAddr( SYM_HANDLE, Va, &Displacement, ThisSymbol )) {
                        if (UseLastSymbol &&
                            LastSymbol->Address &&
                            (LastSymbol->Address == ThisSymbol->Address))
                        {
                            CountAtSymbol += *Counter;
                        } else {
                            OutputSymbolCount(CountAtSymbol,
                                              ProcessorTotalHits[Processor],
                                              &ProfileObject[i],
                                              LastSymbol,
                                              Threshold,
                                              pInitialCounter,
                                              Counter,
                                              OffsetVa,
                                              BytesPerBucket);
                            pInitialCounter = Counter;
                            OffsetVa = (DWORD) Displacement;    // Images aren't > 2g so this cast s/b O.K.
                            CountAtSymbol = *Counter;
                            memcpy( LastSymBuffer, symBuffer, sizeof(symBuffer) );
                            UseLastSymbol = TRUE;
                        }
                    } else {
                        OutputSymbolCount(CountAtSymbol,
                                          ProcessorTotalHits[Processor],
                                          &ProfileObject[i],
                                          LastSymbol,
                                          Threshold,
                                          pInitialCounter,
                                          Counter,
                                          OffsetVa,
                                          BytesPerBucket);
                    }       // else !(NT_SUCCESS)
                }       // if (*Counter)
            }      // for (Counter)

            OutputSymbolCount(CountAtSymbol,
                              ProcessorTotalHits[Processor],
                              &ProfileObject[i],
                              LastSymbol,
                              Threshold,
                              pInitialCounter,
                              Counter,
                              OffsetVa,
                              BytesPerBucket);
            //
            // Clear after buffer's been checked and displayed
            //
            RtlZeroMemory(ProfileObject[i].Buffer[Processor], ProfileObject[i].BufferSize);
        }
    }

    if (bDisplayContextSwitch) {
        fprintf(fpOut, "\n");
        fprintf(fpOut, "Context Switch Information\n");
        fprintf(fpOut, "    Find any processor        %6ld\n", StopContext->FindAny - StartContext->FindAny);
        fprintf(fpOut, "    Find last processor       %6ld\n", StopContext->FindLast - StartContext->FindLast);
        fprintf(fpOut, "    Idle any processor        %6ld\n", StopContext->IdleAny - StartContext->IdleAny);
        fprintf(fpOut, "    Idle current processor    %6ld\n", StopContext->IdleCurrent - StartContext->IdleCurrent);
        fprintf(fpOut, "    Idle last processor       %6ld\n", StopContext->IdleLast - StartContext->IdleLast);
        fprintf(fpOut, "    Preempt any processor     %6ld\n", StopContext->PreemptAny - StartContext->PreemptAny);
        fprintf(fpOut, "    Preempt current processor %6ld\n", StopContext->PreemptCurrent - StartContext->PreemptCurrent);
        fprintf(fpOut, "    Preempt last processor    %6ld\n", StopContext->PreemptLast - StartContext->PreemptLast);
        fprintf(fpOut, "    Switch to idle            %6ld\n", StopContext->SwitchToIdle - StartContext->SwitchToIdle);
        fprintf(fpOut, "\n");
        fprintf(fpOut, "    Total context switches    %6ld\n", StopContext->ContextSwitches - StartContext->ContextSwitches);
    }
    return STATUS_SUCCESS;
}


VOID
OutputSymbolCount(
    IN ULONG CountAtSymbol,
    IN ULONG TotalCount,
    IN PROFILE_BLOCK *ProfileObject,
    IN PIMAGEHLP_SYMBOL SymbolInfo,
    IN ULONG Threshold,
    IN PULONG CounterStart,
    IN PULONG CounterStop,
    IN ULONG Va,
    IN ULONG BytesPerBucket
    )
{
    ULONG Density;
    ULONG i;

    if (CountAtSymbol < Threshold) {
        return;
    }

    fprintf(fpOut, "%9d ", CountAtSymbol);

    if (bPrintPercentages) {
        fprintf(fpOut, "%5.2f ", (CountAtSymbol / (double) TotalCount) * 100);
    }

    if (bDisplayDensity) {
        //
        // Compute hit density = hits * 100 / function length
        //
        if (!SymbolInfo || !SymbolInfo->Size) {
            Density = 0;
        } else {
            Density = CountAtSymbol * 100 / SymbolInfo->Size;
        }
        fprintf(fpOut, "%5d ",Density);
    }

    if(SymbolInfo !=NULL){
        if (SymbolInfo->MaxNameLength) {
            fprintf(fpOut, "%20s %s",
                   ProfileObject->ModuleName,
                   SymbolInfo->Name);
        } else {
            fprintf(fpOut, "%20s 0x%x",
                   ProfileObject->ModuleName,
                   SymbolInfo->Address);
        }

        if (bDisplayAddress) {
            fprintf(fpOut, " 0x0%p %d %d",
                   (PVOID)SymbolInfo->Address,
                   SymbolInfo->Size,
                   ProfileObject->BucketSize);
        }
	}
    if (bDisplayCounters) {
        for (i = 0 ; CounterStart < CounterStop; i++, Va += BytesPerBucket, ++CounterStart) {
            if ((i % 16) == 0) {
                fprintf (fpOut, "\n0x%08x:", Va);
            }
            fprintf(fpOut, " %5d", *CounterStart);
        }
    }
    fprintf (fpOut, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kernrate\amd64.c ===
// 
// Note: The definitions in this file should be consistent with those 
// in halacpi\amd64\amd64.h
//

#define AMD64_PROFILE_MINIMUM  (ProfileMaximum + 1)

typedef enum _AMD64_PROFILE_LIST {
    ProfileAmd64Minimum         = AMD64_PROFILE_MINIMUM,
    ProfileFPDispatchedFPUOps   = AMD64_PROFILE_MINIMUM,
    ProfileFPDispatchedFPUOpsAddExcludeJunk, 
    ProfileFPDispatchedFPUOpsMulExcludeJunk,   
    ProfileFPDispatchedFPUOpsStoreExcludeJunk,   
    ProfileFPDispatchedFPUOpsAddJunk,
    ProfileFPDispatchedFPUOpsMulJunk,   
    ProfileFPDispatchedFPUOpsStoreJunk,   
    ProfileFPCyclesNoFPUOpsRetired,
    ProfileFPDispathedFPUOpsWithFastFlag,
    ProfileLSSegmentRegisterLoad,
    ProfileLSSegmentRegisterLoadES,
    ProfileLSSegmentRegisterLoadCS,
    ProfileLSSegmentRegisterLoadSS,
    ProfileLSSegmentRegisterLoadDS,
    ProfileLSSegmentRegisterLoadFS,
    ProfileLSSegmentRegisterLoadGS,
    ProfileLSSegmentRegisterLoadHS,
    ProfileLSResyncBySelfModifyingCode,
    ProfileLSResyncBySnoop,
    ProfileLSBuffer2Full,
    ProfileLSLockedOperation,
    ProfileLSLateCancelOperation,
    ProfileLSRetiredCFLUSH,
    ProfileLSRetiredCPUID,
    ProfileDCAccess,
    ProfileDCMiss,
    ProfileDCRefillFromL2,
    ProfileDCRefillFromL2Invalid,
    ProfileDCRefillFromL2Shared,
    ProfileDCRefillFromL2Exclusive,
    ProfileDCRefillFromL2Owner,
    ProfileDCRefillFromL2Modified,
    ProfileDCRefillFromSystem,
    ProfileDCRefillFromSystemInvalid,
    ProfileDCRefillFromSystemShared,
    ProfileDCRefillFromSystemExclusive,
    ProfileDCRefillFromSystemOwner,
    ProfileDCRefillFromSystemModified,
    ProfileDCRefillCopyBack,
    ProfileDCRefillCopyBackInvalid,
    ProfileDCRefillCopyBackShared,
    ProfileDCRefillCopyBackExclusive,
    ProfileDCRefillCopyBackOwner,
    ProfileDCRefillCopyBackModified,
    ProfileDCL1DTLBMissL2DTLBHit,
    ProfileDCL1DTLBMissL2DTLBMiss,
    ProfileDCMisalignedDataReference,
    ProfileDCLateCancelOfAnAccess,
    ProfileDCEarlyCancelOfAnAccess,
    ProfileDCOneBitECCError,
    ProfileDCOneBitECCErrorScrubberError,
    ProfileDCOneBitECCErrorPiggybackScrubberError,
    ProfileDCDispatchedPrefetchInstructions,
    ProfileDCDispatchedPrefetchInstructionsLoad,
    ProfileDCDispatchedPrefetchInstructionsStore,
    ProfileDCDispatchedPrefetchInstructionsNTA,
    ProfileBUInternalL2Request,
    ProfileBUInternalL2RequestICFill,
    ProfileBUInternalL2RequestDCFill,
    ProfileBUInternalL2RequestTLBReload,
    ProfileBUInternalL2RequestTagSnoopRequest,
    ProfileBUInternalL2RequestCancelledRequest,
    ProfileBUFillRequestMissedInL2,
    ProfileBUFillRequestMissedInL2ICFill,
    ProfileBUFillRequestMissedInL2DCFill,
    ProfileBUFillRequestMissedInL2TLBLoad,
    ProfileBUFillIntoL2,
    ProfileBUFillIntoL2DirtyL2Victim,
    ProfileBUFillIntoL2VictimFromL1,
    ProfileICFetch,
    ProfileICMiss,
    ProfileICRefillFromL2,
    ProfileICRefillFromSystem,
    ProfileICL1TLBMissL2TLBHit,
    ProfileICL1TLBMissL2TLBMiss,
    ProfileICResyncBySnoop,
    ProfileICInstructionFetchStall,
    ProfileICReturnStackHit,
    ProfileICReturnStackOverflow,
    ProfileFRRetiredx86Instructions,
    ProfileFRRetireduops,
    ProfileFRRetiredBranches,
    ProfileFRRetiredBranchesMispredicted,
    ProfileFRRetiredTakenBranches,
    ProfileFRRetiredTakenBranchesMispredicted,
    ProfileFRRetiredFarControlTransfers,
    ProfileFRRetiredResyncsNonControlTransferBranches,
    ProfileFRRetiredNearReturns,
    ProfileFRRetiredNearReturnsMispredicted,
    ProfileFRRetiredTakenBranchesMispredictedByAddressMiscompare,
    ProfileFRRetiredFPUInstructions,
    ProfileFRRetiredFPUInstructionsx87,
    ProfileFRRetiredFPUInstructionsMMXAnd3DNow,
    ProfileFRRetiredFPUInstructionsPackedSSEAndSSE2,
    ProfileFRRetiredFPUInstructionsScalarSSEAndSSE2,
    ProfileFRRetiredFastpathDoubleOpInstructions,
    ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition0,
    ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition1,
    ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition2,
    ProfileFRInterruptsMaskedCycles,
    ProfileFRInterruptsMaskedWhilePendingCycles,
    ProfileFRTakenHardwareInterrupts,
    ProfileFRNothingToDispatch,
    ProfileFRDispatchStalls,
    ProfileFRDispatchStallsFromBranchAbortToRetire,
    ProfileFRDispatchStallsForSerialization,
    ProfileFRDispatchStallsForSegmentLoad,
    ProfileFRDispatchStallsWhenReorderBufferFull,
    ProfileFRDispatchStallsWhenReservationStationsFull,
    ProfileFRDispatchStallsWhenFPUFull,
    ProfileFRDispatchStallsWhenLSFull,
    ProfileFRDispatchStallsWhenWaitingForAllQuiet,
    ProfileFRDispatchStallsWhenFarControlOrResyncBranchPending,
    ProfileFRFPUExceptions,
    ProfileFRFPUExceptionsx87ReclassMicroFaults,
    ProfileFRFPUExceptionsSSERetypeMicroFaults,
    ProfileFRFPUExceptionsSSEReclassMicroFaults,
    ProfileFRFPUExceptionsSSEAndx87MicroTraps,
    ProfileFRNumberOfBreakPointsForDR0,
    ProfileFRNumberOfBreakPointsForDR1,
    ProfileFRNumberOfBreakPointsForDR2,
    ProfileFRNumberOfBreakPointsForDR3,
    ProfileNBMemoryControllerPageAccessEvent,
    ProfileNBMemoryControllerPageAccessEventPageHit,
    ProfileNBMemoryControllerPageAccessEventPageMiss,
    ProfileNBMemoryControllerPageAccessEventPageConflict,
    ProfileNBMemoryControllerPageTableOverflow,
    ProfileNBMemoryControllerDRAMCommandSlotsMissed,
    ProfileNBMemoryControllerTurnAround,
    ProfileNBMemoryControllerTurnAroundDIMM,
    ProfileNBMemoryControllerTurnAroundReadToWrite,
    ProfileNBMemoryControllerTurnAroundWriteToRead,
    ProfileNBMemoryControllerBypassCounter,
    ProfileNBMemoryControllerBypassCounterHighPriority,
    ProfileNBMemoryControllerBypassCounterLowPriority,
    ProfileNBMemoryControllerBypassCounterDRAMControllerInterface,
    ProfileNBMemoryControllerBypassCounterDRAMControllerQueue,
    ProfileNBSizedCommands,
    ProfileNBSizedCommandsNonPostWrSzByte,
    ProfileNBSizedCommandsNonPostWrSzDword,
    ProfileNBSizedCommandsWrSzByte,
    ProfileNBSizedCommandsWrSzDword,
    ProfileNBSizedCommandsRdSzByte,
    ProfileNBSizedCommandsRdSzDword,
    ProfileNBSizedCommandsRdModWr,
    ProfileNBProbeResult,
    ProfileNBProbeResultMiss,
    ProfileNBProbeResultHit,
    ProfileNBProbeResultHitDirtyWithoutMemoryCancel,
    ProfileNBProbeResultHitDirtyWithMemoryCancel,
    ProfileNBHyperTransportBus0Bandwidth,
    ProfileNBHyperTransportBus0BandwidthCommandSent,
    ProfileNBHyperTransportBus0BandwidthDataSent,
    ProfileNBHyperTransportBus0BandwidthBufferReleaseSent,
    ProfileNBHyperTransportBus0BandwidthNopSent,
    ProfileNBHyperTransportBus1Bandwidth,
    ProfileNBHyperTransportBus1BandwidthCommandSent,
    ProfileNBHyperTransportBus1BandwidthDataSent,
    ProfileNBHyperTransportBus1BandwidthBufferReleaseSent,
    ProfileNBHyperTransportBus1BandwidthNopSent,
    ProfileNBHyperTransportBus2Bandwidth,
    ProfileNBHyperTransportBus2BandwidthCommandSent,
    ProfileNBHyperTransportBus2BandwidthDataSent,
    ProfileNBHyperTransportBus2BandwidthBufferReleaseSent,
    ProfileNBHyperTransportBus2BandwidthNopSent,
    ProfileAmd64Maximum
} AMD64_PROFILE_LIST;

SOURCE Amd64StaticSource[] = 
{ 
    { 
        "ProfileTime", 
        ProfileTime, 
        "ProfileTime", 
        0x10000, 
        0x10000, 
        FALSE 
    },
    { 
        "INVALID_1",
        (KPROFILE_SOURCE)-1,
        "INVALID_1",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "TotalIssues",
        ProfileTotalIssues, 
        "TotalIssues",
        0x10000, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_3",
        (KPROFILE_SOURCE)-1,
        "INVALID_3",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_4",
        (KPROFILE_SOURCE)-1,
        "INVALID_4",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_5",
        (KPROFILE_SOURCE)-1,
        "INVALID_5",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "BranchInstructions",
        ProfileBranchInstructions,  
        "BranchInstructions",
        0x10000, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_7",
        (KPROFILE_SOURCE)-1,
        "INVALID_7",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "DcacheMisses",
        ProfileDcacheMisses,        
        "DcacheMisses",
        0x10000, 
        0x0, 
        FALSE
    },
    { 
        "IcacheMisses",
        ProfileIcacheMisses,        
        "IcacheMisses",
        0x10000, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_10",
        (KPROFILE_SOURCE)-1,
        "INVALID_10",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "BranchMispredictions",
        ProfileBranchMispredictions, 
        "BranchMispredictions",
        0x10000, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_12",
        (KPROFILE_SOURCE)-1,
        "INVALID_12",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "FpInstructions",
        ProfileFpInstructions,       
        "FpInstructions",
        0x10000, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_14",
        (KPROFILE_SOURCE)-1,
        "INVALID_14",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_15",
        (KPROFILE_SOURCE)-1,
        "INVALID_15",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_16",
        (KPROFILE_SOURCE)-1,
        "INVALID_16",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_17",
        (KPROFILE_SOURCE)-1,
        "INVALID_17",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_18",
        (KPROFILE_SOURCE)-1,
        "INVALID_18",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_19",
        (KPROFILE_SOURCE)-1,
        "INVALID_19",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "IcacheIssues",
        ProfileIcacheIssues,            
        "IcacheIssues",
        0x10000, 
        0x0, 
        FALSE
    },
    { 
        "DcacheAccesses",
        ProfileDcacheAccesses,  
        "DcacheAccesses",
        0x10000, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_22",
        (KPROFILE_SOURCE)-1,
        "INVALID_22",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_23",
        (KPROFILE_SOURCE)-1,
        "INVALID_23",
        0x0, 
        0x0, 
        FALSE
    },
    { 
        "INVALID_24",
        (KPROFILE_SOURCE)-1,
        "INVALID_24",
        0x0, 
        0x0, 
        FALSE
    },

    //
    // End of generic profile source
    //

    { 
        "FPDispatchedFPUOps",
        ProfileFPDispatchedFPUOps, 
        "FPUOps",
        0x10000, 
        0x0, 
        FALSE
    },
    { 
        "FPDispatchedFPUOpsAddExcludeJunk",
        ProfileFPDispatchedFPUOpsAddExcludeJunk, 
        "FPUOpsAddNoJunk",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FPDispatchedFPUOpsMulExcludeJunk",
        ProfileFPDispatchedFPUOpsMulExcludeJunk,
        "FPUOpsMulNoJunk",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FPDispatchedFPUOpsStoreExcludeJunk",
        ProfileFPDispatchedFPUOpsStoreExcludeJunk,
        "FPUOpsStoreNoJunk",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FPDispatchedFPUOpsAddJunk",
        ProfileFPDispatchedFPUOpsAddJunk, 
        "FPUOpsAddJunk",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FPDispatchedFPUOpsMulJunk",
        ProfileFPDispatchedFPUOpsMulJunk,
        "FPUOpsMulJunk",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FPDispatchedFPUOpsStoreJunk",
        ProfileFPDispatchedFPUOpsStoreJunk,
        "FPUOpsStoreJunk",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FPCyclesNoFPUOpsRetired",
        ProfileFPCyclesNoFPUOpsRetired,
        "FPCyclesNoRetired",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FPDispathedFPUOpsWithFastFlag",
        ProfileFPDispathedFPUOpsWithFastFlag,
        "FPUOpsWithFastFlag",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSSegmentRegisterLoad",
        ProfileLSSegmentRegisterLoad,
        "LSSegLoad",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSSegmentRegisterLoadES",
        ProfileLSSegmentRegisterLoadES,
        "LSSegLoadES",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSSegmentRegisterLoadCS",
        ProfileLSSegmentRegisterLoadCS,
        "LSSegLoadCS",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSSegmentRegisterLoadSS",
        ProfileLSSegmentRegisterLoadSS,
        "LSSegLoadSS",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSSegmentRegisterLoadDS",
        ProfileLSSegmentRegisterLoadDS,
        "LSSegLoadDS",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSSegmentRegisterLoadFS",
        ProfileLSSegmentRegisterLoadFS,
        "LSSegLoadFS",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSSegmentRegisterLoadGS",
        ProfileLSSegmentRegisterLoadGS,
        "LSSegLoadGS",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSSegmentRegisterLoadHS",
        ProfileLSSegmentRegisterLoadHS,
        "LSSegLoadHS",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSResyncBySelfModifyingCode",
        ProfileLSResyncBySelfModifyingCode,
        "LSResyncBySelfModify",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSResyncBySnoop",
        ProfileLSResyncBySnoop,
        "LSResyncBySnoop",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSBuffer2Ful",
        ProfileLSBuffer2Full,
        "LSBuffer2Ful",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSLockedOperation",
        ProfileLSLockedOperation,
        "LSLockedOperation",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSLateCancelOperation",
        ProfileLSLateCancelOperation,
        "LSLateCancelOp",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSRetiredCFLUSH",
        ProfileLSRetiredCFLUSH,
        "LSRetiredCFLUSH",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "LSRetiredCPUID",
        ProfileLSRetiredCPUID,
        "LSRetiredCPUID",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCAccess",
        ProfileDCAccess,
        "DCAccess",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCMiss",
        ProfileDCMiss,
        "DCMiss",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromL2",
        ProfileDCRefillFromL2,
        "DCRefillL2",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromL2Invalid",
        ProfileDCRefillFromL2Invalid,
        "DCRefillL2Invalid",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromL2Shared",
        ProfileDCRefillFromL2Shared,
        "DCRefillL2Shared",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromL2Exclusive",
        ProfileDCRefillFromL2Exclusive,
        "DCRefillL2Exclusive",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromL2Owner",
        ProfileDCRefillFromL2Owner,
        "DCRefillL2Owner",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromL2Modified",
        ProfileDCRefillFromL2Modified,
        "DCRefillL2Modified",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromSystem",
        ProfileDCRefillFromSystem,
        "DCRefillSystem",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromSystemInvalid",
        ProfileDCRefillFromSystemInvalid,
        "DCRefillSystemInvalid",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromSystemShared",
        ProfileDCRefillFromSystemShared,
        "DCRefillSystemShared",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromSystemExclusive",
        ProfileDCRefillFromSystemExclusive,
        "DCRefillSystemExclusive",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromSystemOwner",
        ProfileDCRefillFromSystemOwner,
        "DCRefillSystemOwner",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillFromSystemModified",
        ProfileDCRefillFromSystemModified,
        "DCRefillSystemModified",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillCopyBack",
        ProfileDCRefillCopyBack,
        "DCRefillCB",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillCopyBackInvalid",
        ProfileDCRefillCopyBackInvalid,
        "DCRefillCBInvalid",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillCopyBackShared",
        ProfileDCRefillCopyBackShared,
        "DCRefillCBShared",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillCopyBackExclusive",
        ProfileDCRefillCopyBackExclusive,
        "DCRefillCBExclusive",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillCopyBackOwner",
        ProfileDCRefillCopyBackOwner,
        "DCRefillCBOwner",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCRefillCopyBackModified",
        ProfileDCRefillCopyBackModified,
        "DCRefillCBModified",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCL1DTLBMissL2DTLBHit",
        ProfileDCL1DTLBMissL2DTLBHit,
        "DCL1DTLBMissL2DTLBHit",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCL1DTLBMissL2DTLBMiss",
        ProfileDCL1DTLBMissL2DTLBMiss,
        "DCL1DTLBMissL2DTLBMiss",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCMisalignedDataReference",
        ProfileDCMisalignedDataReference,
        "DCMisaligned",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCLateCancelOfAnAccess",
        ProfileDCLateCancelOfAnAccess,
        "DCLateCancel",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCEarlyCancelOfAnAccess",
        ProfileDCEarlyCancelOfAnAccess,
        "DCEarlyCancel",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCOneBitECCError",
        ProfileDCOneBitECCError,
        "DCOneBitECC",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCOneBitECCErrorScrubberError",
        ProfileDCOneBitECCErrorScrubberError,
        "DCOneBitECCScrubber",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCOneBitECCErrorPiggybackScrubberError",
        ProfileDCOneBitECCErrorPiggybackScrubberError,
        "DCOneBitECCPbScrubber",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCDispatchedPrefetchInstructions",
        ProfileDCDispatchedPrefetchInstructions,
        "DCPrefetchInst",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCDispatchedPrefetchInstructionsLoad",
        ProfileDCDispatchedPrefetchInstructionsLoad,
        "DCPrefetchInstLoad",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCDispatchedPrefetchInstructionsStore",
        ProfileDCDispatchedPrefetchInstructionsStore,
        "DCPrefetchInstStore",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "DCDispatchedPrefetchInstructionsNTA",
        ProfileDCDispatchedPrefetchInstructionsNTA,
        "DCPrefetchInstNTA",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUInternalL2Request",
        ProfileBUInternalL2Request,
        "BUInternalL2Req",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUInternalL2RequestICFill",
        ProfileBUInternalL2RequestICFill,
        "BUL2ReqICFill",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUInternalL2RequestDCFill",
        ProfileBUInternalL2RequestDCFill,
        "BUL2ReqDCFill",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUInternalL2RequestTLBReload",
        ProfileBUInternalL2RequestTLBReload,
        "BUL2ReqTLBReload",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUInternalL2RequestTagSnoopRequest",
        ProfileBUInternalL2RequestTagSnoopRequest,
        "BUL2ReqTagSnoop",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUInternalL2RequestCancelledRequest",
        ProfileBUInternalL2RequestCancelledRequest,
        "BUL2ReqCancelled",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUFillRequestMissedInL2",
        ProfileBUFillRequestMissedInL2,
        "BUFFillMissedInL2",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUFillRequestMissedInL2ICFill",
        ProfileBUFillRequestMissedInL2ICFill,
        "BUFFillMissedInL2ICFill",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUFillRequestMissedInL2DCFil",
        ProfileBUFillRequestMissedInL2DCFill,
        "BUFFillMissedInL2DCFil",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUFillRequestMissedInL2TLBLoad",
        ProfileBUFillRequestMissedInL2TLBLoad,
        "BUFFillMissedInL2TLBLoad",
        0x10000, 
        0x0, 
        FALSE 
    },
    {
        "BUFillIntoL2",
        ProfileBUFillIntoL2,
        "BUFillL2",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUFillIntoL2DirtyL2Victim",
        ProfileBUFillIntoL2DirtyL2Victim,
        "BUFillL2DirtyL2Victim",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "BUFillIntoL2VictimFromL1",
        ProfileBUFillIntoL2VictimFromL1,
        "BUFillL2VictimFromL1",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICFetch",
        ProfileICFetch,
        "ICFetch",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICMiss",
        ProfileICMiss,
        "ICMiss",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICRefillFromL2",
        ProfileICRefillFromL2,
        "ICRefillFromL2",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICRefillFromSystem",
        ProfileICRefillFromSystem,
        "ICRefillFromSystem",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICL1TLBMissL2TLBHit",
        ProfileICL1TLBMissL2TLBHit,
        "ICL1TLBMissL2TLBHit",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICL1TLBMissL2TLBMiss",
        ProfileICL1TLBMissL2TLBMiss,
        "ICL1TLBMissL2TLBMiss",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICResyncBySnoop",
        ProfileICResyncBySnoop,
        "ICResyncBySnoop",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICInstructionFetchStal",
        ProfileICInstructionFetchStall,
        "ICInstFetchStal",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICReturnStackHit",
        ProfileICReturnStackHit,
        "ICRetStackHit",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "ICReturnStackOverflow",
        ProfileICReturnStackOverflow,
        "ICRetStackOverflow",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredx86Instructions",
        ProfileFRRetiredx86Instructions,
        "FRRetiredx86Inst",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetireduops",
        ProfileFRRetireduops,
        "FRRetireduops",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredBranches",
        ProfileFRRetiredBranches,
        "FRRetiredBranches",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredBranchesMispredicted",
        ProfileFRRetiredBranchesMispredicted,
        "FRRetiredBrMispred",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredTakenBranches",
        ProfileFRRetiredTakenBranches,
        "FRRetiredTakenBr",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredTakenBranchesMispredicted",
        ProfileFRRetiredTakenBranchesMispredicted,
        "FRRetiredTakenBrMispred",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFarControlTransfers",
        ProfileFRRetiredFarControlTransfers,
        "FRRetiredFarCtrl",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredResyncsNonControlTransferBranches",
        ProfileFRRetiredResyncsNonControlTransferBranches,
        "FRRetiredResyncs",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredNearReturns",
        ProfileFRRetiredNearReturns,
        "FRRetiredNearRet",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredNearReturnsMispredicted",
        ProfileFRRetiredNearReturnsMispredicted,
        "FRRetiredNearRetMispred",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredTakenBranchesMispredictedByAddressMiscompare",
        ProfileFRRetiredTakenBranchesMispredictedByAddressMiscompare,
        "FRRetiredTakenBrMispredByMiscomp",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFPUInstructions",
        ProfileFRRetiredFPUInstructions,
        "FRRetiredFPUInst",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFPUInstructionsx87",
        ProfileFRRetiredFPUInstructionsx87,
        "FRRetiredFPUInstx87",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFPUInstructionsMMXAnd3DNow",
        ProfileFRRetiredFPUInstructionsMMXAnd3DNow,
        "FRRetiredFPUInstMMX3DNow",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFPUInstructionsPackedSSEAndSSE2",
        ProfileFRRetiredFPUInstructionsPackedSSEAndSSE2,
        "FRRetiredFPUInstPackedSSE",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFPUInstructionsScalarSSEAndSSE2",
        ProfileFRRetiredFPUInstructionsScalarSSEAndSSE2,
        "FRRetiredFPUInstScalarSSE",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFastpathDoubleOpInstructions",
        ProfileFRRetiredFastpathDoubleOpInstructions,
        "FRRetiredDblOp",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFastpathDoubleOpInstructionsLowOpInPosition0",
        ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition0,
        "FRRetiredDblOpLowOpAt0",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFastpathDoubleOpInstructionsLowOpInPosition1",
        ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition1,
        "FRRetiredDblOpLowOpAt1",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRRetiredFastpathDoubleOpInstructionsLowOpInPosition2",
        ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition2,
        "FRRetiredDblOpLowOpAt2",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRInterruptsMaskedCycles",
        ProfileFRInterruptsMaskedCycles,
        "FRIntMasked",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRInterruptsMaskedWhilePendingCycles",
        ProfileFRInterruptsMaskedWhilePendingCycles,
        "FRIntMaskedWhilePending",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRTakenHardwareInterrupts",
        ProfileFRTakenHardwareInterrupts,
        "FRTakenHwInt",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRNothingToDispatch",
        ProfileFRNothingToDispatch,
        "FRNothingToDispatch",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStalls",
        ProfileFRDispatchStalls,
        "FRStallAll",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStallsFromBranchAbortToRetire",
        ProfileFRDispatchStallsFromBranchAbortToRetire,
        "FRStallsBrAbortToRetire",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStallsForSerialization",
        ProfileFRDispatchStallsForSerialization,
        "FRStallsForSerial",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStallsForSegmentLoad",
        ProfileFRDispatchStallsForSegmentLoad,
        "FRStallsForSegLoad",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStallsWhenReorderBufferFull",
        ProfileFRDispatchStallsWhenReorderBufferFull,
        "FRStallsWhenBufferFull",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStallsWhenReservationStationsFull",
        ProfileFRDispatchStallsWhenReservationStationsFull,
        "FRStallsWhenRSFull",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStallsWhenFPUFull",
        ProfileFRDispatchStallsWhenFPUFull,
        "FRStallsWhenFPUFull",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStallsWhenLSFull",
        ProfileFRDispatchStallsWhenLSFull,
        "FRStallsLSFull",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStallsWhenWaitingForAllQuiet",
        ProfileFRDispatchStallsWhenWaitingForAllQuiet,
        "FRStallsWhenWaitForQuiet",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRDispatchStallsWhenFarControlOrResyncBranchPending",
        ProfileFRDispatchStallsWhenFarControlOrResyncBranchPending,
        "FRStallsWhenFCOrRBPending",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRFPUExceptions",
        ProfileFRFPUExceptions,
        "FRFPUExp",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRFPUExceptionsx87ReclassMicroFaults",
        ProfileFRFPUExceptionsx87ReclassMicroFaults,
        "FRFPUExpx87Reclass",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRFPUExceptionsSSERetypeMicroFaults",
        ProfileFRFPUExceptionsSSERetypeMicroFaults,
        "FRFPUExpSSERetype",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRFPUExceptionsSSEReclassMicroFaults",
        ProfileFRFPUExceptionsSSEReclassMicroFaults,
        "FRFPUExpSSEReclass",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRFPUExceptionsSSEAndx87MicroTraps",
        ProfileFRFPUExceptionsSSEAndx87MicroTraps,
        "FRFPUExpSSEAndx87",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRNumberOfBreakPointsForDR0",
        ProfileFRNumberOfBreakPointsForDR0,
        "FRBPsForDR0",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRNumberOfBreakPointsForDR1",
        ProfileFRNumberOfBreakPointsForDR1,
        "FRBPsForDR1",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRNumberOfBreakPointsForDR2",
        ProfileFRNumberOfBreakPointsForDR2,
        "FRBPsForDR2",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "FRNumberOfBreakPointsForDR3",
        ProfileFRNumberOfBreakPointsForDR3,
        "FRBPsForDR3",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerPageAccessEvent",
        ProfileNBMemoryControllerPageAccessEvent,
        "NBPageAccess",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerPageAccessEventPageHit",
        ProfileNBMemoryControllerPageAccessEventPageHit,
        "NBPageAccessHit",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerPageAccessEventPageMiss",
        ProfileNBMemoryControllerPageAccessEventPageMiss,
        "NBPageAccessMiss",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerPageAccessEventPageConflict",
        ProfileNBMemoryControllerPageAccessEventPageConflict,
        "NBPageAccessConflict",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerPageTableOverflow",
        ProfileNBMemoryControllerPageTableOverflow,
        "NBPageTableOverflow",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerDRAMCommandSlotsMissed",
        ProfileNBMemoryControllerDRAMCommandSlotsMissed,
        "NBDRAMCmdSlotsMissed",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerTurnAround",
        ProfileNBMemoryControllerTurnAround,
        "NBTurnAround",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerTurnAroundDIMM",
        ProfileNBMemoryControllerTurnAroundDIMM,
        "NBTurnAroundDIMM",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerTurnAroundReadToWrite",
        ProfileNBMemoryControllerTurnAroundReadToWrite,
        "NBTurnAroundRToW",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerTurnAroundWriteToRead",
        ProfileNBMemoryControllerTurnAroundWriteToRead,
        "NBTurnAroundWToR",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerBypassCounter",
        ProfileNBMemoryControllerBypassCounter,
        "NBBypassCounter",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerBypassCounterHighPriority",
        ProfileNBMemoryControllerBypassCounterHighPriority,
        "NBBypassHighPri",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerBypassCounterLowPriority",
        ProfileNBMemoryControllerBypassCounterLowPriority,
        "NBBypassLowPri",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerBypassCounterDRAMControllerInterface",
        ProfileNBMemoryControllerBypassCounterDRAMControllerInterface,
        "NBBypassDRAMInterface",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBMemoryControllerBypassCounterDRAMControllerQueue",
        ProfileNBMemoryControllerBypassCounterDRAMControllerQueue,
        "NBBypassDRAMQueue",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBSizedCommands",
        ProfileNBSizedCommands,
        "NBSizedCmd",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBSizedCommandsNonPostWrSzByte",
        ProfileNBSizedCommandsNonPostWrSzByte,
        "NBSizedCmdNonPostWrSzByte",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBSizedCommandsNonPostWrSzDword",
        ProfileNBSizedCommandsNonPostWrSzDword,
        "NBSizedCmdNonPostWrSzDw",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBSizedCommandsWrSzByte",
        ProfileNBSizedCommandsWrSzByte,
        "NBSizedCmdWrSzByte",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBSizedCommandsWrSzDword",
        ProfileNBSizedCommandsWrSzDword,
        "NBSizedCmdWrSzDw",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBSizedCommandsRdSzByte",
        ProfileNBSizedCommandsRdSzByte,
        "NBSizedCmdRdSzByte",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBSizedCommandsRdSzDword",
        ProfileNBSizedCommandsRdSzDword,
        "NBSizedCmdRdSzDw",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBSizedCommandsRdModWr",
        ProfileNBSizedCommandsRdModWr,
        "NBSizedCmdRdModWr",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBProbeResult",
        ProfileNBProbeResult,
        "NBProbe",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBProbeResultMiss",
        ProfileNBProbeResultMiss,
        "NBProbeMiss",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBProbeResultHit",
        ProfileNBProbeResultHit,
        "NBProbeHit",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBProbeResultHitDirtyWithoutMemoryCancel",
        ProfileNBProbeResultHitDirtyWithoutMemoryCancel,
        "NBProbeHitDirtyWithoutCancel",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBProbeResultHitDirtyWithMemoryCancel",
        ProfileNBProbeResultHitDirtyWithMemoryCancel,
        "NBProbeHitDirtyWithCancel",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus0Bandwidth",
        ProfileNBHyperTransportBus0Bandwidth,
        "NBHTBus0Bw",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus0BandwidthCommandSent",
        ProfileNBHyperTransportBus0BandwidthCommandSent,
        "NBBus0BwCmdSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus0BandwidthDataSent",
        ProfileNBHyperTransportBus0BandwidthDataSent,
        "NBBus0BwDataSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus0BandwidthBufferReleaseSent",
        ProfileNBHyperTransportBus0BandwidthBufferReleaseSent,
        "NBBus0BwBufRelSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus0BandwidthNopSent",
        ProfileNBHyperTransportBus0BandwidthNopSent,
        "NBBus0BwNopSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus1Bandwidth",
        ProfileNBHyperTransportBus1Bandwidth,
        "NBBus1Bw",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus1BandwidthCommandSent",
        ProfileNBHyperTransportBus1BandwidthCommandSent,
        "NBBus1BwCmdSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus1BandwidthDataSent",
        ProfileNBHyperTransportBus1BandwidthDataSent,
        "NBBus1BwDataSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus1BandwidthBufferReleaseSent",
        ProfileNBHyperTransportBus1BandwidthBufferReleaseSent,
        "NBBus1BwBufRelSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus1BandwidthNopSent",
        ProfileNBHyperTransportBus1BandwidthNopSent,
        "NBBus1BwNopSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus2Bandwidth",
        ProfileNBHyperTransportBus2Bandwidth,
        "NBBus2Bw",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus2BandwidthCommandSent",
        ProfileNBHyperTransportBus2BandwidthCommandSent,
        "NBBus2BwCmdSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus2BandwidthDataSent",
        ProfileNBHyperTransportBus2BandwidthDataSent,
        "NBBus2BwDataSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus2BandwidthBufferReleaseSent",
        ProfileNBHyperTransportBus2BandwidthBufferReleaseSent,
        "NBBus2BwBufRelSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        "NBHyperTransportBus2BandwidthNopSent",
        ProfileNBHyperTransportBus2BandwidthNopSent,
        "NBBus2BwNopSent",
        0x10000, 
        0x0, 
        FALSE 
    },
    { 
        NULL, 
        (KPROFILE_SOURCE)-1, 
        "", 
        0, 
        0, 
        FALSE 
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kdexts2\wdmaud.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wdmaud.c

Abstract:

    WinDbg Extension Api

Author:

    Noel Cross (NoelC) 18-Sept-1998

Environment:

    Kernel Mode.

Revision History:

--*/


#include "precomp.h"
#define UNDER_NT
#define WDMA_KD
// #include "..\..\ntos\dd\wdm\audio\legacy\wdmaud.sys\wdmsys.h"

typedef union _WDMAUD_FLAGS {
    struct {
        ULONG   Ioctls              : 1;
        ULONG   PendingIrps         : 1;
        ULONG   AllocatedMdls       : 1;
        ULONG   pContextList        : 1;
        ULONG   Reserved1           : 4;
        ULONG   Verbose             : 1;
        ULONG   Reserved            : 23;
    };
    ULONG Flags;
} WDMAUD_FLAGS;

/**********************************************************************
 * Forward References
 **********************************************************************
 */
VOID
PrintCommand (
    ULONG           IoCode
    );

VOID
DumpIoctlLog (
    ULONG64         memLoc,
    ULONG           flags
    );

VOID
DumpPendingIrps (
    ULONG64         memLoc,
    ULONG           flags
    );

VOID
DumpAllocatedMdls (
    ULONG64         memLoc,
    ULONG           flags
    );

VOID
DumpContextList (
    ULONG64         memLoc,
    ULONG           flags
    );


DECLARE_API( wdmaud )
/*++

Routine Description:

    Entry point for the kernel debugger extensions for wdmaud

Arguments:

    flags - 1 - Ioctl History Dump
            2 - Pending Irps
            4 - Allocated Mdls
            8 - pContext Dump
            100 - Verbose

Return Value:

    None.

--*/
{
    ULONG64         memLoc=0;
    CHAR            buffer[256];
    WDMAUD_FLAGS    flags;

    buffer[0] = '\0';
    flags.Flags = 0;

    //
    // get the arguments
    //
    if (!*args)
    {
        memLoc = EXPRLastDump;
    }
    else
    {
        if (GetExpressionEx( args, &memLoc, &args)) {
            StringCchCopy(buffer, sizeof(buffer), args );
        }
    }

    if( '\0' != buffer[0] )
    {
        flags.Flags = (ULONG) GetExpression( buffer );
    }

    if (memLoc)
    {
        if (flags.Ioctls)
        {
            //
            //  dump wdmaud's history of ioctls
            //
            DumpIoctlLog ( memLoc, flags.Flags );
        }
        else if (flags.PendingIrps)
        {
            //
            //  dump any pending irps that wdmaud hasn't completed yet
            //
            DumpPendingIrps ( memLoc, flags.Flags );
        }
        else if (flags.AllocatedMdls)
        {
            //
            //  dump all Mdls which have been allocated by wdmaud
            //
            DumpAllocatedMdls ( memLoc, flags.Flags );
        }
        else if (flags.pContextList)
        {
            //
            //  dump the list of all registered pContexts
            //
            DumpContextList ( memLoc, flags.Flags );
        }
        else
        {
            dprintf("\nNo valid flags\n");
            dprintf("SYNTAX:  !wdmaud <address> <flags>\n");
        }
    }
    else
    {
        dprintf("\nInvalid memory location\n");
        dprintf("SYNTAX:  !wdmaud <address> <flags>\n");
    }

    return S_OK;
}

VOID
PrintCommand(
    ULONG   IoCode
    )
/*++

Routine Description:

    Prints out individual ioctls

Arguments:

    pCommand - Ioctl to log

Return Value:

    None.

--*/
{
    switch( IoCode )
    {
        case IRP_MJ_CREATE:
            dprintf("IRP_MJ_CREATE");
            break;
        case IRP_MJ_CLOSE:
            dprintf("IRP_MJ_CLOSE");
            break;
        case IOCTL_WDMAUD_INIT:
            dprintf("IOCTL_WDMAUD_INIT");
            break;
        case IOCTL_WDMAUD_EXIT:
            dprintf("IOCTL_WDMAUD_EXIT");
            break;
        case IOCTL_WDMAUD_ADD_DEVNODE:
            dprintf("IOCTL_WDMAUD_ADD_DEVNODE");
            break;
        case IOCTL_WDMAUD_REMOVE_DEVNODE:
            dprintf("IOCTL_WDMAUD_REMOVE_DEVNODE");
            break;
        case IOCTL_WDMAUD_GET_CAPABILITIES:
            dprintf("IOCTL_WDMAUD_GET_CAPABILITIES");
            break;
        case IOCTL_WDMAUD_GET_NUM_DEVS:
            dprintf("IOCTL_WDMAUD_GET_NUM_DEVS");
            break;
        case IOCTL_WDMAUD_OPEN_PIN:
            dprintf("IOCTL_WDMAUD_OPEN_PIN");
            break;
        case IOCTL_WDMAUD_CLOSE_PIN:
            dprintf("IOCTL_WDMAUD_CLOSE_PIN");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_PAUSE:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_PAUSE");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_PLAY:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_PLAY");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_RESET:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_RESET");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_BREAKLOOP");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_GET_POS:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_GET_POS");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_SET_VOLUME");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_GET_VOLUME");
            break;
        case IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN:
            dprintf("IOCTL_WDMAUD_WAVE_OUT_WRITE_PIN");
            break;
        case IOCTL_WDMAUD_WAVE_IN_STOP:
            dprintf("IOCTL_WDMAUD_WAVE_IN_STOP");
            break;
        case IOCTL_WDMAUD_WAVE_IN_RECORD:
            dprintf("IOCTL_WDMAUD_WAVE_IN_RECORD");
            break;
        case IOCTL_WDMAUD_WAVE_IN_RESET:
            dprintf("IOCTL_WDMAUD_WAVE_IN_RESET");
            break;
        case IOCTL_WDMAUD_WAVE_IN_GET_POS:
            dprintf("IOCTL_WDMAUD_WAVE_IN_GET_POS");
            break;
        case IOCTL_WDMAUD_WAVE_IN_READ_PIN:
            dprintf("IOCTL_WDMAUD_WAVE_IN_READ_PIN");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_RESET:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_RESET");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_SET_VOLUME");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_GET_VOLUME");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_WRITE_DATA");
            break;
        case IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA:
            dprintf("IOCTL_WDMAUD_MIDI_OUT_WRITE_LONGDATA");
            break;
        case IOCTL_WDMAUD_MIDI_IN_STOP:
            dprintf("IOCTL_WDMAUD_MIDI_IN_STOP");
            break;
        case IOCTL_WDMAUD_MIDI_IN_RECORD:
            dprintf("IOCTL_WDMAUD_MIDI_IN_RECORD");
            break;
        case IOCTL_WDMAUD_MIDI_IN_RESET:
            dprintf("IOCTL_WDMAUD_MIDI_IN_RESET");
            break;
        case IOCTL_WDMAUD_MIDI_IN_READ_PIN:
            dprintf("IOCTL_WDMAUD_MIDI_IN_READ_PIN");
            break;
        case IOCTL_WDMAUD_MIXER_OPEN:
            dprintf("IOCTL_WDMAUD_MIXER_OPEN");
            break;
        case IOCTL_WDMAUD_MIXER_CLOSE:
            dprintf("IOCTL_WDMAUD_MIXER_CLOSE");
            break;
        case IOCTL_WDMAUD_MIXER_GETLINEINFO:
            dprintf("IOCTL_WDMAUD_MIXER_GETLINEINFO");
            break;
        case IOCTL_WDMAUD_MIXER_GETLINECONTROLS:
            dprintf("IOCTL_WDMAUD_MIXER_GETLINECONTROLS");
            break;
        case IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS:
            dprintf("IOCTL_WDMAUD_MIXER_GETCONTROLDETAILS");
            break;
        case IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS:
            dprintf("IOCTL_WDMAUD_MIXER_SETCONTROLDETAILS");
            break;
        default:
            dprintf("UNKNOWN command %X", IoCode );
            break;
    }
}

VOID
DumpIoctlLog (
    ULONG64     memLoc,
    ULONG       flags
    )
/*++

Routine Description:

    This routine dumps out a list of Ioctls that have been sent down
    to wdmaud.sys.  In debugging it is useful to see the context and
    request being made to wdmaud.sys to track down coding errors.

Arguments:

    Flags - Verbose turns prints the pContext that the Ioctl was sent
            down with.

Return Value:

    None

--*/
{
    LIST_ENTRY                  List;
    ULONG64                     ple;
    ULONG64                     pIoctlHistoryListItem;
  //  IOCTL_HISTORY_LIST_ITEM     IoctlHistoryBuffer;
    ULONG                       Result;
    WDMAUD_FLAGS                Flags;
    ULONG                       IoCode, IoStatus;
    ULONG NextOffset;
    FIELD_INFO offField = {"Next", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "tag_IOCTL_HISTORY_LIST_ITEM", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Next in tag_IOCTL_HISTORY_LIST_ITEM
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return ;
    }
    
    NextOffset = (ULONG) offField.address;

    Flags.Flags = flags;

    if (GetFieldValue(memLoc, "LIST_ENTRY", "Flink", ple))
    {
        dprintf("Unable to get value of WdmaIoctlHistoryListHead\n");
        return;
    }

    dprintf("Command history, newest first:\n");

//  ple = List.Flink;
    if (ple == 0)
    {
        dprintf("WdmaIoctlHistoryListHead is NULL!\n");
        return;
    }

    while (ple != memLoc)
    {
        ULONG64 pContext, pIrp;

        if (CheckControlC())
        {
            return;
        }

        pIoctlHistoryListItem = ple - NextOffset;
        if (GetFieldValue(pIoctlHistoryListItem,
                           "tag_IOCTL_HISTORY_LIST_ITEM",
                           "IoCode",
                           IoCode))
        {
            dprintf("Unable to read IOCTL_HISTORY_LIST_ITEM at %08p",pIoctlHistoryListItem);
            return;
        }

        PrintCommand ( IoCode );
        GetFieldValue(pIoctlHistoryListItem,"tag_IOCTL_HISTORY_LIST_ITEM","IoStatus",IoStatus);

        dprintf(" Status=%08X, ", IoStatus );

        if ( Flags.Verbose )
        {
            GetFieldValue(pIoctlHistoryListItem,"tag_IOCTL_HISTORY_LIST_ITEM","pContext",pContext);
            GetFieldValue(pIoctlHistoryListItem,"tag_IOCTL_HISTORY_LIST_ITEM","pIrp",pIrp);
            
            dprintf(" pContext=%08X, Irp=%08X\n", pContext, pIrp );
        }
        else
        {
            dprintf("\n");
        }

        GetFieldValue(pIoctlHistoryListItem,"tag_IOCTL_HISTORY_LIST_ITEM", "Next.Flink", ple);
    }
}

VOID
DumpPendingIrps (
    ULONG64     memLoc,
    ULONG       flags
    )
/*++

Routine Description:

    This routine dumps out a list of Irps that WDMAUD has marked
    pending.  WDMAUD needs to make sure that all Irps have completed
    for a context before allowing the context to be closed.

Arguments:

    Flags - Verbose mode will print out the context on which this
            Irp was allocated.

Return Value:

    None

--*/
{
    LIST_ENTRY              List;
    ULONG64                 ple;
    ULONG64                 pPendingIrpListItem;
//    PENDING_IRP_LIST_ITEM   PendingIrpBuffer;
    ULONG                   Result;
    WDMAUD_FLAGS            Flags;
    ULONG NextOffset;
    FIELD_INFO offField = {"Next", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "tag_PENDING_IRP_LIST_ITEM", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Next in tag_IOCTL_HISTORY_LIST_ITEM
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return ;
    }
    
    NextOffset = (ULONG) offField.address;

    Flags.Flags = flags;

    if (GetFieldValue(memLoc, "LIST_ENTRY", "Flink", ple))
    {
        dprintf("Unable to get value of WdmaPendingIrpListHead\n");
        return;
    }


    dprintf("Dumping pending irps:\n");

//    ple = List.Flink;
    if (ple == 0)
    {
        dprintf("WdmaPendingIrpListHead is NULL!\n");
        return;
    }

    while (ple != memLoc)
    {
        ULONG64 pIrp, pContext;
        ULONG IrpDeviceType;

        if (CheckControlC())
        {
            return;
        }

        pPendingIrpListItem = ple - NextOffset;

        if (GetFieldValue(pPendingIrpListItem,
                          "tag_PENDING_IRP_LIST_ITEM",
                           "IrpDeviceType",
                           IrpDeviceType))
        {
            dprintf("Unable to read PENDING_IRP_LIST_ITEM at %08p",pPendingIrpListItem);
            return;
        }

        GetFieldValue(pPendingIrpListItem,"tag_PENDING_IRP_LIST_ITEM","pIrp",pIrp);
        if ( Flags.Verbose )
        {
            GetFieldValue(pPendingIrpListItem,
                          "tag_PENDING_IRP_LIST_ITEM",
                          "pContext",
                          pContext);
            
            dprintf("Irp: %p, ", pIrp);
            switch (IrpDeviceType)
            {
                case WaveOutDevice:
                    dprintf("IrpType: WaveOut, ");
                    break;

                case WaveInDevice:
                    dprintf("IrpType: WaveIn, ");
                    break;

                case MidiOutDevice:
                    dprintf("IrpType: MidiOut, ");
                    break;

                case MidiInDevice:
                    dprintf("IrpType: MidiIn, ");
                    break;

                case MixerDevice:
                    dprintf("IrpType: Mixer, ");
                    break;

                case AuxDevice:
                    dprintf("IrpType: Aux, ");
                    break;

                default:
                    dprintf("IrpType: Unknown, ");
                    break;
            }
            dprintf("pContext: %p\n", pContext);
        }
        else
        {
            dprintf("Irp: %p\n", pIrp);
        }

        GetFieldValue(pPendingIrpListItem,"tag_PENDING_IRP_LIST_ITEM","Next.Flink", ple);
    }

}

VOID
DumpAllocatedMdls (
    ULONG64     memLoc,
    ULONG       flags
    )
/*++

Routine Description:

    This routine dumps out a list of MDLs that WDMAUD has allocated.
    WDMAUD needs to make sure that all MDLs have freed for a context
    before allowing the context to be closed.

Arguments:

    Flags - Verbose mode will print out the context on which this
            Mdl was allocated.

Return Value:

    None

--*/
{
    LIST_ENTRY                  List;
    ULONG64                     ple;
    ULONG64                     pAllocatedMdlListItem;
//    ALLOCATED_MDL_LIST_ITEM     AllocatedMdlBuffer;
    ULONG                       Result;
    WDMAUD_FLAGS                Flags;
    ULONG NextOffset;
    FIELD_INFO offField = {"Next", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "ALLOCATED_MDL_LIST_ITEM", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Next in tag_IOCTL_HISTORY_LIST_ITEM
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return ;
    }
    
    NextOffset = (ULONG) offField.address;

    Flags.Flags = flags;

    if (GetFieldValue(memLoc, "LIST_ENTRY", "Flink", ple))
    {
        dprintf("Unable to get value of WdmaPendingIrpListHead\n");
        return;
    }


    dprintf("Dumping allocated Mdls:\n");

//    ple = List.Flink;
    if (ple == 0)
    {
        dprintf("WdmaPendingIrpListHead is NULL!\n");
        return;
    }

    while (ple != memLoc)
    {
        ULONG64 pMdl, pContext;
        ULONG IrpDeviceType;

        if (CheckControlC())
        {
            return;
        }

        pAllocatedMdlListItem = ple - NextOffset;

        if (GetFieldValue(pAllocatedMdlListItem,
                          "ALLOCATED_MDL_LIST_ITEM",
                           "pMdl",
                           pMdl))
        {
            dprintf("Unable to read ALLOCATED_MDL_LIST_ITEM at %08p",pAllocatedMdlListItem);
            return;
        }

        if ( Flags.Verbose )
        {
            GetFieldValue(pAllocatedMdlListItem,"ALLOCATED_MDL_LIST_ITEM","pContext",pContext);
            dprintf("Mdl: %p, pContext: %p\n", pMdl,
                                               pContext);
        }
        else
        {
            dprintf("Mdl: %p\n", pMdl);
        }

        GetFieldValue(pAllocatedMdlListItem,"ALLOCATED_MDL_LIST_ITEM","Next.Flink", ple);
    }

}

VOID
DumpContextList (
    ULONG64     memLoc,
    ULONG       flags
    )
/*++

Routine Description:

    This routine dumps out a list of active contexts attached to wdmaud.sys.
    The contexts contain most of the state data for each device.  Whenever
    wdmaud.drv is loaded into a new process, wdmaud.sys will be notified
    of its arrival.  When wdmaud.drv is unload, wdmaud.sys cleans up any
    allocation made in that context.

Arguments:

    Flags - Verbose mode will print out the data members of each
            context structure.

Return Value:

    None

--*/
{
    LIST_ENTRY      List;
    ULONG64         ple;
    ULONG64         pWdmaContextListItem;
  //  WDMACONTEXT     WdmaContextBuffer;
    ULONG           Result;
    WDMAUD_FLAGS    Flags;
    ULONG NextOffset;
    FIELD_INFO offField = {"Next", NULL, 0, DBG_DUMP_FIELD_RETURN_ADDRESS, 0, NULL};
    SYM_DUMP_PARAM TypeSym ={                                                     
        sizeof (SYM_DUMP_PARAM), "WDMACONTEXT", DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &offField
    };
    
    // Get the offset of Next in WDMACONTEXT
    if (Ioctl(IG_DUMP_SYMBOL_INFO, &TypeSym, TypeSym.size)) {
       return ;
    }
    
    NextOffset = (ULONG) offField.address;

    Flags.Flags = flags;

    if (GetFieldValue(memLoc, "LIST_ENTRY", "Flink", ple))
    {
        dprintf("Unable to get value of WdmaContextListHead\n");
        return;
    }


    dprintf("Dumping list of active WDMAUD contexts:\n");

//    ple = List.Flink;
    if (ple == 0)
    {
        dprintf("WdmaAllocatedMdlListHead is NULL!\n");
        return;
    }

    while (ple != memLoc)
    {
        ULONG64 pContext;

        if (CheckControlC())
        {
            return;
        }

        pWdmaContextListItem = ple - NextOffset;
        if (GetFieldValue(pWdmaContextListItem,
                           "WDMACONTEXT",
                           "Next.Flink",
                           ple))
        {
            dprintf("Unable to read WDMACONTEXT at %08lx",pWdmaContextListItem);
            return;
        }

        if ( Flags.Verbose )
        {
            dprintf("Use dt WDMACONTEXT <addr>\n");
/*            dprintf("pContext: %X\n", pWdmaContextListItem);
            dprintf("   fInList:                    %X\n", WdmaContextBuffer.fInList);
            dprintf("   fInitializeSysaudio:        %X\n", WdmaContextBuffer.fInitializeSysaudio);
            dprintf("   InitializedSysaudioEvent:   %X\n", &WdmaContextBuffer.InitializedSysaudioEvent);
            dprintf("   pFileObjectSysaudio:        %X\n", WdmaContextBuffer.pFileObjectSysaudio);
            dprintf("   EventData:                  %X\n", &WdmaContextBuffer.EventData);
            dprintf("   VirtualWavePinId:           %X\n", WdmaContextBuffer.VirtualWavePinId);
            dprintf("   VirtualMidiPinId:           %X\n", WdmaContextBuffer.VirtualMidiPinId);
            dprintf("   PreferredSysaudioWaveDevice:%X\n", WdmaContextBuffer.PreferredSysaudioWaveDevice);
            dprintf("   DevNodeListHead:            %X\n", WdmaContextBuffer.DevNodeListHead);
            dprintf("   NotificationEntry:          %X\n", WdmaContextBuffer.NotificationEntry);
            dprintf("   WorkListWorkItem:           %X\n", WdmaContextBuffer.WorkListWorkItem);
            dprintf("   WorkListHead:               %X\n", WdmaContextBuffer.WorkListHead);
            dprintf("   WorkListSpinLock:           %X\n", WdmaContextBuffer.WorkListSpinLock);
            dprintf("   cPendingWorkList:           %X\n", WdmaContextBuffer.cPendingWorkList);
            dprintf("   SysaudioWorkItem:           %X\n", WdmaContextBuffer.SysaudioWorkItem);
            dprintf("   WorkListWorkerObject:       %X\n", WdmaContextBuffer.WorkListWorkerObject);
            dprintf("   SysaudioWorkerObject:       %X\n", WdmaContextBuffer.SysaudioWorkerObject);

            dprintf("   WaveOutDevs:                %X\n", &WdmaContextBuffer.WaveOutDevs);
            dprintf("   WaveInDevs:                 %X\n", &WdmaContextBuffer.WaveInDevs);
            dprintf("   MidiOutDevs:                %X\n", &WdmaContextBuffer.MidiOutDevs);
            dprintf("   MidiInDevs:                 %X\n", &WdmaContextBuffer.MidiInDevs);
            dprintf("   MixerDevs:                  %X\n", &WdmaContextBuffer.MixerDevs);
            dprintf("   AuxDevs:                    %X\n", &WdmaContextBuffer.AuxDevs);

            dprintf("   apCommonDevice:             %X\n", &WdmaContextBuffer.apCommonDevice);*/
        }
        else
        {
            dprintf("pContext: %p\n", pWdmaContextListItem);
        }

//        ple = WdmaContextBuffer.Next.Flink;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kernprof\pooldump.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pooldump.c

Abstract:

    This module contains the implementation of the temporary routine
    to dump non-paged pool usage.

Usage:

    Set TRACE_ALLOC to 1 in pool.c and rebuild the kernel.
    When pooldump is run, the colllected pool counts are returned
    and analyzed.

Author:

    Lou Perazzoli (loup) 22-Aug-1991

Envirnoment:


    User mode, debug version of the kernel.

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf
//#define DBG_PROFILE  1


NTSTATUS
LoadSymbols (
    VOID
    );

NTSTATUS
LookupSymbolNameAndLocation (
    IN ULONG CodeAddress,
    OUT PSTRING SymbolName,
    OUT PULONG OffsetFromSymbol,
    OUT PULONG ImageIndex
    );

#define PAGE_SIZE 4096

typedef struct _IMAGE_BLOCK {
    ULONG ImageBase;  //actual base where mapped locally.
    PIMAGE_DEBUG_INFO DebugInfo;
    ULONG CodeStart;
    ULONG CodeEnd;
    ULONG TextNumber;
    BOOLEAN KernelCode;
    UNICODE_STRING ImageName;
} IMAGE_BLOCK;


#define MAX_PROFILE_COUNT 30

IMAGE_BLOCK ImageInformation[MAX_PROFILE_COUNT+1];

ULONG NumberOfImages = 0;

//
// Define map data file if the produced data file should be
// a mapped file (currently named "kernprof.dat").
//

// #define MAP_DATA_FILE

//
// Define map as image if the image to be profiled should be mapped
// as an image rather than as data.
//

// #define MAP_AS_IMAGE

#define MAX_POOL_ENTRIES 1024

typedef struct _POOLUSAGE {
    ULONG Caller;
    ULONG Allocations;
    ULONG Frees;
    ULONG Usage;
} POOLUSAGE;

POOLUSAGE Buffer[MAX_POOL_ENTRIES];
__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    NTSTATUS status;
    ULONG i, Offset;
    ULONG TotalAllocs = 0;
    ULONG TotalFrees = 0;
    ULONG TotalUsage = 0;
    ULONG Start;
    STRING SymbolName;
    UCHAR String[80];
    STRING OutString;
    ULONG ImageIndex;

    RtlZeroMemory (&Buffer, MAX_POOL_ENTRIES * sizeof (POOLUSAGE));

    SymbolName.MaximumLength = 80;
    SymbolName.Buffer = String;

    status = NtPartyByNumber (PARTY_DUMP_POOL_USAGE, &Buffer);
    if (!NT_SUCCESS (status)) {
        return(status);
    }
    LoadSymbols ();

    printf("Allocs  Frees   Used      At\n");

    for (i =0; i < MAX_POOL_ENTRIES ; i++ ) {
        if (Buffer[i].Caller == 0) {
            break;
        }

        String[0] = 0;
        SymbolName.MaximumLength = 80;
          SymbolName.Length = 0;
          Offset = Buffer[i].Caller;
        LookupSymbolNameAndLocation (Buffer[i].Caller,
                                     &SymbolName,
                                     &Offset,
                                     &ImageIndex);

        RtlUnicodeStringToAnsiString(&OutString,
                                     &ImageInformation[ImageIndex].ImageName,
                                     TRUE);

        printf("%6ld %6ld %6ld %s + 0x%lx (%s)\n",
                Buffer[i].Allocations,
                Buffer[i].Frees,
                Buffer[i].Usage,
                SymbolName.Buffer,
                Offset,
                OutString.Buffer
                );

        RtlFreeAnsiString(&OutString);
        TotalAllocs += Buffer[i].Allocations;
        TotalFrees += Buffer[i].Frees;
        TotalUsage += Buffer[i].Usage;
    }


    printf("Total: allocations %ld Frees %ld  Difference (A-F) %ld Usage %ld\n",
        TotalAllocs, TotalFrees, (TotalAllocs - TotalFrees), TotalUsage);

    return(status);
}

NTSTATUS
LoadSymbols (
    VOID
    )

/*++

Routine Description:

    This routine initializes symbols for the kernel.

Arguments:

    None.

Return Value:

    Status of operations.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    HANDLE FileHandle, KernelSection;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID ImageBase;
    ULONG ViewSize;
    ULONG CodeLength;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    ULONG DebugSize;
    PVOID KernelBase;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    UCHAR StringBuf[250];
    UNICODE_STRING NameString;
    ULONG TotalOffset;
    CHAR ModuleInfo[8000];
    ULONG ReturnedLength;
    PSYSTEM_LOAD_MODULE_INFORMATION Module;
    ANSI_STRING String;
    STRING SysdiskA;
    STRING SysrootA;
    UNICODE_STRING Sysdisk;
    UNICODE_STRING Sysroot;
    PIMAGE_DEBUG_INFO KernelDebugInfo;

    CurrentProcessHandle = NtCurrentProcess();

    //
    // Locate system drivers.
    //

    status = NtQuerySystemInformation (
                    SystemLoadModuleInformation,
                    ModuleInfo,
                    8000,
                    &ReturnedLength);

    if (!NT_SUCCESS(status)) {
        printf("query system info failed status - %lx\n",status);
        return(status);
    }

    RtlInitString (&SysdiskA,"\\SystemRoot");
    RtlAnsiStringToUnicodeString (&Sysdisk, (PANSI_STRING)&SysdiskA, TRUE);

    RtlInitString (&SysrootA,"\\SystemRoot\\Driver\\");
    RtlAnsiStringToUnicodeString (&Sysroot, (PANSI_STRING)&SysrootA, TRUE);

    NameString.Buffer = &StringBuf[0];
    NameString.Length = 0;
    NameString.MaximumLength = 250;

    Module = &ModuleInfo[0];
    TotalOffset = 0;
    while (TRUE) {

#if DBG_PROFILE
        printf("module base %lx\n",Module->BaseAddress);
        printf("module dll buffer address %lx %lx %lx\n",
                Module->ModuleDllName.Buffer,
                Module->ModuleFileName.Buffer, Module);
        RtlUnicodeStringToAnsiString(&String, &Module->ModuleDllName, TRUE);
        printf("module dll name %s\n",String.Buffer);
        RtlUnicodeStringToAnsiString(&String, &Module->ModuleFileName, TRUE);
        printf("module file name %s\n",String.Buffer);
#endif

        if ( Module->ModuleFileName.Buffer[0] == (WCHAR) '\\' ) {
            Module->ModuleFileName.Buffer++;
            Module->ModuleFileName.Length -= sizeof(WCHAR);
            Module->ModuleFileName.MaximumLength -= sizeof(WCHAR);
            while (Module->ModuleFileName.Buffer[0] != (WCHAR) '\\' ) {
                Module->ModuleFileName.Buffer++;
                Module->ModuleFileName.Length -= sizeof(WCHAR);
                Module->ModuleFileName.MaximumLength -= sizeof(WCHAR);
                }
            }

        NameString.Length = 0;
        status = RtlAppendStringToString (&NameString, (PSTRING)&Sysdisk);
        if (!NT_SUCCESS(status)) {
            printf("append string failed status - %lx\n",status);
            return(status);
        }

        status = RtlAppendStringToString (&NameString, (PSTRING)&Module->ModuleFileName);

        if (!NT_SUCCESS(status)) {
            printf("append string failed status - %lx\n",status);
            return(status);
        }

        InitializeObjectAttributes( &ObjectAttributes,
                                    &NameString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );

        //
        // Open the file as readable and executable.
        //

#if DBG_PROFILE
        RtlUnicodeStringToAnsiString(&String, &NameString, TRUE);
        printf("Opening file name %s\n",String.Buffer);
#endif

        status = NtOpenFile ( &FileHandle,
                              FILE_READ_DATA | FILE_EXECUTE,
                              &ObjectAttributes,
                              &IoStatus,
                              FILE_SHARE_READ,
                              0L);

        if (!NT_SUCCESS(status)) {

            //
            // Try a different name - in SystemRoot\Driver directory.
            //

            NameString.Length = 0;
            status = RtlAppendStringToString (&NameString, &Sysroot);
            if (!NT_SUCCESS(status)) {
                printf("append string failed status - %lx\n",status);
                return(status);
            }

            status = RtlAppendStringToString (&NameString, &Module->ModuleFileName);

            if (!NT_SUCCESS(status)) {
                printf("append string failed status - %lx\n",status);
                return(status);
            }

            InitializeObjectAttributes( &ObjectAttributes,
                                        &NameString,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL );

            //
            // Open the file as readable and executable.
            //

#if DBG_PROFILE
            RtlUnicodeStringToAnsiString(&String, &NameString, TRUE);
            printf("Opening file name %s\n",String.Buffer);
#endif
            status = NtOpenFile ( &FileHandle,
                                  FILE_READ_DATA,
                                  &ObjectAttributes,
                                  &IoStatus,
                                  FILE_SHARE_READ,
                                  0L);

            if (!NT_SUCCESS(status)) {
                RtlUnicodeStringToAnsiString(&String, &NameString, TRUE);
                DbgPrint("open file %s failed status %lx\n",
                          String.Buffer, status);
                return(status);
            }
        }

        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

        //
        // For normal images they would be mapped as an image, but
        // the kernel has no debug section (as yet) information, hence it
        // must be mapped as a file.
        //

        status = NtCreateSection (&KernelSection,
                                  SECTION_MAP_READ,
                                  &ObjectAttributes,
                                  0,
                                  PAGE_READONLY,
                                  SEC_COMMIT,
                                  FileHandle);

        if (!NT_SUCCESS(status)) {
            DbgPrint("create image section failed  status %lx\n", status);
            return(status);
        }

        ViewSize = 0;

        //
        // Map a view of the section into the address space.
        //

        KernelBase = NULL;

        status = NtMapViewOfSection (KernelSection,
                                     CurrentProcessHandle,
                                     &KernelBase,
                                     0L,
                                     0,
                                     NULL,
                                     &ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READONLY);

        if (!NT_SUCCESS(status)) {
            if (status != STATUS_IMAGE_NOT_AT_BASE) {
                DbgPrint("map section status %lx base %lx size %lx\n", status,
                    (ULONG)KernelBase, ViewSize);
            }
        }

        ImageBase = Module->BaseAddress;

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)RtlImageDirectoryEntryToData(
                    KernelBase, FALSE, IMAGE_DIRECTORY_ENTRY_DEBUG, &DebugSize);

        //printf("Mapped base %lx Debug dir %lx\n", (ULONG)KernelBase, DebugDirectory);

        if (!DebugDirectory) {
            DbgPrint("InitializeKernelProfile : No debug directory\n");
            return STATUS_INVALID_IMAGE_FORMAT;
        }


        KernelDebugInfo = (PIMAGE_DEBUG_INFO)((ULONG)KernelBase + DebugDirectory->PointerToRawData);
        CodeLength = KernelDebugInfo->RvaToLastByteOfCode - KernelDebugInfo->RvaToFirstByteOfCode;

        ImageInformation[NumberOfImages].KernelCode = TRUE;
        ImageInformation[NumberOfImages].DebugInfo = KernelDebugInfo;
        ImageInformation[NumberOfImages].CodeStart = ((ULONG)ImageBase +
                                        KernelDebugInfo->RvaToFirstByteOfCode);
        ImageInformation[NumberOfImages].CodeEnd =
                        ImageInformation[NumberOfImages].CodeStart + CodeLength;
        ImageInformation[NumberOfImages].TextNumber = 1;
        ImageInformation[NumberOfImages].ImageBase = ImageBase;
        ImageInformation[NumberOfImages].ImageName = Module->ModuleDllName;

        NumberOfImages += 1;
        if (NumberOfImages == MAX_PROFILE_COUNT) {
            return STATUS_SUCCESS;
        }

        if (Module->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += Module->NextEntryOffset;
        Module = (PSYSTEM_LOAD_MODULE_INFORMATION)&ModuleInfo[TotalOffset];
    }
    return status;
}


NTSTATUS
LookupSymbolNameAndLocation (
    IN ULONG CodeAddress,
    OUT PSTRING SymbolName,
    OUT PULONG OffsetFromSymbol,
    OUT PULONG ImageIndex
    )

/*++

Routine Description:

    Given a code address, this routine returns the nearest symbol
    name and the offset from the symbol to that name.  If the
    nearest symbol is not within 100k of the location, no name
    is returned and the offset is the value of the CodeAddress.

Arguments:

    CodeAddress - Supplies the address to lookup a symbol for.

    SymbolName - Returns the name of the symbol.

    OffsetFromSymbol - Returns the offset from the symbol to the
                       code address.

Return Value:

    Status of operations.

--*/

{

    ULONG j, nextSymbol, imageNumber;
    ULONG NewCodeAddress;
    IMAGE_SYMBOL PreviousSymbol;
    PIMAGE_DEBUG_INFO DebugInfo;
    PIMAGE_SYMBOL SymbolEntry;
    IMAGE_SYMBOL Symbol;
    PUCHAR StringTable;
    ULONG EightChar[3];
    BOOLEAN NoSymbols;

    for (imageNumber = 0; imageNumber < NumberOfImages; imageNumber++) {
        if ((CodeAddress >= ImageInformation[imageNumber].ImageBase) &&
           (CodeAddress <= ImageInformation[imageNumber].CodeEnd)) {
            break;
        }
    }
    *ImageIndex = imageNumber;

    if (imageNumber == NumberOfImages) {

        //
        // Address not found.
        //

        SymbolName->Length = 0;
        *OffsetFromSymbol = CodeAddress;
        return STATUS_SUCCESS;
    }

    NewCodeAddress = CodeAddress - ImageInformation[imageNumber].ImageBase;

    //
    // Locate debug section.
    //

    DebugInfo = ImageInformation[imageNumber].DebugInfo;

    //
    // Crack the symbol table.
    //

    SymbolEntry = (PIMAGE_SYMBOL)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
    StringTable = (PUCHAR)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol +
                                DebugInfo->NumberOfSymbols * (ULONG)IMAGE_SIZEOF_SYMBOL);

    //
    // Find the "header" symbol (skipping all the section names)
    //

    nextSymbol = 0;
//    printf("number of symbols %ld\n", DebugInfo->NumberOfSymbols);
    for (j = 0; j < DebugInfo->NumberOfSymbols; j++) {
        EightChar[0] = SymbolEntry->N.Name.Short;
        EightChar[1] = SymbolEntry->N.Name.Long;
        if (!strcmp((PSZ)&EightChar[0], "header")) {
            nextSymbol = j;
//            printf("found header at %ld\n",j);
            break;
        }
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                        IMAGE_SIZEOF_SYMBOL);
    }
    if (j >= DebugInfo->NumberOfSymbols) {
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
    }

    NoSymbols = TRUE;

    //
    // Loop through all symbols in the symbol table.  For each symbol,
    // if it is within the code section, subtract off the bias and
    // see if there are any hits within the profile buffer for
    // that symbol.
    //

//    printf("number of symbols %ld\n", DebugInfo->NumberOfSymbols);
    for (j = nextSymbol; j < DebugInfo->NumberOfSymbols; j++) {


        try {
//                printf("numberof aux symbols %ld\n",SymbolEntry->NumberOfAuxSymbols );
            while ( SymbolEntry->NumberOfAuxSymbols ) {
                j = j + 1 + SymbolEntry->NumberOfAuxSymbols;
                SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                                IMAGE_SIZEOF_SYMBOL +
                                SymbolEntry->NumberOfAuxSymbols*IMAGE_SIZEOF_SYMBOL);

            }
            RtlMoveMemory (&Symbol, SymbolEntry, IMAGE_SIZEOF_SYMBOL);
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            printf("breaking excpt\n");
            break;
        }

//            printf("value %lx number %lx start %lx\n",Symbol.Value,Symbol.SectionNumber,CodeAddress);
        if (Symbol.SectionNumber == (SHORT)1) {

            //
            // This symbol is within the code.
            //

            if (Symbol.Value < NewCodeAddress) {
                PreviousSymbol = Symbol;
                NoSymbols = FALSE;
            } else {
                break;
            }
        }
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry +
                                                    IMAGE_SIZEOF_SYMBOL);

    }

    if ((NoSymbols) || (NewCodeAddress - PreviousSymbol.Value) > 0x100000) {

      SymbolName->Length = 0;
      *OffsetFromSymbol = CodeAddress;
    } else {
        if (PreviousSymbol.N.Name.Short) {
            SymbolName->Length = 8;
            if (SymbolName->Length > SymbolName->MaximumLength) {
                SymbolName->Length = SymbolName->MaximumLength;
            }

            EightChar[0] = PreviousSymbol.N.Name.Short;
            EightChar[1] = PreviousSymbol.N.Name.Long;
            RtlMoveMemory (SymbolName->Buffer, EightChar, SymbolName->Length);

        } else {
            SymbolName->Length =
                    strlen(&StringTable[PreviousSymbol.N.Name.Long] ) + 1;
            if (SymbolName->Length > SymbolName->MaximumLength) {
                SymbolName->Length = SymbolName->MaximumLength;
            }
            RtlMoveMemory (SymbolName->Buffer,
                           &StringTable[PreviousSymbol.N.Name.Long],
                           SymbolName->Length);
            SymbolName->Buffer[SymbolName->Length] = 0;
        }
        *OffsetFromSymbol = NewCodeAddress - PreviousSymbol.Value;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kernrate\makefile.inc ===
HALIA64_PATH=$(PROJECT_ROOT)\hals\halia64\ia64

$(O)\kernrate.res: kernrate.rc

merced.c: $(HALIA64_PATH)\merced.c profevts.pl makefile.inc
    @perl profevts.pl $(HALIA64_PATH)\merced.c > $@

mckinley.c: $(HALIA64_PATH)\mckinley.c profevts.pl makefile.inc
    @perl profevts.pl $(HALIA64_PATH)\mckinley.c > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\ntsdexts\ext.h ===
//----------------------------------------------------------------------------
//
// Generic interface-style extension support.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __EXT_H__
#define __EXT_H__

#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif
    
// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

HRESULT ExtQuery(PDEBUG_CLIENT Client);
void ExtRelease(void);
    
// Global variables initialized by ExtQuery.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Version 2 interfaces may be NULL.
extern PDEBUG_DATA_SPACES2   g_ExtData2;

extern HANDLE g_hCurrentProcess;
extern HANDLE g_hCurrentThread;
    
// Windbg-style extension interfaces queried at Initialize time.
extern WINDBG_EXTENSION_APIS   ExtensionApis;
extern WINDBG_EXTENSION_APIS32 ExtensionApis32;
extern WINDBG_EXTENSION_APIS64 ExtensionApis64;

typedef BOOL
(CALLBACK *PENUMERATE_UMODE_THREADS_CALLBACK)(
     ULONG ThreadUserId,
     PVOID UserContext
     );

ULONG GetCurrentThreadUserID(void);

BOOL
EnumerateUModeThreads(
    PENUMERATE_UMODE_THREADS_CALLBACK Callback,
    PVOID UserContext
    );

#ifdef __cplusplus
}
#endif

#endif // #ifndef __EXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kernrate\kernrate.c ===
/*++

Copyright (c) 1995-2002  Microsoft Corporation

Module Name:

   kernrate.c

Abstract:

    This program records the rate of various events over a selected
    period of time. It uses the kernel profiling mechanism and iterates
    through the available profile sources to produce an overall profile
    for the various Kernel or User-Process components.

Usage:

    kernrate <commad line options>

Author:

    John Vert (jvert) 31-Mar-1995

Revision History:

    The original MS version has been extensively modified by Thierry Fevrier and Dan Almosnino.

--*/

   // KERNRATE Implementation Notes:
   //
   // 01/10/2000 - Thierry
   // The following code assumes that a kernrate compiled for a specific
   // platform, executes and processes perf data only for that platform.
   //
   // Danalm 02/15/2002:
   //     - Current code supports Windows 2000 and above, won't run on lower versions
   //
   // KERNRATE ToDoList:
   //
   // Thierry 09/30/97:
   //     - KernRate does not clean the ImageHlp API in case of exceptions. I have
   //       just added a SymCleanup() call at the normal exit of this program but
   //       it is not sufficient. We should revisit this one day...
   //
   // Thierry 07/01/2000:
   //     - Kernrate and the Kernel Profiling objects code assume that code sections
   //       that we are profiling are not larger than 4GB.
   //

#include "kernrate.h"
 
VOID
vVerbosePrint(
    ULONG  Level,
    PCCHAR Msg,
    ...
)
{
    if ( gVerbose & Level )  {
        va_list ap;

        va_start( ap, Msg ); 

        vfprintf(stderr , Msg, ap );

        va_end(ap);

    }
    return;

} // vVerbosePrint()

BOOL
CtrlcH(
    DWORD dwCtrlType
    )
{
    LARGE_INTEGER DueTime;

    if ( dwCtrlType == CTRL_C_EVENT ) {
        if(gProfilingDone != TRUE) {
            if (gSleepInterval == 0) {
                SetEvent(ghDoneEvent);
            } else {
                DueTime.QuadPart = (ULONGLONG)-1;
                NtSetTimer(ghDoneEvent,
                           &DueTime,
                           NULL,
                           NULL,
                           FALSE,
                           0,
                           NULL);
            }
        } 
        else {
//MC
            //
            // If someone kills kernrate by pressing Ctrl-C we need to detach from the process (if attached to it)
            // Otherwise that process will hang. Of course we can't do much if someone kills kernrate externally.
            //
            if( ghMCLib != NULL){
                pfnDetachFromProcess();
                FreeLibrary(ghMCLib);
                ghMCLib = NULL;
                exit(0);
            }
//MC    
        }
    
        return TRUE;
    }
    return FALSE;

} // CtrlcH()

static VOID
UsageVerbose(
    VOID
    )
{
  PVERBOSE_DEFINITION pdef = VerboseDefinition;

  FPRINTF( stderr, "  -v [VerboseLevels]      Verbose output where VerboseLevels:\n");
  while( pdef->VerboseString )    {
     FPRINTF( stderr, "                             - %x %s\n", pdef->VerboseEnum,
                                                                pdef->VerboseString
            );
     pdef++;
  }
  FPRINTF( stderr, "                             - Default value: %x\n", VERBOSE_DEFAULT);
  FPRINTF( stderr, "                          These verbose levels can be OR'ed.\n");

  return;

} // UsageVerbose()

static VOID
Usage(
   BOOL ExitKernrate
   )
{

  FPRINTF( stderr, "KERNRATE - Version: %s\n", VER_PRODUCTVERSION_STR );
  FPRINTF( stderr,
"KERNRATE [-l] [-lx] [-r] [-m] [-p ProcessId] [-z ModuleName] [-j SymbolPath] [-c RateInMsec] [-s Seconds] [-i [SrcShortName] Rate]\n"
"         [-n ProcessName] [-w]\n\n"
"  -a                      Do a combined Kernel and User mode profile\n"
"  -av                     Do a combined Kernel and User mode profile and get task list and system threads info\n"
"  -b BucketSize           Specify profiling bucket size (default = 16 bytes, must be a power of 2)\n"
"  -c RateInMsec           Change source every N milliseconds (default 1000ms). Optional. By default all sources will be profiled simultaneously\n"
"  -d                      Generate output rounding buckets up and down\n"
"  -e                      Exclude system-wide and process specific general information (context switches, memory usage, etc.)\n"
"  -f                      Process the collected data at high priority (useful on busy systems if the overhead is not an issue)\n" 
"  -g Rate                 Get interesting processor-counters statistics (Rate optional in events/hit), output not guarantied\n"
"  -i SrcShortName Rate    Specify interrupt interval rate (in events/hit)for the source specified by its ShortName, see notes below\n"
"  -j SymbolPath           Prepend SymbolPath to the default imagehlp search path\n"
"  -k MinHitCount          Limit the output to modules that have at least MinHitCount hits\n"
"  -l                      List the default interval rates for supported sources\n"
"  -lx                     List the default interval rates for supported sources and then exit\n"
"  -m 0xN                  Generate per-CPU profiles on multi-processor machines, Hex CPU affinity mask optional for profiling on selected processors\n"
"  -n ProcessName          Monitor process by its name (default limited to first 8 by the same name), multiple usage allowed\n" 
"  -nv# N ProcessName      Monitor up to N processes by the same name, v will print thread info and list of all running processes (optional)\n"   
"  -o ProcessName {CmdLine}Create and monitor ProcessName (path OK), Command Line parameters optional and must be enclosed in curly brackets\n"
"  -ov# N ProcessName { }  Create N instances of ProcessName, v will print thread info and list of running processes (optional), {command line} optional\n" 
"  -pv ProcessId           Monitor process by its ProcessId, multiple usage allowed - see notes below, v (optional) same as in '-nv'\n"
"  -r                      Raw data from zoomed modules\n"
"  -rd                     Raw data from zoomed modules with disassembly\n"
"  -s Seconds              Stop collecting data after N seconds\n"
"  -t                      Display process list + CPU usage summary for the profiling period\n"
"  -t MaxTasks             As above + Change the maximum no. of processes allowed in Kernrate's list to MaxTasks (default: 256)\n" 
"  -u                      Present symbols in undecorated form\n"
"  -w                      Wait for the user to press ENTER before starting to collect profile data\n"
"  -w Seconds              Wait for N seconds before starting to collect profile data (default is no wait)\n"              
"  -wp                     Wait for the user to press enter to indicate that created processes (see -0 option) are settled (idle)\n"
"  -wp Seconds             Wait for N seconds to allow created processes settle (go idle), default is 2 seconds, (see the -o option)\n"
"  -x                      Get both system and user-process locks information\n"
"  -x#  count              Get both system and user-process locks information for (optional) contention >= count [def. 1000]\n"
"  -xk# count              Get only system lock information for (optional) contention >= count [def. 1000]\n"
"  -xu# count              Get only user-process lock information for (optional) contention >= count [def. 1000]\n"
"  -z module               Name of module to zoom on (no extension needed by default) such as ntdll, multiple usage allowed, see notes below\n"
"  -v Verbose              Verbose Printout, if specified with no level the default is Imagehlp symbol information\n"       
        );

    UsageVerbose();    // -v switches

  FPRINTF( stderr,
"\nMulti-Processes are allowed (each process ID needs to be preceded by -P except for the system process)\n"
"Typical multi-process profiling command line should look like:\n"
"\nkernrate .... -a -z ntoskrnl -z ntdll -z kernel32 -p 1234 -z w3svc -z iisrtl -p 4321 -z comdlg32 -z msvcrt ...\n"
"\nThe first group of -z denotes either kernel modules and-or modules common across processes\n"
"The other -z groups are process specific and should always follow the appropriate -p xxx \n"
"\nThe -z option requires to add the extension (.dll etc.) only if two or more binaries carry the same name and differ only by the extension\n" 
"\nThe '-g' option will attempt to turn on multiple sources. One source at a time profiling mode will automatically be forced\n"  
"\nThe '-i' option can be followed by only a source name (system default interrupt interval rate will then be assumed)\n"
"\nA '-i' option followed by a rate amount (no profile source name) will change the interval rate for the default source (time)\n"
"\nProfiling of the default source (Time) can be disabled by setting its profile interval to zero\n" 
"\nWith the '-n' option, use the common modules -Z option if you expect more than one process with the same name\n" 
"\nThe '-c' option will cause elapsed time to be devided equally between the sources and the monitored processes\n"
"\nThe '-o' option supports redirection of input/output/error streams within the curly brackets. Each redirection character must be escaped with a '^' character\n" 
"----------------------------------------------------------------------------------------------------------------------------\n\n"
         );

    if(ExitKernrate){
      exit(1);
    } else {
      return;
    }
} // Usage()

VOID
CreateDoneEvent(
    VOID
    )
{
    LARGE_INTEGER DueTime;
    NTSTATUS Status;
    DWORD Error;

    if (gSleepInterval == 0) {
        //
        // Create event that will indicate the test is complete.
        //
        ghDoneEvent = CreateEvent(NULL,
                                TRUE,
                                FALSE,
                                NULL);
        if (ghDoneEvent == NULL) {
            Error = GetLastError();
            FPRINTF(stderr, "CreateEvent failed %d\n",Error);
            exit(Error);
        }
    } else {

        //
        // Create timer that will indicate the test is complete
        //
        Status = NtCreateTimer(&ghDoneEvent,
                               MAXIMUM_ALLOWED,
                               NULL,
                               NotificationTimer);

        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr, "NtCreateTimer failed %08lx\n",Status);
            exit(Status);
        }

        DueTime.QuadPart = (LONGLONG) UInt32x32To64(gSleepInterval, 10000);
        DueTime.QuadPart *= -1;

        Status = NtSetTimer(ghDoneEvent,
                            &DueTime,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL);

        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr, "NtSetTimer failed %08lx\n",Status);
            exit(Status);
        }
    }

} // CreateDoneEvent()

/* BEGIN_IMS  SymbolCallbackFunction
******************************************************************************
****
****   SymbolCallbackFunction (  )
****
******************************************************************************
*
* Function Description:
*
*    The user function is called by IMAGEHLP at the specified operations.
*    Refer to the CBA_xxx values.
*
* Arguments:
*
*    HANDLE hProcess :
*
*    ULONG ActionCode :
*
*    PVOID CallbackData :
*
*    PVOID UserContext :
*
* Return Value:
*
*    BOOL
*
* Algorithm:
*
*    ToBeSpecified
*
* Globals Referenced:
*
*    ToBeSpecified
*
* Exception Conditions:
*
*    ToBeSpecified
*
* In/Out Conditions:
*
*    ToBeSpecified
*
* Notes:
*
*    ToBeSpecified
*
* ToDo List:
*
*    ToBeSpecified
*
* Modification History:
*
*    9/30/97  TF  Initial version
*
******************************************************************************
* END_IMS  SymbolCallbackFunction */

BOOL
SymbolCallbackFunction(
    HANDLE    hProcess,
    ULONG     ActionCode,
    ULONG64   CallbackData,
    ULONG64   UserContext
    )
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PIMAGEHLP_DUPLICATE_SYMBOL       idup;
    PIMAGEHLP_CBA_READ_MEMORY        prm;
    PMODULE                         *pmodule;
    PMODULE                          module;
    ULONG                            i;
    //
    // Note: The default return value for this function is FALSE.
    //
    assert( UserContext );
    idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD64) CallbackData;

    switch( ActionCode ) {
        case CBA_DEBUG_INFO:

            VerbosePrint(( VERBOSE_IMAGEHLP, "%s", (LPSTR)CallbackData ));
            break;

        case CBA_DEFERRED_SYMBOL_LOAD_START:

            if(UserContext){
                pmodule = (PMODULE *)UserContext;
                module = *pmodule;
                if(module != NULL)
                    VerbosePrint(( VERBOSE_IMAGEHLP, "CallBack: Loading symbols for %s...\n",
                                                    module->module_FileName
                                                    ));
                return TRUE;
            }

            break;

        case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:

            if (hProcess == SYM_KERNEL_HANDLE &&
                idsl->SizeOfStruct >= FIELD_OFFSET(IMAGEHLP_DEFERRED_SYMBOL_LOAD,
                                                   Reparse))
            {
                i = 0;

                if (strncmp(idsl->FileName, "dump_", sizeof("dump_")-1) == 0)
                {
                    i = sizeof("dump_")-1;
                }

                else if (strncmp(idsl->FileName, "hiber_", sizeof("hiber_")-1) == 0)
                {
                    i = sizeof("hiber_")-1;
                }

                if (i)
                {
                    if (_stricmp (idsl->FileName+i, "scsiport.sys") == 0)
                    {
                         strncpy (idsl->FileName, "diskdump.sys", MAX_PATH-1);
                         idsl->FileName[ MAX_PATH-1 ] = '\0';
                    }
                    else
                    {
                         strncpy(idsl->FileName, idsl->FileName+i, MAX_PATH-1);
                         idsl->FileName[ MAX_PATH-1 ] = '\0';
                    }

                    idsl->Reparse = TRUE;
                    return TRUE;
                }
            }

            if (idsl->FileName && *idsl->FileName)
            {
                VerbosePrint(( VERBOSE_IMAGEHLP, "CallBack: could not load symbols for %s\n",
                                                 idsl->FileName
                                                 ));
            }
            else
            {
                VerbosePrint(( VERBOSE_IMAGEHLP, "CallBack: could not load symbols [MODNAME UNKNOWN]\n"
                                                 ));
            }

            break;

        case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:

            if(UserContext){
                pmodule = (PMODULE *)UserContext;
                module = *pmodule;

                if(idsl && module)
                    FPRINTF(stderr, "CallBack: Finished Attempt to Load symbols for %I64x %s\n\n",
                            idsl->BaseOfImage,
                            ModuleFullName( module )
                            );
            }

            return TRUE;

        case CBA_SYMBOLS_UNLOADED:

            VerbosePrint(( VERBOSE_IMAGEHLP, "CallBack: Symbols Unloaded.\n" ));
            
            break;

        case CBA_DUPLICATE_SYMBOL:

            idup = (PIMAGEHLP_DUPLICATE_SYMBOL) CallbackData;
            
            if(UserContext){
                pmodule = (PMODULE *)UserContext;
                module = *pmodule;
                if(module != NULL && module->module_FileName != NULL )
                     VerbosePrint(( VERBOSE_IMAGEHLP, "Callback: Attempt to load Duplicate symbol for %s\n",
                                                      module->module_FileName
                                                      ));

            }



            if(idup != NULL)
                FPRINTF( stderr, "*** WARNING: Found %ld duplicate symbols for %s\n",
                                   idup->NumberOfDups,
                                   (idup->SelectedSymbol != (ULONG)-1) ? idup->Symbol[idup->SelectedSymbol].Name : "unknown symbol"
                         );


            return TRUE;

        case CBA_READ_MEMORY:

            prm = (PIMAGEHLP_CBA_READ_MEMORY) CallbackData;
            if(prm != NULL){

                return ReadProcessMemory(hProcess,
                                         (LPCVOID)prm->addr,
                                         prm->buf,
                                         prm->bytes,
                                         NULL) == S_OK;


            } 
            break;

        default:
            return FALSE;
    }

    return FALSE;

} // SymbolCallBackFunction()

static PCHAR
GetSymOptionsValues( DWORD SymOptions )
{
   static CHAR  values[SYM_VALUES_BUF_SIZE];
   ULONG  valuesSize = SYM_VALUES_BUF_SIZE - 1;
   
   values[0] = '\0';
   if ( SymOptions & SYMOPT_CASE_INSENSITIVE )   {
      (void)strncat( values, "CASE_INSENSITIVE ", valuesSize );
      SymOptions &= ~SYMOPT_CASE_INSENSITIVE;
   }
   if ( SymOptions & SYMOPT_UNDNAME )   {
      (void)strncat( values, "UNDNAME ", valuesSize-lstrlen(values) );
      SymOptions &= ~SYMOPT_UNDNAME;
   }
   if ( SymOptions & SYMOPT_DEFERRED_LOADS )   {
      (void)strncat( values, "DEFERRED_LOADS ", valuesSize-lstrlen(values) );
      SymOptions &= ~SYMOPT_DEFERRED_LOADS;
   }
   if ( SymOptions & SYMOPT_NO_CPP )   {
      (void)strncat( values, "NO_CPP ", valuesSize-lstrlen(values) );
      SymOptions &= ~SYMOPT_NO_CPP;
   }
   if ( SymOptions & SYMOPT_LOAD_LINES )   {
      (void)strncat( values, "LOAD_LINES ", valuesSize-lstrlen(values) );
      SymOptions &= ~SYMOPT_LOAD_LINES;
   }
   if ( SymOptions & SYMOPT_OMAP_FIND_NEAREST )   {
      (void)strncat( values, "OMAP_FIND_NEAREST ", valuesSize-lstrlen(values) );
      SymOptions &= ~SYMOPT_OMAP_FIND_NEAREST;
   }
   if ( SymOptions & SYMOPT_DEBUG )   {
      (void)strncat( values, "DEBUG ", valuesSize-lstrlen(values) );
      SymOptions &= ~SYMOPT_DEBUG;
   }
   if ( SymOptions )   {
      CHAR uknValues[10];
      (void)_snprintf( uknValues, 10, "0x%x", SymOptions );
      (void)strncat( values, uknValues, valuesSize-lstrlen(values) );
   }
   values[valuesSize] = '\0';

   return( values );

} // GetSymOptionsValues()

void __cdecl UInt64Div (
    unsigned __int64  numer,
    unsigned __int64  denom,
   uint64div_t      *result
    )
{

   assert(result);

   if ( denom != (unsigned __int64)0 )   {
          result->quot = numer / denom;
       result->rem  = numer % denom;
   }
   else  {
       result->rem = result->quot = (unsigned __int64)0;
   }

    return;

} // UInt64Div()

void __cdecl Int64Div (
    __int64    numer,
    __int64    denom,
   int64div_t      *result
    )
{

   assert(result);

   if ( denom != (__int64)0 )   {
          result->quot = numer / denom;
       result->rem  = numer % denom;
       if (numer < 0 && result->rem > 0) {
           /* did division wrong; must fix up */
           ++result->quot;
           result->rem -= denom;
       }
   }
   else  {
       result->rem = result->quot = (__int64)0;
   }

    return;

} // Int64Div()

unsigned __int64 __cdecl
UInt64PerCent( unsigned __int64 Val, unsigned __int64 Denom )
{
   uint64div_t v;

   UInt64Div( 100*Val, Denom, &v );
   while ( v.rem > UINT64_MAXDWORD )   {
      v.quot++;
      v.rem -= UINT64_MAXDWORD;
   }
   return( v.quot );

} // UInt64PerCent()

double
UInt64ToDoublePerCent( unsigned __int64 Val, unsigned __int64 Denom )
{
    double retval;
    retval = ( Denom > (__int64) 0 )?  ((double) (__int64)Val / (double) (__int64)Denom)*(double)100 : (double) 0;
    return retval;
}    
 
//////////////////////////////////////////////////
//                                                //
// Main                                            //
//                                                //
//////////////////////////////////////////////////
int
__cdecl
main (
    int argc,
    char *argv[]
    )
{
    PPROC_TO_MONITOR                          ProcToMonitor       = NULL;
    ULONG                                     i,j;
    ULONG                                     NumTasks;
    BOOLEAN                                   Enabled;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SystemInfoBegin; //For the Profile period only
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SystemInfoEnd;   //For the Profile period only
    NTSTATUS                                  Status;
    PTASK_LIST                                tlist;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION StartInfo2;      //For the extra system-wide and process specific information
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION StopInfo2;       //For the extra system-wide and process specific information
//// Beginning of Program-wide Assertions Section
//
//

    //
    // This code does not support UNICODE strings
    //

#if defined(UNICODE) || defined(_UNICODE)
#error This code does not support UNICODE strings!!!
#endif // UNICODE || _UNICODE

//
//
//// End of Program-wide Assertions Section

    //
    // Per user request, set priority up to realtime to accelerate initialization and symbol loading,
    // minimize timing glitches during the profile and post process the data at high priority
    //
    if (bProcessDataHighPriority == TRUE ) {
        SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
    }
    
    InitializeKernrate( argc, argv );

    if(bWaitCreatedProcToSettle == TRUE){ 
        //
        // First Check if the user asked to wait for a key press (ENTER) to wait a created processes to settle
        //
        if(bCreatedProcWaitForUserInput == TRUE){
            FPRINTF(stderr, "\n***> Waiting for created processes to settle (go idle) Please press ENTER when ready\n");
            getchar();
        } else {
        //
        // Wait for a given number of seconds for created processes to settle
        //
            FPRINTF(stderr, "\nWaiting for %d seconds to let created processe(s) settle (go idle)\n", gSecondsToWaitCreatedProc);
            Sleep(1000*gSecondsToWaitCreatedProc);
        }
    }

    StartInfo2 = calloc(1, gSysBasicInfo->NumberOfProcessors*sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION));
    if (StartInfo2 == NULL) {
       FPRINTF(stderr, "KERNRATE: Allocation for SYSTEM_PROCESSOR_PERFORMANCE_INFO(1) failed\n");
       exit(1);
    }
    
    StopInfo2   = calloc(1, gSysBasicInfo->NumberOfProcessors*sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION));
    if (StopInfo2 == NULL) {
       FPRINTF(stderr, "KERNRATE: Allocation for SYSTEM_PROCESSOR_PERFORMANCE_INFO(2) failed\n");
       exit(1);
    }

    SystemInfoBegin = calloc(1, gSysBasicInfo->NumberOfProcessors*sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION));
    if (SystemInfoBegin == NULL) {
       FPRINTF(stderr, "KERNRATE: Allocation for SYSTEM_PROCESSOR_PERFORMANCE_INFO(3) failed\n");
       exit(1);
    }
    
    SystemInfoEnd   = calloc(1, gSysBasicInfo->NumberOfProcessors*sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION));
    if (SystemInfoEnd == NULL) {
       FPRINTF(stderr, "KERNRATE: Allocation for SYSTEM_PROCESSOR_PERFORMANCE_INFO(4) failed\n");
       exit(1);
    }

    InitAllProcessesModulesInfo();

    //
    // Adjust security level to the needed level for system profile
    //

    Status = RtlAdjustPrivilege(SE_SYSTEM_PROFILE_PRIVILEGE, //If ever not sufficient use SE_DEBUG_PRIVILEGE,
                       TRUE,
                       FALSE,
                       &Enabled
                       );

    if( !NT_SUCCESS(Status) ) {
        FPRINTF(stderr,"RtlAdjustPrivilege(SE_PROFILE_PRIVILEGE) failed: %08x\n", Status);
        exit(1);
    }
    //
    // Find the number of Active Sources and store the indices of the active sources
    // To be used later for better performance than going over the whole source list
    //
    ProcToMonitor = gProcessList;
    for (i=0; i < gSourceMaximum; i++) {
        if (ProcToMonitor->Source[i].Interval != 0) {
            gTotalActiveSources += 1;
        }
    }

    gulActiveSources = (PULONG)malloc( gTotalActiveSources*sizeof(ULONG) );
    if (gulActiveSources==NULL) {
        FPRINTF(stderr, "\nMemory allocation failed for ActiveSources in GetConfiguration\n");
        exit(1);
    }

    ProcToMonitor = gProcessList;
    j = 0;
    for (i=0; i < gSourceMaximum; i++) {
        if (ProcToMonitor->Source[i].Interval != 0) {
            gulActiveSources[j] = i;
            ++j;
        }
    }
    //
    // Create necessary profiles for each process
    //
    ProcToMonitor = gProcessList; 
    for (i=0; i<gNumProcToMonitor; i++){  

       if(ProcToMonitor->ModuleList != NULL)
          CreateProfiles(ProcToMonitor->ModuleList, ProcToMonitor);

        ProcToMonitor = ProcToMonitor->Next;
    }
    //
    // Set priority up to realtime to minimize timing glitches during the profile only
    //
    if (bProcessDataHighPriority == FALSE ) {
        SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
    }
    //
    // Check if the user asked to wait for a key press (ENTER) before starting the profile
    //
    if(bWaitForUserInput == TRUE){
       FPRINTF(stderr, "\n***> Please press ENTER to start collecting profile data\n");
       getchar();
    }
    //
    // Check if the user asked to wait for a given number of seconds before starting the profile
    //
    if(gSecondsToDelayProfile != 0){
       FPRINTF(stderr, "\nWaiting for %d seconds before starting to collect profile data\n", gSecondsToDelayProfile);
       Sleep(1000*gSecondsToDelayProfile);
    }

    FPRINTF(stderr, "Starting to collect profile data\n\n"); 

    if (gSleepInterval == 0) {
        FPRINTF(stderr,"***> Press ctrl-c to finish collecting profile data\n");
    } else {
        FPRINTF(stderr, "Will collect profile data for %d seconds\n", gSleepInterval/1000);
    }

    //
    // Wait for test to complete. Obtain any extra system-wide info out of the profile time-span  
    //
    Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                      (PVOID)StartInfo2,
                                      gSysBasicInfo->NumberOfProcessors*sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        FPRINTF(stderr, "Failed to query starting processor performance information %08lx\n",Status);
        exit(Status);
    }
    //
    // Get or update task list information
    //
    if(bIncludeGeneralInfo || bDisplayTaskSummary || (gVerbose & VERBOSE_PROFILING) ) {
         if( gTlistStart == NULL ){
             gTlistStart = calloc(1, gMaxTasks*sizeof(TASK_LIST));
             if ( gTlistStart == NULL ){
                 FPRINTF(stderr, "KERNRATE: Failed to allocate memory for the running processes task list(5)\n");
                 exit(1);
             }
         }
         gNumTasksStart = GetTaskList( gTlistStart, gMaxTasks);
    }

    if(bIncludeSystemLocksInfo)
        GetSystemLocksInformation(START);

    if(bIncludeUserProcLocksInfo){
        ProcToMonitor = gProcessList;
        for (i=0; i<gNumProcToMonitor; i++){  
            if(ProcToMonitor->ProcessHandle != SYM_KERNEL_HANDLE) {
                GetProcessLocksInformation( ProcToMonitor,
                                            RTL_QUERY_PROCESS_LOCKS,
                                            START
                                            );
            }
            ProcToMonitor = ProcToMonitor->Next;
        }
    }

    SetConsoleCtrlHandler(CtrlcH, TRUE);
    CreateDoneEvent();

    if(bIncludeGeneralInfo)
        GetProfileSystemInfo(START);

    Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                      (PVOID)SystemInfoBegin,
                                      gSysBasicInfo->NumberOfProcessors*sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        FPRINTF(stderr, "Failed to query starting processor performance information %08lx\n",Status);
        exit(Status);
    }

    //
    //Execute the actual Profiles
    //
    ExecuteProfiles( bOldSampling );
    gProfilingDone = TRUE;              // used to synchronize the ctrl handler.

    //
    //Obtain end of run system-wide info
    //
    Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                             (PVOID)SystemInfoEnd,
                             gSysBasicInfo->NumberOfProcessors*sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),
                             NULL);
    if (!NT_SUCCESS(Status)) {
        FPRINTF(stderr, "Failed to query ending processor performance information %08lx\n",Status);
        exit(Status);
    }
    
    if(bIncludeGeneralInfo)
        GetProfileSystemInfo(STOP);

    if(bIncludeUserProcLocksInfo){
        ProcToMonitor = gProcessList;
        for (i=0; i<gNumProcToMonitor; i++){  
            if(ProcToMonitor->ProcessHandle != SYM_KERNEL_HANDLE) {
                GetProcessLocksInformation( ProcToMonitor,
                                            RTL_QUERY_PROCESS_LOCKS,
                                            STOP
                                            );
            }
            ProcToMonitor = ProcToMonitor->Next;
        }
    }

    if(bIncludeSystemLocksInfo)
        GetSystemLocksInformation(STOP);

    if(bIncludeGeneralInfo || bDisplayTaskSummary || (gVerbose & VERBOSE_PROFILING) ) {
         tlist = calloc(1, gMaxTasks*sizeof(TASK_LIST));
         if ( tlist == NULL ){
            FPRINTF(stderr, "KERNRATE: Failed to allocate memory for the running processes task list(6)\n");
            exit(1);
         }

         NumTasks = GetTaskList( tlist, gMaxTasks);
        gNumTasksStop = NumTasks;
    }
    Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                      (PVOID)StopInfo2,
                                      gSysBasicInfo->NumberOfProcessors*sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        FPRINTF(stderr, "Failed to query starting processor performance information %08lx\n", Status);
        exit(Status);
    }

    for (i=0; i<(ULONG)gSysBasicInfo->NumberOfProcessors; i++) {

        gTotal2ElapsedTime64.QuadPart += ( (StopInfo2[i].UserTime.QuadPart - StartInfo2[i].UserTime.QuadPart) +
                                           (StopInfo2[i].KernelTime.QuadPart - StartInfo2[i].KernelTime.QuadPart) );
    }
    
    FPRINTF(stderr, "===> Finished Collecting Data, Starting to Process Results\n");
    //
    // Reduce priority unless user asked to process the collected data at high priority
    //
    if (bProcessDataHighPriority == FALSE ) {
        SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    }
    
    //
    // Restore privilege
    //
 
    RtlAdjustPrivilege(SE_SYSTEM_PROFILE_PRIVILEGE,
                       Enabled,
                       FALSE,
                       &Enabled);

    //
    // Output System-Wide information
    //
    DisplaySystemWideInformation( SystemInfoBegin,
                                  SystemInfoEnd
                                  );

    if( SystemInfoBegin != NULL ){
          free(SystemInfoBegin);
          SystemInfoBegin = NULL;
    }
    if( SystemInfoEnd != NULL ){
            free(SystemInfoEnd);
          SystemInfoEnd = NULL;
    }

    //
    // Output results
    //

    if ( bDisplayTaskSummary || (gVerbose & VERBOSE_PROFILING) ) {

        FPRINTF(stdout, "\n--- Process List and Summary At The End of Data Collection ---\n\n");

        if ( bDisplayTaskSummary ) { 

            DisplayRunningTasksSummary (gTlistStart,
                                        tlist
                                        );
        } else {
         
            FPRINTF(stdout, "         Pid                  Process\n");
            FPRINTF(stdout, "       -------                -----------\n");
            for (i=0; i < NumTasks; i++) {
                 FPRINTF(stdout, "%12I64d %32s\n",
                         tlist[i].ProcessId,
                         &tlist[i].ProcessName
                         );
              }
        
        }    
    
    }

    if( StartInfo2 != NULL ){
          free(StartInfo2);
          StartInfo2 = NULL;
    }
    if( StopInfo2 != NULL ){
            free(StopInfo2);
          StopInfo2 = NULL;
    }

    ProcToMonitor = gProcessList; 

    for (i=0; i<gNumProcToMonitor; i++){  

       if(ProcToMonitor->ProcessHandle != SYM_KERNEL_HANDLE){

          FPRINTF(stdout, "\n----------------------------------------------------------------\n\n"); 
          FPRINTF(stdout, "Results for User Mode Process %s (PID = %I64d)\n",
                          ProcToMonitor->ProcessName,
                          ProcToMonitor->Pid
                          );

          if(bIncludeGeneralInfo)
              OutputProcessPerfInfo ( tlist, NumTasks, ProcToMonitor);
          
          if(bIncludeUserProcLocksInfo)
              GetProcessLocksInformation( ProcToMonitor,
                                          RTL_QUERY_PROCESS_LOCKS,
                                          OUTPUT
                                          );
          FPRINTF(stdout, "------------------------------------------------------------------\n\n"); 
          
       }
       else{
          FPRINTF(stdout, "\n-----------------------------\n\n"); 
          FPRINTF(stdout, "Results for Kernel Mode:\n");
          FPRINTF(stdout, "-----------------------------\n\n"); 
          if( bIncludeGeneralInfo && bSystemThreadsInfo )
              OutputProcessPerfInfo( tlist, NumTasks, ProcToMonitor);

       }
       
       OutputResults(stdout, ProcToMonitor);
//MC
       if(ProcToMonitor->ProcessHandle != SYM_KERNEL_HANDLE){
       
          if( ProcToMonitor->JITHeapLocationsStart != NULL ){   //Meaning we do have JIT modules monitored in this process
                                                                //So the Managed Code Helper library is already loaded
              pfnAttachToProcess((DWORD)ProcToMonitor->Pid);
              ProcToMonitor->JITHeapLocationsStop = pfnGetJitRange();
              pfnDetachFromProcess();
              
              OutputJITRangeComparison(ProcToMonitor);
          }
       }
//MC
       ProcToMonitor = ProcToMonitor->Next;

    }

    //
    // Cleanup
    //

    if( tlist != NULL ){
          free(tlist);
        tlist = NULL;
    }

    if(gpProcDummy != NULL){
        free(gpProcDummy);
        gpProcDummy = NULL;
    }

    if(gSymbol != NULL){
        free(gSymbol);
        gSymbol = NULL;
    }

    if(gSysBasicInfo != NULL){
        free(gSysBasicInfo);
        gSysBasicInfo = NULL;
    }

    if(gulActiveSources!= NULL){
        free(gulActiveSources);
        gulActiveSources = NULL;
    }

//MC
    if( ghMCLib != NULL){
        FreeLibrary(ghMCLib);
        ghMCLib = NULL;
    }
//MC

    SetConsoleCtrlHandler(CtrlcH,FALSE);

    FPRINTF(stdout, "================================= END OF RUN ==================================\n");
    FPRINTF(stderr, "============================== NORMAL END OF RUN ==============================\n");
    //
    // Clean up allocated IMAGEHLP resources
    //

    ProcToMonitor = gProcessList; 
    for (i=0; i<gNumProcToMonitor; i++){  
       (void)SymCleanup( ProcToMonitor->ProcessHandle );
       ProcToMonitor = ProcToMonitor->Next;
    }

    if(ghInput != NULL)
        CloseHandle(ghInput);
    if(ghOutput != NULL)
        CloseHandle(ghOutput);
    if(ghError != NULL)
        CloseHandle(ghError);
    //
    // Normal program exit
    //

    return(0);

} // main()

PMODULE
GetProcessModuleInformation(
    IN PPROC_TO_MONITOR ProcToMonitor
    )
{
    PPROCESS_BASIC_INFORMATION BasicInfo;
    PLIST_ENTRY                LdrHead;
    PPEB_LDR_DATA              Ldr                = NULL;
    PPEB_LDR_DATA              LdrAddress;
    LDR_DATA_TABLE_ENTRY       LdrEntry;
    PLDR_DATA_TABLE_ENTRY      LdrEntryAddress;
    PLIST_ENTRY                LdrNext;
    UNICODE_STRING             Pathname;
    const ULONG                PathnameBufferSize = 600*sizeof(WCHAR); 
    PWCHAR                     PathnameBuffer     = NULL;
    UNICODE_STRING             fullPathName;
    PWCHAR                     fullPathNameBuffer = NULL;
    PEB                        Peb;
    NTSTATUS                   Status;
    BOOL                       Success;
    PMODULE                    NewModule;
    PMODULE                    Root               = NULL;
    PCHAR                      ModuleName         = NULL;
    PCHAR                      moduleFullName     = NULL;
    ANSI_STRING                AnsiString;
    HANDLE                     ProcessHandle = ProcToMonitor->ProcessHandle;
//MC
    int                        i, j;
    BOOL                       bMCInitialized = FALSE;
//MC

    //
    // Get Peb address.
    //

    BasicInfo = malloc(sizeof(PROCESS_BASIC_INFORMATION));
    if(BasicInfo == NULL){
        FPRINTF(stderr, "Memory Allocation failed for ProcessBasicInformation in GetProcessModuleInformation\n");
        exit(1);
    }
    
    Status = NtQueryInformationProcess(ProcessHandle,
                                       ProcessBasicInformation,
                                       BasicInfo,
                                       sizeof(PROCESS_BASIC_INFORMATION),
                                       NULL
                                       );
    if (!NT_SUCCESS(Status)) {
        FPRINTF(stderr, "NtQueryInformationProcess failed status %08lx\n", Status);
        ProcToMonitor->ProcessName = "???(May Be gone)";
        goto CLEANUP;
    }
    if (BasicInfo->PebBaseAddress == NULL) {
        FPRINTF(stderr, "GetProcessModuleInformation: process has no Peb.\n");
        ProcToMonitor->ProcessName = "???(May Be gone)";
        goto CLEANUP;
    }

    //
    // Read Peb to get Ldr.
    //

    Success = ReadProcessMemory(ProcessHandle,
                                BasicInfo->PebBaseAddress,
                                &Peb,
                                sizeof(Peb),
                                NULL);
    if (!Success) {
        FPRINTF(stderr, "ReadProcessMemory to get the PEB failed, error %d\n", GetLastError());
        ProcToMonitor->ProcessName = "???(May Be Gone)";
        goto CLEANUP;
    }

    LdrAddress = Peb.Ldr;
    if (LdrAddress == NULL) {
        FPRINTF(stderr, "Process's LdrAddress is NULL\n");
        ProcToMonitor->ProcessName = "???(May Be Gone)";
        goto CLEANUP;
    }

    //
    // Read Ldr to get Ldr entries.
    //
    Ldr = malloc(sizeof(PEB_LDR_DATA));
    if(Ldr == NULL){
        FPRINTF(stderr, "Memory Allocation failed for Ldr in GetProcessModuleInformation\n");
        exit(1);
    }

    Success = ReadProcessMemory(ProcessHandle,
                                LdrAddress,
                                Ldr,
                                sizeof(PEB_LDR_DATA),
                                NULL);
    if (!Success) {
        FPRINTF(stderr, "ReadProcessMemory to get Ldr entries failed, errror %d\n", GetLastError());
        ProcToMonitor->ProcessName = "???(May Be Gone)";
        goto CLEANUP;
    }

    //
    // Read Ldr table entries to get image information.
    //

    if (Ldr->InLoadOrderModuleList.Flink == NULL) {
        FPRINTF(stderr, "Ldr.InLoadOrderModuleList == NULL\n");
        ProcToMonitor->ProcessName = "???(May Be Gone)";
        goto CLEANUP;
    }
    LdrHead = &LdrAddress->InLoadOrderModuleList;
    Success = ReadProcessMemory(ProcessHandle,
                                &LdrHead->Flink,
                                &LdrNext,
                                sizeof(LdrNext),
                                NULL);
    if (!Success) {
        FPRINTF(stderr, "ReadProcessMemory to get Ldr head failed, errror %d\n", GetLastError());
        ProcToMonitor->ProcessName = "???(May Be Gone)";
        goto CLEANUP;
    }

    //
    // Loop through InLoadOrderModuleList.
    //

    PathnameBuffer = (PWCHAR)malloc(PathnameBufferSize);
    if(PathnameBuffer == NULL){
        FPRINTF(stderr, "Memory Allocation failed for PathNameBuffer in GetProcessModuleInformation\n");
        exit(1);
    }
    fullPathNameBuffer = (PWCHAR)malloc( _MAX_PATH*sizeof(WCHAR));
    if(fullPathNameBuffer == NULL){
        FPRINTF(stderr, "Memory Allocation failed for FullPathNameBuffer in GetProcessModuleInformation\n");
        exit(1);
    }

    ModuleName = malloc(cMODULE_NAME_STRLEN*sizeof(CHAR));
    if(ModuleName == NULL){
        FPRINTF(stderr, "Memory Allocation failed for ModuleName in GetProcessModuleInformation\n");
        exit(1);
    }
    moduleFullName = malloc(_MAX_PATH*sizeof(CHAR));
    if(moduleFullName == NULL){
        FPRINTF(stderr, "Memory Allocation failed for ModuleFullName in GetProcessModuleInformation\n");
        exit(1);
    }

    while (LdrNext != LdrHead) {

        LdrEntryAddress = CONTAINING_RECORD(LdrNext,
                                            LDR_DATA_TABLE_ENTRY,
                                            InLoadOrderLinks);

        Success = ReadProcessMemory(ProcessHandle,
                                    LdrEntryAddress,
                                    &LdrEntry,
                                    sizeof(LdrEntry),
                                    NULL);
        if (!Success) {
            FPRINTF(stderr, "ReadProcessMemory to get LdrEntry failed, errror %d\n", GetLastError());
            ProcToMonitor->ProcessName = "???(May Be Gone)";
            goto CLEANUP;
        }

        //
        // Get copy of image name.
        //

        Pathname = LdrEntry.BaseDllName;

        if( Pathname.MaximumLength > PathnameBufferSize ){
            free( PathnameBuffer );                                         //We already know it's not NULL
            PathnameBuffer = (PWCHAR)malloc( Pathname.MaximumLength );
            if(PathnameBuffer == NULL){
                FPRINTF(stderr, "Memory Allocation failed for PathNameBuffer(2) in GetProcessModuleInformation\n");
                exit(1);
            }
        }

        Pathname.Buffer = &PathnameBuffer[0];

        Success = ReadProcessMemory(ProcessHandle,
                                    LdrEntry.BaseDllName.Buffer,
                                    Pathname.Buffer,
                                    Pathname.MaximumLength,
                                    NULL);
        if (!Success) {
            FPRINTF(stderr, "ReadProcessMemory to get image name failed, errror %d\n", GetLastError());
            ProcToMonitor->ProcessName = "???(May Be Gone)";
            goto CLEANUP;
        }

        //
        // Get Copy of image full pathname
        //

        fullPathName = LdrEntry.FullDllName;
        
        if( fullPathName.MaximumLength > _MAX_PATH*sizeof(WCHAR) ){
            free( fullPathNameBuffer );                                   //We already know it's not NULL
            fullPathNameBuffer = (PWCHAR)malloc( fullPathName.MaximumLength );
            if(fullPathNameBuffer == NULL){
                FPRINTF(stderr, "Memory Allocation failed for FullPathNameBuffer(2) in GetProcessModuleInformation\n");
                exit(1);
            }
        }
 
        fullPathName.Buffer = fullPathNameBuffer;

        Success = ReadProcessMemory( ProcessHandle,
                                     LdrEntry.FullDllName.Buffer,
                                     fullPathName.Buffer,
                                     fullPathName.MaximumLength,
                                     NULL
                                   );

        if (!Success) {
            FPRINTF(stderr, "ReadProcessMemory to get image full path name failed, errror %d\n", GetLastError());
            ProcToMonitor->ProcessName = "???(May Be Gone)";
            goto CLEANUP;
        }

        //
        // Create module
        //
        
        AnsiString.Buffer        = ModuleName;
        AnsiString.MaximumLength = cMODULE_NAME_STRLEN*sizeof(CHAR);
        AnsiString.Length        = 0;
        Status = RtlUnicodeStringToAnsiString(&AnsiString, &Pathname, cDONOT_ALLOCATE_DESTINATION_STRING);
        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr, "KERNRATE WARNING:\n");
            FPRINTF(stderr, "RtlUnicodeStringToAnsiString failed in GetProcessModuleInformation, status= %08lx\n", Status);
            if(Status == STATUS_BUFFER_OVERFLOW){
                FPRINTF(stderr, "Source String: %S\nLength= %ld", &Pathname.Buffer, Pathname.Length); 
                FPRINTF(stderr, "Maximum destination string Length allowed is %d\n", cMODULE_NAME_STRLEN);

            }
        }
        ModuleName[AnsiString.Length] = '\0';

        AnsiString.Buffer = moduleFullName;
        AnsiString.MaximumLength = _MAX_PATH*sizeof(CHAR);
        AnsiString.Length        = 0;
        Status = RtlUnicodeStringToAnsiString(&AnsiString, &fullPathName, cDONOT_ALLOCATE_DESTINATION_STRING );
        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr, "KERNRATE WARNING:\n");
            FPRINTF(stderr, "RtlUnicodeStringToAnsiString failed in GetProcessModuleInformation, status= %08lx\n", Status);
            if(Status == STATUS_BUFFER_OVERFLOW){
                FPRINTF(stderr, "Source String: %S\nLength= %ld", &fullPathName.Buffer, fullPathName.Length); 
                FPRINTF(stderr, "Maximum destination string Length allowed is %d\n", _MAX_PATH);

            }
        }
        moduleFullName[AnsiString.Length] = '\0';
        
        NewModule = CreateNewModule(ProcToMonitor,
                                    ModuleName,
                                    moduleFullName,
                                    (ULONG64)LdrEntry.DllBase,
                                    LdrEntry.SizeOfImage);

        if( NewModule != NULL){
            ProcToMonitor->ModuleCount += 1;

            NewModule->Next = Root;
            Root = NewModule;

            LdrNext = LdrEntry.InLoadOrderLinks.Flink;
        }else{
            FPRINTF(stderr, "KERNRATE: Failed to create new module for %s\n", ModuleName);
        }    
        
        //
        //The first module in the LDR InLoadOrder module list is the Process
        //

        if(ProcToMonitor->ModuleCount == 1){
           PCHAR Name = calloc(1, cMODULE_NAME_STRLEN*sizeof(CHAR)); 
           if(Name != NULL){
              strncpy(Name, ModuleName, cMODULE_NAME_STRLEN-1);
              Name[ cMODULE_NAME_STRLEN-1 ] = '\0';
              ProcToMonitor->ProcessName = _strupr(Name);
           }
        }        
//MC
        //
        // Initialize Managed Code Support if Managed Code main library is present 
        //
        if( !_stricmp(ModuleName, MANAGED_CODE_MAINLIB) ){
            
            bMCInitialized = InitializeManagedCodeSupport( ProcToMonitor );
            if( !bMCInitialized ){
                FPRINTF(stderr, "\nKERNRATE: Failed to Initialize Support for Managed Code for Pid = %I64d\n", ProcToMonitor->Pid);
                FPRINTF(stderr, "Use Verbose Level 4 for More Details\n");
            }

        }
//MC
    }// while (LdrNext != LdrHead)

//MC
    //
    // If Managed Code helper lib is loaded and we do have JIT ranges present, let's create a module for each
    //
    if( bMCInitialized && bMCJitRangesExist ){
        i = 0;
        j = 0;

        while( ProcToMonitor->JITHeapLocationsStart[i] != 0 ){

            _snprintf( ModuleName, cMODULE_NAME_STRLEN*sizeof(CHAR)-1, "JIT%d", j );
            VerbosePrint((VERBOSE_INTERNALS, "KERNRATE: Creating JIT module %s\n", ModuleName)); 
            strncpy(moduleFullName, "JIT_TYPE", cMODULE_NAME_STRLEN-1);
            NewModule = CreateNewModule(ProcToMonitor,
                                        ModuleName,
                                        moduleFullName, //"JIT_TYPE",
                                        (ULONG64)ProcToMonitor->JITHeapLocationsStart[i] ,
                                        (ULONG)ProcToMonitor->JITHeapLocationsStart[i+1]
                                        );
            
            if(NewModule != NULL){

                ProcToMonitor->ModuleCount += 1;
        
                NewModule->Next = Root;
                Root = NewModule;

            }else{
                FPRINTF(stderr, "KERNRATE: Failed to create new JIT module for %s\n", ModuleName);
            }

            i += 2;
            j += 1;

        }
    }
//MC
    //
    // Cleanup
    //
CLEANUP:

    if(BasicInfo != NULL){
        free(BasicInfo);
        BasicInfo = NULL;
    }

    if(Ldr != NULL){
        free(Ldr);
        Ldr = NULL;
    }

    if(PathnameBuffer != NULL){
        free(PathnameBuffer);
        PathnameBuffer = NULL;
    }

    if(fullPathNameBuffer != NULL){
        free(fullPathNameBuffer);
        fullPathNameBuffer = NULL;
    }

    if(ModuleName != NULL){
        free(ModuleName);
        ModuleName = NULL;
    }

    if(moduleFullName != NULL){
        free(moduleFullName);
        moduleFullName = NULL;
    }

    return(Root);

} // GetProcessModuleInformation()

PMODULE
GetKernelModuleInformation(
    VOID
    )
{
    PRTL_PROCESS_MODULES      modules;
    PUCHAR                    buffer;
    ULONG                     bufferSize = 1*1024*1024;    //not a constant!
    ULONG                     i;
    PMODULE                   root       = NULL;
    PMODULE                   newModule;
    NTSTATUS                  status;

    do {
        buffer = malloc(bufferSize);
        if (buffer == NULL) {
            FPRINTF(stderr, "Buffer Allocation failed for ModuleInformation in GetKernelModuleInformation\n");
            exit(1);
        }

        status = NtQuerySystemInformation(SystemModuleInformation,
                                          buffer,
                                          bufferSize,
                                          &bufferSize);
        if (NT_SUCCESS(status)) {
            break;
        }

        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            free(buffer);
            buffer = NULL;
        } else {
            FPRINTF(stderr, "GetKernelModuleInformation failed call to get SystemModuleInformation - ");
            if(status == STATUS_WORKING_SET_QUOTA)
               FPRINTF(stderr, "Insufficient process working set\n");
            if(status == STATUS_INSUFFICIENT_RESOURCES)
               FPRINTF(stderr, "Insufficient system resources\n");
            exit(1);
        } 
        
    } while (buffer == NULL);

#ifdef _WIN64
#define VerboseModuleFormat "start            end              "
#else  // !_WIN64
#define VerboseModuleFormat "start        end          "
#endif // !_WIN64
VerbosePrint(( VERBOSE_MODULES, "Kernel Modules ========== System HighestUserAddress = 0x%p\n"
                                VerboseModuleFormat
                                "module name [full name]\n",
                                (PVOID)gSysBasicInfo->MaximumUserModeAddress
            ));

#undef VerboseModuleFormat

    modules = (PRTL_PROCESS_MODULES)buffer;
    gKernelModuleCount = modules->NumberOfModules;
    for (i=0; i < gKernelModuleCount; i++) {
        PRTL_PROCESS_MODULE_INFORMATION Module;
        Module = &modules->Modules[i];

        if ((ULONG_PTR)Module->ImageBase > gSysBasicInfo->MaximumUserModeAddress) {
            newModule = CreateNewModule(gpSysProc,
                                        (PCHAR)(Module->FullPathName+Module->OffsetToFileName),
                                        (PCHAR)Module->FullPathName,
                                        (ULONG64)(ULONG_PTR)Module->ImageBase,
                                        Module->ImageSize);
            assert( newModule );
            newModule->Next = root;
            root = newModule;
        }
        else {

#define VerboseModuleFormat "0x%p 0x%p "

VerbosePrint(( VERBOSE_MODULES, VerboseModuleFormat " %s [%s] - Base > HighestUserAddress\n",
                                (PVOID)Module->ImageBase,
                                (PVOID)((ULONG64)Module->ImageBase + (ULONG64)Module->ImageSize),
                                Module->FullPathName+Module->OffsetToFileName,
                                Module->FullPathName
            ));

#undef VerboseModuleFormat

        }
    }
    //
    // Cleanup
    //
 
    if(buffer != NULL){
        free(buffer);
        buffer = NULL;
    }

    return(root);

} // GetKernelModuleInformation()

VOID
CreateProfiles(
    IN PMODULE Root,
    IN PPROC_TO_MONITOR ProcToMonitor
    )
{
    PMODULE         Current;
    KPROFILE_SOURCE ProfileSource;
    NTSTATUS        Status;
    PRATE_DATA      Rate;
    ULONG           ProfileSourceIndex, Index;
    ULONG           BucketsNeeded;
    HANDLE          hProc               = NULL;
    KAFFINITY       AffinityMask        = (KAFFINITY)-1;
    LONG            CpuNumber;
    //
    // To get the kernel profile NtCreateProfile has to be called with hProc = NULL
    //    
    hProc = (ProcToMonitor->ProcessHandle == SYM_KERNEL_HANDLE)? NULL : ProcToMonitor->ProcessHandle; 
    for (Index=0; Index < gTotalActiveSources; Index++) {
        ProfileSourceIndex = gulActiveSources[Index];
        ProfileSource = ProcToMonitor->Source[ProfileSourceIndex].ProfileSource;
        Current = Root;
        while (Current != NULL) {
                
            BucketsNeeded = BUCKETS_NEEDED(Current->Length);

            Rate                             = &Current->Rate[ProfileSourceIndex];
                
            Rate->TotalCount                 = calloc(gProfileProcessors,  sizeof(ULONGLONG) );
            if(Rate->TotalCount == NULL){
                FPRINTF(stderr, "KERNRATE: Memory allocation failed for TotalCount in CreateProfiles\n");
                    exit(1);
            }

            Rate->CurrentCount               = calloc(gProfileProcessors,  sizeof(ULONG) );
            if(Rate->CurrentCount == NULL){
                FPRINTF(stderr, "KERNRATE: Memory allocation failed for CurrentCount in CreateProfiles\n");
                exit(1);
            }

            Rate->ProfileHandle              = calloc(gProfileProcessors,  sizeof(HANDLE) ); 
            if(Rate->ProfileHandle == NULL){
                FPRINTF(stderr, "KERNRATE: Memory allocation failed for ProfileHandle in CreateProfiles\n");
                exit(1);
            }

            Rate->ProfileBuffer              = calloc(gProfileProcessors,  sizeof(PULONG) );
            if(Rate->ProfileBuffer == NULL){
                FPRINTF(stderr, "KERNRATE: Memory allocation failed for ProfileBuffer in CreateProfiles\n");
                exit(1);
            }

            Rate->StartTime                  = 0;
            Rate->TotalTime                  = 0;
            Rate->Rate                       = 0;
            Rate->GrandTotalCount            = 0;

            for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                if ( bProfileByProcessor ){
                    AffinityMask = (1 << CpuNumber);
                }
 
                Rate->TotalCount[CpuNumber]      = 0;
                Rate->CurrentCount[CpuNumber]    = 0;
                if (Current->bZoom) {
                        
                    Rate->ProfileBuffer[CpuNumber] = calloc(1, BucketsNeeded*sizeof(ULONG));
                    if (Rate->ProfileBuffer[CpuNumber] == NULL) {
                        FPRINTF(stderr,
                                "KERNRATE: Memory allocation failed for Zoom buffer, Module: %s\n",
                                Current->module_Name
                                );
                        exit(1);
                    }
                if ( !gAffinityMask || (AffinityMask & gAffinityMask) ) {
    
                    Status = NtCreateProfile(&Rate->ProfileHandle[CpuNumber],
                                             hProc,
                                             (PVOID64)Current->Base,
                                             Current->Length,
                                             gLog2ZoomBucket,
                                             Rate->ProfileBuffer[CpuNumber],
                                             sizeof(ULONG)*BucketsNeeded,
                                             ProfileSource,
                                             AffinityMask
                                             ); 

                    if (!NT_SUCCESS(Status)) {
                        FPRINTF(stderr,
                                "NtCreateProfile on zoomed module %s, source %d failed %08lx\n",
                                Current->module_Name,
                                ProfileSource,
                                Status
                                );
                        FPRINTF(stderr,
                                "Base %p\nLength %08lx\nBufferLength %08lx\n",
                                (PVOID64)Current->Base,
                                Current->Length,
                                BucketsNeeded
                                );

                        exit(1);
                    }
                    else if ( gVerbose & VERBOSE_PROFILING )   {
                        FPRINTF(stderr,
                                "Created zoomed profiling on module %s with source: %s\n",
                                Current->module_Name,
                                ProcToMonitor->Source[ProfileSourceIndex].ShortName
                                );
                    }
                }
                } else {

                    Status = NtCreateProfile(&Rate->ProfileHandle[CpuNumber],
                                             hProc,
                                             (PVOID64)Current->Base,
                                             Current->Length,
                                             31,
                                             &Rate->CurrentCount[CpuNumber],
                                             sizeof(Rate->CurrentCount[CpuNumber]),
                                             ProfileSource,
                                             AffinityMask
                                             );

                    if (!NT_SUCCESS(Status)) {
                        FPRINTF(stderr,
                                "NtCreateProfile on module %s, source %d failed %08lx\n",
                                Current->module_Name,
                                ProfileSource,
                                Status
                                );
                        exit(1);
                    }
                    else if ( gVerbose & VERBOSE_PROFILING )   {
                        FPRINTF(stderr,
                                "Created profiling on module %s with source: %s\n",
                                Current->module_Name,
                                ProcToMonitor->Source[ProfileSourceIndex].ShortName
                                );
                    }
                }
            } // CpuNumber
            Current = Current->Next;
        } // Module list
    } // ProfileSourceIndex
}

static void
SetModuleName( PMODULE Module, PCHAR szName )
{

    assert ( Module );
    assert ( szName );

    (void)strncpy( Module->module_Name, szName, sizeof(Module->module_Name) - 1 );
    Module->module_Name[lstrlen(Module->module_Name)] = '\0';
    return;

} // SetModuleName()

VOID
GetConfiguration(
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Gets configuration for this run.

Arguments:

    None

Return Value:

    None, exits on failure.

--*/

{
    DWORD            NumTasks, m;
    CHAR             tmpName[USER_SYMPATH_LENGTH]; 
    NTSTATUS         Status;
    PPROC_TO_MONITOR ProcToMonitor          = NULL;
    PMODULE          ZoomModule;
    PMODULE          tmpModule;
    LONGLONG         Pid;
    int              i, j, k;
    int              tJump                  = 0;
    HANDLE           SymHandle;
    ULONG            MaxProcSameName        = MAX_PROC_SAME_NAME;
    ULONG            ProfileSourceIndex;
    ULONG            IDataCommonRate;
    ULONG            SourcesSoFar           = 1;     //Source TIME is on by default
    ULONG            ulVerbose;
    BOOL             bZoomSpecified         = FALSE;
    BOOL             bTlistInitialized      = FALSE;
    BOOL             tlistVerbose           = FALSE;
    BOOL             tlistDisplayed         = FALSE;
    INPUT_ERROR_TYPE ietResult;
    //
    // Assume system wide profile.
    //
    gProfileProcessors = 1;

    //
    // The following preliminary-check purpose is to get rid of most command line precedence rules
    //
    for (i=1; i < argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            switch ( toupper(argv[i][1]) ) {
                case 'E':
                    //
                    // User asked to exclude system-wide and process specific general information
                    // (context switches, memory usage, etc.)
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "",
                                             NULL,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );
                    if(ietResult == INPUT_GOOD){ 
                        bIncludeGeneralInfo = FALSE;
                    } else if (ietResult == BOGUS_ENTRY){
                        ExitWithUnknownOptionMessage(argv[i+1]);
                    } else {   
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    break;
                    
                case 'M':
                    //
                    // Do multi-processor profile. Allow optional processor affinity mask to be able to
                    // profile only selected processors and reduce profiling overhead on 64 and 32 way.
                    //
                    // The following precedence rule check allows to save some memory footprint
                    // by allocating the zoom module based on the actual gProfileProcessors instead
                    // of the total NumberOfProcessors
                    //  
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "#",
                                             NULL,
                                             tmpName,             //Just used as a temp storage
                                             USER_SYMPATH_LENGTH, //with long enough space
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );

                    if(ietResult == MISSING_REQUIRED_NUMBER){ //Allow a # although the optional mask is initially treated as a string
                        if(i+1 < argc && argv[i+1][0] == '0' && argv[i+1][1] == 'x' || argv[i+1][1] == 'X'){
                            ietResult = INPUT_GOOD;
                        } else {
                            FPRINTF(stderr, "KERNRATE: '-m# 0xN' option requires a valid (0x prefixed) hex number\n");
                            ExitWithUnknownOptionMessage(argv[i+1]);
                        }
                    }
                    
                    if(ietResult == INPUT_GOOD){
                        ULONG LowMask, HighMask;
                        int nChars, iStart=0, iProc;
                        PCHAR cStart = NULL;
                        CHAR tmpstr[8] = ""; 
                        bProfileByProcessor = TRUE;
                        gProfileProcessors = gSysBasicInfo->NumberOfProcessors;

                        nChars = lstrlen(tmpName);
                        cStart = tmpName;
                        if( 'x' == tmpName[1] || 'X' == tmpName[1] ){
                            cStart = &tmpName[2];
                            nChars -= 2;
                        } else if ( 'x' == tmpName[0] || 'X' == tmpName[0] ){
                            cStart = &tmpName[1];
                            nChars -= 1;
                        }
                        if( nChars > 16 || (gProfileProcessors <= 32 && nChars > 8) ){
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Expecting a valid HEX value, maximum 8 characters for up to 32 processors\nor 16 characters for up to 64 processors",
                                                FALSE,
                                                TRUE
                                                );
                        }

                        if( nChars > 8 ){
                            strncpy(tmpstr, cStart, nChars-8);
                            HighMask = strtoul(tmpstr, NULL, 16);
                            iStart = nChars-8+1;
                        }
                        strncpy(tmpstr, &cStart[iStart], (nChars<=8)? nChars:8 );
                        LowMask = strtoul(tmpstr, NULL, 16);
                            
                        gAffinityMask = (nChars<=8)? (KAFFINITY)LowMask:( (((KAFFINITY)HighMask) << 32) +(KAFFINITY)LowMask ) ;

                        if( gAffinityMask == 0 ){
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Expecting a valid HEX value, maximum 8 characters for up to 32 processors\nor 16 characters for up to 64 processors",
                                                FALSE,
                                                TRUE
                                                );
                        }                            
                        FPRINTF(stdout, "\nUser defined CPU affinity mask for profiling= 0x%p\n", (PVOID)gAffinityMask);
                        FPRINTF(stdout, "This will profile the following processors:\n");
                        for( iProc=0; iProc<gProfileProcessors; iProc++){
                            if((1 << iProc) & gAffinityMask)
                                FPRINTF(stdout, "P%d, ", iProc);
                        }
                        FPRINTF(stdout,"\n");
                        ++i;
                        
                    } else if (ietResult == MISSING_STRING){
                        bProfileByProcessor = TRUE;
                        gProfileProcessors = gSysBasicInfo->NumberOfProcessors;
                    } else if (ietResult == BOGUS_ENTRY){
                        ExitWithUnknownOptionMessage(argv[i+1]);
                    } else {   
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    break;

                default:
                    break;
            }
        } else {                  //if ((argv[i][0] == '-') || (argv[i][0] == '/'))
            if( !strchr(argv[i], '{') ){
                continue;
            } else {              //Exclude any command options in the curly brackets  
                while( i < argc && !strchr(argv[i], '}') ){
                    ++i;
                }
            }
        }
    }

    for (i=1; i < argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            switch ( toupper(argv[i][1]) ) {
                case 'T':
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "#",
                                             &gMaxTasks,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );

                    if(ietResult == INPUT_GOOD){
                        //
                        // User also wants to change the maximum number of tasks in the task list from Kernrate's default number
                        //
                        if (gMaxTasks == 0) {
                                InvalidEntryMessage(argv[i],
                                                    argv[i+1],
                                                    "Expecting a decimal number >0",
                                                    FALSE,
                                                    TRUE
                                                    );
                        }
                        FPRINTF(stdout, "---> Kernrate task list set to accommodate %ld processes\n", gMaxTasks);
                        tJump = 1;;
                    } else if(ietResult == MISSING_PARAMETER || ietResult == MISSING_NUMBER) {        //Allowed
                        //
                        //User just wants task summary without changing the default maximum number of tasks
                        //
                    } else if(ietResult == MISSING_REQUIRED_NUMBER){
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-t# N' option requires the maximum (decimal) number of processes in Kernrate's task list",
                                                    FALSE
                                                    );
                    } else if(ietResult == INVALID_NUMBER) {
                        InvalidEntryMessage(argv[i],
                                            argv[i+1],
                                            "Expecting a decimal value >0 in [ms], 0 < N < 10^9",
                                            FALSE,
                                            TRUE
                                            );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    bDisplayTaskSummary = TRUE;

                default:
                    break;
            }
        } else {                  //if ((argv[i][0] == '-') || (argv[i][0] == '/'))
            if( !strchr(argv[i], '{') ){
                continue;
            } else {              //Exclude any command options in the curly brackets  
                while( i < argc && !strchr(argv[i], '}') ){
                    ++i;
                }
            }
        }
    }

    for (i=1; i < argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            BOOL bIncludeProcessThreadsInfo = FALSE;
            switch ( toupper(argv[i][1]) ) {

                case 'A':
                    //
                    // Do both Kernel and User mode profiling
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "v",
                                             NULL,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY);
                    if(ietResult == INPUT_GOOD){ 

                        bCombinedProfile = TRUE; 
                        FPRINTF(stdout, "\n---> Profiling both Kernel and User Modes\n");
                        //
                        // Check if extra options are present
                        //
                        if( strchr(argv[i], 'v') || strchr(argv[i], 'V') ){
                            //
                            // User wants system threads information
                            //

                            tlistVerbose        = TRUE;
                            bSystemThreadsInfo  = TRUE;
                        }

                    } else if (ietResult == BOGUS_ENTRY){
                        ExitWithUnknownOptionMessage(argv[i+1]);
                    } else {   
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    if( bIncludeGeneralInfo || tlistVerbose) { 

                        if ( (!bTlistInitialized && tlistVerbose) || (bSystemThreadsInfo == TRUE && bIncludeThreadsInfo == FALSE) ) {
                            //
                            // If we already took a tlist but that's the first time thread info is required,
                            // we'll have to refresh it and take thread info as well
                            //
                            if( bSystemThreadsInfo == TRUE && bIncludeThreadsInfo == FALSE ){
                                bIncludeThreadsInfo = TRUE;
                            }

                            //
                            // get the task list for the system (this is needed to identify the System Process ID)
                            //
                            if ( !bTlistInitialized ) {
                                gTlistStart = calloc(1, gMaxTasks*sizeof(TASK_LIST));
                                if (gTlistStart == NULL) {
                                    FPRINTF(stderr, "\nKERNRATE: Allocation of memory for the running processes task list failed(1)\n");
                                    exit(1);
                                }
                            }
                        
                            NumTasks = GetTaskList( gTlistStart, gMaxTasks );
                            bTlistInitialized = TRUE;
                            gNumTasksStart = NumTasks;
                        }
                    }

                    if( bTlistInitialized && tlistVerbose ){
                        if( tlistDisplayed == FALSE ){
                            FPRINTF(stdout, "\nRunning processes found before profile start:\n");  
                            FPRINTF(stdout, "         Pid                  Process\n");
                            FPRINTF(stdout, "       -------                -----------\n");

                            for (m=0, k=0; m < NumTasks; m++) {
                                FPRINTF(stdout, "%12I64d %32s\n",
                                                gTlistStart[m].ProcessId,
                                                gTlistStart[m].ProcessName
                                                );
                            }

                            if( tlistDisplayed == FALSE ){
                                FPRINTF(stdout, "\nNOTE: The list above may be missing some or all processes created by the '-o' option\n"); 
                                //
                                //Lets not get carried away if the user specified the verbose option more than once...
                                //
                                tlistDisplayed = TRUE;
                                tlistVerbose = FALSE;    
                            }
                        }
                    }
                    break;

                case 'B':

                    //
                    // Set Zoom Bucket Size
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "#",
                                             &gZoomBucket,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_NONE
                                             );

                    if(ietResult == INPUT_GOOD){

                        if (gZoomBucket == 0) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Invalid bucket size, expecting a decimal value\nBucket size must be power of 2, minimum bucket size is 4",
                                                FALSE,
                                                TRUE
                                                );
                        }

                        for (gLog2ZoomBucket=1; (1UL<<gLog2ZoomBucket) < gZoomBucket; gLog2ZoomBucket++)
                            // Empty Loop
                            ;
    
                        if ( ( gZoomBucket < MINIMUM_ZOOM_BUCKET_SIZE ) || ( gZoomBucket != (1UL<<gLog2ZoomBucket) ) ) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Bucket size must be power of 2, minimum bucket size is 4",
                                                FALSE,
                                                TRUE
                                                );
                        }
                        ++i;
                        
                    } else if(ietResult == MISSING_PARAMETER || ietResult == MISSING_NUMBER) {
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-b N' option requires bucket size (minimum 4 bytes), space separated",
                                                    FALSE
                                                    );
                    } else if(ietResult == MISSING_REQUIRED_NUMBER){
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-b# N' option requires bucket size (minimum 4 bytes), space separated",
                                                    FALSE
                                                    );
                    } else if(ietResult == INVALID_NUMBER) {
                        InvalidEntryMessage(argv[i],
                                            argv[i+1],
                                            "Invalid bucket size, expecting a decimal value\nBucket size must be power of 2, minimum bucket size is 4",
                                            FALSE,
                                            TRUE
                                            );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    
                    FPRINTF(stdout, "---> Profile Bucket Size Set to %u bytes\n", gZoomBucket);
                            
                    break;

                case 'C':
                    //
                    //Use old sampling scheme (sample one source at a time, switch between sources (and monitored processes)
                    //every gChangeInterval in ms). If not specified, all sources will be turned on simultaneously.
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "#",
                                             &gChangeInterval,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );

                    if(ietResult == INPUT_GOOD){
                        //
                        // User wants to sample cyclically one source at a time and also to specify the interval
                        //
                        if (gChangeInterval == 0) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Expecting a decimal value >0 in [ms], 0 < N < 10^9",
                                                FALSE,
                                                TRUE
                                                );
                        }
                        ++i;
                    } else if(ietResult == MISSING_PARAMETER || ietResult == MISSING_NUMBER) {        //Allowed
                        //
                        // User wants to sample cyclically one source at a time using the default interval
                        //
                    } else if(ietResult == MISSING_REQUIRED_NUMBER){
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-c# N' option requires a decimal value in [ms], 0 < N < 10^9",
                                                    FALSE
                                                    );
                    } else if(ietResult == INVALID_NUMBER) {
                        InvalidEntryMessage(argv[i],
                                            argv[i+1],
                                            "Expecting a decimal value >0 in [ms], 0 < N < 10^9",
                                            FALSE,
                                            TRUE
                                            );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    bOldSampling = TRUE;
                    FPRINTF(stdout, "---> Using Cyclic Sampling Scheme (Profiling One Source At A time)\n");
                    FPRINTF(stdout, "Change Interval between Profile Sources Set to %u[ms]\n", gChangeInterval); 

                    break;

                case 'D':
                    //
                    // Output data rounding up and down
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "",
                                             NULL,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );
                    if(ietResult == INPUT_GOOD){ 
                        FPRINTF(stdout, "---> Will output data rounding bucket addresses up and down\n");
                        bRoundingVerboseOutput = TRUE;
                    } else if (ietResult == BOGUS_ENTRY){
                        ExitWithUnknownOptionMessage(argv[i+1]);
                    } else {   
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    break;

                case 'E':
                    //
                    // We already dealt with this command line parameter in the first loop
                    //
                    break;
                     
                case 'F':
                    //
                    // User asked to Finish processing the collected data at high priority
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "",
                                             NULL,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );
                    if(ietResult == INPUT_GOOD){ 
                        bProcessDataHighPriority = TRUE;
                    } else if (ietResult == BOGUS_ENTRY){
                        ExitWithUnknownOptionMessage(argv[i+1]);
                    } else {   
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    break;

                case 'G':
                    //
                    // User wants interesing data statistics so we need to turn on all related sources
                    //
                    {
                        int IDataElements = sizeof(IData)/sizeof(KPROFILE_SOURCE);
                        ietResult = IsInputValid(argc,
                                                 i,
                                                 argv,
                                                 "#",
                                                 &IDataCommonRate,
                                                 NULL,
                                                 0,
                                                 ORDER_ANY,
                                                 OPTIONAL_ANY
                                                 );

                        if(ietResult == INPUT_GOOD){
                            //
                            // User wants interesting data statistics and also to specify the common sampling interval
                            //
                            if (IDataCommonRate == 0) {
                                InvalidEntryMessage(argv[i],
                                                    argv[i+1],
                                                    "Expecting decimal value >0 of events/hit, 0 < N < 10^9, space separated",
                                                    FALSE,
                                                    TRUE
                                                    );
                            }
                            ++i;
                        } else if(ietResult == MISSING_PARAMETER || ietResult == MISSING_NUMBER) { //Allowed
                            //
                            // User wants interesting data statistics using a default common sampling interval
                            //
                            IDataCommonRate = gpProcDummy->Source[IData[0]].DesiredInterval;       //Use a default interval
                        } else if(ietResult == MISSING_REQUIRED_NUMBER){
                            ExitWithMissingEntryMessage(argv[i],
                                                        "'-g# N' option requires a decimal value >0 of events/hit, 0 < N < 10^9",
                                                        FALSE
                                                        );
                        } else if(ietResult == INVALID_NUMBER) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Expecting a decimal value >0 in [ms], 0 < N < 10^9",
                                                FALSE,
                                                TRUE
                                                );
                        } else if(ietResult == UNKNOWN_OPTION) {
                            ExitWithUnknownOptionMessage(argv[i]);
                        }

                        if ( IDataElements > 1 && gpProcDummy->Source[IData[0]].DesiredInterval > 0) {
                            for (j=1; j < IDataElements; j++) {
                                if ( gpProcDummy->Source[IData[j]].DesiredInterval > 0 )
                                    IDataCommonRate = min(IDataCommonRate, gpProcDummy->Source[IData[j]].DesiredInterval);
                            }

                            FPRINTF(stdout, "---> Will attempt to set common profiling rate for interesting data statistics to %ld Events/Hit\n",
                                            IDataCommonRate
                                            ); 
                    
                            for (j=0; j < IDataElements; j++) {
                                gpProcDummy->Source[IData[j]].Interval = IDataCommonRate;
                            }
                            
                            bGetInterestingData = TRUE;
                            bOldSampling = TRUE;
                            FPRINTF(stdout, "---> Using Cyclic Sampling Scheme (Profiling One Source At A time)\n");

                        } else {
                            FPRINTF(stderr, "\nKERNRATE: Interesting processor-counters statistics cannot be collected on this machine\n");
                        }
                    }

                    break;

                case 'I':
                   {

                       //  We'll consider -I option as global for all processes to be profiled
                       // User may have put -I on the command line before any process profile source has been initialized
                       // We therefore supply a valid pointer to just get and store the information for later use

                       ULONG rate;
                       BOOL found;

                       ietResult = IsInputValid(argc,
                                                i,
                                                argv,
                                                "#",
                                                &rate,
                                                tmpName,             //Just used as a temp storage
                                                USER_SYMPATH_LENGTH, //with long enough space
                                                ORDER_ANY,
                                                OPTIONAL_ANY
                                                );

                       if(ietResult == INPUT_GOOD){
                           //
                           // Standard option processing (both name and rate present)
                           //                    
                           i += 2; // two parameters exist (number and string)

                       } else if(ietResult == MISSING_PARAMETER){
                           ExitWithMissingEntryMessage(argv[i],
                                                       "'-i Source_Name Rate' option requires at least a source name or a rate value (or both), space separated",
                                                       TRUE
                                                       );
                       } else if(ietResult == MISSING_STRING) {    //allowed
                           //
                           // The user can specify '-i' with a rate only.
                           // In this case, SOURCE_TIME is used.
                           //
                           if ( rate == 0 ) {
                               SourcesSoFar -= 1; //Default was 1
                           }
                           gpProcDummy->Source[SOURCE_TIME].Interval = rate;
                           ++i;   // one parameter exists (number)
                           break; // We are done here
                       } else if(ietResult == MISSING_NUMBER) {    //alowed
                           ++i;   // one parameter exists (string)
                       } else if(ietResult == MISSING_REQUIRED_NUMBER){
                            ExitWithMissingEntryMessage(argv[i],
                                                        "'-i# Source_Name Rate' option requires a rate value for the source interval, 0 < N < 10^9 (Source_Name optional)",
                                                        FALSE
                                                        );
                       } else if(ietResult == INVALID_NUMBER) {
                           InvalidEntryMessage(argv[i+1],
                                               argv[i+2],
                                               "'-i Source_Name Rate' - Invalid source interval, expecting a number 0 < N < 10^9, space separated",
                                               FALSE,
                                               TRUE
                                               );
                       } else if(ietResult == UNKNOWN_OPTION) {
                           ExitWithUnknownOptionMessage(argv[i]);
                       }

                       //
                       // Standard option processing:
                       // The source shortname string is specified. If not followed by a rate amount 
                       //    we'll assume the user wants the default rate

                       found = FALSE;

                       for ( ProfileSourceIndex = 0; ProfileSourceIndex < gSourceMaximum; ProfileSourceIndex++)   {
                           if ( !_stricmp(gpProcDummy->Source[ProfileSourceIndex].ShortName, tmpName) )    {

                               if (ietResult == MISSING_NUMBER || ietResult == MISSING_REQUIRED_NUMBER) { // If no rate specified, 
                                   gpProcDummy->Source[ProfileSourceIndex].Interval = gpProcDummy->Source[ProfileSourceIndex].DesiredInterval;
                               } else {
                                   gpProcDummy->Source[ProfileSourceIndex].Interval = rate;
                               }

                               if ( (ProfileSourceIndex > SOURCE_TIME) && (gpProcDummy->Source[ProfileSourceIndex].Interval > 0) ) {
                                   SourcesSoFar += 1;
                               } else if ( (ProfileSourceIndex == SOURCE_TIME) && (gpProcDummy->Source[ProfileSourceIndex].Interval == 0) ) {
                                   SourcesSoFar -= 1;                                           //Start value was 1 by default
                               }
                               found = TRUE;

                               break;
                           }

                       }

                       if ( found == FALSE)   {
                           InvalidEntryMessage(argv[i-1],
                                               argv[i],
                                               "Invalid source name, or not space separated\nRun KERNRATE with the '-lx' option to list supported sources",
                                               FALSE,
                                               TRUE
                                               );
                       }
                   }
                   break;

                case 'J':
                    //
                    // User specified symbol search path.
                    // It is going to be prepend to the default image help symbol search path.
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "",
                                             NULL,
                                             gUserSymbolPath,
                                             USER_SYMPATH_LENGTH-1,
                                             ORDER_ANY,
                                             OPTIONAL_NONE
                                             );

                    if(ietResult == INPUT_GOOD){

                        if( lstrlen(argv[i+1]) > USER_SYMPATH_LENGTH){
                            FPRINTF(stderr, "\n===>WARNING: Command-line specified symbol path length exceeds %d characters and will be truncated\n",
                                            USER_SYMPATH_LENGTH-1
                                            ); 
                        }
                        ++i;
                            
                    } else if(ietResult == MISSING_PARAMETER ||
                                 ietResult == MISSING_STRING || ietResult == MISSING_REQUIRED_STRING) {
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-j SymbolPath' option requires a \"SymbolPath\", space separated",
                                                    FALSE
                                                    );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    break;
                    
                case 'K':
                    //
                    // User wants to limit the output to modules that have at least MinHitsToDisplay hits
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "#",
                                             &gMinHitsToDisplay,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_NONE
                                             );

                    if(ietResult == INPUT_GOOD){

                        if ( gMinHitsToDisplay == 0 ) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Invalid entry for this command line option, (expecting a decimal number > 0)",
                                                FALSE,
                                                TRUE
                                                );
                        }
                        ++i;

                    } else if(ietResult == MISSING_PARAMETER || ietResult == MISSING_NUMBER || ietResult == MISSING_REQUIRED_NUMBER) {
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-k N' or '-k# N' options require a number for the minimum hits to display, space separated",
                                                    FALSE
                                                    );
                    } else if(ietResult == INVALID_NUMBER) {
                        InvalidEntryMessage(argv[i],
                                            argv[i+1],
                                            "Invalid entry for minimum hits to display (expecting a number 0 < N < 10^9)",
                                            FALSE,
                                            TRUE
                                            );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    FPRINTF(stdout, "---> Minimum Number of Hits To Display in the Output Set to %u\n", gMinHitsToDisplay); 
                    break;


                case 'L':
                     {
                        // User may have put -L on the command line before any process profile source has been initialized
                        // We'll therefore supply a valid pointer to just get the information

                        PSOURCE src;
                        ietResult = IsInputValid(argc,
                                                 i,
                                                 argv,
                                                 "x",
                                                 NULL,
                                                 NULL,
                                                 0,
                                                 ORDER_ANY,
                                                 OPTIONAL_ANY
                                                 );
                        if(ietResult == INPUT_GOOD){                 //Fall through
                        } else if (ietResult == BOGUS_ENTRY){
                            ExitWithUnknownOptionMessage(argv[i+1]);
                        } else {   
                            ExitWithUnknownOptionMessage(argv[i]);
                        }

                        FPRINTF(stdout, "List of profile sources supported for this platform:\n\n");
                        FPRINTF(stdout, "%*s - %-*s - %-10s\n\n", gDescriptionMaxLen, "Name", gTokenMaxLen, "ShortName", "Interval");

                        //
                        // Print all possible sources.
                        //

                        for ( ProfileSourceIndex = 0; ProfileSourceIndex <  gSourceMaximum; ProfileSourceIndex++ )   {

                            ULONG OldInterval  = 0;
                            ULONG ThisInterval = 0;
                            src = &gpProcDummy->Source[ProfileSourceIndex];

                            //
                            // Display the supported profile sources, only.
                            // We'll determine if a source is supported by trying to set its interval rate
                            //
                            Status = NtQueryIntervalProfile( src->ProfileSource, &OldInterval );
                            if( NT_SUCCESS(Status) ) {
                            
                                NtSetIntervalProfile( src->DesiredInterval, src->ProfileSource );
                                Status = NtQueryIntervalProfile( src->ProfileSource, &ThisInterval );
                            
                                if( NT_SUCCESS(Status) && ThisInterval > 0 ) {
                                    if ( src->DesiredInterval )  {
                                        FPRINTF(stdout, "%*s - %-*s - %-10ld\n",
                                                        gDescriptionMaxLen,
                                                        src->Name,
                                                        gTokenMaxLen,
                                                        src->ShortName,
                                                        src->DesiredInterval
                                                        );
                                    }

                                    NtSetIntervalProfile( OldInterval, src->ProfileSource );
                                }

                            }

                        }

                        FPRINTF(stdout, "\nNOTE: Only up to %u sources can be turned on simultaneously on this machine.\n",
                                        gMaxSimultaneousSources
                                        );
                        FPRINTF(stdout, "      This always includes the default source (TIME).\n");
                        FPRINTF(stdout, "      A cyclic mode of profiling will be turned on automatically if more sources are specified.\n");  
#if !defined(_AMD64_)
                        if( gMaxSimultaneousSources  > 1 )
                            FPRINTF(stdout, "      There is no guarantee that all sources specified in the combination will work together.\n");
#endif
                        FPRINTF(stdout, "      One can always force a cyclic mode of profiling (switching between sources) by using the\n");
                        FPRINTF(stdout, "      '-c' command line option. This will guarantee that all specified sources will run.\n");
                        FPRINTF(stdout, "      The run time will then be divided equally between (number of sources)*(number of processes.\n");
                        //
                        // If the user specified '-lx', we exit immediately.
                        //

                        if ( strchr(argv[i], 'x') || strchr(argv[i], 'X') ) {
                           exit(0);
                        }

                        FPRINTF(stdout, "\n");
                     }
                     break;

                case 'M':
                    //
                    // We already dealt with this command line parameter in the first loop
                    // Just update the index if extra parameter was found
                    //
                    if(gAffinityMask != 0)++i;
                    break;

                case 'N':
                    //
                    // Monitor a given process Name
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "v#",
                                             &MaxProcSameName,
                                             tmpName,
                                             PROCESS_NAME_SIZE,
                                             ORDER_NUMBER_FIRST,
                                             OPTIONAL_NUMBER
                                             );

                    //
                    // User wants the full list of running processes
                    //
                    if(ietResult == INPUT_GOOD || ietResult == MISSING_NUMBER){
                        if( strchr(argv[i], 'v') || strchr(argv[i], 'V') ){
                            tlistVerbose = TRUE;
                            bIncludeProcessThreadsInfo = TRUE;
                        }
                    }

                    if(ietResult == INPUT_GOOD){
                        //
                        // User wants to specify a non-default maximum number of processes with same name
                        //                    
                        if ( MaxProcSameName == 0 ) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Expecting a decimal value >0 for the maximum number of processes with the same name",
                                                FALSE,
                                                TRUE
                                                );
                        }
                        FPRINTF(stdout, "---> Maximum monitored processes with same name set to= %ld\n", MaxProcSameName);
                        i += 2; // two parameters exist (number and string)

                    } else if(ietResult == MISSING_PARAMETER || 
                                 ietResult == MISSING_STRING || ietResult == MISSING_REQUIRED_STRING) {
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-n process_name' option requires at least a process name, space separated",
                                                    FALSE
                                                    );
                    } else if(ietResult == MISSING_REQUIRED_NUMBER){
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-n# number process_name' option requires a number followed by a process name, space separated",
                                                    FALSE
                                                    );
                    } else if(ietResult == MISSING_NUMBER) {    //alowed
                        ++i;   // one parameter exists (string)
                    } else if(ietResult == INVALID_NUMBER) {
                        InvalidEntryMessage(argv[i],
                                            argv[i+1],
                                            "'-n# number process_name' - Expecting a decimal value >0 for the maximum number of processes with the same name",
                                            FALSE,
                                            TRUE
                                            );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    //
                    // Let's not bother the user with minor issues
                    //
                    if(!strstr(tmpName, ".exe"))
                               strncat(tmpName, ".exe", EXT_SIZE);

                    tmpName[PROCESS_SIZE - 1] = '\0';

                    Pid = (LONGLONG) 0xFFFFFFFF;
                    //
                    // The '-n' option requires taking a tlist to get the PID.
                    // If we already took a tlist but that's the first time thread info is required,
                    // we'll have to refresh it and take thread info as well
                    //
                    if ( !bTlistInitialized || (bIncludeProcessThreadsInfo == TRUE && bIncludeThreadsInfo == FALSE) ) {
                        if( bIncludeProcessThreadsInfo == TRUE && bIncludeThreadsInfo == FALSE ){
                            bIncludeThreadsInfo = TRUE;
                        }
                        //
                        // get the task list for the system 
                        //
                        if ( !bTlistInitialized ){
                            gTlistStart = calloc(1, gMaxTasks*sizeof(TASK_LIST));
                            if (gTlistStart == NULL) {
                                FPRINTF(stderr, "\nKERNRATE: Allocation of memory for the running processes task list failed(2)\n");
                                exit(1);
                            }
                        }
                       
                        NumTasks = GetTaskList( gTlistStart, gMaxTasks );
                        bTlistInitialized = TRUE;
                        gNumTasksStart = NumTasks;
                    }

                    //
                    // There may be more than one process with the specified name
                    // We will limit the maximum number monitored (with same name) to MAX_PROCESS_SAME_NAME for now 
                    //
                    if ( tlistDisplayed == FALSE && tlistVerbose ) {
                         FPRINTF(stdout, "\nRunning processes found before profile start:\n");  
                         FPRINTF(stdout, "         Pid                  Process\n");
                         FPRINTF(stdout, "       -------                -----------\n");
                    }

                    for (m=0, k=0; m < NumTasks; m++) {
                      
                        if ( tlistDisplayed == FALSE && tlistVerbose ) {
                            FPRINTF(stdout, "%12I64d %32s\n",
                                            gTlistStart[m].ProcessId,
                                            gTlistStart[m].ProcessName
                                            );
                        }

                        if (_stricmp(gTlistStart[m].ProcessName, tmpName) == 0) {
                            Pid = gTlistStart[m].ProcessId;
                            FPRINTF(stdout, "\n===> Found process: %s, Pid: %I64d\n\n",
                                    gTlistStart[m].ProcessName,
                                    Pid
                                    );

                            ProcToMonitor = InitializeProcToMonitor(Pid);
                            if( ProcToMonitor == NULL ){                   //This process may be gone
                                FPRINTF(stdout, "KERNRATE: Could not initialize for specified process (PID= %12I64d)\n process may be gone or wrong PID specified\n", Pid);
                                continue;
                            }
                            if( bIncludeGeneralInfo ){
                                UpdateProcessStartInfo(ProcToMonitor,
                                                       &gTlistStart[m],
                                                       bIncludeProcessThreadsInfo
                                                      );
                            }
                            if((ULONG)(++k) >= MaxProcSameName) break;
                        }
                    }
                    if( tlistDisplayed == FALSE && tlistVerbose ){
                        FPRINTF(stdout, "\nNOTE: The list above may be missing some or all processes created by the '-o' option\n"); 
                    }

                    //
                    // Let's not print it again if there is another specified on the command line
                    //
                    if ( tlistDisplayed == FALSE && tlistVerbose ){
                        tlistDisplayed = TRUE;
                    }
                    tlistVerbose   = FALSE;
                    
                    
                    if (Pid == (LONGLONG) 0xFFFFFFFF) {
                        Usage(FALSE);
                        FPRINTF(stderr, "\n===>KERNRATE: Requested Process '%s' Not Found.\n\n", argv[i]);
                        FPRINTF(stderr, "Kernrate could not find this process in the task list. Either it does not exist or \n"); 
                        FPRINTF(stderr, "Kernrate hit its limit of maximum %d processes in the task list\n", DEFAULT_MAX_TASKS);
                        FPRINTF(stderr, "In the latter case you may want to specify the process by PID instead of by name\n"); 
                        FPRINTF(stderr, "or use the '-t' option to specify a larger maximum number (default is 256)\n");
                        FPRINTF(stderr, "This may also happen if you specified a number for the maximum number of processes\n");
                        FPRINTF(stderr, "with the same name but forgot to add the process name\n");
                        exit(1);
                    }
             
                    break;

                case 'O':
                {
                    //
                    // Create and monitor a given process Name
                    //
                    ULONG               MaxProcToCreate;// = 1;
                    ULONG               n;
                    STARTUPINFO         StartupInfo;
                    PROCESS_INFORMATION ProcessInformation;
                    PCHAR               tmpCmdLine;
                    PLONGLONG           PidArray;
                    ULONG               nFound = 0;
                    BOOL                fInheritHandles = FALSE;
                    
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "v#",
                                             &MaxProcToCreate,
                                             tmpName,
                                             USER_SYMPATH_LENGTH - EXT_SIZE - 1, // We must allow a fully qualified path here
                                             ORDER_NUMBER_FIRST,
                                             OPTIONAL_NUMBER
                                             );

                    //
                    // User wants the full list of running processes
                    //
                    if(ietResult == INPUT_GOOD || ietResult == MISSING_NUMBER){
                        if( strchr(argv[i], 'v') || strchr(argv[i], 'V') ){
                            tlistVerbose = TRUE;
                            bIncludeProcessThreadsInfo = TRUE;
                            bIncludeThreadsInfo = TRUE;
                        }
                    }

                    if(ietResult == INPUT_GOOD){
                        //
                        // User wants to specify a non-default maximum number of processes to create
                        //                    
                        if ( MaxProcToCreate == 0 ) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Expecting a decimal value >0 for the maximum number of processes to create",
                                                FALSE,
                                                TRUE
                                                );
                        }
                        FPRINTF(stdout, "---> Maximum processes to create set to= %ld for %s\n",
                                        MaxProcToCreate,
                                        tmpName
                                        );

                        if(i+3 < argc && argv[i+3][0] == '{' ){           // Found an opening curly bracket (allowed)
                            i += 3; // three parameters exist (number, ProcessName and {Process Command Line})
                        } else {
                            i += 2; // two parameters exist (number and ProcessName)
                        }
                    } else if(ietResult == MISSING_PARAMETER || 
                                 ietResult == MISSING_STRING || ietResult == MISSING_REQUIRED_STRING) {
                        ExitWithMissingEntryMessage(argv[i],
                                                    "Process name missing, the '-o number process_name {Process command line}' option requires at least a process Name",
                                                    FALSE
                                                    );
                    } else if(ietResult == MISSING_REQUIRED_NUMBER){
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-o# number process_name {Process command line}' option requires a number followed by a process Name",
                                                    FALSE
                                                    );
                    } else if(ietResult == MISSING_NUMBER) {    //alowed
                        MaxProcToCreate = 1;
                        ++i;   // one parameter exists (string)
                    } else if(ietResult == INVALID_NUMBER) {
                        if(!strchr(argv[i], '#') && (i+2 < argc && argv[i+2][0] == '{') ){ // Found an opening curly bracket (allowed)
                                MaxProcToCreate = 1;
                                i += 2;   // two parameters exist (two strings)
                        } else {
                            if( !strchr(argv[i], '#') && (i+1 < argc && argv[i+1][0] == '{') ){
                                InvalidEntryMessage(argv[i],
                                                    argv[i+1],
                                                    "'-o optional_number process_name {Optional Process command line}' - wrong order of parameters (or missing parameter) detected",
                                                    FALSE,
                                                    TRUE
                                                    );
                            } else {
                                InvalidEntryMessage(argv[i],
                                                    argv[i+1],
                                                    "'-o# number process_name {Optional Process command line}' - Expecting a decimal value >0",
                                                    FALSE,
                                                    TRUE
                                                    );
                            }
                        }
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    ZeroMemory( &StartupInfo, sizeof(StartupInfo) );
                    StartupInfo.cb = sizeof(StartupInfo);
                    StartupInfo.wShowWindow = SW_SHOWDEFAULT;

                    //
                    // Let's not bother the user with minor issues
                    //
                    if( !strstr(tmpName, ".exe") && !strstr(tmpName, ".EXE") )
                               strncat(tmpName, ".exe", EXT_SIZE);

                    tmpName[USER_SYMPATH_LENGTH - 1] = '\0';
                    
                    if( i < argc && argv[i][0] == '{'){           // Found an opening curly bracket
                        PCHAR InitPos = &argv[i][0];
                        PCHAR curptr  = InitPos;
                        PCHAR ClosingBracket;
                        while(i < argc){                            //Try to find the closing curly bracket
                          ClosingBracket = strchr(&argv[i][0], '}');
                          if(ClosingBracket == NULL){
                            curptr += (1+strlen(argv[i]));
                            ++i;
                            continue;
                          }else{
                            ClosingBracket = curptr + (ClosingBracket - &argv[i][0]);
                            break;
                          }
                          
                        }
                        if(ClosingBracket != NULL){                   //Process the command line found between the curly brackets
                            PCHAR tmp;
                            ULONG MaxCount;
                            ULONG nChars = (ULONG)(ClosingBracket - InitPos) -1;     //Skip the brackets
                            tmpCmdLine = calloc(1, strlen(tmpName)+ sizeof(CHAR)+ (1+nChars)*sizeof(CHAR)); //name + space + cmdline + terminator
                            if(tmpCmdLine == NULL){
                                FPRINTF(stderr, "KERNRATE: Failed to allocate memory for created process command line\n");
                                exit(1);
                            }
                            strncpy(tmpCmdLine, tmpName, strlen(tmpName));
                            strncat(tmpCmdLine, " ", 1);
                            memcpy(&tmpCmdLine[strlen(tmpCmdLine)], InitPos + 1, nChars); //skip opening and end brackets
                            tmpCmdLine[strlen(tmpName)+ nChars + 1] = '\0';

                            tmp = &tmpCmdLine[0];
                            MaxCount = strlen(tmpName) + nChars + 1; 
                            do{                                     //replace any mid-cmdline string terminators with blank space character
                                if(*tmp == '\0')*tmp = ' ';
                                ++tmp;
                            }while(--MaxCount);

                            MaxCount = HandleRedirections( tmpCmdLine,
                                                           strlen(tmpName) + nChars + 1,
                                                           &ghInput,
                                                           &ghOutput,
                                                           &ghError
                                                           );
                            
                            if(ghInput != NULL || ghOutput != NULL || ghError != NULL){
                                if ( MaxProcToCreate == 1 || (ghOutput == NULL && ghError == NULL) ){
                                    StartupInfo.dwFlags |=  STARTF_USESTDHANDLES;
                                    StartupInfo.hStdInput  = ghInput;
                                    StartupInfo.hStdOutput = ghOutput;
                                    StartupInfo.hStdError  = ghError;
                                    fInheritHandles = TRUE;
                                } else {                       //We won't allow several processes to write to the same output stream simultaneously...
                                    FPRINTF(stderr, "\nKERNRATE: Redirection of output streams in the curly brackets is not allowed if more than one\n");
                                    FPRINTF(stderr, "          process is to be created using the '-o Number ProcessName {parameters}' command line option\n"); 
                                    if(ghInput != NULL)
                                        CloseHandle(ghInput);
                                    if(ghOutput != NULL)
                                        CloseHandle(ghOutput);
                                    if(ghError != NULL)
                                        CloseHandle(ghError);
                                    exit(1);
                                }
                            }    

                        } else {
                            Usage(FALSE);
                            FPRINTF(stderr, "KERNRATE: Unmatched curly brackets containing the command line of the process to be created with the -o option\n");
                            FPRINTF(stderr, "          This could also be the result of not escaping each redirection character: '<' '>' with a '^' character\n");
                            FPRINTF(stderr, "          Note that piping '|' is not supported as part of the allowed parameters within the curly brackets\n");
                            exit(1);
                        }    
                    } else {
                        tmpCmdLine = calloc(1, (1+strlen(tmpName))*sizeof(CHAR)); //name + terminator
                        if(tmpCmdLine == NULL){
                            FPRINTF(stderr, "KERNRATE: Failed to allocate memory for created process command line\n");
                            exit(1);
                        }
                        strncpy(tmpCmdLine, tmpName, strlen(tmpName)); 
                        tmpCmdLine[strlen(tmpName)] = '\0';
                    }

                    PidArray = calloc(MaxProcToCreate, sizeof(ULONG));
                    if(PidArray == NULL){
                        FPRINTF(stderr, "KERNRATE: Failed to allocate memory for created processes PID Array\n");
                        exit(1);
                    }
                        
                    for (m=0; m<MaxProcToCreate; m++) {
                        Pid = (LONGLONG) 0xFFFFFFFF;
                        
                        if(!CreateProcess(NULL,                                  //ProcName
                                          tmpCmdLine,                            //cmd line
                                          NULL,                                  //Security attr.
                                          NULL,                                  //thread attr.
                                          fInheritHandles,                       //inherit handle from debugging proc
                                          CREATE_DEFAULT_ERROR_MODE |CREATE_SEPARATE_WOW_VDM | CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_PROCESS_GROUP | CREATE_NEW_CONSOLE | NORMAL_PRIORITY_CLASS,
                                          NULL,                                  //environment of calling proc
                                          NULL,                                  //Current dir same as debugging proc
                                          &StartupInfo,                          //Startup Info
                                          &ProcessInformation)                   //PROCESS_INFORMATION struct
                                          ) {
                            FPRINTF(stderr, "KERNRATE: Failed to Create Process %s\n", tmpName);

                        } else {

                            Pid = ProcessInformation.dwProcessId;
                            PidArray[m] = Pid;
                            FPRINTF(stdout, "Created Process %s, PID= %I64d\n", tmpName, Pid);
                            FPRINTF(stdout, "Process Command Line = %s\n", tmpCmdLine);
                            ProcToMonitor = InitializeProcToMonitor(Pid);
                            if( ProcToMonitor == NULL ){                   //This process may be gone
                                FPRINTF(stdout, "KERNRATE: Could not initialize for specified process (PID= %12I64d)\n process may be gone or wrong PID specified\n", Pid);
                                continue;
                            }
                        }
                    } 
                    
                    if ( bTlistInitialized ) {         //Refresh the task list to make sure we include the new process
                                                       //(this will take care of thread info as well if required for the first time)
                        NumTasks = GetTaskList( gTlistStart, gMaxTasks );
                        gNumTasksStart = NumTasks;
                        
                    } else {
                        //
                        // get the task list for the system (this will take care of thread info as well if required for the first time) 
                        //
                        gTlistStart = calloc(1, gMaxTasks*sizeof(TASK_LIST));
                        if (gTlistStart == NULL) {
                            FPRINTF(stderr, "\nKERNRATE: Allocation of memory for the running processes task list failed(3)\n");
                            exit(1);
                        }
                       
                        NumTasks = GetTaskList( gTlistStart, gMaxTasks );
                        bTlistInitialized = TRUE;
                        gNumTasksStart = NumTasks;
                    }

                    if ( tlistDisplayed == FALSE && tlistVerbose ) {
                         FPRINTF(stdout, "\nRunning processes found before profile start:\n");  
                         FPRINTF(stdout, "         Pid                  Process\n");
                         FPRINTF(stdout, "       -------                -----------\n");
                    }

                    for (m=0; m < NumTasks; m++) {
                      
                        if ( tlistDisplayed == FALSE && tlistVerbose ) {
                            FPRINTF(stdout, "%12I64d %32s\n",
                                            gTlistStart[m].ProcessId,
                                            gTlistStart[m].ProcessName
                                            );
                        }
                        for (n=0; n<MaxProcToCreate; n++){ 
                            if ( gTlistStart[m].ProcessId == PidArray[n] ) {
                                FPRINTF(stdout, "\n===> Found process: %s, Pid: %I64d\n\n",
                                                gTlistStart[m].ProcessName,
                                                gTlistStart[m].ProcessId
                                                );
                                nFound += 1;
                                ProcToMonitor = gProcessList;
                                while (ProcToMonitor != NULL){
                                    if(ProcToMonitor->Pid == gTlistStart[m].ProcessId && bIncludeGeneralInfo ){
                                        UpdateProcessStartInfo(ProcToMonitor,
                                                               &gTlistStart[m],
                                                               bIncludeProcessThreadsInfo
                                                               );

                                        break;
                                    }
                                    ProcToMonitor = ProcToMonitor->Next;
                                }
                            }
                        }
                    }
                    if( tlistDisplayed == FALSE && tlistVerbose ){
                        FPRINTF(stdout, "\nNOTE: The list above may be missing some or all processes created by the '-o' option\n"); 
                    }
                    free(tmpCmdLine);
                    free(PidArray);
                    //
                    // Let's not print it again if there is another specified on the command line
                    //
                    if ( tlistDisplayed == FALSE && tlistVerbose ){
                        tlistDisplayed = TRUE;
                    }
                    tlistVerbose   = FALSE;

                    if(nFound == 0){
                        FPRINTF(stderr, "KERNRATE: None of the processes you tried to create was found in the task list\n");
                        FPRINTF(stderr, "          This is either because:\n");
                        FPRINTF(stderr, "       1. The executable was not found in the default path therefore not launched\n");
                        FPRINTF(stderr, "          The -o option does allow you to specify a fully qualified path with the process name (use quotes)\n");
                        FPRINTF(stderr, "       2. The default number of entries in the task list is too small\n");
                        FPRINTF(stderr, "          The maximum number of tasks in the task list can be increased using the -t# option\n");
                        FPRINTF(stderr, "       3. The processes were never created because of some other reason or are gone\n");
                        FPRINTF(stderr, "       4. The number or order of parameters on the command line is wrong,\n");
                        FPRINTF(stderr, "          it should be '-o# number process_name {Process command line}' (only the process name is mandatory)\n"); 
                        exit(1);
                    } else if (nFound < MaxProcToCreate){
                        FPRINTF(stderr, "KERNRATE: Only %d of the %d processes you tried to create were found in the task list\n", nFound, MaxProcToCreate);
                        FPRINTF(stderr, "          This is either because the default number of entries in the task list is too small\n");
                        FPRINTF(stderr, "          or because these processes were never created or are gone\n");
                        FPRINTF(stderr, "          The maximum number of tasks in the task list can be increased using the -t# option\n");
                        FPRINTF(stderr, "          Kernrate will try to continue the run with the existing processes\n");
                    }
                    bWaitCreatedProcToSettle = TRUE;
                }
                break;


                case 'P':
                    //
                    // Monitor a given process ID
                    //
                    {
                        LONG tmpPid;
                        BOOL bFound = FALSE;

                        ietResult = IsInputValid(argc,
                                                 i,
                                                 argv,
                                                 "v#",
                                                 &tmpPid,
                                                 NULL,
                                                 0,
                                                 ORDER_ANY,
                                                 OPTIONAL_NONE
                                                 );

                        if(ietResult == INPUT_GOOD){
                            if (tmpPid == 0){
                                InvalidEntryMessage(argv[i],
                                                    argv[i+1],
                                                    "Invalid Process ID specified on the command line, expecting PID > 0",
                                                    FALSE,
                                                    TRUE
                                                    );
                            }
                            //
                            // User wants the full list of running processes
                            //
                            if( strchr(argv[i], 'v') || strchr(argv[i], 'V') ) {
                                tlistVerbose = TRUE; 
                                bIncludeProcessThreadsInfo = TRUE;
                            }
                            ++i;
                        } else if(ietResult == MISSING_PARAMETER || ietResult == MISSING_NUMBER || ietResult == MISSING_REQUIRED_NUMBER) {
                            ExitWithMissingEntryMessage(argv[i],
                                                        "'-p# PID' option requires a decimal process ID (PID>0), space separated",
                                                        FALSE
                                                        );
                        } else if(ietResult == INVALID_NUMBER) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Invalid Process ID specified on the command line, expecting a decimal number",
                                                FALSE,
                                                TRUE
                                                );
                        } else if(ietResult == UNKNOWN_OPTION) {
                            ExitWithUnknownOptionMessage(argv[i]);
                        }

                        Pid = (LONGLONG)tmpPid;

                        ProcToMonitor = InitializeProcToMonitor(Pid);
                        if( ProcToMonitor == NULL ){                   //This process may be gone
                            FPRINTF(stdout, "KERNRATE: Could not initialize for specified process (PID= %12I64d)\n process may be gone or wrong PID specified\n", Pid);
                            continue;
                        }
                        //
                        //Get the task list and Copy the initial performance data for the process 
                        //Note: It is possible that the specified Pid is not on the tlist because
                        //of the DEFAULT_MAX_TASKS limit. We won't stop the run because of that but there will be no
                        //performance data for that process.
                        //
                        if( bIncludeGeneralInfo || tlistVerbose) { 
                            if ( !bTlistInitialized || (bIncludeProcessThreadsInfo == TRUE && bIncludeThreadsInfo == FALSE) ) {
                                //
                                // In the second check above if we already took a tlist but that's the first time thread info is required,
                                // we'll have to refresh it and take thread info as well
                                //
                                if( bIncludeProcessThreadsInfo == TRUE && bIncludeThreadsInfo == FALSE ){
                                    bIncludeThreadsInfo = TRUE;
                                }

                                //
                                // get the task list for the system 
                                //
                                if( !bTlistInitialized ){
                                    gTlistStart = calloc(1, gMaxTasks*sizeof(TASK_LIST));
                                    if (gTlistStart == NULL) {
                                        FPRINTF(stderr, "\nKERNRATE: Allocation of memory for the running processes task list failed(4)\n");
                                        exit(1);
                                    }
                                }
                                NumTasks = GetTaskList( gTlistStart, gMaxTasks );
                                bTlistInitialized = TRUE;
                                gNumTasksStart = NumTasks;

                            }
                        }

                        if( bTlistInitialized && (bIncludeGeneralInfo || tlistVerbose) ) {

                            if ( tlistDisplayed == FALSE && tlistVerbose ) {
                                 FPRINTF(stdout, "\nRunning processes found before profile start:\n");  
                                 FPRINTF(stdout, "         Pid                  Process\n");
                                 FPRINTF(stdout, "       -------                -----------\n");
                            }

                            for (m=0; m < NumTasks; m++) {
                                if ( tlistDisplayed == FALSE && tlistVerbose) {
                                    FPRINTF(stdout, "%12I64d %32s\n",
                                                    gTlistStart[m].ProcessId,
                                                    gTlistStart[m].ProcessName
                                                    );
                                }

                                if ( Pid == gTlistStart[m].ProcessId ) {
                                    FPRINTF(stdout, "\n===> Found process: %s, Pid: %I64d\n\n",
                                                    gTlistStart[m].ProcessName,
                                                    Pid
                                                    );

                                    UpdateProcessStartInfo(ProcToMonitor,
                                                           &gTlistStart[m],
                                                           bIncludeProcessThreadsInfo
                                                           );

                                    bFound = TRUE;
                                    if(!tlistVerbose)
                                        break;
                                }
                    
                            }

                            if( tlistDisplayed == FALSE && tlistVerbose ){
                                FPRINTF(stdout, "\nNOTE: The list above may be missing some or all processes created by the '-o' option\n"); 
                                //
                                // Let's not print it again if there is another specified on the command line
                                //
                                tlistDisplayed = TRUE;
                                tlistVerbose   = FALSE;
                            }
                          
                            if(!bFound){
                                FPRINTF(stderr, "===>KERNRATE: Process Performance Summary for PID= %I64d will not be gathered\n", Pid);
                                FPRINTF(stderr, "because Kernrate could not find this process in the task list.\n"); 
                                FPRINTF(stderr, "This could be due to Kernrate's limit of maximum %d processes in the task list\n", DEFAULT_MAX_TASKS); 
                                FPRINTF(stderr, "You may use the '-t# N' option to specify a larger maximum number (default is 256)\n"); 
                            }

                        }

                    }

                    break;

                case 'R':
                    //
                    // Turn on RAW bucket dump
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "d",
                                             NULL,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );
                    if(ietResult == INPUT_GOOD){ 

                        bRawData = TRUE;
                        //
                        // If the user specified '-rd', we want to output disassembly with the raw data.
                        //
                        if ( strchr(argv[i], 'd') || strchr(argv[i], 'D') ){
                            bRawDisasm = TRUE;
#ifndef DISASM_AVAILABLE
                            FPRINTF(stderr, "\n===>KERNRATE: '-rd' command line option specified but disassembly is not available at present\n");
#endif
                        }

                    } else if (ietResult == BOGUS_ENTRY){
                        ExitWithUnknownOptionMessage(argv[i+1]);
                    } else {   
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    break;
                    
                case 'S':
                    //
                    // Set Sleep interval
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,//argv[i][1],
                                             "#",
                                             &gSleepInterval,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_NONE
                                             );

                    if(ietResult == INPUT_GOOD){

                        gSleepInterval *= 1000;
                        if (gSleepInterval == 0) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Expecting a decimal number >0 in seconds",
                                                FALSE,
                                                TRUE
                                                );
                        }
                        ++i;

                    } else if(ietResult == MISSING_PARAMETER || ietResult == MISSING_NUMBER || ietResult == MISSING_REQUIRED_NUMBER) {
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-s N' or '-s# N' options require a specified time >0 in seconds, space separated",
                                                    FALSE
                                                    );
                    } else if(ietResult == INVALID_NUMBER) {
                        InvalidEntryMessage(argv[i],
                                            argv[i+1],
                                            "Expecting a decimal number >0 in seconds",
                                            FALSE,
                                            TRUE
                                            );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }
                    break;

                case 'T':
                    //
                    // We already dealt with this command line parameter in the second loop
                    // Just update the running index in case we found an extra optional entry
                    //

                    i += tJump;

                    break;


                case 'U':
                    //
                    // Requests IMAGEHLP to present undecorated symbol names
                    //
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "",
                                             NULL,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );
                    if(ietResult == INPUT_GOOD){ 
                        gSymOptions |= SYMOPT_UNDNAME;
                    } else if (ietResult == BOGUS_ENTRY){
                        ExitWithUnknownOptionMessage(argv[i+1]);
                    } else {   
                        ExitWithUnknownOptionMessage(argv[i]);
                    }
                    break;

                case 'V':
                    //
                    // Verbose mode.
                    //

                    gVerbose = VERBOSE_DEFAULT;
                    ulVerbose = VERBOSE_DEFAULT;
                    
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "#",
                                             &ulVerbose,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );

                    if(ietResult == INPUT_GOOD){

                        gVerbose |= ulVerbose;
                        if ( gVerbose > VERBOSE_MAX ){
                            FPRINTF(stderr,
                                    "\n===>WARNING: Invalid Verbose level '-v %s' specified, or'ed verbose levels cannot exceed %d\n",
                                    argv[i+1],
                                    VERBOSE_MAX
                                    );
                            FPRINTF(stderr,
                                    "---> Verbose level is set to %d\n",
                                    VERBOSE_MAX
                                    );  
                            
                            gVerbose = VERBOSE_MAX; 
                        }    
                        ++i;

                    } else if(ietResult == MISSING_PARAMETER || ietResult == MISSING_NUMBER) {   // Allowed
                        //
                        // No verbose level specified, using default
                        //
                    } else if(ietResult == MISSING_REQUIRED_NUMBER){
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-v# N' option requires a specific verbose level",
                                                    FALSE
                                                    );
                    } else if(ietResult == INVALID_NUMBER) {
                        InvalidEntryMessage(argv[i],
                                            argv[i+1],
                                            "Invalid Verbose level (expecting a decimal entry)",
                                            TRUE,
                                            TRUE
                                            );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    if ( gVerbose & VERBOSE_IMAGEHLP )   {
                        gSymOptions |= SYMOPT_DEBUG;
                    }
                    break;

                case 'W':
                    {
                        LONG tmpTime;
                        //
                        // Case WP: (associated with process creation via the -O option)
                        // Wait for CR or a given number of seconds to allow the created processes to settle. 
                        // This is useful in cases where the created process takes time to initialize and load modules,
                        // or if the user needs to interact with it before profiling.
                        //
                        // Case W:
                        // Wait for CR or a given number of seconds before starting the profile
                        // This is useful in cases where the system is very busy with the task being monitored
                        // One can start Kernrate ahead of the task, allow for proper initialization (symbol loading)
                        // and then launch the task to be monitored
                        //
                        ietResult = IsInputValid(argc,
                                                 i,
                                                 argv,
                                                 "#p",
                                                 &tmpTime,
                                                 NULL,
                                                 0,
                                                 ORDER_ANY,
                                                 OPTIONAL_ANY
                                                 );

                        if(ietResult == INPUT_GOOD){
                            //
                            // Wait for a given number of seconds before continuing
                            //
                            if ( strchr(argv[i], 'p') || strchr(argv[i], 'P') ){
                                gSecondsToWaitCreatedProc = tmpTime;                                //Zero allowed
                            } else {
                                gSecondsToDelayProfile    = tmpTime;
                            }
                            ++i;
                        } else if(ietResult == MISSING_PARAMETER || ietResult == MISSING_NUMBER) {  //Allowed
                            //
                            // Wait for user to press a key before continuing
                            //
                            if ( strchr(argv[i], 'p') || strchr(argv[i], 'P') ){
                                bCreatedProcWaitForUserInput = TRUE;
                            } else {
                                bWaitForUserInput = TRUE;
                            }
                        } else if(ietResult == MISSING_REQUIRED_NUMBER){
                                ExitWithMissingEntryMessage(argv[i-1],
                                                            "'-wp# N' or '-w# N' options require a (decimal) number of seconds to wait",
                                                            FALSE
                                                            );
                        } else if(ietResult == INVALID_NUMBER) {
                            InvalidEntryMessage(argv[i],
                                                argv[i+1],
                                                "Expecting a decimal value in seconds, 0 < N < 10^9",
                                                FALSE,
                                                TRUE
                                                );
                        } else if(ietResult == UNKNOWN_OPTION) {
                            ExitWithUnknownOptionMessage(argv[i]);
                        }
                    } 
                    break; 
                        
                case 'X':
                    //
                    // User asked for Locks information
                    //
                    bIncludeUserProcLocksInfo = TRUE;
                    bIncludeSystemLocksInfo   = TRUE;
                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "uk#",
                                             &gLockContentionMinCount,
                                             NULL,
                                             0,
                                             ORDER_ANY,
                                             OPTIONAL_ANY
                                             );

                    if( strchr(argv[i], 'k') || strchr(argv[i], 'K') ) 
                        bIncludeUserProcLocksInfo = FALSE;
                    if( strchr(argv[i], 'u') || strchr(argv[i], 'U') ) 
                        bIncludeSystemLocksInfo = FALSE;

                    if(ietResult == INPUT_GOOD){
                        FPRINTF(stdout, "---> Minimum lock contention for processing set to= %ld\n", gLockContentionMinCount);
                        ++i;
                    } else if(ietResult == MISSING_NUMBER) {  //Allowed
                        FPRINTF(stdout, "---> Minimum lock contention for processing set to default= %ld\n", gLockContentionMinCount);
                    } else if(ietResult == MISSING_REQUIRED_NUMBER || ietResult == MISSING_PARAMETER){
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-x# number' '-xk# number' '-xu# number' options require a number for the minimum lock-contention filtering",
                                                    FALSE
                                                    );
                    } else if(ietResult == INVALID_NUMBER) {
                        InvalidEntryMessage(argv[i],
                                            argv[i+1],
                                            "'-x# number', '-xk# number', '-xu# number' options expect a number 0 <= N < 10^9",
                                            FALSE,
                                            TRUE
                                            );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    //
                    // The user didn't bother to read the usage guide and specified both k and u after the '-x'...
                    //
                    if( bIncludeUserProcLocksInfo == FALSE && bIncludeSystemLocksInfo == FALSE ){
                        bIncludeUserProcLocksInfo = TRUE;
                        bIncludeSystemLocksInfo   = TRUE;
                    }
                    
                    break;
                                                        
                case 'Z':

                    ietResult = IsInputValid(argc,
                                             i,
                                             argv,
                                             "",
                                             NULL,
                                             tmpName,             //Used as a temporary storage
                                             cMODULE_NAME_STRLEN,
                                             ORDER_ANY,
                                             OPTIONAL_NONE
                                             );

                    if (ietResult == INPUT_GOOD){

                        ZoomModule = calloc(1, MODULE_SIZE);
                        if (ZoomModule==NULL) {
                            FPRINTF(stderr, "\nAllocation of zoom module %s failed\n", argv[i]);
                            exit(1);
                        }

                        SetModuleName( ZoomModule, tmpName );
                        ZoomModule->bZoom = TRUE;
                        //
                        //For compatibility with original behaviour (when monitoring kernel only)
                        //We'll also use this for allowing the user to specify zoom modules common accross processes
                        //
                        if (ProcToMonitor == NULL){       
                            ZoomModule->Next = gCommonZoomList; 
                            gCommonZoomList = ZoomModule; 
                        } else {
                            ZoomModule->Next = ProcToMonitor->ZoomList;
                            ProcToMonitor->ZoomList = ZoomModule;
                        }
                        bZoomSpecified = TRUE;
                        ++i;
                            
                    } else if( ietResult == MISSING_PARAMETER ||
                                                             ietResult == MISSING_STRING ||
                                                             ietResult == MISSING_REQUIRED_STRING ) {
                        ExitWithMissingEntryMessage(argv[i],
                                                    "'-z modulename' option requires a module name, multiple usage is allowed\nRead the usage guide or help printout for more options",
                                                    TRUE
                                                    );
                    } else if(ietResult == UNKNOWN_OPTION) {
                        ExitWithUnknownOptionMessage(argv[i]);
                    }

                    break;

                case 'H':
                case '?':
                    //
                    // We don't really care about bogus trailing letters or entries here
                    // Print Usage string and exits
                    //
                    Usage(TRUE);
                    break;

                default:
                    //
                    // Specify the unknown option and print the Usage string. Then exists.
                    //
                    ExitWithUnknownOptionMessage(argv[i]);
            }
        } else {    //if ((argv[i][0] == '-') || (argv[i][0] == '/'))
            Usage(FALSE);
            FPRINTF(stderr,
                    "\n===>KERNRATE: Invalid switch %s\n",
                    argv[i]
                    );
            exit(1);
        }
    }

    //
    // User asked for system resource information but has not turned on kernel profile
    // The resource information depends on Kernrate initializing for the system process. 
    // We'll turn kernel profile on and issue a message
    //
    if( bIncludeSystemLocksInfo == TRUE && bCombinedProfile == FALSE){
        bCombinedProfile = TRUE;
        FPRINTF(stderr, "\n===>KERNRATE: User requested System resource (locks) information but did not turn on kernel profiling\n");
        FPRINTF(stderr, "                System resource information depends on Kernrate initializing for kernel profiling\n");
        FPRINTF(stderr, "                Kernel profiling will therefore be started by kernrate on behalf of the user\n");
    }

    //
    // Both i386 and IA64 processors cannot always support turning on several profile sources simultaneously.
    // This is because not every combination of profile sources can be turned on together.
    // AMD64 does allow turning on up to 4 profile sources concurrently (in any combination).
    // We'll automatically adapt the profiling method if the user specified more than the maximum 
    // simultaneous sources allowed but did not specify the '-c' option on the command line.
    // Default switching interval will be used in that case. 
    //
    if( SourcesSoFar > gMaxSimultaneousSources ){
        
        if( bOldSampling == FALSE ){
            bOldSampling = TRUE;
            FPRINTF( stdout, "\nNOTE:\nThe number of sources specified is greater than the maximum that can be turned on\n");
            FPRINTF( stdout, "simultaneously on this machine (%u), Kernrate will therefore profile one source at a time\n",
                             gMaxSimultaneousSources
                             );
            FPRINTF( stdout, "The overall run time will be devided into segments (no. processes x no. profile sources)\n");
            FPRINTF( stdout, "The interval for switching between sources and processes is currently set to %dms\n",
                             gChangeInterval
                             );
            FPRINTF( stdout, "This interval can be adjusted using the '-c# N' command line option, where N is in [ms]\n\n");
        }                 
    }else{
        if( SourcesSoFar > 1 ){

#if defined(_IA64_)
            FPRINTF( stdout, "\nNOTE: Kernrate Will attempt to turn on simultaneously the sources specified\n");
            FPRINTF( stdout, "but it is not guaranteed that just any combination of sources will work together\n");
            FPRINTF( stdout, "on this machine. No hits will be recorded for any source that could not be turned on\n");
#else if defined(_AMD64_)
            FPRINTF( stdout, "\nNOTE: The sources specified will be turned on simultaneously\n");
#endif // _IA64_

        }
    }

    if ( SourcesSoFar == 0 ){
        FPRINTF(stderr, "\n===>KERNRATE: User apparently turned OFF the default source (TIME), but did not specify any other valid source\n");
        FPRINTF(stderr, "              Kernrate needs at least one valid CPU source with non-zero rate to perform a profile\n");
        FPRINTF(stderr, "              Use the '-i SourceName Interval' command line option to specify a source\n");
        FPRINTF(stderr, "              Use the '-lx' command line option to get a list of supported CPU sources on the current platform\n");
        FPRINTF(stderr, "              Only general information will be available as a result of this run\n");
        bOldSampling = FALSE; //To prevent early exit
    }

    //
    // Determine supported sources and set Profile Interval as necessary
    //
    ProcToMonitor = gProcessList;
    for (i=0; i < (LONG)gNumProcToMonitor; i++){
       SetProfileSourcesRates( ProcToMonitor );
       ProcToMonitor = ProcToMonitor->Next;
    }

    return;

} /* GetConfiguration() */

INPUT_ERROR_TYPE
IsInputValid(int    argc,
               int    OptionIndex,
               PCHAR  *Option,
               PCHAR  AllowedTrailLetters,
               PLONG  AssociatedNumber,
               PCHAR  AssociatedString,
               ULONG  MaxStringLength,
               INPUT_ORDER Order,
               INPUT_OPTIONAL Optional
               )
/*++

Routine Description:

Checks the validity of a command line input entry:
 1. Unallowed duplicate entries
 2. Bogus trailing letters
 3. Missing or bogus associated parameters
 4. Type and validity of additional parameters

Arguments:

argc                - The number of command line arguments (including the kernrate process name)
OptionIndex         - The current index of a command line entry
Option              - A pointer to the command line entry (argv)
AllowedTrailLetters - A character string of the allowed sub-option letters that can come with an entry
                      (For example, the -n option can also accept -nv and or -n# so the string would be "v#"
AssociatedNumber    - A pointer to optional or required data (number) to be specified with the option
AssociatedString    - Same as above, but for a string
MaxStringLength     - Maximum allowed characters in the associated string
Order               - In case of two possible associated parameters (a number and a string), which one should come first
Optional            - In case of two possible associated parameters (a number and a string), which one is optional

Input/Output        
                    - When AssociatedNumber is not NULL the value found will be filled if it exists
                    - When AssociatedString is not NULL the string found will be filled in if it exists
Return Value:       
                    - Error type/condition

--*/

{
    BOOL bFoundNumber  = FALSE;
    BOOL bFoundString  = FALSE;
    int  index;
    LONG i;
    LONG OptionLength  = lstrlen(Option[OptionIndex]);
    LONG TrailerLength = lstrlen(AllowedTrailLetters);
    const int maxIndex = sizeof(InputOption)/sizeof(InputOption[0])-1;
    const int wIndex   = 'W' - 'A';
    //
    //Check for unallowed duplicate entries
    //
    index = toupper(Option[OptionIndex][1]) - 'A';
    if( index < 0 || index > maxIndex ){            //Sanity check (should have been detected already in GetConfiguration) 
        ExitWithUnknownOptionMessage(Option[OptionIndex]);
    }    
    //
    // Deal with special case ('-w' and '-wp')
    //
    if(index == wIndex){
        if( strchr(Option[OptionIndex], 'p') || strchr(Option[OptionIndex], 'P') ){
            wpCount.ActualCount += 1;
            if( wpCount.ActualCount > wpCount.Allowed ){
                InputOption[index].ActualCount = InputOption[index].Allowed; //cause failure
            }
        } else {
            wCount.ActualCount += 1;
            if( wCount.ActualCount > wCount.Allowed ){
                InputOption[index].ActualCount = InputOption[index].Allowed; //cause failure
            }
        }
    }

    InputOption[index].ActualCount += 1;
    if( (InputOption[index].Allowed > -1) && InputOption[index].ActualCount > InputOption[index].Allowed ){
        FPRINTF(stderr, "KERNRATE: ERROR - Command line option -%c (or a variant) appears more times than allowed (%d)\n",
                        InputOption[index].InputOption,
                        InputOption[index].Allowed
                        );
        if( index == wIndex ){
            FPRINTF(stderr, "          (One time for the '-w' option and one time for the '-wp' option)\n");
        }
        exit(1);
    } else if( (InputOption[index].Allowed == -2) && InputOption[index].ActualCount > 1 ){
        FPRINTF(stderr, "KERNRATE: WARNING - Command line option -%c (or a variant) appears more than once (non-critical error)\n",
                        InputOption[index].InputOption
                        );
    }
    //
    //Check for bogus trailing letters
    //
    if(  OptionLength <= 2+TrailerLength ){
        for(i=2; i < OptionLength; i++)
        {
            if( !strchr(AllowedTrailLetters, tolower(Option[OptionIndex][i])) ){
                return (UNKNOWN_OPTION);
            }
        }
    } else {
        return (UNKNOWN_OPTION);
    }
    //
    //Check for missing (or bogus) associated parameters following the command line option
    //
    if (OptionIndex+1 == argc || Option[OptionIndex+1][0] == '-' || Option[OptionIndex+1][0] == '/'){
        if( (AssociatedNumber != NULL) && (AssociatedString != NULL) ){
            return (MISSING_PARAMETER);
        }
        if( AssociatedNumber != NULL ){
            if( strchr(Option[OptionIndex], '#') ){
                return (MISSING_REQUIRED_NUMBER);
            }
            return (MISSING_NUMBER);
        }
        if( AssociatedString != NULL ){
            return (MISSING_STRING);
        }
    } else {
        if( (AssociatedNumber == NULL) && (AssociatedString == NULL) ){
            return (BOGUS_ENTRY);
        }
    }
    //
    //Check if the next parameter is a number or a string and fill in its value
    //Consider the specified order in the case of two parameters
    //
    if( strchr(Option[OptionIndex], '#') || (NULL != AssociatedNumber) ){
        if( (IsStringANumber( Option[OptionIndex+1] )) &&
                        ((Order == ORDER_NUMBER_FIRST) || (Order == ORDER_ANY)) ) {    
            bFoundNumber = TRUE;
            if( NULL == AssociatedString){
                *AssociatedNumber = atol( Option[OptionIndex+1] );
            }
        } else if( NULL != AssociatedString ) { //Either not a number,
                                                //or this number must be a string as indicated by the order
            strncpy( AssociatedString, Option[OptionIndex+1],  MaxStringLength);
            AssociatedString[MaxStringLength-1] = '\0';
            bFoundString = TRUE;
        } else {
            return (INVALID_NUMBER); //We get here only if we did not expect a string but got one
        }
    } else if ( NULL != AssociatedString ) {
        strncpy( AssociatedString, Option[OptionIndex+1],  MaxStringLength);
        AssociatedString[MaxStringLength-1] = '\0';
        bFoundString = TRUE;
    }
    //
    //Check if there is another parameter in continuation, if two parameters are asked for
    //
    if( (AssociatedNumber != NULL) && (AssociatedString != NULL) ){
        if ( OptionIndex+2 == argc || Option[OptionIndex+2][0] == '-' || Option[OptionIndex+2][0] == '/' ){
            //
            // There is no second parameter
            //
            if(bFoundNumber){
                if( (Optional == OPTIONAL_NUMBER) ) { //First parameter a number but it should be taken as a string
                    strncpy( AssociatedString, Option[OptionIndex+1],  MaxStringLength);
                    AssociatedString[MaxStringLength-1] = '\0';
                    if( strchr(Option[OptionIndex], '#') ){
                        return (MISSING_REQUIRED_NUMBER);
                    }
                    return (MISSING_NUMBER);
                } else {
                    *AssociatedNumber = atol( Option[OptionIndex+1] ); //Already checked if it is a valid number
                    if( ((Optional != OPTIONAL_STRING) && (Optional != OPTIONAL_ANY)) ){
                        return (MISSING_REQUIRED_STRING);
                    } else {
                        return (MISSING_STRING);
                    }
                }
            } else {                                           //Found a string as first parameter
                if( strchr(Option[OptionIndex], '#') ||
                       ((Optional != OPTIONAL_NUMBER) && (Optional != OPTIONAL_ANY)) ){
                    return (MISSING_REQUIRED_NUMBER);
                }
                return (MISSING_NUMBER);
            }
        } else if (bFoundString){                              //Found a string as first parameter
            if( IsStringANumber( Option[OptionIndex+2] ) ){    
                *AssociatedNumber = atol( Option[OptionIndex+2] );
            } else {
                return (INVALID_NUMBER);
            }
        } else {                                               //Found a number as first parameter
            *AssociatedNumber = atol( Option[OptionIndex+1] ); //Already checked if it is a valid number
            strncpy( AssociatedString, Option[OptionIndex+2],  MaxStringLength );
            AssociatedString[MaxStringLength-1] = '\0';
        }
    }

    return (INPUT_GOOD);
}// IsInputValid()
              
VOID
ExitWithUnknownOptionMessage(PCHAR CurrentOption)
{
    Usage(FALSE);
    FPRINTF(stderr,
            "KERNRATE: Unknown command line option '%s' <---Check for missing space separator or bogus characters/entries\n",
            CurrentOption
            );
    exit(1);
}

VOID
InvalidEntryMessage(
    PCHAR CurrentOption,
    PCHAR CurrentValue,
    PCHAR Remark,
    BOOL  bUsage,
    BOOL  bExit
    )
{
    if(bUsage)
        Usage(FALSE);
    FPRINTF(stderr,
            "\n===>KERNRATE: Invalid entry %s %s \n%s\n",
            CurrentOption,
            CurrentValue,
            Remark
            );
    if(bExit)
        exit(1);
}

VOID
ExitWithMissingEntryMessage(
    PCHAR CurrentOption,
    PCHAR Remark,
    BOOL  bUsage
    )
{
    if(bUsage)
        Usage(FALSE);
    FPRINTF(stderr,
            "\n===>KERNRATE: Missing entry for command line option %s \n%s\n",
            CurrentOption,
            Remark
            );
    exit(1);
}

PPROC_TO_MONITOR
InitializeProcToMonitor(LONGLONG Pid)
/*++

Routine Description:

Opens the given process and gets a handle to it
Allocates a process structure and initializes it
Initializes the profile source information for this process

Arguments:

Pid                 - The process ID (PID)

Return Value:       
                    - Pointer to the process structure

--*/

{
    HANDLE           SymHandle;
    PPROC_TO_MONITOR ProcToMonitor;
    PMODULE          tmpModule, ZoomModule;

    SymHandle = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, //PROCESS_ALL_ACCESS,
                            FALSE,
                            (DWORD)Pid);

    if (SymHandle==NULL) {
        FPRINTF(stderr,
                "KERNRATE: OpenProcess Pid= (%I64d) failed - it could be just gone %d\n",
                Pid,
                GetLastError()
        );
        return (NULL);
    }

    ProcToMonitor = calloc(1, sizeof(PROC_TO_MONITOR));
    if (ProcToMonitor==NULL) {
        FPRINTF(stderr, "\n===>KERNRATE: Allocation for Process %I64d failed\n", Pid);
        exit(1);
    }

    ProcToMonitor->ProcessHandle         = SymHandle;
    ProcToMonitor->Pid                   = Pid;
    ProcToMonitor->Index                 = gNumProcToMonitor;
    ProcToMonitor->ProcessName           = "";               //Will be set in GetProcessModuleInformation 
    ProcToMonitor->ModuleCount           = 0;
    ProcToMonitor->ZoomCount             = 0;
    ProcToMonitor->ModuleList            = NULL;
    ProcToMonitor->ZoomList              = NULL;
    ProcToMonitor->Source                = NULL;
//MC
    ProcToMonitor->JITHeapLocationsStart = NULL;
    ProcToMonitor->JITHeapLocationsStop  = NULL;
//MC
    ProcToMonitor->pProcThreadInfoStart  = NULL;

    gNumProcToMonitor++;                     

    //
    //copy the common module list to the current process zoom list
    //
    tmpModule = gCommonZoomList;
    while( tmpModule != NULL ){

        ZoomModule = calloc(1, MODULE_SIZE);

        if (ZoomModule==NULL) {
            FPRINTF(stderr, "Allocation of memory for common zoom list failed\n");
            exit(1);
        }
                       
        strncpy(ZoomModule->module_Name, tmpModule->module_Name, cMODULE_NAME_STRLEN-1);
        ZoomModule->module_Name[cMODULE_NAME_STRLEN-1] = '\0'; 

        ZoomModule->bZoom = TRUE;

        ZoomModule->Next = ProcToMonitor->ZoomList;
        ProcToMonitor->ZoomList = ZoomModule;                       
                       
        tmpModule = tmpModule->Next;
    }
                    
    //
    //Initialize Profile Source Info for this process
    // 
    InitializeProfileSourceInfo(ProcToMonitor);

    ProcToMonitor->Next           = gProcessList;
    gProcessList                  = ProcToMonitor;

    return (ProcToMonitor);
}// InitializeProcToMonitor()

VOID
UpdateProcessStartInfo(
    PPROC_TO_MONITOR ProcToMonitor,
    PTASK_LIST TaskListEntry,
    BOOL  bIncludeProcessThreadsInfo
    )
{
    if(ProcToMonitor != NULL && TaskListEntry != NULL){
        memcpy(&ProcToMonitor->ProcPerfInfoStart,
               &TaskListEntry->ProcessPerfInfo,
               sizeof(TaskListEntry->ProcessPerfInfo)
               ); 

        if( bIncludeProcessThreadsInfo == TRUE ){
            if( &TaskListEntry->pProcessThreadInfo != NULL ){
                ProcToMonitor->pProcThreadInfoStart =
                    malloc(ProcToMonitor->ProcPerfInfoStart.NumberOfThreads*sizeof(SYSTEM_THREAD_INFORMATION));
                if( ProcToMonitor->pProcThreadInfoStart == NULL){
                    FPRINTF(stderr, "KERNRATE: Memory allocation failed for process thread-information, attempting to continue without it\n");
                    return;
                }
                memcpy(&ProcToMonitor->pProcThreadInfoStart, 
                       &TaskListEntry->pProcessThreadInfo,
                       sizeof(TaskListEntry->pProcessThreadInfo)
                       );
            }
        }
    }
}

PSOURCE
InitializeStaticSources(
    VOID
    )
{
    PSOURCE                       source = StaticSources;

#if defined(_IA64_)
    NTSTATUS                      status;
    PSYSTEM_PROCESSOR_INFORMATION sysProcInfo;

    sysProcInfo = malloc(sizeof(SYSTEM_PROCESSOR_INFORMATION));
    if(sysProcInfo == NULL){
        FPRINTF(stderr,"Memory allocation failed for SystemProcessorInformation in InitializeStaticsources\n");
        exit(1);
    }
    status = NtQuerySystemInformation( SystemProcessorInformation,
                                       sysProcInfo,
                                       sizeof(SYSTEM_PROCESSOR_INFORMATION),
                                       NULL);

    if ( NT_SUCCESS(status) && 
        (sysProcInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) ) {

        ULONG n;

        switch( IA64ProcessorLevel2ProcessorFamily( sysProcInfo->ProcessorLevel ) ) {
            case IA64_FAMILY_MERCED:
               //
               // Patch the last entry as defined with convention used to initialize
               // gSourceMaximum.
               //

               n = sizeof(mercedStaticSources)/sizeof(mercedStaticSources[0]);
               mercedStaticSources[n-1].Name       = NULL;
               mercedStaticSources[n-1].ShortName  = "";
               source = mercedStaticSources;
               break;

            case IA64_FAMILY_MCKINLEY:
            default: // Following HALIA64 scheme, default IPF PMU as McKinley PMU.
               n = sizeof(mckinleyStaticSources)/sizeof(mckinleyStaticSources[0]);
               mckinleyStaticSources[n-1].Name       = NULL;
               mckinleyStaticSources[n-1].ShortName  = "";
               source = mckinleyStaticSources;
               break;
        }

        if ( sysProcInfo != NULL ) {
            free(sysProcInfo);
            sysProcInfo = NULL;
        } 
    }
#endif // _IA64_

#if defined(_AMD64_)
    source = Amd64StaticSource;
#endif // _AMD64_

    return source;

} // InitializeStaticSources()

ULONG
InitializeProfileSourceInfo (
    PPROC_TO_MONITOR ProcToMonitor
    )
/*++

Function Description:

    This function initializes the Profile sources.

Argument:

    Pointer to Process to be monitored or NULL if only Maximum Source Count is needed.

Return Value:

    Maximum Source Count Found.

Algorithm:

    ToBeSpecified

In/Out Conditions:

    ToBeSpecified

Globals Referenced:

    ToBeSpecified

Exception Conditions:

    ToBeSpecified

MP Conditions:

    ToBeSpecified

Notes:

    This function has been enhanced from its original version
    to support and use the static profiling sources even if the
    pstat driver is not present or returned no active profiling
    event.

ToDo List:

    ToBeSpecified

Modification History:

    3/17/2000  TF  Initial version

--*/
{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    const ULONG                 bufferSize = 400;
    PUCHAR                      buffer;
    ULONG                       i, j;
    PEVENTID                    Event;
    HANDLE                      DriverHandle;
    PEVENTS_INFO                eventInfo;
    PSOURCE                     staticSource, src;
    ULONG                       staticCount, driverCount, totalCount;

    DriverHandle = INVALID_HANDLE_VALUE;
    staticCount = driverCount = 0;

    buffer = malloc(bufferSize*sizeof(UCHAR));
    if(buffer == NULL){
        FPRINTF(stderr,"Memory allocation failed for buffer in InitializeProfileSourceInfo\n");
        exit(1);
    }

    //
    // Try to Open PStat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if ( NT_SUCCESS(status) ) {

        //
        // Determine how many events the driver provides
        //
        
        if (WIN2K_OS)
        {
            Event = (PEVENTID) buffer;

            do {
                *((PULONG) buffer) = driverCount;
                driverCount += 1;

                status = NtDeviceIoControlFile(
                            DriverHandle,
                            (HANDLE) NULL,          // event
                            (PIO_APC_ROUTINE) NULL,
                            (PVOID) NULL,
                            &IOSB,
                            PSTAT_QUERY_EVENTS,
                            buffer,                 // input buffer
                            bufferSize,
                            NULL,                   // output buffer
                            0
                            );
            } while (NT_SUCCESS(status));

        } else {                                                       // WinXP/.Net and above

            eventInfo = (PEVENTS_INFO)buffer;

            status = NtDeviceIoControlFile( DriverHandle,
                                            (HANDLE) NULL,          // event
                                            (PIO_APC_ROUTINE) NULL,
                                            (PVOID) NULL,
                                            &IOSB,
                                            PSTAT_QUERY_EVENTS_INFO,
                                            buffer,                 // input buffer
                                            bufferSize,
                                            NULL,                   // output buffer
                                            0
                                          );

            if(NT_SUCCESS(status)) driverCount = eventInfo->Events;
            if ( driverCount ) {
                if ( eventInfo->TokenMaxLength > gTokenMaxLen )  {
                     gTokenMaxLen = eventInfo->TokenMaxLength;
                }
                if ( eventInfo->DescriptionMaxLength > gDescriptionMaxLen )  {
                     gDescriptionMaxLen = eventInfo->DescriptionMaxLength;
                }
            }

        }

    }

    //
    // Determine how many static events there are and
    // re-initialize the format specifiers if needed.
    //

    src = staticSource = InitializeStaticSources();

    //
    // There should be at least one static source (TIME)
    //
    if( staticSource == NULL ) {
        FPRINTF(stderr, "KERNRATE: InitializeStaticSources returned NULL, Aborting\n");
        exit(1);
    } 

    while( src->Name != NULL ) {
        if ( lstrlen( src->Name ) > (LONG)gDescriptionMaxLen )   {
            gDescriptionMaxLen = lstrlen( src->Name );
        }
        if ( strlen( src->ShortName ) > gTokenMaxLen )   {
            gTokenMaxLen = lstrlen( src->ShortName );
        }
        staticCount++;
        src++;
    }

    gStaticSource = staticSource;
    gStaticCount  = staticCount;
    totalCount = driverCount + staticCount;

    //
    //Calling this routine with NULL will just return the maximum source count
    //
    
    if(ProcToMonitor != NULL){
        //
        // Allocate memory for static events, plus the driver provided events
        //
        ProcToMonitor->Source = calloc(totalCount, sizeof(SOURCE));
        if ( ProcToMonitor->Source == NULL )   {
            FPRINTF(stderr, "KERNRATE: Events memory allocation failed\n" );
            if ( IsValidHandle( DriverHandle ) )    {
                NtClose (DriverHandle);
            }
            exit(1);
        }

        //
        // copy static events to new list
        //

        for (j=0; j < staticCount; j++) {
            ProcToMonitor->Source[j] = staticSource[j];
        }

        //
        // Append the driver provided events to new list
        //

        if ( IsValidHandle( DriverHandle ) ) {
            Event = (PEVENTID) buffer;
            for (i=0; i < driverCount; i++) {
                *((PULONG) buffer) = i;
                status = NtDeviceIoControlFile( DriverHandle,
                                                (HANDLE) NULL,          // event
                                                (PIO_APC_ROUTINE) NULL,
                                                (PVOID) NULL,
                                                &IOSB,
                                                PSTAT_QUERY_EVENTS,
                                                buffer,                 // input buffer
                                                bufferSize,
                                                NULL,                   // output buffer
                                                0
                                                );

                //
                // Source Names:
                //   - For the Name, we use the description
                //   - For the short Name, we use the token string stored
                //     in the first string of the buffer
                //
                if( NT_SUCCESS(status) ){
                    ProcToMonitor->Source[j].Name            = _strdup ( (PCHAR)(Event->Buffer + Event->DescriptionOffset) );
                    ProcToMonitor->Source[j].ShortName       = _strdup( (PCHAR)Event->Buffer );
                    ProcToMonitor->Source[j].ProfileSource   = Event->ProfileSource;
                    ProcToMonitor->Source[j].DesiredInterval = Event->SuggestedIntervalBase;
                    j++;
                }

            } //for

        } //if( IsValidHandle() )

    } // if( ProcToMonitor )

    if ( IsValidHandle( DriverHandle ) ){
        NtClose (DriverHandle);
    }
    if(buffer != NULL){
        free(buffer);
        buffer = NULL;
    }
    return( totalCount );

} // InitializeProfileSourceInfo()

ULONG
NextSource(
    IN ULONG CurrentSource,
    IN PMODULE ModuleList,
    IN PPROC_TO_MONITOR ProcToMonitor
    )

/*++

Routine Description:

    Stops the current profile source and starts the next one.

    If a Source is already started, it will be stopped first, otherwise no source will
    be stopped and the first active source will be started.

Arguments:

    CurrentSource - Supplies the current profile source

    ModuleList - Supplies the list of modules whose soruces are to be changed

    ProcToMonitor - Pointer to the process to be monitored

Return Value:

    Returns the new current profile source

--*/

{
    if ( ProcToMonitor->Source[CurrentSource].bProfileStarted == TRUE) {
        StopSource(CurrentSource, ModuleList, ProcToMonitor);
        ProcToMonitor->Source[CurrentSource].bProfileStarted = FALSE;
    }

    //
    // Iterate through the available sources to find the
    // next active source to be started.
    //
    if (ModuleList->mu.bProfileStarted == FALSE) {
        CurrentSource = 0;
        while ( ProcToMonitor->Source[CurrentSource].Interval == 0 ){
            CurrentSource = CurrentSource+1;
            if (CurrentSource >= gSourceMaximum) {
                FPRINTF(stderr, "\n===>KERNRATE: NextSource - No valid sources found to start profiling\n"); 
                exit(1);
            }            
        }    
    } else {
        do {
            CurrentSource = CurrentSource+1;
            if (CurrentSource == gSourceMaximum) {
                CurrentSource = 0;
            }
        } while ( ProcToMonitor->Source[CurrentSource].Interval == 0);
    }

    StartSource(CurrentSource, ModuleList, ProcToMonitor);
    ProcToMonitor->Source[CurrentSource].bProfileStarted = TRUE;

    return(CurrentSource);
}


VOID
StopSource(
    IN ULONG ProfileSourceIndex,
    IN PMODULE ModuleList,
    IN PPROC_TO_MONITOR ProcToMonitor
    )

/*++

Routine Description:

    Stops all profile objects for a given source

Arguments:

    ProfileSource - Supplies the source to be stopped.

    ModuleList - Supplies the list of modules whose profiles are to be stopped

    ProcToMonitor - Pointer to the process to be monitored

Return Value:

    None.

--*/

{
    PMODULE   Current;
    NTSTATUS  Status;
    NTSTATUS  SaveStatus;
    ULONGLONG StopTime;
    ULONGLONG ElapsedTime;
    LONG      CpuNumber;

    Current = ModuleList;
    while (Current != NULL) {
        SaveStatus = STATUS_SUCCESS;
        
      for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
        if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;

        Status = NtStopProfile(Current->Rate[ProfileSourceIndex].ProfileHandle[CpuNumber]);

        if (!NT_SUCCESS(Status)) {
            SaveStatus = Status;
            FPRINTF(stderr,
                    "Pid= %I64d (%s) - NtStopProfile on source %s on CPU %d failed, %s %08lx",
                    ProcToMonitor->Pid,
                    ProcToMonitor->ProcessName,
                    ProcToMonitor->Source[ProfileSourceIndex].Name,
                    CpuNumber,
                    Current->module_Name,
                    Status);
            if(Status == STATUS_NO_MEMORY)FPRINTF(stderr, " - Status = NO_MEMORY");
            if(Status == STATUS_PROFILING_NOT_STARTED)FPRINTF(stderr, " - Status = PROFILING_NOT_STARTED");
            FPRINTF(stderr,"\n");
        }
        
      }

      if (NT_SUCCESS(SaveStatus)) {
      
          GetSystemTimeAsFileTime((LPFILETIME)&StopTime);

          ElapsedTime = StopTime - Current->Rate[ProfileSourceIndex].StartTime;
          Current->Rate[ProfileSourceIndex].TotalTime += ElapsedTime;

          for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {

              Current->Rate[ProfileSourceIndex].TotalCount[CpuNumber] += 
                  Current->Rate[ProfileSourceIndex].CurrentCount[CpuNumber];
              Current->Rate[ProfileSourceIndex].CurrentCount[CpuNumber] = 0;
          }
      }
      Current = Current->Next;

    }
}


VOID
StartSource(
    IN ULONG ProfileSourceIndex,
    IN PMODULE ModuleList,
    IN PPROC_TO_MONITOR ProcToMonitor
    )

/*++

Routine Description:

    Starts all profile objects for a given source

Arguments:

    ProfileSource - Supplies the source to be started.

    ModuleList - Supplies the list of modules whose profiles are to be stopped

    ProcToMonitor - Pointer to the process to be monitored

Return Value:

    None.

--*/

{
    PMODULE   Current;
    NTSTATUS  Status;
    LONG      CpuNumber;

    Current = ModuleList;

    while (Current != NULL) {
      
      for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
        if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;
        Status = NtStartProfile(Current->Rate[ProfileSourceIndex].ProfileHandle[CpuNumber]);
        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr,
                    "Pid= %I64d (%s) - NtStartProfile on source %s for Module %s failed on CPU %d, %08lx",
                    ProcToMonitor->Pid,
                    ProcToMonitor->ProcessName,
                    ProcToMonitor->Source[ProfileSourceIndex].Name,
                    Current->module_Name,
                    CpuNumber,
                    Status);
            
            if(Status == STATUS_PROFILING_NOT_STOPPED)FPRINTF(stderr, " - Status = PROFILING_NOT_STOPPED");
            if(Status == STATUS_NO_MEMORY)FPRINTF(stderr, " - Status = NO_MEMORY");
            if(Status == STATUS_INSUFFICIENT_RESOURCES){
                FPRINTF(stderr, " - Status = INSUFFICIENT_RESOURCES\n");
                FPRINTF(stderr, "KERNRATE: This issue can be caused by selecting a small bucket size and/or extensive zooming\n");
                FPRINTF(stderr, "          You may want to try the -c command line options in this case or not use the -m option");
            }
            FPRINTF(stderr,"\n");

        }
      }

      GetSystemTimeAsFileTime((LPFILETIME)&Current->Rate[ProfileSourceIndex].StartTime);
      Current = Current->Next;
    }
}

VOID
OutputResults(
    IN FILE *Out,
    IN PPROC_TO_MONITOR ProcToMonitor
    )

/*++

Routine Description:

    Outputs the collected data.

Arguments:

    Out - Supplies the FILE * where the output should go.

    ProcToMonitor - Pointer to the process to be monitored

Return Value:

    None.

--*/

{

    PRATE_DATA RateData;
    ULONG      i, ProfileSourceIndex, Index;
    ULONG      RoundDown;
    ULONG      ModuleCount;
    PULONG     Hits;
    LONG       CpuNumber;
    PMODULE    ModuleList                  = ProcToMonitor->ModuleList;
    PMODULE    Current;
    HANDLE     SymHandle                   = ProcToMonitor->ProcessHandle;
    BOOL       bAttachedToProcess          = FALSE;


    //
    // Sum up the total buffers of any zoomed modules
    //

    Current = ModuleList;
    while (Current != NULL) {
        if (Current->bZoom) {
            Current->mu.bHasHits = FALSE;

            for (Index=0; Index < gTotalActiveSources; Index++) {
                ProfileSourceIndex = gulActiveSources[Index];

                RateData = &Current->Rate[ProfileSourceIndex];
                RateData->GrandTotalCount = 0;
                //
                // Sum the entire profile buffer for this module/source
                //
                for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                    RateData->TotalCount[CpuNumber] = 0;
                    Hits = RateData->ProfileBuffer[CpuNumber];
                    for (i=0; i < BUCKETS_NEEDED(Current->Length); i++) {
                        RateData->TotalCount[CpuNumber] += Hits[i];
                        if( Hits[i] > 0 ) Current->mu.bHasHits = TRUE;
                    }
                    RateData->GrandTotalCount += RateData->TotalCount[CpuNumber];
                }
            }
        }
        Current = Current->Next;
    }

    //
    // Output the results ordered by profile source.
    //
    if(SymHandle == SYM_KERNEL_HANDLE){
       ModuleCount = gKernelModuleCount;
       FPRINTF(stdout, "OutputResults: KernelModuleCount = %d\n", ModuleCount);
       FPRINTF(stdout, "Percentage in the following table is based on the Total Hits for the Kernel\n"); 

    } 
    else{
       ModuleCount = ProcToMonitor->ModuleCount;
//MC
       FPRINTF(stdout, "OutputResults: ProcessModuleCount (Including Managed-Code JITs) = %d\n", ModuleCount);
       FPRINTF(stdout, "Percentage in the following table is based on the Total Hits for this Process\n"); 
//MC    
    }
    
    OutputModuleList(Out, ModuleList, ModuleCount, ProcToMonitor, NULL);

    //
    // For any zoomed modules, create and output a module list
    // consisting of the functions in the module.
    //
    Current = ModuleList;
    while (Current != NULL) {
        if (Current->bZoom && Current->mu.bHasHits == TRUE) {

            FPRINTF(stderr, "===> Processing Zoomed Module %s...\n\n", Current->module_FileName);

            for (RoundDown = 0; RoundDown <= (bRoundingVerboseOutput ? 1UL:0UL); RoundDown++) {
                
                if ( (gVerbose & VERBOSE_PROFILING) ) {
                    FPRINTF(stdout, "\n -------------- VERBOSE PROFILE DATA FOR ZOOMED MODULE %s ----------------\n", Current->module_FileName);  
                    FPRINTF(stdout,
                            "Module Name, Parent Base Address, Module Base address, Current Bucket Index, Current Bucket Address, Total Current Bucket Hits, Per CPU Hits, Remarks\n\n"
                           );
                }   
                
                CreateZoomedModuleList(Current, RoundDown, ProcToMonitor);

                if(ProcToMonitor->ZoomList == NULL) {
                    FPRINTF(stdout, "No Hits or No symbols found for module %s\n", Current->module_FileName);
                } else {
                   PMODULE Temp;

                   FPRINTF(Out, "\n----- Zoomed module %s (Bucket size = %d bytes, Rounding %s) --------\n",
                            Current->module_FileName,
                            gZoomBucket,
                            (RoundDown ? "Up" : "Down" ) );
                   FPRINTF(stdout, "Percentage in the following table is based on the Total Hits for this Zoom Module\n"); 

                   OutputModuleList(Out, ProcToMonitor->ZoomList, gZoomCount, ProcToMonitor, Current);

                   CleanZoomModuleList(ProcToMonitor);  //Done with current module - prepare for next module
                }

            } //for rounddown/roundup loop
        
            //
            // Display the raw bucket counts for all zoomed modules
            //

            if (bRawData) {
                OutputRawDataForZoomModule( Out, ProcToMonitor, Current );
            }

            //
            // We are finished with processing the data for this zoom module, let's unload the associated symbol information
            //

            if(!SymUnloadModule64( ProcToMonitor->ProcessHandle, Current->Base))
                VerbosePrint(( VERBOSE_IMAGEHLP, "Kernrate: Could Not Unload Module, Base= %p for Process %s\n",
                                                 (PVOID64)Current->Base,
                                                 ProcToMonitor->ProcessName
                                                 ));

        } else { 
            if( Current->bZoom )
                FPRINTF(stdout, "No Hits were recorded for zoom module %s\n", Current->module_FileName);
        }    //if(Current->bZoom)

        Current = Current->Next;
    } //while module loop

//MC            
    if( bAttachedToProcess ){
        pfnDetachFromProcess();
        bAttachedToProcess = FALSE;
    }
//MC

    return;

} // OutputResults()

BOOL
CreateZoomModuleCallback(
    IN LPSTR   szSymName,
    IN ULONG64 Address,
    IN ULONG   Size,
    IN PVOID   Cxt
    )
{
    ULONG            Index, ProfileSourceIndex;
    BOOL             HasHits;
    LONG             CpuNumber;
    PMODULE          Module;
    PRATE_DATA       pRate;
    PPROC_TO_MONITOR ProcToMonitor;
    ULONG64          i, StartIndex, EndIndex, ip, disp, HighLimit;
    static ULONG64   LastIndex;
    static PMODULE   LastParentModule;
    static PPROC_TO_MONITOR LastCxt;
    
    HighLimit = Address + Size;

    Module = malloc(MODULE_SIZE);
    if (Module == NULL) {
        FPRINTF(stderr, "KERNRATE: CreateZoomModuleCallback failed to allocate Zoom module\n");
        exit(1);
    }

    ProcToMonitor  = (PPROC_TO_MONITOR) Cxt;

    Module->Base   = Address;
    Module->Length = Size;
    Module->bZoom  = FALSE;
    SetModuleName( Module, szSymName );
    pRate = malloc(gSourceMaximum*(RATE_DATA_FIXED_SIZE+RATE_DATA_VAR_SIZE));
    if (pRate == NULL) {
        FPRINTF(stderr, "KERNRATE: CreateZoomModuleCallback failed to allocate RateData\n");
        exit(1);
    }
    
    //
    // Compute range in profile buffer to sum.
    //
    StartIndex = (ULONG64)((Module->Base - gCallbackCurrent->Base) / gZoomBucket);
    EndIndex = (Module->Base + Module->Length - gCallbackCurrent->Base) / gZoomBucket;
    //
    // Check if we already counted the hits for this bucket for the present module
    // in case we had an address gap for the present module within the bucket itself
    //
    if(StartIndex == LastIndex && LastParentModule != (PMODULE)NULL &&
                               gCallbackCurrent == LastParentModule &&
                               LastCxt != (PPROC_TO_MONITOR)NULL && LastCxt == ProcToMonitor ){
        for (ip=gCallbackCurrent->Base+StartIndex*gZoomBucket; ip<Address; ip+=1){
            if( SymGetSymFromAddr64(ProcToMonitor->ProcessHandle, ip, &disp, gSymbol ) ){
                if( 0 == strcmp(gSymbol->Name, Module->module_Name ) ){
                    StartIndex+=1;             // We have a match, don't count this bucket for this module again
                    if(StartIndex > EndIndex){
                        HasHits = FALSE;
                        goto LABEL;           // No hits, jump to exit
                    }
                }
            }
        }
    }
    //
    // Look for hits in the current module and sum them up
    //
    HasHits = FALSE;
    for (Index=0; Index < gTotalActiveSources; Index++) {

        ProfileSourceIndex = gulActiveSources[Index];
        Module->Rate[ProfileSourceIndex] = pRate[ProfileSourceIndex];
            
        Module->Rate[ProfileSourceIndex].StartTime  = gCallbackCurrent->Rate[ProfileSourceIndex].StartTime;
        Module->Rate[ProfileSourceIndex].TotalTime  = gCallbackCurrent->Rate[ProfileSourceIndex].TotalTime;

        Module->Rate[ProfileSourceIndex].TotalCount = calloc(gProfileProcessors, sizeof(ULONGLONG) );
        if( Module->Rate[ProfileSourceIndex].TotalCount == NULL ){
            FPRINTF(stderr, "KERNRATE: Memory allocation failed for TotalCount in CreateZoomModuleCallback\n");
            exit(1);
        }

        Module->Rate[ProfileSourceIndex].DoubtfulCounts = 0;

        for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {

            Module->Rate[ProfileSourceIndex].TotalCount[CpuNumber] = 0;

            for (i=StartIndex; i <= EndIndex; i++) {
                Module->Rate[ProfileSourceIndex].TotalCount[CpuNumber] +=
                    gCallbackCurrent->Rate[ProfileSourceIndex].ProfileBuffer[CpuNumber][i];
            }

            if (Module->Rate[ProfileSourceIndex].TotalCount[CpuNumber] > 0) {
                HasHits = TRUE;
            }
        }
    }
LABEL:
    //
    // If the routine has hits add it to the list, otherwise
    // ignore it.
    //
    if (HasHits) {
        //
        //useful verbose print for identifying shared buckets and actual bucket inhabitants, see also raw data printout
        //
        if ( gVerbose & VERBOSE_PROFILING ) {
            
            ULONGLONG BucketCount, TotCount, DoubtfulCounts;
            CHAR LastSymName[cMODULE_NAME_STRLEN] = "\0";
            BOOL bCounted = FALSE;

            PIMAGEHLP_LINE64 pLine = (PIMAGEHLP_LINE64) malloc(sizeof(IMAGEHLP_LINE64));
            if ( pLine == NULL ){
                FPRINTF(stderr, "KERNRATE: Memory allocation failed for pLine in CreateZoomModuleCallback\n");
                exit(1);
            }
            pLine->SizeOfStruct = sizeof(IMAGEHLP_LINE64);

            for (Index=0; Index < gTotalActiveSources; Index++) {
                ProfileSourceIndex = gulActiveSources[Index];
                TotCount = 0;
                DoubtfulCounts = 0;
                for (i=StartIndex; i <= EndIndex; i++) {
                    bCounted = FALSE;
                    BucketCount=0;
                    for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                       BucketCount +=  gCallbackCurrent->Rate[ProfileSourceIndex].ProfileBuffer[CpuNumber][i];
                    }
                    TotCount += BucketCount;
                    if(BucketCount > 0){
                      
                        ip = gCallbackCurrent->Base + (ULONG64)(i*gZoomBucket);
                        //
                        // Print the info for the current bucket
                        //
                        FPRINTF(stdout, "%s, 0x%I64x, 0x%I64x, %I64d, 0x%I64x, %Ld",
                                Module->module_Name,
                                gCallbackCurrent->Base,
                                Module->Base,
                                i,
                                ip,
                                BucketCount
                                );              
                            
                        for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                            if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;
                            FPRINTF(stdout, ", %Ld",
                                    gCallbackCurrent->Rate[ProfileSourceIndex].ProfileBuffer[CpuNumber][i]
                                    ); 
                        }
                      
                        OutputLineFromAddress64( ProcToMonitor->ProcessHandle, ip, pLine ); 
                        //
                        // Find out if anyone else is sharing this bucket
                        //
                        disp = 0;
                        for(; (ip<gCallbackCurrent->Base + (ULONG64)((i+1)*gZoomBucket))&&(ip < HighLimit); ip+=1) {
                            if ( SymGetSymFromAddr64(ProcToMonitor->ProcessHandle, ip, &disp, gSymbol ) ) {
                                if (0 != strcmp( Module->module_Name, gSymbol->Name ) ){
                                    if(!bCounted){
                                        FPRINTF(stdout, " , Actual Hits Should be Attributed to or Shared with ===> %s+0x%I64x",
                                                        gSymbol->Name,
                                                        disp
                                                        );

                                        OutputLineFromAddress64( ProcToMonitor->ProcessHandle, ip+disp, pLine ); 
                                        DoubtfulCounts += BucketCount;
                                        strncpy(LastSymName, gSymbol->Name, cMODULE_NAME_STRLEN-1);
                                        LastSymName[cMODULE_NAME_STRLEN-1] = '\0';
                                        bCounted = TRUE;
                                    } else if( 0 != strcmp(LastSymName, gSymbol->Name ) ){
                                        FPRINTF(stdout, "\nActual Hits Should also be Attributed to or Shared with ===> %s+0x%I64x",
                                                        gSymbol->Name,
                                                        disp
                                                        );

                                        OutputLineFromAddress64( ProcToMonitor->ProcessHandle, ip+disp, pLine ); 
                                        strncpy(LastSymName, gSymbol->Name, cMODULE_NAME_STRLEN-1);
                                        LastSymName[cMODULE_NAME_STRLEN-1] = '\0';
                                    }
                                }
                            } else {
                                //
                                //This should be rare (no need to increase the doubtful counts)
                                //
                                FPRINTF(stdout, " , Actual Hits Should be Attributed to or Shared with ===> UNKNOWN_SYMBOL"); 
                            }
                        }
                        FPRINTF(stdout, "\n");
                    }
                } 
                //
                // Print the totals for the current module
                //
                FPRINTF(stdout, "%s, %s - Module Total Count = %I64d, Total Doubtful or Shared Counts = %I64d\n\n",
                                ProcToMonitor->Source[ProfileSourceIndex].Name,
                                Module->module_Name,
                                TotCount,
                                DoubtfulCounts
                                );
                Module->Rate[ProfileSourceIndex].DoubtfulCounts = DoubtfulCounts; 
            
                if( pLine != NULL ){
                    free(pLine);
                    pLine = NULL;
                }
            }      
        }     // if(VERBOSE_PROFILING)

        Module->Next = ProcToMonitor->ZoomList;
        ProcToMonitor->ZoomList = Module;
        ++gZoomCount;

    } else {
        //
        // Cleanup
        //
        for (Index=0; Index < gTotalActiveSources; Index++) {
            ProfileSourceIndex = gulActiveSources[Index];
            if ( Module->Rate[ProfileSourceIndex].TotalCount != NULL){
                free(Module->Rate[ProfileSourceIndex].TotalCount);
                Module->Rate[ProfileSourceIndex].TotalCount = NULL;
            }
        } 
        if( pRate != NULL ){
            free(pRate);
            pRate = NULL;
        }
        if( Module != NULL ){
            free(Module);
            Module = NULL;
        }
    }
    LastIndex = EndIndex;
    LastParentModule = gCallbackCurrent;
    LastCxt = ProcToMonitor;
//MC
    //
    //Imagehlp SymEnumerateSymbols64 returns SUCSESS even if no symbols are found
    //We need an indication wheter we need to go into expensive Managed-Code symbol enumeration
    //
    bImageHlpSymbolFound = TRUE;
//MC
    return(TRUE);

} //CreateZoomModuleCallback

BOOL
CreateJITZoomModuleCallback(
    IN PWCHAR  wszSymName,  
    IN LPSTR   szSymName,
    IN ULONG64 Address,
    IN ULONG   Size,
    IN PVOID   Cxt
    )
{
    ULONG            ProfileSourceIndex, Index;
    BOOL             HasHits;
    LONG             CpuNumber;
    PMODULE          Module;
    PRATE_DATA       pRate;
    PPROC_TO_MONITOR ProcToMonitor;
    ULONG64          i, StartIndex, EndIndex, ip, HighLimit;
    static ULONG64   LastIndex;
    static PMODULE   LastParentModule;
    static PPROC_TO_MONITOR LastCxt;
    
    HighLimit = Address + Size;

    Module = malloc(MODULE_SIZE);
    if (Module == NULL) {
        FPRINTF(stderr, "KERNRATE: CreateZoomModuleCallback failed to allocate Zoom module\n");
        exit(1);
    }

    ProcToMonitor  = (PPROC_TO_MONITOR) Cxt;

    Module->Base   = Address;
    Module->Length = Size;
    Module->bZoom  = FALSE;
    SetModuleName( Module, szSymName );

    pRate = malloc(gSourceMaximum*(RATE_DATA_FIXED_SIZE+RATE_DATA_VAR_SIZE));
    if (pRate == NULL) {
        FPRINTF(stderr, "KERNRATE: CreateZoomModuleCallback failed to allocate RateData\n");
        exit(1);
    }
    
    //
    // Compute range in profile buffer to sum.
    //
    StartIndex = (ULONG64)((Module->Base - gCallbackCurrent->Base) / gZoomBucket);
    EndIndex = (Module->Base + Module->Length - gCallbackCurrent->Base) / gZoomBucket;
    //
    // Check if we already counted the hits for this bucket for the present module
    // in case we had an address gap for the present module within the bucket itself
    //
    if(StartIndex == LastIndex && LastParentModule != (PMODULE)NULL &&
                               gCallbackCurrent == LastParentModule &&
                               LastCxt != (PPROC_TO_MONITOR)NULL && LastCxt == ProcToMonitor ){
        for (ip=gCallbackCurrent->Base+StartIndex*gZoomBucket; ip<Address; ip+=1){
            if( 0 < pfnIP2MD( (DWORD_PTR)ip, &gwszSymbol ) && (gwszSymbol != NULL) ){
                if( !wcscmp( wszSymName, gwszSymbol ) ){
                    StartIndex += 1;             // We have a match, don't count this bucket for this module again
                    if(StartIndex > EndIndex){
                        HasHits = FALSE;
                        goto LABEL;           // No hits, jump to exit
                    }
                }
            }
        }
    }
    //
    // Look for hits in the current module
    //
    HasHits = FALSE;
    for (Index=0; Index < gTotalActiveSources; Index++) {

        ProfileSourceIndex = gulActiveSources[Index];
            
        Module->Rate[ProfileSourceIndex] = pRate[ProfileSourceIndex];
            
        Module->Rate[ProfileSourceIndex].StartTime  = gCallbackCurrent->Rate[ProfileSourceIndex].StartTime;
        Module->Rate[ProfileSourceIndex].TotalTime  = gCallbackCurrent->Rate[ProfileSourceIndex].TotalTime;

        Module->Rate[ProfileSourceIndex].TotalCount = calloc(gProfileProcessors, sizeof(ULONGLONG) );
        if( Module->Rate[ProfileSourceIndex].TotalCount == NULL ){
            FPRINTF(stderr, "KERNRATE: Memory allocation failed for TotalCount in CreateZoomModuleCallback\n");
            exit(1);
        }

        Module->Rate[ProfileSourceIndex].DoubtfulCounts = 0;

        for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {

            Module->Rate[ProfileSourceIndex].TotalCount[CpuNumber] = 0;

            for (i=StartIndex; i <= EndIndex; i++) {
                Module->Rate[ProfileSourceIndex].TotalCount[CpuNumber] +=
                    gCallbackCurrent->Rate[ProfileSourceIndex].ProfileBuffer[CpuNumber][i];
            }

            if (Module->Rate[ProfileSourceIndex].TotalCount[CpuNumber] > 0) {
                HasHits = TRUE;
            }
        }
    }

LABEL:
    //
    // If the routine has hits add it to the list, otherwise
    // ignore it.
    //
    if (HasHits) {
        //
        //useful verbose print for identifying shared buckets and actual bucket inhabitants, see also raw data printout
        //
        if ( gVerbose & VERBOSE_PROFILING ) {
            
            ULONGLONG BucketCount, TotCount, DoubtfulCounts;
            WCHAR LastSymName[cMODULE_NAME_STRLEN];
            BOOL bCounted = FALSE;

            PIMAGEHLP_LINE64 pLine = malloc(sizeof(IMAGEHLP_LINE64));
            if ( pLine == NULL ){
                FPRINTF(stderr, "KERNRATE: Memory allocation failed for pLine in CreateZoomModuleCallback\n");
                exit(1);
            }

            pLine->SizeOfStruct = sizeof(IMAGEHLP_LINE64);

            _wcsset(&LastSymName[cMODULE_NAME_STRLEN-1], L'\0');
            
            for (Index=0; Index < gTotalActiveSources; Index++) {
                ProfileSourceIndex = gulActiveSources[Index];
                TotCount = 0;
                DoubtfulCounts = 0;
                for (i=StartIndex; i <= EndIndex; i++) {
                    bCounted = FALSE;
                    BucketCount=0;
                    for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                        BucketCount +=  gCallbackCurrent->Rate[ProfileSourceIndex].ProfileBuffer[CpuNumber][i];
                    }
                    TotCount += BucketCount;
                    if(BucketCount > 0){
                      
                        ip = gCallbackCurrent->Base + (ULONG64)(i*gZoomBucket);
                        //
                        // Print the info for the current bucket
                        //
                        FPRINTF(stdout, "%s, 0x%I64x, 0x%I64x, %I64d, 0x%I64x, %Ld",
                                Module->module_Name,
                                gCallbackCurrent->Base,
                                Module->Base,
                                i,
                                ip,
                                BucketCount
                                );              
                            
                        for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                            if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;
                            FPRINTF(stdout, ", %Ld",
                                    gCallbackCurrent->Rate[ProfileSourceIndex].ProfileBuffer[CpuNumber][i]
                                    ); 
                        }
                        //
                        // Find out if anyone else is sharing this bucket
                        //
                        for(; (ip<gCallbackCurrent->Base + (ULONG64)((i+1)*gZoomBucket)) && (ip<HighLimit); ip+=1) {

                            if ( (0 < pfnIP2MD( (DWORD_PTR)ip, &gwszSymbol )) && (gwszSymbol != NULL) ) {
                                if (0 != wcscmp( wszSymName, gwszSymbol ) ){
                                    if(!bCounted){

                                        FPRINTF(stdout, " , Actual Hits Should be Attributed to or Shared with ===> %S",
                                                        gwszSymbol
                                                        );

                                        DoubtfulCounts += BucketCount;
                                        wcsncpy(LastSymName, gwszSymbol, cMODULE_NAME_STRLEN-1);
                                        _wcsset(&LastSymName[cMODULE_NAME_STRLEN-1], L'\0');
                                        bCounted = TRUE;
                                    } else if( 0 != wcscmp(LastSymName, gwszSymbol ) ){
                                        FPRINTF(stdout, "\nActual Hits Should also be Attributed to or Shared with ===> %S",
                                                        gwszSymbol
                                                        );

                                        wcsncpy(LastSymName, gwszSymbol, cMODULE_NAME_STRLEN-1);
                                        _wcsset(&LastSymName[cMODULE_NAME_STRLEN-1], L'\0');
                                    }
                                }
                            } else {
                                //
                                //This should be rare (no need to increase the doubtful counts)
                                //
                                FPRINTF(stdout, " , Actual Hits Should be Attributed to or Shared with ===> UNKNOWN_SYMBOL"); 
                            }
                        }
                        FPRINTF(stdout, "\n");
                    }
                } 
                //
                // Print the totals for the current module
                //
                FPRINTF(stdout, "%s, %s - Module Total Count = %I64d, Total Doubtful or Shared Counts = %I64d\n\n",
                                ProcToMonitor->Source[ProfileSourceIndex].Name,
                                Module->module_Name,
                                TotCount,
                                DoubtfulCounts
                                );

                Module->Rate[ProfileSourceIndex].DoubtfulCounts = DoubtfulCounts; 
            
                if( pLine != NULL ){
                    free(pLine);
                    pLine = NULL;
                }
            }      
        }     // if(VERBOSE_PROFILING)

        Module->Next = ProcToMonitor->ZoomList;
        ProcToMonitor->ZoomList = Module;
        ++gZoomCount;

    } else {
        //
        // Cleanup
        //

        for (Index=0; Index < gTotalActiveSources; Index++) {
            ProfileSourceIndex = gulActiveSources[Index];
            if ( Module->Rate[ProfileSourceIndex].TotalCount != NULL){
                free(Module->Rate[ProfileSourceIndex].TotalCount);
                Module->Rate[ProfileSourceIndex].TotalCount = NULL;
            }
        } 
        if( pRate != NULL ){
            free(pRate);
            pRate = NULL;
        }
        if( Module != NULL ){
            free(Module);
            Module = NULL;
        }
    }

    LastIndex = EndIndex;
    LastParentModule = gCallbackCurrent;
    LastCxt = ProcToMonitor;
    
    return(TRUE);

} //CreateJITZoomModuleCallback;

/* BEGIN_IMS  TkEnumerateSymbols
******************************************************************************
****
****   TkEnumerateSymbols (  )
****
******************************************************************************
*
* Function Description:
*
*    Calls the specified function for every symbol in the Current module.
*    The algorithm results in a round-up behavior for the output --
*    for each bucket, the symbol corresponding to the first byte of the
*    bucket is used.
*
* Arguments:
*
*    IN HANDLE SymHandle : ImageHelp handle
*
*    IN PMODULE Current : Pointer to current module structure
*
*    IN PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback : Routine to call for each symbol
*
*    IN PVOID pProc : Pointer to Process
* 
*  Return Value:
*
*    BOOL
*
* Algorithm:
*
*    ToBeSpecified
*
* Globals Referenced:
*
*    ToBeSpecified
*
* Exception Conditions:
*
*    ToBeSpecified
*
* In/Out Conditions:
*
*    ToBeSpecified
*
* Notes:
*
*    ToBeSpecified
*
* ToDo List:
*
*    ToBeSpecified
*
* Modification History:
*
*    9/5/97  TF  Initial version
*
******************************************************************************
* END_IMS  TkEnumerateSymbols */

BOOL
TkEnumerateSymbols(
    IN HANDLE                      SymHandle,
    IN PMODULE                     Current,
    IN PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    IN PVOID                       pProc
    )
{
    CHAR   CurrentSym[cMODULE_NAME_STRLEN];
    DWORD64 CurrentAddr    = 0;
    ULONG   i;
    DWORD64 Displacement;

    CurrentSym[0] = '\0';

    for (i=0; i<BUCKETS_NEEDED(Current->Length); i++) {
        // Check if this bucket will be assigned to a different symbol...
        if (SymGetSymFromAddr64(SymHandle, Current->Base+i*gZoomBucket, &Displacement, gSymbol )) {

            // It will... Invoke the callback for the old one
            if (CurrentSym[0] == '\0' ||
                strncmp(gSymbol->Name, CurrentSym, strlen(CurrentSym))) {

                if (CurrentAddr != 0) {
                    ULONG64 Size = (Current->Base+i*gZoomBucket) - CurrentAddr;
                    if ( Size == 0 )    {
                        FPRINTF( stderr, "XXTF Size==0 - %s = %s\n", gSymbol->Name, CurrentSym );
                    }
                    else {
                        if (!EnumSymbolsCallback(CurrentSym, CurrentAddr, (ULONG)Size, pProc))  {
                            FPRINTF(stderr, "KERNRATE: Failed CallBack in TkEnumerateSymbols Address= %x\n",
                            Current->Base+i*gZoomBucket
                            );  
                            break;
                        }
                    }
                }

                // Save the new info
                CurrentAddr = Current->Base+i*gZoomBucket;
                strncpy(CurrentSym, gSymbol->Name, cMODULE_NAME_STRLEN-1);
                CurrentSym[ cMODULE_NAME_STRLEN-1 ] = '\0';
            }
        }
        else {
            DWORD ErrorCode = GetLastError();
            FPRINTF(stderr, "KERNRATE: Failed Call to SymGetSymFromAddress %x in TkEnumerateSymbols Error Code= %x\n",
                    Current->Base+i*gZoomBucket,
                    ErrorCode
                    );
        } 
    }

    // Cleanup for the last symbol
    if (CurrentAddr != 0) {
        ULONG64 Size = (Current->Base+i*gZoomBucket) - CurrentAddr;
        if( (CurrentAddr + Size) < (Current->Base + Current->Length) )
            (VOID) EnumSymbolsCallback(CurrentSym, CurrentAddr, (ULONG)Size, pProc);
    }

    return(TRUE);

} // TkEnumerateSymbols()

BOOL
JITEnumerateSymbols(
    IN PMODULE                     Current,
    IN PVOID                       pProc,
    IN DWORD64                     BaseOptional,
    IN ULONG                       SizeOptional
    )
/*++

Routine Description:

    Enumerates the symbols found in a managed code module
         
Arguments:

    Current       - Pointer to the managed code module to be enumerated for symbols
    pProc         - Pointer to the structure of the process being monitored
    BaseOptional  - If not zero then the enumeration will be performed on part of the module,
                    starting from this address
    SizeOptional  - Required size if BaseOptional is non-zero                      

Return Value:

    TRUE if symbols are found, FALSE in case no symbols are found

--*/
{
    WCHAR          CurrentSym[cMODULE_NAME_STRLEN];
    CHAR           SymName[cMODULE_NAME_STRLEN];
    ANSI_STRING    AnsiString;
    UNICODE_STRING UnicodeString;
    DWORD64        CurrentAddr         = 0;
    DWORD64        TopAddress;
    DWORD64        Base;
    ULONG          Length;
    BOOL           bFoundSym           = FALSE;
    ULONG          Size                = 0;
    ULONG          InitialStep         = (gZoomBucket < JIT_MAX_INITIAL_STEP)? gZoomBucket : JIT_MAX_INITIAL_STEP;
    ULONG          step                = InitialStep;
    ULONG          i, j, k;

    WCHAR         *Symbol = (WCHAR *)malloc ( cMODULE_NAME_STRLEN * sizeof(WCHAR) );
    if (Symbol == NULL){
       FPRINTF(stderr, "KERNRATE: Allocation for Symbol in JITEnumerateSymbols failed\n");
       exit(1);
    }

    
    CurrentSym[0] = '\0';
    Base = (BaseOptional == 0)? Current->Base : BaseOptional;
    CurrentAddr = Base;
    Length = (SizeOptional == 0)? Current->Length : SizeOptional;
    TopAddress  = (SizeOptional == 0)? Current->Base + Current->Length : BaseOptional + SizeOptional;

    if (CurrentAddr == 0) {
        FPRINTF(stderr, "KERNRATE: Zero base address passed to JITEnumerateSymbols for module %s\n",
                Current->module_Name
                );
        free(Symbol);
        Symbol = NULL;
        return (FALSE);
    }
    if (Current->Length == 0) {
        FPRINTF(stderr, "KERNRATE: Zero module length passed to JITEnumerateSymbols for module %s\n",
                Current->module_Name
                );
        free(Symbol);
        Symbol = NULL;
        return (FALSE);
    }
    //
    // find first symbol
    //
    for (i=0; i < Length; i++){

        j = i;
        if ( (0 < pfnIP2MD( (DWORD_PTR)CurrentAddr, &Symbol )) && (Symbol != NULL) ) {
            wcsncpy(CurrentSym, Symbol, cMODULE_NAME_STRLEN-1);
            _wcsset(&CurrentSym[cMODULE_NAME_STRLEN-1], L'\0');

            bFoundSym = TRUE;
            break;
        }
        ++CurrentAddr;

    }
    if( !bFoundSym ){
        free(Symbol);
        Symbol = NULL;
        return (FALSE);
    }

    step = (InitialStep < Length)? InitialStep : 1;          
    Size = 1;
    
    if( gVerbose & VERBOSE_INTERNALS )
        FPRINTF(stdout, "\nJITEnumSymbols Verbose Detail: Symbol, Address Range, Size\n");

    for (i=j+step; i < Length; ){
        
        k = i;
        if ( (0 == pfnIP2MD( (DWORD_PTR)(Base + i), &Symbol )) || (Symbol == NULL) ) {
            wcsncpy(Symbol, L"NO_SYMBOL", cMODULE_NAME_STRLEN-1);
            _wcsset(&Symbol[cMODULE_NAME_STRLEN-1], L'\0');
        }

        if( 0 == wcscmp( CurrentSym, Symbol) ) { //Same symbol, increase size and continue stepping
            Size += step;                                               
            i = k + step;
            if(i < Length)
                continue;
                
        } else {                                // not same symbol, decrease step and go back to find boudary

            step >>=1;
            if (step > 0){
                i = k - step;                   // k was incremented by previous step so it's larger than present step 
                continue;
            }
        }   

        if( 0 != wcscmp(Symbol, L"NO_SYMBOL") && 0 != wcscmp(Symbol, L"\0") ){
            RtlInitUnicodeString( &UnicodeString, CurrentSym ); 
            AnsiString.Buffer        = SymName;
            AnsiString.MaximumLength = cMODULE_NAME_STRLEN*sizeof(CHAR);
            AnsiString.Length        = 0;
            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, cDONOT_ALLOCATE_DESTINATION_STRING);
            SymName[AnsiString.Length] = '\0';
            if ( !CreateJITZoomModuleCallback(CurrentSym, SymName, CurrentAddr, Size, pProc) )  {
                 FPRINTF(stderr, "KERNRATE: Failed CallBack in JITEnumerateSymbols Address= %I64x for module %s\n",
                                 CurrentAddr,
                                 Current->module_Name
                                 );  
                 free(Symbol);
                 Symbol = NULL;
                 return (FALSE);
            }
        }
        if( gVerbose & VERBOSE_INTERNALS )
            FPRINTF(stdout, "%S, 0x%p - 0x%p, 0x%lx\n", CurrentSym, (PVOID)CurrentAddr, (PVOID)(CurrentAddr+Size), Size);

        wcsncpy(CurrentSym, Symbol, cMODULE_NAME_STRLEN-1);       //Put the next symbol into current symbol
        _wcsset(&CurrentSym[cMODULE_NAME_STRLEN-1], L'\0');

        CurrentAddr += Size;                               //Advance to next method base
        Size = 1;                                          //Reset initial size and step for the next symbol

        if ( InitialStep < (TopAddress - CurrentAddr) ){
            step = InitialStep;
        } else {
            step = 1;
        }

        i = k + step;
    }//for i

    if (Symbol != NULL) {
        free(Symbol);
        Symbol = NULL;
    }
    return TRUE;

} //JITEnumerateSymbols()               

BOOL
EnumerateSymbolsByBuckets(
    IN HANDLE                      SymHandle,
    IN PMODULE                     Current,
    IN PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    IN PVOID                       pProc
    )
/*++

Routine Description:

    Finds buckets with hits in the current module and enumerates the symbols found in these buckets
         
Arguments:
    SymHandle           - ImageHelp handle to current process 
    Current             - Pointer to the parent module to be enumerated for symbols
    EnumSymbolsCallback - Pointer to a user supplied callback function 
    pProc               - Pointer to the structure of the process being monitored

Return Value:

    TRUE if any symbols are found, FALSE in case no symbols are found at all

--*/
{
    DWORD64 Base;
    ULONG Size;
    ULONG i;
    BOOL bRet = FALSE;                      //One time toggle switch (once set to TRUE it remains TRUE) 
    
    Base = Current->Base;
    Size = 0;
    
    for (i=0; i< BUCKETS_NEEDED(Current->Length); i++){
        
        if ( HitsFound(pProc, i) ){ 
            Size += gZoomBucket;            //just increase the size of this segment by a bucket
            continue;
        } else if ( Size > 0 ){             //Reached end of segment where hits were found, enumerate the symbols within
            if(SymHandle != NULL){
                if ( TRUE == PrivEnumerateSymbols( SymHandle, Current, EnumSymbolsCallback, pProc, Base, Size ) )
                    bRet = TRUE;
            } else {
                if ( TRUE == JITEnumerateSymbols( Current, pProc, Base, Size ) )
                    bRet = TRUE;
            }

            Base += Size;                   //Done enumerating,  shift the base to the end of the segment and reset the size
            Size = 0;
        }
        Base += gZoomBucket;                //No hits found, so further shift base of segment by one bucket and continue
    }
    return (bRet);
}

BOOL
PrivEnumerateSymbols(
    IN HANDLE                      SymHandle,
    IN PMODULE                     Current,
    IN PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    IN PVOID                       pProc,
    IN DWORD64                     BaseOptional,
    IN ULONG                       SizeOptional
    )
/*++

Routine Description:

    Enumerates the symbols found in a module
         
Arguments:
    SymHandle           - ImageHelp handle to current process 
    Current             - Pointer to the module to be enumerated for symbols
    EnumSymbolsCallback - Pointer to a user supplied callback function 
    pProc               - Pointer to the structure of the process being monitored
    BaseOptional        - If not zero then the enumeration will be performed on part of the module,
                          starting from this address
    SizeOptional        - Required size if BaseOptional is non-zero                      

Return Value:

    TRUE if symbols are found, FALSE in case no symbols are found

--*/
{
    CHAR           CurrentSym[cMODULE_NAME_STRLEN];
    CHAR           SymName[cMODULE_NAME_STRLEN];
    DWORD64        CurrentAddr         = 0;
    DWORD64        TopAddress;
    DWORD64        Displacement;
    DWORD64        Base;
    ULONG          Length;
    BOOL           bFoundSym           = FALSE;
    ULONG          Size                = 0;
    ULONG          step                = INITIAL_STEP;
    ULONG          i, j, k;

    PIMAGEHLP_SYMBOL64 Symbol = (PIMAGEHLP_SYMBOL64) malloc( sizeof(IMAGEHLP_SYMBOL64) + MAX_SYMNAME_SIZE );

    if (Symbol == NULL){
       FPRINTF(stderr, "KERNRATE: Allocation for Symbol in PrivEnumerateSymbols failed\n");
       exit(1);
    }

    Symbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL64);
    Symbol->MaxNameLength = MAX_SYMNAME_SIZE;

    CurrentSym[0] = '\0';

    Base = (BaseOptional == 0)? Current->Base : BaseOptional;
    CurrentAddr = Base;
    Length = (SizeOptional == 0)? Current->Length : SizeOptional;
    TopAddress  = (SizeOptional == 0)? Current->Base + Current->Length : BaseOptional + SizeOptional;
    if (CurrentAddr == 0) {
        FPRINTF(stderr, "KERNRATE: Zero base address passed to PrivEnumerateSymbols for module %s\n",
                Current->module_Name
                );
        free(Symbol);
        Symbol = NULL;
        return (FALSE);
    }
    if (Length == 0) {
        FPRINTF(stderr, "KERNRATE: Zero module length passed to PrivEnumerateSymbols for module %s\n",
                Current->module_Name
                );
        free(Symbol);
        Symbol = NULL;
        return (FALSE);
    }
    //
    // find first symbol
    //
    for (i=0; i < Length; i++){

        j = i;
        if ( (SymGetSymFromAddr64( SymHandle, CurrentAddr, &Displacement, Symbol ))) {    
            if( 0 == strcmp(Symbol->Name, "\0") )
                continue; 
            strncpy(CurrentSym, Symbol->Name, cMODULE_NAME_STRLEN-1);
            CurrentSym[cMODULE_NAME_STRLEN-1] = '\0';
            bFoundSym = TRUE;
            break;
        }
        ++CurrentAddr;

    }
    if( !bFoundSym ){
        free(Symbol);
        Symbol = NULL;
        return (FALSE);
    }

    step = (INITIAL_STEP < Length)?INITIAL_STEP : 1;
    Size = 1;
    
    if( gVerbose & VERBOSE_INTERNALS )
        FPRINTF(stdout, "\nPrivEnumSymbols Verbose Detail: Symbol, Address Range, Size\n");

    for (i=j+step; i < Length; ){
        
        k = i;
        if ( (!SymGetSymFromAddr64( SymHandle, Base + i, &Displacement, Symbol ))) {
            strncpy(Symbol->Name, "NO_SYMBOL", cMODULE_NAME_STRLEN-1);
            Symbol->Name[cMODULE_NAME_STRLEN-1] = '\0';
        }

        if( !strcmp(CurrentSym, Symbol->Name) ) { //Same symbol, increase size and continue stepping
            Size += step;                                               
            i = k + step;
            if(i < Length)
                continue;
                
        } else {                                // not same symbol, decrease step and go back to find boudary

            step >>=1;
            if (step > 0){
                i = k - step;                   // k was incremented by previous step so it's larger than present step 
                continue;
            }
        }   

        if( 0 != strcmp(Symbol->Name, "NO_SYMBOL") && 0 != strcmp(Symbol->Name, "\0") ){
            if ( !CreateZoomModuleCallback(CurrentSym, CurrentAddr, Size, pProc) )  {
                 FPRINTF(stderr, "KERNRATE: Failed CallBack in PrivEnumerateSymbols Address= %I64x for module %s\n",
                                 CurrentAddr,
                                 Current->module_Name
                                 );  
                 free(Symbol);
                 Symbol = NULL;
                 return (FALSE);
            }
        }
        if( gVerbose & VERBOSE_INTERNALS )
            FPRINTF(stdout, "%s, 0x%p - 0x%p, 0x%lx\n", CurrentSym, (PVOID)CurrentAddr, (PVOID)(CurrentAddr+Size), Size);

        strncpy(CurrentSym, Symbol->Name, cMODULE_NAME_STRLEN-1);       //Put the next symbol into current symbol
        CurrentSym[cMODULE_NAME_STRLEN-1] = '\0';

        CurrentAddr += Size;                               //Advance to next method base
        Size = 1;                                          //Reset initial size and step for the next symbol

        if ( INITIAL_STEP < (TopAddress - CurrentAddr) ){
            step = INITIAL_STEP;
        } else {
            step = 1;
        }

        i = k + step;

    }//for i

    if (Symbol != NULL) {
        free(Symbol);
        Symbol = NULL;
    }
    return TRUE;

} //PrivEnumerateSymbols()               

BOOL
HitsFound(
    IN PPROC_TO_MONITOR pProc,
    IN ULONG BucketIndex
    )
/*++

Routine Description:

    Determines if the current bucket scored any hits at all
         
Arguments:
    pProc               - Pointer to the structure of the process being monitored
    BucketIndex         - Index of the bucket matching the current address. 
    
Return Value:

    TRUE if hits are found, FALSE in case no hits are found

--*/
{
    ULONG Index, CpuNumber;

    for (Index=0; Index < gTotalActiveSources; Index++) {
        for (CpuNumber=0; CpuNumber < (ULONG)gProfileProcessors; CpuNumber++) {
            if ( 0 < gCallbackCurrent->Rate[gulActiveSources[Index]].ProfileBuffer[CpuNumber][BucketIndex] ){
                return (TRUE);
            }
        }
    }
    return (FALSE);
}

VOID
CreateZoomedModuleList(
    IN PMODULE ZoomModule,
    IN ULONG RoundDown,
    IN PPROC_TO_MONITOR pProc
    )

/*++

Routine Description:

    Creates a module list from the functions in a given module

Arguments:

    ZoomModule - Supplies the module whose zoomed module list is to be created

    RoundDown  - Used for selecting the method of symbol enumeration

    ProcToMonitor - Pointer to the process to be monitored


Return Value:

    Pointer to the zoomed module list
    NULL on error.

--*/

{
    BOOL   Success   = FALSE;
    HANDLE SymHandle = pProc->ProcessHandle;

   
    gCallbackCurrent = ZoomModule;

//MC  
    if (( bMCHelperLoaded == TRUE ) &&  (!_stricmp(ZoomModule->module_FullName, "JIT_TYPE"))){
        pfnAttachToProcess((DWORD)pProc->Pid);
 
        Success = EnumerateSymbolsByBuckets(  NULL,
                                              ZoomModule,
                                              NULL,
                                              pProc
                                              );
        pfnDetachFromProcess();
//MC
    } else { 

        if (RoundDown == 0)  {

            Success = EnumerateSymbolsByBuckets(  SymHandle,
                                                  ZoomModule,
                                                  CreateZoomModuleCallback,
                                                  pProc
                                                  );
//MC
            //
            // If we failed the imagehlp call we have to check if this is a pre-compiled JIT module (ngen)
            // We cannot count on the imagehlp return value because it will return success even if no symbols are found
            //
            if ( (bImageHlpSymbolFound == FALSE) && ( bMCHelperLoaded == TRUE ) ){
                pfnAttachToProcess((DWORD)pProc->Pid);

                Success = EnumerateSymbolsByBuckets(  NULL,
                                                      ZoomModule,
                                                      NULL,
                                                      pProc
                                                      );

                pfnDetachFromProcess();
            }
//MC
        } else {

            Success = TkEnumerateSymbols( SymHandle,
                                          ZoomModule,
                                          CreateZoomModuleCallback,
                                          pProc
                                          );

        }
    }

    if (!Success) {
        DWORD ErrorCode = GetLastError();
        FPRINTF(stderr,
                "Symbol Enumeration failed (or no symbols found) on module %s in CreateZoomedModuleList, Error Code= %x\n",
                ZoomModule->module_Name,
                ErrorCode
                );
    }
//MC    
    bImageHlpSymbolFound = FALSE; //Reset for next module
//MC    
    return;

} // CreateZoomedModuleList()

VOID
OutputModuleList(
    IN FILE *Out,
    IN PMODULE ModuleList,
    IN ULONG NumberModules,
    IN PPROC_TO_MONITOR ProcToMonitor,
    IN PMODULE Parent
    )

/*++

Routine Description:

    Outputs the given module list

Arguments:

    Out - Supplies the FILE * where the output should go.

    ModuleList - Supplies the list of modules to output

    NumberModules - Supplies the number of modules in the list

    ProcToMonitor - Pointer to the process to be monitored

Return Value:

    None.

--*/

{
    PRATE_DATA    RateData;
    PRATE_DATA    SummaryData;
    PRATE_SUMMARY RateSummary;
    BOOL          Header;
    ULONG         i, j, ProfileSourceIndex, Index;
    PMODULE      *ModuleArray;
    PMODULE       Current, tmpModule;
    LONG          CpuNumber;
    ULONGLONG     TempTotalCount, TempDoubtfulCount;

//// Beginning of Function Assertions Section:
//
//

//
// It is not really a bug but we are printing only the first 132 characters of the module name.
// This assertion will remind us this.
//

assert( sizeof(Current->module_Name) >= cMODULE_NAME_STRLEN );

//
//
//// End of Function Assertions Section

    RateSummary = calloc(gSourceMaximum, sizeof (RATE_SUMMARY));
    if (RateSummary == NULL) {
        FPRINTF(stderr, "KERNRATE: Buffer allocation failed(1) while doing output of Module list\n");
        exit(1);
    }

    SummaryData = calloc(gSourceMaximum, (RATE_DATA_FIXED_SIZE + RATE_DATA_VAR_SIZE));
    if (SummaryData == NULL) {
        FPRINTF(stderr, "KERNRATE: Buffer allocation failed(2) while doing output of Module list\n");
        free(RateSummary);
        RateSummary = NULL;
        exit(1);
    }

    for (Index=0; Index < gTotalActiveSources; Index++) {
        ProfileSourceIndex = gulActiveSources[Index];
        SummaryData[ProfileSourceIndex].Rate = 0;

        //
        // Walk through the module list and compute the summary
        // and collect the interesting per-module data.
        //
        RateSummary[ProfileSourceIndex].TotalCount = 0;
        RateSummary[ProfileSourceIndex].Modules = malloc(NumberModules*sizeof(PMODULE));
        if (RateSummary[ProfileSourceIndex].Modules == NULL) {
            FPRINTF(stderr, "KERNRATE: Buffer allocation failed(3) while doing output of Module list\n");
            exit(1);
        }
        RateSummary[ProfileSourceIndex].ModuleCount = 0;

        ModuleArray = RateSummary[ProfileSourceIndex].Modules;
        Current = ModuleList;

        while (Current != NULL) {
            RateData = &Current->Rate[ProfileSourceIndex];

            TempTotalCount = 0;
            TempDoubtfulCount = 0;
            for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                TempTotalCount += RateData->TotalCount[CpuNumber];
            }
            TempDoubtfulCount = RateData->DoubtfulCounts;
            RateData->GrandTotalCount = TempTotalCount;
            if (TempTotalCount > 0) {
                RateSummary[ProfileSourceIndex].TotalCount += TempTotalCount;
                //
                // Find if we already have a module by that name (optimizations may have split the module to several pieces)
                // This will slow down processing, so we'll turn it off if the user decided to use the '-e' option to haste
                // the output (in cases that monitored processes might go away frequently for example, we want to finish symbol 
                // processing before the process goes away, so any extra processing delay should be removed). 
                //
                if(bIncludeGeneralInfo == TRUE) {
                    for ( i=0; i < RateSummary[ProfileSourceIndex].ModuleCount; i++){

                        if ( !strcmp(Current->module_Name, ModuleArray[i]->module_Name) ){                 //Found a match 
                            if (gVerbose & VERBOSE_INTERNALS)
                                FPRINTF(stdout, "===> Found module %s more than once, merged hit counts and re-sorted\n",
                                                Current->module_Name
                                                );
                                                 
                            ModuleArray[i]->Rate[ProfileSourceIndex].GrandTotalCount += TempTotalCount;     // Update the original module 
                            for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                                 ModuleArray[i]->Rate[ProfileSourceIndex].TotalCount[CpuNumber] += RateData->TotalCount[CpuNumber]; 
                            }  
                            ModuleArray[i]->Rate[ProfileSourceIndex].DoubtfulCounts += TempDoubtfulCount;   // Update the shared counts total
                            //
                            // Re-Sort since number of hits changed
                            //
                            for (j=0; j<RateSummary[ProfileSourceIndex].ModuleCount; j++) {                 
                                if ( i > j && ModuleArray[i]->Rate[ProfileSourceIndex].GrandTotalCount > ModuleArray[j]->Rate[ProfileSourceIndex].GrandTotalCount) {
                                    //
                                    // insert here
                                    //
                                    tmpModule = ModuleArray[i];          //preserve the ptr to current module
                                    MoveMemory(&ModuleArray[j+1],        //shift the ptr array by one index to free the array element at j
                                               &ModuleArray[j],
                                               sizeof(PMODULE)*(i-j)
                                               );
                                    ModuleArray[j] = tmpModule;          //set the free array element to the preserved ptr  
                                    break;
                                }

                            }
                            goto NEXT_1;                              //Go to the next module on the list (skipping current as a new module)
                        }

                    }
                    
                }

                //
                // No match found, so insert the new module in a sorted position in the array.
                //
                ModuleArray[RateSummary[ProfileSourceIndex].ModuleCount] = Current;
                RateSummary[ProfileSourceIndex].ModuleCount++;
                if (RateSummary[ProfileSourceIndex].ModuleCount > NumberModules) {
                    DbgPrint("Error, ModuleCount %d > NumberModules %d for Source %s\n",
                             RateSummary[ProfileSourceIndex].ModuleCount,
                             NumberModules,
                             ProcToMonitor->Source[ProfileSourceIndex].Name
                             );
                    DbgBreakPoint();
                }

                for (i=0; i<RateSummary[ProfileSourceIndex].ModuleCount; i++) {
                    if (TempTotalCount > ModuleArray[i]->Rate[ProfileSourceIndex].GrandTotalCount) {
                        //
                        // insert here
                        //
                        MoveMemory(&ModuleArray[i+1],
                                   &ModuleArray[i],
                                   sizeof(PMODULE)*(RateSummary[ProfileSourceIndex].ModuleCount-i-1)
                                   );
                        ModuleArray[i] = Current;

                        break;
                    }
                }

            }
NEXT_1:     Current = Current->Next;
        }

        if (RateSummary[ProfileSourceIndex].TotalCount > (ULONGLONG)0 ) {
            //
            // Output the result
            //
            PSOURCE s;
            s = &ProcToMonitor->Source[ProfileSourceIndex];
            if(Parent == NULL){
                FPRINTF(Out, "\n%s   %I64u hits, %ld events per hit --------\n",
                             s->Name,
                             RateSummary[ProfileSourceIndex].TotalCount,
                             s->Interval
                             );
            } else {
                FPRINTF(Out, "\n%s   %I64u hits, %ld events per hit --------",
                             s->Name,
                             Parent->Rate[ProfileSourceIndex].GrandTotalCount,
                             s->Interval
                             );
                if( gVerbose & VERBOSE_PROFILING ) {
                    FPRINTF(Out, " (%I64u total hits from summing-up the module components)\n",
                                 RateSummary[ProfileSourceIndex].TotalCount
                                 );
                } else {
                    FPRINTF(Out, "\n");
                }
            }
            if ( gVerbose & VERBOSE_PROFILING ) {
                FPRINTF(Out," Module                                Hits        Shared    msec  %%Total %%Certain Events/Sec\n");
            } else {
                FPRINTF(Out," Module                                Hits   msec  %%Total  Events/Sec\n");
            }
            for (i=0; i < RateSummary[ProfileSourceIndex].ModuleCount; i++) {
                Current = ModuleArray[i];
                if ( ModuleArray[i]->Rate[ProfileSourceIndex].GrandTotalCount >= (ULONGLONG)gMinHitsToDisplay ) {
                    FPRINTF(Out, "%-32s", Current->module_Name); // Note only the first 132 characters are printed.

                    OutputLine(Out,
                               ProfileSourceIndex,
                               Current,
                               &RateSummary[ProfileSourceIndex],
                               ProcToMonitor
                               );
                }
                    
                SummaryData[ProfileSourceIndex].Rate += Current->Rate[ProfileSourceIndex].Rate;
                SummaryData[ProfileSourceIndex].GrandTotalCount += Current->Rate[ProfileSourceIndex].GrandTotalCount;
            }
        } else {
            FPRINTF(Out, "\n%s - No Hits Recorded\n", ProcToMonitor->Source[ProfileSourceIndex].Name );
        }
        FPRINTF(Out, "\n");
    }

    //
    // Output interesting data for the summary.
    //

    if( bGetInterestingData == TRUE ) {        
        FPRINTF(stdout,
                "\n-------------- INTERESTING SUMMARY DATA ----------------------\n"
                ); 
        OutputInterestingData(Out, SummaryData);
    }

    //
    // Output the results ordered by module
    //

    Current = ModuleList;
    while (Current != NULL) {
        Header = FALSE;
        if ( gVerbose & VERBOSE_MODULES )   {    //The printout below duplicates data already printed, let's limit the flood

            for (Index=0; Index < gTotalActiveSources; Index++) {
                ProfileSourceIndex = gulActiveSources[Index];

                if ( Current->Rate[ProfileSourceIndex].GrandTotalCount > 0 ) {
                    if (!Header) {

                        FPRINTF(Out,"\nMODULE %s   --------\n",Current->module_Name);
                        if ( gVerbose & VERBOSE_PROFILING ) {
                            FPRINTF(Out," %-*s      Hits        Shared    msec  %%Total %%Certain Events/Sec\n", gDescriptionMaxLen, "Source");
                        } else {
                            FPRINTF(Out," %-*s      Hits       msec  %%Total  Events/Sec\n", gDescriptionMaxLen, "Source");
                        }
                        Header = TRUE;
                    }

                    FPRINTF(Out, "%-*s", gDescriptionMaxLen, ProcToMonitor->Source[ProfileSourceIndex].Name);

                    OutputLine(Out,
                               ProfileSourceIndex,
                               Current,
                               &RateSummary[ProfileSourceIndex],
                               ProcToMonitor);
                }

            }

        }
        //
        // Output interesting data for the module.
        //

        if( bGetInterestingData == TRUE ) {        
            FPRINTF(stdout,
                    "\n-------------- INTERESTING MODULE DATA FOR %s---------------------- \n",
                    Current->module_Name
                    ); 
            OutputInterestingData(Out, &Current->Rate[0]);
        }

        Current = Current->Next;
    }

    return;

} // OutputModuleList()


VOID
OutputLine(
    IN FILE *Out,
    IN ULONG ProfileSourceIndex,
    IN PMODULE Module,
    IN PRATE_SUMMARY RateSummary,
    IN PPROC_TO_MONITOR ProcToMonitor
    )

/*++

Routine Description:

    Outputs a line corresponding to the particular module/source

Arguments:

    Out - Supplies the file pointer to output to.

    ProfileSource - Supplies the source to use

    Module - Supplies the module to be output

    RateSummary - Supplies the rate summary for this source

    ProcToMonitor - Pointer to the process to be monitored

Return Value:

    None.

--*/

{
    ULONG      Msec;
    ULONGLONG  Events;
    ULONGLONG  TempTotalCount;
    PRATE_DATA RateData;
    LONG       CpuNumber      = 0;

    RateData = &Module->Rate[ProfileSourceIndex];

    TempTotalCount = RateData->GrandTotalCount;
    //
    //The time is in 100ns units = 0.1us = 1/10,000ms
    //The events are fired every 100ns=0.1us=1/10,000ms (or 10,000,000 events per second)
    //
    Msec = (ULONG)(RateData->TotalTime/10000);
    Events = TempTotalCount * ProcToMonitor->Source[ProfileSourceIndex].Interval * 1000; //To get Events/sec below

    if ( gVerbose & VERBOSE_PROFILING ) {
        FPRINTF(Out,
                " %10I64u %10I64u %10ld    %2d %% %2d %%  ",
                TempTotalCount,
                RateData->DoubtfulCounts,
                Msec,
                (ULONG)(100*TempTotalCount/
                        RateSummary->TotalCount),
                (ULONG)(100*(TempTotalCount - RateData->DoubtfulCounts)/
                        RateSummary->TotalCount)
                );
    } else {
        FPRINTF(Out,
                " %10I64u %10ld    %2d %%  ",
                TempTotalCount,
                Msec,
                (ULONG)(100*TempTotalCount/
                        RateSummary->TotalCount)
                );
    }
    
    if (Msec > 0) {
        RateData->Rate = Events/Msec;                 //The final result is in Events/sec
        FPRINTF(Out, "%10I64u\n", RateData->Rate);
    } else {
        RateData->Rate = 0;
        FPRINTF(Out,"---\n");
    }

    if (bProfileByProcessor) {
        for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
            if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;

            TempTotalCount = RateData->TotalCount[CpuNumber];
            Events = TempTotalCount * ProcToMonitor->Source[ProfileSourceIndex].Interval * 1000;
            FPRINTF(Out,
                    "%6d %7I64u %6ld    %2d %%  ",
                    CpuNumber,
                    TempTotalCount,
                    Msec,
                    (ULONG)(100*TempTotalCount/RateSummary->TotalCount));

            if (Msec > 0) {
                FPRINTF(Out,"%10I64d\n", Events/Msec);   //The final result is in Events/sec
            } else {
                FPRINTF(Out,"---\n");
            }
        }
    }

} //OutputLine()


VOID
OutputInterestingData(
    IN FILE *Out,
    IN RATE_DATA Data[]
    )

/*++

Routine Description:

    Computes interesting Processor Statistics and outputs them.

Arguments:

    Out    - Supplies the file pointer to output to.

    Data   - Supplies an array of RATE_DATA. The Rate field is the only interesting part.

    Header - Supplies header to be printed.

Return Value:

    None.

--*/

{
    ULONGLONG Temp1,Temp2;
    LONGLONG  Temp3;
    float     Ratio;
    BOOL      DataFound   = FALSE;

    //
    // Note that we have to do a lot of funky (float)(LONGLONG) casts in order
    // to prevent the weenie x86 compiler from choking.
    //

    //
    // Compute cycles/instruction and instruction mix data.
    //
    if ((Data[ProfileTotalIssues].Rate > 0) &&
        (Data[ProfileTotalIssues].GrandTotalCount > 10)) {           
        if (Data[ProfileTotalCycles].Rate > 0) {
            Ratio = (float)(LONGLONG)(Data[ProfileTotalCycles].Rate)/
                    (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
            DataFound = TRUE;
            FPRINTF(Out, "Cycles per instruction\t\t%6.2f\n", Ratio);
        }

        if (Data[ProfileLoadInstructions].Rate > 0) {
            Ratio = (float)(LONGLONG)(Data[ProfileLoadInstructions].Rate)/
                    (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
            if (Ratio >= 0.01 && Ratio <= 1.0) {                
                DataFound = TRUE;
                FPRINTF(Out, "Load instruction percentage\t%6.2f %%\n",Ratio*100);
            }
        }

        if (Data[ProfileStoreInstructions].Rate > 0) {
            Ratio = (float)(LONGLONG)(Data[ProfileStoreInstructions].Rate)/
                    (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
            if (Ratio >= 0.01 && Ratio <= 1.0) {
                DataFound = TRUE;
                FPRINTF(Out, "Store instruction percentage\t%6.2f %%\n",Ratio*100);
            }
        }
        
        if (Data[ProfileBranchInstructions].Rate > 0) {
            Ratio = (float)(LONGLONG)(Data[ProfileBranchInstructions].Rate)/
                    (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
            if (Ratio >= 0.01 && Ratio <= 1.0) {
                DataFound = TRUE;
                FPRINTF(Out, "Branch instruction percentage\t%6.2f %%\n",Ratio*100);
            }
        }

        if (Data[ProfileFpInstructions].Rate > 0) {
            Ratio = (float)(LONGLONG)(Data[ProfileFpInstructions].Rate)/
                    (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
            if (Ratio >= 0.01 && Ratio <= 1.0) {
                DataFound = TRUE;
                FPRINTF(Out, "FP instruction percentage\t%6.2f %%\n",Ratio*100);
            }
        }

        if (Data[ProfileIntegerInstructions].Rate > 0) {
            Ratio = (float)(LONGLONG)(Data[ProfileIntegerInstructions].Rate)/
                    (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
            if (Ratio >= 0.01 && Ratio <= 1.0) {
                DataFound = TRUE;
                FPRINTF(Out, "Integer instruction percentage\t%6.2f %%\n",Ratio*100);
            }
        }

        //
        // Compute icache hit rate
        //
        if (Data[ProfileIcacheMisses].Rate > 0) {
            Temp3 = (LONGLONG)(Data[ProfileTotalIssues].Rate - Data[ProfileIcacheMisses].Rate);
            if(Temp3 > 0){
                Ratio = (float)Temp3/
                        (float)(LONGLONG)(Data[ProfileTotalIssues].Rate);
                if( Ratio <= 1.0 ) {
                    DataFound = TRUE;
                    FPRINTF(Out, "Icache hit rate\t\t\t%6.2f %%\n", Ratio*100);
                }
            }
        }

    }

    //
    // Compute dcache hit rate
    // 
    if( Data[ProfileLoadInstructions].Rate > 0 && Data[ProfileStoreInstructions].Rate > 0 ){ 
        Temp1 = Data[ProfileLoadInstructions].Rate + Data[ProfileStoreInstructions].Rate;
        if ((Data[ProfileDcacheMisses].Rate > 0) &&
            (Temp1 != 0) &&
            (Data[ProfileDcacheMisses].GrandTotalCount > 10)) { 

            Temp2 = Temp1 - Data[ProfileDcacheMisses].Rate;
            Temp3 = (LONGLONG) Temp2;
            Ratio = (float)Temp3/(float)(LONGLONG)Temp1;
            if( Temp3 > 0 && Ratio <= 1.0 ) {
                DataFound = TRUE;
                FPRINTF(Out, "Dcache hit rate\t\t\t%6.2f %%\n", Ratio*100);
            }
        }
    }

    //
    // Compute branch prediction hit percentage
    //
    if ((Data[ProfileBranchInstructions].Rate > 0) &&
        (Data[ProfileBranchMispredictions].Rate > 0) &&
        (Data[ProfileBranchInstructions].GrandTotalCount > 10)) {        
        Temp3 = (LONGLONG)(Data[ProfileBranchInstructions].Rate-Data[ProfileBranchMispredictions].Rate);
        if(Temp3 > 0){
            Ratio = (float)Temp3 /
                    (float)(LONGLONG)(Data[ProfileBranchInstructions].Rate);
            if( Ratio <= 1.0 ) {
                DataFound = TRUE;
                FPRINTF(Out, "Branch predict hit percentage\t%6.2f %%\n", Ratio*100);
            }
        }
    }

    if ( !DataFound )
        FPRINTF(Out, "===> No interesting data found or hit counts too low\n");

} // OutputInterestingData()

/* BEGIN_IMS  CreateNewModule
******************************************************************************
****
****   CreateNewModule (  )
****
******************************************************************************
*
* Function Description:
*
*    This function allocates and initializes a module entry.
*
* Arguments:
*
*    IN HANDLE ProcessHandle :
*
*    IN PCHAR ModuleName :
*
*    IN PCHAR ModuleFullName :
*
*    IN ULONG ImageBase :
*
*    IN ULONG ImageSize :
*
* Return Value:
*
*    PMODULE
*
* Algorithm:
*
*    ToBeSpecified
*
* Globals Referenced:
*
*    ToBeSpecified
*
* Exception Conditions:
*
*    ToBeSpecified
*
* In/Out Conditions:
*
*    ToBeSpecified
*
* Notes:
*
*    ToBeSpecified
*
* ToDo List:
*
*    ToBeSpecified
*
* Modification History:
*
*    9/8/97  TF  Initial version
*
******************************************************************************
* END_IMS  CreateNewModule */

PMODULE
CreateNewModule(
    IN PPROC_TO_MONITOR  ProcToMonitor,
    IN PCHAR    ModuleName,
    IN PCHAR    ModuleFullName,
    IN ULONG64  ImageBase,
    IN ULONG    ImageSize
    )
{
    PMODULE           NewModule;
    PMODULE           ZoomModule;
    HANDLE            ProcessHandle = ProcToMonitor->ProcessHandle;
    PCHAR             lastptr = NULL, dotptr = NULL;  

    NewModule = calloc(1, MODULE_SIZE);
    if (NewModule == NULL) {
        FPRINTF(stderr, "Memory allocation of NewModule for %s failed\n", ModuleName);
        exit(1);
    }
    NewModule->bZoom = FALSE;
    SetModuleName( NewModule, ModuleName );
    //
    // Following WinDbg's rule: module names are filenames without their extension.
    // However, currently long file names may include more than one period
    // We'll try to strip only the last extension and keep the rest
    //

    dotptr = strchr(NewModule->module_Name, '.');
    while (dotptr != NULL){
        lastptr = dotptr;
        dotptr = strchr(dotptr+1, '.');
    }        
    if(lastptr != NULL)
        *lastptr = '\0';

    //
    // See if this module is on the zoom list.
    //
    ZoomModule = ProcToMonitor->ZoomList;

    while ( ZoomModule != NULL ) {
        //
        // By default the user needs to specify only the module name (no extension) for a zoom module
        // The 2nd part of the following check allows the user to specify a full file name for a zoom module
        // This allows kernrate to make a distinction in cases that a .exe and a .dll for example carry
        // the same module name 
        //
        if ( _stricmp(ZoomModule->module_Name, NewModule->module_Name) == 0 ||
            (NULL != ModuleName && 0 == _stricmp( ModuleName, ZoomModule->module_Name )) ) {
            //
            // found a match
            //
            NewModule->hProcess = ProcessHandle;
            NewModule->Base = ImageBase;
            NewModule->Length = ImageSize;
            NewModule->bZoom = TRUE;

            NewModule->module_FileName = _strdup( ModuleName );        // File name including extension
            if ( ModuleFullName )   {
               NewModule->module_FullName = _strdup( ModuleFullName ); // Including the fully qualified path
            }

            gCurrentModule = NewModule;

            //
            // Load symbols
            //
            // Note 15/09/97 TF: do not be confused here...
            // In this routine, the ModuleName variable is a filename with its
            // extension: File.exe or File.dll
            //
            // Note 30/09/97 TF: The current kernrate version does not change
            // the default IMAGEHLP behaviour in terms of symbol file loading:
            // It is synchronous ( and not deferred ) with the SymLoadModule
            // call. Our registered callback will be called with the standard
            // symbol file operations.
            // If the kernrate behaviour changes, we will have to revisit this
            // assumption.
            //
//MC
            if(0 != _stricmp(ModuleFullName, "JIT_TYPE")){
//MC
                (void)SymLoadModule64( ProcessHandle,                              // hProcess
                                       NULL,                                       // hFile [for Debugger]
                                       ModuleName,                                 // ImageName
                                       NULL,                                       // ModuleName
                                       ImageBase,                                  // BaseOfDll
                                       ImageSize                                   // SizeOfDll
                                     );
//MC
            }
//MC
            gCurrentModule = (PMODULE)0;

            break;
        }

        ZoomModule = ZoomModule->Next;

    } //while

    if(NewModule->bZoom == FALSE){
        NewModule->hProcess = ProcessHandle;
        NewModule->Base = ImageBase;   // Note TF: I know for zoomed it is a redone...
        NewModule->Length = ImageSize; // Note TF: I know for zoomed it is a redone...
        assert( ModuleName );
        if ( NewModule->module_FileName == (PCHAR)0 )   {
            NewModule->module_FileName = _strdup( ModuleName );
        }
        if ( ModuleFullName && NewModule->module_FullName == (PCHAR)0 )   {
            NewModule->module_FullName = _strdup( ModuleFullName );
        }

    }

#define VerboseModuleFormat "0x%p 0x%p "

VerbosePrint(( VERBOSE_MODULES, VerboseModuleFormat " %s [%s]\n",
                                (PVOID)NewModule->Base,
                                (PVOID)(NewModule->Base + (ULONG64)NewModule->Length),
                                NewModule->module_Name,
                                ModuleFullName
            ));

#undef VerboseModuleFormat

    return(NewModule);

} // CreateNewModule()

BOOL
InitializeAsDebugger(VOID)
{

    HANDLE              Token;
    PTOKEN_PRIVILEGES   NewPrivileges;
    LUID                LuidPrivilege;
    BOOL                bRet           = FALSE;

    //
    // Make sure we have access to adjust and to get the old token privileges
    //
    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &Token)) {

        return( FALSE );

    }

    //
    // Initialize the privilege adjustment structure
    //

    LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &LuidPrivilege );

    NewPrivileges = (PTOKEN_PRIVILEGES)calloc(1,sizeof(TOKEN_PRIVILEGES) +
                                          (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL) {
        CloseHandle(Token);
        return( FALSE );
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    bRet = AdjustTokenPrivileges( Token,
                                 FALSE,
                                 NewPrivileges,
                                 0,
                                 (PTOKEN_PRIVILEGES)NULL,
                                 NULL );

    CloseHandle( Token );
    
    free( NewPrivileges );
     
    return (bRet);
} // InitializeAsDebugger()
      
VOID
InitSymbolPath(
    HANDLE SymHandle
    )
{
    PCHAR tmpPath;
    LONG  CharsLeft;
    CHAR  WinDirPath[]    = ";%Windir%\\System32\\Drivers;%Windir%\\System32;%Windir%";
    CHAR  DriversPath[]   = "\\system32\\drivers;";
    CHAR  System32Path[]  = "\\system32;";
    CHAR  PathSeparator[] = ";";

    tmpPath = malloc(TOTAL_SYMPATH_LENGTH*sizeof(char));
    if(tmpPath == NULL){
        FPRINTF(stderr, "KERNRATE: Failed memory allocation for tmpPath in InitSymbolPath\n");
        exit(1);
    }
    
    if ( SymSetSearchPath(SymHandle, (LPSTR)0 ) == TRUE )   { 
       // When SymSetSearchPath() is called with SearchPath as NULL, the following 
       // symbol path default is used: 
       //    .;%_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%; 

       if ( gUserSymbolPath[0] != '\0' )   { 
          // 
          // Note: We prepend the user specified path to the current search path. 
          // 
          if ( SymGetSearchPath( SymHandle, tmpPath, sizeof( tmpPath ) ) == TRUE )   { 
             strncpy( gSymbolPath, gUserSymbolPath, USER_SYMPATH_LENGTH-1);
             strncat( gSymbolPath, PathSeparator, lstrlen(PathSeparator) ); 
             CharsLeft = TOTAL_SYMPATH_LENGTH - lstrlen(gSymbolPath)-1;
             if ( (lstrlen(gSymbolPath) + lstrlen(tmpPath) ) > TOTAL_SYMPATH_LENGTH - 1 )
                 FPRINTF(stderr, "===>WARNING: Overall symbol path length exceeds %d characters and will be truncated\n",
                                 TOTAL_SYMPATH_LENGTH
                                 );     

             strncat( gSymbolPath, tmpPath, CharsLeft-1 );
             gSymbolPath[ TOTAL_SYMPATH_LENGTH-1 ] = '\0'; 

             if ( SymSetSearchPath( SymHandle, gSymbolPath ) != TRUE )   { 
                FPRINTF( stderr, "KERNRATE: Failed to set the user specified symbol search path.\nUsing default IMAGEHLP symbol search path...\n" );
             } 
          } 
       } 
       //
       // IMAGEHLP also looks for the executabe image. Let's append %windir%\system32\drivers;%windir%\system32;%windir%
       // to the end of the path. This way privates will always be searched first in the current directory. 
       // Also, this order will allow to find executables in their "natural" directories first, before going to dllcache etc.
       //
       if ( SymGetSearchPath( SymHandle, gSymbolPath, sizeof( gSymbolPath ) ) == TRUE ) {
           CharsLeft = TOTAL_SYMPATH_LENGTH - lstrlen( gSymbolPath ) - 1; 
           strncpy( tmpPath, WinDirPath, CharsLeft);
           tmpPath[CharsLeft] = '\0'; 
           
           if ( (lstrlen(gSymbolPath) + lstrlen(tmpPath)) > TOTAL_SYMPATH_LENGTH - 1 )
               FPRINTF(stderr, "===>WARNING: Overall symbol path length exceeds %d characters and will be truncated\n",
                               TOTAL_SYMPATH_LENGTH
                               );     

           strncat( gSymbolPath, tmpPath, lstrlen(tmpPath) );  //tmpPath length is CharsLeft
           gSymbolPath[ TOTAL_SYMPATH_LENGTH-1 ] = '\0';
       
           if ( SymSetSearchPath(SymHandle, gSymbolPath) != TRUE ) {
                FPRINTF( stderr, "KERNRATE: Failed to set the symbol search path with %%windir%%.\nCurrent symbol search path is: %s\n", gSymbolPath );
           }
       }
    } 
    else  { 

       FPRINTF( stderr, "KERNRATE: Failed to set the IMAGEHLP default symbol search path, trying to set to %%windir%% and sub directories\n" ); 
       // 
       // Set the Symbol Search Path with "%WINDIR%" - 
       // it was the behaviour of the original MS code... 
       // Let's also append system32 and system32\drivers to the path so people will stop complaining
       // 
       if( 0 != GetEnvironmentVariable("windir", gSymbolPath, sizeof(gSymbolPath)) ){ 
           CharsLeft = TOTAL_SYMPATH_LENGTH - 1;
           if( CharsLeft >= (lstrlen(System32Path) + 3*lstrlen(gSymbolPath) + lstrlen(DriversPath) + lstrlen(PathSeparator) ) ){
               strncpy(tmpPath, gSymbolPath, TOTAL_SYMPATH_LENGTH - 1);
               tmpPath[ TOTAL_SYMPATH_LENGTH-1 ] = '\0';  
               strncat(tmpPath, DriversPath, lstrlen(DriversPath) );
               strncat(tmpPath, gSymbolPath, lstrlen(gSymbolPath) ); 
               strncat(tmpPath, System32Path, lstrlen(System32Path) ); 
               strncat(tmpPath, gSymbolPath, lstrlen(gSymbolPath) ); 
               strncat(tmpPath, PathSeparator, lstrlen(PathSeparator) ); 
               strncpy(gSymbolPath, tmpPath,  TOTAL_SYMPATH_LENGTH - 1 );
               gSymbolPath[TOTAL_SYMPATH_LENGTH - 1] = '\0';      
           
           }
           else{
               FPRINTF( stderr, "KERNRATE: Overall path length for %%windir%% and sub directories exceeds %d characters\n",
                                TOTAL_SYMPATH_LENGTH
                                );
           }   
       
           SymSetSearchPath(SymHandle, gSymbolPath); 
       } else {
           FPRINTF(stderr, "KERNRATE: Failed to get environment variable for %%windir%%, failed to set alternate symbol path\n");
       }  
    } 
    // 
    // In any case [and it is redundant to do this in some of the previous cases], 
    // but we want to be in sync, especially for the image and debug files checksum check. 
    // 
    if ( SymGetSearchPath(SymHandle, gSymbolPath, sizeof( gSymbolPath ) ) != TRUE )  { 
       FPRINTF( stderr, "KERNRATE: Failed to get IMAGEHLP symbol files search path...\n" ); 
       // 
       // The content of gSymbolPath is now undefined. so clean it... 
       // gSymbolPath[] users have to check the content. 
       // 
       gSymbolPath[0] = '\0'; 
    } 
    else if ( gVerbose & VERBOSE_IMAGEHLP )  { 
       FPRINTF( stderr, "KERNRATE: IMAGEHLP symbol search path is: %s\n", gSymbolPath ); 
    } 

    free( tmpPath );
    bSymPathInitialized = TRUE;
} // InitSymbolPath()


BOOL
InitializeKernelProfile(VOID)
{

    DWORD m,k;

    PPROC_TO_MONITOR ProcToMonitor = calloc(1, sizeof(PROC_TO_MONITOR));

    if (ProcToMonitor==NULL) {
        FPRINTF(stderr, "Allocation for the System Process failed\n");
        return(FALSE);
    }

    gpSysProc                    = ProcToMonitor;

    ProcToMonitor->ProcessHandle        = SYM_KERNEL_HANDLE;
    ProcToMonitor->Index                = gNumProcToMonitor;
    ProcToMonitor->Next                 = gProcessList;       // NULL
    gProcessList                        = ProcToMonitor;
    ProcToMonitor->ZoomList             = gCommonZoomList;    // gCommonZoomList may contain System modules
    ProcToMonitor->pProcThreadInfoStart = NULL;

    for(m=0; m<gNumTasksStart; m++){
        if( !_stricmp(gTlistStart[m].ProcessName, gSystemProcessName) ){
            ProcToMonitor->Pid = gTlistStart[m].ProcessId;    
            if( bSystemThreadsInfo == TRUE ){
                UpdateProcessStartInfo(ProcToMonitor,
                                       &gTlistStart[m],
                                       bSystemThreadsInfo
                                       );
            }
            break;
        }
    }
        
    InitializeProfileSourceInfo(ProcToMonitor);        // Initialize ProfileSourceInfo for kernel trace

    // Update profiling rate for kernel trace if necessary

    SetProfileSourcesRates(ProcToMonitor);

    gNumProcToMonitor++;

    if (!SymInitialize( SYM_KERNEL_HANDLE, NULL, FALSE )) {
        FPRINTF (stderr, "Could not initialize imagehlp for kernel - %d\n", GetLastError ());
        return (FALSE);
    }

    if (!bSymPathInitialized) {
        InitSymbolPath( SYM_KERNEL_HANDLE );
    }
    else {
        SymSetSearchPath(ProcToMonitor->ProcessHandle,  gSymbolPath); 
    }

    if ( SymRegisterCallback64( ProcToMonitor->ProcessHandle, SymbolCallbackFunction, (ULONG64)&gCurrentModule ) != TRUE )   {
         FPRINTF( stderr, "KERNRATE: Failed to register callback for IMAGEHLP Kernel handle operations...\n" );
    }

    return TRUE;

} //InitializeKernelProfile()


DWORD
GetTaskList(
    PTASK_LIST      pTask,
    ULONG           NumTasks
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses internal NT apis and data structures.  This
    api is MUCH faster that the non-internal version that uses the registry.

Arguments:

    pTask          - Pointer to a TASK_LIST struct
    NumTasks       - Maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

--*/

{
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo;
    NTSTATUS                     status;
    ANSI_STRING                  pname;
    PCHAR                        p;
    PUCHAR                       CommonLargeBuffer;
    ULONG                        TotalOffset;
    ULONG                        totalTasks = 0;
    ULONG                        CommonLargeBufferSize = 64*1024;

    do {
        
        CommonLargeBuffer = VirtualAlloc (NULL,
                                          CommonLargeBufferSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE);
        if (CommonLargeBuffer == NULL) {
            return 0;
        }

        status = NtQuerySystemInformation(
                    SystemProcessInformation,
                    CommonLargeBuffer,
                    CommonLargeBufferSize,
                    NULL
                    );

        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            CommonLargeBufferSize += 8192;
            VirtualFree (CommonLargeBuffer, 0, MEM_RELEASE);
            CommonLargeBuffer = NULL;
        }
        else if ( !NT_SUCCESS(status) ) {
            FPRINTF(stderr, "KERNRATE: NtQuerySystemInformation failed in getTaskList, status %08lx, aborting\n", status);
            exit(1);
        }  

    
    } while ( CommonLargeBuffer == NULL ); 
    
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) CommonLargeBuffer;
    TotalOffset = 0;
    
    do {

        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) {

            status = RtlUnicodeStringToAnsiString( &pname, (PUNICODE_STRING)&ProcessInfo->ImageName, TRUE );
            if ( NT_SUCCESS(status) && pname.Buffer )   {
                p = strrchr(pname.Buffer,'\\');
                if ( p ) {
                    p++;
                }
                else {
                    p = pname.Buffer;
                }
            }
            else  {
                p = "???UToAStr err"; // RtlUnicodeStringToAnsiString error.
            }
        }
        else {
            p = "System Idle Process";
        }

        strncpy( pTask->ProcessName, p, sizeof(pTask->ProcessName)-1 ); 
        pTask->ProcessId = (LONGLONG)ProcessInfo->UniqueProcessId;

        if(bIncludeGeneralInfo){        
            pTask->ProcessPerfInfo.NumberOfThreads        = ProcessInfo->NumberOfThreads;
            pTask->ProcessPerfInfo.UserTime               = ProcessInfo->UserTime;
            pTask->ProcessPerfInfo.KernelTime             = ProcessInfo->KernelTime;
            pTask->ProcessPerfInfo.ReadOperationCount     = ProcessInfo->ReadOperationCount;
            pTask->ProcessPerfInfo.WriteOperationCount    = ProcessInfo->WriteOperationCount;
            pTask->ProcessPerfInfo.OtherOperationCount    = ProcessInfo->OtherOperationCount;
            pTask->ProcessPerfInfo.ReadTransferCount      = ProcessInfo->ReadTransferCount;
            pTask->ProcessPerfInfo.WriteTransferCount     = ProcessInfo->WriteTransferCount;
            pTask->ProcessPerfInfo.OtherTransferCount     = ProcessInfo->OtherTransferCount;
            pTask->ProcessPerfInfo.PageFaultCount         = ProcessInfo->PageFaultCount;
            pTask->ProcessPerfInfo.HandleCount            = ProcessInfo->HandleCount;
            pTask->ProcessPerfInfo.VirtualSize            = ProcessInfo->VirtualSize;
            pTask->ProcessPerfInfo.WorkingSetSize         = ProcessInfo->WorkingSetSize;
            pTask->ProcessPerfInfo.QuotaPagedPoolUsage    = ProcessInfo->QuotaPagedPoolUsage;
            pTask->ProcessPerfInfo.QuotaNonPagedPoolUsage = ProcessInfo->QuotaNonPagedPoolUsage;
            pTask->ProcessPerfInfo.PagefileUsage          = ProcessInfo->PagefileUsage;
            pTask->ProcessPerfInfo.PrivatePageCount       = ProcessInfo->PrivatePageCount;

            if( bIncludeThreadsInfo == TRUE ){

                if(pTask->pProcessThreadInfo != NULL) //This is not the first time we,ve been called
                    free(pTask->pProcessThreadInfo);
                
                pTask->pProcessThreadInfo = 
                    (PSYSTEM_THREAD_INFORMATION)calloc(ProcessInfo->NumberOfThreads,
                                                       sizeof(SYSTEM_THREAD_INFORMATION)
                                                       );
                if (pTask->pProcessThreadInfo != NULL) {
                    UINT nThreads = ProcessInfo->NumberOfThreads;
                    PSYSTEM_THREAD_INFORMATION pSysThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
                    while (nThreads--){
                        pTask->pProcessThreadInfo[nThreads].KernelTime      = pSysThreadInfo->KernelTime;
                        pTask->pProcessThreadInfo[nThreads].UserTime        = pSysThreadInfo->UserTime;
                        pTask->pProcessThreadInfo[nThreads].CreateTime      = pSysThreadInfo->CreateTime;
                        pTask->pProcessThreadInfo[nThreads].WaitTime        = pSysThreadInfo->WaitTime;
                        pTask->pProcessThreadInfo[nThreads].StartAddress    = pSysThreadInfo->StartAddress;
                        pTask->pProcessThreadInfo[nThreads].ClientId.UniqueProcess =
                                                                    pSysThreadInfo->ClientId.UniqueProcess;
                        pTask->pProcessThreadInfo[nThreads].ClientId.UniqueThread =
                                                                     pSysThreadInfo->ClientId.UniqueThread;
                        pTask->pProcessThreadInfo[nThreads].Priority        = pSysThreadInfo->Priority;
                        pTask->pProcessThreadInfo[nThreads].BasePriority    = pSysThreadInfo->BasePriority;
                        pTask->pProcessThreadInfo[nThreads].ContextSwitches = pSysThreadInfo->ContextSwitches;
                        pTask->pProcessThreadInfo[nThreads].ThreadState     = pSysThreadInfo->ThreadState;
                        pTask->pProcessThreadInfo[nThreads].WaitReason      = pSysThreadInfo->WaitReason;

                        pSysThreadInfo++;
                    }
                }
            }
        }

        pTask++;
        totalTasks++;

        if ( ProcessInfo->NextEntryOffset == 0 ){
            break;
        } 

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CommonLargeBuffer[TotalOffset];


    }while ( totalTasks < NumTasks );

    if(CommonLargeBuffer != NULL){
        VirtualFree(CommonLargeBuffer, 0, MEM_RELEASE);
    }
    
    return totalTasks;

} //getTasklist()

VOID
SetProfileSourcesRates(
    PPROC_TO_MONITOR ProcToMonitor
    )
/*++

Routine Description:

    Attempts to set the requested (or default) sampling rates for the selected profile sources
    Will try to set the system default rate if it failed to set the requested rate for a particular source
     
Arguments:

    ProcToMonitor - Pointer to the structure of the process being monitored

Return Value:

    None.

--*/

{

    KPROFILE_SOURCE ProfileSource;
    NTSTATUS        Status;
    ULONG           ProfileSourceIndex;
    ULONGLONG       Pid;
    CHAR            String1[]          = "\nKernel Profile (PID = %I64d): Source=";
    CHAR            String2[]          = "\nPID = %I64d: Source=";
    CHAR            OutString[256]     = "";

    // Update profiling rate for kernel or user processes traces if necessary

    for (ProfileSourceIndex = 0; ProfileSourceIndex < gSourceMaximum; ProfileSourceIndex++){

        if (gpProcDummy->Source[ProfileSourceIndex].Interval != 0){

            Pid = ProcToMonitor->Pid;
       
            if( ProcToMonitor->ProcessHandle == SYM_KERNEL_HANDLE ) {
                sprintf( &OutString[0], String1, Pid);
            } else {
                sprintf( &OutString[0], String2, Pid);
            }

            ProcToMonitor->Source[ProfileSourceIndex].Interval = gpProcDummy->Source[ProfileSourceIndex].Interval;

            if ( ProcToMonitor->Source[ProfileSourceIndex].DesiredInterval && ProcToMonitor->Source[ProfileSourceIndex].Interval )   {

                ULONG ThisInterval;
           
                ProfileSource = ProcToMonitor->Source[ProfileSourceIndex].ProfileSource;
                NtSetIntervalProfile(ProcToMonitor->Source[ProfileSourceIndex].Interval, ProfileSource);

                Status = NtQueryIntervalProfile(ProfileSource, &ThisInterval);
                if(gVerbose & VERBOSE_PROFILING ) 

                    FPRINTF(stdout, "Requested Rate= %ld Events/Hit, Actual Rate= %ld Events/Hit\n",
                                    ProcToMonitor->Source[ProfileSourceIndex].Interval,
                                    ThisInterval
                                    );

                if ((NT_SUCCESS(Status)) && RATES_MATCH(ThisInterval, gpProcDummy->Source[ProfileSourceIndex].Interval) ) {

                    if ( ProfileSourceIndex < gStaticCount ) {
                        if ( ProcToMonitor->Source[ProfileSourceIndex].Interval == gStaticSource[ProfileSourceIndex].Interval ){

                            if (ThisInterval == ProcToMonitor->Source[ProfileSourceIndex].Interval){
                                FPRINTF(stdout,
                                        "%s %s, \nUsing Kernrate Default Rate of %ld events/hit\n",
                                        OutString,
                                        ProcToMonitor->Source[ProfileSourceIndex].Name,
                                        ThisInterval
                                        );
                            } else {
                                FPRINTF(stdout,
                                        "%s, %s, \nTried Using Kernrate Default Rate of %ld events/hit, Actual Rate= %ld events/hit\n",
                                        OutString,
                                        ProcToMonitor->Source[ProfileSourceIndex].Name,
                                        ProcToMonitor->Source[ProfileSourceIndex].Interval,
                                        ThisInterval
                                        );
                            }
                        } else {

                            FPRINTF(stdout,
                                    "%s %s, \nUser Requested Rate= %ld events/hit, Actual Rate= %ld events/hit\n",
                                    OutString,
                                    ProcToMonitor->Source[ProfileSourceIndex].Name,
                                    ProcToMonitor->Source[ProfileSourceIndex].Interval,
                                    ThisInterval
                                    );

                        }
                    } else {     

                        FPRINTF(stdout,
                                "%s %s, \nUsing Kernrate Default or User Requested Rate of %ld events/hit\n",
                                OutString,
                                ProcToMonitor->Source[ProfileSourceIndex].Name,
                                ThisInterval
                                );

                    }
                    ProcToMonitor->Source[ProfileSourceIndex].Interval = ThisInterval;           
           
                } else {

                    NtSetIntervalProfile(ProcToMonitor->Source[ProfileSourceIndex].DesiredInterval, ProfileSource);
                    Status = NtQueryIntervalProfile(ProfileSource, &ThisInterval);
           
                    if ((NT_SUCCESS(Status)) && (ThisInterval > 0)) {
                        BOOL bPrint = TRUE;
                        //
                        // The StaticSources array (may) contain invalid default intervals, let's not bother the user with that
                        //
                        if ( ProfileSourceIndex < gStaticCount ) {
                            if ( ProcToMonitor->Source[ProfileSourceIndex].Interval == gStaticSource[ProfileSourceIndex].Interval ){

                                FPRINTF(stdout,
                                        "%s %s, \nUsing Kernrate Default Rate of %ld events/hit\n",
                                        OutString,
                                        ProcToMonitor->Source[ProfileSourceIndex].Name,
                                        ThisInterval
                                        );

                                bPrint = FALSE;
                            }
                        }     
                   
                        if(bPrint == TRUE) {

                            FPRINTF(stdout,
                                    "%s %s, \nCould Not Set User Requested Rate, Using System Default Rate of %ld events/hit\n",
                                    OutString,
                                    ProcToMonitor->Source[ProfileSourceIndex].Name,
                                    ThisInterval
                                    );

                        }

                        ProcToMonitor->Source[ProfileSourceIndex].Interval = ThisInterval;
           
                    } else {
                        ProcToMonitor->Source[ProfileSourceIndex].Interval = 0;

                        FPRINTF(stdout,
                                "%s %s, Could not Set Interval Rate, Setting to 0 (disabling this source)\n",
                                OutString,
                                ProcToMonitor->Source[ProfileSourceIndex].Name
                                );

                    }
                }
            } else {
                ProcToMonitor->Source[ProfileSourceIndex].Interval = 0;
            }

        } else if( ProfileSourceIndex == SOURCE_TIME ) { 
            ULONG ThisInterval;

            ProfileSource = ProcToMonitor->Source[ProfileSourceIndex].ProfileSource;
            NtSetIntervalProfile(ProcToMonitor->Source[ProfileSourceIndex].Interval, ProfileSource);
            Status = NtQueryIntervalProfile(ProfileSource, &ThisInterval);
            if ((NT_SUCCESS(Status)) && (ThisInterval == 0)) {
                FPRINTF(stdout,
                        "CPU TIME source disabled per user request\n"
                        );
            } else {
                FPRINTF(stderr,
                        "KERNRATE: Could not disable CPU TIME source on this platform (Kernrate will just not profile it)\n"
                        );
            }
            ProcToMonitor->Source[ProfileSourceIndex].Interval = 0;
        }

    } //for

} //SetProfileSourcesRates()    

VOID
GetProcessLocksInformation (
      PPROC_TO_MONITOR ProcToMonitor,
      ULONG Flags,
      ACTION_TYPE Action
      )
/*++

Routine Description:

    Gets and outputs the information about process locks that are under contention
    The list will miss short-lived locks that were created after the start count but went away before the end count.
         
Arguments:

    ProcToMonitor - Pointer to the structure of the process being monitored
    Flags         - RTL_QUERY_PROCESS_LOCKS 
    Action        - Either START, STOP or OUTPUT
Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG    BufferSize = 0; 

    if ( !WIN2K_OS )
        Flags |= RTL_QUERY_PROCESS_NONINVASIVE;                      //Not defined on Win2K

    switch (Action) {

    case START:

        ProcToMonitor->pProcDebugInfoStart = RtlCreateQueryDebugBuffer( BufferSize, FALSE );

        if(ProcToMonitor->pProcDebugInfoStart == NULL) {
               FPRINTF(stderr, "KERNRATE: Failed to create buffer (START) in GetProcessLocksInformation\n");
               FPRINTF(stderr, "KERNRATE: Process %s may have insufficient virtual memory left for collecting locks information\n",
                               ProcToMonitor->ProcessName
                               );

            return;
        }

        Status = RtlQueryProcessDebugInformation(  (HANDLE)ProcToMonitor->Pid,
                                                   Flags,
                                                   ProcToMonitor->pProcDebugInfoStart
                                                   );

        if(!NT_SUCCESS(Status)) {
               FPRINTF(stderr, "KERNRATE: Failed call to RtlQueryProcessDebugInformation (START) for Locks Information\n");
            FPRINTF(stderr, "Process: %s, Status = %x\n", ProcToMonitor->ProcessName, Status);
            if(Status == STATUS_INFO_LENGTH_MISMATCH)FPRINTF(stderr, "Status = INFO_LENGTH_MISMATCH\n");
            if(Status == STATUS_NO_MEMORY)FPRINTF(stderr, "Status = NO_MEMORY\n");

            return;
        }

        break;    

    case STOP:
            
        ProcToMonitor->pProcDebugInfoStop = RtlCreateQueryDebugBuffer( BufferSize, FALSE );

        if(ProcToMonitor->pProcDebugInfoStop == NULL) {
               FPRINTF(stderr, "KERNRATE: Failed to create buffer (STOP) in GetProcessLocksInformation\n");
               FPRINTF(stderr, "KERNRATE: Process %s may have insufficient virtual memory left for collecting locks information\n",
               ProcToMonitor->ProcessName
               );
               

            return;
        }

        Status = RtlQueryProcessDebugInformation(  (HANDLE)ProcToMonitor->Pid,
                                                   Flags,
                                                   ProcToMonitor->pProcDebugInfoStop
                                                   );

        if(!NT_SUCCESS(Status)){
               FPRINTF(stderr, "KERNRATE: Failed call to RtlQueryProcessDebugInformation (STOP) for Locks Information\n");
            FPRINTF(stderr, "Process: %s, Status = %x\n", ProcToMonitor->ProcessName, Status);
            if(Status == STATUS_INFO_LENGTH_MISMATCH)FPRINTF(stderr, "Status = INFO_LENGTH_MISMATCH\n");
            if(Status == STATUS_NO_MEMORY)FPRINTF(stderr, "Status = NO_MEMORY\n");

            return;
        }

        break;    

    case OUTPUT:
        
        {

            if(    ProcToMonitor->pProcDebugInfoStart == NULL || ProcToMonitor->pProcDebugInfoStop == NULL) return;

                OutputLocksInformation( ProcToMonitor->pProcDebugInfoStart->Locks,
                                        ProcToMonitor->pProcDebugInfoStop->Locks,
                                        ProcToMonitor
                                       );

            //
            // Cleanup for this process    - note that the target process may be gone so we need to be careful
            //

            try {
                if ( ProcToMonitor->pProcDebugInfoStart != NULL)
                    RtlDestroyQueryDebugBuffer( ProcToMonitor->pProcDebugInfoStart );
                if ( ProcToMonitor->pProcDebugInfoStop != NULL)
                    RtlDestroyQueryDebugBuffer( ProcToMonitor->pProcDebugInfoStop );

            } _except ( EXCEPTION_EXECUTE_HANDLER ) {

                FPRINTF(stderr, "Exception %X raised while trying to call RtlDestroyQueryDebugBuffer\n",
                                _exception_code()
                                );
                FPRINTF(stderr, "This could happen if the monitored process is gone\n");
                return;
            }

        }
         

         break;
    
    default:
        
        FPRINTF(stderr, "GetProcessLocksInformation was called with an invalid Action parameter - %d\n", Action);
            
    }
    
} //GetProcessLocksInformation ()     


VOID
GetSystemLocksInformation (
      ACTION_TYPE Action
      )
/*++

Routine Description:

    Gets and outputs the information about System (Kernel) locks that are under contention
    The list will miss short-lived locks that were created after the start count but went away before the end count.
          
Arguments:

    Action        - Either START, STOP or OUTPUT

Return Value:

    None.

--*/

{
    NTSTATUS                  Status;
    static BOOL               bDisplayLockInfo;
    static PRTL_PROCESS_LOCKS ProcessLockInfoStart;
    static PRTL_PROCESS_LOCKS ProcessLockInfoStop;
    ULONG                     BufferSize            = sizeof(RTL_PROCESS_LOCKS);


    switch (Action) {

    case START:

        bDisplayLockInfo = TRUE;
        
        do {
        
            ProcessLockInfoStart = malloc(BufferSize);
            if(ProcessLockInfoStart == NULL)
            {
                FPRINTF(stderr, "KERNRATE: Failed to allocate Buffer for Lock Info (START) \n");
                bDisplayLockInfo = FALSE;
                return;
            }
            Status = NtQuerySystemInformation(SystemLocksInformation,
                                              ProcessLockInfoStart,
                                              BufferSize,
                                              &BufferSize
                                              );
            if(Status == STATUS_SUCCESS){
                break;
            }

            if(Status != STATUS_INFO_LENGTH_MISMATCH){
                FPRINTF(stderr, "KERNRATE: Failed call to NTQuerySystemInformation for Lock Info (START) \n");
                bDisplayLockInfo = FALSE;
                return;
            }

            free( ProcessLockInfoStart );
            ProcessLockInfoStart = NULL;

        }while (Status == STATUS_INFO_LENGTH_MISMATCH);
        
        break;

    case STOP:

        do {
        
            ProcessLockInfoStop = malloc(BufferSize);
            if(ProcessLockInfoStop == NULL)
            {
                FPRINTF(stderr, "KERNRATE: Failed to allocate Buffer for Lock Info (STOP) \n");
                bDisplayLockInfo = FALSE;
                return;
            }
            Status = NtQuerySystemInformation( SystemLocksInformation,
                                               ProcessLockInfoStop,
                                               BufferSize,
                                               &BufferSize
                                               );
            if(Status == STATUS_SUCCESS){
                break;
            }

            if(Status != STATUS_INFO_LENGTH_MISMATCH){
                FPRINTF(stderr, "KERNRATE: Failed call to NTQuerySystemInformation for Lock Info (STOP) \n");
                bDisplayLockInfo = FALSE;
                return;
            }

            free( ProcessLockInfoStop );
            ProcessLockInfoStop = NULL;

        }while (Status == STATUS_INFO_LENGTH_MISMATCH);
        
        break;
    
    case OUTPUT:

        if( bDisplayLockInfo == TRUE ){
            
            OutputLocksInformation( ProcessLockInfoStart,
                                    ProcessLockInfoStop,
                                    gpSysProc
                                    );

            //
            // Cleanup
            //
            if(ProcessLockInfoStart != NULL){
                free( ProcessLockInfoStart );
                ProcessLockInfoStart = NULL;
            }
            if(ProcessLockInfoStop != NULL){
                free( ProcessLockInfoStop );
                ProcessLockInfoStop = NULL;
            }

        
        }
        break;
    
    default:
        
            FPRINTF(stderr, "KERNRATE INTERNAL ERROR: GetSystemLocksInformation was called with an invalid Action parameter - %d\n",
                            Action
                            );
            
    }
    
} //GetSystemLocksInformation ()     

VOID
OutputLocksInformation(
     PRTL_PROCESS_LOCKS pLockInfoStart,
     PRTL_PROCESS_LOCKS pLockInfoStop,
     PPROC_TO_MONITOR   Proc
     )
/*++

Routine Description:

    Outputs Lock Contention information for either System (Kernel) or User Process Locks
    If a lock is new (has only final counts) or gone (has only initial counts, it will be marked accordingly
    The routine will try to get the symbol name associated with the lock if one exists.
    The user can control (filter) the output by changing gLockContentionMinCount
    The list will miss short-lived Locks that were created after the start count but went away before the end count.
             
Arguments:

    pLockInfoStart - Pointer to lock info struct (Initial count)
    pLockInfoStop  - Pointer to lock info struct (Final count)
    SymHandle      - Symbol Handle to the process
     
Return Value:

    None.

--*/

{
    ULONG              i,j,k;
    DWORD64            disp;
    CHAR               TypeString[32]       = "UNKNOWN";
    PMODULE            Module;
    BOOL               bAnyLocksFound       = FALSE;
    BOOL              *Index                = NULL;
    ULONG64           *LoadedBases          = NULL; 
    HANDLE             SymHandle;
    
    if(Proc == NULL){
        FPRINTF(stderr, "KERNRATE: NULL Process pointer passed to OutputLocksInformation\n");
        FPRINTF(stderr, "Possible cause: Kernel Resource info was required with the -x or -xk command line options,\n");
        FPRINTF(stderr, "but was the -a option specified on the command line as well?\n"); 
        exit(1);  
    }
    SymHandle = Proc->ProcessHandle;

    if( pLockInfoStart != NULL ) {
        if( pLockInfoStart->NumberOfLocks > 0 ) {   
            Index = (BOOL*)calloc(pLockInfoStart->NumberOfLocks, sizeof(BOOL));
            if( Index == NULL ){
                FPRINTF(stderr, "KERNRATE: Failed to allocate memory for Index data in OutputLocksInformation\n");
                exit(1);
            }
        } else {
            FPRINTF(stdout, "\nNo locks found or process %s has insufficient virtual memory for collecting lock information\n",
                            Proc->ProcessName
                            );  
            return;
        }
    }

    FPRINTF(stdout,
            "\nLocks Contention Info:\n\nAddress, Contention-Diff., Rate(per sec.), Thread, Type, Recursion, Waiting-Shared, Waiting-Exclusive, Symbol-Information\n"
            );

    // We could sort the data first for a faster search, but sorting the two arrays costs too...
    if( pLockInfoStop != NULL ) { 

        LoadedBases = (ULONG64 *)calloc( Proc->ModuleCount, sizeof(ULONG64) );
        if( LoadedBases == NULL ){
            FPRINTF(stderr, "KERNRATE: Failed to allocate memory for module base data in OutputLocksInformation\n");
            exit(1);
        }

        for (i=0; i < pLockInfoStop->NumberOfLocks; i++){
                        
            BOOL bFound = FALSE;

            if( pLockInfoStop->Locks[i].ContentionCount >= gLockContentionMinCount)   //Additional preliminary filter
                                                                                //(if not true then contention difference not true)
            if( pLockInfoStart != NULL ) { 
                for (j=0; j < pLockInfoStart->NumberOfLocks; j++){  

                    if( (DWORD64)(DWORD64 *)pLockInfoStop->Locks[i].Address == (DWORD64)(DWORD64 *)pLockInfoStart->Locks[j].Address ){
                        LONG ContentionDiff = pLockInfoStop->Locks[i].ContentionCount -
                                                             pLockInfoStart->Locks[j].ContentionCount;
                        long double Rate   = (long double)ContentionDiff / gldElapsedSeconds;
                        LONG RecursionDiff = pLockInfoStop->Locks[i].RecursionCount -
                                                             pLockInfoStart->Locks[j].RecursionCount;
                        LONG WaitShrdDiff  = pLockInfoStop->Locks[i].NumberOfWaitingShared -
                                                              pLockInfoStart->Locks[j].NumberOfWaitingShared;
                        LONG WaitExclDiff  = pLockInfoStop->Locks[i].NumberOfWaitingExclusive -
                                                             pLockInfoStart->Locks[j].NumberOfWaitingExclusive;

                        if(ContentionDiff >= (LONG)gLockContentionMinCount ){
                            if(pLockInfoStop->Locks[i].Type == RTL_CRITSECT_TYPE)
                                strncpy(TypeString, "CRITICAL_SECTION", sizeof(TypeString)-1);
                            if(pLockInfoStop->Locks[i].Type == RTL_RESOURCE_TYPE)
                                strncpy(TypeString, "RESOURCE", sizeof(TypeString)-1);

                            FPRINTF(stdout, "%p, %10ld, %10.0f,      0x%I64x, %s, ",
                                            (PVOID64)pLockInfoStop->Locks[i].Address,
                                            ContentionDiff,
                                              Rate,
                                             (LONGLONG)pLockInfoStop->Locks[i].OwningThread,
                                            TypeString
                                             );

                            if(pLockInfoStop->Locks[i].Type == RTL_CRITSECT_TYPE)
                                FPRINTF(stdout, " %10ld,     N/A,     N/A", RecursionDiff);
         
                             if(pLockInfoStop->Locks[i].Type == RTL_RESOURCE_TYPE)
                                 FPRINTF(stdout, " N/A,    %10ld, %10ld ", WaitShrdDiff,    WaitExclDiff);
                                
                            Module = FindModuleForAddress64( Proc,
                                                             (DWORD64)(DWORD64 *)pLockInfoStop->Locks[i].Address);
                            
                            //
                            //In the folllowing it may happen that we try to load a module more than once
                            //we don't really care about the return status
                            // 
                            if( Module != NULL ) {
                                if( Module->bZoom != TRUE ){
                                    //
                                    //Avoid trying to load what's already loaded and for later cleanup purposes
                                    //
                                    for( k=0; k<Proc->ModuleCount; k++ ) {         
                                                                                 
                                        if(LoadedBases[k] == Module->Base) {     //Already been loaded
                                            break;
                                        } else if( LoadedBases[k] == 0 ) {             //End of populated list, load a new module 
                                            (void)SymLoadModule64( SymHandle,                              // hProcess
                                                                   NULL,                                   // hFile [for Debugger]
                                                                   Module->module_Name,                    // ImageName
                                                                   NULL,                                   // ModuleName
                                                                   Module->Base,                           // BaseOfDll
                                                                   Module->Length                          // SizeOfDll
                                                                   );

                                            *LoadedBases = Module->Base;
                                            ++LoadedBases;
                                            break;
                                        }
                                    }
                                }
                                if ( Module->Base )     
                                     FPRINTF(stdout, " ,base= %p", (PVOID64)Module->Base);  
                                if ( Module->module_Name )
                                     FPRINTF(stdout, " - %s", Module->module_Name);
                            }     

                             if ( SymGetSymFromAddr64((HANDLE)SymHandle, (DWORD64)(DWORD64 *)pLockInfoStop->Locks[i].Address, &disp, gSymbol )){
                                 FPRINTF(stdout, "!%s\n", gSymbol->Name);
                            } else {
                                  FPRINTF(stdout, "\n");
                            }    
                            bAnyLocksFound = TRUE;
                        }
                        Index[j] = TRUE;
                        bFound = TRUE;
                        break;
                    }
                    
                }//for(j)

            }//if(pLockInfoStart)

            //
            // No matching address found for START, therefore this is a NEW lock
            // Note that here the additional filter is checked anyway at the beginning
            //

            if( !bFound && pLockInfoStop->Locks[i].ContentionCount >= gLockContentionMinCount ) {
                long double Rate = (long double)pLockInfoStop->Locks[i].ContentionCount / gldElapsedSeconds;
                FPRINTF(stdout, "%p, %10Ld, %10.0f,       0x%I64x, %s, ",
                        (PVOID64)pLockInfoStop->Locks[i].Address,
                        pLockInfoStop->Locks[i].ContentionCount,
                        Rate,
                        (LONGLONG)pLockInfoStop->Locks[i].OwningThread,
                        TypeString
                        );

                if( pLockInfoStop->Locks[i].Type == RTL_CRITSECT_TYPE )
                    FPRINTF(stdout, " %10Ld,     N/A,     N/A",
                                    pLockInfoStop->Locks[i].RecursionCount);

                if( pLockInfoStop->Locks[i].Type == RTL_RESOURCE_TYPE )
                    FPRINTF(stdout, " N/A,    %10Ld, %10Ld ",
                                    pLockInfoStop->Locks[i].NumberOfWaitingShared,
                                    pLockInfoStop->Locks[i].NumberOfWaitingExclusive
                                    );

                Module = FindModuleForAddress64( Proc,
                                                 (DWORD64)(DWORD64 *)pLockInfoStop->Locks[i].Address);
                if( Module != NULL ) {
                    if( Module->bZoom != TRUE ){
                        //
                        //Avoid trying to load what's already loaded and for later cleanup purposes
                        //
                        for( k=0; k<Proc->ModuleCount; k++ ) {         
                            if(LoadedBases[k] == Module->Base) {     //Already been loaded
                                   break;
                            } else {
                                if( LoadedBases[k] == 0 ) {             //End of populated list, load a new module

                                    (void)SymLoadModule64( SymHandle,                              // hProcess
                                                           NULL,                                   // hFile [for Debugger]
                                                           Module->module_Name,                    // ImageName
                                                           NULL,                                   // ModuleName
                                                           Module->Base,                           // BaseOfDll
                                                           Module->Length                          // SizeOfDll
                                                           );

                                    *LoadedBases = Module->Base;
                                    ++LoadedBases;
                                    break;
                                }
                            }
                        }
                    }
                    if ( Module->Base )     
                         FPRINTF(stdout, ", base= %p", (PVOID64)Module->Base);  
                    if ( Module->module_Name )
                         FPRINTF(stdout, " - %s", Module->module_Name);

                }     

                 if ( SymGetSymFromAddr64((HANDLE)SymHandle,(DWORD64)(DWORD64 *)pLockInfoStop->Locks[i].Address, &disp, gSymbol )){
                    FPRINTF(stdout, "!%s,  NEW - (actual rate could be higher)\n", gSymbol->Name);
                  } else {
                    FPRINTF(stdout, ",  NEW - (actual rate could be higher)\n");
                   }
                bAnyLocksFound = TRUE;
            }
                
        }// for(i)     
        
        // Cleanup

        for( i=0; i<Proc->ModuleCount; i++ )
        {
            if(LoadedBases[i] != 0) {
                if(!SymUnloadModule64( SymHandle, LoadedBases[i])) {
                    VerbosePrint(( VERBOSE_IMAGEHLP, "Kernrate: Could Not Unload Module, Base= %p for Process %s\n",
                                                     (PVOID64)LoadedBases[i],
                                                     Proc->ProcessName
                                                     ));
                    continue;
                } 
                
                VerbosePrint(( VERBOSE_IMAGEHLP, "Kernrate: Unloaded Module, Base= %p for Process %s\n", 
                                                 (PVOID64)LoadedBases[i],
                                                 Proc->ProcessName
                                                 ));
            }
        } 
            

    }//if(pLockInfoStop)        

    //
    // No matching address found for STOP, therefore this lock is GONE 
    // 
    if( pLockInfoStart != NULL) { 

        for (j=0; j < pLockInfoStart->NumberOfLocks; j++){

            if( (Index[j] == FALSE) && (pLockInfoStart->Locks[j].ContentionCount >= gLockContentionMinCount) ){
                if(pLockInfoStart->Locks[j].Type == RTL_CRITSECT_TYPE)
                    strncpy(TypeString, "CRITICAL_SECTION",  sizeof(TypeString)-1);
                if(pLockInfoStart->Locks[j].Type == RTL_RESOURCE_TYPE)
                    strncpy(TypeString, "RESOURCE",  sizeof(TypeString)-1);

                FPRINTF(stdout, "%p, %10Ld,        N/A,      0x%I64x, %s, ",
                                (PVOID64)pLockInfoStart->Locks[j].Address,
                                pLockInfoStart->Locks[j].ContentionCount,
                                (LONGLONG)pLockInfoStart->Locks[j].OwningThread,
                                TypeString
                                   );
                FPRINTF(stdout, "  GONE\n");

                bAnyLocksFound = TRUE;
            }
        }//for(j)
    
    }//if(pLockInfoStart)

    if ( bAnyLocksFound == FALSE)
        FPRINTF(stdout, "\nNo Locks with a contention-count difference of at least %d were found\n", gLockContentionMinCount);
    //
    //Cleanup
    //
    if(Index != NULL){
        free(Index);
        Index = NULL;
    }
    if(LoadedBases != NULL){
        free(LoadedBases);
        LoadedBases = NULL;
    }

} //OutputLocksInformation()        

VOID
GetProfileSystemInfo(
      ACTION_TYPE Action
      )
/*++

Routine Description:

    Gets and outputs System-Wide performance counts (context-switches, I/O, etc.)
    for the duration of the run   
         
Arguments:

    Action        - Either START, STOP or OUTPUT

Return Value:

    None.

--*/

{

    NTSTATUS Status;

    static BOOL                            bDisplayPerfInfo;
    static PSYSTEM_PERFORMANCE_INFORMATION SysPerfInfoStart;
    static PSYSTEM_PERFORMANCE_INFORMATION SysPerfInfoStop;
           
    switch (Action) {

    case START:

        bDisplayPerfInfo = TRUE;
        SysPerfInfoStart = malloc(sizeof(SYSTEM_PERFORMANCE_INFORMATION));
        if(SysPerfInfoStart == NULL){
            FPRINTF(stderr, "Memory allocation failed for SystemPerformanceInformation in GetProfileSystemInfo\n");
            exit(1);
        }
        Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                          SysPerfInfoStart,
                                          sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                          NULL);
        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr, "QuerySystemInformation for performance information(1) failed %08lx\n", Status);
            bDisplayPerfInfo = FALSE;
        }

        break;

    case STOP:

        SysPerfInfoStop = malloc(sizeof(SYSTEM_PERFORMANCE_INFORMATION));
        if(SysPerfInfoStop == NULL){
            FPRINTF(stderr, "Memory allocation failed for SystemPerformanceInformation in GetProfileSystemInfo\n");
            exit(1);
        }
        
        Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                          SysPerfInfoStop,
                                          sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                          NULL);
        if (!NT_SUCCESS(Status)) {
            FPRINTF(stderr, "QuerySystemInformation for performance information(2) failed %08lx\n", Status);
            bDisplayPerfInfo = FALSE;
        }
        
        break;

    case OUTPUT:

        if( bDisplayPerfInfo == TRUE ){

            FPRINTF (stdout, "\n                                  Total      Avg. Rate\n");
       
            DisplayTotalAndRate( SysPerfInfoStart->ContextSwitches,
                                 SysPerfInfoStop->ContextSwitches,
                                 gldElapsedSeconds,
                                 "Context Switches",
                                 "sec."
                                 );
                                   
            DisplayTotalAndRate( SysPerfInfoStart->SystemCalls,
                                 SysPerfInfoStop->SystemCalls,
                                 gldElapsedSeconds,
                                 "System Calls",
                                 "sec."
                                 );
            
            DisplayTotalAndRate( SysPerfInfoStart->PageFaultCount,
                                 SysPerfInfoStop->PageFaultCount,
                                 gldElapsedSeconds,
                                 "Page Faults",
                                 "sec."
                                 );
            
            DisplayTotalAndRate( SysPerfInfoStart->IoReadOperationCount,
                                 SysPerfInfoStop->IoReadOperationCount,
                                 gldElapsedSeconds,
                                 "I/O Read Operations",
                                 "sec."
                                 );
            
            DisplayTotalAndRate( SysPerfInfoStart->IoWriteOperationCount,
                                 SysPerfInfoStop->IoWriteOperationCount,
                                 gldElapsedSeconds,
                                 "I/O Write Operations",
                                 "sec."
                                 );

            DisplayTotalAndRate( SysPerfInfoStart->IoOtherOperationCount,
                                 SysPerfInfoStop->IoOtherOperationCount,
                                 gldElapsedSeconds,
                                 "I/O Other Operations",
                                 "sec."
                                 );

            DisplayTotalAndRate( SysPerfInfoStart->IoReadTransferCount.QuadPart,
                                 SysPerfInfoStop->IoReadTransferCount.QuadPart,
                                 (long double)(SysPerfInfoStop->IoReadOperationCount - SysPerfInfoStart->IoReadOperationCount),
                                 "I/O Read Bytes",
                                 " I/O"
                                 );
            
            DisplayTotalAndRate( SysPerfInfoStart->IoWriteTransferCount.QuadPart,
                                 SysPerfInfoStop->IoWriteTransferCount.QuadPart,
                                 (long double)(SysPerfInfoStop->IoWriteOperationCount - SysPerfInfoStart->IoWriteOperationCount),
                                 "I/O Write Bytes",
                                 " I/O"
                                 );

            DisplayTotalAndRate( SysPerfInfoStart->IoOtherTransferCount.QuadPart,
                                 SysPerfInfoStop->IoOtherTransferCount.QuadPart,
                                 (long double)(SysPerfInfoStop->IoOtherOperationCount - SysPerfInfoStart->IoOtherOperationCount),
                                 "I/O Other Bytes",
                                 " I/O"
                                 );

            
        }
        //
        // Cleanup
        //
        if(SysPerfInfoStart != NULL){
            free(SysPerfInfoStart);
            SysPerfInfoStart = NULL;
        }

        if(SysPerfInfoStop != NULL){
            free(SysPerfInfoStop);
            SysPerfInfoStop = NULL;
        }

        break;

    default:
        
            FPRINTF(stderr, "GetProfileSystemInfo was called with an invalid Action parameter - %d\n", Action);
            
    }

} //GetProfileSystemInfo()   

VOID
DisplayTotalAndRate (
        LONGLONG StartCount,
        LONGLONG StopCount,
        long double RateAgainst,
        PCHAR CounterName,
        PCHAR RateAgainstUnits
        )
{
    long double   Rate;
    LARGE_INTEGER Total;
    
    Total.QuadPart = StopCount - StartCount;
    Rate    = RateAgainst > 0? (long double)Total.QuadPart/RateAgainst : 0;
    

    FPRINTF(stdout, "    %-21s, %12I64d,         %.0f/%s\n",
            CounterName,
            Total.QuadPart,
            Rate,
            RateAgainstUnits
            );
} //DisplayTotalAndRate()

VOID
OutputStartStopValues (
        SIZE_T StartCount,
        SIZE_T StopCount,
        PCHAR CounterName
        )
{
    LARGE_INTEGER StartValue;
    LARGE_INTEGER StopValue;
    LARGE_INTEGER Diff;

    StartValue.QuadPart = StartCount;
    StopValue.QuadPart  = StopCount;

    Diff.QuadPart = StopValue.QuadPart - StartValue.QuadPart;

    FPRINTF(stdout, "    %-21s, %15I64d, %15I64d, %15I64d\n",
            CounterName,
            StartValue.QuadPart,
            StopValue.QuadPart,
            Diff.QuadPart
            );
} //OutputStartStopValues()

VOID
OutputPercentValue (
        LONGLONG StartCount,
        LONGLONG StopCount,
        LARGE_INTEGER Base,
        PCHAR CounterName
        )
{
    long double        PercentValue;
    LARGE_INTEGER      Diff;
    
    Diff.QuadPart = StopCount - StartCount;
    PercentValue = Base.QuadPart > 0? 100*(long double)Diff.QuadPart/(long double)Base.QuadPart : 0; 
    FPRINTF(stdout, "    %-28s= %.2f%% of the Elapsed Time\n",
            CounterName,
            PercentValue
            );
} //OutputPercentValue()


VOID
OutputProcessPerfInfo (
        PTASK_LIST       pTask,
        ULONG            NumTasks,
        PPROC_TO_MONITOR ProcToMonitor
        )
/*++

Routine Description:

    Gets and outputs Process-Specific performance counts (context-switches, I/O, etc.)
    for the duration of the run   
         
Arguments:

    pTask         - A pointer to Kernrate's structure of running tasks
    NumTasks      - Number of tasks in kernrate's task list
    ProcToMonitor - Pointer to the process structure

Return Value:

    None.

--*/

{
    DWORD    m, k, nThreads;
    LONGLONG Diff;

    if (pTask != NULL) {
        if (ProcToMonitor != NULL){
            
            for (m=0; m < NumTasks; m++) {

                if (pTask[m].ProcessId == ProcToMonitor->Pid) {

                    FPRINTF (stdout, "\n");
                    
    
                    OutputPercentValue( ProcToMonitor->ProcPerfInfoStart.UserTime.QuadPart,
                                        pTask[m].ProcessPerfInfo.UserTime.QuadPart,
                                        gTotal2ElapsedTime64,
                                        "User Time"
                                        );
                    
                    OutputPercentValue( ProcToMonitor->ProcPerfInfoStart.KernelTime.QuadPart,
                                        pTask[m].ProcessPerfInfo.KernelTime.QuadPart,
                                        gTotal2ElapsedTime64,
                                        "Kernel Time"
                                        );

                    FPRINTF (stdout, "\n                                  Total      Avg. Rate\n");

                    DisplayTotalAndRate( ProcToMonitor->ProcPerfInfoStart.PageFaultCount,
                                         pTask[m].ProcessPerfInfo.PageFaultCount,
                                         gldElapsedSeconds,
                                         "Page Faults",
                                         "sec."
                                         ); 

                    DisplayTotalAndRate( ProcToMonitor->ProcPerfInfoStart.ReadOperationCount.QuadPart,
                                         pTask[m].ProcessPerfInfo.ReadOperationCount.QuadPart,
                                         gldElapsedSeconds,
                                         "I/O Read Operations",
                                         "sec."
                                         ); 
                    
                    DisplayTotalAndRate( ProcToMonitor->ProcPerfInfoStart.WriteOperationCount.QuadPart,
                                         pTask[m].ProcessPerfInfo.WriteOperationCount.QuadPart,
                                         gldElapsedSeconds,
                                         "I/O Write Operations",
                                         "sec."
                                         ); 

                    DisplayTotalAndRate( ProcToMonitor->ProcPerfInfoStart.OtherOperationCount.QuadPart,
                                         pTask[m].ProcessPerfInfo.OtherOperationCount.QuadPart,
                                         gldElapsedSeconds,
                                         "I/O Other Operations",
                                         "sec."
                                         ); 

                    Diff = pTask[m].ProcessPerfInfo.ReadOperationCount.QuadPart
                           - ProcToMonitor->ProcPerfInfoStart.ReadOperationCount.QuadPart;

                    DisplayTotalAndRate( ProcToMonitor->ProcPerfInfoStart.ReadTransferCount.QuadPart,
                                         pTask[m].ProcessPerfInfo.ReadTransferCount.QuadPart,
                                         (long double)Diff,
                                         "I/O Read Bytes",
                                         " I/O"
                                         ); 
                    
                    Diff = pTask[m].ProcessPerfInfo.WriteOperationCount.QuadPart
                           - ProcToMonitor->ProcPerfInfoStart.WriteOperationCount.QuadPart;

                    DisplayTotalAndRate( ProcToMonitor->ProcPerfInfoStart.WriteTransferCount.QuadPart,
                                         pTask[m].ProcessPerfInfo.WriteTransferCount.QuadPart,
                                         (long double)Diff,
                                         "I/O Write Bytes",
                                         " I/O"
                                         ); 

                    Diff = pTask[m].ProcessPerfInfo.OtherOperationCount.QuadPart
                           - ProcToMonitor->ProcPerfInfoStart.OtherOperationCount.QuadPart;
                    
                    DisplayTotalAndRate( ProcToMonitor->ProcPerfInfoStart.OtherTransferCount.QuadPart,
                                         pTask[m].ProcessPerfInfo.OtherTransferCount.QuadPart,
                                         (long double)Diff,
                                         "I/O Other Bytes",
                                         " I/O"
                                         ); 

                    FPRINTF (stdout, "\n                               Start-Count       Stop-Count         Diff.\n");

                    OutputStartStopValues( ProcToMonitor->ProcPerfInfoStart.NumberOfThreads,
                                           pTask[m].ProcessPerfInfo.NumberOfThreads,
                                           "Threads"
                                           );

                    OutputStartStopValues( ProcToMonitor->ProcPerfInfoStart.HandleCount,
                                           pTask[m].ProcessPerfInfo.HandleCount,
                                           "Handles"
                                           );

                    OutputStartStopValues( ProcToMonitor->ProcPerfInfoStart.WorkingSetSize,
                                           pTask[m].ProcessPerfInfo.WorkingSetSize,
                                           "Working Set Bytes"
                                           );


                    OutputStartStopValues( ProcToMonitor->ProcPerfInfoStart.VirtualSize,
                                           pTask[m].ProcessPerfInfo.VirtualSize,
                                           "Virtual Size Bytes"
                                           );

                    OutputStartStopValues( ProcToMonitor->ProcPerfInfoStart.QuotaPagedPoolUsage,
                                           pTask[m].ProcessPerfInfo.QuotaPagedPoolUsage,
                                           "Paged Pool Bytes"
                                           );

                    OutputStartStopValues( ProcToMonitor->ProcPerfInfoStart.QuotaNonPagedPoolUsage,
                                           pTask[m].ProcessPerfInfo.QuotaNonPagedPoolUsage,
                                           "Non Paged Pool Bytes"
                                           );

                    OutputStartStopValues( ProcToMonitor->ProcPerfInfoStart.PagefileUsage,
                                           pTask[m].ProcessPerfInfo.PagefileUsage,
                                           "Pagefile Bytes"
                                           );

                    OutputStartStopValues( ProcToMonitor->ProcPerfInfoStart.PrivatePageCount,
                                           pTask[m].ProcessPerfInfo.PrivatePageCount,
                                           "Private Pages Bytes"
                                           );

                    if ( ProcToMonitor->pProcThreadInfoStart != NULL ){
                        OutputThreadInfo (pTask,
                                          m,
                                          ProcToMonitor
                                          );
                    }
                    return;
                }
            }
            
            FPRINTF(stdout, "\nGeneral Info Unavailable for Process %s (PID= %I64d), because the process is GONE\n",
                            ProcToMonitor->ProcessName,
                            ProcToMonitor->Pid
                            );  

        } else {
            FPRINTF(stderr, "Kernrate: OuputProcessPerfInfo - ProcToMonitor is NULL\n"); 
        }

    } else {
        FPRINTF(stderr, "Kernrate: OuputProcessPerfInfo - pTask is NULL\n"); 
    }

} //OutputProcessPerfInfo()

VOID
OutputThreadInfo (
        PTASK_LIST       pTask,
        DWORD            TaskNumber,
        PPROC_TO_MONITOR ProcToMonitor
        )
/*++

Routine Description:

    Outputs Thread-Specific counts for a given process 
         
Arguments:

    pTask         - A pointer to Kernrate's structure of running tasks
    TaskNumber    - The task index in kernrate's task list
    ProcToMonitor - Pointer to the process structure

Return Value:

    None.

--*/

{
    DWORD    m, k, nThreads;
    LONGLONG Diff;
    BOOL     bFound;
    BOOL    *Index          = NULL;

    m = TaskNumber;

    if( ProcToMonitor->ProcPerfInfoStart.NumberOfThreads > 0 ){
        Index = (BOOL*)calloc(ProcToMonitor->ProcPerfInfoStart.NumberOfThreads, sizeof(BOOL));
        if( Index == NULL ){
            FPRINTF(stderr, "KERNRATE: Failed to allocate memory for Index data in OutputThreadInfo\n");
            exit(1);
        }
    }else{
        FPRINTF(stderr, "KERNRATE: No Threads for process %I64d at START???\n", ProcToMonitor->Pid);
        return;
    }

    FPRINTF(stdout, "\n------------- Thread Information ---------------\n");
    FPRINTF (stdout, "\n                               Start-Count       Stop-Count         Diff.\n");

    nThreads = pTask[m].ProcessPerfInfo.NumberOfThreads;
    while(nThreads--){
        k = ProcToMonitor->ProcPerfInfoStart.NumberOfThreads;
        bFound = FALSE;
        while( k-- ){
            if( pTask[m].pProcessThreadInfo[nThreads].ClientId.UniqueThread
                == ProcToMonitor->pProcThreadInfoStart[k].ClientId.UniqueThread){

                PMODULE module = FindModuleForAddress64(ProcToMonitor, (DWORD64)ProcToMonitor->pProcThreadInfoStart[k].StartAddress);
                FPRINTF(stdout, "\nPid= %I64d, Tid= %I64d,  StartAddr= 0x%p",
                                (DWORD64)(DWORD64 *)ProcToMonitor->pProcThreadInfoStart[k].ClientId.UniqueProcess,
                                (DWORD64)(DWORD64 *)ProcToMonitor->pProcThreadInfoStart[k].ClientId.UniqueThread,
                                ProcToMonitor->pProcThreadInfoStart[k].StartAddress
                                );

                if(module != NULL){
                    FPRINTF(stdout, " (%s)\n", module->module_Name);
                }else{
                    FPRINTF(stdout, " (unknown module)\n");
                }
                
                FPRINTF(stdout, "    Thread State         , %15s, %15s\n",
                                ThreadState[ProcToMonitor->pProcThreadInfoStart[k].ThreadState],
                                ThreadState[pTask[m].pProcessThreadInfo[nThreads].ThreadState]
                                );

                FPRINTF(stdout, "    Wait Reason          , %15s, %15s\n",
                                WaitReason[ProcToMonitor->pProcThreadInfoStart[k].WaitReason],
                                WaitReason[pTask[m].pProcessThreadInfo[nThreads].WaitReason]
                                );

                OutputStartStopValues( ProcToMonitor->pProcThreadInfoStart[k].WaitTime,
                                       pTask[m].pProcessThreadInfo[nThreads].WaitTime,
                                       "Wait Time [.1 uSec]"
                                       );

                FPRINTF(stdout, "    Base Priority        , %15d, %15d\n",
                                ProcToMonitor->pProcThreadInfoStart[k].BasePriority,
                                pTask[m].pProcessThreadInfo[nThreads].BasePriority
                                );

                FPRINTF(stdout, "    Priority             , %15d, %15d\n",
                                ProcToMonitor->pProcThreadInfoStart[k].Priority,
                                pTask[m].pProcessThreadInfo[nThreads].Priority
                                );
        
                OutputStartStopValues( ProcToMonitor->pProcThreadInfoStart[k].ContextSwitches,
                                       pTask[m].pProcessThreadInfo[nThreads].ContextSwitches,
                                       "Context Switches"
                                       );

                Diff = pTask[m].pProcessThreadInfo[nThreads].ContextSwitches
                       - ProcToMonitor->pProcThreadInfoStart[k].ContextSwitches;
                    
                DisplayTotalAndRate( ProcToMonitor->pProcThreadInfoStart[k].ContextSwitches,
                                     pTask[m].pProcessThreadInfo[nThreads].ContextSwitches,
                                     gldElapsedSeconds,
                                     "Context Switches",
                                     "sec."
                                     ); 

                FPRINTF(stdout, "\n");

                OutputPercentValue( ProcToMonitor->pProcThreadInfoStart[k].UserTime.QuadPart,
                                    pTask[m].pProcessThreadInfo[nThreads].UserTime.QuadPart,
                                    gTotal2ElapsedTime64,
                                    "User Time"
                                    );
                    
                OutputPercentValue( ProcToMonitor->pProcThreadInfoStart[k].KernelTime.QuadPart,
                                    pTask[m].pProcessThreadInfo[nThreads].KernelTime.QuadPart,
                                    gTotal2ElapsedTime64,
                                    "Kernel Time"
                                    );
                Index[k] = TRUE;
                bFound = TRUE;
                break;
            }
        }
        if(!bFound){ // This is a new thread

                PMODULE module = FindModuleForAddress64(ProcToMonitor, (DWORD64)pTask[m].pProcessThreadInfo[nThreads].StartAddress);

                FPRINTF(stdout, "\nPid= %I64d, Tid= %I64d,  StartAddr= 0x%p",
                                (DWORD64)(DWORD64 *)pTask[m].pProcessThreadInfo[nThreads].ClientId.UniqueProcess,
                                (DWORD64)(DWORD64 *)pTask[m].pProcessThreadInfo[nThreads].ClientId.UniqueThread,
                                pTask[m].pProcessThreadInfo[nThreads].StartAddress
                                );

                if(module != NULL){
                    FPRINTF(stdout, " (%s)                   --->(NEW)\n", module->module_Name);
                }else{
                    FPRINTF(stdout, " (unknown module)       --->(NEW)\n");
                }

                FPRINTF(stdout, "    Thread State         , %15s\n",
                                ThreadState[pTask[m].pProcessThreadInfo[nThreads].ThreadState]
                                );

                FPRINTF(stdout, "    Wait Reason          , %15s\n",
                                WaitReason[pTask[m].pProcessThreadInfo[nThreads].WaitReason]
                                );

                OutputStartStopValues( 0,
                                       pTask[m].pProcessThreadInfo[nThreads].WaitTime,
                                       "Wait Time [.1 uSec]"
                                       );

                FPRINTF(stdout, "    Base Priority        , %15d\n",
                                pTask[m].pProcessThreadInfo[nThreads].BasePriority
                                );

                FPRINTF(stdout, "    Priority             , %15d\n",
                                pTask[m].pProcessThreadInfo[nThreads].Priority
                                );
        
                OutputStartStopValues( 0,
                                       pTask[m].pProcessThreadInfo[nThreads].ContextSwitches,
                                       "Context Switches"
                                       );

                Diff = pTask[m].pProcessThreadInfo[nThreads].ContextSwitches;
                    
                DisplayTotalAndRate( 0,
                                     pTask[m].pProcessThreadInfo[nThreads].ContextSwitches,
                                     gldElapsedSeconds,
                                     "Context Switches",
                                     "sec."
                                     ); 

                FPRINTF(stdout, "\n");

                OutputPercentValue( 0,
                                    pTask[m].pProcessThreadInfo[nThreads].UserTime.QuadPart,
                                    gTotal2ElapsedTime64,
                                    "User Time"
                                    );
                    
                OutputPercentValue( 0,
                                    pTask[m].pProcessThreadInfo[nThreads].KernelTime.QuadPart,
                                    gTotal2ElapsedTime64,
                                    "Kernel Time"
                                    );
             
        }    
    }
    //
    // Anything beyond this is a thread that is already GONE
    //
    k = ProcToMonitor->ProcPerfInfoStart.NumberOfThreads;
    while (k--){
        if(Index[k] == FALSE){

            PMODULE module = FindModuleForAddress64(ProcToMonitor, (DWORD64)ProcToMonitor->pProcThreadInfoStart[k].StartAddress);

            FPRINTF(stdout, "\nPid= %I64d, Tid= %I64d,  StartAddr= 0x%p",
                            (DWORD64)(DWORD64 *)ProcToMonitor->pProcThreadInfoStart[k].ClientId.UniqueProcess,
                            (DWORD64)(DWORD64 *)ProcToMonitor->pProcThreadInfoStart[k].ClientId.UniqueThread,
                            ProcToMonitor->pProcThreadInfoStart[k].StartAddress
                            );
            if(module != NULL){
                FPRINTF(stdout, " (%s)                       --->(GONE)\n", module->module_Name);
            }else{
                FPRINTF(stdout, " (unknown module)           --->(GONE)\n");
            }

        }
    }
    if(Index != NULL){
        free(Index);
        Index = NULL;
    }
}//OutputThreadInfo()

VOID
DisplayRunningTasksSummary (
        PTASK_LIST pTaskStart,
        PTASK_LIST pTaskStop
        )
/*++

Routine Description:

    Displays a summary of all processes running at the start and at the end of Kernrate's run
    and their average CPU utilization.
    Processes that existed at the start count but not at the end count will be marked as "GONE".
    Processes that exist at the end count but not at the start count will be marked as "NEW".
    The list will miss short-lived processes that were created after the start count but went away before the end count.

         
Arguments:

    pTaskStart    - Pointer to the task list taken at the start
    pTaskStart    -    Pointer to the task list taken at the end

Return Value:

    None.

--*/

{   

    ULONG  i, j;
    BOOL   bFound;
    
    BOOL *Index        = (BOOL *)calloc(gNumTasksStart, sizeof(BOOL));

    if ( Index == NULL ){
        FPRINTF(stderr, "KERNRATE: Failed to allocate memory for Index in DisplayRunningTasksSummary\n");
        exit(1);
    }
    FPRINTF(stdout, "Found %u processes at the start point, %u processes at the stop point\n",
                    gNumTasksStart,
                    gNumTasksStop
                    );
    FPRINTF(stdout, "Percentage in the following table is based on the Elapsed Time\n"); 

    FPRINTF(stdout, "\n    ProcessID, Process Name,                     Kernel Time,   User-Mode Time,   Idle Time\n\n");

    for (i=0; i < gNumTasksStop; i++) {

        bFound = FALSE;
        for (j=0; j < gNumTasksStart; j++) {
        
            if ( pTaskStop[i].ProcessId == pTaskStart[j].ProcessId ) {
                
                long double UserPercentValue;
                long double KernelPercentValue;
                LARGE_INTEGER Diff;

                Diff.QuadPart = pTaskStop[i].ProcessPerfInfo.KernelTime.QuadPart - 
                                           pTaskStart[j].ProcessPerfInfo.KernelTime.QuadPart;
                
                KernelPercentValue = gTotalElapsedSeconds > 0? 100*(long double)Diff.QuadPart/(long double)gTotal2ElapsedTime64.QuadPart : 0; 

                Diff.QuadPart = pTaskStop[i].ProcessPerfInfo.UserTime.QuadPart - 
                                        pTaskStart[j].ProcessPerfInfo.UserTime.QuadPart;

                UserPercentValue = gTotalElapsedSeconds > 0? 100*(long double)Diff.QuadPart/(long double)gTotal2ElapsedTime64.QuadPart : 0; 
            
                // Additional Perf Data can be added if needed

                if(    pTaskStop[i].ProcessId != 0 ) {

                    FPRINTF(stdout, "%12I64d, %32s, %10.2f%%, %10.2f%%\n",
                                    pTaskStop[i].ProcessId,
                                    pTaskStop[i].ProcessName,
                                    KernelPercentValue,
                                    UserPercentValue
                                    );
                } else {                                                 // This is the System Idle Process

                    FPRINTF(stdout, "%12I64d, %32s, %10.2f%%, %10.2f%%,         ~%6.2f%%\n",
                                    pTaskStop[i].ProcessId,
                                    pTaskStop[i].ProcessName,
                                    KernelPercentValue,
                                    0.00,
                                    KernelPercentValue
                                    );
                }

                bFound = TRUE;
                Index[j] = TRUE;
                break;
            }
        }

        //
        // No match found in the START list, therefore this is a NEW process
        //
        if( !bFound ) {

                long double UserPercentValue;
                long double KernelPercentValue;
                LARGE_INTEGER Diff;

                Diff.QuadPart = pTaskStop[i].ProcessPerfInfo.KernelTime.QuadPart;
                
                KernelPercentValue = gTotalElapsedSeconds > 0? 100*(long double)Diff.QuadPart/(long double)gTotal2ElapsedTime64.QuadPart : 0; 

                Diff.QuadPart = pTaskStop[i].ProcessPerfInfo.UserTime.QuadPart;

                UserPercentValue = gTotalElapsedSeconds > 0? 100*(long double)Diff.QuadPart/(long double)gTotal2ElapsedTime64.QuadPart : 0; 
                
                FPRINTF(stdout, "%12I64d, %32s, %10.2f%%, %10.2f%%, NEW\n",
                                pTaskStop[i].ProcessId,
                                pTaskStop[i].ProcessName,
                                KernelPercentValue,
                                UserPercentValue
                                );
                               
        }

    }//for(i)

    //
    // No match found in the STOP list, therefore this process is GONE
    //
    for (j=0; j < gNumTasksStart; j++){

        if( Index[j] == FALSE ) {
                
            FPRINTF(stdout, "%12I64d, %32s, GONE\n",
                            pTaskStart[j].ProcessId,
                            pTaskStart[j].ProcessName
                            );
        }
    }
    //
    // cleanup
    //
    if(Index != NULL){
        free(Index);
        Index = NULL;
    }
       
} //DisplayRunningTasksSummary()
                   
PMODULE
FindModuleForAddress64(    
        PPROC_TO_MONITOR ProcToMonitor,
        DWORD64          Address
        )
{
    PMODULE Module = ProcToMonitor->ModuleList;
    
    while( Module != NULL ) {
        if( ( (PVOID)Address >= (PVOID)Module->Base) && ( (PVOID)Address < (PVOID)(Module->Base + (ULONG64)Module->Length) ) ){
            return (Module);
        }
        Module = Module->Next;
    }
    
    return (NULL);

} //FindModuleForAddress64()
    

VOID
OutputLineFromAddress64(
        HANDLE           hProc,
        DWORD64          qwAddr,
        PIMAGEHLP_LINE64 pLine
        )
/*++

Routine Description:

    Gets source-code line number and file information for a given address
    and outputs the data
         
Arguments:

    hProc         - Imagehlp Handle to the process
    qwAddr        -    Address for which we need the source code line information
    pLine         - Pointer to a user allocated IMAGEHLP_LINE64 struct 

Return Value:

    None.

Notes:

    If successful, the data returned in pLine includes the source-code line number,
    the full path to the source file, the displacement (not used here) and the address 
    where the first instruction is encountered in the line.
    
    If unsuccessful, nothing is printed. In most cases this is due to an unmatching
    symbol file or a supplied address that does not contain code instructions.
    This can also happen if the pdb file does not contain source line information.
       
--*/

{
    DWORD dwDisplacement = 0;
    if ( SymGetLineFromAddr64( hProc, qwAddr, &dwDisplacement, pLine) ){
                              FPRINTF(stdout, " (line %ld in %s, 0x%I64x)",
                                              pLine->LineNumber,
                                              pLine->FileName,
                                              pLine->Address
                                              );
    }

}//OutputLineFromAddress64

//MC

BOOL
InitializeManagedCodeSupport(
     PPROC_TO_MONITOR   ProcToMonitor
     )
/*++

Routine Description:

    If the main LKR library (mscoree.dll) is loaded, load the managed code helper (ip2md.dll) unless it's already loaded
    and get pointers to its main function calls. If successful, get the JIT ranges for the current process.
    If no JIT ranges are identified - return failure, but don't unload the helper library yet in case another process
    needs it.
              
Arguments:

    ProcToMonitor - Pointer to the structure of the process being monitored

Return Value:

    TRUE for success, FALSE for Failure 

--*/

{

    BOOL   bRet         = FALSE;

// Managed code (CLR) currently not supported on IA64 - just return FALSE on initialization attempt

#if defined(_X86_)

    int    i,j;

    if( bMCHelperLoaded != TRUE ){
                
        VerbosePrint((VERBOSE_INTERNALS, "KERNRATE: Found mscoree.dll, loading ip2md.dll Managed code helper\n")); 

        ghMCLib = LoadLibrary( MANAGED_CODE_SYMHLPLIB );
            
        if(ghMCLib == NULL){
            VerbosePrint((VERBOSE_INTERNALS, "KERNRATE: Failed to load Managed Code helper library (ip2md.dll)\n"));
        }else{
            bMCHelperLoaded      = TRUE;
            VerbosePrint((VERBOSE_INTERNALS, "KERNRATE: Succsessfully loaded ip2md.dll Managed code helper\n")); 

            pfnAttachToProcess   = (PFN1)GetProcAddress(ghMCLib, "AttachToProcess");
            if(!pfnAttachToProcess){
                VerbosePrint((VERBOSE_INTERNALS, "KERNRATE: Failed to get proc address for pfnAttachToProcess from ip2md.dll\n"));
                bMCHelperLoaded      = FALSE;
            }
            pfnDetachFromProcess = (PFN2)GetProcAddress(ghMCLib, "DetachFromProcess");
            if(!pfnDetachFromProcess){
                VerbosePrint((VERBOSE_INTERNALS, "KERNRATE: Failed to get proc address for pfnDetachFromProcess from ip2md.dll\n"));
                bMCHelperLoaded      = FALSE;
            }
            pfnIP2MD             = (PFN3)GetProcAddress(ghMCLib, "IP2MD");
            if(!pfnIP2MD){
                VerbosePrint((VERBOSE_INTERNALS, "KERNRATE: Failed to get proc address for pfnIP2MD from ip2md.dll\n"));
                bMCHelperLoaded      = FALSE;
            }
            pfnGetJitRange       = (PFN4)GetProcAddress(ghMCLib, "GetJitRange");
            if(!pfnGetJitRange){
                VerbosePrint((VERBOSE_INTERNALS, "KERNRATE: Failed to get proc address for pfnGetJitRange from ip2md.dll\n"));
                bMCHelperLoaded      = FALSE;
            }
            if( bMCHelperLoaded == FALSE && ghMCLib != NULL){
                FreeLibrary(ghMCLib);
                ghMCLib = NULL;
            }
        }
    }
    
    if( bMCHelperLoaded == TRUE ){ 
        //
        //Initialization will be considered successful at this point even if there are no JIT ranges
        //We'll keep the helper library loaded because there may be some Pre-Generated modules loaded as modules in the process
        //
        bRet = TRUE;
                
        VerbosePrint((VERBOSE_INTERNALS, "KERNRATE: Attaching to Process %I64d to get JIT ranges\n", ProcToMonitor->Pid)); 

        pfnAttachToProcess( (DWORD)ProcToMonitor->Pid ); 
        ProcToMonitor->JITHeapLocationsStart = pfnGetJitRange(); 

        if( ProcToMonitor->JITHeapLocationsStart == NULL){
            VerbosePrint((VERBOSE_INTERNALS,
                          "KERNRATE: No JIT heap locations returned for Pid= %I64d, detaching from process\n",
                          ProcToMonitor->Pid
                          ));

        } else {

            if(gVerbose & VERBOSE_INTERNALS){
                FPRINTF(stderr, "KERNRATE: Identified JIT ranges (Name, BaseAddr, Length:\n");
                i = 0;
                j = 0;
                while( ProcToMonitor->JITHeapLocationsStart[i] != 0 ){
                    FPRINTF(stderr, "JIT%d, 0x%lx, %ld\n",
                                    j,
                                    ProcToMonitor->JITHeapLocationsStart[i],
                                    ProcToMonitor->JITHeapLocationsStart[i+1]
                                    );
                    i+=2;
                    j+=1;
                }
            }
            
            bMCJitRangesExist = TRUE;
        }
               
        pfnDetachFromProcess();

    }
    
#endif //defined(_X86_)

    return (bRet);

} //InitializeManagedCodeSupport()

VOID
OutputJITRangeComparison(
     PPROC_TO_MONITOR   ProcToMonitor
     )
/*++

Routine Description:

    Compares the lists of a process JIT ranges before and after the profiling. 
    The list will miss short-lived JIT ranges that were created after the start count but went away before the end count.
         
Arguments:

    ProcToMonitor - Pointer to the structure of the process being monitored

Return Value:

    None.

--*/

{
    ULONG  i,j, jcount;
    BOOL   bFound;
    BOOL  *index;
    
    
    // We already checked if ProcToMonitor->JITHeapLocationsStart != NULL before calling

    jcount = 0;
    
    if(    ProcToMonitor->JITHeapLocationsStop != NULL){
        while (    ProcToMonitor->JITHeapLocationsStop[jcount] ){
            jcount += 2;
        }
    }
    
    index = (BOOL *)calloc( jcount, sizeof(BOOL) );
    if( index == NULL ){
        FPRINTF(stderr, "KERNRATE: Failed to allocate memory for index array in OutputJITRangeComparison\n");
        return;
    }
     
    i = 0;

    FPRINTF(stdout, "\n---------------------- JIT RANGES STATUS AFTER DATA PROCESSING ------------------------\n\n");

    FPRINTF(stdout, "   Base-Address,    Size,         Status   \n");
         
    while ( ProcToMonitor->JITHeapLocationsStart[i] ){
        
        j = 0;
        bFound = FALSE;
        
        if(ProcToMonitor->JITHeapLocationsStop != NULL){
            while (    ProcToMonitor->JITHeapLocationsStop[j] ){
                if( (ProcToMonitor->JITHeapLocationsStart[i] == ProcToMonitor->JITHeapLocationsStop[j]) &&
                     (ProcToMonitor->JITHeapLocationsStart[i+1] == ProcToMonitor->JITHeapLocationsStop[j+1]) ){
                 
                         FPRINTF(stdout, "0x%lx %12ld EXISTS\n",
                                          ProcToMonitor->JITHeapLocationsStart[i],
                                          ProcToMonitor->JITHeapLocationsStart[i+1]
                                         );
                         bFound = TRUE;
                         index[j] = TRUE;
                         break;
                }else{
                    j += 2;
                }
            }
        }

        if(!bFound){
                     FPRINTF(stdout, "0x%lx %12ld GONE\n",
                                     ProcToMonitor->JITHeapLocationsStart[i],
                                     ProcToMonitor->JITHeapLocationsStart[i+1]
                                     );
        }
    
        i += 2;
    }            

    if( ProcToMonitor->JITHeapLocationsStop != NULL){
        j = 0;
        while (    ProcToMonitor->JITHeapLocationsStop[j] ){
            if( index[j] == FALSE ){
                         FPRINTF(stdout, "0x%lx %12ld NEW\n",
                                         ProcToMonitor->JITHeapLocationsStop[j],
                                         ProcToMonitor->JITHeapLocationsStop[j+1]
                                         );
            }
            j += 2;
        }
    
    }
    
    if( index != NULL ){
        free(index);
        index = NULL;
    }

    FPRINTF(stdout, "\n-----------------------------------------------------------\n\n");

} //OutputJITRangeComparison()

//MC

VOID
OutputRawDataForZoomModule(
    IN FILE *Out,
    IN PPROC_TO_MONITOR ProcToMonitor,
    IN PMODULE Current
    )
/*++

Routine Description:

    Outputs raw profile data for every bucket in a zoom module
              
Arguments:

    Out           - Supplies the file pointer to output to.
    ProcToMonitor -    Pointer to the struct of the current process.
    Current       - Pointer to the current zoom module struct. 

Return Value:

    None.

Notes:

    The routine will also try to find other sharers of the same bucket
    If the routine fails to find a symbol for an address it will try
    to find a Managed Code JIT method at that address, provided that
    proper Managed Code support exists
               
--*/

{
    PRATE_DATA RateData;
    LONG       CpuNumber;
    ULONG      i, ProfileSourceIndex, Index;
//MC
    ULONGLONG  TempTotal, TotCount, TotUnknownSymbolCount, TotJITCount, TotPreJITCount;
//MC                
    CHAR       LastSymbol[cMODULE_NAME_STRLEN];
    HANDLE     SymHandle                       = ProcToMonitor->ProcessHandle;
    BOOL       bLastSymbolExists;
    BOOL       bAttachedToProcess              = FALSE;

    BOOL       bPrintLastTotal                 = FALSE;
    BOOL       bPrintJITLastTotal              = FALSE;
    BOOL       bPrintPREJITLastTotal           = FALSE;

    PIMAGEHLP_LINE64 pLine = malloc(sizeof(IMAGEHLP_LINE64));
    if (pLine == NULL) {
        FPRINTF(stderr, "KERNRATE: Buffer allocation failed for pLine in OutputResults\n");
        exit(1);
    }
    pLine->SizeOfStruct = sizeof(IMAGEHLP_LINE64);

    for (Index=0; Index < gTotalActiveSources; Index++) {
        ProfileSourceIndex = gulActiveSources[Index];

        FPRINTF(Out,
                "\n---- RAW %s Profile: Source= %s, Module Base= 0x%I64x\n",
                Current->module_Name,
                ProcToMonitor->Source[ProfileSourceIndex].Name,
                Current->Base
                );

        FPRINTF(Out, "Function Name+Displacement[Address], Bucket Number, Total Bucket Hits");
        if (bProfileByProcessor) {
            FPRINTF(Out, ", Hits on Processor(s)");
            for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                 if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;
                 FPRINTF(Out," %2d,", CpuNumber);
            }
        }
        FPRINTF(Out, " Source-Line,  Source-File,  Addr. of First Instruction\n\n");

        TotCount = 0;
        TotUnknownSymbolCount = 0;
//MC
        TotJITCount = 0;
        TotPreJITCount = 0;
//MC
        bLastSymbolExists = FALSE;
                        
        RateData = &Current->Rate[ProfileSourceIndex];
        for (i=0; i < BUCKETS_NEEDED(Current->Length) ; i++) {
            TempTotal = 0;
            for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                 TempTotal += RateData->ProfileBuffer[CpuNumber][i];
            }

            if ( TempTotal > 0 ) {

                // TF - FIXFIX - 07/2000.
                // The current version of kernrate and kernel profiling objects code 
                // assume code section < 4GB.
                //

                ULONG64 ip = Current->Base + (ULONG64)(i * gZoomBucket);
                ULONG64 disp = 0;

                if ( !SymGetSymFromAddr64(SymHandle, ip, &disp, gSymbol ) ) {
//MC
                    //
                    // No Symbol, Let's check if this is a managed code address
                    //

                    int Retval = 0;
                    ULONG64 ipMax = ip + (ULONG64)gZoomBucket;

                    if( bMCHelperLoaded == TRUE) {
                                    
                        if( !bAttachedToProcess ){
                            pfnAttachToProcess((DWORD)ProcToMonitor->Pid);
                            bAttachedToProcess = TRUE;
                        }
                        //
                        // Try to find a Managed Code symbol anywhere in the bucket
                        //
                        while (Retval == 0 && ip < ipMax){
                            Retval = pfnIP2MD((DWORD_PTR)ip, &gwszSymbol);
                            ip += 1;
                            if( Retval > 0 && gwszSymbol == NULL ){
                                Retval = 0;
                                continue;
                            }
                        }
                                        
                        if( Retval > 0 && gwszSymbol != NULL ){ 

                            if( Retval == 1 ){
                                            
                                FPRINTF(Out, "%S[0x%I64x], %10Ld, %10Ld, JIT_TYPE",
                                             gwszSymbol,
                                             ip,
                                             i,
                                             TempTotal
                                             );

                                TotJITCount += TempTotal;
                            }
                            else if(Retval == 2){

                                FPRINTF(Out, "%S[0x%I64x], %10Ld, %10Ld, PRE-JITTED_TYPE",
                                             gwszSymbol,
                                             ip,
                                             i,
                                             TempTotal
                                             );

                                TotPreJITCount += TempTotal;
                            }
                        }
                        //
                        // Print other symbols in this bucket by incrementing
                        // by 2 bytes at a time. Note that we start from the ip reached above
                        // so the loop below may not get executed at all
                        //  

                        ip    += (ULONG64)2;
                        bPrintJITLastTotal = TRUE;
                        bPrintPREJITLastTotal = TRUE;

                        while( ip < ipMax ) {

                            WCHAR lastSym[cMODULE_NAME_STRLEN] = L"";
                            int retv = 0;
                                            
                            if(gwszSymbol != NULL){ 
                                wcsncpy( lastSym, gwszSymbol, cMODULE_NAME_STRLEN-1 );
                                _wcsset(&lastSym[ cMODULE_NAME_STRLEN-1 ], L'\0');
                            }
                                            
                            retv = pfnIP2MD( (DWORD_PTR)ip, &gwszSymbol );
                                            
                            if ( retv > 0 && gwszSymbol != NULL ) {
                                                
                                if ( wcscmp( lastSym, gwszSymbol ) ) {
                                                
                                    if(retv == 1){
                                        FPRINTF(Out, "JIT Module Total Count = %Ld\n\n", TotJITCount); 
                                        TotJITCount = 0;
                                    }
                                    else if(retv == 2){
                                        FPRINTF(Out, "PRE-JITTED Module Total Count = %Ld\n\n", TotPreJITCount); 
                                        TotPreJITCount = 0;
                                    }

                                    FPRINTF( Out, "    %S[0x%I64x]\n", gwszSymbol, ip );
                                                
                                    wcsncpy( lastSym, gwszSymbol , cMODULE_NAME_STRLEN-1);
                                    _wcsset( &lastSym[ cMODULE_NAME_STRLEN-1 ], L'\0');
                                    bPrintJITLastTotal = FALSE;
                                    bPrintPREJITLastTotal = FALSE;
                                }
                            }
                            ip += (ULONG64)2;

                        } // End of while( ip < ipMax )

                    } // if( bMCHelperLoaded )
//MC
                    //
                    // No Symbol and no managed code symbol    found
                    //
                    if(!Retval){
                        FPRINTF(Out, "Unknown_Symbol+0x%I64x[0x%I64x], %10Ld, %10Ld",
                                     disp,
                                     ip,
                                     i,
                                     TempTotal
                                     ); 
                                      
                        TotUnknownSymbolCount += TempTotal;
                    }

                    if (bProfileByProcessor) {
                        for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                            if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;
                            FPRINTF( Out,", %10Ld",
                                         RateData->ProfileBuffer[CpuNumber][i]
                                         );
                        }
                    }
                    FPRINTF(Out,"\n"); 
                                    
                } 
                else {

                    CHAR symName[cMODULE_NAME_STRLEN];
                    ULONG64 ipMax;

                    if (i > 0 && strcmp( LastSymbol, gSymbol->Name ) ) {
                         if ( bLastSymbolExists )
                             FPRINTF(Out, "Module Total Count = %Ld\n\n", TotCount); 
                         TotCount = 0;
                         strncpy(LastSymbol, gSymbol->Name, cMODULE_NAME_STRLEN-1);
                         LastSymbol[ cMODULE_NAME_STRLEN-1 ] = '\0';  
                         bLastSymbolExists = TRUE;
                    }
                    TotCount += TempTotal;

                    _snprintf( symName, cMODULE_NAME_STRLEN*sizeof(CHAR)-1, "%s+0x%I64x[0x%I64x]", gSymbol->Name, disp, ip );
                    symName[cMODULE_NAME_STRLEN-1] = '\0';

                    if ( bRawDisasm )   {
                        CHAR sourceCode[528];
#ifndef DISASM_AVAILABLE
// Thierry - FIXFIX - 07/2000.
// dbg is not helping... The old disassembly APIs no longer work.
// I have to re-write a full disassembly wrapper.
#define Disasm( IpAddr, Buffer, Flag ) 0
#endif // !DISASM_AVAILABLE
                        if ( Disasm( &ip, sourceCode, FALSE ) ) {
                            FPRINTF( Out,"%-40s, %10Ld, %10Ld, %s",
                                         symName,
                                         i,
                                         TempTotal,
                                         sourceCode
                                         );
                                           
                            if (bProfileByProcessor) {
                                for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                                    if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;
                                    FPRINTF( Out,", %10Ld",
                                                 RateData->ProfileBuffer[CpuNumber][i]
                                                 );
                                }
                            }
                            FPRINTF(Out,"\n"); 
                        }
                        else {
                            FPRINTF( Out,"%-40s, %10Ld, %10Ld<disasm:?????>",
                                         symName,
                                         i,
                                         TempTotal
                                         );

                            if (bProfileByProcessor) {
                                for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                                    if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;
                                    FPRINTF( Out,", %10Ld",
                                                 RateData->ProfileBuffer[CpuNumber][i]
                                                 );
                                }
                            }
                            FPRINTF(Out,"\n"); 
                        }

                    }
                    else {
                        FPRINTF( Out,"%-40s, %10Ld, %10Ld",
                                     symName,
                                     i,
                                     TempTotal
                                     );

                        if (bProfileByProcessor) {
                            for (CpuNumber=0; CpuNumber < gProfileProcessors; CpuNumber++) {
                                if( gAffinityMask && !((1<<CpuNumber) & gAffinityMask) )continue;
                                FPRINTF( Out,", %10Ld",
                                             RateData->ProfileBuffer[CpuNumber][i]
                                             );
                            }
                        }

                        OutputLineFromAddress64( SymHandle, ip, pLine);
                                      
                        FPRINTF(Out,"\n"); 
                    } //if(bRawDisasm)
                                    
                    //
                    // Print other symbols in this bucket by incrementing
                    // by 2 bytes at a time.
                    //

                    ipMax  = ip + (ULONG64)gZoomBucket;
                    ip    += (ULONG64)2;
                    bPrintLastTotal = TRUE;
                    while( ip < ipMax ) {

                        CHAR lastSym[cMODULE_NAME_STRLEN];

                        strncpy( lastSym, gSymbol->Name, cMODULE_NAME_STRLEN-1 );
                        lastSym[ cMODULE_NAME_STRLEN-1 ] = '\0';

                        if ( SymGetSymFromAddr64(SymHandle, ip, &disp , gSymbol ) ) {
                            if ( strcmp( lastSym, gSymbol->Name ) ) {
                                                
                                FPRINTF(Out, "Module Total Count = %Ld\n\n", TotCount); 
                                TotCount = 0;

                                FPRINTF( Out, "    %s+0x%I64x[0x%I64x] ", gSymbol->Name, disp, ip );
                                                
                                OutputLineFromAddress64( SymHandle, ip, pLine);

                                FPRINTF(stdout, "\n");
                                strncpy( lastSym, gSymbol->Name , cMODULE_NAME_STRLEN-1);
                                lastSym[ cMODULE_NAME_STRLEN-1 ] = '\0';
                                bPrintLastTotal = FALSE;
                            }
                        }
                        ip += (ULONG64)2;

                    } // End of while( ip < ipMax )
                                
                } //If(SymGetSymFromAddr64)
                            
            } //if(TempTotal > 0)
                        
        } // i bucket loop 
//MC                        
        if ( bPrintLastTotal == TRUE )
            FPRINTF(Out, "Module Total Count (not including JIT, PRE-JIT and Unknown) = %Ld\n\n", TotCount); 
        if ( TotUnknownSymbolCount > 0 )
            FPRINTF(Out, "Module Total Count For Unknown Symbols = %Ld\n\n", TotUnknownSymbolCount);
        if( (TotJITCount > 0) && (bPrintJITLastTotal == TRUE) )
            FPRINTF(Out, "Module Total Count For JIT type = %Ld\n\n", TotJITCount);
        if( (TotPreJITCount > 0) && (bPrintPREJITLastTotal == TRUE) )
            FPRINTF(Out, "Module Total Count For PRE-JITTED type = %Ld\n\n", TotPreJITCount);

//MC                    
                
    } // Sources loop
            
    if( pLine != NULL ){
        free(pLine);
        pLine = NULL;
    }

}//OutputRawDataForZoomModule()


PSYSTEM_BASIC_INFORMATION
GetSystemBasicInformation(
    VOID
    )
{
    NTSTATUS                  status;
    PSYSTEM_BASIC_INFORMATION SystemInformation = NULL;
    
    SystemInformation = malloc(sizeof(SYSTEM_BASIC_INFORMATION));

    if(SystemInformation == NULL){
            FPRINTF(stderr, "Buffer allocation failed for SystemInformation in GetSystemBasicInformation\n");
            exit(1);
    }

    status = NtQuerySystemInformation(SystemBasicInformation,
                                      SystemInformation,
                                      sizeof(SYSTEM_BASIC_INFORMATION),
                                      NULL);
    if (!NT_SUCCESS(status)) {
        FPRINTF(stderr, "NtQuerySystemInformation failed status %08lx\n",status);
        if ( SystemInformation != NULL ){
            free( SystemInformation );
            SystemInformation = NULL;
        } 
    }

    return (SystemInformation);
}
    
VOID
InitializeKernrate(
    int argc,
    char *argv[]
    )
{

    ULONG j;
    BOOL  OSCompat = FALSE;

    gOSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;
    GetVersionEx(&gOSInfo);
    if ( gOSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ){
        if ( gOSInfo.dwMajorVersion >= 5 ){
            OSCompat = TRUE;
        }
    }
    if ( OSCompat == FALSE ){
        FPRINTF(stderr, "This version of Kernrate will only run on Windows 2000 or above\n"); 
        exit(1);
    }     
    //
    // Initialize gSourceMaximum, find supported sources
    // The dummy process will be used later to store user-defined event rates with the -i command line option  
    //
    gMaxSimultaneousSources   = MAX_SIMULTANEOUS_SOURCES;

    gpProcDummy = calloc(1, sizeof(PROC_TO_MONITOR));
    if (gpProcDummy==NULL) {
       FPRINTF(stderr, "KERNRATE: Allocation for Process failed for the -I or -L options\n");
       exit(1);
    }
                        
    gSourceMaximum = InitializeProfileSourceInfo(gpProcDummy);

    if ( gSourceMaximum == 0 || gStaticCount == 0 )   {
        FPRINTF( stderr, "KERNRATE: no profile source detected for this machine...\n" );
        exit(0);
    }

    // This will guaranty that we'll not enable any unwanted profiling
    for (j=0; j < gSourceMaximum; j++) {
        if( j < gStaticCount ) {
           gpProcDummy->Source[j].Interval = gStaticSource[j].Interval;
           if( j == SOURCE_TIME && gStaticSource[j].Interval == 0 )
               gpProcDummy->Source[j].Interval = KRATE_DEFAULT_TIMESOURCE_RATE; //IA64 default is zero
        } else {     
           gpProcDummy->Source[j].Interval = 0;
        }
    }

    //
    // Get the default IMAGEHLP global option mask
    // NOTE: This global variable could be changed by GetConfigurations().
    //       It is required to initialize it before calling this function.
    //

    gSymOptions = SymGetOptions();
    if ( gVerbose & VERBOSE_IMAGEHLP )   {
        FPRINTF( stderr, "KERNRATE: default IMAGEHLP SymOptions: %s\n", GetSymOptionsValues( gSymOptions ) );
    }

    //Bump kernrate's security privileges to debugger priveleges for tough guys like csrss.exe and dllhost.exe
 
    if (!InitializeAsDebugger()){
        FPRINTF(stderr, "KERNRATE: Unable to Get Debugger Security Privileges\n");
        exit(1);
    }

    //
    // Get some basic info about the system, determine the number of processors
    //
    gSysBasicInfo = GetSystemBasicInformation();
    if( gSysBasicInfo == NULL){
       FPRINTF(stderr, "KERNRATE: Failed to get SYSTEM_BASIC_INFORMATION\n");
       exit(1);
    }

    //
    // Get initial parameters from the Command Line
    //

    GetConfiguration(argc, argv);
    
    //
    // Initialize dbghelp
    //
    // Note that gSymOptions could have been modified in GetConfiguration().
    //

    SymSetOptions( gSymOptions );
    if ( gVerbose & VERBOSE_IMAGEHLP )   {
        FPRINTF( stderr, "KERNRATE: current IMAGEHLP SymOptions: %s\n", GetSymOptionsValues( gSymOptions ) );
    }

    gSymbol = (PIMAGEHLP_SYMBOL64) malloc( sizeof(IMAGEHLP_SYMBOL64) + MAX_SYMNAME_SIZE );
    if ( gSymbol == NULL ) {
       FPRINTF(stderr, "KERNRATE: Allocation for gSymbol failed\n");
       exit(1);
    }

    gSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL64);
    gSymbol->MaxNameLength = MAX_SYMNAME_SIZE;

}//InitializeKernrate()

VOID
InitAllProcessesModulesInfo(
    VOID
    )

{
    PPROC_TO_MONITOR ProcToMonitor = NULL;
    PMODULE          ZoomModule;
    ULONG            i, j;

    //
    // Deal with Kernel Profile Initialization
    //

    if(gNumProcToMonitor == 0 || bCombinedProfile == TRUE ){
        if( !InitializeKernelProfile()){
           FPRINTF(stderr, "Failed to Initialize Kernel Profile\n");
           exit(1);
        }
    }    

    // 
    // Deal with per-Process Profile Initialization
    //
    // Get information on kernel and/or process modules
    //


    ProcToMonitor = gProcessList; 

    for (i=0; i < gNumProcToMonitor; i++){  
    
       if(ProcToMonitor->ProcessHandle != SYM_KERNEL_HANDLE){

           if ( gVerbose & VERBOSE_IMAGEHLP )   {
               FPRINTF(stdout, "ProcessID= %I64d\n",    ProcToMonitor->Pid);
           }

           SymInitialize( ProcToMonitor->ProcessHandle, NULL, FALSE );
           
           if(!bSymPathInitialized) {
              InitSymbolPath( ProcToMonitor->ProcessHandle );
           }
           else {
               SymSetSearchPath(ProcToMonitor->ProcessHandle,  gSymbolPath); 
           }

           if ( SymRegisterCallback64( ProcToMonitor->ProcessHandle, SymbolCallbackFunction, (ULONG64)&gCurrentModule ) != TRUE )   {
              FPRINTF( stderr, "KERNRATE: Failed to register callback for IMAGEHLP process-handle operations...\n" );

           }

           ProcToMonitor->ModuleList = GetProcessModuleInformation(ProcToMonitor);
           
           if(ProcToMonitor->ModuleList != NULL)
              ProcToMonitor->ModuleList->mu.bProfileStarted = FALSE;

           for(j=0; j<gSourceMaximum; j++){
              ProcToMonitor->Source[j].bProfileStarted = FALSE;
           }

       }
       else{

           ProcToMonitor->ModuleList = GetKernelModuleInformation();
           if(ProcToMonitor->ModuleList != NULL)
              ProcToMonitor->ModuleList->mu.bProfileStarted = FALSE;

           for(j=0; j < gSourceMaximum; j++){
              ProcToMonitor->Source[j].bProfileStarted=FALSE;
           }

       }

       //
       // Any remaining entries on the ZoomList are liable to be errors.
       //
       if(gVerbose & VERBOSE_MODULES){
           ZoomModule = ProcToMonitor->ZoomList;
           while (ZoomModule != NULL) {
               PMODULE Module = ProcToMonitor->ModuleList;
               BOOL    bFound = FALSE;

               while (Module != NULL) {
                   if( 0 == _stricmp(ZoomModule->module_Name, Module->module_Name) ||
                       0 == _stricmp(ZoomModule->module_Name, Module->module_FileName) ){
                           FPRINTF(stdout,
                           "===>KERNRATE: Requested zoom module %s was found in the process modules list\n",
                           ZoomModule->module_Name
                           );

                       bFound = TRUE;
                       break;
                   }
                   Module = Module->Next;
               }
               if(!bFound){
                   FPRINTF(stdout,
                           "===>KERNRATE: Requested zoom module %s was not found in the process modules list, ignoring\n",
                           ZoomModule->module_Name
                           );
               }
               ZoomModule = ZoomModule->Next;
           }
       }
       CleanZoomModuleList(ProcToMonitor); //Done with the zoom list - cleanup for reuse in the post processing

       ProcToMonitor = ProcToMonitor->Next;
    } //for

}//InitAllProcessesModulesInfo

VOID
CleanZoomModuleList(
    PPROC_TO_MONITOR Proc
    )
{
    PMODULE Temp = Proc->ZoomList;
    while (Temp != NULL) {
        Proc->ZoomList = Proc->ZoomList->Next;
        free(Temp);
        Temp = NULL;
        Temp = Proc->ZoomList;
    }
} // CleanZoomModuleList()

VOID
ExecuteProfiles(
    BOOL bMode
    )
{

    ULONG             i,j;
    DWORD             Error = ERROR_SUCCESS;

    PPROC_TO_MONITOR  ProcToMonitor       = NULL;
    ULONG             ProcessActiveSource = 0;
    ULONG             LastActiveSource    = 0;

    if(bMode){ 
                    //old scheme - turn on one source at a time, switch sources every ChangeInterval ms
                    //             Note that this will cause the total profile time to be devided equally
                    //             between the N processes being monitored, each being profiled for 
                    //             an amount of TotalTime/N seconds...  
        do{

            ProcToMonitor = gProcessList; 

            for (i=0; i<gNumProcToMonitor; i++){  
                if( ProcToMonitor->ModuleList != NULL ){

                    do{ 
                        LastActiveSource = ProcessActiveSource;
                        ProcessActiveSource = NextSource(ProcessActiveSource,
                                                         ProcToMonitor->ModuleList,
                                                         ProcToMonitor
                                                         );
               
                        ProcToMonitor->ModuleList->mu.bProfileStarted = TRUE;
               
                        Error = WaitForSingleObject(ghDoneEvent, gChangeInterval);

                    }while(ProcessActiveSource > LastActiveSource); 

          

                    StopSource(ProcessActiveSource, ProcToMonitor->ModuleList, ProcToMonitor);
                }

                ProcToMonitor->Source[ProcessActiveSource].bProfileStarted = FALSE;

                ProcToMonitor = ProcToMonitor->Next;

            }

        } while ( Error == WAIT_TIMEOUT );

    } else {    // new scheme - turn on all requested profile sources and let them run simultaneously

        ProcToMonitor = gProcessList; 

        for (i=0; i<gNumProcToMonitor; i++){  
            if( ProcToMonitor->ModuleList != NULL ){

                for (j=0; j < gTotalActiveSources; j++){
                    StartSource(gulActiveSources[j], ProcToMonitor->ModuleList, ProcToMonitor);
                }
            }

            ProcToMonitor = ProcToMonitor->Next;

        }

        do{       

            Error = WaitForSingleObject(ghDoneEvent, gChangeInterval); //ChangeInterval does not switch any sources here

        } while ( Error == WAIT_TIMEOUT );

        ProcToMonitor = gProcessList; 

        for (i=0; i<gNumProcToMonitor; i++){  
            if( ProcToMonitor->ModuleList != NULL ){

                for (j=0; j < gTotalActiveSources; j++){
                    StopSource(gulActiveSources[j], ProcToMonitor->ModuleList, ProcToMonitor);
                }

            }

            ProcToMonitor = ProcToMonitor->Next;

        }

    } //if(bMode)

}//ExecuteProfiles()

VOID
DisplaySystemWideInformation(
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SystemInfoBegin,
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SystemInfoEnd
    )

{
    TIME_FIELDS                               Time;
    ULONG                                     i;
    ULONG                                     InterruptCounts, TotalInterruptCounts;
    LARGE_INTEGER                             Elapsed, Idle, Kernel, User, Dpc, Interrupt;
    LARGE_INTEGER                             TotalElapsed, TotalIdle, TotalKernel, TotalUser, TotalDpc, TotalInterrupt;



    TotalElapsed.QuadPart   = 0;
    TotalIdle.QuadPart      = 0;
    TotalKernel.QuadPart    = 0;
    TotalUser.QuadPart      = 0;
    TotalDpc.QuadPart       = 0;
    TotalInterrupt.QuadPart = 0;
    TotalInterruptCounts    = 0;

    FPRINTF(stdout, "\n------------Overall Summary:--------------\n\n");
    
    for (i=0; i<(ULONG)gSysBasicInfo->NumberOfProcessors; i++) {
        double n;
        long double m;

        Idle.QuadPart      = SystemInfoEnd[i].IdleTime.QuadPart   - SystemInfoBegin[i].IdleTime.QuadPart;
        User.QuadPart      = SystemInfoEnd[i].UserTime.QuadPart   - SystemInfoBegin[i].UserTime.QuadPart;
        Kernel.QuadPart    = SystemInfoEnd[i].KernelTime.QuadPart - SystemInfoBegin[i].KernelTime.QuadPart;
        Elapsed.QuadPart   = Kernel.QuadPart + User.QuadPart;
        Kernel.QuadPart   -= Idle.QuadPart;
        Dpc.QuadPart       = SystemInfoEnd[i].DpcTime.QuadPart - SystemInfoBegin[i].DpcTime.QuadPart;
        Interrupt.QuadPart = SystemInfoEnd[i].InterruptTime.QuadPart - SystemInfoBegin[i].InterruptTime.QuadPart;
        InterruptCounts    = SystemInfoEnd[i].InterruptCount - SystemInfoBegin[i].InterruptCount; 
        
        TotalKernel.QuadPart    += Kernel.QuadPart;
        TotalUser.QuadPart      += User.QuadPart;
        TotalIdle.QuadPart      += Idle.QuadPart;
        TotalElapsed.QuadPart   += Elapsed.QuadPart;
        TotalDpc.QuadPart       += Dpc.QuadPart;
        TotalInterrupt.QuadPart += Interrupt.QuadPart;
        TotalInterruptCounts    += InterruptCounts;

        FPRINTF(stdout, "P%d   ",i);
        RtlTimeToTimeFields(&Kernel, &Time);
        n = UInt64ToDoublePerCent( Kernel.QuadPart, Elapsed.QuadPart );
        FPRINTF(stdout, "  K %ld:%02ld:%02ld.%03ld (%4.1f%%)",
                Time.Hour,
                Time.Minute,
                Time.Second,
                Time.Milliseconds,
                n );

        RtlTimeToTimeFields(&User, &Time);
        n = UInt64ToDoublePerCent( User.QuadPart, Elapsed.QuadPart );
        FPRINTF(stdout, "  U %ld:%02ld:%02ld.%03ld (%4.1f%%)",
                Time.Hour,
                Time.Minute,
                Time.Second,
                Time.Milliseconds,
                n );

        RtlTimeToTimeFields(&Idle, &Time);
        n = UInt64ToDoublePerCent( Idle.QuadPart, Elapsed.QuadPart );
        FPRINTF(stdout, "  I %ld:%02ld:%02ld.%03ld (%4.1f%%)",
                Time.Hour,
                Time.Minute,
                Time.Second,
                Time.Milliseconds,
                n );

        RtlTimeToTimeFields(&Dpc, &Time);
        n = UInt64ToDoublePerCent( Dpc.QuadPart, Elapsed.QuadPart );
        FPRINTF(stdout, "  DPC %ld:%02ld:%02ld.%03ld (%4.1f%%)",
                Time.Hour,
                Time.Minute,
                Time.Second,
                Time.Milliseconds,
                n );

        RtlTimeToTimeFields(&Interrupt, &Time);
        n = UInt64ToDoublePerCent( Interrupt.QuadPart, Elapsed.QuadPart );
        FPRINTF(stdout, "  Interrupt %ld:%02ld:%02ld.%03ld (%4.1f%%)\n",
               Time.Hour,
               Time.Minute,
               Time.Second,
               Time.Milliseconds,
               n );

        m = Elapsed.QuadPart > 0 ? (long double)10000000 * (long double)InterruptCounts / (long double)Elapsed.QuadPart : 0; 
        FPRINTF(stdout, "       Interrupts= %ld, Interrupt Rate= %.0f/sec.\n\n",
                InterruptCounts,
                m );
   
    }

  
    if (gSysBasicInfo->NumberOfProcessors > 1) {

        double n;
        long double m;

        FPRINTF(stdout, "TOTAL");
        RtlTimeToTimeFields(&TotalKernel, &Time);
        n = UInt64ToDoublePerCent( TotalKernel.QuadPart, TotalElapsed.QuadPart );
        FPRINTF(stdout, "  K %ld:%02ld:%02ld.%03ld (%4.1f%%)",
                Time.Hour,
                Time.Minute,
                Time.Second,
                Time.Milliseconds,
                n );

        RtlTimeToTimeFields(&TotalUser, &Time);
        n = UInt64ToDoublePerCent( TotalUser.QuadPart, TotalElapsed.QuadPart );
        FPRINTF(stdout, "  U %ld:%02ld:%02ld.%03ld (%4.1f%%)",
                Time.Hour,
                Time.Minute,
                Time.Second,
                Time.Milliseconds,
                n );

        RtlTimeToTimeFields(&TotalIdle, &Time);
        n = UInt64ToDoublePerCent( TotalIdle.QuadPart, TotalElapsed.QuadPart );
        gTotalIdleTime = n;
        FPRINTF(stdout, "  I %ld:%02ld:%02ld.%03ld (%4.1f%%)",
                Time.Hour,
                Time.Minute,
                Time.Second,
                Time.Milliseconds,
                n );

        RtlTimeToTimeFields(&TotalDpc, &Time);
        n = UInt64ToDoublePerCent( TotalDpc.QuadPart, TotalElapsed.QuadPart );
        FPRINTF(stdout, "  DPC %ld:%02ld:%02ld.%03ld (%4.1f%%)",
                Time.Hour,
                Time.Minute,
                Time.Second,
                Time.Milliseconds,
                n );

        RtlTimeToTimeFields(&TotalInterrupt, &Time);
        n = UInt64ToDoublePerCent( TotalInterrupt.QuadPart, TotalElapsed.QuadPart );
        FPRINTF(stdout, "  Interrupt %ld:%02ld:%02ld.%03ld (%4.1f%%)\n",
                Time.Hour,
                Time.Minute,
                Time.Second,
                Time.Milliseconds,
                n );


        m = Elapsed.QuadPart > 0 ? (long double)10000000 * (long double)TotalInterruptCounts / (long double)Elapsed.QuadPart : 0; 

        FPRINTF(stdout, "       Total Interrupts= %ld, Total Interrupt Rate= %.0f/sec.\n\n",
                TotalInterruptCounts,
                m );

    }
    //
    // Display system-wide counters information 
    //
    gldElapsedSeconds = (long double)Elapsed.QuadPart / (long double)10000000; 
    gTotalElapsedSeconds = (ULONG)(TotalElapsed.QuadPart/10000000);            //Sum on all processors
    gTotalElapsedTime64.QuadPart = TotalElapsed.QuadPart;
    

    FPRINTF(stdout, "\nTotal Profile Time = %ld msec\n", (ULONG)Elapsed.QuadPart/(ULONG)10000);
    
    if(bIncludeGeneralInfo)
        GetProfileSystemInfo(OUTPUT);
    if(bIncludeSystemLocksInfo)
        GetSystemLocksInformation(OUTPUT);


}//DisplaySystemWideInformation()


BOOL
IsStringANumber(
    IN PCHAR String
    )
/*++

Routine Description:

    Checks if a string is representing a positive decimal form integer
    not larger than 999,999,999 (9 digits maximum)  
              
Arguments:

    String           - Supplies the character string pointer.

Return Value:

    TRUE             - The string represents a number under the restrictions above
    FALSE            - The string does not represent a number under the restrictions above

Notes:

    The functions atol() and atoi() will return a number for a mixed string that starts with a number,
    such as 345d (345 will be returned). Also they don't handle overflow conditions.
    
--*/

{
    BOOL  bRet  = FALSE;
    ULONG i     = 0;
    
    if ( String != NULL ) {
        while( (i <= MAX_DIGITS_IN_INPUT_STRING) && isdigit( String[i] ) ){
           if( String[i+1] == ' ' || iscntrl( String[i+1] ) ){
               bRet = TRUE; 
               break;
           }
           ++i;
        }
    }    
    
    return (bRet);    
}

ULONG
HandleRedirections(
    IN  PCHAR  cmdLine,
    IN  ULONG  nCharsStart,
    OUT HANDLE *hInput,
    OUT HANDLE *hOutput,
    OUT HANDLE *hError
    )
{
    PCHAR Input = NULL, Output = NULL, Error = NULL;
    PCHAR tmp = NULL;
    ULONG retLength = nCharsStart;
    ULONG jump = 0;
    DWORD dwMode = OPEN_EXISTING;

    SECURITY_ATTRIBUTES *sa = calloc( 1, sizeof(SECURITY_ATTRIBUTES));
    if( sa == NULL ){
        FPRINTF(stderr, "KERNRATE: Failed to allocate memory for security attributes in HandleRedirections()\n");
        exit(1);
    }
    sa->bInheritHandle = TRUE;

    tmp = strchr(cmdLine, '|');
    if (tmp != NULL ){
        FPRINTF(stderr, "\nKERNRATE: Piping '|' is not supported for '-o ProcessName {command line parameters}'\n");
        FPRINTF(stderr, "            Redirections of the input/output/error streams are supported.\n");
        exit(1);
    }
    
    tmp = strchr(cmdLine, '<');
    if ( tmp != NULL ){
        PCHAR Startptr = tmp;
        ULONG Length;

        while(tmp[jump] == ' '){
            ++jump;
        }
        Input = &tmp[jump];
        Length = jump + lstrlen(Input);
        
        *hInput = CreateFile(Input, 
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             sa,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                            );

        if (*hInput == INVALID_HANDLE_VALUE){
            FPRINTF(stderr, "\nKERNRATE: Could not open user specified input file %s, attempting to continue\n", Input);
        }
        memcpy(Startptr, Startptr + Length, (retLength - (ULONG)(Startptr - cmdLine) - Length ) );
        retLength -= Length;
        cmdLine[retLength] = '\0';

    }

    jump = 0;
    tmp = strstr(cmdLine, "2>>");
    if( tmp != NULL ){
        jump = 3;
        dwMode = OPEN_ALWAYS;
    } else {
        tmp = strstr(cmdLine, "2>");
        if( tmp != NULL ){
            jump = 2;
            dwMode = CREATE_ALWAYS;
        }
    }

    if ( tmp != NULL ){
        PCHAR Startptr = tmp;
        ULONG Length;

        while(tmp[jump] == ' '){
            ++jump;
        }
        Error = &tmp[jump];
        Length = jump + lstrlen(Error);

        *hError = CreateFile(Error, 
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             sa,
                             dwMode,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                             );

        if (*hError == INVALID_HANDLE_VALUE){
            FPRINTF(stderr, "\nKERNRATE: Could not open or create user specified Error file %s, attempting to continue\n", Error);
        }
        if(dwMode == OPEN_ALWAYS){
            SetFilePointer(*hError, 0, NULL, FILE_END);
        }

        memcpy(Startptr, Startptr + Length, (retLength - (ULONG)(Startptr - cmdLine) - Length ) );
        retLength -= Length;
        cmdLine[retLength] = '\0';

    }

    jump = 0;    
    tmp = strstr(cmdLine, "1>>");
    if ( tmp != NULL ){
        jump = 3;
        dwMode = OPEN_ALWAYS;
    } else { 
        tmp = strstr(cmdLine, "1>");
        if ( tmp != NULL ){
            jump = 2;
            dwMode = CREATE_ALWAYS;
        } 
    }

    if ( tmp == NULL && hError == NULL ) {
        tmp = strstr(cmdLine, ">>");
        if (tmp != NULL){
            jump = 2;
            dwMode = OPEN_ALWAYS;
        } else {
            tmp = strchr(cmdLine, '>');
            jump = 1;
            dwMode = CREATE_ALWAYS;
        }
    }

    if ( tmp != NULL ){
        PCHAR Startptr = tmp;
        ULONG Length;

        while(tmp[jump] == ' '){
            ++jump;
        }

        Output = &tmp[jump];
        Length = jump + lstrlen(Output);

        *hOutput = CreateFile(Output, 
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              sa,
                              dwMode,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              );

        if (*hOutput == INVALID_HANDLE_VALUE){
            FPRINTF(stderr, "\nKERNRATE: Could not open or create user specified Output file %s, attempting to continue\n", Output);
        }
        if(dwMode == OPEN_ALWAYS){
            SetFilePointer(*hOutput, 0, NULL, FILE_END);
        }
        memcpy(Startptr, Startptr + Length, (retLength - (ULONG)(Startptr - cmdLine) - Length ) );
        retLength -= Length;
        cmdLine[retLength] = '\0';

    }

    free(sa);
    sa = NULL;

    return (retLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\ntsdexts\hleak.c ===
#include "ntsdextp.h"


#define REASONABLE_NUMBER   8


typedef BOOL (_ID_MATCH_FN)(
    PVOID   A,
    PVOID   B);
typedef _ID_MATCH_FN * PID_MATCH_FN;

typedef VOID (_ID_BANNER_FN)(
    PVOID   Id
    );
typedef _ID_BANNER_FN * PID_BANNER_FN;

typedef VOID (_HANDLE_CALLBACK_FN)(
    PVOID Context,
    HANDLE Here,
    HANDLE There
    );
typedef _HANDLE_CALLBACK_FN * PHANDLE_CALLBACK_FN;


#define MATCH_LARGE_INT     ((PID_MATCH_FN)1)

typedef struct _HANDLE_TRACK {
    LIST_ENTRY  List ;
    ULONG       Flags ;
    ULONG       Count ;
    ULONG       Size ;
    PHANDLE     Handles ;
    HANDLE      HandleList[ REASONABLE_NUMBER ];
    UCHAR       IdData[ 1 ];
} HANDLE_TRACK, * PHANDLE_TRACK ;

typedef struct _HANDLE_TRACK_ARRAY {
    ULONG       Count ;
    ULONG       Size ;
    ULONG       IdDataSize ;
    PID_MATCH_FN MatchFunc ;
    LIST_ENTRY  List ;
} HANDLE_TRACK_ARRAY, * PHANDLE_TRACK_ARRAY ;

typedef struct _THREAD_TRACK_INFO {
    CLIENT_ID   Id ;
    PVOID       Win32StartAddress ;
    DWORD       Status ;
} THREAD_TRACK_INFO ;

typedef struct _HANDLE_LEAK_HELPER {
    PWSTR               Type ;
    PID_BANNER_FN       Banner ;
    PHANDLE_CALLBACK_FN Filter ;
    ULONG               ArraySize ;
    PID_MATCH_FN        Match ;
} HANDLE_LEAK_HELPER, * PHANDLE_LEAK_HELPER ;

_ID_BANNER_FN       ThreadBanner ;
_ID_BANNER_FN       TokenBanner ;
_HANDLE_CALLBACK_FN ThreadCallback ;
_HANDLE_CALLBACK_FN TokenCallback ;

HANDLE_LEAK_HELPER HandleLeakHelpers[] = {
    { L"Thread", ThreadBanner, ThreadCallback, sizeof( THREAD_TRACK_INFO ), MATCH_LARGE_INT },
    { L"Token", TokenBanner, TokenCallback, sizeof( TOKEN_CONTROL ), MATCH_LARGE_INT }
};


PHANDLE_TRACK_ARRAY
CreateArray(
    ULONG   IdDataSize,
    PID_MATCH_FN MatchFn
    )
{
    PHANDLE_TRACK_ARRAY    Array ;

    Array = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( HANDLE_TRACK_ARRAY ) );

    if ( Array )
    {
        Array->Count = 0 ;
        Array->Size = 0;
        Array->IdDataSize = IdDataSize ;
        Array->MatchFunc = MatchFn ;

        InitializeListHead( &Array->List );

        return Array ;
    }

    return NULL ;
}

VOID
DeleteArray(
    PHANDLE_TRACK_ARRAY Array
    )
{
    ULONG i ;
    PHANDLE_TRACK Track ;

    while ( !IsListEmpty( &Array->List ) )
    {
        Track = (PHANDLE_TRACK) RemoveHeadList( &Array->List );

        if ( Track->Handles != Track->HandleList )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, Track->Handles );
        }

        RtlFreeHeap( RtlProcessHeap(), 0, Track );
    }

    RtlFreeHeap( RtlProcessHeap(), 0, Array );
}


VOID
ExtendTrack(
    PHANDLE_TRACK Track
    )
{
    PHANDLE NewHandle ;

    NewHandle = RtlAllocateHeap( RtlProcessHeap(), 0, (Track->Size + REASONABLE_NUMBER ) *
                        sizeof( HANDLE ) );

    if ( NewHandle )
    {
        CopyMemory( NewHandle,
                    Track->Handles,
                    Track->Count * sizeof( HANDLE ) );

        if ( Track->Handles != Track->HandleList )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, Track->Handles );
        }

        Track->Handles = NewHandle ;
        Track->Size += REASONABLE_NUMBER ;
    }
}

VOID
AddHandleToArray(
    PHANDLE_TRACK_ARRAY Array,
    PVOID IdData,
    HANDLE Handle
    )
{
    ULONG i;
    ULONG j;
    BOOL Match ;
    PHANDLE_TRACK Track ;
    PLIST_ENTRY Scan ;

    Scan = Array->List.Flink ;

    while ( Scan != &Array->List )
    {
        Track = (PHANDLE_TRACK) Scan ;

        if ( Array->MatchFunc == MATCH_LARGE_INT )
        {
            Match = ((PLARGE_INTEGER) Track->IdData)->QuadPart ==
                    ((PLARGE_INTEGER) IdData)->QuadPart ;
        }
        else
        {
            Match = Array->MatchFunc( Track->IdData, IdData );
        }

        if ( Match )
        {
            //
            // We have a match:
            //

            if ( Track->Count == Track->Size )
            {
                ExtendTrack( Track );
            }

            if ( Track->Count < Track->Size )
            {
                Track->Handles[
                        Track->Count ] = Handle ;

                Track->Count++;
            }

            return ;
        }

        Scan = Scan->Flink ;
    }

    //
    // No match, gotta add a new tid
    //

    Track = RtlAllocateHeap( RtlProcessHeap(), 0,
                sizeof( HANDLE_TRACK ) + Array->IdDataSize );

    if ( Track )
    {
        Track->Size = REASONABLE_NUMBER ;
        Track->Count = 1 ;
        Track->Handles = Track->HandleList ;
        Track->HandleList[0] = Handle ;

        CopyMemory( Track->IdData, IdData, Array->IdDataSize );

        InsertTailList( &Array->List, &Track->List );
    }

}

VOID
DumpArray(
    PHANDLE_TRACK_ARRAY Array,
    PID_BANNER_FN   Banner
    )
{
    ULONG j;
    PHANDLE_TRACK Track ;
    PLIST_ENTRY Scan ;

    Scan = Array->List.Flink ;

    while ( Scan != &Array->List )
    {
        Track = (PHANDLE_TRACK) Scan ;

        Banner( Track->IdData );

        dprintf("  Handles  \t%d:  ", Track->Count );
        for ( j = 0 ; j < Track->Count ; j++ )
        {
            dprintf("%x, ", Track->Handles[j] );
        }

        dprintf("\n");

        Scan = Scan->Flink ;
    }

}

VOID
HandleScanner(
    HANDLE  hCurrentProcess,
    PWSTR   Type,
    PVOID   Context,
    PHANDLE_CALLBACK_FN Callback
    )
{
    DWORD   HandleCount;
    NTSTATUS Status;
    DWORD   Total;
    DWORD   Handle;
    DWORD   Hits;
    DWORD   Matches;
    HANDLE  hHere ;
    PHANDLE_TRACK_ARRAY Array ;
    POBJECT_TYPE_INFORMATION    pTypeInfo;
    UCHAR   Buffer[1024];

    Status = NtQueryInformationProcess( hCurrentProcess,
                                        ProcessHandleCount,
                                        &HandleCount,
                                        sizeof( HandleCount ),
                                        NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return;
    }

    Hits = 0;
    Handle = 0;
    Matches = 0;

    while ( Hits < HandleCount )
    {
        Status = NtDuplicateObject( hCurrentProcess, (HANDLE)(DWORD_PTR)Handle,
                                    NtCurrentProcess(), &hHere,
                                    0, 0,
                                    DUPLICATE_SAME_ACCESS );

        if ( NT_SUCCESS( Status ) )
        {

            pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;

            ZeroMemory( Buffer, 1024 );

            Status = NtQueryObject( hHere, ObjectTypeInformation, pTypeInfo, 1024, NULL );

            if (NT_SUCCESS(Status))
            {
                if ( wcscmp( pTypeInfo->TypeName.Buffer, Type ) == 0 )
                {
                    //
                    // Score!
                    //

                    Callback( Context, hHere, (HANDLE)(DWORD_PTR)Handle );

                    Matches++ ;

                }
            }

            Hits++ ;

            NtClose( hHere );

        }

        Handle += 4;
    }

    dprintf("%d handles to objects of type %ws\n", Matches, Type );
}


VOID
ThreadBanner(
    PVOID Id
    )
{
    UCHAR Symbol[ MAX_PATH ];
    DWORD_PTR Disp ;
    THREAD_TRACK_INFO * Info ;
    UCHAR ExitStatus[ 32 ];

    Info = (THREAD_TRACK_INFO *) Id ;

    Symbol[0] = '\0';

    GetSymbol( Info->Win32StartAddress, Symbol, &Disp );

    if ( Info->Status != STILL_ACTIVE )
    {
        sprintf(ExitStatus, " Stopped, %#x", Info->Status );
    }
    else
    {
        strcpy( ExitStatus, "<Running>");
    }

    if ( Symbol[0] )
    {
        dprintf("Thread %x.%x (%s) %s\n", Info->Id.UniqueProcess,
                        Info->Id.UniqueThread,
                        Symbol,
                        ExitStatus );
    }
    else
    {
        dprintf("Thread %x.%x %s\n", Info->Id.UniqueProcess,
                        Info->Id.UniqueThread,
                        ExitStatus );

    }
}

VOID
ThreadCallback(
    PVOID Context,
    HANDLE Here,
    HANDLE There
    )
{
    NTSTATUS Status ;
    THREAD_BASIC_INFORMATION Info;

    THREAD_TRACK_INFO ThdInfo ;

    ZeroMemory( &ThdInfo, sizeof( ThdInfo ) );

    Status = NtQueryInformationThread( Here,
                                       ThreadBasicInformation,
                                       &Info,
                                       sizeof( Info ),
                                       NULL );

    if ( NT_SUCCESS( Status ) )
    {
        ThdInfo.Id = Info.ClientId ;
        ThdInfo.Status = Info.ExitStatus ;

        Status = NtQueryInformationThread( Here,
                                           ThreadQuerySetWin32StartAddress,
                                           &ThdInfo.Win32StartAddress,
                                           sizeof( PVOID ),
                                           NULL );

        AddHandleToArray( Context, &ThdInfo , There );
    }
}

VOID
TokenCallback(
    PVOID Context,
    HANDLE Here,
    HANDLE There
    )
{
    NTSTATUS Status ;
    TOKEN_CONTROL Control ;
    TOKEN_STATISTICS Stats ;
    ULONG Size ;

    Status = NtQueryInformationToken(   Here,
                                        TokenStatistics,
                                        &Stats,
                                        sizeof( Stats ),
                                        &Size );

    if ( NT_SUCCESS( Status ) )
    {
        Control.TokenId = Stats.TokenId ;
        Control.AuthenticationId = Stats.AuthenticationId ;
        Control.ModifiedId = Stats.ModifiedId ;
        NtQueryInformationToken( Here, TokenSource, &Control.TokenSource, sizeof( TOKEN_SOURCE ), &Size );

        AddHandleToArray( Context, &Control, There );
    }
    else
    {
        dprintf("Unable to query token information, %x\n", Status );
    }
}

VOID
TokenBanner(
    PVOID Id
    )
{
    PTOKEN_CONTROL Control ;

    Control = (PTOKEN_CONTROL) Id ;

    dprintf("Token   Id %x:%x, LogonId = %x:%x, Source = %s\n",
                Control->TokenId.HighPart, Control->TokenId.LowPart,
                Control->AuthenticationId.HighPart, Control->AuthenticationId.LowPart,
                Control->TokenSource.SourceName );
}


DECLARE_API( hleak )
{
    UNICODE_STRING String ;
    PHANDLE_LEAK_HELPER Helper = NULL ;
    PHANDLE_TRACK_ARRAY Array ;
    int i ;

    INIT_API();

    if ( !args ||
         (*args == '\0' ) )
    {
        dprintf( "!hleak <typename>\n" );
        goto Exit;
    }

    while ( *args == ' ' )
    {
        args++ ;
    }

    if ( !RtlCreateUnicodeStringFromAsciiz( &String, args ) )
    {
        goto Exit;
    }

    for ( i = 0 ; 
          i < sizeof( HandleLeakHelpers ) / sizeof( HANDLE_LEAK_HELPER ) ; 
          i++ )
    {
        if ( _wcsicmp( String.Buffer, HandleLeakHelpers[ i ].Type ) == 0 )
        {
            Helper = &HandleLeakHelpers[ i ];
            break;
        }
    }

    if ( Helper == NULL )
    {
        dprintf( "The type '%ws' was not recognized.  Valid types are:\n", String.Buffer );
        for ( i = 0 ; 
              i < sizeof( HandleLeakHelpers ) / sizeof( HANDLE_LEAK_HELPER ) ; 
              i++ )
        {
            dprintf( "\t%ws\n", HandleLeakHelpers[ i ].Type );
        }
        RtlFreeUnicodeString( &String );
        goto Exit;
    }

    RtlFreeUnicodeString( &String );

    Array = CreateArray( Helper->ArraySize, Helper->Match );

    if ( !Array )
    {
        dprintf( "not enough memory\n" );
    }

    HandleScanner( g_hCurrentProcess,
                   Helper->Type,
                   Array,
                   Helper->Filter );

    DumpArray( Array, Helper->Banner );

    DeleteArray( Array );

 Exit:
    EXIT_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\ntsdexts\ext.cpp ===
//----------------------------------------------------------------------------
//
// Generic interface-style extension support.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <windows.h>
#define NOEXTAPI
#include <wdbgexts.h>

#include "ext.h"

int g_ExtRecurse;
PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

PDEBUG_DATA_SPACES2   g_ExtData2;

HANDLE g_hCurrentProcess;
HANDLE g_hCurrentThread;

WINDBG_EXTENSION_APIS   ExtensionApis;
WINDBG_EXTENSION_APIS32 ExtensionApis32;
WINDBG_EXTENSION_APIS64 ExtensionApis64;

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if (++g_ExtRecurse > 1)
    {
        // Already queried.
        return S_OK;
    }
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    ULONG64 Cur;
    
    if ((Status = g_ExtSystem->GetCurrentProcessHandle(&Cur)) != S_OK)
    {
        goto Fail;
    }
    g_hCurrentProcess = (HANDLE)(ULONG_PTR)Cur;
    
    if ((Status = g_ExtSystem->GetCurrentThreadHandle(&Cur)) != S_OK)
    {
        goto Fail;
    }
    g_hCurrentThread = (HANDLE)(ULONG_PTR)Cur;
    
    ExtensionApis64.nSize = sizeof(ExtensionApis64);
    if ((Status = g_ExtControl->
         GetWindbgExtensionApis64(&ExtensionApis64)) != S_OK)
    {
        goto Fail;
    }
    ExtensionApis32.nSize = sizeof(ExtensionApis32);
    if ((Status = g_ExtControl->
         GetWindbgExtensionApis32(&ExtensionApis32)) != S_OK)
    {
        goto Fail;
    }
    
#ifdef _WIN64
    memcpy(&ExtensionApis, &ExtensionApis64, sizeof(ExtensionApis));
#else
    memcpy(&ExtensionApis, &ExtensionApis32, sizeof(ExtensionApis));
#endif

    // Check for version 2 interfaces.  Do not consider
    // it fatal if they can't be queried.  Extension code
    // must handle the potential lack of these interfaces.
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces2),
                                         (void **)&g_ExtData2)) != S_OK)
    {
        g_ExtData2 = NULL;
    }
    
    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    if (--g_ExtRecurse > 0)
    {
        // Recursive release so don't do anything.
        return;
    }
    
    g_ExtClient = NULL;
    g_hCurrentProcess = NULL;
    g_hCurrentThread = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
    EXT_RELEASE(g_ExtData2);
}

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    return S_OK;
}


ULONG GetCurrentThreadUserID(void)
{
    ULONG Id;
    if (!g_ExtSystem) {
        return 0;
    }

    if (g_ExtSystem->GetCurrentThreadId(&Id) != S_OK) {
        return 0;
    }
    return Id;
}
BOOL
EnumerateUModeThreads(
    PENUMERATE_UMODE_THREADS_CALLBACK Callback,
    PVOID UserContext
    )
{
    ULONG CurrentThreadId;
    ULONG ThreadId;

    if (!g_ExtSystem) {
        return FALSE;
    }

    // Remember thread we started with
    if (g_ExtSystem->GetCurrentThreadId(&CurrentThreadId) != S_OK) {
        return FALSE;
    }

    // Loop through all threads
    for (ThreadId=0;;ThreadId++) {

        // set ThreadId as current thread
        if (g_ExtSystem->SetCurrentThreadId(ThreadId) != S_OK) {
            // finished enumerateing threads
            break;
        }

        // call the callback routine
        if (!((*Callback)(ThreadId, UserContext))) {
            // callback failed, break out
            break;
        }

    }

    // Set current thread back to original value
    g_ExtSystem->SetCurrentThreadId(CurrentThreadId);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\ntsdexts\ntsdextp.h ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <heap.h>
#include <stktrace.h>
#include <lmerr.h>

#include <ntcsrsrv.h>

#include "ext.h"

#include "secexts.h"

#undef DECLARE_API

#define DECLARE_API(extension) \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API() if (ExtQuery(Client) != S_OK) return E_OUTOFMEMORY
#define EXIT_API() ExtRelease(); return S_OK


BOOL Idreg(
    DWORD opts,
    LPCSTR InString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\kernrate\kernrate.h ===
#ifndef KERNRATE_H_INCLUDED
#define KERNRATE_H_INCLUDED

/*++

  Copyright (c) 1989-2002  Microsoft Corporation

--*/

//
// set the debug environment
//
#if DBG                 // NTBE environment
   #if NDEBUG
      #undef NDEBUG     // <assert.h>: assert() is defined
   #endif // NDEBUG
   #define _DEBUG       // <crtdbg.h>: _ASSERT(), _ASSERTE() are defined.
   #define DEBUG   1    // our internal file debug flag
#elif _DEBUG            // VC++ environment
   #ifndef NEBUG
   #define NDEBUG
   #endif // !NDEBUG
   #define DEBUG   1    // our internal file debug flag
#endif

//
// Include System Header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>   //The debugger team recommends using dbghelp.h rather than imagehlp.h
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
//MC
#include <wchar.h>
//MC

#include <..\pperf\pstat.h>

#include ".\kernrate.rc"

//
// Constant Definitions
//
#define DEFAULT_ZOOM_BUCKET_SIZE         16              //Minimum is 4 bytes
#define DEFAULT_LOG2_ZOOM_BUCKET          4
#define MINIMUM_ZOOM_BUCKET_SIZE          4
#define DEFAULT_SOURCE_CHANGE_INTERVAL 1000              //ms
#define KRATE_DEFAULT_TIMESOURCE_RATE 25000              //Events/Hit
#define DEFAULT_SLEEP_INTERVAL            0

#define MAX_SYMNAME_SIZE               1024
#define USER_SYMPATH_LENGTH             512              //specified on the command line
#define TOTAL_SYMPATH_LENGTH           1024
#define SYM_VALUES_BUF_SIZE             160

#define SYM_KERNEL_HANDLE              (HANDLE)-1
#define SYSTEM_PROCESS_NAME            "System"

#define TITLE_SIZE                       64
#define PROCESS_NAME_SIZE                36              //without extension 
#define EXT_SIZE                          4              //.exe
#define PROCESS_SIZE                   (PROCESS_NAME_SIZE+EXT_SIZE+1)
#define DEFAULT_MAX_TASKS               256
#define MAX_PROC_SAME_NAME                8
#define INITIAL_STEP                      2              //Symbol enumeration default address stepping
#define JIT_MAX_INITIAL_STEP             16              //Managed Code symbol enumeration maximum step size (bytes)
#define LOCK_CONTENTION_MIN_COUNT      1000
#define MIN_HITS_TO_DISPLAY               1
#define SECONDS_TO_DELAY_PROFILE          0
#define SECONDS_TO_WAIT_CREATED_PROC      2
#define UINT64_MAXDWORD                ((unsigned __int64)0xffffffff)

#define DEFAULT_TOKEN_MAX_LENGTH         12              // strlen("dcacheacces")
#define DEFAULT_DESCRIPTION_MAX_LENGTH   25              // strlen("Load Linked Instructions")

#define MAX_DIGITS_IN_INPUT_STRING        9              // Max. allowed digits considered valid input for a number on the command line

#if defined(_IA64_)|| defined(_AMD64_)
#define MAX_SIMULTANEOUS_SOURCES          4
#else
#define MAX_SIMULTANEOUS_SOURCES          1
#endif

#if defined(DISASM_AVAILABLE)
#undefine(DISASM_AVAILABLE)
#endif

//MC
#define MANAGED_CODE_MAINLIB             "mscoree.dll"   // Presence of which indicates need to handle Managed Code
#define MANAGED_CODE_SYMHLPLIB           "ip2md.dll"     // Symbol translation helper library for Managed Code
//MC

//
// Macros
//
#define WIN2K_OS               (gOSInfo.dwMajorVersion == 5 && gOSInfo.dwMinorVersion == 0)
#define FPRINTF                (void)fprintf
#define RATE_DATA_FIXED_SIZE   (5*sizeof(ULONGLONG))
#define RATE_DATA_VAR_SIZE     ((sizeof(ULONGLONG *)+sizeof(HANDLE *)+sizeof(ULONG *)+sizeof(PULONG *))*gProfileProcessors)
#define BUCKETS_NEEDED(length) ( length%gZoomBucket == 0? (length/gZoomBucket):(1+length/gZoomBucket) )
#define MODULE_SIZE            (sizeof(MODULE)+(RATE_DATA_FIXED_SIZE + RATE_DATA_VAR_SIZE)*gSourceMaximum)
#define IsValidHandle( _Hdl )  ( ( (_Hdl) != (HANDLE)0 ) && ( (_Hdl) != INVALID_HANDLE_VALUE ) )
#define VerbosePrint( _x_ )    vVerbosePrint _x_

#define ModuleFileName( _Module ) \
   ( (_Module)->module_FileName ? (_Module)->module_FileName : (_Module)->module_Name )
#define ModuleFullName( _Module ) \
   ( (_Module)->module_FullName ? (_Module)->module_FullName : ModuleFileName( _Module ) )

//
// On Itanium it turns out that you may request a rate of let's say 800 but actually get 799...
// The check for an exact match in this case will fail and the logic will force the default rate
// The following allows a tollerance of 25 percent to be considered as a match
// 
#define PERCENT_DIFF(a,b)      ( a > b? (100*(a-b))/b : (100*(b-a))/b )
#define RATES_MATCH(a,b)       ( PERCENT_DIFF(a,b) <= 25 )

//
// Struct and Enum Type Definitions and Related Globals
//
typedef enum _KERNRATE_NAMESPACE {
    cMAPANDLOAD_READONLY = TRUE,
    cDONOT_ALLOCATE_DESTINATION_STRING = FALSE,
} eKERNRATE_NAMESPACE;

typedef enum _ACTION_TYPE {
   START  = 0,
   STOP   = 1,
   OUTPUT = 2,
   DEFAULT= 3
} ACTION_TYPE;

//
// Verbose Output Related 
//
typedef enum _VERBOSE_ENUM {
   VERBOSE_NONE      = 0,   //
   VERBOSE_IMAGEHLP  = 0x1, //
   VERBOSE_PROFILING = 0x2, //
   VERBOSE_INTERNALS = 0x4, //
   VERBOSE_MODULES   = 0x8, //
   VERBOSE_DEFAULT   = VERBOSE_IMAGEHLP,
   VERBOSE_MAX       = VERBOSE_IMAGEHLP | VERBOSE_PROFILING | VERBOSE_INTERNALS | VERBOSE_MODULES
} VERBOSE_ENUM;

typedef struct _VERBOSE_DEFINITION {
   VERBOSE_ENUM        VerboseEnum;
   const char * const  VerboseString;
} VERBOSE_DEFINITION, *PVERBOSE_DEFINITION;

//
// Profile Source Related
//

typedef struct _SOURCE {
    PCHAR           Name;                  // pstat EVENTID.Description
    KPROFILE_SOURCE ProfileSource;
    PCHAR           ShortName;             // pstat EVENTID.ShortName
    ULONG           DesiredInterval;       // system default interval
    ULONG           Interval;              // user set interval (not guaranteed)
    BOOL            bProfileStarted;
} SOURCE, *PSOURCE;

typedef struct _RATE_DATA {
    ULONGLONG   StartTime;
    ULONGLONG   TotalTime;
    ULONGLONG   Rate;                      // Events/Second
    ULONGLONG   GrandTotalCount;
    ULONGLONG   DoubtfulCounts;
    ULONGLONG  *TotalCount;
    HANDLE     *ProfileHandle;
    ULONG      *CurrentCount;
    PULONG     *ProfileBuffer;
} RATE_DATA, *PRATE_DATA;

//
// Module related definitions
//
typedef enum _MODULE_NAMESPACE {
    cMODULE_NAME_STRLEN = 132,   // maximum module name, including '\0'
} eMODULE_NAMESPACE;

typedef struct _MODULE {
    struct _MODULE *Next;
    HANDLE          hProcess;
    ULONG64         Base;
    ULONG           Length;
    BOOL            bZoom;
    union {
        BOOL        bProfileStarted;
        BOOL        bHasHits;
        } mu;
    CHAR            module_Name[cMODULE_NAME_STRLEN]; // filename w/o  its extension
    PCHAR           module_FileName;                  // filename with its extension
    PCHAR           module_FullName;                  // full pathname
    RATE_DATA       Rate[];
} MODULE, *PMODULE;

typedef struct _RATE_SUMMARY {
    ULONGLONG   TotalCount;
    PMODULE    *Modules;
    ULONG       ModuleCount;
} RATE_SUMMARY, *PRATE_SUMMARY;

//
// Process related definitions
//
typedef struct _PROC_PERF_INFO {
    ULONG NumberOfThreads;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SIZE_T VirtualSize;
    ULONG HandleCount;
    ULONG PageFaultCount;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
//  If ever needed the following can be added
//    SIZE_T PeakVirtualSize;
//    SIZE_T PeakWorkingSetSize;
//    SIZE_T QuotaPeakPagedPoolUsage;
//    SIZE_T QuotaPeakNonPagedPoolUsage;
} PROC_PERF_INFO, *PPROC_PERF_INFO;

typedef struct _PROC_TO_MONITOR {
    struct    _PROC_TO_MONITOR *Next;
    HANDLE    ProcessHandle;
    LONGLONG  Pid;
    ULONG     Index;
    PCHAR     ProcessName;
    ULONG     ModuleCount;
    ULONG     ZoomCount;
    PMODULE   ModuleList;
    PMODULE   ZoomList;
    PSOURCE   Source;
    PROC_PERF_INFO ProcPerfInfoStart;
    PSYSTEM_THREAD_INFORMATION pProcThreadInfoStart; 
    PRTL_DEBUG_INFORMATION pProcDebugInfoStart;
    PRTL_DEBUG_INFORMATION pProcDebugInfoStop;
//MC
    DWORD    *JITHeapLocationsStart;
    DWORD    *JITHeapLocationsStop;
//MC
} PROC_TO_MONITOR, *PPROC_TO_MONITOR;


//
// These processor level enums should be defined in public headers.
// ntexapi.h - NtQuerySystemInformation( SystemProcessorInformation).
//
// For Now Define them locally.
//

typedef enum _PROCESSOR_FAMILY   {
    IA64_FAMILY_MERCED    = 0x7,
    IA64_FAMILY_ITANIUM   = IA64_FAMILY_MERCED,
    IA64_FAMILY_MCKINLEY  = 0x1f
} PROCESSOR_FAMILY;

#if defined(_IA64_)
#if 0
#define IA64ProcessorLevel2ProcessorFamily( (_ProcessorLevel >> 8) & 0xff )
#else 
//
// BUGBUG - Thierry - 02/20/2002
// Fix until SYSTEM_PROCESSOR_INFORMATION is fixed in the OS.
//
#ifndef CV_IA64_CPUID3
#define CV_IA64_CPUID3 3331
#endif 
__inline USHORT
IA64ProcessorLevel2ProcessorFamily( 
    USHORT ProcessorLevel
    )
{
    return( (USHORT)((__getReg(CV_IA64_CPUID3) >> 24) & 0xff));
}
#endif 
#endif // _IA64_

//
// The Following is Defined in pstat.h but not for Win2K
// The definition below allows for single source management for Win2K and above
//
#ifndef PSTAT_QUERY_EVENTS_INFO  
#define PSTAT_QUERY_EVENTS_INFO CTL_CODE (FILE_DEVICE_UNKNOWN, 5, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _EVENTS_INFO {
    ULONG           Events;
    ULONG           TokenMaxLength;
    ULONG           DescriptionMaxLength;
    ULONG           OfficialTokenMaxLength;
    ULONG           OfficialDescriptionMaxLength;
} EVENTS_INFO, *PEVENTS_INFO;
#endif

#ifndef RTL_QUERY_PROCESS_NONINVASIVE
#define RTL_QUERY_PROCESS_NONINVASIVE   0x80000000
#endif
//
//
//
typedef struct _TASK_LIST {
    LONGLONG        ProcessId;
    CHAR            ProcessName[PROCESS_SIZE];
    PSYSTEM_THREAD_INFORMATION pProcessThreadInfo;
    PROC_PERF_INFO  ProcessPerfInfo;
} TASK_LIST, *PTASK_LIST;

typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    ULONG       numtasks;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;

typedef struct _uint64div  {
   unsigned __int64 quot;
   unsigned __int64 rem;
} uint64div_t;

typedef struct _int64div  {
   __int64 quot;
   __int64 rem;
} int64div_t;

typedef struct _InputCount {
    UCHAR InputOption;
    SHORT Allowed;
    SHORT ActualCount;
} InputCount;

//
// Globals 
//

//
static CHAR        gUserSymbolPath[USER_SYMPATH_LENGTH];
static CHAR        gSymbolPath[TOTAL_SYMPATH_LENGTH];
static DWORD       gSymOptions;
PIMAGEHLP_SYMBOL64 gSymbol;
BOOL               bSymPathInitialized   = FALSE;
//
static PMODULE     gCurrentModule        = (PMODULE)0;
PMODULE            gCallbackCurrent;
ULONG              gZoomCount;
//
PSYSTEM_BASIC_INFORMATION gSysBasicInfo;
LONG                      gProfileProcessors;        //Actual being profiled
KAFFINITY                 gAffinityMask  = 0;        //Processor Afinity Mask for selected processor profiling      
ULONG                     gMaxSimultaneousSources;   //Maximum allowed number of sources that can be turned on simultaneously
CHAR                      gSystemProcessName[] = SYSTEM_PROCESS_NAME;

OSVERSIONINFO      gOSInfo;
HANDLE             ghDoneEvent;
BOOL               gProfilingDone        = FALSE;
//
ULONG              gNumProcToMonitor     = 0;        //Total Number of Processes To Monitor
ULONG              gKernelModuleCount    = 0;
PPROC_TO_MONITOR   gProcessList          = NULL; 
PPROC_TO_MONITOR   gpProcDummy;
PPROC_TO_MONITOR   gpSysProc             = NULL;
PMODULE            gCommonZoomList       = NULL;     //List of Zoom Modules Common to More Than One Process such as ntdll  
//
long double        gldElapsedSeconds;
ULONG              gTotalElapsedSeconds;             // Sum On All Processors
LARGE_INTEGER      gTotalElapsedTime64;
LARGE_INTEGER      gTotal2ElapsedTime64;
//
ULONG              gZoomBucket           = DEFAULT_ZOOM_BUCKET_SIZE;
ULONG              gLog2ZoomBucket       = DEFAULT_LOG2_ZOOM_BUCKET;
ULONG              gSourceMaximum        = 0;
ULONG              gStaticCount          = 0;
ULONG              gTotalActiveSources   = 0;
PSOURCE            gStaticSource         = NULL;
//
ULONG              gNumTasksStart;
ULONG              gNumTasksStop;
PTASK_LIST         gTlistStart;
double             gTotalIdleTime        = 0;
//MC
BOOL               bMCHelperLoaded       = FALSE;    //Is Managed Code Helper Library Loaded
BOOL               bMCJitRangesExist     = FALSE;    //Were any JIT ranges found
BOOL               bImageHlpSymbolFound  = FALSE;    //SymEnumerateSymbols64 found at least one symbol
HANDLE             ghMCLib               = NULL;     //Handle to MC helper IP2MC.DLL
WCHAR*             gwszSymbol;
//MC

//
// Print format for event strings
//
ULONG              gTokenMaxLen          = DEFAULT_TOKEN_MAX_LENGTH;
ULONG              gDescriptionMaxLen    = DEFAULT_DESCRIPTION_MAX_LENGTH;
//
//Verbose Output related
//
VERBOSE_DEFINITION VerboseDefinition[] = {
    { VERBOSE_NONE,       "None" },
    { VERBOSE_IMAGEHLP,   "Displays ImageHlp  Operations" },
    { VERBOSE_PROFILING,  "Displays Profiling Operations and Per Bucket Information Including Symbol Verification" },
    { VERBOSE_INTERNALS,  "Displays Internals Operations" },
    { VERBOSE_MODULES,    "Displays Modules   Operations" },
    { VERBOSE_NONE,       NULL }
};

ULONG  gVerbose                 = VERBOSE_NONE;
BOOL   bRoundingVerboseOutput   = FALSE;
//
// User command-line input related
//
typedef enum _INPUT_ERROR_TYPE {
    INPUT_GOOD           = 1,
    UNKNOWN_OPTION,
    BOGUS_ENTRY,
    MISSING_PARAMETER,
    MISSING_NUMBER,
    MISSING_REQUIRED_NUMBER,
    MISSING_STRING,
    MISSING_REQUIRED_STRING,
    INVALID_NUMBER
} INPUT_ERROR_TYPE;

typedef enum _INPUT_ORDER {
    ORDER_ANY,
    ORDER_STRING_FIRST,
    ORDER_NUMBER_FIRST
} INPUT_ORDER;

typedef enum _INPUT_OPTIONAL {
    OPTIONAL_ANY,
    OPTIONAL_STRING,
    OPTIONAL_NUMBER,
    OPTIONAL_NONE,
} INPUT_OPTIONAL;

BOOL   bCombinedProfile         = FALSE;	// Do Both Kernel and User Process(es)
LONG   gChangeInterval          = DEFAULT_SOURCE_CHANGE_INTERVAL;
BOOL   bWaitForUserInput        = FALSE;    // Wait for the user to press a key before starting the profile
BOOL   bWaitCreatedProcToSettle = FALSE;    // Indication that one or more processes were created via the -o option 
BOOL   bCreatedProcWaitForUserInput = FALSE; // Wait for the user to press a key to indicate a created process has settled (gone idle)
LONG   gSecondsToDelayProfile   = SECONDS_TO_DELAY_PROFILE; // Wait for N seconds before starting the profile
LONG   gSecondsToWaitCreatedProc = SECONDS_TO_WAIT_CREATED_PROC; // Wait for N seconds for a created process to settle (go idle)
LONG   gSleepInterval           = DEFAULT_SLEEP_INTERVAL; //Used to set the profile period
BOOL   bRawData                 = FALSE;
BOOL   bRawDisasm               = FALSE;
BOOL   bProfileByProcessor      = FALSE;    
BOOL   bGetInterestingData      = FALSE;    // Get Interesting statistics (turns on several sources, depends on hits, not guaratied)
BOOL   bOldSampling             = FALSE;    // Use new sampling scheme (start all sources and let them run simultaneously)
BOOL   bIncludeGeneralInfo      = TRUE;     // Include system-wide and process-specific information (such as context switches, memory usage, etc.) 
BOOL   bDisplayTaskSummary      = FALSE;
ULONG  gMaxTasks                = DEFAULT_MAX_TASKS; //Max Number of tasks accomodated in Kernrate's Task List
BOOL   bIncludeSystemLocksInfo  = FALSE;    // Get System lock contention info
BOOL   bIncludeUserProcLocksInfo= FALSE;    // Get User process lock contention info
ULONG  gLockContentionMinCount  = LOCK_CONTENTION_MIN_COUNT; // Default minimum count of lock contention for output processing
ULONG  gMinHitsToDisplay        = MIN_HITS_TO_DISPLAY;
BOOL   bProcessDataHighPriority = FALSE;    // User may opt to finish processing the collected data at high priority
                                            // This is useful on a very busy system if the momentary overhead is not an issue
BOOL   bSystemThreadsInfo       = FALSE;    // System-Process (kernel mode) threads 
BOOL   bIncludeThreadsInfo      = FALSE;    // Get thread info (it will then be gathered for all running tasks)

HANDLE ghInput = NULL, ghOutput = NULL, ghError = NULL;
//
// Most Static Sources desired intervals are computed to give approximately
// one interrupt per millisecond and be a nice even power of 2
//

enum _STATIC_SOURCE_TYPE  {
   SOURCE_TIME = 0,
};

// The following are defined in several headers,
// were supported on ALPHA, but they currently have no x86 KE/HAL support except for Time and AlignFixup
// Merced.c and Mckinley.c define the supported static sources on IA64 Merced/McKinley systems
// Amd64.c defines the supported static sources on Amd64 systems

SOURCE StaticSources[] = {
   {"Time",                     ProfileTime,                 "time"       , 1000, KRATE_DEFAULT_TIMESOURCE_RATE},
   {"Alignment Fixup",          ProfileAlignmentFixup,       "alignfixup" , 1,0},
   {"Total Issues",             ProfileTotalIssues,          "totalissues", 131072,0},
   {"Pipeline Dry",             ProfilePipelineDry,          "pipelinedry", 131072,0},
   {"Load Instructions",        ProfileLoadInstructions,     "loadinst"   , 65536,0},
   {"Pipeline Frozen",          ProfilePipelineFrozen,       "pilelinefrz", 131072,0},
   {"Branch Instructions",      ProfileBranchInstructions,   "branchinst" , 65536,0},
   {"Total Nonissues",          ProfileTotalNonissues,       "totalnoniss", 131072,0},
   {"Dcache Misses",            ProfileDcacheMisses,         "dcachemiss" , 16384,0},
   {"Icache Misses",            ProfileIcacheMisses,         "icachemiss" , 16384,0},
   {"Cache Misses",             ProfileCacheMisses,          "cachemiss"  , 16384,0},
   {"Branch Mispredictions",    ProfileBranchMispredictions, "branchpred" , 16384,0},
   {"Store Instructions",       ProfileStoreInstructions,    "storeinst"  , 65536,0},
   {"Floating Point Instr",     ProfileFpInstructions,       "fpinst"     , 65536,0},
   {"Integer Instructions",     ProfileIntegerInstructions,  "intinst"    , 65536,0},
   {"Dual Issues",              Profile2Issue,               "2issue"     , 65536,0},
   {"Triple Issues",            Profile3Issue,               "3issue"     , 16384,0},
   {"Quad Issues",              Profile4Issue,               "4issue"     , 16384,0},
   {"Special Instructions",     ProfileSpecialInstructions,  "specinst"   , 16384,0},
   {"Cycles",                   ProfileTotalCycles,          "totalcycles", 655360,0},
   {"Icache Issues",            ProfileIcacheIssues,         "icacheissue", 65536,0},
   {"Dcache Accesses",          ProfileDcacheAccesses,       "dcacheacces", 65536,0},
   {"MB Stall Cycles",          ProfileMemoryBarrierCycles,  "membarcycle", 32767,0},
   {"Load Linked Instructions", ProfileLoadLinkedIssues,     "loadlinkiss", 16384,0},
   {NULL, ProfileMaximum, "", 0, 0}
   };


#if defined(_IA64_)
#include "merced.c"
#include "mckinley.c"
#endif // _IA64_

#if defined(_AMD64_)
#include "amd64.c"
#endif // _AMD64_

//
// "Interesting Data" constituents
//
KPROFILE_SOURCE IData[] = {
#if defined(_IA64_)
   ProfileTotalIssues,          //This source must always be first in the array
   ProfileLoadInstructions,
   ProfileStoreInstructions,
   ProfileBranchInstructions,
   ProfileFpInstructions,
   ProfileIntegerInstructions,
   ProfileCacheMisses,
   ProfileIcacheMisses,
   ProfileDcacheMisses,
   ProfileBranchMispredictions,
   ProfileTotalCycles
#elif defined(_AMD64_)
    ProfileTotalIssues,
    ProfileBranchInstructions,
    ProfileFpInstructions,
    ProfileIcacheMisses,
    ProfileDcacheMisses,
    ProfileBranchMispredictions
#else
   ProfileTotalIssues
#endif

};

PULONG gulActiveSources;
//
// For checking command line input options for unallowed duplicates
// (0=no such option, -1=unlimited, -2 don't care) 
//
InputCount InputOption[] = {
    { 'A', 1, 0 },
    { 'B', 1, 0 },
    { 'C', 1, 0 },
    { 'D',-2, 0 },
    { 'E',-2, 0 },
    { 'F',-2, 0 },
    { 'G', 1, 0 },
    { 'H',-2, 0 },
    { 'I',-1, 0 },
    { 'J', 1, 0 },
    { 'K', 1, 0 },
    { 'L', 1, 0 },
    { 'M', 1, 0 },
    { 'N',-1, 0 },
    { 'O',-1, 0 },
    { 'P',-1, 0 },
    { 'Q', 0, 0 },
    { 'R',-2, 0 },
    { 'S', 1, 0 },
    { 'T', 1, 0 },
    { 'U',-2, 0 },
    { 'V',-1, 0 },
    { 'W', 2, 0 },
    { 'X', 1, 0 },
    { 'Y', 0, 0 },
    { 'Z',-1, 0 }
    };

InputCount wCount  = {'W', 1, 0};
InputCount wpCount = {'W', 1, 0};

//
// Function prototypes
//
VOID
CleanZoomModuleList(
    PPROC_TO_MONITOR Proc
    );

VOID
CreateDoneEvent(
    VOID
    );

//MC
BOOL
CreateJITZoomModuleCallback(
    IN PWCHAR  wszSymName,  
    IN LPSTR   szSymName,
    IN ULONG64 Address,
    IN ULONG   Size,
    IN PVOID   Cxt
    );
//MC

PMODULE
CreateNewModule(
    IN PPROC_TO_MONITOR ProcToMonitor,
    IN PCHAR   ModuleName,
    IN PCHAR   ModuleFullName,
    IN ULONG64 ImageBase,
    IN ULONG   ImageSize
    );

VOID
CreateProfiles(
    IN PMODULE          Root,
    IN PPROC_TO_MONITOR ProcToMonitor
    );

VOID
CreateZoomedModuleList(
    IN PMODULE          ZoomModule,
    IN ULONG            RoundDown,
    IN PPROC_TO_MONITOR pProc
    );

BOOL
CreateZoomModuleCallback(
    IN LPSTR   szSymName,
    IN ULONG64 Address,
    IN ULONG   Size,
    IN PVOID   Cxt
    );

VOID
DisplayRunningTasksSummary (
    PTASK_LIST pTaskStart,
    PTASK_LIST pTaskStop
    );

VOID
DisplaySystemWideInformation(
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SystemInfoBegin,
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION SystemInfoEnd
    );

VOID
DisplayTotalAndRate (
    LONGLONG StartCount,
    LONGLONG StopCount,
    long double RateAgainst,
    PCHAR CounterName,
    PCHAR RateAgainstUnits
    );

BOOL
EnumerateSymbolsByBuckets(
    IN HANDLE                      SymHandle,
    IN PMODULE                     Current,
    IN PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    IN PVOID                       pProc
    );


VOID
ExecuteProfiles(
    BOOL bMode
    );

VOID
ExitWithMissingEntryMessage(
    PCHAR CurrentOption,
    PCHAR Remark,
    BOOL  bUsage
    );

VOID
ExitWithUnknownOptionMessage(
    PCHAR CurrentOption
    );

PMODULE
FindModuleForAddress64(    
     PPROC_TO_MONITOR   ProcToMonitor,
     DWORD64            Address
     );

VOID
GetConfiguration(
    int argc,
    char *argv[]
    );

PMODULE
GetKernelModuleInformation(
    VOID
    );

VOID
GetProcessLocksInformation (
    PPROC_TO_MONITOR ProcToMonitor,
    ULONG Flags,
    ACTION_TYPE Action
    );

PMODULE
GetProcessModuleInformation(
    IN PPROC_TO_MONITOR   ProcToMonitor
    );

VOID
GetProfileSystemInfo(
    ACTION_TYPE Action
    );

PSYSTEM_BASIC_INFORMATION
GetSystemBasicInformation(
    VOID
    );

VOID
GetSystemLocksInformation (
    ACTION_TYPE Action
    );

DWORD
GetTaskList(
    PTASK_LIST      pTask,
    ULONG           NumTasks
    );

ULONG
HandleRedirections(
    IN  PCHAR  cmdLine,
    IN  ULONG  nCharsStart,
    OUT HANDLE *hInput,
    OUT HANDLE *hOutput,
    OUT HANDLE *hError
    );

BOOL
HitsFound(
    IN PPROC_TO_MONITOR pProc,
    IN ULONG BucketIndex
    );

VOID
InitAllProcessesModulesInfo(
    VOID
    );

BOOL
InitializeAsDebugger(VOID);

BOOL
InitializeKernelProfile(VOID);

VOID
InitializeKernrate(
    int argc,
    char *argv[]
    );

PPROC_TO_MONITOR
InitializeProcToMonitor(
    LONGLONG Pid
    );

ULONG
InitializeProfileSourceInfo (
    PPROC_TO_MONITOR ProcToMonitor
    );

VOID
InitSymbolPath(
    HANDLE SymHandle
    );

VOID
InvalidEntryMessage(
    PCHAR CurrentOption,
    PCHAR CurrentValue,
    PCHAR Remark,
    BOOL  bUsage,
    BOOL  bExit
    );

INPUT_ERROR_TYPE
IsInputValid(int    argc,
               int    OptionIndex,
               PCHAR  *Option,
               PCHAR  AllowedTrailLetters,
               PLONG  AssociatedNumber,
               PCHAR  AssociatedString,
               ULONG  MaxStringLength,
               INPUT_ORDER Order,
               INPUT_OPTIONAL Optional
               );

BOOL
IsStringANumber(
    IN  PCHAR String
    );

ULONG
NextSource(
    IN ULONG            CurrentSource,
    IN PMODULE          ModuleList,
    IN PPROC_TO_MONITOR ProcToMonitor
    );

VOID
OutputInterestingData(
    IN FILE      *Out,
    IN RATE_DATA Data[]
    );

VOID
OutputLine(
    IN FILE             *Out,
    IN ULONG            ProfileSourceIndex,
    IN PMODULE          Module,
    IN PRATE_SUMMARY    RateSummary,
    IN PPROC_TO_MONITOR ProcToMonitor
    );

VOID
OutputLineFromAddress64(
     HANDLE           hProc,
     DWORD64 	      qwAddr,
     PIMAGEHLP_LINE64 pLine
     );

VOID
OutputLocksInformation(
    PRTL_PROCESS_LOCKS pLockInfoStart,
    PRTL_PROCESS_LOCKS pLockInfoStop,
    PPROC_TO_MONITOR   Proc
    );

VOID
OutputModuleList(
    IN FILE             *Out,
    IN PMODULE          ModuleList,
    IN ULONG            NumberModules,
    IN PPROC_TO_MONITOR ProcToMonitor,
    IN PMODULE          Parent
    );

VOID
OutputPercentValue (
    LONGLONG StartCount,
    LONGLONG StopCount,
    LARGE_INTEGER Base,
    PCHAR CounterName
    );

VOID
OutputProcessPerfInfo (
    PTASK_LIST      pTask,
    ULONG           NumTasks,
    PPROC_TO_MONITOR ProcToMonitor
    );

VOID
OutputRawDataForZoomModule(
    IN FILE *Out,
    IN PPROC_TO_MONITOR ProcToMonitor,
    IN PMODULE Current
    );

VOID
OutputResults(
    IN FILE             *Out,
    IN PPROC_TO_MONITOR ProcToMonitor
    );

VOID
OutputStartStopValues (
    SIZE_T StartCount,
    SIZE_T StopCount,
    PCHAR CounterName
    );

VOID
OutputThreadInfo (
    PTASK_LIST       pTask,
    DWORD            TaskNumber,
    PPROC_TO_MONITOR ProcToMonitor
    );

BOOL
PrivEnumerateSymbols(
    IN HANDLE                      SymHandle,
    IN PMODULE                     Current,
    IN PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    IN PVOID                       pProc,
    IN DWORD64                     BaseOptional,
    IN ULONG                       SizeOptional
    );

VOID
SetProfileSourcesRates(
    PPROC_TO_MONITOR ProcToMonitor
    );

VOID
StartSource(
    IN ULONG            ProfileSource,
    IN PMODULE          ModuleList,
    IN PPROC_TO_MONITOR ProcToMonitor
    );

VOID
StopSource(
    IN ULONG            ProfileSourceIndex,
    IN PMODULE          ModuleList,
    IN PPROC_TO_MONITOR ProcToMonitor
    );

BOOL
TkEnumerateSymbols(
    IN HANDLE                      SymHandle,
    IN PMODULE                     Current,
    IN PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    IN PVOID                       pProc
    );

VOID
UpdateProcessStartInfo(
    PPROC_TO_MONITOR ProcToMonitor,
    PTASK_LIST TaskListEntry,
    BOOL  bIncludeProcessThreadsInfo
    );

VOID
vVerbosePrint(
     ULONG     Level,
     PCCHAR    Msg,
     ...
     );

//MC
//
// Note: CLR currently does not support 64 bit. 
//
// AttachToProcess is not reentrant, even for different PIDs!
// only call once and pair with DetachFromProcess.
extern void AttachToProcess(DWORD dwPid);
extern void DetachFromProcess();

// 0 is error
// 1 is normal JIT
// 2 is ngen (prejitted module)
// wszResult contains class/method (string) of given IP address
// Note: The space is allocated by the routine itself! 
extern int IP2MD(DWORD_PTR test,WCHAR** wszResult);

// return value is array of DWORDs, stored in pairs, null terminated.
// first dword is start address, second dword is length.
extern DWORD* GetJitRange();

typedef void (*PFN1)(DWORD);
PFN1 pfnAttachToProcess; 

typedef void (*PFN2)(VOID);
PFN2 pfnDetachFromProcess;

typedef int  (*PFN3)(DWORD_PTR, WCHAR**);
PFN3 pfnIP2MD;

typedef DWORD* (*PFN4)(VOID);
PFN4 pfnGetJitRange;

BOOL
InitializeManagedCodeSupport(
     PPROC_TO_MONITOR   ProcToMonitor
    );
 
BOOL
JITEnumerateSymbols(
    IN PMODULE                     Current,
    IN PVOID                       pProc,
    IN DWORD64                     BaseOptional,
    IN ULONG                       SizeOptional
    );

VOID
OutputJITRangeComparison(
     PPROC_TO_MONITOR   ProcToMonitor
    );

//MC

PCHAR WaitReason [] = {
    {"Executive"},
    {"FreePage"},
    {"PageIn"},
    {"PoolAllocation"},
    {"DelayExecution"},
    {"Suspended"},
    {"UserRequest"},
    {"WrExecutive"},
    {"WrFreePage"},
    {"WrPageIn"},
    {"WrPoolAllocation"},
    {"WrDelayExecution"},
    {"WrSuspended"},
    {"WrUserRequest"},
    {"WrEventPair"},
    {"WrQueue"},
    {"WrLpcReceive"},
    {"WrLpcReply"},
    {"WrVirtualMemory"},
    {"WrPageOut"},
    {"WrRendezvous"},
    {"Spare2"},
    {"Spare3"},
    {"Spare4"},
    {"Spare5"},
    {"Spare6"},
    {"WrKernel"},
    {"WrResource"},
    {"WrPushLock"},
    {"WrMutex"},
    {"WrQuantumEnd"},
    {"WrDispatchInt"},
    {"WrPreempted"},
    {"WrYieldExecution"},
    {"MaximumWaitReason"}
    };

PCHAR ThreadState[] = {
    {"Initialized"},
    {"Ready"},
    {"Running"},
    {"Standby"},
    {"Terminated"},
    {"Waiting"},
    {"Transition"},
    {"DeferredReady"}
    };

#endif /* !KERNRATE_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\ntsdexts\leak.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:


Revision History:

--*/

#include "ntsdextp.h"


//
// Lists threads sorted by CPU time consumed, in order to 
// track runaway threads
//

typedef struct _INTERESTING_THREAD_INFO {
    ULONG_PTR       ThreadId ;
    ULONG_PTR       Flags ;
    LARGE_INTEGER   UserTime ;
    LARGE_INTEGER   KernelTime ;
    LARGE_INTEGER   ElapsedTime ;
} INTERESTING_THREAD_INFO, * PINTERESTING_THREAD_INFO ;

#define ITI_USER_DONE       0x00000001
#define ITI_KERNEL_DONE     0x00000002
#define ITI_ELAPSED_DONE    0x00000004

DECLARE_API( runaway )
{
    PROCESS_BASIC_INFORMATION ProcessInfo ;
    PSYSTEM_PROCESS_INFORMATION SystemInfo ;
    PSYSTEM_PROCESS_INFORMATION Walk ;
    PSYSTEM_THREAD_INFORMATION ThreadInfo ;
    PINTERESTING_THREAD_INFO Threads ;
    NTSTATUS Status ;
    ULONG Flags = 1 ;
    ULONG i, j, Found ;
    LARGE_INTEGER Now ;
    LARGE_INTEGER Compare ;
    TIME_FIELDS Time ;

    INIT_API();

    if (sscanf( args, "%x", &Flags ) == 0) {
        goto Exit;
    }

    Status = NtQueryInformationProcess(
                    g_hCurrentProcess,
                    ProcessBasicInformation,
                    &ProcessInfo,
                    sizeof( ProcessInfo ),
                    NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        dprintf( "could not get process information, %d\n",
                 RtlNtStatusToDosError( Status ) );
        goto Exit;
    }

    SystemInfo = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    1024 * sizeof( SYSTEM_PROCESS_INFORMATION ) );

    if ( !SystemInfo )
    {
        dprintf( "not enough memory\n" );
        goto Exit;
    }

    Status = NtQuerySystemInformation(
                    SystemProcessInformation,
                    SystemInfo,
                    1024 * sizeof( SYSTEM_PROCESS_INFORMATION ),
                    NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        dprintf( "unable to get system information\n" );

        RtlFreeHeap(
                RtlProcessHeap(),
                0,
                SystemInfo );

        goto Exit;
    }

    //
    // First, find the process:
    //
    
    Walk = SystemInfo ;

    while ( HandleToUlong( Walk->UniqueProcessId ) != ProcessInfo.UniqueProcessId )
    {
        if ( Walk->NextEntryOffset == 0 )
        {
            Walk = NULL ;
            break;
        }

        Walk = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) Walk + Walk->NextEntryOffset );

    }

    if ( !Walk )
    {
        dprintf( "unable to find process\n" );

        RtlFreeHeap( RtlProcessHeap(), 0, SystemInfo );

        goto Exit;
    }

    //
    // Now, walk the threads
    //

    ThreadInfo = (PSYSTEM_THREAD_INFORMATION) (Walk + 1);

    Threads = RtlAllocateHeap( 
                    RtlProcessHeap(),
                    0,
                    sizeof( INTERESTING_THREAD_INFO ) * Walk->NumberOfThreads );

    if ( !Threads )
    {
        dprintf( "not enough memory\n" );

        RtlFreeHeap(
                RtlProcessHeap(),
                0,
                SystemInfo );

        goto Exit;
    }

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );

    for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
    {
        Threads[ i ].Flags = 0 ;
        Threads[ i ].ThreadId = HandleToUlong( ThreadInfo[ i ].ClientId.UniqueThread );
        Threads[ i ].ElapsedTime.QuadPart = Now.QuadPart - ThreadInfo[ i ].CreateTime.QuadPart ;
        Threads[ i ].KernelTime = ThreadInfo[ i ].KernelTime ;
        Threads[ i ].UserTime = ThreadInfo[ i ].UserTime ;

    }

    //
    // Scan through the list of threads (in an ugly, bubble-ish sort
    // of way), and display the threads in order of time, once per time
    // field, by way of the flags:
    //

    if ( Flags & ITI_USER_DONE )
    {
        j = Walk->NumberOfThreads ;

        Found = 0 ;
        
        dprintf( " User Mode Time\n" );
        dprintf( " Thread    Time\n" );

        while ( j-- )
        {
            Compare.QuadPart = 0 ;
            for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
            {
                if ( ( ( Threads[ i ].Flags & ITI_USER_DONE ) == 0 ) && 
                     ( Threads[ i ].UserTime.QuadPart >= Compare.QuadPart ) )
                {
                    Compare.QuadPart = Threads[ i ].UserTime.QuadPart ;
                    Found = i ;
                }
            }

            Threads[ Found ].Flags |= ITI_USER_DONE ;

            RtlTimeToElapsedTimeFields( &Compare, &Time );

            dprintf( " %-3x      %3ld:%02ld:%02ld.%04ld\n",
                        Threads[ Found ].ThreadId,
                        Time.Hour,
                        Time.Minute,
                        Time.Second,
                        Time.Milliseconds );

        }

    }

    if ( Flags & ITI_KERNEL_DONE )
    {
        j = Walk->NumberOfThreads ;

        Found = 0 ;
        
        dprintf( " Kernel Mode Time\n" );
        dprintf( " Thread    Time\n" );

        while ( j-- )
        {
            Compare.QuadPart = 0 ;
            for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
            {
                if ( ( ( Threads[ i ].Flags & ITI_KERNEL_DONE ) == 0 ) && 
                     ( Threads[ i ].KernelTime.QuadPart >= Compare.QuadPart ) )
                {
                    Compare.QuadPart = Threads[ i ].KernelTime.QuadPart ;
                    Found = i ;
                }
            }

            Threads[ Found ].Flags |= ITI_KERNEL_DONE ;

            RtlTimeToElapsedTimeFields( &Compare, &Time );

            dprintf( " %-3x      %3ld:%02ld:%02ld.%04ld\n",
                        Threads[ Found ].ThreadId,
                        Time.Hour,
                        Time.Minute,
                        Time.Second,
                        Time.Milliseconds );

        }

    }

    if ( Flags & ITI_ELAPSED_DONE )
    {
        j = Walk->NumberOfThreads ;

        Found = 0 ;
        
        dprintf( " Elapsed Time\n" );
        dprintf( " Thread    Time\n" );

        while ( j-- )
        {
            Compare.QuadPart = 0 ;
            for ( i = 0 ; i < Walk->NumberOfThreads ; i++ )
            {
                if ( ( ( Threads[ i ].Flags & ITI_ELAPSED_DONE ) == 0 ) && 
                     ( Threads[ i ].ElapsedTime.QuadPart >= Compare.QuadPart ) )
                {
                    Compare.QuadPart = Threads[ i ].ElapsedTime.QuadPart ;
                    Found = i ;
                }
            }

            Threads[ Found ].Flags |= ITI_ELAPSED_DONE ;

            RtlTimeToElapsedTimeFields( &Compare, &Time );

            dprintf( " %-3x      %3ld:%02ld:%02ld.%04ld\n",
                        Threads[ Found ].ThreadId,
                        Time.Hour,
                        Time.Minute,
                        Time.Second,
                        Time.Milliseconds );

        }

    }

    if ( SystemInfo )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, SystemInfo );
    }

 Exit:
    EXIT_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\ntsdexts\ntsdexts.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Revision History:

    Daniel Mihai (DMihai) 18-Feb-2001

    Add !htrace - useful for dumping handle trace information.
--*/

#include "ntsdextp.h"

DECLARE_API( version )
{
    OSVERSIONINFOA VersionInformation;
    HKEY hkey;
    DWORD cb, dwType;
    CHAR szCurrentType[128];
    CHAR szCSDString[3+128];

    INIT_API();

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        dprintf("GetVersionEx failed - %u\n", GetLastError());
        goto Exit;
        }

    szCurrentType[0] = '\0';
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\Windows NT\\CurrentVersion",
                     0,
                     KEY_READ,
                     &hkey
                    ) == NO_ERROR
       ) {
        cb = sizeof(szCurrentType);
        if (hkey) {
            if (RegQueryValueEx(hkey, "CurrentType", NULL, &dwType, szCurrentType, &cb ) != 0) {
                szCurrentType[0] = '\0';
            }
            RegCloseKey(hkey);
        }
    }

    if (VersionInformation.szCSDVersion[0]) {
        _snprintf(szCSDString, sizeof(szCSDString) / sizeof(szCSDString[0]), ": %s", VersionInformation.szCSDVersion);
        szCSDString[(sizeof(szCSDString) / sizeof(szCSDString[0])) - 1] = 0;
        }
    else {
        szCSDString[0] = '\0';
        }

    dprintf("Version %d.%d (Build %d%s) %s\n",
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          szCSDString,
          szCurrentType
         );

 Exit:
    EXIT_API();
}

DECLARE_API( help )
{
    INIT_API();

    while (*args == ' ')
        args++;

    if (*args == '\0') {
        dprintf("ntsdexts help:\n\n");
        dprintf("!critSec csAddress           - Dump a critical section\n");
        dprintf("!dp [v] [pid | pcsr_process] - Dump CSR process\n");
        dprintf("!dreg -[d|w] <keyPath>[![<valueName> | *]]  - Dump registry information\n");
        dprintf("!dt [v] pcsr_thread          - Dump CSR thread\n");
        dprintf("!error value                 - Decode error value\n");
        dprintf("!gatom                       - Dump the global atom table\n");
        dprintf("!handle [handle]             - Dump handle information\n");
        dprintf("!help [cmd]                  - Displays this list or gives details on command\n");
        dprintf("!locks [-v][-o]              - Dump all Critical Sections in process\n");
        dprintf("!version                     - Dump system version and build number\n");

    } else {
        if (*args == '!')
            args++;
        if (strcmp( args, "handle") == 0) {
            dprintf("!handle [handle [flags [type]]] - Dump handle information\n");
            dprintf("       If no handle specified, all handles are dumped.\n");
            dprintf("       Flags are bits indicating greater levels of detail.\n");
            dprintf("If the handle is 0 or -1, all handles are scanned.  If the handle is not\n");
            dprintf("zero, that particular handle is examined.  The flags are as follows:\n");
            dprintf("    1   - Get type information (default)\n");
            dprintf("    2   - Get basic information\n");
            dprintf("    4   - Get name information\n");
            dprintf("    8   - Get object specific info (where available)\n");
            dprintf("\n");
            dprintf("If Type is specified, only object of that type are scanned.  Type is a\n");
            dprintf("standard NT type name, e.g. Event, Semaphore, etc.  Case sensitive, of\n");
            dprintf("course.\n");
            dprintf("\n");
            dprintf("Examples:\n");
            dprintf("\n");
            dprintf("    !handle     -- dumps the types of all the handles, and a summary table\n");
            dprintf("    !handle 0 0 -- dumps a summary table of all the open handles\n");
            dprintf("    !handle 0 f -- dumps everything we can find about a handle.\n");
            dprintf("    !handle 0 f Event\n");
            dprintf("                -- dumps everything we can find about open events\n");
        } else if (strcmp( args, "gflag") == 0) {
            dprintf("If a value is not given then displays the current bits set in\n");
            dprintf("NTDLL!NtGlobalFlag variable.  Otherwise value can be one of the\n");
            dprintf("following:\n");
            dprintf("\n");
            dprintf("    -? - displays a list of valid flag abbreviations\n");
            dprintf("    number - 32-bit number that becomes the new value stored into\n");
            dprintf("             NtGlobalFlag\n");
            dprintf("    +number - specifies one or more bits to set in NtGlobalFlag\n");
            dprintf("    +abbrev - specifies a single bit to set in NtGlobalFlag\n");
            dprintf("    -number - specifies one or more bits to clear in NtGlobalFlag\n");
            dprintf("    -abbrev - specifies a single bit to clear in NtGlobalFlag\n");
        } else {
            dprintf("Invalid command.  No help available\n");
        }
    }

    EXIT_API();
}

VOID
DumpStackBackTraceIndex(
    IN USHORT BackTraceIndex
    )
{
#if i386
    BOOL b;
    PRTL_STACK_TRACE_ENTRY pBackTraceEntry;
    RTL_STACK_TRACE_ENTRY BackTraceEntry;
    ULONG i;
    CHAR Symbol[ 1024 ];
    ULONG_PTR Displacement;

    ULONG NumberOfEntriesAdded;
    PRTL_STACK_TRACE_ENTRY *EntryIndexArray;    // Indexed by [-1 .. -NumberOfEntriesAdded]

    PSTACK_TRACE_DATABASE *pRtlpStackTraceDataBase;
    PSTACK_TRACE_DATABASE RtlpStackTraceDataBase;
    STACK_TRACE_DATABASE StackTraceDataBase;



    pRtlpStackTraceDataBase = (PSTACK_TRACE_DATABASE *)GetExpression( "NTDLL!RtlpStackTraceDataBase" );

    if (pRtlpStackTraceDataBase == NULL) {

        dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpStackTraceDataBase\n" );
    }

    if ((BackTraceIndex != 0) && (pRtlpStackTraceDataBase != NULL)) {

        b = ReadMemory( (ULONG_PTR)pRtlpStackTraceDataBase,
                        &RtlpStackTraceDataBase,
                        sizeof( RtlpStackTraceDataBase ),
                        NULL
                      );

        if (!b || RtlpStackTraceDataBase == NULL) {

            return;
        }

        b = ReadMemory( (ULONG_PTR)RtlpStackTraceDataBase,
                        &StackTraceDataBase,
                        sizeof( StackTraceDataBase ),
                        NULL
                      );
        if (!b) {

            return;
        }


        if (BackTraceIndex < StackTraceDataBase.NumberOfEntriesAdded) {

            b = ReadMemory( (ULONG_PTR)(StackTraceDataBase.EntryIndexArray - BackTraceIndex),
                            &pBackTraceEntry,
                            sizeof( pBackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace index (%x) entry at %p\n",
                         BackTraceIndex,
                         (StackTraceDataBase.EntryIndexArray - BackTraceIndex)
                         );
                return;
            }

            b = ReadMemory( (ULONG_PTR)pBackTraceEntry,
                            &BackTraceEntry,
                            sizeof( BackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace entry at %p\n",
                         pBackTraceEntry
                         );
                return;
            }

            dprintf( "\n    Stack trace (%u) at %x:\n", BackTraceIndex, pBackTraceEntry );

            for (i=0; i<BackTraceEntry.Depth; i++) {

                GetSymbol( (LPVOID)BackTraceEntry.BackTrace[ i ],
                           Symbol,
                           &Displacement
                           );

                dprintf( "        %08x: %s", BackTraceEntry.BackTrace[ i ], Symbol );

                if (Displacement != 0) {
                    dprintf( "+0x%p", Displacement );
                }

                dprintf( "\n" );
            }
        }
    }
#endif
    return;
}


PLIST_ENTRY
DumpCritSec(
    DWORD_PTR dwAddrCritSec,
    DWORD_PTR dwAddrDebugInfo,
    BOOLEAN bDumpIfUnowned,
    BOOLEAN bOrphaned
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the contents of the specified critical section.

Arguments:


    dwAddrCritSec - Supplies the address of the critical section to
        be dumped or NULL if dumping via debug info

    dwAddrDebugInfo - Supllies the address of a critical section debug info
        struct to be dumped or NULL if the critical section address is passed in

    bDumpIfUnowned - TRUE means to dump the critical section even if
        it is currently unowned.

    bOrphaned - TRUE: means that the caller only wants to know if the debuginfo does
        not point to a valid critical section

Return Value:

    Pointer to the next critical section in the list for the process or
    NULL if no more critical sections.

--*/

{
    USHORT i;
    CHAR Symbol[1024];
    DWORD_PTR Displacement;
    CRITICAL_SECTION CriticalSection;
    CRITICAL_SECTION_DEBUG DebugInfo;
    BOOL b;
    PLIST_ENTRY              Next=NULL;


    if (dwAddrDebugInfo != (DWORD_PTR)NULL) {
        //
        //  the address of the debug info was passes in, read it in from the debugged process
        //
        b = ReadMemory( dwAddrDebugInfo,
                        &DebugInfo,
                        sizeof(DebugInfo),
                        NULL
                      );
        if ( !b ) {

            dprintf(" NTSDEXTS: Unable to read RTL_CRITICAL_SECTION_DEBUG at %p\n", dwAddrDebugInfo );
            return NULL;
        }

        //
        //  get the critical section from the debug info
        //
        dwAddrCritSec=(DWORD_PTR)DebugInfo.CriticalSection;

        //
        //  set the next pointer now. It is only used when the debuginfo is passed in
        //
        Next=DebugInfo.ProcessLocksList.Flink;

    } else {
        //
        //  the debug info address was zero, the critical section address better not be too
        //
        if (dwAddrCritSec == (DWORD_PTR)NULL) {
            //
            //  If the debuginfo value was not valid, then the critical section value must be
            //
            return NULL;
        }
    }

    //
    //  we should now have a pointer to the critical section, either passed in or read from
    //  the debug info
    //
    //
    // Read the critical section from the debuggees address space into our
    // own.
    //
    b = ReadMemory( dwAddrCritSec,
            &CriticalSection,
               sizeof(CriticalSection),
               NULL
            );

    if ( !b ) {

        if (bDumpIfUnowned || bOrphaned) {

            dprintf("\nCritSec at %p could not be read\n",dwAddrCritSec);
            dprintf("Perhaps the critical section was a global variable in a dll that was unloaded?\n");

            if (dwAddrDebugInfo != (DWORD_PTR)NULL) {

                if (bOrphaned) {

                    DumpStackBackTraceIndex(DebugInfo.CreatorBackTraceIndex);
                }
            }
        }
        return Next;

    }

    if (dwAddrDebugInfo != (DWORD_PTR)NULL) {
        //
        //  the debug info address was passed in, make sure the critical section that
        //  it pointed to points back to it.
        //
        if ((DWORD_PTR)CriticalSection.DebugInfo != dwAddrDebugInfo) {
            //
            //  this critical section does not point back to debug info that we got it from
            //
            CRITICAL_SECTION_DEBUG OtherDebugInfo;

            //
            //  now lets try to read in the debug info that this critical section points to,
            //  to see if it does point back the critical section in question
            //
            ZeroMemory(&OtherDebugInfo,sizeof(OtherDebugInfo));

            b = ReadMemory( (ULONG_PTR)CriticalSection.DebugInfo,
                            &OtherDebugInfo,
                            sizeof(DebugInfo),
                            NULL
                          );
            if ( !b ) {
                //
                //  we could not read the debug info pointed to by the critical section,
                //  probably means the critical section has been trashed
                //
                if (bDumpIfUnowned || bOrphaned) {

                    dprintf("\nCritSec at %p does not point back to the debug info at %p\n",dwAddrCritSec,dwAddrDebugInfo);
                    dprintf("Perhaps the memory that held the critical section has been reused without calling DeleteCriticalSection() ?\n");

                    if (bOrphaned) {

                        DumpStackBackTraceIndex(DebugInfo.CreatorBackTraceIndex);
                    }
                }

            } else {
                //
                //  we were able to read in the debug info, see if it points to this new
                //  critical section
                //
                if ((DWORD_PTR)OtherDebugInfo.CriticalSection == dwAddrCritSec) {
                    //
                    //  the debug info points back to the critical section.
                    //  The definitely means that it was re-initialized.
                    //
                    if (bDumpIfUnowned || bOrphaned) {

                        GetSymbol((LPVOID)dwAddrCritSec,Symbol,&Displacement);
                        dprintf(
                            "\nThe CritSec %s+%lx at %p has been RE-INITIALIZED.\n",
                            Symbol,
                            Displacement,
                            dwAddrCritSec
                            );

                        dprintf("The critical section points to DebugInfo at %p instead of %p\n",(DWORD_PTR)CriticalSection.DebugInfo,dwAddrDebugInfo);

                        if (bOrphaned) {

                            DumpStackBackTraceIndex(DebugInfo.CreatorBackTraceIndex);
                        }

                    }

                } else {
                    //
                    //  The debug info does not point back the critical section, probably means that
                    //  the critical section was trashed
                    //
                    if (bDumpIfUnowned || bOrphaned) {

                        dprintf("\nCritSec at %p does not point back to the debug info at %p\n",dwAddrCritSec,dwAddrDebugInfo);
                        dprintf("Perhaps the memory that held the critical section has been reused without calling DeleteCriticalSection() ?\n");

                        if (bOrphaned) {

                            DumpStackBackTraceIndex(DebugInfo.CreatorBackTraceIndex);
                        }
                    }
                }
            }
        }

    } else {
        //
        //  we need to read in the debug info from the critical section since it was not passed in
        //
        ZeroMemory(&DebugInfo,sizeof(DebugInfo));

        b = ReadMemory( (ULONG_PTR)CriticalSection.DebugInfo,
                        &DebugInfo,
                        sizeof(DebugInfo),
                        NULL
                      );
        if ( !b ) {
            //
            //  use this to signal that we could not read the debuginfo for the critical section
            //
            CriticalSection.DebugInfo=NULL;

            dprintf("\nDebugInfo for CritSec at %p could not be read\n",dwAddrCritSec);
            dprintf("Probably NOT an initialized critical section.\n");

        } else {
            //
            //  we were able to read in the debug info, see if it valid
            //
            if ((DWORD_PTR)DebugInfo.CriticalSection != dwAddrCritSec) {
                //
                //  The debug info does not point back to the critical section
                //
                dprintf("\nDebugInfo for CritSec at %p does not point back to the critical section\n",dwAddrCritSec);
                dprintf("NOT an initialized critical section.\n");
            }
        }
    }

    //
    //  we should now have read in both the critical section and debug info for that critical section
    //
    if (bOrphaned) {
        //
        //  the user only wanted to check for orphaned critical sections
        //
        return Next;
    }

    //
    // Dump the critical section
    //

    if ( CriticalSection.LockCount == -1 && !bDumpIfUnowned) {
        //
        //  Lock is not held and the user does not want verbose output
        //
        return Next;
    }

    //
    // Get the symbolic name of the critical section
    //

    dprintf("\n");
    GetSymbol((LPVOID)dwAddrCritSec,Symbol,&Displacement);
    dprintf(
        "CritSec %s+%lx at %p\n",
        Symbol,
        Displacement,
        dwAddrCritSec
        );

    if ( CriticalSection.LockCount == -1) {

        dprintf("LockCount          NOT LOCKED\n");

    } else {

        dprintf("LockCount          %ld\n",CriticalSection.LockCount);
    }

    dprintf("RecursionCount     %ld\n",CriticalSection.RecursionCount);
    dprintf("OwningThread       %lx\n",CriticalSection.OwningThread);

    if (CriticalSection.DebugInfo != NULL) {
        //
        //  we have the debug info
        //
        dprintf("EntryCount         %lx\n",DebugInfo.EntryCount);
        dprintf("ContentionCount    %lx\n",DebugInfo.ContentionCount);

    }

    if ( CriticalSection.LockCount != -1) {

        dprintf("*** Locked\n");
    }

    return Next;
}

DECLARE_API( critsec )
{
    DWORD_PTR dwAddrCritSec;

    INIT_API();

    //
    // Evaluate the argument string to get the address of
    // the critical section to dump.
    //

    dwAddrCritSec = GetExpression(args);
    if ( !dwAddrCritSec ) {
        goto Exit;
        }

    DumpCritSec(dwAddrCritSec,0,TRUE,FALSE);

 Exit:
    EXIT_API();
}


DECLARE_API( locks )

/*++

Routine Description:

    This function is called as an NTSD extension to display all
    critical sections in the target process.

Return Value:

    None.

--*/

{
    BOOL b;
    CRITICAL_SECTION_DEBUG DebugInfo;
    PVOID AddrListHead;
    LIST_ENTRY ListHead;
    PLIST_ENTRY Next;
    BOOLEAN Verbose;
    BOOLEAN Orphaned=FALSE;
    LPCSTR p;
    DWORD   NumberOfCriticalSections;

    INIT_API();

    Verbose = FALSE;
    p = (LPSTR)args;
    while ( p != NULL && *p ) {
        if ( *p == '-' ) {
            p++;
            switch ( *p ) {
                case 'V':
                case 'v':
                    Verbose = TRUE;
                    p++;
                    break;

                case 'o':
                case 'O':
                    Orphaned=TRUE;
                    p++;
                    break;


                case ' ':
                    goto gotBlank;

                default:
                    dprintf( "NTSDEXTS: !locks invalid option flag '-%c'\n", *p );
                    break;

                }
            }
        else {
gotBlank:
            p++;
            }
        }

    if (Orphaned) {

        dprintf( "Looking for orphaned critical sections\n" );
    }
    //
    // Locate the address of the list head.
    //

    AddrListHead = (PVOID)GetExpression("ntdll!RtlCriticalSectionList");
    if ( !AddrListHead ) {
        dprintf( "NTSDEXTS: Unable to resolve ntdll!RtlCriticalSectionList\n" );
        dprintf( "NTSDEXTS: Please check your symbols\n" );
        goto Exit;
        }

    //
    // Read the list head
    //

    b = ReadMemory( (ULONG_PTR)AddrListHead,
                    &ListHead,
                    sizeof(ListHead),
                    NULL
                  );
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read memory at ntdll!RtlCriticalSectionList\n" );
        goto Exit;
        }

    Next = ListHead.Flink;

    (CheckControlC)();

    NumberOfCriticalSections=0;
    //
    // Walk the list of critical sections
    //
    while ( Next != AddrListHead ) {

        Next=DumpCritSec(
            0,
            (DWORD_PTR)CONTAINING_RECORD( Next, RTL_CRITICAL_SECTION_DEBUG, ProcessLocksList),
            Verbose,
            Orphaned
            );


        if (Next == NULL) {

            dprintf( "\nStopped scanning because of problem reading critical section debug info\n");

            break;
        }

        NumberOfCriticalSections++;

        if ((CheckControlC)()) {

            dprintf( "\nStopped scanning because of control-C\n");

            break;
        }

    }

    dprintf( "\nScanned %d critical sections\n",NumberOfCriticalSections);

 Exit:
    EXIT_API();
}


//
// Simple routine to convert from hex into a string of characters.
// Used by debugger extensions.
//
// by scottlu
//

char *
HexToString(
    ULONG_PTR dw,
    CHAR *pch
    )
{
    if (dw > 0xf) {
        pch = HexToString(dw >> 4, pch);
        dw &= 0xf;
    }

    *pch++ = ((dw >= 0xA) ? ('A' - 0xA) : '0') + (CHAR)dw;
    *pch = 0;

    return pch;
}


//
// dt == dump thread
//
// dt [v] pcsr_thread
// v == verbose (structure)
//
// by scottlu
//

DECLARE_API( dt )
{
    char chVerbose;
    CSR_THREAD csrt;
    ULONG_PTR dw;
    BOOL b;

    INIT_API();

    while (*args == ' ')
        args++;

    chVerbose = ' ';
    if (*args == 'v')
        chVerbose = *args++;

    dw = GetExpression(args);

    b = ReadMemory( dw, &csrt, sizeof(csrt), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read memory\n" );
        goto Exit;
    }

    //
    // Print simple thread info if the user did not ask for verbose.
    //
    if (chVerbose == ' ') {
        dprintf("Thread %08lx, Process %08lx, ClientId %lx.%lx, Flags %lx, Ref Count %lx\n",
                dw,
                csrt.Process,
                csrt.ClientId.UniqueProcess,
                csrt.ClientId.UniqueThread,
                csrt.Flags,
                csrt.ReferenceCount);
        goto Exit;
    }

    dprintf("PCSR_THREAD @ %08lx:\n"
            "\t+%04lx Link.Flink                %08lx\n"
            "\t+%04lx Link.Blink                %08lx\n"
            "\t+%04lx Process                   %08lx\n",
            dw,
            FIELD_OFFSET(CSR_THREAD, Link.Flink), csrt.Link.Flink,
            FIELD_OFFSET(CSR_THREAD, Link.Blink), csrt.Link.Blink,
            FIELD_OFFSET(CSR_THREAD, Process), csrt.Process);

    dprintf(
            "\t+%04lx WaitBlock                 %08lx\n"
            "\t+%04lx ClientId.UniqueProcess    %08lx\n"
            "\t+%04lx ClientId.UniqueThread     %08lx\n"
            "\t+%04lx ThreadHandle              %08lx\n",
            FIELD_OFFSET(CSR_THREAD, WaitBlock), csrt.WaitBlock,
            FIELD_OFFSET(CSR_THREAD, ClientId.UniqueProcess), csrt.ClientId.UniqueProcess,
            FIELD_OFFSET(CSR_THREAD, ClientId.UniqueThread), csrt.ClientId.UniqueThread,
            FIELD_OFFSET(CSR_THREAD, ThreadHandle), csrt.ThreadHandle);

    dprintf(
            "\t+%04lx Flags                     %08lx\n"
            "\t+%04lx ReferenceCount            %08lx\n"
            "\t+%04lx HashLinks.Flink           %08lx\n"
            "\t+%04lx HashLinks.Blink           %08lx\n",
            FIELD_OFFSET(CSR_THREAD, Flags), csrt.Flags,
            FIELD_OFFSET(CSR_THREAD, ReferenceCount), csrt.ReferenceCount,
            FIELD_OFFSET(CSR_THREAD, HashLinks.Flink), csrt.HashLinks.Flink,
            FIELD_OFFSET(CSR_THREAD, HashLinks.Blink), csrt.HashLinks.Blink);

 Exit:
    EXIT_API();
}

//
// dp == dump process
//
// dp [v] [pid | pcsr_process]
//      v == verbose (structure + thread list)
//      no process == dump process list
//
// by scottlu
//

DECLARE_API( dp )
{
    PLIST_ENTRY ListHead, ListNext;
    char ach[80];
    char chVerbose;
    PCSR_PROCESS pcsrpT;
    CSR_PROCESS csrp;
    PCSR_PROCESS pcsrpRoot;
    PCSR_THREAD pcsrt;
    ULONG_PTR dwProcessId;
    ULONG_PTR dw;
    DWORD_PTR dwRootProcess;
    BOOL b;

    INIT_API();

    while (*args == ' ')
        args++;

    chVerbose = ' ';
    if (*args == 'v')
        chVerbose = *args++;

    dwRootProcess = GetExpression("csrsrv!CsrRootProcess");
    if ( !dwRootProcess ) {
        goto Exit;
        }

    b = ReadMemory( dwRootProcess, &pcsrpRoot, sizeof(pcsrpRoot), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read RootProcess\n" );
        goto Exit;
    }
    //
    // See if user wants all processes. If so loop through them.
    //
    if (*args == 0) {
        ListHead = &pcsrpRoot->ListLink;
        b = ReadMemory( (ULONG_PTR)(&ListHead->Flink), &ListNext, sizeof(ListNext), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }

        while (ListNext != ListHead) {
            pcsrpT = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);

            ach[0] = chVerbose;
            ach[1] = ' ';
            HexToString((ULONG_PTR)pcsrpT, &ach[2]);

            dp(Client, ach);

            b = ReadMemory( (ULONG_PTR)(&ListNext->Flink), &ListNext, sizeof(ListNext), NULL);
            if ( !b ) {
                dprintf( "NTSDEXTS: Unable to read ListNext\n" );
                goto Exit;
            }
        }

        dprintf("---\n");
        goto Exit;
    }

    //
    // User wants specific process structure. Evaluate to find id or process
    // pointer.
    //
    dw = (ULONG)GetExpression(args);

    ListHead = &pcsrpRoot->ListLink;
    b = ReadMemory( (ULONG_PTR)(&ListHead->Flink), &ListNext, sizeof(ListNext), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read ListNext\n" );
        goto Exit;
    }

    while (ListNext != ListHead) {
        pcsrpT = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);
        b = ReadMemory( (ULONG_PTR)(&ListNext->Flink), &ListNext, sizeof(ListNext), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }

        b = ReadMemory( (ULONG_PTR)(&pcsrpT->ClientId.UniqueProcess), &dwProcessId, sizeof(dwProcessId), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }

        if (dw == dwProcessId) {
            dw = (ULONG_PTR)pcsrpT;
            break;
        }
    }

    pcsrpT = (PCSR_PROCESS)dw;
    b = ReadMemory( (ULONG_PTR)pcsrpT, &csrp, sizeof(csrp), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read RootProcess\n" );
        goto Exit;
    }

    //
    // If not verbose, print simple process info.
    //
    if (chVerbose == ' ') {
        dprintf("Process %08lx, Id %p, Seq# %lx, Flags %lx, Ref Count %lx\n",
                pcsrpT,
                csrp.ClientId.UniqueProcess,
                csrp.SequenceNumber,
                csrp.Flags,
                csrp.ReferenceCount);
        goto Exit;
    }

    dprintf("PCSR_PROCESS @ %08lx:\n"
            "\t+%04lx ListLink.Flink            %08lx\n"
            "\t+%04lx ListLink.Blink            %08lx\n",
            pcsrpT,
            FIELD_OFFSET(CSR_PROCESS, ListLink.Flink), csrp.ListLink.Flink,
            FIELD_OFFSET(CSR_PROCESS, ListLink.Blink), csrp.ListLink.Blink);

    dprintf(
            "\t+%04lx ThreadList.Flink          %08lx\n"
            "\t+%04lx ThreadList.Blink          %08lx\n"
            "\t+%04lx NtSession                 %08lx\n"
            "\t+%04lx ExpectedVersion           %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, ThreadList.Flink), csrp.ThreadList.Flink,
            FIELD_OFFSET(CSR_PROCESS, ThreadList.Blink), csrp.ThreadList.Blink,
            FIELD_OFFSET(CSR_PROCESS, NtSession), csrp.NtSession,
            FIELD_OFFSET(CSR_PROCESS, ExpectedVersion), csrp.ExpectedVersion);

    dprintf(
            "\t+%04lx ClientPort                %08lx\n"
            "\t+%04lx ClientViewBase            %08lx\n"
            "\t+%04lx ClientViewBounds          %08lx\n"
            "\t+%04lx ClientId.UniqueProcess    %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, ClientPort), csrp.ClientPort,
            FIELD_OFFSET(CSR_PROCESS, ClientViewBase), csrp.ClientViewBase,
            FIELD_OFFSET(CSR_PROCESS, ClientViewBounds), csrp.ClientViewBounds,
            FIELD_OFFSET(CSR_PROCESS, ClientId.UniqueProcess), csrp.ClientId.UniqueProcess);

    dprintf(
            "\t+%04lx ProcessHandle             %08lx\n"
            "\t+%04lx SequenceNumber            %08lx\n"
            "\t+%04lx Flags                     %08lx\n"
            "\t+%04lx DebugFlags                %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, ProcessHandle), csrp.ProcessHandle,
            FIELD_OFFSET(CSR_PROCESS, SequenceNumber), csrp.SequenceNumber,
            FIELD_OFFSET(CSR_PROCESS, Flags), csrp.Flags,
            FIELD_OFFSET(CSR_PROCESS, DebugFlags), csrp.DebugFlags);

    dprintf(
            "\t+%04lx DebugUserInterface        %08lx\n"
            "\t+%04lx ReferenceCount            %08lx\n"
            "\t+%04lx ProcessGroupId            %08lx\n"
            "\t+%04lx ProcessGroupSequence      %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, DebugUserInterface.UniqueProcess), csrp.DebugUserInterface.UniqueProcess,
            FIELD_OFFSET(CSR_PROCESS, ReferenceCount), csrp.ReferenceCount,
            FIELD_OFFSET(CSR_PROCESS, ProcessGroupId), csrp.ProcessGroupId,
            FIELD_OFFSET(CSR_PROCESS, ProcessGroupSequence), csrp.ProcessGroupSequence);

    dprintf(
            "\t+%04lx fVDM                      %08lx\n"
            "\t+%04lx ThreadCount               %08lx\n"
            "\t+%04lx PriorityClass             %08lx\n"
            "\t+%04lx ShutdownLevel             %08lx\n"
            "\t+%04lx ShutdownFlags             %08lx\n",
            FIELD_OFFSET(CSR_PROCESS, fVDM), csrp.fVDM,
            FIELD_OFFSET(CSR_PROCESS, ThreadCount), csrp.ThreadCount,
            FIELD_OFFSET(CSR_PROCESS, PriorityClass), csrp.PriorityClass,
            FIELD_OFFSET(CSR_PROCESS, ShutdownLevel), csrp.ShutdownLevel,
            FIELD_OFFSET(CSR_PROCESS, ShutdownFlags), csrp.ShutdownFlags);

    //
    // Now dump simple thread info for this processes' threads.
    //

    ListHead = &pcsrpT->ThreadList;
    b = ReadMemory( (ULONG_PTR)(&ListHead->Flink), &ListNext, sizeof(ListNext), NULL);
    if ( !b ) {
        dprintf( "NTSDEXTS: Unable to read ListNext\n" );
        goto Exit;
    }

    dprintf("Threads:\n");

    while (ListNext != ListHead) {
        pcsrt = CONTAINING_RECORD(ListNext, CSR_THREAD, Link);

        //
        // Make sure this pcsrt is somewhat real so we don't loop forever.
        //
        b = ReadMemory( (ULONG_PTR)(&pcsrt->ClientId.UniqueProcess), &dwProcessId, sizeof(dwProcessId), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }

        if (dwProcessId != (DWORD_PTR)csrp.ClientId.UniqueProcess) {
            dprintf("Invalid thread. Probably invalid argument to this extension.\n");
            goto Exit;
        }

        HexToString((ULONG_PTR)pcsrt, ach);
        dt(Client, ach);

        b = ReadMemory( (ULONG_PTR)(&ListNext->Flink), &ListNext, sizeof(ListNext), NULL);
        if ( !b ) {
            dprintf( "NTSDEXTS: Unable to read ListNext\n" );
            goto Exit;
        }
    }

 Exit:
    EXIT_API();
}



VOID
DllsExtension(
    PCSTR args,
    PPEB ProcessPeb
    );

DECLARE_API( gatom )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the global atom table
    kept in kernel mode

    Called as:

        !gatom

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ATOM_TABLE_INFORMATION TableInfo;
    PATOM_TABLE_INFORMATION pTableInfo = NULL;
    PATOM_BASIC_INFORMATION pBasicInfo = NULL;
    ULONG RequiredLength, MaxLength, i;

    INIT_API();

    dprintf("\nGlobal atom table ");
    Status = NtQueryInformationAtom( RTL_ATOM_INVALID_ATOM,
                                     AtomTableInformation,
                                     &TableInfo,
                                     sizeof( TableInfo ),
                                     &RequiredLength
                                   );
    if (Status != STATUS_INFO_LENGTH_MISMATCH) {
        dprintf( " - cant get information - %x\n", Status );
        goto Exit;
        }

    RequiredLength += 100 * sizeof( RTL_ATOM );
    pTableInfo = LocalAlloc( 0, RequiredLength );
    if (pTableInfo == NULL) {
        dprintf( " - cant allocate memory for %u atoms\n", RequiredLength / sizeof( RTL_ATOM ) );
        goto Exit;
        }

    Status = NtQueryInformationAtom( RTL_ATOM_INVALID_ATOM,
                                     AtomTableInformation,
                                     pTableInfo,
                                     RequiredLength,
                                     &RequiredLength
                                   );
    if (!NT_SUCCESS( Status )) {
        dprintf( " - cant get information about %x atoms - %x\n", RequiredLength / sizeof( RTL_ATOM ), Status );
        goto Exit;
        }

    MaxLength = sizeof( *pBasicInfo ) + RTL_ATOM_MAXIMUM_NAME_LENGTH;
    pBasicInfo = LocalAlloc( 0, MaxLength );

    if (!pBasicInfo) {
        dprintf("LocalAlloc failed.\n");
        goto Exit;
    }

    for (i=0; i<pTableInfo->NumberOfAtoms; i++) {
        Status = NtQueryInformationAtom( pTableInfo->Atoms[ i ],
                                         AtomBasicInformation,
                                         pBasicInfo,
                                         MaxLength,
                                         &RequiredLength
                                       );
        if (!NT_SUCCESS( Status )) {
            dprintf( "%hx *** query failed (%x)\n", pTableInfo->Atoms[ i ], Status );
            }
        else {
            dprintf( "%hx(%2d) = %ls (%d)%s\n",
                     pTableInfo->Atoms[ i ],
                     pBasicInfo->UsageCount,
                     pBasicInfo->Name,
                     pBasicInfo->NameLength,
                     pBasicInfo->Flags & RTL_ATOM_PINNED ? " pinned" : ""
                   );
            }
        }

 Exit:
    if (pTableInfo != NULL) {
        LocalFree (pTableInfo);
    }

    if (pBasicInfo != NULL) {
        LocalFree (pBasicInfo);
    }

    EXIT_API();
}



/*++

Routine Description:

    This function is called as an NTSD extension to mimic the !handle
    kd command.  This will walk through the debuggee's handle table
    and duplicate the handle into the ntsd process, then call NtQueryobjectInfo
    to find out what it is.

    Called as:

        !handle [handle [flags [Type]]]

    If the handle is 0 or -1, all handles are scanned.  If the handle is not
    zero, that particular handle is examined.  The flags are as follows
    (corresponding to secexts.c):
        1   - Get type information (default)
        2   - Get basic information
        4   - Get name information
        8   - Get object specific info (where available)

    If Type is specified, only object of that type are scanned.  Type is a
    standard NT type name, e.g. Event, Semaphore, etc.  Case sensitive, of
    course.

    Examples:

        !handle     -- dumps the types of all the handles, and a summary table
        !handle 0 0 -- dumps a summary table of all the open handles
        !handle 0 f -- dumps everything we can find about a handle.
        !handle 0 f Event
                    -- dumps everything we can find about open events

--*/
DECLARE_API( handle )
{
    HANDLE  hThere;
    DWORD   Type;
    DWORD   Mask;
    DWORD   HandleCount;
    NTSTATUS Status;
    DWORD   Total;
    DWORD   TypeCounts[TYPE_MAX];
    DWORD   Handle;
    DWORD   Hits;
    DWORD   Matches;
    DWORD   ObjectType;
    BOOL    GetDirect;
    ULONG   SessionType;
    ULONG   SessionQual;

    INIT_API();

    Mask = GHI_TYPE ;
    hThere = INVALID_HANDLE_VALUE;
    Type = 0;

    while (*args == ' ') {
        args++;
    }

    if ( strcmp( args, "-?" ) == 0 )
    {
        help(Client, "handle" );

        goto Exit;
    }

    hThere = (PVOID) GetExpression( args );

    while (*args && (*args != ' ') ) {
        args++;
    }
    while (*args == ' ') {
        args++;
    }

    if (*args) {
        Mask = (DWORD)GetExpression( args );
    }

    while (*args && (*args != ' ') ) {
        args++;
    }
    while (*args == ' ') {
        args++;
    }

    if (*args) {
        Type = GetObjectTypeIndex( (LPSTR)args );
        if (Type == (DWORD) -1 ) {
            dprintf("Unknown type '%s'\n", args );
            goto Exit;
        }
    }

    //
    // if they specified 0, they just want the summary.  Make sure nothing
    // sneaks out.
    //

    if ( Mask == 0 ) {
        Mask = GHI_SILENT;
    }

    //
    // If this is a dump debug session,
    // check and see whether we can retrieve handle
    // information through the engine interface.
    //

    if (g_ExtControl == NULL ||
        g_ExtControl->lpVtbl->
        GetDebuggeeType(g_ExtControl, &SessionType, &SessionQual) != S_OK) {
        SessionType = DEBUG_CLASS_USER_WINDOWS;
        SessionQual = DEBUG_USER_WINDOWS_PROCESS;
    }

    if (SessionType == DEBUG_CLASS_USER_WINDOWS &&
        SessionQual != DEBUG_USER_WINDOWS_PROCESS) {

        // This is a dump or remote session so we have to use
        // the stored handle information accessible
        // through the interface.
        if (g_ExtData2 == NULL ||
            g_ExtData2->lpVtbl->
            ReadHandleData(g_ExtData2, 0, DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT,
                           &HandleCount, sizeof(HandleCount),
                           NULL) != S_OK) {
            dprintf("Unable to read handle information\n");
            goto Exit;
        }

        GetDirect = FALSE;

    } else {

        // This is a live session so we can make direct NT calls.
        // More information is available this way so we use it
        // whenever we can.
        GetDirect = TRUE;
    }

    //
    // hThere of 0 indicates all handles.
    //
    if ((hThere == 0) || (hThere == INVALID_HANDLE_VALUE)) {

        if (GetDirect) {
            Status = NtQueryInformationProcess( g_hCurrentProcess,
                                                ProcessHandleCount,
                                                &HandleCount,
                                                sizeof( HandleCount ),
                                                NULL );

            if ( !NT_SUCCESS( Status ) ) {
                goto Exit;
            }
        }

        Hits = 0;
        Handle = 0;
        Matches = 0;
        ZeroMemory( TypeCounts, sizeof(TypeCounts) );

        while ( Hits < HandleCount ) {
            if ( Type ) {
                if (GetHandleInfo( GetDirect, g_hCurrentProcess,
                                   (HANDLE) (DWORD_PTR) Handle,
                                   GHI_TYPE | GHI_SILENT,
                                   &ObjectType ) ) {
                    Hits++;
                    if ( ObjectType == Type ) {
                        GetHandleInfo( GetDirect, g_hCurrentProcess,
                                       (HANDLE)(DWORD_PTR)Handle,
                                       Mask,
                                       &ObjectType );
                        Matches ++;
                    }

                }
            } else {
                if (GetHandleInfo(  GetDirect, g_hCurrentProcess,
                                    (HANDLE)(DWORD_PTR)Handle,
                                    GHI_TYPE | GHI_SILENT,
                                    &ObjectType) ) {
                    Hits++;
                    TypeCounts[ ObjectType ] ++;

                    GetHandleInfo(  GetDirect, g_hCurrentProcess,
                                    (HANDLE)(DWORD_PTR)Handle,
                                    Mask,
                                    &ObjectType );

                }
            }

            Handle += 4;
        }

        if ( Type == 0 ) {
            dprintf( "%d Handles\n", Hits );
            dprintf( "Type           \tCount\n");
            for (Type = 0; Type < TYPE_MAX ; Type++ ) {
                if (TypeCounts[Type]) {
                    dprintf("%-15ws\t%d\n", pszTypeNames[Type], TypeCounts[Type]);
                }
            }
        } else {
            dprintf("%d handles of type %ws\n", Matches, pszTypeNames[Type] );
        }


    } else {
        GetHandleInfo( GetDirect, g_hCurrentProcess, hThere, Mask, &Type );
    }

 Exit:
    EXIT_API();
}


DECLARE_API( threadtoken )
{
    HANDLE hToken ;
    NTSTATUS Status ;

    INIT_API();


    dprintf("\n\n!threadtoken has been replaced by !token (in exts.dll).\n\n");

    EXIT_API();
}



#define PAGE_ALL (PAGE_READONLY|\
                  PAGE_READWRITE|\
                  PAGE_WRITECOPY|\
                  PAGE_EXECUTE|\
                  PAGE_EXECUTE_READ|\
                  PAGE_EXECUTE_READWRITE|\
                  PAGE_EXECUTE_WRITECOPY|\
                  PAGE_NOACCESS)

VOID
printflags(
    DWORD Flags
    )
{
    switch (Flags & PAGE_ALL) {
        case PAGE_READONLY:
            dprintf("PAGE_READONLY");
            break;
        case PAGE_READWRITE:
            dprintf("PAGE_READWRITE");
            break;
        case PAGE_WRITECOPY:
            dprintf("PAGE_WRITECOPY");
            break;
        case PAGE_EXECUTE:
            dprintf("PAGE_EXECUTE");
            break;
        case PAGE_EXECUTE_READ:
            dprintf("PAGE_EXECUTE_READ");
            break;
        case PAGE_EXECUTE_READWRITE:
            dprintf("PAGE_EXECUTE_READWRITE");
            break;
        case PAGE_EXECUTE_WRITECOPY:
            dprintf("PAGE_EXECUTE_WRITECOPY");
            break;
        case PAGE_NOACCESS:
            if ((Flags & ~PAGE_NOACCESS) == 0) {
                dprintf("PAGE_NOACCESS");
                break;
            } // else fall through
        default:
            dprintf("*** Invalid page protection ***\n");
            return;
            break;
    }

    if (Flags & PAGE_NOCACHE) {
        dprintf(" + PAGE_NOCACHE");
    }
    if (Flags & PAGE_GUARD) {
        dprintf(" + PAGE_GUARD");
    }
    dprintf("\n");
}



/*++

Routine Description:

    This function is called as an NTSD extension to dump registry information

    Called as:

        !dreg -[d|w] <keyPath>[![<valueName> | *]]

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    args - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

DECLARE_API( dreg )
{
    DWORD    opts = 1;

    INIT_API();


    // Skip past leading spaces
    while (*args == ' ')
    {
        args++;
    }

    if (*args == '-')
    {
        args++;
        switch (*args)
        {
        case 'd':
            opts = 4;
            break;
        case 'w':
            opts = 2;
            break;
        default:
            opts = 1;
            break;
        }

        if (*args)
        {
            // expect a space between options
            args++;

            // Skip past leading spaces
            while (*args == ' ')
            {
                args++;
            }
        }
    }

    Idreg(opts, (LPSTR)args);

    EXIT_API();
}

NTSTATUS
GetHandleTraceInfo(
    PPROCESS_HANDLE_TRACING_QUERY *Info,
    PULONG BufferSize
    )
{
    NTSTATUS Status = NO_ERROR;
    ULONG CurrentBufferSize = *BufferSize;

    if (*BufferSize == 0)
    {
        CurrentBufferSize =  sizeof (PROCESS_HANDLE_TRACING_QUERY);
    }
    while (TRUE) {

        //
        // Allocate a new buffer
        //

        *Info = (PPROCESS_HANDLE_TRACING_QUERY)malloc (CurrentBufferSize);

        if (*Info == NULL) {

            dprintf ("ERROR: Cannot allocate buffer with size 0x%p\n",
                     CurrentBufferSize);
            Status = ERROR_OUTOFMEMORY;
            goto DoneAll;
        }

        ZeroMemory( *Info,
                    CurrentBufferSize );

        Status = NtQueryInformationProcess (g_hCurrentProcess,
                                            ProcessHandleTracing,
                                            *Info,
                                            CurrentBufferSize,
                                            NULL );

        if( NT_SUCCESS (Status) ) {

            //
            // We have all the information ready
            //

            break;
        }

        CurrentBufferSize = sizeof (PROCESS_HANDLE_TRACING_QUERY) + (*Info)->TotalTraces * sizeof ((*Info)->HandleTrace[ 0 ]);

        free (*Info);
        *Info = NULL;

        if( CheckControlC() ) {

            goto DoneAll;
        }

        if (Status != STATUS_INFO_LENGTH_MISMATCH) {

            //
            // No reason to try querying again
            //

            if (Status == STATUS_INVALID_PARAMETER) {

                dprintf ("App verifier handle tracing is not enabled for this process.\n");
            }
            else {

                dprintf ("Query process information failed, status 0x%X\n",
                         Status);
            }

            goto DoneAll;
        }

        //
        // Try allocating another buffer with the new size
        //
    }
    *BufferSize = CurrentBufferSize;
    return NO_ERROR;
DoneAll:
    free (*Info);
    *Info = NULL;
    return Status;
}

HRESULT
_EFN_GetHandleTrace(
    PDEBUG_CLIENT Client,
    ULONG TraceType,
    ULONG StartIndex,
    PULONG64 HandleValue,
    PULONG64 StackFunctions,
    ULONG StackTraceSize
    )
/*+++
    This extension function returns handle trace info for a given type of trace,
    or handle.

Arguments:

    If TraceType is set it returns first trace found of that type.

    If StartIndex is set it starts looking for traces from that index onwards

    If HandleValue is set it returns first  stack found of that handle

Return Value:

    S_OK for success.
--*/
{
    HRESULT Hr = E_FAIL;
    PPROCESS_HANDLE_TRACING_QUERY Info = NULL;
    ULONG InfoSize = 0;
    ULONG CrtStackTrace;

    INIT_API();
    if (NT_SUCCESS(Hr = GetHandleTraceInfo(&Info, &InfoSize)) && (Info != NULL))
    {
        for (CrtStackTrace = StartIndex; CrtStackTrace < Info->TotalTraces; CrtStackTrace += 1) {

            if( CheckControlC() ) {

                CrtStackTrace += 1;
                goto Done;
            }

            if (*HandleValue == 0 || *HandleValue == (ULONG64) Info->HandleTrace[ CrtStackTrace ].Handle) {

                if (Info->HandleTrace[ CrtStackTrace ].Type == TraceType ||
                    TraceType == 0)
                {
                    ULONG CapturedAddressIndex;
                    PVOID *CrtStack;
                    PVOID CapturedAddress;

                    *HandleValue = (ULONG64) Info->HandleTrace[ CrtStackTrace ].Handle;

                    Hr = S_OK;
                    for (CapturedAddressIndex = 0, CrtStack = &Info->HandleTrace[ CrtStackTrace ].Stacks[ 0 ];
                         CapturedAddressIndex < (sizeof(Info->HandleTrace[ CrtStackTrace ].Stacks) /
                                                 sizeof(Info->HandleTrace[ CrtStackTrace ].Stacks[0]));
                         CapturedAddressIndex += 1, CrtStack += 1) {

                        if( CheckControlC() ) {

                            CrtStackTrace += 1;
                            goto Done;
                        }

                        CapturedAddress = *CrtStack;

                        if (CapturedAddress == NULL) {

                            //
                            // Done with dumping this stack trace
                            //

                            goto Done;
                        }

                        if (StackTraceSize > CapturedAddressIndex)
                        {
                            if (sizeof(ULONG64) == sizeof(PVOID))
                            {
                                StackFunctions[CapturedAddressIndex] = (ULONG64) (LONG64) (ULONG_PTR) CapturedAddress;
                            } else
                            {
                                StackFunctions[CapturedAddressIndex] = (ULONG64) (LONG64) (LONG) (ULONG_PTR) CapturedAddress;
                            }
                        }
                    }
                    goto Done;
                }
            }
        }
    }
Done:
    if (Info)
    {
        free (Info);
    }
    EXIT_API();
    return Hr;

}

/*++

Routine Description:

    This function is called as an NTSD extension to dump handle tracing information

    Called as:

        !htrace [handle]

Arguments:

    args - Supplies the pattern and expression for this
        command.


Return Value:

    None.

--*/

DECLARE_API( htrace )
{
    HANDLE Handle;
    PPROCESS_HANDLE_TRACING_QUERY Info;
    ULONG_PTR Displacement;
    NTSTATUS Status;
    ULONG CurrentBufferSize;
    ULONG CrtStackTrace;
    ULONG EntriesDisplayed;
    ULONG CapturedAddressIndex;
    PVOID *CrtStack;
    PVOID CapturedAddress;
    SYSTEM_BASIC_INFORMATION SysBasicInfo;
    CHAR Symbol[ 1024 ];

    INIT_API();

    Info = NULL;
    CrtStackTrace = 0;
    EntriesDisplayed = 0;

    //
    // Did the user ask for some help?
    //

    if (strcmp (args, "-?") == 0 ||
        strcmp (args, "?") == 0  ||
        strcmp (args, "-h") == 0) {

        dprintf ("!htrace [handle]\n");
        goto DoneAll;
    }

    //
    // Get the handle from the command line
    //

    Handle = (HANDLE)GetExpression (args);

    //
    // Get the stack traces using NtQueryInformationProcess
    //
    Info = NULL; CurrentBufferSize = 0;
    Status = GetHandleTraceInfo(&Info, &CurrentBufferSize);
    if (!NT_SUCCESS(Status))
    {
        goto DoneAll;
    }

    //
    // If we have 0 stack traces there is nothing we can dump
    //

    if (Info->TotalTraces == 0) {

        dprintf( "No stack traces available.\n" );
        goto DoneAll;
    }

    //
    // Find out the highest user address because
    // we will skip kernel mode addresses from the stack traces.
    //


    Status = NtQuerySystemInformation (SystemBasicInformation,
                                       &SysBasicInfo,
                                       sizeof (SysBasicInfo),
                                       NULL);

    if (!NT_SUCCESS (Status)) {

        dprintf ("Query system basic information failed, status 0x%X\n",
                 Status);

        goto DoneAll;
    }

    //
    // Dump all the stack traces.
    //

    for (CrtStackTrace = 0; CrtStackTrace < Info->TotalTraces; CrtStackTrace += 1) {

        if( CheckControlC() ) {

            CrtStackTrace += 1;
            goto DoneDumping;
        }

        if (Handle == 0 || Handle == Info->HandleTrace[ CrtStackTrace ].Handle) {

            EntriesDisplayed += 1;

            dprintf ("--------------------------------------\n"
                     "Handle = 0x%p - ",
                     Info->HandleTrace[ CrtStackTrace ].Handle);

            switch( Info->HandleTrace[ CrtStackTrace ].Type ) {

            case HANDLE_TRACE_DB_OPEN:
                dprintf( "OPEN:\n" );
                break;

            case HANDLE_TRACE_DB_CLOSE:
                dprintf( "CLOSE:\n" );
                break;

            case HANDLE_TRACE_DB_BADREF:
                dprintf( "*** BAD REFERENCE ***:\n" );
                break;

            default:
                dprintf( "Invalid operation type: %u\n",
                         Info->HandleTrace[ CrtStackTrace ].Type );
                goto DoneDumping;
            }

            for (CapturedAddressIndex = 0, CrtStack = &Info->HandleTrace[ CrtStackTrace ].Stacks[ 0 ];
                 CapturedAddressIndex < (sizeof(Info->HandleTrace[ CrtStackTrace ].Stacks) /
                                         sizeof(Info->HandleTrace[ CrtStackTrace ].Stacks[0]));
                 CapturedAddressIndex += 1, CrtStack += 1) {

                if( CheckControlC() ) {

                    CrtStackTrace += 1;
                    goto DoneDumping;
                }

                CapturedAddress = *CrtStack;

                if (CapturedAddress == NULL) {

                    //
                    // Done with dumping this stack trace
                    //

                    break;
                }

                if ((ULONG_PTR)CapturedAddress > SysBasicInfo.MaximumUserModeAddress) {

                    //
                    // Skip kernel-mode addresses
                    //

                    continue;
                }

                GetSymbol (CapturedAddress,
                           Symbol,
                           &Displacement);

                dprintf ("0x%p: %s+0x%p\n",
                         CapturedAddress,
                         Symbol,
                         Displacement );
            }
        }
    }

DoneDumping:

    dprintf ("\n--------------------------------------\n"
            "Parsed 0x%X stack traces.\n"
            "Dumped 0x%X stack traces.\n",
            CrtStackTrace,
            EntriesDisplayed);

DoneAll:

    if (Info != NULL) {

        free (Info);
    }

    EXIT_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\ntsdexts\regexts.c ===
/*******************************************************************
*
*    Copyright (c) 1999  Microsoft Corporation
*
*    DESCRIPTION: an extension to dump the contents of registry keys and values
*
*    AUTHOR:
*         Based on Code by : danielwe (Dan Weisman)
*         ntsd addition by : kksharma (Kshitiz K. Sharma)
*
*    DATE:4/20/1999
*
*******************************************************************/

#include "ntsdextp.h"
#include <strsafe.h>

#ifndef KERNEL
#ifndef Print
#define Print dprintf
#endif


#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define LINE_NUMBER     0
#define NUM_ASCII_CHARS 16
#define NUM_HEX_CHARS   (NUM_ASCII_CHARS * 3)
#define SPACE           7
#define PB_BUFFER_SIZE  (NUM_ASCII_CHARS * 50)

VOID dregHelp() {
   dprintf("!dreg -[d|w] <keyPath>[![<valueName> | *]]  - Dumps registry information\n");
   dprintf("!dreg -d ...                                - Prints binary values as DWORDs\n");
   dprintf("!dreg -w ...                                - Prints binary values as WORDs\n");
   dprintf("!dreg <keyPath>!*                           - Prints all values under <keyPath>\n");
   dprintf("!dreg <keyPath>                             - Prints all subkeys of <keyPath>\n");
   dprintf("\n");
   dprintf("<keypath> can begin with any of the following:\n");
   dprintf("\thklm - HKEY_LOCAL_MACHINE\n");
   dprintf("\thkcu - HKEY_CURRENT_USER\n");
   dprintf("\thkcr - HKEY_CLASSES_ROOT\n");
   dprintf("\thku  - HKEY_USERS\n");
   dprintf("\tif absent, hklm is assumed\n");
   dprintf("\n");
   dprintf("Ex:\n");
   dprintf("!dreg hkcu\\Software\\Microsoft\n");
   dprintf("!dreg System\\CurrentControlSet\\Services\\Tcpip!*\n");
   dprintf("!dreg System\\CurrentControlSet\\Services\\Tcpip!Start\n");
}

VOID PrintBinary(PBYTE pbData, DWORD cbData, USHORT uWidth)
{
    CHAR    line[80];
    INT     i;
    INT     ascii = 0;
    PBYTE   temp = pbData;
    BOOL    fDone = FALSE;
    DWORD   cbCount = 0;

    CHAR hex_digits[] = "0123456789ABCDEF";

    while (!fDone)
    {
        DWORD   cb;

        memset(line, 0x20, sizeof(line));
        Print("%04X:  ", cbCount);
        for (ascii = 0,i = LINE_NUMBER, cb = 0;
             ascii < NUM_ASCII_CHARS;
             ascii++, temp++)
        {
            if ((DWORD)(temp - pbData) >= cbData)
            {
                if (cbData < PB_BUFFER_SIZE)
                {
                    fDone = TRUE;
                    break;
                }
                else
                    return;
            }
            line[i] = hex_digits[(*temp & 0xF0) >> 4];
            line[i + 1] = hex_digits[(*temp & 0x0F)];
            cb++;
            if ((ascii + 1) % uWidth == 0)
            {
                line[i + 2] = 0x20;
                i++;
                if (uWidth > 1)
                {
                    line[i + 3] = 0x20;
                    i++;
                }
                else if (uWidth == 1 && (!(cb % 4)))
                {
                    line[i + 3] = 0x20;
                    line[i + 4] = 0x20;
                    i += 2;
                }
            }
            i += 2;
            line[ascii + NUM_HEX_CHARS + SPACE + LINE_NUMBER] =
                (isprint(*temp) ? *temp : '.');
            cbCount++;
        }

        line[79] = 0;
        Print("%s\n", line);
    }
}

VOID PrintMultiSz(PBYTE pbData)
{
    LPSTR   sz = (LPSTR)pbData;
    DWORD   csz = 0;

    while (*sz)
    {
        Print("%d: \"%s\"\n", csz, *sz ? sz : "<empty>");
        csz++;
        sz += lstrlenA(sz) + 1;
    }
}

VOID PrintRegistryValue(DWORD dwType, PBYTE pbData, DWORD cbData, USHORT uWidth)
{
    switch (dwType)
    {
    case REG_SZ:
        Print("REG_SZ: \"%s\"\n", *pbData ? pbData : "<empty>");
        break;

    case REG_EXPAND_SZ:
        {
            CHAR    szExpanded[MAX_PATH + 1];

            Print("REG_EXPAND_SZ: \"%s\"\n", pbData);
            ExpandEnvironmentStringsA((LPCSTR)pbData, (LPSTR)szExpanded,
                                      MAX_PATH);
            Print("expanded = \"%s\"\n", szExpanded);
            break;
        }

    case REG_DWORD:
        {
            DWORD   dwData = * ((DWORD *)pbData);

            Print("REG_DWORD: %lu = 0x%08X\n", dwData, dwData);
            break;
        }

    case REG_BINARY:
        {
            Print("REG_BINARY:\n");
            PrintBinary(pbData, cbData, uWidth);
            break;
        }

    case REG_MULTI_SZ:
        {
            Print("REG_MULTI_SZ:\n");
            PrintMultiSz(pbData);
            break;
        }
    }
}

VOID EnumSubKeys(HKEY hkeyRoot, LPSTR szKey)
{
    HKEY    hkey;
    LONG    l;
    BOOL    fFound = FALSE;

    l = RegOpenKeyExA(hkeyRoot, szKey, 0, KEY_READ, &hkey);
    if (ERROR_SUCCESS == l)
    {
        FILETIME    ft;
        DWORD       cbName;
        CHAR        szName[MAX_PATH + 1];
        DWORD       dwIndex;

        for (dwIndex = 0; l == ERROR_SUCCESS; dwIndex++)
        {
            cbName = MAX_PATH;
            l = RegEnumKeyExA(hkey, dwIndex, szName, &cbName, NULL,
                              NULL, NULL,&ft);
            if (ERROR_SUCCESS == l)
            {
                Print("Subkey: %s\n", szName);
                fFound = TRUE;
            }
        }

        RegCloseKey(hkey);
    }
    else
    {
        Print("Could not open subkey %s. Error (%d).\n", szKey, l);
    }

    if (!fFound)
    {
        Print("No subkeys\n");
    }
}

VOID EnumValues(HKEY hkeyRoot, LPSTR szKey, USHORT uWidth)
{
    HKEY    hkey;
    LONG    l;
    BOOL    fFound = FALSE;

    l = RegOpenKeyExA(hkeyRoot, szKey, 0, KEY_READ, &hkey);
    if (ERROR_SUCCESS == l)
    {
        DWORD   cbMax;

        l = RegQueryInfoKeyA(hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                             NULL, &cbMax, NULL, NULL);
        if (ERROR_SUCCESS == l)
        {
            DWORD       cbName;
            CHAR        szName[MAX_PATH + 1];
            DWORD       dwIndex;
            PBYTE       pbData;
            DWORD       dwType;
            DWORD       cbData;

            pbData = (PBYTE)LocalAlloc(LPTR, cbMax);

            if (pbData)
            {
                for (dwIndex = 0; l == ERROR_SUCCESS; dwIndex++)
                {
                    cbName = MAX_PATH;
                    cbData = cbMax;
                    l = RegEnumValueA(hkey, dwIndex, szName, &cbName, NULL,
                                      &dwType, pbData, &cbData);
                    if (ERROR_SUCCESS == l)
                    {
                        Print("Value: \"%s\" - ", szName);
                        PrintRegistryValue(dwType, pbData, cbData, uWidth);
                        Print("------------------------------------------------------------------------\n");
                        fFound = TRUE;
                    }
                }

                LocalFree(pbData);
            }
        }

        RegCloseKey(hkey);
    }
    else
    {
        Print("Could not open subkey %s. Error (%d).\n", szKey, l);
    }

    if (!fFound)
    {
        Print("No values\n");
    }
}

/************************************************************************\
* Procedure: Idreg
*
* Description: Dumps registry value
*
* Returns: fSuccess
*
* 4/14/1999 Created DanielWe
*
\************************************************************************/
BOOL Idreg(
    DWORD opts,
    LPCSTR InString)
{
    LONG    l;
    HKEY    hkey;
    DWORD   cbData = 0;
    DWORD   dwType;
    LPBYTE  pbData = NULL;
    LPSTR   szKey = NULL;
    LPSTR   szValue = NULL;
    CHAR    String[512] = {0};
    LPTSTR  lpas = String;
    LPTSTR  lpasOrig = String;
    HKEY    hkeyRoot;

    if (strlen(InString) < sizeof(String))
    {
        StringCchCopy(String, sizeof(String), InString);
    }

    // Eat leading spaces first
    while (*lpas && *lpas == ' ')
    {
        lpas++;
    }

    while (*lpas && *lpas != '\\')
    {
        lpas++;
    }

    if (!*lpas)
    {
        // Corner case.. no backslash at all. Assume HKLM and start over
        hkeyRoot = HKEY_LOCAL_MACHINE;
        lpas = lpasOrig;
    }
    else
    {
        // Figure out which hive they want to open
        *lpas = 0;
        if (!_stricmp(lpasOrig, "hkcu"))
        {
            hkeyRoot = HKEY_CURRENT_USER;
            lpas++;
        }
        else if (!_stricmp(lpasOrig, "hklm"))
        {
            hkeyRoot = HKEY_LOCAL_MACHINE;
            lpas++;
        }
        else if (!_stricmp(lpasOrig, "hku"))
        {
            hkeyRoot = HKEY_USERS;
            lpas++;
        }
        else if (!_stricmp(lpasOrig, "hkcr"))
        {
            hkeyRoot = HKEY_CLASSES_ROOT;
            lpas++;
        }
        else if (!_stricmp(lpasOrig, "help"))
        {
           dregHelp();
           return FALSE;
        }
        else
        {
            hkeyRoot = HKEY_LOCAL_MACHINE;

            // Restore the backslash because we assume if they don't use these
            // keywords, then they want HKLM
            *lpas = '\\';
            lpas = lpasOrig;
        }
    }

    szKey = (LPSTR)lpas;

    while (*lpas && *lpas != '!')
    {
        lpas++;
    }

    if (*lpas)
    {
        // Null terminate the !
        *lpas++ = 0;

        // mark beginning of new string
        szValue = (LPSTR)lpas;
    }

    if (szKey == NULL || *szKey == 0)
    {
        Print("Expected subkey name\n");
        dregHelp();
        return FALSE;
    }
    if (szValue == NULL || *szValue == 0)
    {
        EnumSubKeys(hkeyRoot, szKey);
    }
    else if (!lstrcmpA(szValue, "*"))
    {
        EnumValues(hkeyRoot, szKey, (USHORT)opts);
    }
    else
    {
        l = RegOpenKeyExA(hkeyRoot, (LPCSTR)szKey, 0, KEY_READ, &hkey);
        if (ERROR_SUCCESS == l)
        {
            l = RegQueryValueExA(hkey, (LPCSTR)szValue, NULL, &dwType, NULL,
                                &cbData);
            if (ERROR_SUCCESS == l)
            {
                pbData = (LPBYTE)LocalAlloc(LPTR, cbData);
                l = RegQueryValueExA(hkey, (LPCSTR)szValue, NULL, &dwType, pbData,
                                    &cbData);
                if (ERROR_SUCCESS == l)
                {
                    PrintRegistryValue(dwType, pbData, cbData, (USHORT)opts);
                }

                LocalFree(pbData);
            }
            else
            {
                Print("Could not query value %s!%s. Error (%d).\n", szKey, szValue, l);
            }
            RegCloseKey(hkey);
        }
        else
        {
            Print("Could not open subkey %s. Error (%d).\n", szKey, l);
        }
    }

    return TRUE;
}

#endif // !KERNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\ntsdexts\secexts.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:


Abstract:

    This function contains the default ntsd debugger extensions

Author:


Revision History:

--*/

#include "ntsdextp.h"
#include <strsafe.h>

char * AccessMask[] = { "Delete", "ReadControl", "WriteDac", "WriteOwner",
                        "Synch", "", "", "",
                        "Sacl", "MaxAllowed", "", "",
                        "GenericAll", "GenericExec", "GenericWrite", "GenericRead"};

char * TokenRights[] = {"AssignPrimary", "Duplicate", "Impersonate", "Query",
                        "QuerySource", "AdjustPriv", "AdjustGroup", "AdjustDef"};

char * KeyRights[] = {  "QueryValue", "SetValue", "CreateSubKey", "EnumSubKey",
                        "Notify", "CreateLink", "", "" };

char * EventRights[] = {"QueryState", "ModifyState" };

char * MutantRights[]={ "QueryState" };

char * SemaphoreRights[] = { "QueryState", "ModifyState" };

char * TimerRights[] = {"QueryState", "ModifyState" };

char * ProfileRights[]={"Control"};

char * ProcessRights[]={"Terminate", "CreateThread", "", "VMOp",
                        "VMRead", "VMWrite", "DupHandle", "CreateProcess",
                        "SetQuota", "SetInfo", "QueryInfo", "SetPort" };

char * ThreadRights[] ={"Terminate", "Suspend", "Alert", "GetContext",
                        "SetContext", "SetInfo", "QueryInfo", "SetToken",
                        "Impersonate", "DirectImpersonate" };

char * SectionRights[]={"Query", "MapWrite", "MapRead", "MapExecute",
                        "Extend"};

char * FileRights[] = { "Read/List", "Write/Add", "Append/SubDir/CreatePipe", "ReadEA",
                        "WriteEA", "Execute/Traverse", "DelChild", "ReadAttr",
                        "WriteAttr"};

char * PortRights[] = { "Connect" };

char * DirRights[]  = { "Query", "Traverse", "Create", "CreateSubdir" };

char * SymLinkRights[]={"Query" };

char * WinstaRights[]={ "EnumDesktops", "ReadAttr", "Clipboard", "CreateDesktop",
                        "WriteAttr", "GlobalAtom", "ExitWindows", "",
                        "Enumerate", "ReadScreen" };

char * DesktopRights[]={"ReadObjects", "CreateWindow", "CreateMenu", "HookControl",
                        "JournalRecord", "JournalPlayback", "Enumerate", "WriteObjects",
                        "SwitchDesktop" };

char * CompletionRights[] = { "Query", "Modify" };

char * ChannelRights[] = { "ReadMessage", "WriteMessage", "Query", "SetInfo" };

char * JobRights[] = { "AssignProcess", "SetAttr", "Query", "Terminate", "SetSecAttr" };

char * DebugObjectRights[] = { "ReadEvent", "ProcessAssign",
                               "SetInformation", "QueryInformation" };

char * KeyedEventRights[] = { "Wait", "Wake" };

TCHAR * PrivNames[] = {
            TEXT("Invalid"),
            TEXT("Invalid"),
            SE_CREATE_TOKEN_NAME,
            SE_ASSIGNPRIMARYTOKEN_NAME,
            SE_LOCK_MEMORY_NAME,
            SE_MACHINE_ACCOUNT_NAME,
            SE_TCB_NAME,
            SE_SECURITY_NAME,
            SE_TAKE_OWNERSHIP_NAME,
            SE_LOAD_DRIVER_NAME,
            SE_SYSTEM_PROFILE_NAME,
            SE_PROF_SINGLE_PROCESS_NAME,
            SE_INC_BASE_PRIORITY_NAME,
            SE_CREATE_PAGEFILE_NAME,
            SE_CREATE_PERMANENT_NAME,
            SE_BACKUP_NAME,
            SE_RESTORE_NAME,
            SE_SHUTDOWN_NAME,
            SE_DEBUG_NAME,
            SE_AUDIT_NAME,
            SE_SYSTEM_ENVIRONMENT_NAME,
            SE_CHANGE_NOTIFY_NAME,
            SE_REMOTE_SHUTDOWN_NAME,
            SE_UNDOCK_NAME,
            SE_SYNC_AGENT_NAME,
            SE_ENABLE_DELEGATION_NAME
        };

///////////////////////////////

char *  TokenImpLevels[] = { "Anonymous", "Identification", "Impersonation", "Delegation" };
#define GetTokenImpersonationLevel( x ) \
                ( x <= SecurityDelegation ? TokenImpLevels[ x ] : "Invalid" )

LPWSTR   pszTypeNames[TYPE_MAX] = { L"None", L"Event", L"Section", L"File",
                                L"Port", L"Directory", L"SymbolicLink",
                                L"Mutant", L"WindowStation", L"Semaphore",
                                L"Key", L"Token", L"Process", L"Thread",
                                L"Desktop", L"IoCompletion", L"Channel",
                                L"Timer", L"Job", L"WaitablePort",
                                L"DebugObject", L"KeyedEvent" };

LPSTR   pszTypeNamesA[TYPE_MAX] = { "None", "Event", "Section", "File",
                                "Port", "Directory", "SymbolicLink",
                                "Mutant", "WindowStation", "Semaphore",
                                "Key", "Token", "Process", "Thread",
                                "Desktop", "IoCompletion", "Channe",
                                "Timer", "Job", "WaitablePort",
                                "DebugObject", "KeyedEvent" };

typedef VOID
( * TYPEINFOFN)(HANDLE hObject, DWORD Flags);

VOID EventInfo(HANDLE, ULONG);
VOID MutantInfo(HANDLE, ULONG);
VOID SemaphoreInfo(HANDLE, ULONG);
VOID TimerInfo(HANDLE, ULONG);
VOID SectionInfo(HANDLE, ULONG);
VOID KeyInfo(HANDLE, ULONG);
VOID ProcessInfo(HANDLE, ULONG);
VOID ThreadInfo(HANDLE, ULONG);
VOID TokenInfo(HANDLE, ULONG);
VOID IoCompleteInfo(HANDLE, ULONG);
VOID JobInfo( HANDLE, ULONG );

typedef struct _TYPEINFO {
    PWSTR       pszName;
    char * *    AccessRights;
    DWORD       NumberRights;
    TYPEINFOFN  Func;
} TYPEINFO, * PTYPEINFO;

TYPEINFO TypeNames[TYPE_MAX] = {
    { L"None", NULL, 0, 0 },
    { L"Event", EventRights, 2, EventInfo },
    { L"Section", SectionRights, 5, SectionInfo },
    { L"File", FileRights, 9, 0 },
    { L"Port", PortRights, 1, 0 },
    { L"Directory", DirRights, 4, 0 },
    { L"SymbolicLink", SymLinkRights, 1, 0 },
    { L"Mutant", MutantRights, 2, MutantInfo },
    { L"WindowStation", WinstaRights, 10, 0 },
    { L"Semaphore", SemaphoreRights, 2, SemaphoreInfo },
    { L"Key", KeyRights, 6, KeyInfo },
    { L"Token", TokenRights, 8, TokenInfo },
    { L"Process", ProcessRights, 12, ProcessInfo },
    { L"Thread", ThreadRights, 10, ThreadInfo },
    { L"Desktop", DesktopRights, 10, 0 },
    { L"IoCompletion", CompletionRights, 2, IoCompleteInfo },
    { L"Channel", ChannelRights, 4, 0},
    { L"Timer", TimerRights, 2, TimerInfo },
    { L"Job", JobRights, 5, JobInfo },
    { L"WaitablePort", PortRights, 1, 0 },
    { L"DebugObject", DebugObjectRights, 4, 0 },
    { L"KeyedEvent", KeyedEventRights, 2, 0 }
    };

void DisplayFlags(  DWORD       Flags,
                    DWORD       FlagLimit,
                    char        *flagset[],
                    UCHAR *      buffer,
                    LONG        bufferSize)
{
   char *         offset;
   DWORD          mask, test, i, len, rem;
   DWORD          scratch;

   if (!Flags) {
      StringCchCopy((CHAR *)buffer, bufferSize, "None");
      return;
   }

   mask = 0;
   offset = (CHAR *) buffer;
   test = 1;
   for (i = 0 ; i < FlagLimit ; i++ ) {
      if (Flags & test) {
          if (StringCchCopy(offset, bufferSize, flagset[i]) == S_OK)
          {
              offset+=strlen(offset);
              bufferSize -= strlen(offset);
              mask |= test;
              if (Flags & (~mask)) {
                  *offset++ = ',';
                  --bufferSize;
              }
          }
      }
      test <<= 1;
   }
}

VOID
EventInfo(
    HANDLE  hEvent,
    DWORD   Flags)
{
    EVENT_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQueryEvent(  hEvent,
                            EventBasicInformation,
                            &Info,
                            sizeof( Info ),
                            NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Event Type %s\n", Info.EventType == SynchronizationEvent ?
                                    "Auto Reset" : "Manual Reset" );
        dprintf("    Event is %s\n", Info.EventState ? "Set" : "Waiting" );
    }
}

VOID
SemaphoreInfo(
    HANDLE  hSem,
    DWORD   Flags)
{
    SEMAPHORE_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQuerySemaphore(  hSem,
                                SemaphoreBasicInformation,
                                &Info,
                                sizeof( Info ),
                                NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Semaphore Count %d\n", Info.CurrentCount );
        dprintf("    Semaphore Limit %d\n", Info.MaximumCount );
    }

}

VOID
MutantInfo(
    HANDLE  hMutant,
    DWORD   Flags)
{
    MUTANT_BASIC_INFORMATION    Info;
    NTSTATUS Status;

    Status = NtQueryMutant( hMutant,
                            MutantBasicInformation,
                            &Info,
                            sizeof( Info ),
                            NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Mutex is %s\n", Info.CurrentCount ? "Free" : "Owned" );
        if ( Info.AbandonedState )
        {
            dprintf("    Mutex is abandoned\n");
        }
    }
}

VOID
TimerInfo(
    HANDLE  hTimer,
    DWORD   Flags)
{
    TIMER_BASIC_INFORMATION Info;
    NTSTATUS    Status;

    Status = NtQueryTimer( hTimer,
                           TimerBasicInformation,
                           &Info,
                           sizeof( Info ),
                           NULL );

    if (NT_SUCCESS( Status ) )
    {
        dprintf("    Timer is %s\n", Info.TimerState ? "signalled" : "waiting" );
        dprintf("    Remaining time %d\n", (DWORD) Info.RemainingTime.QuadPart );
    }
}

VOID
SectionInfo(
    HANDLE  hSection,
    DWORD   Flags)
{
    SECTION_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQuerySection(    hSection,
                                SectionBasicInformation,
                                &Info,
                                sizeof( Info ),
                                NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Section base address %#x\n", Info.BaseAddress );
        dprintf("    Section attributes %#x\n", Info.AllocationAttributes );
        dprintf("    Section max size %#x\n", (DWORD) Info.MaximumSize.QuadPart );
    }
}

VOID
KeyInfo(
    HANDLE  hKey,
    DWORD   Flags)
{
    PKEY_BASIC_INFORMATION  pInfo;
    NTSTATUS Status;
    SYSTEMTIME st;
    FILETIME lft;
    ULONG   Length;

    pInfo = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 1024);
    if ( pInfo )
    {
        Status = NtQueryKey( hKey,
                             KeyBasicInformation,
                             pInfo,
                             1024,
                             &Length );

        if ( NT_SUCCESS( Status ) )
        {
            FileTimeToLocalFileTime( (FILETIME *) &pInfo->LastWriteTime,
                                     & lft );
            FileTimeToSystemTime( &lft, &st );

            dprintf("    Key last write time:  %02d:%02d:%02d. %d/%d/%d\n",
                    st.wHour, st.wMinute, st.wSecond, st.wMonth,
                    st.wDay, st.wYear );

            dprintf("    Key name %ws\n", pInfo->Name );
        }

        LocalFree( pInfo );
    }
}

VOID
ProcessInfo(
    HANDLE  hProcess,
    DWORD   Flags)
{
    PROCESS_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQueryInformationProcess( hProcess,
                                        ProcessBasicInformation,
                                        &Info,
                                        sizeof( Info ),
                                        NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Process Id  %d\n", Info.UniqueProcessId );
        dprintf("    Parent Process  %d\n", Info.InheritedFromUniqueProcessId );
        dprintf("    Base Priority %d\n", Info.BasePriority );
    }

}

VOID
ThreadInfo(
    HANDLE hThread,
    DWORD   Flags)
{
    THREAD_BASIC_INFORMATION Info;
    NTSTATUS Status;
    PVOID StartAddr ;
    CHAR Buffer[ 128 ];
    DWORD_PTR Offset ;

    Status = NtQueryInformationThread( hThread,
                                       ThreadBasicInformation,
                                       &Info,
                                       sizeof( Info ),
                                       NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Thread Id   %x.%x\n", Info.ClientId.UniqueProcess, Info.ClientId.UniqueThread );
        dprintf("    Priority    %d\n", Info.Priority );
        dprintf("    Base Priority %d\n", Info.BasePriority );
    }

    Status = NtQueryInformationThread( hThread,
                                       ThreadQuerySetWin32StartAddress,
                                       &StartAddr,
                                       sizeof( PVOID ),
                                       NULL );

    if ( NT_SUCCESS( Status ) )
    {
        Buffer[0] = '\0';
        GetSymbol( StartAddr, Buffer, &Offset );
        dprintf("    Start Address %x %s\n",
                StartAddr, Buffer[0] ? Buffer : "" );
    }
}

VOID
IoCompleteInfo(
    HANDLE  hIoCompletionPort,
    DWORD   Flags)
{
    IO_COMPLETION_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = NtQueryIoCompletion(   hIoCompletionPort,
                                    IoCompletionBasicInformation,
                                    &Info,
                                    sizeof( Info ),
                                    NULL );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Depth  %d\n", Info.Depth );
    }

}

VOID
TokenInfo(
    HANDLE  hToken,
    DWORD   Flags)
{
    TOKEN_STATISTICS    Stats;
    UCHAR               Buffer[ 1024 ];
    PTOKEN_USER         pUser;
    PTOKEN_GROUPS       pGroups;
    PTOKEN_PRIVILEGES   pPrivs ;
    ULONG               Size;
    NTSTATUS            Status;
    UNICODE_STRING      s;
    WCHAR               Name[ 64 ];
    WCHAR               Domain[ 64 ];
    DWORD               NameSize;
    DWORD               DomainSize;
    SID_NAME_USE        Use;
    BOOL                FoundName;
    ULONG               Index;



    Status = NtQueryInformationToken(   hToken,
                                        TokenStatistics,
                                        &Stats,
                                        sizeof(Stats),
                                        &Size );

    if ( NT_SUCCESS( Status ) )
    {
        dprintf("    Auth Id    %#x : %#x\n", Stats.AuthenticationId.HighPart, Stats.AuthenticationId.LowPart );
        dprintf("    Type       %s\n", Stats.TokenType == TokenPrimary ? "Primary" : "Impersonation" );
        dprintf("    Imp Level  %s\n", GetTokenImpersonationLevel( Stats.ImpersonationLevel ) );

        if ( Flags & GHI_VERBOSE )
        {
            dprintf("     Token Id  %#x : %#x \n", Stats.TokenId.HighPart, Stats.TokenId.LowPart );
            dprintf("     Mod Id    %#x : %#x \n", Stats.ModifiedId.HighPart, Stats.ModifiedId.LowPart );
            dprintf("     Dyn Chg   %#x\n", Stats.DynamicCharged );
            dprintf("     Dyn Avail %#x\n", Stats.DynamicAvailable );
            dprintf("     Groups    %d\n",  Stats.GroupCount );
            dprintf("     Privs     %d\n",  Stats.PrivilegeCount );

            pUser = (PTOKEN_USER) Buffer;
            Status = NtQueryInformationToken(   hToken,
                                                TokenUser,
                                                Buffer,
                                                sizeof(Buffer),
                                                &Size );

            if (NT_SUCCESS( Status ) )
            {
                FoundName = FALSE ;

                if ( !(Flags & GHI_NOLOOKUP) )
                {
                    NameSize = 64 ;
                    DomainSize = 64 ;

                    if ( LookupAccountSidW( NULL,
                                            pUser->User.Sid,
                                            Name,
                                            &NameSize,
                                            Domain,
                                            &DomainSize,
                                            &Use ) )
                    {
                        dprintf("     User      %ws\\%ws\n", Domain, Name );
                        FoundName = TRUE;
                    }
                }

                if ( (Flags & GHI_NOLOOKUP) || (!FoundName) )
                {
                    if (FAILED(RtlConvertSidToUnicodeString( &s, pUser->User.Sid, TRUE )))
                    {
                        dprintf("     User      <sid unavailable>\n" );
                    } else
                    {
                        dprintf("     User      %ws\n", s.Buffer );
                        RtlFreeUnicodeString( &s );
                    }
                }
            }

            pGroups = (PTOKEN_GROUPS) Buffer;
            Status = NtQueryInformationToken(   hToken,
                                                TokenGroups,
                                                Buffer,
                                                sizeof(Buffer),
                                                &Size );

            if ( NT_SUCCESS( Status ) )
            {
                dprintf("     Groups    %d\n", pGroups->GroupCount );
                for ( Index = 0 ; Index < pGroups->GroupCount ; Index++ )
                {
                    FoundName = FALSE ;

                    if ( !(Flags & GHI_NOLOOKUP) )
                    {
                        NameSize = 64 ;
                        DomainSize = 64 ;

                        if ( LookupAccountSidW( NULL,
                                                pGroups->Groups[Index].Sid,
                                                Name,
                                                &NameSize,
                                                Domain,
                                                &DomainSize,
                                                &Use ) )
                        {
                            dprintf("               %ws\\%ws\n", Domain, Name );
                            FoundName = TRUE;
                        }
                    }
                    if ( ( Flags & GHI_NOLOOKUP ) || ( !FoundName ) )
                    {
                        RtlConvertSidToUnicodeString( &s,
                                                    pGroups->Groups[Index].Sid,
                                                    TRUE );

                        dprintf("               %ws\n", s.Buffer );

                        RtlFreeUnicodeString( &s );

                    }
                }
            }

            pPrivs = (PTOKEN_PRIVILEGES) Buffer ;
            Status = NtQueryInformationToken(   hToken,
                                                TokenPrivileges,
                                                Buffer,
                                                sizeof(Buffer),
                                                &Size );

            if ( NT_SUCCESS( Status ) )
            {
                dprintf("     Privileges    %d\n", pPrivs->PrivilegeCount );
                for ( Index = 0 ; Index < pPrivs->PrivilegeCount ; Index++ )
                {
                    dprintf("               %s (%s%s)\n",
                            PrivNames[ pPrivs->Privileges[ Index ].Luid.LowPart ],
                            pPrivs->Privileges[ Index ].Attributes & SE_PRIVILEGE_ENABLED ? " Enabled " : " ",
                            pPrivs->Privileges[ Index ].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT ? "Default " : ""
                            );
                }

            }
        }
    }

}

VOID
JobInfo(
    HANDLE Job,
    ULONG Flags
    )
{
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo ;
    UCHAR Buffer[ 128 * sizeof( ULONG_PTR ) ];
    PJOBOBJECT_BASIC_PROCESS_ID_LIST ProcList ;
    NTSTATUS Status ;
    ULONG Size ;
    TIME_FIELDS Time ;

    //
    // Delay load this API since it does not exist on NT 4
    //

    typedef NTSTATUS (NTAPI* PNTQUERYJOB)(HANDLE, JOBOBJECTINFOCLASS, PVOID, LONG, PULONG);

    HMODULE hNtdll;
    PNTQUERYJOB pNtQueryJob;

    hNtdll = GetModuleHandle( "ntdll.dll" );
    if (!hNtdll) {
        dprintf("Unable to get module handle for ntdll.dll\n");
        return;
    }

    pNtQueryJob =
        (PNTQUERYJOB)GetProcAddress( hNtdll, "NtQueryInformationJobObject" );

    if (pNtQueryJob == NULL) {
        dprintf("Unable to get address of NtQueryInformationJobObject\n");
        return;
    }

    Status = pNtQueryJob(
                    Job,
                    JobObjectBasicAccountingInformation,
                    &BasicInfo,
                    sizeof( BasicInfo ),
                    &Size );

    if ( NT_SUCCESS( Status ) )
    {
        RtlTimeToElapsedTimeFields( &BasicInfo.TotalUserTime, &Time );
        dprintf( "    TotalUserTime     \t%3ld:%02ld:%02ld.%04ld\n",
                 Time.Hour,
                 Time.Minute,
                 Time.Second,
                 Time.Milliseconds );
        RtlTimeToElapsedTimeFields( &BasicInfo.TotalKernelTime, &Time );
        dprintf( "    TotalKernelTime   \t%3ld:%02ld:%02ld.%04ld\n",
                 Time.Hour,
                 Time.Minute,
                 Time.Second,
                 Time.Milliseconds );

        dprintf( "    TotalProcesses    \t%x\n",
                 BasicInfo.TotalProcesses );
        dprintf( "    ActiveProcesses   \t%x\n",
                 BasicInfo.ActiveProcesses );
        dprintf( "    TotalPageFaultCount\t%x\n",
                 BasicInfo.TotalPageFaultCount );

        if ( BasicInfo.ActiveProcesses )
        {
            ProcList = (PJOBOBJECT_BASIC_PROCESS_ID_LIST) Buffer ;

            Status = pNtQueryJob(
                            Job,
                            JobObjectBasicProcessIdList,
                            ProcList,
                            sizeof( Buffer ),
                            &Size );

            if ( NT_SUCCESS( Status ) )
            {
                ULONG i ;

                dprintf( "    Processes:\n" );

                for (i = 0 ; i < ProcList->NumberOfProcessIdsInList ; i++ )
                {
                    dprintf( "    %x\n", ProcList->ProcessIdList[ i ] );
                }
            }
        }

    }
}


DWORD
GetObjectTypeIndex(
    LPCSTR  pszTypeName )
{
    WCHAR   TypeName[ MAX_PATH ];
    DWORD   i;

    if (pszTypeName && (strlen(pszTypeName) < MAX_PATH))
    {
        mbstowcs( TypeName, pszTypeName, strlen( pszTypeName ) + 1 );
        for ( i = 1 ; i < TYPE_MAX ; i++ )
        {
            if (_wcsicmp( TypeNames[i].pszName, TypeName ) == 0 )
            {
                return( i );
            }
        }
    }


    return( (DWORD) -1 );
}

DWORD
GetHandleInfoDirect(
    HANDLE  hProcess,
    HANDLE  hThere,
    DWORD   Flags,
    DWORD * Type)
{
    HANDLE  hHere;
    NTSTATUS    Status;
    POBJECT_TYPE_INFORMATION    pTypeInfo;
    POBJECT_NAME_INFORMATION    pNameInfo;
    POBJECT_BASIC_INFORMATION   pBasicInfo;
    UCHAR   Buffer[1024];
    DWORD   SuccessCount = 0;
    DWORD   i;
    UCHAR   szBuf[256];


    if (!DuplicateHandle(   hProcess, hThere,
                            GetCurrentProcess(), &hHere,
                            0, FALSE,
                            DUPLICATE_SAME_ACCESS) )
    {
        if ( (Flags & GHI_SILENT) == 0)
        {
            dprintf("Could not duplicate handle %x, error %d\n",
                            hThere, GetLastError() );
        }
        return( 0 );
    }


    pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;
    pNameInfo = (POBJECT_NAME_INFORMATION) Buffer;
    pBasicInfo = (POBJECT_BASIC_INFORMATION) Buffer;

    if ( (Flags & GHI_SILENT) == 0)
    {
        dprintf("Handle %x\n", hThere );
    }

    *Type = 0;

    if (Flags & (GHI_TYPE | GHI_NAME))
    {
        ZeroMemory( Buffer, 1024 );
        Status = NtQueryObject( hHere, ObjectTypeInformation, pTypeInfo, 1024, NULL );

        if (NT_SUCCESS(Status))
        {
            for (i = 1; i < TYPE_MAX ; i++ )
            {
                if (wcscmp(pTypeInfo->TypeName.Buffer, TypeNames[i].pszName) == 0)
                {
                    *Type = i;
                    break;
                }
            }

            if (Flags & GHI_TYPE)
            {
                if (!(Flags & GHI_SILENT))
                {
                    dprintf("  Type         \t%ws\n", pTypeInfo->TypeName.Buffer );
                }
                SuccessCount++;
            }
        }
    }

    if (Flags & GHI_BASIC)
    {
        ZeroMemory( Buffer, 1024 );

        Status = NtQueryObject(hHere, ObjectBasicInformation, pBasicInfo,
                        sizeof( OBJECT_BASIC_INFORMATION), NULL);
        if (NT_SUCCESS(Status))
        {
            dprintf("  Attributes   \t%#x\n", pBasicInfo->Attributes );
            dprintf("  GrantedAccess\t%#x:\n", pBasicInfo->GrantedAccess );
            DisplayFlags( pBasicInfo->GrantedAccess >> 16,
                          16,
                          AccessMask,
                          szBuf,
                          sizeof(szBuf));
            dprintf("         %s\n", szBuf);
            DisplayFlags( pBasicInfo->GrantedAccess & 0xFFFF,
                          TypeNames[ *Type ].NumberRights,
                          TypeNames[ *Type ].AccessRights,
                          szBuf,
                          sizeof(szBuf));
            dprintf("         %s\n", szBuf);
            dprintf("  HandleCount  \t%d\n", pBasicInfo->HandleCount );
            dprintf("  PointerCount \t%d\n", pBasicInfo->PointerCount );
            SuccessCount++;
        }
        else
        {
            if ( Status != STATUS_INVALID_HANDLE )
            {
                dprintf("unable to query object information\n");
            }
        }
    }

    if ( (Flags & GHI_NAME) &&
         (*Type != TYPE_FILE ) )
    {
        ZeroMemory( Buffer, 1024 );
        Status = NtQueryObject( hHere, ObjectNameInformation, pNameInfo, 1024, NULL );

        if (NT_SUCCESS(Status))
        {
            dprintf("  Name         \t%ws\n", pNameInfo->Name.Buffer ?
                                        pNameInfo->Name.Buffer : L"<none>" );
            SuccessCount++;
        }
        else
        {
            if ( Status != STATUS_INVALID_HANDLE )
            {
                dprintf("unable to query object information\n");
            }
        }
    }

    if ( Flags & GHI_SPECIFIC )
    {
        if ( TypeNames[ *Type ].Func )
        {
            dprintf("  Object Specific Information\n");
            TypeNames[ *Type ].Func( hHere, Flags );
        }
    }

    CloseHandle( hHere );

    return( SuccessCount );

}

DWORD
GetHandleInfoInterface(
    HANDLE  hThere,
    DWORD   Flags,
    DWORD * Type)
{
    ULONG64 IfHandle = (ULONG_PTR)hThere;
    HRESULT Status;
    DWORD   SuccessCount = 0;
    DWORD   i;
    UCHAR   Buffer[1024];
    UCHAR   szBuf[256];

    if ( (Flags & GHI_SILENT) == 0)
    {
        dprintf("Handle %I64x\n", IfHandle );
    }

    *Type = 0;

    if (Flags & (GHI_TYPE | GHI_NAME))
    {
        if (g_ExtData2->lpVtbl->
            ReadHandleData(g_ExtData2, IfHandle,
                           DEBUG_HANDLE_DATA_TYPE_TYPE_NAME,
                           Buffer, sizeof(Buffer), NULL) == S_OK)
        {
            for (i = 1; i < TYPE_MAX ; i++ )
            {
                if (strcmp((LPSTR)Buffer, pszTypeNamesA[i]) == 0)
                {
                    *Type = i;
                    break;
                }
            }
            if (Flags & GHI_TYPE)
            {
                if (!(Flags & GHI_SILENT))
                {
                    dprintf("  Type         \t%s\n", Buffer);
                }
                SuccessCount++;
            }
        }
    }

    if (Flags & GHI_BASIC)
    {
        DEBUG_HANDLE_DATA_BASIC Basic;

        if (g_ExtData2->lpVtbl->
            ReadHandleData(g_ExtData2, IfHandle,
                           DEBUG_HANDLE_DATA_TYPE_BASIC,
                           &Basic, sizeof(Basic), NULL) == S_OK)
        {
            dprintf("  Attributes   \t%#x\n", Basic.Attributes );
            dprintf("  GrantedAccess\t%#x:\n", Basic.GrantedAccess );
            DisplayFlags( Basic.GrantedAccess >> 16,
                          16,
                          AccessMask,
                          szBuf,
                          sizeof(szBuf));
            dprintf("         %s\n", szBuf);
            DisplayFlags( Basic.GrantedAccess & 0xFFFF,
                          TypeNames[ *Type ].NumberRights,
                          TypeNames[ *Type ].AccessRights,
                          szBuf,
                          sizeof(szBuf));
            dprintf("         %s\n", szBuf);
            dprintf("  HandleCount  \t%d\n", Basic.HandleCount );
            dprintf("  PointerCount \t%d\n", Basic.PointerCount );
            SuccessCount++;
        }
        else
        {
            dprintf("unable to query object information\n");
        }
    }

    if ( (Flags & GHI_NAME) &&
         (*Type != TYPE_FILE ) )
    {
        if (g_ExtData2->lpVtbl->
            ReadHandleData(g_ExtData2, IfHandle,
                           DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME,
                           Buffer, sizeof(Buffer), NULL) == S_OK)
        {
            dprintf("  Name         \t%s\n",
                    Buffer[0] ? Buffer : "<none>" );
            SuccessCount++;
        }
        else
        {
            dprintf("unable to query object information\n");
        }
    }

    if ( Flags & GHI_SPECIFIC )
    {
        dprintf("  No object specific information available\n");
    }

    return( SuccessCount );

}

DWORD
GetHandleInfo(
    BOOL    Direct,
    HANDLE  hProcess,
    HANDLE  hThere,
    DWORD   Flags,
    DWORD * Type)
{
    if (Direct) {
        return GetHandleInfoDirect(hProcess, hThere, Flags, Type);
    } else {
        return GetHandleInfoInterface(hThere, Flags, Type);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\pstat.h ===
#ifndef _PSTAT_INCLUDED_
#define _PSTAT_INCLUDED_

//
//
// MAX_CESRS  - maximum number of event selection registers
//              This is a softwate limit. NoCESR is the runtime value.
// MAX_EVENTS - maximum number of active performance counter registers.
//              This is a softwate limit. NoCounters is the runtime value.
//
// Note - We could define these values as processor independent and
//        use a maximum denominator. 
//        Mostly to limit the size of data structures and arrays based
//        on these values, we are defining 

#if defined(_X86_)
#define MAX_EVENTS              2  // sw: max number of active perf. counters.
#define MAX_CESRS               2  // sw: max number of event selection registers.
#else // !_X86_
// include _IA64_ ...
#define MAX_EVENTS              4  // sw: max number of active perf. counters.
#define MAX_CESRS               4  // sw: max number of event selection registers.
#endif // !_X86_

#define MAX_THUNK_COUNTERS     64
#define MAX_PROCESSORS         32


#define PSTAT_READ_STATS         CTL_CODE (FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_SET_CESR           CTL_CODE (FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_HOOK_THUNK         CTL_CODE (FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_REMOVE_HOOK        CTL_CODE (FILE_DEVICE_UNKNOWN, 3, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_QUERY_EVENTS       CTL_CODE (FILE_DEVICE_UNKNOWN, 4, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_QUERY_EVENTS_INFO  CTL_CODE (FILE_DEVICE_UNKNOWN, 5, METHOD_NEITHER, FILE_ANY_ACCESS)

#define OFFSET(type, field) ((LONG_PTR)(&((type *)0)->field))

//
//
//

typedef struct {
    ULONGLONG       Counters[MAX_EVENTS];
    ULONG           EventId[MAX_EVENTS];
    ULONGLONG       TSC;
    ULONG           reserved;
// FIXFIX - Thierry - 01/2000: 
// To virtualize these counters, we should use ULONGLONG types and not polymorphic types.
    ULONG_PTR       SpinLockAcquires;     
    ULONG_PTR       SpinLockCollisions;
    ULONG_PTR       SpinLockSpins;
    ULONG_PTR       Irqls;
    ULONGLONG       ThunkCounters[MAX_THUNK_COUNTERS];
} PSTATS, *pPSTATS;

typedef struct {
    ULONG           EventId;
    BOOLEAN         Active;
    BOOLEAN         UserMode;
    BOOLEAN         KernelMode;
    BOOLEAN         EdgeDetect;
    ULONG           AppReserved;
    ULONG           reserved;
} SETEVENT, *PSETEVENT;

typedef struct {
    PUCHAR          SourceModule;
    ULONG_PTR       ImageBase;
    PUCHAR          TargetModule;
    PUCHAR          Function;
    ULONG           TracerId;
} HOOKTHUNK, *PHOOKTHUNK;

typedef struct {
    ULONG           EventId;
    KPROFILE_SOURCE ProfileSource;
    ULONG           DescriptionOffset;
    ULONG           SuggestedIntervalBase;
    UCHAR           Buffer[];
} EVENTID, *PEVENTID;

typedef struct _EVENTS_INFO {
    ULONG           Events;
    ULONG           TokenMaxLength;
    ULONG           DescriptionMaxLength;
    ULONG           OfficialTokenMaxLength;
    ULONG           OfficialDescriptionMaxLength;
} EVENTS_INFO, *PEVENTS_INFO;

#if defined(ExAllocatePool)
#undef ExAllocatePool
#endif
#define ExAllocatePool(Type,Size)   ExAllocatePoolWithTag((Type),(Size),'ttsp')

#endif /* _PSTAT_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\ntsdexts\secexts.h ===
#define GHI_TYPE        0x00000001
#define GHI_BASIC       0x00000002
#define GHI_NAME        0x00000004
#define GHI_SPECIFIC    0x00000008
#define GHI_VERBOSE     0x00000010
#define GHI_NOLOOKUP    0x00000020
#define GHI_SILENT      0x00000100

#define TYPE_NONE       0
#define TYPE_EVENT      1
#define TYPE_SECTION    2
#define TYPE_FILE       3
#define TYPE_PORT       4
#define TYPE_DIRECTORY  5
#define TYPE_LINK       6
#define TYPE_MUTANT     7
#define TYPE_WINSTA     8
#define TYPE_SEM        9
#define TYPE_KEY        10
#define TYPE_TOKEN      11
#define TYPE_PROCESS    12
#define TYPE_THREAD     13
#define TYPE_DESKTOP    14
#define TYPE_COMPLETE   15
#define TYPE_CHANNEL    16
#define TYPE_TIMER      17
#define TYPE_JOB        18
#define TYPE_WPORT      19
#define TYPE_DEBUG_OBJECT 20
#define TYPE_KEYED_EVENT  21
#define TYPE_MAX          22

extern LPWSTR   pszTypeNames[TYPE_MAX];

DWORD
GetObjectTypeIndex(
    LPCSTR  pszTypeName );

DWORD
GetHandleInfo(
    BOOL    Direct,
    HANDLE  hProcess,
    HANDLE  hThere,
    DWORD   Flags,
    DWORD * Type);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\app\calc.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdio.h>
#include "pperf.h"
#include "..\pstat.h"

extern UCHAR            Buffer[];
extern PDISPLAY_ITEM    Calc1, Calc2;
extern PDISPLAY_ITEM    PerfGraphList;
extern ULONG            NumberOfProcessors;
extern BOOL             LazyOp;

#define  BufferSize 60000

VOID AssignCalcId (PDISPLAY_ITEM pPerf);
PDISPLAY_ITEM LookUpCalcId (IN ULONG id);


VOID SnapPercent (PDISPLAY_ITEM);
VOID SnapSum (PDISPLAY_ITEM);
VOID InitPercent (PDISPLAY_ITEM);
VOID InitSum (PDISPLAY_ITEM);

ULONG   StaticPercentScale = 10000;
ULONG   CalcSort = 300000;

VOID   (*InitCalc[])(PDISPLAY_ITEM) = {
            InitPercent, InitSum, InitPercent, InitPercent
            };


INT_PTR
CALLBACK CalcDlgProc(
   HWND hDlg,
   unsigned int message,
   WPARAM wParam,
   LPARAM lParam
   )
{
    PDISPLAY_ITEM   pPerf;
    UINT            ButtonState;
    UINT            Index, i;

    switch (message) {
    case WM_INITDIALOG:
        Buffer[BufferSize - 1] = 0;
        _snprintf (Buffer, 
                   BufferSize - 1,
                   "A. %s", Calc1->PerfName);
        SetDlgItemText(hDlg, IDM_CALC_TEXTA, Buffer);

        _snprintf (Buffer, 
                   BufferSize - 1,
                   "B. %s", Calc2->PerfName);
        SetDlgItemText(hDlg, IDM_CALC_TEXTB, Buffer);
        return (TRUE);

    case WM_COMMAND:

           switch(wParam) {
           case IDOK:
                if (Calc1 && Calc2) {
                    for (i=IDM_CALC_FORM1; i <= IDM_CALC_FORM4; i++) {
                        if (SendDlgItemMessage(hDlg,i,BM_GETCHECK,0,0)) {
                            // found selected form type
                            i = i - IDM_CALC_FORM1;

                            AssignCalcId (Calc1);
                            AssignCalcId (Calc2);

                            pPerf = AllocateDisplayItem();
                            pPerf->CalcPercentId[0] = Calc1->CalcId;
                            pPerf->CalcPercentId[1] = Calc2->CalcId;
                            pPerf->SnapParam1 = i;
                            pPerf->IsCalc = TRUE;
                            InitCalc[i](pPerf);

                            SetDisplayToTrue (pPerf, CalcSort++);
                            RefitWindows(NULL, NULL);
                            break;
                        }
                    }
                }
                EndDialog(hDlg, DIALOG_SUCCESS);
                return (TRUE);

           case IDCANCEL:
                EndDialog(hDlg, DIALOG_CANCEL );
                return (TRUE);
        }
    }
    return (FALSE);
}


VOID
AssignCalcId (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    PDISPLAY_ITEM p;
    ULONG   l;

    if (pPerf->CalcId) {
        return ;
    }

    l = 0;
    for (p=PerfGraphList; p; p=p->Next) {
        if (p->CalcId > l) {
            l = p->CalcId;
        }
    }

    pPerf->CalcId = l + 1;
    pPerf->DispName[sizeof(pPerf->DispName) - 1] = 0;
    _snprintf (pPerf->DispName, 
               sizeof(pPerf->DispName) - 1,
               "%d. %s", l+1, pPerf->PerfName);
    pPerf->DispNameLen = strlen(pPerf->DispName);
}


PDISPLAY_ITEM
LookUpCalcId (
    IN ULONG id
    )
{
    PDISPLAY_ITEM p;

    for (p=PerfGraphList; p; p=p->Next) {
        if (p->CalcId == id) {
            return p;
        }
    }
    return NULL;
}



VOID
InitPercent (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    // for now use same type
    _snprintf (pPerf->PerfName, 
               sizeof(pPerf->PerfName) - 1,
               "%d %%of %d",
               Calc1->CalcId, Calc2->CalcId);
    pPerf->PerfName[sizeof(pPerf->PerfName) - 1] = 0;

    pPerf->SnapData   = SnapPercent;
    pPerf->IsPercent  = TRUE;
    pPerf->AutoTotal  = FALSE;
    pPerf->MaxToUse   = &StaticPercentScale;
    pPerf->DisplayMode= DISPLAY_MODE_TOTAL;
}


VOID
InitSum (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    // for now use same type
    _snprintf (pPerf->PerfName,
               sizeof(pPerf->PerfName) - 1,
               "Sum %d+%d",
               Calc1->CalcId, Calc2->CalcId);
    pPerf->PerfName[sizeof(pPerf->PerfName) - 1] = 0;


    pPerf->SnapData = SnapSum;
}


VOID
SnapPercent (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    PDISPLAY_ITEM   p1, p2;
    ULONG   i, l, l1, l2;

    p1 = pPerf->CalcPercent[0];
    p2 = pPerf->CalcPercent[1];
    if (p1 == NULL  ||  p2 == NULL) {
        p1 = pPerf->CalcPercent[0] = LookUpCalcId (pPerf->CalcPercentId[0]);
        p2 = pPerf->CalcPercent[1] = LookUpCalcId (pPerf->CalcPercentId[1]);

        if (p1 == NULL || p2 == NULL) {
            LazyOp = TRUE;
            pPerf->DeleteMe = TRUE;
            return;
        }
    }

    l1 = p1->DataList[0][0];
    l2 = p2->DataList[0][0];

    if (l1 > 0x60000) {
        l2 = l2 / 10000;
    } else {
        l1 = l1 * 10000;
    }

    if (l2) {
        pPerf->CurrentDataPoint[0] = l1 / l2;
    } else {
        pPerf->CurrentDataPoint[0] = 0;
    }
}


VOID
SnapSum (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    PDISPLAY_ITEM   p1, p2;
    ULONG   i, l, l1, l2;

    p1 = pPerf->CalcPercent[0];
    p2 = pPerf->CalcPercent[1];
    if (p1 == NULL  ||  p2 == NULL) {
        p1 = pPerf->CalcPercent[0] = LookUpCalcId (pPerf->CalcPercentId[0]);
        p2 = pPerf->CalcPercent[1] = LookUpCalcId (pPerf->CalcPercentId[1]);

        if (p1 == NULL || p2 == NULL) {
            LazyOp = TRUE;
            pPerf->DeleteMe = TRUE;
            return;
        }
    }

    for (i=0; i < NumberOfProcessors; i++) {
        pPerf->CurrentDataPoint[i+1] =
            p1->CurrentDataPoint[i+1] + p2->CurrentDataPoint[i+1];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\app\calcperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtrp.h

Abstract:

    This module contains NT/Win32 Perfmtr private data and types

Author:

    Mark Enstrom (marke) 28-Mar-1991

Revision History:

--*/

#ifndef _CALCPERFH_INCLUDED_
#define _CALCPERFH_INCLUDED_

#define MAX_PROCESSORS   32
#define DATA_LIST_LENGTH 100
#define DELAY_SECONDS    2

//
// display const
//

#define BORDER_WIDTH   2
#define INDENT_WIDTH   8
#define GRAPH_WIDTH    130
#define GRAPH_HEIGHT   40

//
//  time constant for sampling performance
//

#define PERF_TIME_DELAY 1000

//
//  types of display modes
//

#define DISPLAY_MODE_TOTAL          0
#define DISPLAY_MODE_BREAKDOWN      1
#define DISPLAY_MODE_PER_PROCESSOR  2

//
//  This info packet is associated with each
//  performance item
//

typedef struct tagDISPLAYITEM
{
    HDC     MemoryDC;
    HBITMAP MemoryBitmap;
    struct  tagDISPLAYITEM  *Next;
    ULONG   sort;
    PULONG  MaxToUse;
    ULONG   Max;
    ULONG   PositionX;
    ULONG   PositionY;
    ULONG   Width;
    ULONG   Height;
    ULONG   CurrentDrawingPos;
    ULONG   Mega;
    RECT    Border;
    RECT    GraphBorder;
    RECT    TextBorder;
    BOOL    ChangeScale;
    BOOL    DeleteMe;
    BOOL    Display;
    BOOL    AutoTotal;
    BOOL    IsPercent;
    BOOL    IsCalc;
    UCHAR   na[2];
    ULONG   DisplayMode;
    struct  tagDISPLAYITEM  *CalcPercent[2];
    ULONG   CalcPercentId[2];
    ULONG   CalcId;
    UCHAR   PerfName[80];
    UCHAR   DispName[80];
    ULONG   DispNameLen;
    VOID    (*SnapData)(struct tagDISPLAYITEM *pItem);
    ULONG   SnapParam1;
    ULONG   SnapParam2;
    ULONG   LastAccumulator     [MAX_PROCESSORS+1];
    ULONG   CurrentDataPoint    [MAX_PROCESSORS+1];
    PULONG  DataList            [MAX_PROCESSORS+1];

} DISPLAY_ITEM,*PDISPLAY_ITEM;

//
// flag to activate each menu selection
//

#define DISPLAY_INACTIVE 0
#define DISPLAY_ACTIVE   1

VOID
SetCounterEvents (PVOID Events, ULONG length);

// this function is really found in pperf.h but is
// used in calcperf.c so it'd prototyped here
VOID
InitPossibleEventList();

BOOL
UpdatePerfInfo(
   PULONG   DataPointer,
   ULONG    NewDataValue,
   PULONG   OldMaxValue
   );

VOID
UpdatePerfInfo1(
   PULONG    DataPointer,
   ULONG     NewDataValue
   );

VOID
UpdateInternalStats (
    VOID
);


VOID
InitListData(
   PDISPLAY_ITEM    PerfListItem,
   ULONG            NumberOfItems
   );

#endif /* _CALCPERFH_INCLUDED */


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\app\calcperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   CalcPerf.c

Abstract:

   calculate perfoemance statistics

Author:



Environment:

   Win32

Revision History:

   10-20-91     Initial version



--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include "calcperf.h"
#include "..\pstat.h"

//SYSTEM_PERFORMANCE_INFORMATION              PerfInfo;
//SYSTEM_PERFORMANCE_INFORMATION              PreviousPerfInfo;

#define     INFSIZE     60000

HANDLE      DriverHandle;

ULONG                                       NumberOfProcessors;
ULONG                                       Buffer[INFSIZE/4];

extern  ULONG   UseGlobalMax, GlobalMax;

ULONG
InitPerfInfo()
/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

   None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-21-91      Initial code

--*/

{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSORS) {
        return(0);
    }


    //
    // Open P5Stat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        DriverHandle = NULL;
        return 0;
    }

    InitPossibleEventList();

    return(NumberOfProcessors);
}


BOOL
CalcPerf(
   PDISPLAY_ITEM    pPerf1
   )

/*++

Routine Description:

   calculate and return %cpu time and time periods

Arguments:

   None

Return Value:


Revision History:

      10-21-91      Initial code

--*/

{
    ULONG           i;
    ULONG           TotalDataPoint;
    ULONG           OldGlobalMax;
    PDISPLAY_ITEM   pPerf;

    //
    // get system performance info
    //

    OldGlobalMax = GlobalMax;
    GlobalMax = 0;
    UpdateInternalStats();

    for (pPerf = pPerf1; pPerf; pPerf = pPerf->Next) {

        TotalDataPoint = 0;
        pPerf->SnapData (pPerf);

        if (pPerf->AutoTotal) {
            //
            // Automatically calc system total by summing each processor
            //

            switch (pPerf->DisplayMode) {
                case DISPLAY_MODE_TOTAL:
                case DISPLAY_MODE_BREAKDOWN:
                default:

                    for (i=0; i < NumberOfProcessors; i++) {
                        TotalDataPoint += pPerf->CurrentDataPoint[i + 1];

                        UpdatePerfInfo1 (
                            pPerf->DataList[i + 1],
                            pPerf->CurrentDataPoint[i + 1]
                            );
                    }

                    pPerf->ChangeScale = UpdatePerfInfo (
                                            pPerf->DataList[0],
                                            TotalDataPoint,
                                            &pPerf->Max
                                            );

                    break;

                case DISPLAY_MODE_PER_PROCESSOR:
                    for (i=0; i < NumberOfProcessors; i++) {

                        TotalDataPoint += pPerf->CurrentDataPoint[i + 1];

                        pPerf->ChangeScale = UpdatePerfInfo (
                            pPerf->DataList[i + 1],
                            pPerf->CurrentDataPoint[i + 1],
                            &pPerf->Max
                            );

                    }

                    UpdatePerfInfo1 (pPerf->DataList[0], TotalDataPoint);
                    break;
            }
        } else {
            for (i=0; i < NumberOfProcessors+1; i++) {
                pPerf->ChangeScale = UpdatePerfInfo (
                    pPerf->DataList[i],
                    pPerf->CurrentDataPoint[i],
                    &pPerf->Max
                    );
            }
        }

    }

    if (UseGlobalMax  &&  OldGlobalMax != GlobalMax) {
        for (pPerf = pPerf1; pPerf; pPerf = pPerf->Next) {
            pPerf->ChangeScale = TRUE;
        }
    }

    return(TRUE);
}

VOID
UpdateInternalStats(VOID)
{
    IO_STATUS_BLOCK             IOSB;

    if (! DriverHandle) {
        return;
    }

    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_READ_STATS,
        Buffer,                 // input buffer
        INFSIZE,
        NULL,                   // output buffer
        0
    );
}

VOID
SetCounterEvents (PVOID Events, ULONG length)
{
    IO_STATUS_BLOCK             IOSB;

    if (! DriverHandle) {
        return;
    }

    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_SET_CESR,
        Events,                 // input buffer
        length,
        NULL,                   // output buffer
        0
    );
}

VOID
SnapNull (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    ULONG   i;

    for (i=0; i < NumberOfProcessors; i++) {
        pPerf->CurrentDataPoint[i + 1] = 0;
    }
}


VOID
SnapInterrupts (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfo[MAX_PROCESSORS];
    ULONG   i, l;

    NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSORS,
       NULL
    );

    for (i=0; i < NumberOfProcessors; i++) {
        l = ProcessorInfo[i].InterruptCount - pPerf->LastAccumulator[i+1];
        pPerf->LastAccumulator[i+1] = ProcessorInfo[i].InterruptCount;
        pPerf->CurrentDataPoint[i+1] = l / DELAY_SECONDS;
    }
}

VOID
SnapPrivateInfo (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    ULONG   i, j, l, len;
    PULONG  PrivateStat;


    len = *((PULONG) Buffer);
    PrivateStat = (PULONG) ((PUCHAR) Buffer + sizeof(ULONG) + pPerf->SnapParam1);

    // accumlating data, take delta

    for (i=0; i < NumberOfProcessors; i++) {
        if (pPerf->Mega) {
            PULONGLONG li = (PULONGLONG) PrivateStat;

            *li = *li >> 10;
        }

        j = *PrivateStat / DELAY_SECONDS;
        l = j - pPerf->LastAccumulator[i+1];
        pPerf->LastAccumulator[i+1] = j;

        if (l > 0) {
            pPerf->CurrentDataPoint[i+1] = l;

        } else {
            // item wrapped
            pPerf->CurrentDataPoint[i+1] = 0 - l;
        }

        PrivateStat = (PULONG)((PUCHAR)PrivateStat + len);
    }
}



BOOL
UpdatePerfInfo(
   PULONG    DataPointer,
   ULONG     NewDataValue,
   PULONG    OldMaxValue
   )

/*++

Routine Description:

    Shift array of DATA_LIST_LENGTH USORTS and add the new value to the
    start of list

Arguments:

    DataPointer  - Pointer to the start of a DATA_LIST_LENGTH array
    NewDataValue - Data element to be added
    OldMaxValue  - Scale value

Return Value:

    TRUE is MaxValue must be increased or decreased

Revision History:

      10-21-91      Initial code

--*/

{
    ULONG   Index;
    ULONG   ScanMax;

    //
    //  Shift DataArray while keeping track of the max value
    //


    //
    //  Set temp max to 100 to init a minimum maximum
    //

    ScanMax = 100;

    for (Index=DATA_LIST_LENGTH-1;Index>=1;Index--) {

        DataPointer[Index] = DataPointer[Index-1];



        if (DataPointer[Index] > ScanMax) {
            ScanMax = DataPointer[Index];
        }
    }

    //
    // add and check first value
    //

    DataPointer[0] = NewDataValue;

    if (NewDataValue > ScanMax) {
        ScanMax = NewDataValue;
    }

    //
    //  If Max values changed then undate the new max
    //  value and return TRUE.
    //

    if (ScanMax > GlobalMax) {
        GlobalMax = ScanMax;
    }

    if (ScanMax != *OldMaxValue) {
        if (ScanMax < *OldMaxValue  &&
            *OldMaxValue - ScanMax <= *OldMaxValue / 10) {
                //
                // New ScanMax is smaller, but only by a tiny amount
                //

                return (FALSE);
        }

        *OldMaxValue = ScanMax;
        return(TRUE);
    }

    return(FALSE);

}

VOID
UpdatePerfInfo1(
   PULONG    DataPointer,
   ULONG     NewDataValue
   )

/*++

Routine Description:

    Shift array of DATA_LIST_LENGTH USORTS and add the new value to the
    start of list

Arguments:

    DataPointer  - Pointer to the start of a DATA_LIST_LENGTH array
    NewDataValue - Data element to be added
    OldMaxValue  - Scale value

Return Value:

    TRUE is MaxValue must be increased or decreased

Revision History:

      10-21-91      Initial code

--*/

{
    ULONG   Index;
    ULONG   ScanMax;

    //
    //  Shift DataArray while keeping track of the max value
    //


    //
    //  Set temp max to 100 to init a minimum maximum
    //

    ScanMax = 100;

    for (Index=DATA_LIST_LENGTH-1;Index>=1;Index--) {

        DataPointer[Index] = DataPointer[Index-1];
    }

    //
    // add and check first value
    //

    DataPointer[0] = NewDataValue;

    return ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\app\pperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Wperf.c

Abstract:

   Win32 application to display performance statictics.

Author:

   Ken Reneris  hacked into pperf.exe

   original code from Mark Enstrom

Environment:

   Win32

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include "pperf.h"
#include "..\pstat.h"



//
// global handles
//

HANDLE  hInst;

extern UCHAR Buffer[];
extern HANDLE   DriverHandle;

//
// Selected Display Mode (read from wp2.ini), default set here.
//

DISPLAY_ITEM    *PerfGraphList;
WINPERF_INFO    WinperfInfo;


VOID SnapNull (PDISPLAY_ITEM);
VOID SnapPrivateInfo (PDISPLAY_ITEM);
VOID SnapInterrupts (PDISPLAY_ITEM);
VOID SnapCsTest (PDISPLAY_ITEM);

ULONG   DefaultDisplayMode = DISPLAY_MODE_TOTAL;
ULONG   UseGlobalMax, LogIt;
ULONG   GlobalMax;
PDISPLAY_ITEM   Calc1, Calc2;
BOOLEAN LazyOp;

#define MAX_EVENTS         2

struct {
    ULONG   EventId;
    PUCHAR  ShortName;
    PUCHAR  PerfName;
} *Counters;

struct {
    ULONG           WhichCounter;
    ULONG           ComboBoxIndex;
    PDISPLAY_ITEM   pWhichGraph;
    BOOLEAN         R0;
    BOOLEAN         R3;
    UCHAR           na[2];
} ActiveCounters [MAX_EVENTS];

SETEVENT CounterEvents[MAX_EVENTS];


typedef struct {
    ULONG           IdSel;
    PDISPLAY_ITEM   WhichGraph;
    ULONG           State;
    VOID            (*Fnc)(PDISPLAY_ITEM);
    ULONG           Param;
    PUCHAR          Name;
} GENCOUNTER, *PGENCOUNTER;

GENCOUNTER GenCounts[] = {
    IDM_SCALE,          NULL, 0, NULL,            0, NULL,
    IDM_LOGIT,          NULL, 0, NULL,            0, NULL,

    IDM_SPIN_ACQUIRE,   NULL, 0, SnapPrivateInfo, OFFSET(PSTATS, SpinLockAcquires),   "KRes[0]",
    IDM_SPIN_COLL,      NULL, 0, SnapPrivateInfo, OFFSET(PSTATS, SpinLockCollisions), "KRes[1]",
    IDM_SPIN_SPIN,      NULL, 0, SnapPrivateInfo, OFFSET(PSTATS, SpinLockSpins),      "KRes[2]",
    IDM_IRQL,           NULL, 0, SnapPrivateInfo, OFFSET(PSTATS, Irqls),              "KRes[3]",
    IDM_INT,            NULL, 0, SnapInterrupts,  0, "Interrupts",
//  IDM_PERCENT,        NULL, 0, SnapPercent,     0, "Percent 1-2",

// to track checked state
    IDM_P5_R0_0,         NULL, 0, NULL,           0, NULL,
    IDM_P5_R3_0,         NULL, 0, NULL,           0, NULL,
    IDM_P5_K_0,          NULL, 0, NULL,           0, NULL,

    IDM_P5_R0_1,         NULL, 0, NULL,           0, NULL,
    IDM_P5_R3_1,         NULL, 0, NULL,           0, NULL,
    IDM_P5_K_1,          NULL, 0, NULL,           0, NULL,

// eol
    0, NULL, 0, NULL, 0, NULL
};


VOID
InitComboBox (
    HWND hDlg,
    ULONG id,
    ULONG counter
);

VOID
SetGenPerf (
    HWND hDlg,
    PGENCOUNTER GenCount
);


int
__cdecl
main(USHORT argc, CHAR **argv)
/*++

Routine Description:

   Windows entry point routine


Arguments:

Return Value:

   status of operation

Revision History:

      03-21-91      Initial code

--*/
{

//
//
//

   HANDLE   hInstance     = GetModuleHandle(NULL);
   HANDLE   hPrevInstance = (HANDLE)NULL;
   INT      nCmdShow      = SW_SHOWDEFAULT;
   USHORT   _argc         = argc;
   CHAR     **_argv       = argv;
   MSG      msg;
   HBRUSH   BackBrush;


    //
    // check for other instances of this program
    //

    BackBrush = CreateSolidBrush(RGB(192,192,192));

    if (!InitApplication(hInstance,BackBrush)) {
        //DbgPrint("Init Application fails\n");
        return (FALSE);
    }


    //
    // Perform initializations that apply to a specific instance
    //

    if (!InitInstance(hInstance, nCmdShow)){
        //DbgPrint("Init Instance fails\n");
        return (FALSE);
    }

    //
    // Acquire and dispatch messages until a WM_QUIT message is received.
    //


    while (GetMessage(&msg,        // message structure
            (HWND)NULL,            // handle of window receiving the message
            (UINT)NULL,            // lowest message to examine
            (UINT)NULL))           // highest message to examine
        {
        TranslateMessage(&msg);    // Translates virtual key codes
        DispatchMessage(&msg);     // Dispatches message to window
    }

    DeleteObject(BackBrush);

    return (msg.wParam);           // Returns the value from PostQuitMessage
}




BOOL
InitApplication(
    HANDLE  hInstance,
    HBRUSH  hBackground)

/*++

Routine Description:

   Initializes window data and registers window class.

Arguments:

   hInstance   - current instance
   hBackground - background fill brush

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{
    WNDCLASS  wc;
    BOOL      ReturnStatus;

    //
    // Fill in window class structure with parameters that describe the
    // main window.
    //

    wc.style         = CS_DBLCLKS;                          // Class style(s).
    wc.lpfnWndProc   = MainWndProc;                         // Function to retrieve messages for
                                                            // windows of this class.
    wc.cbClsExtra    = 0;                                   // No per-class extra data.
    wc.cbWndExtra    = 0;                                   // No per-window extra data.
    wc.hInstance     = hInstance;                           // Application that owns the class.
    wc.hIcon         = LoadIcon(hInstance,                  //
                            MAKEINTRESOURCE(WINPERF_ICON)); // Load Winperf icon
    wc.hCursor       = LoadCursor((HANDLE)NULL, IDC_ARROW); // Load default cursor
    wc.hbrBackground = hBackground;;                        // Use background passed to routine
    wc.lpszMenuName  = "pperfMenu";                         // Name of menu resource in .RC file.
    wc.lpszClassName = "PPerfClass";                        // Name used in call to CreateWindow.

    ReturnStatus = RegisterClass(&wc);

    return(ReturnStatus);

}





BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    )

/*++

Routine Description:

   Save instance handle and create main window. This function performs
   initialization tasks that cannot be shared by multiple instances.

Arguments:

    hInstance - Current instance identifier.
    nCmdShow  - Param for first ShowWindow() call.

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{


    DWORD   WindowStyle;

    //
    // Save the instance handle in a static variable, which will be used in
    // many subsequent calls from this application to Windows.
    //

    hInst = hInstance;

    //
    // init the window position and size to be in the upper corner of
    // the screen, 200x100
    //


    //
    //  What I want here is a way to get the WINDOW dimensions
    //

    WinperfInfo.WindowPositionX = 640 - 250;
    WinperfInfo.WindowPositionY = 0;
    WinperfInfo.WindowSizeX	= 250;
    WinperfInfo.WindowSizeY     = 100;

    //
    //  read profile data from .ini file
    //

    // InitProfileData(&WinperfInfo);

    WinperfInfo.hMenu = LoadMenu(hInstance,"pperfMenu");

    //
    // Create a main window for this application instance.
    //

    WinperfInfo.hWndMain = CreateWindow(
        "PPerfClass",                   // See RegisterClass() call.
        "x86 Perf Meter",               // Text for window title bar.
        WS_OVERLAPPEDWINDOW,            // window style
        WinperfInfo.WindowPositionX,    // Default horizontal position.
        WinperfInfo.WindowPositionY,    // Default vertical position.
        WinperfInfo.WindowSizeX,        // Default width.
        WinperfInfo.WindowSizeY,        // Default height.
        (HWND)NULL,                     // Overlapped windows have no parent.
        (HMENU)NULL,                    // Use the window class menu.
        hInstance,                      // This instance owns this window.
        (LPVOID)NULL                    // Pointer not needed.
    );

    //
    // If window could not be created, return "failure"
    //

    if (!WinperfInfo.hWndMain) {
      return (FALSE);
    }


    //
    // Show menu initially
    //

    WindowStyle = GetWindowLong(WinperfInfo.hWndMain,GWL_STYLE);
    WindowStyle = (WindowStyle & (~STYLE_DISABLE_MENU)) | STYLE_ENABLE_MENU;
    SetMenu(WinperfInfo.hWndMain,WinperfInfo.hMenu);
    SetWindowLong(WinperfInfo.hWndMain,GWL_STYLE,WindowStyle);
    SetWindowPos(WinperfInfo.hWndMain, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
    ShowWindow(WinperfInfo.hWndMain,SW_SHOW);
    WinperfInfo.DisplayMode=STYLE_ENABLE_MENU;
    WinperfInfo.DisplayMenu = TRUE;


    //
    // Make the window visible; update its client area; and return "success"
    //

    SetFocus(WinperfInfo.hWndMain);
    ShowWindow(WinperfInfo.hWndMain, SW_SHOWNORMAL);
    UpdateWindow(WinperfInfo.hWndMain);

    return (TRUE);

}


VOID
InitPossibleEventList()
{
    UCHAR               buffer[400];
    ULONG               i, Count;
    NTSTATUS            status;
    PEVENTID            Event;
    IO_STATUS_BLOCK     IOSB;


    if (! DriverHandle) {
        return;
    }

    //
    // Initialize possible counters
    //

    // determine how many events there are

    Event = (PEVENTID) buffer;
    Count = 0;
    do {
        *((PULONG) buffer) = Count;
        Count += 1;

        status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    PSTAT_QUERY_EVENTS,
                    buffer,                 // input buffer
                    sizeof (buffer),
                    NULL,                   // output buffer
                    0
                    );
    } while (NT_SUCCESS(status));

    Counters = malloc(sizeof(*Counters) * Count);
    if (Counters == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    Count -= 1;
    for (i=0; i < Count; i++) {
        *((PULONG) buffer) = i;
        NtDeviceIoControlFile(
           DriverHandle,
           (HANDLE) NULL,          // event
           (PIO_APC_ROUTINE) NULL,
           (PVOID) NULL,
           &IOSB,
           PSTAT_QUERY_EVENTS,
           buffer,                 // input buffer
           sizeof (buffer),
           NULL,                   // output buffer
           0
           );

        Counters[i].EventId   = Event->EventId;
        Counters[i].ShortName = _strdup (Event->Buffer);
        Counters[i].PerfName  = _strdup (Event->Buffer + Event->DescriptionOffset);
    }

    Counters[i].EventId   = 0;
    Counters[i].ShortName = NULL;
    Counters[i].PerfName  = NULL;
}



INT_PTR
CALLBACK
MainWndProc(
   HWND   hWnd,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   message - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation


Revision History:

      02-17-91      Initial code

--*/

{
    int             DialogResult;
    PAINTSTRUCT     ps;
    PDISPLAY_ITEM   pPerf, p;
    ULONG           l, i, x, y;
    HDC             hDC;
                     
    //
    //   process each message
    //

    switch (message) {

        //
        // create window
        //

        case WM_CREATE:
        {
            
            BOOLEAN   Fit;
            UINT      Index;

            hDC = GetDC(hWnd);
            //
            // make brushes and pens
            //

            WinperfInfo.hBluePen     = CreatePen(PS_SOLID,1,RGB(0,0,128));
            WinperfInfo.hDotPen      = CreatePen(PS_DOT,1,RGB(0,0,0));

            WinperfInfo.hPPen[0] = CreatePen(PS_SOLID,1,RGB(255,  0,    0));
            WinperfInfo.hPPen[1] = CreatePen(PS_SOLID,1,RGB(  0, 255,   0));
            WinperfInfo.hPPen[2] = CreatePen(PS_SOLID,1,RGB(255, 255,   0));
            WinperfInfo.hPPen[3] = CreatePen(PS_SOLID,1,RGB(255,   0, 255));
            WinperfInfo.hPPen[4] = CreatePen(PS_SOLID,1,RGB(128,   0,   0));
            WinperfInfo.hPPen[5] = CreatePen(PS_SOLID,1,RGB(  0, 128,   0));
            WinperfInfo.hPPen[6] = CreatePen(PS_SOLID,1,RGB(128, 128,   0));
            WinperfInfo.hPPen[7] = CreatePen(PS_SOLID,1,RGB(128,   0, 128));
            WinperfInfo.hPPen[8] = CreatePen(PS_SOLID,1,RGB(  0,   0, 128));
            WinperfInfo.hPPen[9] = CreatePen(PS_SOLID,1,RGB(  0, 128, 128));
            WinperfInfo.hPPen[10]= CreatePen(PS_SOLID,1,RGB(128, 128, 128));
            // the other 20 pens will just reuse these handles

            WinperfInfo.hBackground  = CreateSolidBrush(RGB(192,192,192));
            WinperfInfo.hLightBrush  = CreateSolidBrush(RGB(255,255,255));
            WinperfInfo.hDarkBrush   = CreateSolidBrush(RGB(128,128,128));
            WinperfInfo.hRedBrush    = CreateSolidBrush(RGB(255,000,000));
            WinperfInfo.hGreenBrush  = CreateSolidBrush(RGB(000,255,000));
            WinperfInfo.hBlueBrush   = CreateSolidBrush(RGB(000,000,255));

            //
            //  create thee fonts using NT default font families
            //

            WinperfInfo.SmallFont      = CreateFont(8,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Small Fonts");

            WinperfInfo.MediumFont      = CreateFont(10,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");

            WinperfInfo.LargeFont      = CreateFont(14,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");


            //
            // create a system timer event to call performance gathering routines by.
            //

            WinperfInfo.TimerId = SetTimer(hWnd,(UINT)TIMER_ID,(UINT)1000 * DELAY_SECONDS,(TIMERPROC)NULL);

            //
            // init performance routines
            //

            WinperfInfo.NumberOfProcessors = InitPerfInfo();

            // copy pen's for remaining processor breakout
            for (i=11; i < WinperfInfo.NumberOfProcessors; i++) {
                WinperfInfo.hPPen[i] = WinperfInfo.hPPen[i % 12];
            }

            if (!WinperfInfo.NumberOfProcessors) {
                MessageBox(hWnd,"P5Stat driver not installed","Winperf",MB_OK);
                DestroyWindow(hWnd);
            }

            //
            // init display variables
            //

            RefitWindows (hWnd, hDC);

            //
            // release the DC handle
            //

            ReleaseDC(hWnd,hDC);

      }
      break;

      //
      // re-size
      //

      case WM_SIZE:

      {
            //int     i;
            RECT    ClientRect;
            BOOLEAN Fit;

            hDC = GetDC(hWnd);
            //
            // get size of client area
            //

            GetWindowRect(hWnd,&ClientRect);

            WinperfInfo.WindowPositionX = ClientRect.left;
            WinperfInfo.WindowPositionY = ClientRect.top;
            WinperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            WinperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            RefitWindows(hWnd, NULL);
      }
      break;

      case WM_MOVE:
      {
            RECT    ClientRect;


            hDC = GetDC(hWnd);

            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            WinperfInfo.WindowPositionX = ClientRect.left;
            WinperfInfo.WindowPositionY = ClientRect.top;
            WinperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            WinperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            ReleaseDC(hWnd,hDC);

      }

      break;


      //
      // command from application menu
      //

    case WM_COMMAND:



            switch (wParam){

               //
               // exit window
               //

               case IDM_EXIT:

                  DestroyWindow(hWnd);
                  break;

               //
               // about command
               //

            case IDM_SELECT:
                DialogResult = DialogBox(hInst, MAKEINTRESOURCE(IDM_SEL_DLG), hWnd, SelectDlgProc);
                if (DialogResult == DIALOG_SUCCESS) {
                    RefitWindows(hWnd, NULL);
                }
                break;

            case IDM_DISPLAY_TOTAL:
                SetDefaultDisplayMode (hWnd, DISPLAY_MODE_TOTAL);
                break;
            case IDM_DISPLAY_BREAKDOWN:
                SetDefaultDisplayMode (hWnd, DISPLAY_MODE_BREAKDOWN);
                break;
            case IDM_DISPLAY_PER_PROCESSOR:
                SetDefaultDisplayMode (hWnd, DISPLAY_MODE_PER_PROCESSOR);
                break;

            case IDM_TOPMOST:
                //SetWindowPos( hWnd, HWND_NOTOPMOST, 0, 0, 0, 0,
                //                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

                SetWindowPos( hWnd, HWND_TOPMOST, 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                break;

            case IDM_THUNK:
                DialogBox(hInst, MAKEINTRESOURCE(IDM_THUNK_DLG), hWnd, ThunkDlgProc);
                break;

            case IDM_HACK:
                DoCSTest(hWnd);
                RefitWindows(hWnd, NULL);
                break;

            default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
            }

            break;

        case WM_PAINT:

            //
            // repaint the window
            //

            {

                
                hDC = BeginPaint(hWnd,&ps);

                SelectObject(hDC,GetStockObject(NULL_BRUSH));
                for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                    DrawFrame(hDC,pPerf);
                    DrawPerfText(hDC,pPerf);
                    DrawPerfGraph(hDC,pPerf);
                }

                EndPaint(hWnd,&ps);

            }
            break;


        case WM_TIMER:
        {
            
            hDC = GetDC(hWnd);

            //
            // Calc new information
            //

            CalcPerf(PerfGraphList);

            //
            // If some lazy op, then perform it
            //

            if (LazyOp) {
                pPerf=PerfGraphList;
                while (pPerf) {
                    if (pPerf->DeleteMe) {
                        pPerf = SetDisplayToFalse (pPerf);
                    } else {
                        pPerf = pPerf->Next;
                    }
                }
                RefitWindows(hWnd, hDC);
                LazyOp = FALSE;
            }

            //
            // update all performance information
            //

            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                if (pPerf->ChangeScale) {
                    DrawPerfText(hDC,pPerf);
                    DrawPerfGraph(hDC,pPerf);
                } else {
                    DrawPerfText(hDC,pPerf);
                    ShiftPerfGraph(hDC,pPerf);
                }
            }
            ReleaseDC(hWnd,hDC);
        }
        break;

        //
        // right double click
        //

        case WM_NCRBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
            Calc1 = NULL;

            y = HIWORD(lParam);
            x = LOWORD(lParam);
            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                if (x > pPerf->PositionX  &&  x < pPerf->PositionX+pPerf->Width  &&
                    y > pPerf->PositionY  &&  y < pPerf->PositionY+pPerf->Height) {

                    if (pPerf->IsCalc) {
                        SetDisplayToFalse (pPerf);
                        FreeDisplayItem (pPerf);
                        RefitWindows (hWnd, NULL);
                        break;
                    }


                    switch (pPerf->DisplayMode) {
                        case DISPLAY_MODE_TOTAL:            l = DISPLAY_MODE_BREAKDOWN;     break;
                        case DISPLAY_MODE_BREAKDOWN:        l = DISPLAY_MODE_PER_PROCESSOR; break;
                        case DISPLAY_MODE_PER_PROCESSOR:    l = DISPLAY_MODE_TOTAL;         break;
                    }

                    pPerf->DisplayMode = l;
                    hDC = BeginPaint(hWnd,&ps);
                    DrawPerfGraph(hDC,pPerf);       // redraw graph in new mode
                    EndPaint(hWnd,&ps);
                    break;
                }
            }
            break;

            switch (DefaultDisplayMode) {
                case DISPLAY_MODE_TOTAL:            l = DISPLAY_MODE_BREAKDOWN;     break;
                case DISPLAY_MODE_BREAKDOWN:        l = DISPLAY_MODE_PER_PROCESSOR; break;
                case DISPLAY_MODE_PER_PROCESSOR:    l = DISPLAY_MODE_TOTAL;         break;
            }

            DefaultDisplayMode = l;
            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                pPerf->DisplayMode = l;
                hDC = BeginPaint(hWnd,&ps);
                DrawPerfGraph(hDC,pPerf);       // redraw graph in new mode
                EndPaint(hWnd,&ps);
            }
            break;

        //
        // handle a double click
        //

        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            DWORD   WindowStyle;


            //
            // get old window style, take out caption and menu
            //

            Calc1 = NULL;
            if (!IsIconic(hWnd)) {

                if (WinperfInfo.DisplayMenu) {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
                    SetMenu(hWnd,NULL);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    WinperfInfo.DisplayMode=STYLE_DISABLE_MENU;
                    WinperfInfo.DisplayMenu = FALSE;

                } else {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle & (~STYLE_DISABLE_MENU)) | STYLE_ENABLE_MENU;
                    SetMenu(hWnd,WinperfInfo.hMenu);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, (HWND)NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    WinperfInfo.DisplayMode=STYLE_ENABLE_MENU;
                    WinperfInfo.DisplayMenu = TRUE;
                }
            } else {
                DefWindowProc(hWnd, message, wParam, lParam);
            }


        }
        break;

        case WM_NCRBUTTONDOWN:
        case WM_RBUTTONDOWN:
            y = HIWORD(lParam);
            x = LOWORD(lParam);
            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                if (x > pPerf->PositionX  &&  x < pPerf->PositionX+pPerf->Width  &&
                    y > pPerf->PositionY  &&  y < pPerf->PositionY+pPerf->Height) {

                    if (!Calc1) {
                        Calc1 = pPerf;
                        break;
                    }

                    if (Calc1 != pPerf) {
                        Calc2 = pPerf;
                        DialogBox(hInst, MAKEINTRESOURCE(IDM_CALC_DLG), hWnd, CalcDlgProc);
                        Calc1 = Calc2 = NULL;
                        break;
                    }
                    break;
                }
            }
            break;


        //
        //  enable dragging with mouse in non-client
        //

        case WM_NCHITTEST:
        {
            lParam = DefWindowProc(hWnd, message, wParam, lParam);
            if ((WinperfInfo.DisplayMenu==FALSE) && (lParam == HTCLIENT)) {
                return(HTCAPTION);
            } else {
                return(lParam);
            }


        }
        break;

        case WM_DESTROY:
        {
            UINT    Index;

            //
            // Save profile info
            //

            // SaveProfileData(&WinperfInfo);

            //
            // Delete Windows Objects
            //

            KillTimer(hWnd,TIMER_ID);

            DeleteObject(WinperfInfo.hBluePen);
            for (i=0; i < 12; i++) {
                DeleteObject(WinperfInfo.hPPen[i]);
            }

            for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                DeleteMemoryContext(pPerf);
            }

            //
            // Destroy window
            //

            PostQuitMessage(0);
         }
         break;


        default:

            //
            // Passes message on if unproccessed
            //

            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return ((LONG)NULL);
}




INT_PTR
CALLBACK SelectDlgProc(
   HWND         hDlg,
   unsigned int message,
   WPARAM       wParam,
   LPARAM       lParam
   )

/*++

Routine Description:

   Process message for select dialog box.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    PDISPLAY_ITEM   pPerf;
    UINT            ButtonState;
    UINT            Index, i;

    switch (message) {
    case WM_INITDIALOG:
        InitComboBox (hDlg, IDM_P5_GEN1, 0);
        InitComboBox (hDlg, IDM_P5_GEN2, 1);

        for (i=0; GenCounts[i].IdSel; i++) {
            SendDlgItemMessage(
                    hDlg,
                    GenCounts[i].IdSel,
                    BM_SETCHECK,
                    GenCounts[i].State,
                    0
                );
        }

        return (TRUE);

    case WM_COMMAND:

           switch(wParam) {

               //
               // end function
               //


           case IDOK:
           case IDM_ACCEPT:
                SetP5Perf  (hDlg, IDM_P5_GEN1, 0);
                SetP5Perf  (hDlg, IDM_P5_GEN2, 1);
                for (i=0; GenCounts[i].IdSel; i++) {
                    SetGenPerf (hDlg, GenCounts+i);
                }

                UseGlobalMax = GenCounts[0].State;
                LogIt        = GenCounts[1].State;

                for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
                    pPerf->MaxToUse =
                        UseGlobalMax ? &GlobalMax : &pPerf->Max;
                }

                if (wParam == IDOK) {
                    EndDialog(hDlg, DIALOG_SUCCESS);
                } else {
                    RefitWindows (NULL, NULL);
                }
                return (TRUE);

           case IDCANCEL:

                EndDialog(hDlg, DIALOG_CANCEL );
                return (TRUE);
        }

    }
    return (FALSE);
}


VOID
RefitWindows (HWND hWnd, HDC CurhDC)
{
    PDISPLAY_ITEM   pPerf;
    BOOLEAN         fit;
    ULONG           Index;
    HDC             hDC;

    hWnd = WinperfInfo.hWndMain;

    hDC = CurhDC;
    if (!CurhDC) {
        hDC = GetDC(hWnd);
    }

    fit = FitPerfWindows(hWnd,hDC,PerfGraphList);
    if (!fit) {
        //DbgPrint("Fit Fails\n");
    }

    for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
        DeleteMemoryContext(pPerf);
        CalcDrawFrame(pPerf);

        if (!CreateMemoryContext(hDC,pPerf)) {
            MessageBox(hWnd,"Error Allocating Memory","Winperf",MB_OK);
            DestroyWindow(hWnd);
            break;
        }
    }
    InvalidateRect(hWnd,(LPRECT)NULL,TRUE);

    if (!CurhDC) {
        ReleaseDC(hWnd,hDC);
    }
}

VOID
InitComboBox (HWND hDlg, ULONG id, ULONG counter)
{
    HWND    ComboList;
    ULONG   i, nIndex;

    ComboList = GetDlgItem(hDlg, id);
    SendMessage(ComboList, CB_RESETCONTENT, 0, 0);
    SendMessage(ComboList, CB_SETITEMDATA, 0L, 0L);

    if (Counters) {
        for (i=0; Counters[i].PerfName; i++) {
            nIndex = SendMessage(
                            ComboList,
                            CB_ADDSTRING,
                            0,
                            (DWORD) Counters[i].PerfName
                            );

            SendMessage(
                ComboList,
                CB_SETITEMDATA,
                nIndex,
                (DWORD) i
                );
        }
    }

    SendMessage(ComboList, CB_SETCURSEL, ActiveCounters[counter].ComboBoxIndex, 0L);
}

VOID
SetP5Perf (HWND hDlg, ULONG IdCombo, ULONG counter)
{
    static  PUCHAR NameSuffix[] = { "", " (R0)", " (R3)", "" };
    HWND    ComboList;
    ULONG   nIndex, Mega, DU, BSEncoding, flag;
    PDISPLAY_ITEM   pPerf;
    PUCHAR  name;
    SETEVENT   Event;

    ComboList = GetDlgItem(hDlg, IdCombo);
    nIndex = (int)SendMessage(ComboList, CB_GETCURSEL, 0, 0);
    ActiveCounters[counter].ComboBoxIndex = nIndex;

    memset (&Event, 0, sizeof (Event));
    Event.Active = TRUE;
    Event.KernelMode = SendDlgItemMessage(hDlg,IdCombo+1,BM_GETCHECK,0,0) ? TRUE : FALSE;
    Event.UserMode = SendDlgItemMessage(hDlg,IdCombo+2,BM_GETCHECK,0,0) ? TRUE : FALSE;
    BSEncoding = (Event.UserMode << 1) | Event.KernelMode;

    Mega = SendDlgItemMessage(hDlg,IdCombo+3,BM_GETCHECK,0,0) ? 1 : 0;
    //DU = SendDlgItemMessage(hDlg,IdCombo+3,BM_GETCHECK,0,0) ? 1 : 0;
    DU = 0;

    // get encoding for counter
    if ((!Event.KernelMode && !Event.UserMode)  ||  nIndex == -1) {

        // no counter selected, done
        if (ActiveCounters[counter].pWhichGraph != NULL) {
            ClearGraph (ActiveCounters[counter].pWhichGraph);
        }
        return ;
    }

    // select counter
    nIndex = SendMessage(ComboList, CB_GETITEMDATA, nIndex, 0);
    Event.EventId = Counters[nIndex].EventId;

    ActiveCounters[counter].WhichCounter = nIndex;
    if (ActiveCounters[counter].pWhichGraph == NULL) {
        ActiveCounters[counter].pWhichGraph = AllocateDisplayItem();
    }

    pPerf = ActiveCounters[counter].pWhichGraph;    // which window
    _snprintf (pPerf->PerfName, 
               sizeof(pPerf->PerfName) - 1,
               "%s%s", Counters[nIndex].PerfName, NameSuffix[BSEncoding]);
    pPerf->PerfName[sizeof(pPerf->PerfName) - 1] = 0;

    flag = TRUE;
    if (Mega != pPerf->Mega || memcmp (&Event, CounterEvents+counter, sizeof (Event))) {

        flag = FALSE;
        CounterEvents[counter] = Event;
        SetCounterEvents (CounterEvents, sizeof CounterEvents);
    }

    pPerf->SnapData   = SnapPrivateInfo;                // generic snap
    pPerf->SnapParam1 = OFFSET(PSTATS, Counters[ counter ]);
    pPerf->Mega       = Mega;
    SetDisplayToTrue (pPerf, IdCombo);

    if (flag) {
        // didn't change types
        return ;
    }

    // clear graph
    flag = pPerf->CalcId;
    ClearGraph (pPerf);
    pPerf->Mega   = Mega;
    pPerf->CalcId = flag;
    SetDisplayToTrue (pPerf, IdCombo);

    UpdateInternalStats ();
    pPerf->SnapData (pPerf);

    UpdateInternalStats ();
    pPerf->SnapData (pPerf);
}

VOID
ClearGraph (
    PDISPLAY_ITEM   pPerf
)
{
    ULONG   i, j;
    PULONG  pDL;

    SetDisplayToFalse (pPerf);
    pPerf->Mega = FALSE;

    for (i=0 ; i < WinperfInfo.NumberOfProcessors+1; i++) {
        pDL = pPerf->DataList[i];

        for (j=0; j<DATA_LIST_LENGTH; j++) {
            *(pDL++) = 0;
        }
    }

    pPerf->Max = 1;
    pPerf->CurrentDrawingPos = 0;
    pPerf->ChangeScale = TRUE;
}

VOID
SetGenPerf (HWND hDlg, PGENCOUNTER GenCount)
{
    PDISPLAY_ITEM   pPerf;
    ULONG   ButtonState;

    GenCount->State = SendDlgItemMessage(hDlg,GenCount->IdSel,BM_GETCHECK,0,0);
    if (GenCount->Fnc == NULL) {
        return ;
    }

    if (GenCount->WhichGraph == NULL) {
        GenCount->WhichGraph = AllocateDisplayItem();
    }
    pPerf = GenCount->WhichGraph;

    if (!GenCount->State) {
        ClearGraph (pPerf);
        return ;
    }

    strncpy (pPerf->PerfName, GenCount->Name, sizeof(pPerf->PerfName) - 1);
    pPerf->PerfName[sizeof(pPerf->PerfName) - 1] = 0;

    pPerf->SnapData   = GenCount->Fnc;
    pPerf->SnapParam1 = GenCount->Param;
    pPerf->SnapData  (pPerf);
    SetDisplayToTrue (pPerf, GenCount->IdSel);
}

VOID
SetDisplayToTrue (
    PDISPLAY_ITEM   pPerf,
    ULONG           sort
)
{
    PDISPLAY_ITEM   p, *pp;

    Calc1 = NULL;
    if (pPerf->Display) {                           // already displayed
        return ;                                    // just return
    }

    pPerf->DispName[sizeof(pPerf->DispName) - 1] = 0;
    if (pPerf->CalcId) {
        _snprintf (pPerf->DispName, sizeof(pPerf->DispName) - 1,
                   "%d. %s", pPerf->CalcId, pPerf->PerfName);
    } else {
        strncpy (pPerf->DispName, pPerf->PerfName, sizeof(pPerf->DispName) - 1);
    }
    pPerf->DispNameLen = strlen (pPerf->DispName);

    pPerf->Display = TRUE;                          // set to display
    pPerf->sort = sort;

    // check to see if grap is already listed
    for (p = PerfGraphList; p; p = p->Next) {
        if (p == pPerf) {
            // already in the active list, ret
            return ;
        }
    }

    // put graph in perfered sorting order
    for (pp = &PerfGraphList; *pp; pp = &(*pp)->Next) {
        if ((*pp)->sort > sort) {
            break;
        }
    }

    pPerf->Next = *pp;
    *pp = pPerf;
}

PDISPLAY_ITEM
SetDisplayToFalse (
    PDISPLAY_ITEM   pPerf
)
{
    PDISPLAY_ITEM   *p, p1;

    for (p = &PerfGraphList; *p; p = &(*p)->Next) {     // remove graph from
        if (*p == pPerf) {                              // active list
            *p = pPerf->Next;
            break;
        }
    }

    if (pPerf->CalcId) {
        Calc1 = Calc2 = NULL;
        for (p1 = PerfGraphList; p1; p1 = p1->Next) {
            p1->CalcPercent[0] = NULL;
            p1->CalcPercent[1] = NULL;
        }
    }

    pPerf->CalcId  = 0;
    pPerf->Display = FALSE;                             // clear flag
    return *p;
}

VOID
SetDefaultDisplayMode (HWND hWnd, ULONG mode)
{
    HDC hDC;
    PDISPLAY_ITEM pPerf;
    PAINTSTRUCT     ps;

    hDC = BeginPaint(hWnd,&ps);
    DefaultDisplayMode = mode;
    for (pPerf=PerfGraphList; pPerf; pPerf=pPerf->Next) {
        if (pPerf->IsPercent) {
            continue;
        }

        pPerf->DisplayMode = DefaultDisplayMode;
        DrawPerfGraph(hDC,pPerf);       // redraw graph in new mode
    }

    EndPaint(hWnd,&ps);
}


PDISPLAY_ITEM
AllocateDisplayItem()
{
    PDISPLAY_ITEM   pPerf;
    UINT    Index1, Index2;
    PULONG  pDL;

    pPerf = malloc(sizeof (DISPLAY_ITEM));
    if (pPerf == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    RtlZeroMemory (pPerf, sizeof (DISPLAY_ITEM));

    pPerf->Display      = FALSE;
    pPerf->Max          = 1;
    pPerf->SnapData     = SnapNull;
    pPerf->DisplayMode  = DefaultDisplayMode;
    pPerf->AutoTotal    = TRUE;
    pPerf->MaxToUse     = &pPerf->Max;
    //
    // I will not fix these as PerfName is not likely to be 1...
    //
    strcpy (pPerf->PerfName, "?");
    strcpy (pPerf->DispName, "?");
    pPerf->DispNameLen = 1;

    for (Index1=0 ; Index1 < WinperfInfo.NumberOfProcessors+1; Index1++) {
        pDL = malloc (DATA_LIST_LENGTH * sizeof (ULONG));
        if (pDL == NULL) {
            printf("Memory allocation failed.\n");
            exit(1);
        }

        pPerf->DataList[Index1] = pDL;

        RtlZeroMemory (pDL, sizeof(ULONG) * DATA_LIST_LENGTH);
    }

    return pPerf;
}

VOID
FreeDisplayItem(PDISPLAY_ITEM pPerf)
{
    ULONG   i;

    for (i=0 ; i < WinperfInfo.NumberOfProcessors+1; i++) {
        free (pPerf->DataList[i]);
    }

    free (pPerf);
}


//
// ************** HACKTEST
//

ULONG CsCount[32*32];

struct s_ThreadInfo {
    PULONG  Counter;
    HDC     MemoryDC;
    HWND    hWnd;
} ThreadInfo[32];

DWORD
WorkerCsTestThread (
    struct s_ThreadInfo *TInfo
)
{
    HDC     hDC;
    HDC     hDCmem;
    HBITMAP hbm;
    ULONG   i;

    hDC = GetDC(TInfo->hWnd);
    hDCmem= CreateCompatibleDC(hDC);
    hbm = CreateCompatibleBitmap(hDC,100,100);
    SelectObject(hDCmem,hbm);

    for (i = 0; i < (ULONG)-1 ; i++) {
        (*TInfo->Counter)++;

        //GetPixel(hDC, 9999, 9999);
        //BitBlt(hDC, 1, 1, 20, 20, TInfo->MemoryDC, 0, 0, SRCCOPY);
         PatBlt(hDCmem,0,0,20,20,PATCOPY);
    }

    ReleaseDC(TInfo->hWnd,hDC);

    return 0;
}


VOID
DoCSTest(HWND hWnd)
{
    static  ULONG   ThreadCount = 0;
    PDISPLAY_ITEM   pPerf;
    DWORD           junk;

    if (ThreadCount >= 32) {
        return ;
    }

    pPerf = AllocateDisplayItem();

    ThreadInfo[ThreadCount].Counter = &CsCount[ThreadCount];
    ThreadInfo[ThreadCount].MemoryDC = pPerf->MemoryDC;
    ThreadInfo[ThreadCount].hWnd = hWnd;

    CreateThread (NULL, 0,
        (LPTHREAD_START_ROUTINE) WorkerCsTestThread,
        (LPVOID) &ThreadInfo[ThreadCount],
        0,
        &junk);

    pPerf->SnapData = SnapCsTest;
    pPerf->SnapParam1 = ThreadCount;
    ThreadCount++;

    _snprintf (pPerf->PerfName, 
               sizeof(pPerf->PerfName) - 1,
               "CS trans %ld", ThreadCount);
    pPerf->PerfName[sizeof(pPerf->PerfName) - 1] = 0;

    SetDisplayToTrue (pPerf, 1);
}


VOID
SnapCsTest (
    IN OUT PDISPLAY_ITEM pPerf
    )
{
    ULONG   i;

    pPerf->CurrentDataPoint[1] = CsCount[pPerf->SnapParam1];
    CsCount[pPerf->SnapParam1] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\app\draw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Draw.c

Abstract:

   Win32 application to display performance statictics. This routine implements
   graphics output for display windows.

Author:

   Mark Enstrom  (marke)

Environment:

   Win32

Revision History:

   10-07-92     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <math.h>
#include <errno.h>
#include "pperf.h"

extern WINPERF_INFO    WinperfInfo;
extern ULONG           NumberOfProcessors, LogIt;



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems
    )

/*++

Routine Description:

    Calculate all parameters to fit the given number of
    windows into the app window. Fill out the data structure
    for each sub-window

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/

{
    RECT    ClientRect;
    int     cx,cy;
    UINT    Index;
    int     ActiveWindows,IndexX,IndexY;
    int     WindowsX,WindowsY,WindowWidth,WindowHeight;
    int     LastRowWidth,LoopWidth;
    double  fWindowsX,fActiveWindows,fcx,fcy;
    PDISPLAY_ITEM   pPerf;

    //
    //  Find out the client area bounds
    //

    GetClientRect(hWnd,&ClientRect);

    cx = ClientRect.right;
    cy = ClientRect.bottom - 2;   // subtract 2 to give a little more border

    //
    //  Find out how many perf windows are active
    //

    ActiveWindows = 0;

    for (pPerf=DisplayItems; pPerf; pPerf = pPerf->Next) {
        if (pPerf->Display == TRUE) {
            ActiveWindows++;
        }
    }

    //
    // Return if there are no active windows to display
    //

    if (ActiveWindows == 0) {
        return(TRUE);
    }


    //
    //  Now convert the window dimensions to floating point and
    //  then take the square root of the window dimension to find
    //  out the number of windows in the x direction
    //

    fActiveWindows = 1.0 * ActiveWindows;

    fcx = 1.0 * cx;
    fcy = 1.0 * cy;

    if (fcy != 0.0) {
        fWindowsX = sqrt((fcx * fActiveWindows) / fcy);
    }   else {

        //
        // If fcy = 0 then return since this is an error condition that
        // would cause a divide by zero.
        //

        return(FALSE);
    }

    //
    // convert back to integer
    //

    WindowsX = (int)fWindowsX;

    if (WindowsX == 0) {
        WindowsX = 1;
    } else if (WindowsX > ActiveWindows) {
        WindowsX = ActiveWindows;
    }

    WindowsY = ActiveWindows / WindowsX;

    //
    //  Add on extra line to Y to take care of the left over windows ie:
    //  if there are 15 active windows and the x number = 7 then y = 2 with 1
    //  left over.
    //

    Index = ActiveWindows - (WindowsX * WindowsY);

    if (Index > 0) {
        WindowsY++;
        LastRowWidth = cx / Index;
    } else {
        LastRowWidth = cx / WindowsX;
    }

    WindowWidth  = cx / WindowsX;
    WindowHeight = cy / WindowsY;

    //
    // Assign positions for each active window
    //

    pPerf = DisplayItems;
    for (IndexY=0;IndexY<WindowsY;IndexY++) {
        for (IndexX=0;IndexX<WindowsX;IndexX++) {

            //
            // Find the next active display item
            //

            while (pPerf->Display != TRUE  &&  pPerf) {
                pPerf = pPerf->Next;
            }
            if (!pPerf) {
                break;
            }

            //
            //  Add y fixup for last row
            //

            if (IndexY == WindowsY - 1) {
                LoopWidth = LastRowWidth;
            } else {
                LoopWidth = WindowWidth;
            }


            pPerf->PositionX = LoopWidth  * IndexX;
            pPerf->PositionY = WindowHeight * IndexY + 1;  // +1 for more top border
            pPerf->Width     = LoopWidth - 1;
            pPerf->Height    = WindowHeight - 1;

            //
            // Last Column fix-up to use all of window.
            //

            if (IndexX == WindowsX - 1) {
                pPerf->Width = cx - pPerf->PositionX - 1;
            }

            pPerf = pPerf->Next;
            if (!pPerf) {
                break;
            }

        }

        if (!pPerf) {
            break;
        }
    }

    return(TRUE);
}



VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Calculate all borders for graphics windows

Arguments:

    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;
    LONG    GraphHeight,TextHeight;
    BOOLEAN TextWindow;

    double  fx1,fx2,fy1;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->PositionX + 2;
    x2 = DisplayItem->PositionX + DisplayItem->Width - 2;
    y1 = DisplayItem->PositionY + 2;
    y2 = DisplayItem->PositionY + DisplayItem->Height - 2;

    //
    // find out in there is enough space for a text window
    //

    if ((y2 - y1 - 12) > 30) {

        TextWindow = TRUE;

        //
        // Calculate dimensions for a text window and a graphics window
        //
        // fx1 = portion of the window - bordres and free space
        //
        // fx2 = fraction of window used for graphics
        //
        // fy1 = fraction of winddow used for text
        //

        fx1 = (y2 - y1 - 10);

        fx2 = fx1 * 0.6666;
        fy1 = fx1 * 0.3333;

        GraphHeight = (LONG)fx2;
        TextHeight  = (LONG)fy1;

        if (TextHeight > 20) {
            GraphHeight += TextHeight-20;
            TextHeight = 20;
        }

        //
        // Calculate window boundaries
        //

        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y1 + 4 + GraphHeight + 1;

        tx1 = x1 + 4;
        tx2 = x2 - 4;
        ty1 = gy2 + 1 + 2 + 1;  // border,free space,border
        ty2 = gy2 + TextHeight + 1;

    }   else {

        TextWindow = FALSE;
        GraphHeight = y2 - y1 - 10;
        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y2 - 4;
        tx1 = tx2 = ty1 = ty2 = 0;

    }

    //
    // Fill in structures for drawing text and graphics
    //

    DisplayItem->Border.left        = x1;
    DisplayItem->Border.right       = x2;
    DisplayItem->Border.top         = y1;
    DisplayItem->Border.bottom      = y2;

    DisplayItem->GraphBorder.left   = gx1;
    DisplayItem->GraphBorder.right  = gx2;
    DisplayItem->GraphBorder.top    = gy1;
    DisplayItem->GraphBorder.bottom = gy2;

    DisplayItem->TextBorder.left    = tx1;
    DisplayItem->TextBorder.right   = tx2;
    DisplayItem->TextBorder.top     = ty1;
    DisplayItem->TextBorder.bottom  = ty2;
}




VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw the window frame for a performance window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    DrawRect;
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->Border.left;
    x2 = DisplayItem->Border.right;
    y1 = DisplayItem->Border.top;
    y2 = DisplayItem->Border.bottom;

    gx1 = DisplayItem->GraphBorder.left;
    gx2 = DisplayItem->GraphBorder.right;
    gy1 = DisplayItem->GraphBorder.top;
    gy2 = DisplayItem->GraphBorder.bottom;

    tx1 = DisplayItem->TextBorder.left;
    tx2 = DisplayItem->TextBorder.right;
    ty1 = DisplayItem->TextBorder.top;
    ty2 = DisplayItem->TextBorder.bottom;

    //
    // Draw top border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y1 + 2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // Draw Left border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x1 + 2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // Draw right border in dark shade
    //


    DrawRect.left   = x2 - 2;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // draw bottom in dark shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y2-2;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw graphics area single border
    //

    //
    // Draw top border in dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy1+1;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw Left border in Dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx1 + 1;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw right border in Light shade
    //


    DrawRect.left   = gx2 - 1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // draw bottom in Light shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy2-1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    if (tx2 > 0) {

        //
        // Draw top border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty1 + 1;

        FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

        //
        // Draw Left border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx1 + 1;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

        //
        // Draw right border in Light shade
        //


        DrawRect.left   = tx2 - 1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

        //
        // draw bottom in Light shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty2-1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    }
}




VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw text into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    TextRect;
    UCHAR   TextStr[50];
    ULONG   j;
    UINT    FontSize;

    //
    // Check that text display is enabled
    //

    if (DisplayItem->TextBorder.right == 0) {
        return;
    }

    TextRect.left = DisplayItem->TextBorder.left +1;
    TextRect.right = DisplayItem->TextBorder.right -1;
    TextRect.top = DisplayItem->TextBorder.top +1;
    TextRect.bottom = DisplayItem->TextBorder.bottom -1;

    FillRect(hDC,&TextRect,WinperfInfo.hBackground);

    SetBkColor(hDC,RGB(192,192,192));

    //
    //  Decide which font to draw with
    //

    FontSize =  TextRect.bottom - TextRect.top;

    if (FontSize >= 15) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.LargeFont);
    } else if (FontSize > 10) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.MediumFont);
    } else {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.SmallFont);
    }

    DrawText(
                hDC,
                DisplayItem->DispName,
                DisplayItem->DispNameLen,
                &TextRect,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE
             );


    //
    // Build the numeric value
    //

    if (DisplayItem->Mega) {
        wsprintf(TextStr,"   %liK",DisplayItem->DataList[0][0]);
    } else {
        if (DisplayItem->IsPercent) {
            j = wsprintf(TextStr,"   %03li", DisplayItem->DataList[0][0]);
            TextStr[j+1] = 0;
            TextStr[j-0] = TextStr[j-1];
            TextStr[j-1] = TextStr[j-2];
            TextStr[j-2] = '.';
        } else {
            wsprintf(TextStr,"   %li",DisplayItem->DataList[0][0]);
        }
    }

    DrawText(
                hDC,
                TextStr,
                strlen(TextStr),
                &TextRect,
                DT_RIGHT | DT_VCENTER | DT_SINGLELINE
             );


    SelectObject(hDC,WinperfInfo.hOldFont);

}





VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw graphics into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect;
    ULONG   Scale,i,j,GraphWidth,GraphHeight,Max;
    PULONG  pDL;
    HPEN    pen;

    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth +1;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&MemGraphRect,WinperfInfo.hBackground);

    MemGraphRect.right  = GraphWidth;
    MemGraphRect.bottom = GraphHeight;

    Max = *DisplayItem->MaxToUse;
    if (Max == 0) {
        Max = 1;
    }

    //
    // calculate scale from data to perf window
    //

    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }

    if (DisplayItem->DisplayMode == DISPLAY_MODE_BREAKDOWN  ||
        DisplayItem->DisplayMode == DISPLAY_MODE_PER_PROCESSOR) {

        for (j=0; j < NumberOfProcessors; j++) {
            pen = WinperfInfo.hPPen[j];
            SelectObject(DisplayItem->MemoryDC,pen);

            pDL = DisplayItem->DataList[j+1];
            MoveToEx(DisplayItem->MemoryDC,
                     MemGraphRect.right,
                     MemGraphRect.bottom - (pDL[0] * GraphHeight) / Max,
                     (LPPOINT)NULL);

            for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
                LineTo(DisplayItem->MemoryDC,
                       MemGraphRect.right - Scale * i,
                       MemGraphRect.bottom - (pDL[i] * GraphHeight)/Max);
            }
        }
    }


    if (DisplayItem->DisplayMode == DISPLAY_MODE_TOTAL  ||
        DisplayItem->DisplayMode == DISPLAY_MODE_BREAKDOWN) {

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBluePen);
        pDL = DisplayItem->DataList[0];

        MoveToEx(DisplayItem->MemoryDC,
                 MemGraphRect.right,
                 MemGraphRect.bottom - (pDL[0] * GraphHeight)/Max,
                 (LPPOINT)NULL);



        for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
                   MemGraphRect.right - Scale * i,
                   MemGraphRect.bottom - (pDL[i] * GraphHeight)/Max);
        }
    }

    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);
}

VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Shift memory bitmap 1 location left then draw the 1 new data point.
    BitBlt this to the screen.


Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect,FillArea;
    ULONG   Scale,j,GraphWidth,GraphHeight,Max;
    PULONG  pDL;
    HPEN    pen;


    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight;

    Max = *DisplayItem->MaxToUse;
    if (Max == 0) {
        Max = 1;
    }

    //
    // calculate scale from data to perf window
    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }

    //
    // Shift memory image left by scale
    //


    BitBlt( DisplayItem->MemoryDC,
            0,
            0,
            GraphWidth+1 - Scale,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            Scale,
            0,
            SRCCOPY);


    //
    // Fill The new area on the right of the screen
    //

    FillArea.left   = GraphWidth +1 - Scale;
    FillArea.right  = GraphWidth +1;
    FillArea.top    = 0;
    FillArea.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&FillArea,WinperfInfo.hBackground);



    if (DisplayItem->DisplayMode == DISPLAY_MODE_BREAKDOWN ||
        DisplayItem->DisplayMode == DISPLAY_MODE_PER_PROCESSOR) {

        for (j=0; j < NumberOfProcessors; j++) {
            pen = WinperfInfo.hPPen[j];
            SelectObject(DisplayItem->MemoryDC,pen);

            pDL = DisplayItem->DataList[j+1];
            MoveToEx(DisplayItem->MemoryDC,
                     MemGraphRect.right,
                     MemGraphRect.bottom - (pDL[0] * GraphHeight)/ Max,
                     (LPPOINT)NULL);

            LineTo(DisplayItem->MemoryDC,
                    MemGraphRect.right - Scale,
                    MemGraphRect.bottom - (pDL[1] * GraphHeight)/ Max);
        }
    }

    if (DisplayItem->DisplayMode == DISPLAY_MODE_TOTAL  ||
        DisplayItem->DisplayMode == DISPLAY_MODE_BREAKDOWN) {

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBluePen);

        pDL = DisplayItem->DataList[0];
        MoveToEx(DisplayItem->MemoryDC,
                 MemGraphRect.right,
                 MemGraphRect.bottom - (pDL[0] * GraphHeight)/Max,
                 (LPPOINT)NULL);

        LineTo(DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (pDL[1] * GraphHeight)/Max);
    }

    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);

}



BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Create a memory context and a memory bitmap for each perf window



Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    int     Width;
    int     Height;

    if (DisplayItem->Display == TRUE) {

        //
        //  Calculate width of memory bitmap needed
        //

        Width  = DisplayItem->GraphBorder.right - DisplayItem->GraphBorder.left;
        Height = DisplayItem->GraphBorder.bottom - DisplayItem->GraphBorder.top;

        if ((Width<=0) || (Height <= 0)) {

            //
            // Disable this window that is to small to be seen
            //

            //DisplayItem->Display = FALSE;

            //return(TRUE);

            //
            // make a fake width and height
            //

            Width  = 1;
            Height = 1;
        }

        //
        //  Create DC and Bitmap
        //

        DisplayItem->MemoryDC     = CreateCompatibleDC(hDC);

        if (DisplayItem->MemoryDC == NULL) {
            return(FALSE);
        }


        DisplayItem->MemoryBitmap = CreateCompatibleBitmap(hDC,Width,Height);

        if (DisplayItem->MemoryBitmap == 0) {
            return(FALSE);
        }

        SelectObject(DisplayItem->MemoryDC,DisplayItem->MemoryBitmap);

    }

    return(TRUE);
}



VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Delete memory bitmap and context

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    if (DisplayItem->MemoryDC != NULL) {
        DeleteDC(DisplayItem->MemoryDC);
    }

    if (DisplayItem->MemoryBitmap != NULL) {
        DeleteObject(DisplayItem->MemoryBitmap);
    }

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\makefile.inc ===
DoAlways :
    binplace   p5ctrnam.h
    binplace   p5ctrs.ini
    binplace   p5perf.txt
    binplace   ..\p5perf.reg

.\msg00001.bin : DoAlways p5ctrmsg.mc
    erase .\p5ctrmsg.h
    erase .\msg00001.bin
    erase .\p5ctrmsg.rc
    mc -v -s p5ctrmsg.mc

.\p5ctrmsg.rc : p5ctrmsg.mc 
    erase .\p5ctrmsg.h
    erase .\msg00001.bin
    erase .\p5ctrmsg.rc
    mc -v -s p5ctrmsg.mc

.\p5ctrmsg.h: p5ctrmsg.mc
    erase .\p5ctrmsg.h
    erase .\msg00001.bin
    erase .\p5ctrmsg.rc
    mc -v -s p5ctrmsg.mc

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\app\pperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    winperf.h

Abstract:

   This module contains the definit

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#ifndef _WINPERFH_INCLUDED_
#define _WINPERFH_INCLUDED_

#define DIALOG_SUCCESS  100
#define DIALOG_CANCEL   0

#define IDM_EXIT        1100
#define IDM_SELECT      1101
#define IDM_THUNK       1102
#define IDM_ALL         1103
#define IDM_HACK        1104
#define TIMER_ID        1001
#define IDM_SEL_DLG     1004
#define IDM_THUNK_DLG   1005
#define IDM_CALC_DLG    1006

#define IDM_DISPLAY_TOTAL           1106
#define IDM_DISPLAY_BREAKDOWN       1107
#define IDM_DISPLAY_PER_PROCESSOR   1108
#define IDM_TOPMOST                 1109

#define IDM_ACCEPT                  1200

#define IDM_P5_GEN1                 1206
#define IDM_P5_R0_0                 1207
#define IDM_P5_R3_0                 1208
#define IDM_P5_K_0                  1209

#define IDM_P5_GEN2                 1210
#define IDM_P5_R0_1                 1211
#define IDM_P5_R3_1                 1212
#define IDM_P5_K_1                  1213

#define IDM_PERCENT                 1214

#define IDM_SPIN_ACQUIRE            1250
#define IDM_SPIN_COLL               1251
#define IDM_SPIN_SPIN               1252
#define IDM_IRQL                    1253
#define IDM_INT                     1254

#define IDM_LOGIT                   1260
#define IDM_SCALE                   1261

#define IDM_THUNK_LIST              1301
#define IDM_THUNK_SOURCE            1302
#define IDM_THUNK_IMPORT            1303
#define IDM_THUNK_FUNCTION          1304
#define IDM_THUNK_ADD               1305
#define IDM_THUNK_REMOVE            1306
#define IDM_THUNK_CLEAR_ALL         1307

#define IDM_CALC_TEXTA              1350
#define IDM_CALC_TEXTB              1351
#define IDM_CALC_FORM1              1352
#define IDM_CALC_FORM2              1353
#define IDM_CALC_FORM3              1354
#define IDM_CALC_FORM4              1355


#define WINPERF_ICON 1011
#define CPUTHERM_ICON 1012
#define BALL_BITMAP 1011


#include "calcperf.h"




typedef struct _WINPERF_INFO
{
    DWORD   WindowPositionX;
    DWORD   WindowPositionY;
    DWORD   WindowSizeX;
    DWORD   WindowSizeY;
    DWORD   DisplayMode;
    HPEN    hBluePen;               // total pen
    HPEN    hPPen[MAX_PROCESSORS];
    HPEN    hDotPen;
    HBRUSH  hBackground;
    HBRUSH  hRedBrush;
    HBRUSH  hGreenBrush;
    HBRUSH  hBlueBrush;
    HBRUSH  hLightBrush;
    HBRUSH  hDarkBrush;
    HFONT   LargeFont;
    HFONT   MediumFont;
    HFONT   SmallFont;
    HFONT   hOldFont;
    HMENU   hMenu;
    HWND    hWndMain;
    UINT    TimerId;
    UINT    NumberOfProcessors;
    BOOL    DisplayMenu;
} WINPERF_INFO,*PWINPERF_INFO;






BOOL
InitApplication(
   HANDLE hInstance,
   HBRUSH hBackground
   );


BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    );



INT_PTR
CALLBACK
MainWndProc(
   HWND   hWnd,
   UINT   message,
   WPARAM DWORD,
   LPARAM lParam
   );



LONG APIENTRY
CpuWndProc(
   HWND  hWnd,
   UINT  message,
   DWORD DWORD,
   LONG  lParam
   );


INT_PTR
CALLBACK
About(
   HWND    hDlg,
   UINT    message,
   WPARAM  DWORD,
   LPARAM  lParam
   );


BOOL    APIENTRY MGetWindowExt(HDC hdc, INT * pcx, INT * pcy);
BOOL    APIENTRY MGetCurrentPosition(HDC hdc, INT * px, INT * py);
HANDLE  APIENTRY MGetInstHandle(VOID);

LPSTR   MGetCmdLine(VOID);


VOID
UpdateCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient
   );

VOID
DrawCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient,
   IN   ULONG DisplayItem
   );

VOID
ReScalePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

BOOL
CalcCpuTime(
   PDISPLAY_ITEM    PerfListItem
   );

ULONG
InitPerfInfo(VOID);


VOID
InitProfileData(PWINPERF_INFO pWinperfInfo);







VOID
DrawPerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );


VOID
UpdatePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

//
//  change style constants
//

#define STYLE_ENABLE_MENU  WS_OVERLAPPEDWINDOW
#define STYLE_DISABLE_MENU (WS_THICKFRAME+WS_BORDER)


LONG APIENTRY
DbgWndProc(
   HWND   hWnd,
   UINT   message,
   DWORD  wParam,
   LONG   lParam
   );

INT_PTR
CALLBACK ThunkDlgProc(
   HWND         hDlg,
   unsigned int message,
   WPARAM       wParam,
   LPARAM       lParam
   );

INT_PTR
CALLBACK CalcDlgProc(
   HWND         hDlg,
   unsigned int message,
   WPARAM       wParam,
   LPARAM       lParam
   );


BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems
    );

VOID
RefitWindows (
    IN  HWND hWnd,
    IN  HDC CurhDC
);

BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );



INT_PTR
CALLBACK SelectDlgProc(
   HWND         hDlg,
   unsigned int message,
   WPARAM       wParam,
   LPARAM       lParam
   );

VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

BOOL
CalcPerf(
   PDISPLAY_ITEM    pPerf1
   );

VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   Displ