S_SERVER, &CacheResponse->Tickets[Index].ServerName);

	 	sPrintTime(endTime, CacheResponse->Tickets[Index].EndTime);
 		sPrintTime(renewTime, CacheResponse->Tickets[Index].RenewTime);
	 	AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_ReallyVerbose, 0, IDS_KERBEROS_ENDTIME, endTime);
 		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_ReallyVerbose, 0, IDS_KERBEROS_RENEWTIME, renewTime);

		//
		// Complain if required tickets were not found.
		//
	}

	if ( !KrbtgtTicketFound ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOTICKET, KrbtgtTicketName);
		RetVal = FALSE;
	}

	if ( !OurMachineTicketFound ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOTICKET, OurMachineTicketName);
		RetVal = FALSE;
	}

	//
	// Let subsequent tests know that kerberos is working.
	//
	if ( RetVal ) 
	{	
		pResults->Global.fKerberosIsWorking = TRUE;
	}


L_ERR:

    if (LogonHandle != NULL) 
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (CacheResponse != NULL) 
    {
        LsaFreeReturnBuffer(CacheResponse);
    }

    if (!RetVal && hr == S_OK)
	{
		pResults->Kerberos.hr = hr = E_FAIL;
		PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
	}
	else
	{
		PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
	}
    
	return S_OK;
} 

void KerberosGlobalPrint(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
	if (pParams->fVerbose || !FHrOK(pResults->Kerberos.hr))
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams, IDS_KERBEROS_LONG, IDS_KERBEROS_SHORT, pResults->Kerberos.fPerformed,
							pResults->Kerberos.hr, 0);

		if (pParams->fReallyVerbose || !FHrOK(pResults->Kerberos.hr))
			PrintMessageList(pParams, &pResults->Kerberos.lmsgOutput);

		if (!FHrOK(pResults->Kerberos.hr))
		{
			if(pResults->Kerberos.idsContext)
				PrintError(pParams, pResults->Kerberos.idsContext, pResults->Kerberos.hr);
		}
	}

}

void KerberosPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
							 IN OUT NETDIAG_RESULT *pResults,
							 IN INTERFACE_RESULT *pIfResult)
{
	// no perinterface information
}

void KerberosCleanup(IN NETDIAG_PARAMS *pParams,
						 IN OUT NETDIAG_RESULT *pResults)
{
	MessageListCleanUp(&pResults->Kerberos.lmsgOutput);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\machine.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      machine.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

//
// Common include files.
//
#include "precomp.h"
#include "strings.h"

HRESULT GetHotfixInfo(NETDIAG_RESULT *pResults, HKEY hkeyLocalMachine);


/*!--------------------------------------------------------------------------
    GetMachineSpecificInfo
        Get the OS info for the specified machine.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetMachineSpecificInfo(IN NETDIAG_PARAMS *pParams,
                               IN OUT NETDIAG_RESULT *pResults)
{
    HKEY    hkey = HKEY_LOCAL_MACHINE;
    HKEY    hkeyBuildNumber = NULL;
    HKEY    hkeyNTType;
    DWORD   dwErr;
    DWORD   dwType, dwLen;
    DWORD   dwMaxLen = 0;
    HRESULT hr = hrOK;
    TCHAR   szBuffer[256];

    CheckErr( RegOpenKeyEx( hkey,
                            c_szRegKeyWindowsNTCurrentVersion,
                            0,
                            KEY_READ,
                            &hkeyBuildNumber) );

    RegQueryInfoKey(hkeyBuildNumber,
                    NULL,           // lpclass
                    NULL,           // lpcbClass
                    NULL,           // lpReserved
                    NULL,           // lpcSubkeys
                    NULL,           // lpcbMaxSubkeyLen
                    NULL,           // lpcbMaxClassLen
                    NULL,           // lpcValues
                    NULL,           // lpcbMaxValueNameLen
                    &dwMaxLen,      // lpcbMaxValueLen
                    NULL,           // lpSecurity
                    NULL);          // last write time

    pResults->Global.pszCurrentVersion = Malloc((dwMaxLen+1) * sizeof(TCHAR));
    if (pResults->Global.pszCurrentVersion == NULL)
        CheckHr( E_OUTOFMEMORY );

    pResults->Global.pszCurrentBuildNumber = Malloc((dwMaxLen+1) * sizeof(TCHAR));
    if (pResults->Global.pszCurrentBuildNumber == NULL)
        CheckHr( E_OUTOFMEMORY );

    pResults->Global.pszCurrentType = Malloc((dwMaxLen+1) * sizeof(TCHAR));
    if (pResults->Global.pszCurrentType == NULL)
        CheckHr( E_OUTOFMEMORY );

    dwLen = dwMaxLen;
    CheckErr( RegQueryValueEx(hkeyBuildNumber,
                              c_szRegCurrentType,
                              (LPDWORD) NULL,
                              &dwType,
                              (LPBYTE) pResults->Global.pszCurrentType,
                              &dwLen) );

    dwLen = dwMaxLen;
    CheckErr( RegQueryValueEx(hkeyBuildNumber,
                              c_szRegCurrentVersion,
                              (LPDWORD) NULL,
                              &dwType,
                              (LPBYTE) pResults->Global.pszCurrentVersion,
                              &dwLen) );

    dwLen = dwMaxLen;
    dwErr = RegQueryValueEx( hkeyBuildNumber,
                             c_szRegCurrentBuildNumber,
                             (LPDWORD) NULL,
                             &dwType,
                             (LPBYTE) pResults->Global.pszCurrentBuildNumber,
                             &dwLen);

    if (dwErr != ERROR_SUCCESS) {

        dwLen = dwMaxLen;
        dwErr = RegQueryValueEx( hkeyBuildNumber,
                                 c_szRegCurrentBuild,
                                 (LPDWORD) NULL,
                                 &dwType,
                                 (LPBYTE) pResults->Global.pszCurrentBuildNumber,
                                 & dwLen);

    }

    GetEnvironmentVariable(_T("PROCESSOR_IDENTIFIER"),
                           szBuffer,
                           DimensionOf(szBuffer));
    pResults->Global.pszProcessorInfo = StrDup(szBuffer);

    
    CheckErr( RegOpenKeyEx( hkey,
                            c_szRegKeyControlProductOptions,
                            0,
                            KEY_READ,
                            &hkeyNTType) );
    dwLen = DimensionOf(szBuffer);
    dwErr = RegQueryValueEx( hkeyNTType,
                             _T("ProductType"),
                             (LPDWORD) NULL,
                             &dwType,
                             (LPBYTE) szBuffer,
                             & dwLen);
    if (dwErr == ERROR_SUCCESS)
    {
        if (StriCmp(szBuffer, _T("WinNT")) == 0)
        {
            pResults->Global.pszServerType = LoadAndAllocString(IDS_GLOBAL_PROFESSIONAL); 
        }
        else
        {
            pResults->Global.pszServerType = LoadAndAllocString(IDS_GLOBAL_SERVER); 
        }
    }

    // get the hotfix information
    GetHotfixInfo(pResults, hkey);


    
    hr = HResultFromWin32(dwErr);

Error:
    if ( hkeyNTType != NULL )
        (VOID) RegCloseKey(hkeyNTType);
    
    if ( hkeyBuildNumber != NULL )
        (VOID) RegCloseKey(hkeyBuildNumber);
    
    if (FAILED(hr))
    {
        //IDS_GLOBAL_NO_MACHINE_INFO    "[FATAL] Failed to get system information of this machine.\n"
        PrintMessage(pParams, IDS_GLOBAL_NO_MACHINE_INFO);
    }

    return hr;
}


/*!--------------------------------------------------------------------------
    GetHotfixInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetHotfixInfo(NETDIAG_RESULT *pResults, HKEY hkeyLocalMachine)
{
    HRESULT hr = hrOK;
    HKEY    hkeyHotFix = NULL;
    HKEY    hkeyMainHotFix = NULL;
    TCHAR   szBuffer[MAX_PATH];
    DWORD   cchBuffer = MAX_PATH;
    DWORD   i = 0;
    DWORD   cSubKeys = 0;
    DWORD   dwType, dwLen, dwInstalled;
    
    // Open the hotfix registry key
    CheckErr( RegOpenKeyEx( hkeyLocalMachine,
                            c_szRegKeyHotFix,
                            0,
                            KEY_READ,
                            &hkeyMainHotFix) );

    // Get the list of summary information
    RegQueryInfoKey(hkeyMainHotFix,
                    NULL,           // lpclass
                    NULL,           // lpcbClass
                    NULL,           // lpReserved
                    &cSubKeys,      // lpcSubkeys
                    NULL,           // lpcbMaxSubkeyLen
                    NULL,           // lpcbMaxClassLen
                    NULL,           // lpcValues
                    NULL,           // lpcbMaxValueNameLen
                    NULL,           // lpcbMaxValueLen
                    NULL,           // lpSecurity
                    NULL);          // last write time


    assert(pResults->Global.pHotFixes == NULL);
    pResults->Global.pHotFixes = Malloc(sizeof(HotFixInfo)*cSubKeys);
    if (pResults->Global.pHotFixes == NULL)
        CheckHr(E_OUTOFMEMORY);
    ZeroMemory(pResults->Global.pHotFixes, sizeof(HotFixInfo)*cSubKeys);
    
    // Enumerate the keys under this to get the list of hotfixes
    while ( RegEnumKeyEx( hkeyMainHotFix,
                          i,
                          szBuffer,                 
                          &cchBuffer,
                          NULL,
                          NULL,
                          NULL,
                          NULL) == ERROR_SUCCESS)
    {

        // Now add an entry for each key
        pResults->Global.pHotFixes[i].fInstalled = FALSE;
        pResults->Global.pHotFixes[i].pszName = StrDup(szBuffer);

        // Open up the key and get the installed value
        assert(hkeyHotFix == NULL);
        CheckErr( RegOpenKeyEx( hkeyMainHotFix,
                                szBuffer,
                                0,
                                KEY_READ,
                                &hkeyHotFix) );

        // Now get the value
        dwType = REG_DWORD;
        dwInstalled = FALSE;
        dwLen = sizeof(DWORD);
        if (RegQueryValueEx(hkeyHotFix,
                            c_szRegInstalled,
                            (LPDWORD) NULL,
                            &dwType,
                            (LPBYTE) &dwInstalled,
                            &dwLen) == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
                pResults->Global.pHotFixes[i].fInstalled = dwInstalled;
        }


        if (hkeyHotFix)
            RegCloseKey(hkeyHotFix);
        hkeyHotFix = NULL;
        i ++;
        pResults->Global.cHotFixes++;
        cchBuffer = MAX_PATH;
    }

Error:
    if (hkeyHotFix)
        RegCloseKey(hkeyHotFix);
    
    if (hkeyMainHotFix)
        RegCloseKey(hkeyMainHotFix);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\member.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      member.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--


#include "precomp.h"
#undef IsEqualGUID
#include "objbase.h"
#include "regutil.h"
#include "strings.h"

const WCHAR c_wszUserDnsDomain[] = L"USERDNSDOMAIN";

BOOL IsSysVolReady(NETDIAG_PARAMS* pParams);

/*!--------------------------------------------------------------------------
    MemberTest

    Determine the machines role and membership.

    Arguments:

    None.

    Return Value:
    
    TRUE: Test suceeded.
    FALSE: Test failed
        
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MemberTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pPrimaryDomain = NULL;
    DWORD       dwErr;
    NTSTATUS Status;
    DWORD LogonServerLength;
    WCHAR swzLogonServer[MAX_PATH+1];
    int     iBuildNo;
    BOOL    fDomain;        // TRUE if domain, FALSE is workgroup

    LSA_HANDLE PolicyHandle = NULL;
    PPOLICY_DNS_DOMAIN_INFO pPolicyDomainInfo = NULL;
    OBJECT_ATTRIBUTES ObjAttributes;

    PrintStatusMessage(pParams,0, IDS_MEMBER_STATUS_MSG);

    //
    // Get the build number of this machine
    //
    if (pResults->Global.pszCurrentBuildNumber &&
        (pResults->Global.pszCurrentBuildNumber[0] == 0))
    {
        PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
        PrintStatusMessage(pParams,0, IDS_MEMBER_CANNOT_DETERMINE_BUILD);
        pResults->Global.hrMemberTestResult = E_FAIL;
        return E_FAIL;
    }

    iBuildNo = _ttoi( pResults->Global.pszCurrentBuildNumber );

    
    // Assmume that the test has succeeded
    pResults->Global.hrMemberTestResult = hrOK;


    //
    // Get the name of the domain this machine is a member of
    //

    dwErr = DsRoleGetPrimaryDomainInformation(
                                              NULL,   // local call
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pPrimaryDomain);
    pResults->Global.pPrimaryDomainInfo = pPrimaryDomain;
    if (dwErr != NO_ERROR)
    {
        PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
        PrintStatusMessage(pParams,0, IDS_MEMBER_CANNOT_DETERMINE_DOMAIN);
        pResults->Global.hrMemberTestResult = E_FAIL;
        goto Cleanup;
    }

    //
    // Handle being a member of a domain
    //
    if ( pPrimaryDomain->MachineRole != DsRole_RoleStandaloneWorkstation &&
         pPrimaryDomain->MachineRole != DsRole_RoleStandaloneServer )
    {       
        //
        // Ensure the netlogon service is running.
        //
        
        dwErr = IsServiceStarted( _T("Netlogon") );
        
        if ( dwErr != NO_ERROR )
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            PrintStatusMessage(pParams,0, IDS_MEMBER_NETLOGON_NOT_RUNNING);
        }
        else
        {
            pResults->Global.fNetlogonIsRunning = TRUE;
        }
        
        //
        // Save the name of this domain as a domain to test.
        //  Do NOT free this up.  This will get freed up
        //  by the code that frees up the list of domains.

        pResults->Global.pMemberDomain = AddTestedDomain( pParams,
                                    pResults,
                                    pPrimaryDomain->DomainNameFlat,
                                    pPrimaryDomain->DomainNameDns,
                                    TRUE );
        if (pResults->Global.pMemberDomain == NULL)
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        
        
        //
        // Get the SID of the domain we're a member of
        //
        
        InitializeObjectAttributes(
                                   &ObjAttributes,
                                   NULL,
                                   0L,
                                   NULL,
                                   NULL
                                  );
        
        Status = LsaOpenPolicy(
                               NULL,
                               &ObjAttributes,
                               POLICY_VIEW_LOCAL_INFORMATION,
                               &PolicyHandle );
        
        if (! NT_SUCCESS(Status))
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            PrintDebugSz(pParams, 0, _T("    [FATAL] Member: Cannot LsaOpenPolicy."));
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        Status = LsaQueryInformationPolicy(
                                           PolicyHandle,
                                           PolicyDnsDomainInformation,
                                           (PVOID *) &pPolicyDomainInfo
                                          );
        
        if (! NT_SUCCESS(Status))
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            if (pParams->fDebugVerbose)
            PrintDebugSz(pParams, 0, _T("    [FATAL] Member: Cannot LsaQueryInformationPolicy (PolicyDnsDomainInformation).") );
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        if ( pPolicyDomainInfo->Sid == NULL )
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            
            // IDS_MEMBER_11206 "    [FATAL] Member: Cannot LsaQueryInformationPolicy has no domain sid." 
            PrintDebug(pParams, 0, IDS_MEMBER_11206 );
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        //
        // Save the domain sid for other tests
        //
        pResults->Global.pMemberDomain->DomainSid =
            Malloc(RtlLengthSid(pPolicyDomainInfo->Sid));
        if (pResults->Global.pMemberDomain->DomainSid == NULL)
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            // IDS_MEMBER_11207 "    Member: Out of memory\n" 
            PrintDebug(pParams, 0, IDS_MEMBER_11207);
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        RtlCopyMemory( pResults->Global.pMemberDomain->DomainSid,
                       pPolicyDomainInfo->Sid,
                       RtlLengthSid( pPolicyDomainInfo->Sid ) );
    }

    //Bug 293635, check whether system volume is ready if the machine is a DC
    if (DsRole_RoleBackupDomainController == pPrimaryDomain->MachineRole ||
        DsRole_RolePrimaryDomainController == pPrimaryDomain->MachineRole)
    {
        pResults->Global.fSysVolNotReady = !IsSysVolReady(pParams);
        if (pResults->Global.fSysVolNotReady)
            pResults->Global.hrMemberTestResult = S_FALSE;
    }
    
    
    //
    // Get the name of the logged on user.
    //
    Status = LsaGetUserName( &pResults->Global.pLogonUser,
                             &pResults->Global.pLogonDomainName );
    
    if ( !NT_SUCCESS(Status))
    {
        PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
        PrintStatusMessage(pParams,0, IDS_MEMBER_UNKNOWN_LOGON);
        pResults->Global.hrMemberTestResult = S_FALSE;
        goto Cleanup;
    }
    

    //
    // If we're not logged onto a local account,
    //  add the logon domain to the list of tested domains
    //
    
    if ( _wcsicmp( pResults->Global.swzNetBiosName,
                   pResults->Global.pLogonDomainName->Buffer ) != 0 )
    {
        LPWSTR pwszLogonDomainDnsName = NULL;
        DWORD cchLogonDomainDnsName = 0;

        cchLogonDomainDnsName = GetEnvironmentVariableW(c_wszUserDnsDomain, 
                                                    NULL,
                                                    0);

        if (cchLogonDomainDnsName)
        {
            pwszLogonDomainDnsName = Malloc(sizeof(WCHAR) * cchLogonDomainDnsName);
            ZeroMemory(pwszLogonDomainDnsName, sizeof(WCHAR) * cchLogonDomainDnsName);
            cchLogonDomainDnsName = GetEnvironmentVariableW(c_wszUserDnsDomain,
                                                    pwszLogonDomainDnsName,
                                                    cchLogonDomainDnsName);
        }

        // Save the name of this domain as a domain to test.
        // ------------------------------------------------------------     
        if (cchLogonDomainDnsName && pwszLogonDomainDnsName && lstrlenW(pwszLogonDomainDnsName))
        {
            pResults->Global.pLogonDomain = AddTestedDomain( pParams, pResults,
                pResults->Global.pLogonDomainName->Buffer,
                pwszLogonDomainDnsName,
                FALSE );
        }
        else
        {
            pResults->Global.pLogonDomain = AddTestedDomain( pParams, pResults,
                pResults->Global.pLogonDomainName->Buffer,
                NULL,
                FALSE );
        }
        
        if (pwszLogonDomainDnsName)
            Free(pwszLogonDomainDnsName);

        if ( pResults->Global.pLogonDomain == NULL )
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
    }
    
    //
    // Get the name of the logon server.
    //  
    LogonServerLength = GetEnvironmentVariableW(
                                                L"LOGONSERVER",
                                                swzLogonServer,
                                                DimensionOf(swzLogonServer));
    if ( LogonServerLength != 0 )
    {
        //
        // If the caller was supposed to logon to a domain,
        //  and this isn't a DC,
        //  see if the user logged on with cached credentials.
        //
        if ( pResults->Global.pLogonDomain != NULL &&
             pPrimaryDomain->MachineRole != DsRole_RoleBackupDomainController &&
             pPrimaryDomain->MachineRole != DsRole_RolePrimaryDomainController ) {
            LPWSTR pswzLogonServer;
            
            if ( swzLogonServer[0] == L'\\' && swzLogonServer[1] == L'\\')
            {
                pswzLogonServer = &swzLogonServer[2];
            }
            else
            {
                pswzLogonServer = &swzLogonServer[0];
            }
            
            pResults->Global.pswzLogonServer = _wcsdup(swzLogonServer);
        
            if ( _wcsicmp( pResults->Global.swzNetBiosName, pswzLogonServer ) == 0 )
            {
                pResults->Global.fLogonWithCachedCredentials = TRUE;                
            }           
        }
    }

    if (pPrimaryDomain->DomainNameFlat == NULL)
    {
        // the NetBIOS name is not specified
        if (FHrSucceeded(pResults->Global.hrMemberTestResult))
            pResults->Global.hrMemberTestResult = S_FALSE;
    }

    PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);
    
Cleanup:
    
    if ( pPolicyDomainInfo != NULL ) {
        (void) LsaFreeMemory((PVOID) pPolicyDomainInfo);
    }
    if ( PolicyHandle != NULL ) {
        (void) LsaClose(PolicyHandle);
    }

    return pResults->Global.hrMemberTestResult;
}

//Check if System Volume is ready
//Author:   NSun
BOOL IsSysVolReady(NETDIAG_PARAMS* pParams)
{
    DWORD   dwData = 1;
    DWORD   dwSize = sizeof(dwData);
    LONG    lRet;
    BOOL    fRetVal = TRUE;
    HKEY    hkeyNetLogonParams = NULL;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                c_szRegNetLogonParams,
                0,
                KEY_READ,
                &hkeyNetLogonParams);
    
    if (ERROR_SUCCESS == lRet)
    {
        //it's ok that the SysVolReady value doesn't exist
        if (ReadRegistryDword(hkeyNetLogonParams,
                            c_szRegSysVolReady,
                            &dwData))
        {
            if (0 == dwData)
                fRetVal = FALSE;
        }

        RegCloseKey(hkeyNetLogonParams);
    }
    else
        PrintDebugSz(pParams, 0, _T("Failed to open the registry of NetLogon parameters.\n"));

    return fRetVal;
}

/*!--------------------------------------------------------------------------
    MemberGlobalPrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void MemberGlobalPrint(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pPrimaryDomain = NULL;
    BOOL                fDomain = TRUE;
    TCHAR               szName[256];
    int                 ids;

    if (pParams->fVerbose || !FHrOK(pResults->Global.hrMemberTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_MEMBER_LONG, IDS_MEMBER_SHORT, TRUE,
                             pResults->Global.hrMemberTestResult, 0);
    }

    pPrimaryDomain = pResults->Global.pPrimaryDomainInfo;

    if (!pPrimaryDomain)
        goto L_ERROR;

    //Bug 293635, check whether system volume is ready if the machine is a DC
    if (pResults->Global.fSysVolNotReady && 
        (DsRole_RoleBackupDomainController == pPrimaryDomain->MachineRole ||
         DsRole_RolePrimaryDomainController == pPrimaryDomain->MachineRole))
    {
        PrintMessage(pParams, IDS_MEMBER_SYSVOL_NOT_READY);
    }

    if (pParams->fReallyVerbose)
        //IDS_MEMBER_11208 "    Machine is a:        "
        PrintMessage(pParams, IDS_MEMBER_11208 );

    switch ( pPrimaryDomain->MachineRole )
    {
        case DsRole_RoleStandaloneWorkstation:
            // IDS_MEMBER_11209 "Standalone Workstation" 
            ids = IDS_MEMBER_11209;
            fDomain = FALSE;
            break;
        case DsRole_RoleMemberWorkstation:
            // IDS_MEMBER_11210 "Member Workstation"
            ids = IDS_MEMBER_11210;
            fDomain = TRUE;
            break;
        case DsRole_RoleStandaloneServer:
            // IDS_MEMBER_11211 "Standalone Server" 
            ids = IDS_MEMBER_11211;
            fDomain = FALSE;
            break;
        case DsRole_RoleMemberServer:
            // IDS_MEMBER_11212 "Member Server" 
            ids = IDS_MEMBER_11212;
            fDomain = TRUE;
            break;
        case DsRole_RoleBackupDomainController:
            // IDS_MEMBER_11213 "Backup Domain Controller" 
            ids = IDS_MEMBER_11213;
            fDomain = TRUE;
            break;
        case DsRole_RolePrimaryDomainController:
            // IDS_MEMBER_11214 "Primary Domain Controller" 
            ids = IDS_MEMBER_11214;
            fDomain = TRUE;
            break;
        default:
            if (pParams->fReallyVerbose)
            {
                // IDS_MEMBER_11215 "<Unknown Role> %ld" 
                PrintMessage(pParams, IDS_MEMBER_11215,
                             pPrimaryDomain->MachineRole );
            }
            ids = 0;
            fDomain = TRUE;
            break;
    }

    if (pParams->fReallyVerbose && ids)
        PrintMessage(pParams, ids);

    if (pParams->fReallyVerbose)
        PrintNewLine(pParams, 1);

    if ( pPrimaryDomain->DomainNameFlat == NULL )
    {
        // IDS_MEMBER_11217  "    Netbios Domain name is not specified: "
        // IDS_MEMBER_11232  "    Netbios Workgroup name is not specified: "
        ids = fDomain ? IDS_MEMBER_11217 : IDS_MEMBER_11232;
    
        PrintMessage(pParams, ids);
    }
    else
    {
        // IDS_MEMBER_11216  "    Netbios Domain name: %ws\n" 
        // IDS_MEMBER_11218  "    Netbios Workgroup name: %ws\n" 
        ids = fDomain ? IDS_MEMBER_11216 : IDS_MEMBER_11218;
    
        if (pParams->fReallyVerbose)
            PrintMessage(pParams,  ids,
                         pPrimaryDomain->DomainNameFlat );
    }
    
    if ( pPrimaryDomain->DomainNameDns == NULL )
    {
        // IDS_MEMBER_11219 "    Dns domain name is not specified.\n" 
        PrintMessage(pParams,  IDS_MEMBER_11219 );
    }
    else
    {
        if (pParams->fReallyVerbose)
            // IDS_MEMBER_11220 "    Dns domain name:     %ws\n" 
            PrintMessage(pParams,  IDS_MEMBER_11220,
                         pPrimaryDomain->DomainNameDns );
    }
    
    if ( pPrimaryDomain->DomainForestName == NULL )
    {
        // IDS_MEMBER_11221 "    Dns forest name is not specified.\n" 
        PrintMessage(pParams,  IDS_MEMBER_11221 );
    }
    else
    {
        if (pParams->fReallyVerbose)
            // IDS_MEMBER_11222 "    Dns forest name:     %ws\n" 
            PrintMessage(pParams,  IDS_MEMBER_11222,
                    pPrimaryDomain->DomainForestName );
    }
    
    
    if ( pParams->fReallyVerbose )
    {
        WCHAR swzGuid[64];

        // IDS_MEMBER_11223  "    Domain Guid:         " 
        PrintMessage(pParams, IDS_MEMBER_11223);
        StringFromGUID2(&pPrimaryDomain->DomainGuid, 
                        swzGuid, 
                        DimensionOf(swzGuid));
        PrintMessage(pParams, IDS_GLOBAL_WSTRING, swzGuid);
        PrintNewLine(pParams, 1);
    
        if ( pPrimaryDomain->MachineRole != DsRole_RoleStandaloneWorkstation &&
             pPrimaryDomain->MachineRole != DsRole_RoleStandaloneServer )
        {       
            // IDS_MEMBER_11227 "    Domain Sid:          " 
            PrintMessage(pParams, IDS_MEMBER_11227);
            PrintSid( pParams, pResults->Global.pMemberDomain->DomainSid );
        }

        // IDS_MEMBER_11228  "    Logon User:          %wZ\n" 
        PrintMessage(pParams, IDS_MEMBER_11228, pResults->Global.pLogonUser );
        // IDS_MEMBER_11229  "    Logon Domain:        %wZ\n" 
        PrintMessage(pParams, IDS_MEMBER_11229, pResults->Global.pLogonDomainName );
    }
    
    if ( pParams->fReallyVerbose)
    {
        if (pResults->Global.pswzLogonServer &&
            pResults->Global.pswzLogonServer[0])
            // IDS_MEMBER_11230 "    Logon Server:        %ws\n" 
            PrintMessage(pParams, IDS_MEMBER_11230, pResults->Global.pswzLogonServer );
        
        if (pResults->Global.fLogonWithCachedCredentials)
        {
            // IDS_MEMBER_11231 "    [WARNING] Member: User was logged on with cached credentials\n" 
            PrintMessage(pParams, IDS_MEMBER_11231);
        }
    }

L_ERROR:
    return;
}

/*!--------------------------------------------------------------------------
    MemberPerInterfacePrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void MemberPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResult)
{
}

/*!--------------------------------------------------------------------------
    MemberCleanup
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void MemberCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    free(pResults->Global.pswzLogonServer);
    pResults->Global.pswzLogonServer = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\nbtnm.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      nbtnm.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//      NSun   - 9-03-1998
//
//--
#include "precomp.h"

#include "dhcptest.h"

const TCHAR c_szPath[] = _T("\\Device\\NetBT_Tcpip_");
TCHAR pDeviceName[NBT_MAXIMUM_BINDINGS][MAX_NAME+1];

TCHAR * printable( IN TCHAR *  string, IN TCHAR *  StrOut );

//$REVIEW (nsun) previously using ReadNbtNameRegistry() see Bug 152014
LONG GetInterfaceList( IN OUT TCHAR pDeviceName[][MAX_NAME+1], IN OUT PUCHAR pScope );
NTSTATUS OpenNbt(IN char path[][MAX_NAME+1], OUT PHANDLE pHandle, int max_paths);
NTSTATUS DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );


/*  =======================================================================
 *  name_type()     --  describe NBT Name types
 *
 */

char *
name_type(int t)
{
    if (t & GROUP_NAME)    return("GROUP");
    else                   return("UNIQUE");
}


//-------------------------------------------------------------------------//
//######  N b t N m T e s t ()  ###########################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Test that the names                                                //
//          <00> - wks svc name = NETBIOS computer name                    //
//          <03> - messenger svc name                                      //
//          <20> - server svc name                                         //
//      are present on all interfaces and that they are not in conflict    //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//      none                                                       //
//  Revision History:                                                      //
//      List remote machines cache too - Rajkumar 06/30/98                 //
//-------------------------------------------------------------------------//
HRESULT NbtNmTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT   hr = S_OK;
    TCHAR   pScope[MAX_NAME + 1];
    int    index;
    HANDLE hNbt = (HANDLE) -1;
    ULONG  BufferSize = sizeof(tADAPTERSTATUS);
    PVOID  pBuffer = NULL;
    LONG   lCount;
    int    nNameProblemCnt = 0;
    BOOL   is00, is03, is20, isGlobal00, isGlobal03, isGlobal20;

    tADAPTERSTATUS *pAdapterStatus;
    NAME_BUFFER    *pNames;
    NTSTATUS status;
    TDI_REQUEST_QUERY_INFORMATION QueryInfo;

    //
    // Variables for Netbios Name resolution option - Rajkumar
    //

    HKEY hkeyNetBTKey;
    HKEY hkeyNBTAdapterKey;
    DWORD valueType;
    DWORD valueLength;
    DWORD NetbiosOptions;
    INT err;

    //
    // For remote cache information
    //

    UCHAR* Addr;
    TCHAR   HostAddr[20];

    //
    // End of changes - Rajkumar 06/17/98
    //

    PrintStatusMessage(pParams, 4, IDS_NBTNM_STATUS_MSG);

    //Init the global message link list
    InitializeListHead( &pResults->NbtNm.lmsgGlobalOutput );

    if (!pResults->Global.fHasNbtEnabledInterface)
    {
        AddMessageToList( &pResults->NbtNm.lmsgGlobalOutput, Nd_Verbose, IDS_NBTNM_ALL_DISABELED);
        return S_OK;
    }

    //
    //  get the names of all the interfaces from the registry
    //
    if ( ERROR_SUCCESS != GetInterfaceList( pDeviceName, pScope ) )
    {
        //IDS_NBTNM_12201                  "    [FATAL] failed to read NBT interface info from the registry!\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_Quiet, IDS_NBTNM_12201 );
        hr = S_FALSE;
        goto end_NbtNmTest;
    }


    if ( *pScope == '\0')
        //IDS_NBTNM_12202                  "   No NetBT scope defined\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12202 );
    else
        //IDS_NBTNM_12203                  "   NetBT scope: %s\n"
        AddMessageToList(  &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12203, pScope );

    //
    //  loop through the interfaces and get the names on them
    //

    isGlobal00 = isGlobal03 = isGlobal20 = FALSE;
    for ( index = 0; index < NBT_MAXIMUM_BINDINGS && pDeviceName[index][0]; index++ )
    {
        LPTSTR  pszAdapterName;
        INTERFACE_RESULT*    pIfResults;
        UINT    c03NameProblem = 0;

        pIfResults = NULL;

        //try to find a match in the current interface list
//$REVIEW   It seems we should always find a match here. Maybe we need print
//        a FAIL message if cannot find a match.
        if( 0 == _tcsncmp(c_szPath, pDeviceName[index], _tcslen(c_szPath)))
        {
//            LPTSTR pszAdapterName;
            int i;
            pszAdapterName = _tcsdup( pDeviceName[index] + _tcslen(c_szPath));
            for ( i=0; i<pResults->cNumInterfaces; i++)
            {
                if (_tcscmp(pResults->pArrayInterface[i].pszName,
                         pszAdapterName) == 0)
                {
                pIfResults = pResults->pArrayInterface + i;
                break;
                }
            }
            Free(pszAdapterName);
        }

        if(NULL == pIfResults)
        {
            //we should be able to get the match. That is weird!
            DebugMessage("[WARNING] A NetBT interface is not in our TCPIP interface list!\n");

            // We need a new interface result structure, grab one
            // (if it is free), else allocate more.
            if (pResults->cNumInterfaces >= pResults->cNumInterfacesAllocated)
            {
                PVOID   pv;
                // Need to do a realloc to get more memory
                pv = Realloc(pResults->pArrayInterface,
                             sizeof(INTERFACE_RESULT)*(pResults->cNumInterfacesAllocated+8));
                if (pv == NULL)
                {
                    DebugMessage(" Realloc memory failed. \n");
                    hr = E_OUTOFMEMORY;
                    goto end_NbtNmTest;
                }

                pResults->pArrayInterface = pv;
                pResults->cNumInterfacesAllocated += 8;
            }

            pIfResults = pResults->pArrayInterface + pResults->cNumInterfaces;
            pResults->cNumInterfaces++;

            ZeroMemory(pIfResults, sizeof(INTERFACE_RESULT));
            pIfResults->pszName = _tcsdup(pszAdapterName);
            pIfResults->pszFriendlyName = _tcsdup(_T("Additional NetBT interface"));

            pIfResults->fActive = TRUE;
            pIfResults->NbtNm.fActive = TRUE;
            pIfResults->NbtNm.fQuietOutput = FALSE;
        }
        else
        {
            pIfResults->NbtNm.fActive = pIfResults->fActive;
        }

        if(!pIfResults->NbtNm.fActive || 
            NETCARD_DISCONNECTED == pIfResults->dwNetCardStatus)
            continue;

        InitializeListHead( &pIfResults->NbtNm.lmsgOutput );

        if (!pIfResults->fNbtEnabled)
        {
            AddMessageToList(&pIfResults->NbtNm.lmsgOutput, Nd_Verbose, IDS_NBTNM_IF_DISABLED);
			continue;
        }

/*        //$REVIEW Can we skip WAN adapters
        if ( _tcsstr( pDeviceName[index], "NdisWan" ) ) {
            //
            //  let's not worry about WAN interfaces yet
            //
            continue;
        }
*/

        // Strip off the "\Device\" off of the beginning of
            // the string
        //IDS_NBTNM_12204                  "   %s\n"
        AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12204, MapGuidToServiceName(pDeviceName[index]+8));

        status = OpenNbt( &pDeviceName[index], &hNbt, NBT_MAXIMUM_BINDINGS - index );


        //
        //  let's get the names on this interface
        //

        pBuffer = Malloc( BufferSize );
        if ( !pBuffer ) {
            DebugMessage(" [FATAL] name table buffer allocation failed!\n" );
            hr = E_OUTOFMEMORY;
            CloseHandle( hNbt );
            goto end_NbtNmTest;
        }
        ZeroMemory( pBuffer, BufferSize );

        QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status or whatever

        //
        //  find the right buffer size
        //
        status = STATUS_BUFFER_OVERFLOW;
        while ( status == STATUS_BUFFER_OVERFLOW )
        {
//$REVIEW there should be a better way to decide the buffer size
            status = DeviceIoCtrl(hNbt,
                                  pBuffer,
                                  BufferSize,
                                  IOCTL_TDI_QUERY_INFORMATION,
                                  &QueryInfo,
                                  sizeof(TDI_REQUEST_QUERY_INFORMATION)
                                );
            if ( status == STATUS_BUFFER_OVERFLOW ) {
                Free( pBuffer );
                BufferSize *= 2;
                pBuffer = Malloc( BufferSize );
                if ( !pBuffer ) {
                    DebugMessage( "       [FATAL] Buffer allocation for name table retrieval failed.\n" );
                    hr = E_OUTOFMEMORY;
                    CloseHandle( hNbt );
                    goto end_NbtNmTest;
                }
                ZeroMemory( pBuffer, BufferSize );
            }
        }

        //
        // at this point we have the local name table in pBuffer
        //

        pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
        if ( (pAdapterStatus->AdapterInfo.name_count == 0) ||
             (status != STATUS_SUCCESS) )
        {
            //IDS_NBTNM_12205                  "       No names have been found.\n"
            AddMessageToListId(&pIfResults->NbtNm.lmsgOutput, Nd_Verbose,  IDS_NBTNM_12205 );
            Free( pBuffer );
            CloseHandle( hNbt );
            continue;
        }

        pNames = pAdapterStatus->Names;
        lCount = pAdapterStatus->AdapterInfo.name_count;

        //
        //  cycle thorugh the names
        //

        nNameProblemCnt = 0;
        is00 = is03 = is20 = FALSE;
        while( lCount-- )
        {
            TCHAR szNameOut[NETBIOS_NAME_SIZE +4];
        //$REVIEW (nsun) BUG227186 CliffV said problems with <03> name is not fatal.
        // Just need a warning message.
            BOOL    f03Name = FALSE;

            if ( pNames->name[NETBIOS_NAME_SIZE-1] == 0x0 )
            {
                isGlobal00 = TRUE;
                is00 = TRUE;
                if ( !(pNames->name_flags & GROUP_NAME) ) {
                    // unique name
                    memcpy( nameToQry, pNames->name, (NETBIOS_NAME_SIZE-1));
                }
            }
            if ( pNames->name[NETBIOS_NAME_SIZE-1] == 0x3 ) {
                isGlobal03 = TRUE;
                is03 = TRUE;
                f03Name = TRUE;
            }
            if ( pNames->name[NETBIOS_NAME_SIZE-1] == 0x20 ) {
                isGlobal20 = TRUE;
                is20 = TRUE;
            }

            //IDS_NBTNM_12206                  "\t%-15.15s<%02.2X>  %-10s  "
            AddMessageToList( &pIfResults->NbtNm.lmsgOutput,
                       Nd_ReallyVerbose,
                       IDS_NBTNM_12206,
                       printable(pNames->name, szNameOut),
                       pNames->name[NETBIOS_NAME_SIZE-1],
                       name_type(pNames->name_flags));

            switch(pNames->name_flags & 0x0F)
            {
                case DUPLICATE_DEREG:
                   //IDS_NBTNM_12207                  "CONFLICT_DEREGISTERED"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12207 );

                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
                case DUPLICATE:
                   //IDS_NBTNM_12208                  "CONFLICT"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12208 );

                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
                case REGISTERING:
                    //IDS_NBTNM_12209                  "REGISTERING"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12209 );

                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
                case DEREGISTERED:
                    //IDS_NBTNM_12210                  "DEREGISTERED"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12210 );

                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
                case REGISTERED:
                    //IDS_NBTNM_12211                  "REGISTERED"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12211 );
                   break;
                default:
//$REVIEW Should have a PM to review words and grammar of the output message, DONT_KNOW
                    //IDS_NBTNM_12212                  "DONT_KNOW"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12212 );
                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
            }
            pNames++;

            //IDS_GLOBAL_EmptyLine                  "\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_GLOBAL_EmptyLine );
        } /* while() all the names on a given interface */

        if ( nNameProblemCnt != 0 )
        {
            pIfResults->NbtNm.fQuietOutput = TRUE;
            //if not really verbose, the device name is not printed before.
            if( !pParams->fReallyVerbose)
            {
                //IDS_NBTNM_12204                  "   %s\n"
                AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12204, pDeviceName[index] );
            }
            //IDS_NBTNM_12214                  "    [FATAL] At least one of your NetBT names is not registered properly!\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12214 );
            //IDS_NBTNM_12215                  "    You have a potential name conflict!\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12215 );
            //IDS_NBTNM_12216                  "    Please check that the machine name is unique!\n"
            AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12216 );
            hr = S_FALSE;
        }
        else if( c03NameProblem != 0 )
        {
            //if not really verbose, the device name is not printed before.
            if( !pParams->fReallyVerbose)
            {
                //IDS_NBTNM_12204                  "   %s\n"
                AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12204, pDeviceName[index] );
            }
            //IDS_NBTNM_03PROBLEM           "    [WARNING] At least one of your <03> NetBT names is not registered properly!\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_03PROBLEM );

        }

        if ( !(is00 && is03 && is20) )
        {
            //if not really verbose, the device name is not printed before.
            if( !pParams->fReallyVerbose)
            {
                //IDS_NBTNM_12204                  "   %s\n"
                AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12204, pDeviceName[index] );
            }
            //IDS_NBTNM_12217                  "    [WARNING] At least one of the <00>, <03>, <20> names is missing!\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Verbose, IDS_NBTNM_12217 );
        }

        nNameProblemCnt = 0;

        if (pParams->fReallyVerbose)
        {

            err = RegOpenKey(HKEY_LOCAL_MACHINE,
                         "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces",
                         &hkeyNetBTKey
                         );

            // if we are here , then we are working on a LAN card
            if( ERROR_SUCCESS != err )
            {
                DebugMessage("Error Opening \\NetBT\\Parameters\\Interfaces Key\n");
                goto continue_NbtNmTest;
            }

            err = RegOpenKey(hkeyNetBTKey,
                             pDeviceName[index]+14,
                             &hkeyNBTAdapterKey
                             );
            if( ERROR_SUCCESS != err )
            {
                DebugMessage2("Error Reading Adapter %s Key\n", pDeviceName[index]+14);
                goto continue_NbtNmTest;
            }

            valueLength = sizeof(DWORD);
            err = RegQueryValueEx(hkeyNBTAdapterKey,
                               "NetbiosOptions",
                               NULL,
                               &valueType,
                               (LPBYTE)&NetbiosOptions,
                               &valueLength
                              );
            if( ERROR_SUCCESS != err)
            {
                DebugMessage("Error Reading NetbiosOptions\n");
                goto continue_NbtNmTest;
            }

            //IDS_NBTNM_12218                  "\n          NetBios Resolution : "
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12218);
            switch( NetbiosOptions )
            {
            case 0:
                //IDS_NBTNM_12219                  "via DHCP \n\n"
                AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12219);
                break;
            case 1:
                //IDS_NBTNM_12220                  "Enabled\n\n"
                AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12220);
                break;
            case 2:
                //IDS_NBTNM_12221                  "Disabled\n\n"
                AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12221);
                break;
            default:
                //IDS_NBTNM_12222                  "Invalid Option Value!\n"
                AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12222);
                break;
            }
        }
continue_NbtNmTest:

        //
        // Start of code changes for dumping remote machine cache entries - Rajkumar
        //


        status = STATUS_BUFFER_OVERFLOW;
        while ( status == STATUS_BUFFER_OVERFLOW )
        {
            status = DeviceIoCtrl(hNbt,
                                  pBuffer,
                                  BufferSize,
                                  IOCTL_NETBT_GET_REMOTE_NAMES,
                                  NULL,
                                  0
                                );
            if ( status == STATUS_BUFFER_OVERFLOW )
            {
                Free( pBuffer );
                BufferSize *= 2;
                pBuffer = Malloc( BufferSize );
                if ( !pBuffer || (BufferSize == 0xFFFF) )
                {
                    DebugMessage( "       [FATAL] Buffer allocation for name table retrieval failed.\n" );
                    hr = E_OUTOFMEMORY;
                    CloseHandle( hNbt );
                    goto end_NbtNmTest;
                }
                ZeroMemory( pBuffer, BufferSize );
            }
        }


        pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
        if ( (pAdapterStatus->AdapterInfo.name_count == 0) ||
             (status != STATUS_SUCCESS)
           )
        {
            //IDS_NBTNM_12224                  "       No remote names have been found.\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Verbose, IDS_NBTNM_12224 );
            CloseHandle( hNbt );
            Free( pBuffer );
//$REVIEW Should we return S_FALSE here?
            continue;
        }

        pNames = pAdapterStatus->Names;
        lCount = pAdapterStatus->AdapterInfo.name_count;

        //IDS_NBTNM_12225                  "\t\tNetbios Remote Cache Table\n"
        AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12225);
        //IDS_NBTNM_12226                  "\tName      Type        HostAddress      Life [sec]\n"
        AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12226);
        //IDS_NBTNM_12227                  "\t--------------------------------------------------\n"
        AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12227);

        if (lCount == 0)
            //IDS_NBTNM_12228                  "\nNone\n\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12228);

        while (lCount-- )
        {
            TCHAR    szNameOut[NETBIOS_NAME_SIZE +4];

            //IDS_NBTNM_12229                  "\t%-15.15s<%02.2X>  %-10s  "
            AddMessageToList( &pIfResults->NbtNm.lmsgOutput,
                       Nd_ReallyVerbose,
                       IDS_NBTNM_12229,
                       printable(pNames->name, szNameOut),
                       pNames->name[NETBIOS_NAME_SIZE-1],
                       name_type(pNames->name_flags));

            Addr = &(UCHAR)((tREMOTE_CACHE *)pNames)->IpAddress;
            _stprintf( HostAddr, "%d.%d.%d.%d", Addr[3], Addr[2], Addr[1], Addr[0]);
            //IDS_NBTNM_12231                  "%-20.20s    %-d\n"
            AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12231, HostAddr, ((tREMOTE_CACHE *)pNames)->Ttl);

            ((tREMOTE_CACHE *)pNames)++;
        }

        //IDS_GLOBAL_EmptyLine                  "\n"
        AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_GLOBAL_EmptyLine);
        Free(pBuffer);
        //
        // End of code changes
        //

        CloseHandle(hNbt);
    } /* for ( all the interfaces ) */


    if ( !(isGlobal00 && isGlobal03 && isGlobal20) )
    {
        //IDS_NBTNM_12233                  "    [WARNING] You don't have a single interface with the <00>, <03>, <20> names defined!\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_Quiet, IDS_NBTNM_12233 );
    }
    else
    {
        //IDS_NBTNM_12234                  "\n    PASS - your NetBT configuration looks OK\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12234 );
        //IDS_NBTNM_12235                  "           there is at least one interface where the <00>, <03>, <20>\n"
        AddMessageToList( &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12235 );
        //IDS_NBTNM_12236                  "           names are defined and they are not in conflict.\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12236 );
     }

end_NbtNmTest:
    if ( FHrOK(hr) )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
    }

    pResults->NbtNm.hrTestResult = hr;
    return hr;
} /* END OF NbtNmTest() */


//-------------------------------------------------------------------------//
//######  O p e n N b t ()  ###############################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Opens a handle to the device                                       //
//  Arguments:                                                             //
//      path    - path to the driver                                       //
//      pHandle - the handle that we return from this function             //
//      max_paths - I think this is unused                                 //
//  Return value:                                                          //
//      0  if successful                                                   //
//      -1 otherwise                                                       //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
NTSTATUS
OpenNbt(
    IN TCHAR path[][MAX_NAME+1],
    OUT PHANDLE pHandle,
    int max_paths
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    LONG                index=0;

    assert( max_paths <= NBT_MAXIMUM_BINDINGS );

    while ((path[index][0] != 0) && (index < max_paths))
    {

        RtlInitString(&name_string, path[index]);
        RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &uc_name_string,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status = NtCreateFile(
                    &StreamHandle,
                    SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0);

        RtlFreeUnicodeString(&uc_name_string);

        if (NT_SUCCESS(status)) {
            *pHandle = StreamHandle;
            return(status);
        }

        ++index;
    }

    return (status);
} /* END OF OpenNbt() */


//-------------------------------------------------------------------------//
//######  D e v i c e I o C t r l ()  #####################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Wrapper for NtDeviceIoControlFile                                  //
//  Arguments:                                                             //
//  Return value:                                                          //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )
{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;


    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);

} /* END OF DeviceIoCtrl() */


//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure converts non prinatble characaters to periods ('.')

Arguments:
    string - the string to convert
    StrOut - ptr to a string to put the converted string into

Return Value:

    a ptr to the string that was converted (Strout)

--*/

TCHAR *
printable(
    IN TCHAR *  string,
    IN TCHAR *  StrOut
    )
{
    unsigned char *Out;
    unsigned char *cp;
    LONG     i;

    Out = StrOut;
    for (cp = string, i= 0; i < NETBIOS_NAME_SIZE; cp++,i++) {
        if (isprint(*cp)) {
            *Out++ = *cp;
            continue;
        }

        if (*cp >= 128) { /* extended characters are ok */
            *Out++ = *cp;
            continue;
        }
        *Out++ = '.';
    }
    return(StrOut);
}



//------------------------------------------------------------------------
NTSTATUS
GetInterfaceList(   IN OUT TCHAR pDeviceName[][MAX_NAME+1],
                    IN OUT PUCHAR pScope
                )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string, AnsiString;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    char                pNbtWinsDeviceName[MAX_NAME] = "\\Device\\NetBt_Wins_Export";

    PUCHAR  SubKeyParms="system\\currentcontrolset\\services\\netbt\\parameters";
    HKEY    Key;
    LONG    Type;
    ULONG   size;
    CHAR    pScopeBuffer[BUFF_SIZE];
    PUCHAR  Scope="ScopeId";

    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize=10*sizeof(NETBT_ADAPTER_INDEX_MAP)+sizeof(ULONG);
    PVOID                   pInput = NULL;
    ULONG                   SizeInput = 0;

    LONG    i, index=0;

    pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
    if (!pInterfaceInfo)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitString(&name_string, pNbtWinsDeviceName);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString(&uc_name_string);

    if (NT_SUCCESS (status))
    {
        do
        {
            status = DeviceIoCtrl(StreamHandle,
                                 pInterfaceInfo,
                                 InterfaceInfoSize,
                                 IOCTL_NETBT_GET_INTERFACE_INFO,
                                 pInput,
                                 SizeInput);

            if (status == STATUS_BUFFER_OVERFLOW)
            {
                LocalFree(pInterfaceInfo);

                InterfaceInfoSize *=2;
                pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
                if (!pInterfaceInfo || (InterfaceInfoSize == 0xFFFF))
                {
                    NtClose(StreamHandle);
                    DebugMessage("\nUnable to allocate packet");
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
            else if (!NT_SUCCESS (status))
            {
                LocalFree(pInterfaceInfo);
                NtClose(StreamHandle);
                return(status);
            }

        } while (status == STATUS_BUFFER_OVERFLOW);
        NtClose (StreamHandle);

        for (i=0; i<pInterfaceInfo->NumAdapters; i++)
        {
            RtlInitString(&name_string, NULL);
            RtlInitUnicodeString(&uc_name_string, pInterfaceInfo->Adapter[i].Name);
            if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&name_string, &uc_name_string, TRUE)))
            {
                size = (name_string.Length > MAX_NAME) ? MAX_NAME : name_string.Length;

                strncpy(pDeviceName[index], name_string.Buffer, size);
                pDeviceName[index][size] = '\0';
                RtlFreeAnsiString (&name_string);

                index++;
            }
        }

        LocalFree(pInterfaceInfo);

        //
        // NULL out the next device string ptr
        //
        if (index < NBT_MAXIMUM_BINDINGS)
        {
            pDeviceName[index][0] = '\0';
        }

        //
        // Read the ScopeId key!
        //
        size = BUFF_SIZE;
        *pScope = '\0';     // By default
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SubKeyParms,
                     0,
                     KEY_READ,
                     &Key);

        if (status == ERROR_SUCCESS)
        {
            // now read the Scope key
            status = RegQueryValueEx(Key, Scope, NULL, &Type, pScopeBuffer, &size);
            if (status == ERROR_SUCCESS)
            {
                strcpy(pScope,pScopeBuffer);
            }
            status = RegCloseKey(Key);
        }

        status = STATUS_SUCCESS;
    }
    else
    {
        LocalFree(pInterfaceInfo);
    }

    return status;
}

/*
//-------------------------------------------------------------------------//
//######  R e a d R e g i s t r y ()  #####################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Reads the names of the NetBT devices and the NetBT scope name form //
//      the registry. The names are stored in the Linkage/Export section   //
//      under the NetBT key.                                               //
//  Arguments:                                                             //
//      pScope - buffer where to store the scope string                    //
//  Return value:                                                          //
//      0  if successful                                                   //
//      -1 otherwise                                                       //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
LONG ReadNbtNameRegistry( IN OUT TCHAR pDeviceName[][MAX_NAME+1],
                          IN OUT PUCHAR pScope )
{

    LPCTSTR  c_szSubKeyParams = _T("system\\currentcontrolset\\services\\netbt\\parameters");
    LPCTSTR  c_szSubKeyLinkage = _T("system\\currentcontrolset\\services\\netbt\\linkage");
    HKEY    Key;
    LPCTSTR  c_szScope = _T("ScopeId");
    LPCTSTR  c_szExport = _T("Export");
    DWORD    dwType;
    LONG    status;
    LONG    status2;
    DWORD   size;
    LPBYTE  pBuffer;

    size = BUFF_SIZE;
    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           c_szSubKeyLinkage,
                           0,
                           KEY_READ,
                           &Key
                         );
    if ( ERROR_SUCCESS != status)
    {
        return status;
    }

    // now read the Export values

    status = RegQueryValueEx( Key,
                              c_szExport,
                              NULL,
                              &dwType,
                              NULL,
                              &size
                             );


    pBuffer = Malloc(size);
    if( NULL == pBuffer)
    {
        DebugMessage("Out of Memory!\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pBuffer, size );

    status = RegQueryValueEx( Key,
                              c_szExport,
                              NULL,
                              &dwType,
                              pBuffer,
                              &size
                            );

    if ( ERROR_SUCCESS != status)
    {
        RegCloseKey(Key);
        return status;
    }

    if ( status == ERROR_SUCCESS )
    {

        LPBYTE  curPtr = pBuffer;
        LONG    index = 0;

        //
        // Copy over all the export keys
        //

        while( (*curPtr) && (index < NBT_MAXIMUM_BINDINGS) )
        {
            _tcscpy( pDeviceName[index], curPtr );
            ++index;
            curPtr += strlen(curPtr) + 1;
        }

        //
        // NULL out the next device string ptr
        //
        if ( index < NBT_MAXIMUM_BINDINGS ) {
            pDeviceName[index][0] = 0;
        }
    }

    Free(pBuffer);

    status = RegCloseKey( Key );

    if ( status != ERROR_SUCCESS )
        DebugMessage("Error closing the Registry key\n");


    status2 = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           c_szSubKeyParams,
                           0,
                           KEY_READ,
                           &Key
                         );

    if ( status2 == ERROR_SUCCESS )
    {
        // now read the linkage values
        status2 = RegQueryValueEx( Key,
                                  c_szScope,
                                  NULL,
                                  &dwType,
                                  pScope,
                                  &size
                                );
        if( ERROR_SUCCESS != status2)
        {
            // No ScopeId!
            *pScope = 0;
        }

        status2 = RegCloseKey(Key);
    }

    return status;

}
*/




void NbtNmGlobalPrint(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || pResults->NbtNm.hrTestResult != S_OK)
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, 
                             IDS_NBTNM_LONG, 
                             IDS_NBTNM_SHORT, 
                             pResults->Global.fHasNbtEnabledInterface ? TRUE : FALSE,
                             pResults->NbtNm.hrTestResult, 0);
    }

    PrintMessageList(pParams, &pResults->NbtNm.lmsgGlobalOutput);
}

void NbtNmPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN OUT NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResults)
{
    if (!pIfResults->NbtNm.fActive ||
        NETCARD_DISCONNECTED == pIfResults->dwNetCardStatus)
        return;


    if(pParams->fVerbose || pIfResults->NbtNm.fQuietOutput)
    {
        PrintTestTitleResult(pParams, 
                             IDS_NBTNM_LONG, 
                             IDS_NBTNM_SHORT, 
                             pIfResults->fNbtEnabled ? TRUE : FALSE,
                             pResults->NbtNm.hrTestResult, 8);
    }

    PrintMessageList(pParams, &pIfResults->NbtNm.lmsgOutput);
}

void NbtNmCleanup(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    int i;
    MessageListCleanUp(&pResults->NbtNm.lmsgGlobalOutput);
    for(i = 0; i < pResults->cNumInterfaces; i++)
    {
        if(pResults->pArrayInterface[i].NbtNm.fActive)
            MessageListCleanUp(&pResults->pArrayInterface[i].NbtNm.lmsgOutput);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\modemtst.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      modemtst.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#undef IsEqualGUID
#include <ras.h>
#include <tapi.h>
#include <unimodem.h>


#define PRINT_MODEM( _i, _ids, _mdm) \
        PrintMessage(pParams, _ids, \
         MAP_ON_OFF(pResults->Modem.pModemDevice[_i].dwModemOptions & _mdm))


void GetLineId(NETDIAG_RESULT *pResults,
               int cModems,
               HLINEAPP hLineApp,
               DWORD dwDeviceID);

HRESULT
ModemTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//
// Description:
//
// This function performs diagnostics on all the line devices
//
// Arguments
// None
//
// Return:
// None
{
    
    LONG lReturn;
    DWORD dwNumDevs = 0;
    DWORD dwAPIVersion = TAPI_CURRENT_VERSION;
    HLINEAPP hLineApp = 0;
    DWORD dwDeviceID;
//  char pszDeviceClass[] = "tapi/line/diagnostics";
    char pszDeviceClass[] = "comm";
    LPVARSTRING lpVarString = NULL;
    VARSTRING   varStringT;
    DWORD   dwSize;
    LINEINITIALIZEEXPARAMS  lineParams;
    int         cModems = 0;
    
    PUMDEVCFG               lpDevConfig     = NULL;
    LPMODEMSETTINGS lpModemSettings = NULL;
    LPCOMMCONFIG    lpCommConfig    = NULL;
    HRESULT         hr = hrOK;

    PrintStatusMessage(pParams, 4, IDS_MODEM_STATUS_MSG);
    
    ZeroMemory(&lineParams, sizeof(lineParams));
    lineParams.dwTotalSize = sizeof(lineParams);
    lineParams.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;
    
    pResults->Modem.fPerformed = TRUE;

    lReturn = lineInitializeEx(
                               &hLineApp,
                               NULL,
                               NULL,
                               "NetDiag",
                               &dwNumDevs,
                               &dwAPIVersion,
                               &lineParams);
    
    
    //
    // Check whether this version can support our calls.
    // 
    
    
    if (lReturn != 0)
    {
        SetMessage(&pResults->Modem.ndOutput,
                   Nd_Quiet,
                   IDS_MODEM_LINEINIT_FAILED,
                   lReturn);
        pResults->Modem.hr = E_FAIL;
        return S_FALSE;
    }
    
    if (dwNumDevs == 0)
    {
        SetMessage(&pResults->Modem.ndOutput,
                   Nd_ReallyVerbose,
                   IDS_MODEM_NO_DEVICES);
        pResults->Modem.hr = hrOK;
        pResults->Modem.fPerformed = FALSE; //test is skipped
        return hrOK;
    }


    // Need to allocate a device structure for each device
    Free(pResults->Modem.pModemDevice);

    pResults->Modem.pModemDevice = (MODEM_DEVICE *) Malloc(
        sizeof(MODEM_DEVICE) * dwNumDevs);
    if (pResults->Modem.pModemDevice == NULL)
        return E_OUTOFMEMORY;

    ZeroMemory(pResults->Modem.pModemDevice,
               sizeof(MODEM_DEVICE) * dwNumDevs);
    pResults->Modem.cModems = dwNumDevs;
    
    //
    // Get the line device configuration settings
    //
    
    for (dwDeviceID = 0; dwDeviceID < dwNumDevs ; dwDeviceID++)
    {

        Free(lpVarString);
        lpVarString = NULL;


        // Get the proper size for the structure
        ZeroMemory(&varStringT, sizeof(VARSTRING));
        varStringT.dwTotalSize = sizeof(VARSTRING);
        lReturn = lineGetDevConfig(dwDeviceID,
                                   &varStringT,
                                   pszDeviceClass);

        if ((lReturn != 0) && (lReturn != LINEERR_STRUCTURETOOSMALL))
            continue;

        // dwSize = varStringT.dwNeededSize + sizeof(VARSTRING);
        dwSize = varStringT.dwNeededSize;
        
        lpVarString = (VARSTRING *) Malloc(dwSize);
        ZeroMemory(lpVarString, dwSize);
        lpVarString->dwTotalSize = dwSize;
        lpVarString->dwStringFormat = STRINGFORMAT_BINARY;
        lReturn = lineGetDevConfig(dwDeviceID,
                                   lpVarString,
                                   pszDeviceClass);

        
        if (lReturn != 0)
        {           
            DebugMessage2("Error: lineGetDevConfig for line id %d\n",lReturn);
            continue;
        }
        
        //
        // Interpret the results
        //
        
        if (lpVarString->dwStringFormat == STRINGFORMAT_BINARY
            && lpVarString->dwStringSize > sizeof(UMDEVCFG))
        {           
            lpDevConfig = (PUMDEVCFG) ((LPBYTE) lpVarString + lpVarString->dwStringOffset);
            lpCommConfig    = &lpDevConfig->commconfig;
            
            if (lpCommConfig->dwProviderSubType == PST_MODEM)
            {
                lpModemSettings = (LPMODEMSETTINGS)((LPBYTE) lpCommConfig + lpCommConfig->dwProviderOffset);

                GetLineId(pResults, cModems, hLineApp, dwDeviceID);
                
                pResults->Modem.pModemDevice[cModems].dwNegotiatedSpeed =
                    lpModemSettings->dwNegotiatedDCERate;
                pResults->Modem.pModemDevice[cModems].dwModemOptions =
                    lpModemSettings->dwNegotiatedModemOptions;
                pResults->Modem.pModemDevice[cModems].dwDeviceID = dwDeviceID;
                
                cModems++;
            } 
            
        }
        
    }

    pResults->Modem.cModems = cModems;
    
    Free(lpVarString);
    
    //
    // Shutdown TAPI
    //
    
    lReturn = lineShutdown(hLineApp);
    
    if (lReturn != 0)
    {       
//      if (pParams->fDebugVerbose)
//          printf("Error : lineShutdown!\n");
        pResults->Modem.hr = S_FALSE;
        return S_FALSE;
    }
    
    pResults->Modem.hr = hrOK;
    return hrOK;
    
}



/*!--------------------------------------------------------------------------
    ModemGlobalPrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ModemGlobalPrint( NETDIAG_PARAMS* pParams,
                          NETDIAG_RESULT*  pResults)
{
    int     i;
    
    if (pParams->fVerbose || !FHrOK(pResults->Modem.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_MODEM_LONG, IDS_MODEM_SHORT, pResults->Modem.fPerformed,
                             pResults->Modem.hr, 0);

        PrintNdMessage(pParams, &pResults->Modem.ndOutput);

        if (pParams->fReallyVerbose)
        {
            for ( i=0; i<pResults->Modem.cModems; i++)
            {
                PrintNewLine(pParams, 1);
                PrintMessage(pParams, IDS_MODEM_NAME,
                             pResults->Modem.pModemDevice[i].pszName);
                PrintMessage(pParams, IDS_MODEM_DEVICEID,
                             pResults->Modem.pModemDevice[i].dwDeviceID);
                PrintMessage(pParams, IDS_MODEM_PORT,
                             pResults->Modem.pModemDevice[i].pszPort);
                PrintMessage(pParams, IDS_MODEM_NEGOTIATED_SPEED,
                             pResults->Modem.pModemDevice[i].dwNegotiatedSpeed);
                
                PRINT_MODEM( i, IDS_MODEM_COMPRESSION, MDM_COMPRESSION);
                PRINT_MODEM( i, IDS_MODEM_ERROR_CONTROL, MDM_ERROR_CONTROL);
                PRINT_MODEM( i, IDS_MODEM_FORCED_EC, MDM_FORCED_EC);
                PRINT_MODEM( i, IDS_MODEM_CELLULAR, MDM_CELLULAR);
                PRINT_MODEM( i, IDS_MODEM_FLOWCONTROL_HARD, MDM_FLOWCONTROL_HARD);
                PRINT_MODEM( i, IDS_MODEM_FLOWCONTROL_SOFT, MDM_FLOWCONTROL_SOFT);
                PRINT_MODEM( i, IDS_MODEM_CCITT_OVERRIDE, MDM_CCITT_OVERRIDE);
                PRINT_MODEM( i, IDS_MODEM_SPEED_ADJUST, MDM_SPEED_ADJUST);
                PRINT_MODEM( i, IDS_MODEM_TONE_DIAL, MDM_TONE_DIAL);
                PRINT_MODEM( i, IDS_MODEM_BLIND_DIAL, MDM_BLIND_DIAL);
                PRINT_MODEM( i, IDS_MODEM_V23_OVERRIDE, MDM_V23_OVERRIDE);
                
            }
        }
    }
}

/*!--------------------------------------------------------------------------
    ModemPerInterfacePrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ModemPerInterfacePrint( NETDIAG_PARAMS* pParams,
                                NETDIAG_RESULT*  pResults,
                                INTERFACE_RESULT *pInterfaceResults)
{
    // no per-interface results
}


/*!--------------------------------------------------------------------------
    ModemCleanup
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ModemCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    int     i;
    
    ClearMessage(&pResults->Modem.ndOutput);

    for (i=0; i<pResults->Modem.cModems; i++)
    {
        Free(pResults->Modem.pModemDevice[i].pszPort);
        pResults->Modem.pModemDevice[i].pszPort = NULL;
    }
    
    Free(pResults->Modem.pModemDevice);
    pResults->Modem.pModemDevice = NULL;
    pResults->Modem.cModems = 0;
}


void GetLineId(NETDIAG_RESULT *pResults,
               int cModems,
               HLINEAPP hLineApp,
               DWORD dwDeviceID)
{
    HLINE   hLine = 0;
    LONG    lReturn;
    VARSTRING   varString;
    VARSTRING * lpVarString;
    LINEDEVCAPS lineDevCaps;
    LINEDEVCAPS * pLineDevCaps = NULL;
    
    
    lReturn = lineOpen(hLineApp,
                       dwDeviceID,
                       &hLine,
                       TAPI_CURRENT_VERSION,
                       0,
                       0,
                       LINECALLPRIVILEGE_NONE,
                       LINEMEDIAMODE_UNKNOWN,
                       NULL);

    if (lReturn == 0)
    {
        ZeroMemory(&varString, sizeof(VARSTRING));
        varString.dwTotalSize = sizeof(VARSTRING);
        lReturn = lineGetID(hLine, 0, 0, LINECALLSELECT_LINE,
                            &varString, "comm/datamodem/portname");
        if ((lReturn == 0) || (lReturn == LINEERR_STRUCTURETOOSMALL))
        {
            lpVarString = (VARSTRING *) Malloc(varString.dwNeededSize);
            if (lpVarString)
            {
				ZeroMemory(lpVarString, varString.dwNeededSize);
				lpVarString->dwTotalSize = varString.dwNeededSize;
                lReturn = lineGetID(hLine, 0, 0, LINECALLSELECT_LINE,
                                    lpVarString, "comm/datamodem/portname");
                pResults->Modem.pModemDevice[cModems].pszPort =
                    StrDupTFromA((char *) (lpVarString + 1));

                Free(lpVarString);
            }
        }
        
        lineClose(hLine);
    }

    // Get the name of this line

    ZeroMemory(&lineDevCaps, sizeof(lineDevCaps));
    lineDevCaps.dwTotalSize = sizeof(LINEDEVCAPS);
    lineDevCaps.dwStringFormat = STRINGFORMAT_UNICODE;
    
    lReturn = lineGetDevCaps(hLineApp,
                             dwDeviceID,
                             TAPI_CURRENT_VERSION, 
                             0,
                             &lineDevCaps);

    if ((lReturn == 0) || (lReturn == LINEERR_STRUCTURETOOSMALL))
    {
        pLineDevCaps = (LINEDEVCAPS *) Malloc(lineDevCaps.dwNeededSize);
		if (pLineDevCaps)
		{
			ZeroMemory(pLineDevCaps, lineDevCaps.dwNeededSize);
			pLineDevCaps->dwTotalSize = lineDevCaps.dwNeededSize;
			pLineDevCaps->dwStringFormat = STRINGFORMAT_UNICODE;
                
			lReturn = lineGetDevCaps(hLineApp,
									 dwDeviceID,
									 TAPI_CURRENT_VERSION,
									 0,
									 pLineDevCaps);
			if (lReturn == 0)
			{
				if (pLineDevCaps->dwStringFormat == STRINGFORMAT_UNICODE)
				{
					pResults->Modem.pModemDevice[cModems].pszName =
						StrDupTFromW((WCHAR *) (((BYTE *) pLineDevCaps) +
									 pLineDevCaps->dwLineNameOffset));
				}
				else
				{
					pResults->Modem.pModemDevice[cModems].pszName =
						StrDupTFromA((char *) (((BYTE *) pLineDevCaps) +
									 pLineDevCaps->dwLineNameOffset));
				}
			}
		}
        
    }
                   

    if (pLineDevCaps)
        Free(pLineDevCaps);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\nbtxport.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      nbttrprt.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "nbtutil.h"

BOOLEAN NlTransportGetIpAddress(IN LPWSTR TransportName,
                                OUT PULONG IpAddress,
                               IN OUT NETDIAG_RESULT *pResults);

/*!--------------------------------------------------------------------------
    NetBTTest
    Do whatever initialization Cliff's routines need that Karoly's will really
    do as a part of his tests.

    Arguments:
    
    None.
    
    Return Value:
    
    S_OK: Test suceeded.
    S_FALSE: Test failed
        
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT
NetBTTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT     hr = hrOK;
    NET_API_STATUS NetStatus;
    PWKSTA_TRANSPORT_INFO_0 pWti0 = NULL;
    DWORD EntriesRead;
    DWORD TotalEntries;
    DWORD i;
    PNETBT_TRANSPORT pNetbtTransport;
    LONG    cNetbtTransportCount = 0;

    //
    //  Generate a global list of NetbtTransports.
    //  ?? Karoly, Please populate GlobalNetbtTransports and cNetbtTransportCount
    //      using some mechanism lower level mechanism.
    //
    
	if (!pResults->Global.fHasNbtEnabledInterface)
	{
		pResults->NetBt.fPerformed = FALSE;
		//IDS_NETBT_SKIP
		SetMessage(&pResults->NetBt.msgTestResult,
                   Nd_Verbose,
                   IDS_NETBT_SKIP);
		return S_OK;
	}

	PrintStatusMessage(pParams,0, IDS_NETBT_STATUS_MSG);

	pResults->NetBt.fPerformed = TRUE;

    NetStatus = NetWkstaTransportEnum(
                                      NULL,
                                      0,
                                      (LPBYTE *)&pWti0, 
                                      0xFFFFFFFF,      // MaxPreferredLength
                                      &EntriesRead,
                                      &TotalEntries,
                                      NULL );          // Optional resume handle

    if (NetStatus != NERR_Success)
    {
        // IDS_NETBT_11403 "    NetBt : [FATAL] Unable to retrieve transport list from Redir. [%s]\n"
        SetMessage(&pResults->NetBt.msgTestResult,
                   Nd_Quiet,
                   IDS_NETBT_11403, NetStatusToString(NetStatus));
        
        // the test failed, but we can continue with the other tests
        hr = S_FALSE;
    }
    else
    {
        cNetbtTransportCount = 0;
        
        for ( i=0; i<EntriesRead; i++ )
        {
            UNICODE_STRING TransportName;

            RtlInitUnicodeString( &TransportName, (LPWSTR)pWti0[i].wkti0_transport_name );

            if ( TransportName.Length >= sizeof(NETBT_DEVICE_PREFIX) &&
                _wcsnicmp( TransportName.Buffer, NETBT_DEVICE_PREFIX, (sizeof(NETBT_DEVICE_PREFIX)/sizeof(WCHAR)-1)) == 0 ) {

                //
                // Determine if this is a duplicate transport
                //
                pNetbtTransport = FindNetbtTransport( pResults, TransportName.Buffer );

                if ( pNetbtTransport != NULL )
                {
                    // IDS_NETBT_DUPLICATE "    NetBt : [WARNING] Transport %-16.16wZ is a duplicate"
                    PrintStatusMessage(pParams,0, IDS_NETBT_DUPLICATE,
                                       &TransportName);

                }
                else
                {

                    //
                    // Allocate a new netbt transport
                    //
                    pNetbtTransport = (PNETBT_TRANSPORT) Malloc(
                        sizeof(NETBT_TRANSPORT) +
                        TransportName.Length + sizeof(WCHAR));
                    
                    if ( pNetbtTransport == NULL )
                    {
                        // IDS_NETBT_11404 "    NetBt : [FATAL] Out of memory."
                        SetMessage(&pResults->NetBt.msgTestResult,
                                   Nd_Quiet,
                                   IDS_NETBT_11404);
        
                        // the test failed, but we can continue with the other tests
                        hr = S_FALSE;
                        goto Cleanup;
                    }

                    ZeroMemory( pNetbtTransport, 
                        sizeof(NETBT_TRANSPORT) +
                        TransportName.Length + sizeof(WCHAR));

                    wcscpy( pNetbtTransport->pswzTransportName, TransportName.Buffer );
                    pNetbtTransport->Flags = 0;

                    if ( !NlTransportGetIpAddress( pNetbtTransport->pswzTransportName,
                        &pNetbtTransport->IpAddress,
                        pResults) )
                    {
                        // the test failed, but we can continue with the other tests
                        hr = S_FALSE;
                        goto Cleanup;
                    }

                    InsertTailList( &pResults->NetBt.Transports,
                                    &pNetbtTransport->Next );
                    cNetbtTransportCount ++;
                }
            }
        }

        if ( cNetbtTransportCount == 0 )
        {
            // IDS_NETBT_11405 "    NetBt : [FATAL] No NetBt transports are configured"
            SetMessage(&pResults->NetBt.msgTestResult,
                       Nd_Quiet,
                       IDS_NETBT_11405);
            
            // the test failed, but we can continue with the other tests
            hr = S_FALSE;
        }
        else
        {
            int     ids;
            TCHAR   szBuffer[256];

            if (cNetbtTransportCount > 1)
            {
                ids = IDS_NETBT_11406;
                // IDS_NETBT_11406 "    %ld NetBt transport%s currently configured.\n"
            }
            else
            {
                ids = IDS_NETBT_11407;
                // IDS_NETBT_11407 "    1 NetBt transport currently configured.\n"
            }
            SetMessage(&pResults->NetBt.msgTestResult,
                       Nd_Verbose,
                       ids,
                       cNetbtTransportCount);
        }
    }

    
    pResults->NetBt.cTransportCount = cNetbtTransportCount;

Cleanup:
    if ( pWti0 )
    {
        NetApiBufferFree( pWti0 );
    }

    pResults->NetBt.hr = hr;

    return hr;
}


BOOLEAN
NlTransportGetIpAddress(
                        IN LPWSTR pswzTransportName,
                        OUT PULONG IpAddress,
                        IN OUT NETDIAG_RESULT *pResults
    )
/*++

Routine Description:

    Get the IP Address associated with the specified transport.

Arguments:

    pswzTransportName - Name of the transport to query.

    IpAddress - IP address of the transport.
        Zero if the transport currently has no address or
            if the transport is not IP.

Return Value:

    TRUE: transport is an IP transport

--*/
{
    NTSTATUS Status;
    BOOLEAN RetVal = FALSE;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING TransportNameString;
    HANDLE TransportHandle = NULL;
    ULONG IpAddresses[NBT_MAXIMUM_BINDINGS+1];
    ULONG BytesReturned;

    //
    // Open the transport device directly.
    //

    *IpAddress = 0;

    RtlInitUnicodeString( &TransportNameString, pswzTransportName );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &TransportNameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    Status = NtOpenFile(
                   &TransportHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   0 );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;

    }

    if (! NT_SUCCESS(Status))
    {
        // IDS_NETBT_11408 "    [FATAL] Cannot open netbt driver '%ws'\n"
        SetMessage(&pResults->NetBt.msgTestResult,
                   Nd_Quiet,
                   IDS_NETBT_11408,
                   pswzTransportName);
        goto Cleanup;
    }

    //
    // Query the IP Address
    //

    if (!DeviceIoControl( TransportHandle,
                          IOCTL_NETBT_GET_IP_ADDRS,
                          NULL,
                          0,
                          IpAddresses,
                          sizeof(IpAddresses),
                          &BytesReturned,
                          NULL))
    {
        TCHAR   szBuffer[256];
        
        Status = NetpApiStatusToNtStatus(GetLastError());
        // IDS_NETBT_11409 "    [FATAL] Cannot get IP address from netbt driver '%ws':"
        SetMessage(&pResults->NetBt.msgTestResult,
                   Nd_Quiet,
                   IDS_NETBT_11409,
                   pswzTransportName);
        goto Cleanup;
    }

    //
    // Return IP Address
    //  (Netbt returns the address in host order.)
    //

    *IpAddress = htonl(*IpAddresses);
    RetVal = TRUE;

Cleanup:

    if ( TransportHandle != NULL )
    {
        (VOID) NtClose( TransportHandle );
    }

    return RetVal;
}

void NetBTGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    PLIST_ENTRY ListEntry;
    PNETBT_TRANSPORT pNetbtTransport;

    if (pParams->fVerbose || !FHrOK(pResults->NetBt.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_NETBT_LONG,
                             IDS_NETBT_SHORT,
                             pResults->NetBt.fPerformed,
                             pResults->NetBt.hr,
                             0);
    }


    if ( pParams->fVerbose && pResults->NetBt.fPerformed)
    {
        // IDS_NETBT_11411 "    List of NetBt transports currently configured.\n"
        PrintMessage(pParams, IDS_NETBT_11411);
    }

    // Iterate through the transports
    //
    for ( ListEntry = pResults->NetBt.Transports.Flink ;
          ListEntry != &pResults->NetBt.Transports ;
          ListEntry = ListEntry->Flink )
    {
        //
        // If the transport names match,
        //  return the entry
        //

        pNetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

        if (pParams->fVerbose)
        {
            // Strip off the "\Device\" off of the beginning of
            // the string
            
            // IDS_NETBT_11412 "        %ws\n"
            PrintMessage(pParams, IDS_NETBT_11412,
                         MapGuidToServiceNameW(pNetbtTransport->pswzTransportName+8));
        }

    }

    PrintNdMessage(pParams, &pResults->NetBt.msgTestResult);
}

void NetBTPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
}

void NetBTCleanup(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    PNETBT_TRANSPORT pNetbtTransport;
    PLIST_ENTRY pListEntry;
    PLIST_ENTRY pListHead = &pResults->NetBt.Transports;
    
    // Need to remove all entries from the list
    while (!IsListEmpty(pListHead))
    {
        pListEntry = RemoveHeadList(pListHead);
        pNetbtTransport = CONTAINING_RECORD( pListEntry, NETBT_TRANSPORT, Next );
        Free( pNetbtTransport );
    }
    
    ClearMessage(&pResults->NetBt.msgTestResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ndisquer.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ndisquer.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#pragma pack(push)
#pragma pack()
#include <ndispnp.h>
#pragma pack(pop)
#include <malloc.h>
//#include <cfgmgr32.h>

const TCHAR c_szDevicePath[] = _T("\\DEVICE\\");
const LPCTSTR c_ppszNetCardStatus[] = {
    "CONNECTED",
    "DISCONNECTED",
    "UNKNOWN"
    };

LPTSTR UTOTWithAlloc(IN PUNICODE_STRING U);

DWORD
CheckThisDriver(
    NETDIAG_RESULT *pResults, 
    PNDIS_INTERFACE pInterface, 
    DWORD *pdwNetCardStatus);


WCHAR               BLBuf[4096];
PNDIS_ENUM_INTF     Interfaces = (PNDIS_ENUM_INTF)BLBuf;

//
//  This routine first gets the list of all Network drivers and then query
//  them for the statistics
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE:  Test suceeded.
//      FALSE: Test failed
//
HRESULT NdisTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT     hr = S_OK;

    BOOL        bAtleastOneDriverOK = FALSE;

    int iIfIndex;

    PrintStatusMessage( pParams, 4, IDS_NDIS_STATUS_MSG );
    
    InitializeListHead(&pResults->Ndis.lmsgOutput);

    //IDS_NDIS_16000                  "\n    Information of Netcard drivers:\n\n" 
    AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16000);

    if (NdisEnumerateInterfaces(Interfaces, sizeof(BLBuf)))
    {
        UINT        i;

        for (i = 0; i < Interfaces->TotalInterfaces; i++) 
        {
            //we also put the netcard status to the per interface results if the interface
            //is bound to tcpip or ipx
            INTERFACE_RESULT*    pIfResults = NULL;
            LPTSTR pszDeviceDescription = UTOTWithAlloc(&Interfaces->Interface[i].DeviceDescription);
            LPTSTR pszDeviceName = UTOTWithAlloc(&Interfaces->Interface[i].DeviceName);
            DWORD  dwCardStatus = NETCARD_CONNECTED;
            
            if (pszDeviceDescription == NULL || pszDeviceName == NULL)
            {
            // memory allocation failed
               continue;
            }

//$REVIEW should we ignore WAN minports?
            if(NULL != _tcsstr(pszDeviceDescription, "WAN Miniport")){
                // ignore WAN miniports
                continue;
            }

            if(NULL != _tcsstr(pszDeviceDescription, "ATM Emulated LAN")){
                // ignore ATM Emulated LAN
                continue;
            }

            if(NULL != _tcsstr(pszDeviceDescription, "Direct Parallel"))
            {
                // ignore "Direct Parallel" interface because it doesn't support NdisQueryStatistics()
                continue;
            }


            //IDS_NDIS_16001                  "    ---------------------------------------------------------------------------\n" 
            AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16001);
            //IDS_NDIS_16002                  "    Description: %s\n" 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, 
                                IDS_NDIS_16002, pszDeviceDescription);

            //IDS_NDIS_16003                  "    Device: %s\n" 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, 
                                IDS_NDIS_16003, pszDeviceName);

            //try to find a match in the current interface list
            if( 0 == StrniCmp(c_szDevicePath, pszDeviceName, _tcslen(c_szDevicePath)))
            {
                LPTSTR pszAdapterName = pszDeviceName + _tcslen(c_szDevicePath);
    
                for ( iIfIndex=0; iIfIndex<pResults->cNumInterfaces; iIfIndex++)
                {
                    if (_tcscmp(pResults->pArrayInterface[iIfIndex].pszName,
                             pszAdapterName) == 0)
                    {
                        pIfResults = pResults->pArrayInterface + iIfIndex;
                        break;
                    }
                }
            }

            Free(pszDeviceDescription);
            Free(pszDeviceName);

            CheckThisDriver(pResults, &Interfaces->Interface[i], &dwCardStatus);

            if(NETCARD_CONNECTED == dwCardStatus)
                bAtleastOneDriverOK = TRUE;

            //if the interface is in the tcpip or ipx binding path, save the status
            //in the per interface result
            if (pIfResults)
                pIfResults->dwNetCardStatus = dwCardStatus;

        }
    } 
    else 
    {
        //IDS_NDIS_16004                  "    Enumerate failed 0x%lX\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_16004, Win32ErrorToString(GetLastError()));
        hr = S_FALSE;
    }


    //IDS_NDIS_16005                  "    ---------------------------------------------------------------------------\n" 
    AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16005);

    if(!bAtleastOneDriverOK)
    {
        BOOL    fAllCardDown = TRUE;
        for ( iIfIndex=0; iIfIndex<pResults->cNumInterfaces; iIfIndex++)
        {
            if (NETCARD_DISCONNECTED != pResults->pArrayInterface[iIfIndex].dwNetCardStatus)
            {
                fAllCardDown = FALSE;
                break;
            }
        }

        //IDS_NDIS_16006                  "    [FATAL] - None of the Netcard drivers gave satisfactory results!\n" 
        AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_16006);
        if (fAllCardDown)
        {
            //IDS_NDIS_ALL_CARD_DOWN            "\nSince there is no network connection for this machine, we do not need to perform any more network diagnostics.\n"
            AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_ALL_CARD_DOWN);
            hr = E_FAIL;
        }
        else
            hr = S_FALSE;                                                              
    } 
    else 
    {
        //IDS_NDIS_16007                  "    [SUCCESS] - At least one Netcard driver gave satisfactory results!\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16007);
    }


    if ( FHrOK(hr) )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
    }

    pResults->Ndis.hrTestResult = hr;
    return hr;
}

//Convert a UNICODE_STRING to a TString with memory allocation.
//It's the caller's responsibility to free the memory with Free()
LPTSTR UTOTWithAlloc(IN PUNICODE_STRING U)
{
    LPTSTR pszBuf = (LPTSTR)Malloc(U->Length + sizeof(TCHAR));
    if (pszBuf != NULL)
       StrnCpyTFromW(pszBuf, U->Buffer, U->Length/(sizeof(*(U->Buffer))) + 1);
    return pszBuf;
}

//Map a NetCardStatus code to the description string
LPCTSTR MapNetCardStatusToString(DWORD  dwNicStatus)
{
    return c_ppszNetCardStatus[dwNicStatus];
}

#define SECS_PER_DAY    (24*60*60)
#define SECS_PER_HOUR   (60*60)
#define SECS_PER_MIN    60

//Check and print the NIC driver status. pdwNetCardStatus will contain the net card status when
//the function returns. If the query failed, *pdwNetCardStatus will be set
// as NETCARD_STATUS_UNKNOWN.
// Return:   the Windows Error code.
DWORD
CheckThisDriver(NETDIAG_RESULT *pResults, PNDIS_INTERFACE pInterface, DWORD *pdwNetCardStatus)
{
    NIC_STATISTICS  Stats;
    DWORD   dwReturnVal = ERROR_SUCCESS;
    DWORD   dwNicStatus = NETCARD_CONNECTED;
    
    assert(pdwNetCardStatus);

    memset(&Stats, 0, sizeof(NIC_STATISTICS));
    Stats.Size = sizeof(NIC_STATISTICS);

    if(NdisQueryStatistics(&pInterface->DeviceName, &Stats))
    {
        //IDS_NDIS_16008                  "\n    Media State:                     %s\n" 
        AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16008);
        switch(Stats.MediaState)
        {
        case MEDIA_STATE_CONNECTED:
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_CONNECTED);
            break;
        case MEDIA_STATE_DISCONNECTED:
            dwNicStatus = NETCARD_DISCONNECTED; 
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_DISCONNECTED);
            break;
        default:
            dwNicStatus = NETCARD_STATUS_UNKNOWN;
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_UNKNOWN);
            break;
        }

        //IDS_NDIS_16009                  "\n    Device State:                     " 
        AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16009);
        switch(Stats.DeviceState)
        {
        case DEVICE_STATE_CONNECTED:
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_CONNECTED);
            break;
        case DEVICE_STATE_DISCONNECTED:
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_DISCONNECTED);
            break;
        default:
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_UNKNOWN);
            break;
        }
        

        //IDS_NDIS_16010                  "    Connect Time:                    " 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16010);
        if (Stats.ConnectTime > SECS_PER_DAY)
        {
            //IDS_NDIS_16011                  "%d days, " 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16011, Stats.ConnectTime / SECS_PER_DAY);
            Stats.ConnectTime %= SECS_PER_DAY;
        }
        //IDS_NDIS_16012                  "%02d:" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16012, Stats.ConnectTime / SECS_PER_HOUR);
        Stats.ConnectTime %= SECS_PER_HOUR;
        //IDS_NDIS_16013                  "%02d:" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16013, Stats.ConnectTime / SECS_PER_MIN);
        Stats.ConnectTime %= SECS_PER_MIN;
        //IDS_NDIS_16014                  "%02d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16014, Stats.ConnectTime);

        Stats.LinkSpeed *= 100;
        if (Stats.LinkSpeed >= 1000000000)
            //IDS_NDIS_16015                  "    Media Speed:                     %d Gbps\n" 
          AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16015, 
                                                    Stats.LinkSpeed / 1000000000);
        else if (Stats.LinkSpeed >= 1000000)
            //IDS_NDIS_16016                  "    Media Speed:                     %d Mbps\n" 
          AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16016, 
                                                    Stats.LinkSpeed / 1000000);
        else if (Stats.LinkSpeed >= 1000)
            //IDS_NDIS_16017                  "    Media Speed:                     %d Kbps\n" 
          AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16017, 
                                                    Stats.LinkSpeed / 1000);
        else
            //IDS_NDIS_16018                  "    Media Speed:                     %d bps\n" 
          AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16018, 
                                                    Stats.LinkSpeed);

        //IDS_NDIS_16019                  "\n    Packets Sent:                    %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16019, Stats.PacketsSent);
        //IDS_NDIS_16020                  "    Bytes Sent (Optional):           %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16020, Stats.BytesSent);

        //IDS_NDIS_16021                  "\n    Packets Received:                %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16021, 
                                                    Stats.PacketsReceived);
        //IDS_NDIS_16022                  "    Directed Pkts Recd (Optional):   %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16022, 
                                                Stats.DirectedPacketsReceived);
        //IDS_NDIS_16023                  "    Bytes Received (Optional):       %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16023, 
                                                Stats.BytesReceived);
        //IDS_NDIS_16024                  "    Directed Bytes Recd (Optional):  %d\n\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16024, 
                                                Stats.DirectedBytesReceived);

        if (Stats.PacketsSendErrors != 0)
            //IDS_NDIS_16025                  "    Packets SendError:               %d\n" 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16025, 
                                                Stats.PacketsSendErrors);
        if (Stats.PacketsReceiveErrors != 0)
            //IDS_NDIS_16026                  "    Packets RecvError:               %d\n" 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16026, 
                                                Stats.PacketsReceiveErrors);
    
        // if we received packets, consider this driver to be fine
        if(NETCARD_CONNECTED != dwNicStatus)
        {
            //IDS_NDIS_16029                "	[WARNING] The net card '%wZ' may not work!\n"
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_16029,
                              &pInterface->DeviceDescription);
        }
        else if (!Stats.PacketsReceived)
        {
            //IDS_NDIS_NO_RCV                   "    [WARNING] The net card '%wZ' may not be working because it receives no packets!\n"
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_NO_RCV,
                              &pInterface->DeviceDescription);
        }
    } else {
        dwReturnVal = GetLastError();
        //IDS_NDIS_16027                  "    GetStats failed for '%wZ'. [%s]\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_16027, 
                          &pInterface->DeviceDescription, Win32ErrorToString(dwReturnVal));
        
        dwNicStatus = NETCARD_STATUS_UNKNOWN;
    }

    
    *pdwNetCardStatus = dwNicStatus;

    return dwReturnVal;
}


void NdisGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || !FHrOK(pResults->Ndis.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_NDIS_LONG,
                             IDS_NDIS_SHORT,
                             TRUE,
                             pResults->Ndis.hrTestResult,
                             0);
    }

    PrintMessageList(pParams, &pResults->Ndis.lmsgOutput);
}

void NdisPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    if (pParams->fVerbose || NETCARD_CONNECTED != pInterfaceResults->dwNetCardStatus)
    {
        PrintNewLine(pParams, 1);
        if (NETCARD_CONNECTED != pInterfaceResults->dwNetCardStatus)
        {
            PrintTestTitleResult(pParams, IDS_NDIS_LONG, IDS_NDIS_SHORT, TRUE, S_FALSE, 8);
            //IDS_NDIS_16030    "	NetCard Status			%s\n"
            PrintMessage(pParams, IDS_NDIS_16030, MapNetCardStatusToString(pInterfaceResults->dwNetCardStatus));
            if (NETCARD_DISCONNECTED == pInterfaceResults->dwNetCardStatus)
                PrintMessage(pParams, IDS_NDIS_CARD_DOWN);
        }
        else
            PrintTestTitleResult(pParams, IDS_NDIS_LONG, IDS_NDIS_SHORT, TRUE, S_OK, 8);
    }
}


void NdisCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Ndis.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ndstruct.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ndstruct.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_NDSTRUCT
#define HEADER_NDSTRUCT


typedef struct _NETBT_TRANSPORT {
    LIST_ENTRY Next;

    //
    // Flags describing this Netbt transport
    //

    DWORD Flags;

#define BOUND_TO_REDIR    0x001 // Transport is bound to the redir
#define BOUND_TO_BOWSER   0x002 // Transport is bound to the bowser
#define IP_ADDRESS_IN_DNS 0x004 // IP address is registered in DNS

    //
    // IP Address for this transport
    //

    ULONG IpAddress;

    //
    // Name of the transport (Must be the last field in the structure)
    //
    WCHAR pswzTransportName[1];
} NETBT_TRANSPORT, *PNETBT_TRANSPORT;


//
// Structure describing a single tested domain
//

typedef struct _TESTED_DOMAIN {
    LIST_ENTRY Next;

    //
    // Name of the domain.
    //
    //  Queryable domain is NULL for the domain we're a member of so we can
    //  pass NULL to DsGetDcName for that domain.  Doing so has better query
    //  characteristics since it tries both the Netbios and DNS domain names.
    //
    //LPWSTR DomainName;
    LPWSTR  NetbiosDomainName;      // NULL if not known
    LPWSTR  DnsDomainName;          // NULL if not known
    LPWSTR  PrintableDomainName;    // Pointer to a non-NULL domain name string

    LPWSTR QueryableDomainName;  // Can be NULL for domain we're a member of
    BOOL    fPrimaryDomain;      // True if the domain is domain we're a member of 

    //BOOL IsNetbios;     // True if DomainName is syntactically a Netbios name
    //BOOL IsDns;         // True if DomainName is syntactically a Dns name

    //
    // Domain Sid of the domain (if known)
    //
	BOOL fDomainSid;		// do we have the domain sid?
    PSID DomainSid;

    //
    // DcInfo for a DS_PREFERRED DC in the domain.
    //
    PDOMAIN_CONTROLLER_INFOW DcInfo;
    BOOL    fTriedToFindDcInfo;

    //
    // List of DCs to test.
    //

    LIST_ENTRY TestedDcs;

} TESTED_DOMAIN, *PTESTED_DOMAIN;

//
// Structure describing a single tested DC
//

typedef struct _TESTED_DC {
    LIST_ENTRY Next;

    //
    // Name of the DC
    //
    // This will be the DNS DC name if we know it.  Otherwise it will be the
    // Netbios DC name.
    //
    LPWSTR ComputerName;

    WCHAR NetbiosDcName[CNLEN+1];

	ULONG	Rid;

    //
    // IP Address of the DC
    //  NULL: Not yet known
    //

    LPWSTR DcIpAddress;

    //
    // Backlink to domain this DC belongs to
    //

    PTESTED_DOMAIN TestedDomain;

    //
    // Flags describing this DC.
    //

    ULONG Flags;

#define DC_IS_DOWN      0x001   // DC cannot be pinged
#define DC_IS_NT5       0x002   // DC is running NT 5 (or newer)
#define DC_IS_NT4       0x004   // DC is running NT 4 (or older)
#define DC_PINGED       0x008   // The DC pinged
#define DC_FAILED_PING	0x010	// The DC ping failed


} TESTED_DC, *PTESTED_DC;


//
// Generic interface to DsGetDcName

typedef DWORD (WINAPI DSGETDCNAMEW)(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\nbtutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nbtutil.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_NBTUTIL
#define HEADER_NBTUTIL

PNETBT_TRANSPORT FindNetbtTransport(NETDIAG_RESULT *pResults,
									LPWSTR TransportName);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\nbtutil.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      domutil.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//		the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information. 
//--

//
// Common include files.
//
#include "precomp.h"
#include "nbtutil.h"


/*!--------------------------------------------------------------------------
	FindNetbtTransport

    Determine if the specified Netbt transport is configured.

	Arguments:
	
	TransportName - Name of transport to find.
	
	Return Value:

    Pointer to struct describing transport
    NULL: Transport is not configured

	Author: KennT
 ---------------------------------------------------------------------------*/
PNETBT_TRANSPORT
FindNetbtTransport(
				   NETDIAG_RESULT *pResults,
				   LPWSTR pswzTransportName
				  )
{
    PLIST_ENTRY ListEntry;
    PNETBT_TRANSPORT pNetbtTransport;

    //
    // Loop through the list of netbt transports finding this one.
    //

    for ( ListEntry = pResults->NetBt.Transports.Flink ;
          ListEntry != &pResults->NetBt.Transports ;
          ListEntry = ListEntry->Flink )
	{
        //
        // If the transport names match,
        //  return the entry
        //

        pNetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

        if ( _wcsicmp( pNetbtTransport->pswzTransportName, pswzTransportName ) == 0 ) {
            return pNetbtTransport;
        }

    }

    return NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ndutils.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ndutils.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "global.h"
#include <ntstatus.dbg>
#include <winerror.dbg>
#include "ipcfg.h"

#define MAX_NET_STATUS_LENGTH 80
#define MAX_WINERR_SIZE       80

const TCHAR c_szSectionName[] = _T("NetDiagContact");
const TCHAR c_szFileName[] = _T("NdContact.ini");


HRESULT HResultFromWin32(DWORD dwErr)
{
    return HRESULT_FROM_WIN32(dwErr);
}

LPTSTR Win32ErrorToString(DWORD Id)
{
    
    int i = 0;
    static TCHAR s_szWinerr[MAX_WINERR_SIZE + 1];
    
    while (winerrorSymbolicNames[ i ].SymbolicName) 
    {
        if (winerrorSymbolicNames[ i ].MessageId == Id) 
        {
            _tcsncpy( s_szWinerr, A2T(winerrorSymbolicNames[ i ].SymbolicName), 
                      MAX_WINERR_SIZE);

            return s_szWinerr;
        } 
        else 
        {
            i ++;
        }
    }

    
    //if we reach here, then we cannot find the Win32 Error string

    _stprintf(s_szWinerr, _T("%X"), (DWORD)Id);
    
    return s_szWinerr;

}

LPSTR
FindSymbolicNameForStatus(
    DWORD Id
    )
{
    ULONG i;

    i = 0;
    if (Id == 0) {
        return "STATUS_SUCCESS";
    }

    if (Id & 0xC0000000) {
        while (ntstatusSymbolicNames[ i ].SymbolicName) {
            if (ntstatusSymbolicNames[ i ].MessageId == (NTSTATUS)Id) {
                return ntstatusSymbolicNames[ i ].SymbolicName;
            } else {
                i += 1;
            }
        }
    }

    i = 0;
    while (winerrorSymbolicNames[ i ].SymbolicName) {
        if (winerrorSymbolicNames[ i ].MessageId == Id) {
            return winerrorSymbolicNames[ i ].SymbolicName;
        } else {
            i += 1;
        }
    }

#ifdef notdef
    while (neteventSymbolicNames[ i ].SymbolicName) {
        if (neteventSymbolicNames[ i ].MessageId == Id) {
            return neteventSymbolicNames[ i ].SymbolicName
        } else {
            i += 1;
        }
    }
#endif // notdef

    return NULL;
}




VOID
PrintSid(
    IN NETDIAG_PARAMS *pParams,
    IN PSID Sid OPTIONAL
    )
/*++

Routine Description:

    Prints a SID

Arguments:

    Sid - SID to output

Return Value:

    none

--*/
{

    if ( Sid == NULL ) 
    {
        //IDS_UTIL_SID_NULL      "(null)\n"
        PrintMessage(pParams, IDS_UTIL_SID_NULL);
    } 
    else 
    {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );

        if ( !NT_SUCCESS(Status) ) 
        {
            //IDS_UTIL_SID_INVALID       "Invalid 0x%lX\n"
            PrintMessage(pParams, IDS_UTIL_SID_INVALID, Status);
        } 
        else 
        {
            //IDS_GLOBAL_UNICODE_STRING          "%wZ"
            PrintMessage(pParams, IDS_GLOBAL_UNICODE_STRING, &SidString);
            PrintNewLine(pParams, 1);
            RtlFreeUnicodeString( &SidString );
        }
    }

}



NET_API_STATUS
IsServiceStarted(
    IN LPTSTR pszServiceName
    )

/*++

Routine Description:

    This routine queries the Service Controller to find out if the
    specified service has been started.

Arguments:

    pszServiceName - Supplies the name of the service.

Return Value:

    NO_ERROR: if the specified service has been started
    -1: the service was stopped normally
    Otherwise returns the reason the service isn't running.


--*/
{
    NET_API_STATUS NetStatus;
    SC_HANDLE hScManager;
    SC_HANDLE hService;
    SERVICE_STATUS ServiceStatus;


    if ((hScManager = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT
                          )) == (SC_HANDLE) NULL) {

        NetStatus = GetLastError();

        DebugMessage2(" IsServiceStarted(): OpenSCManager failed. [%s]\n", NetStatusToString(NetStatus));

        return NetStatus;
    }

    if ((hService = OpenService(
                        hScManager,
                        pszServiceName,
                        SERVICE_QUERY_STATUS
                        )) == (SC_HANDLE) NULL) 
    {

        NetStatus = GetLastError();

        DebugMessage3(" IsServiceStarted(): OpenService '%s' failed. [%s]\n", 
                            pszServiceName, NetStatusToString(NetStatus) );

        (void) CloseServiceHandle(hScManager);

        return NetStatus;
    }

    if (! QueryServiceStatus(
              hService,
              &ServiceStatus
              )) {


        NetStatus = GetLastError();

        DebugMessage3(" IsServiceStarted(): QueryServiceStatus '%s' failed. [%s]\n", 
                        pszServiceName, NetStatusToString(NetStatus) );

        (void) CloseServiceHandle(hScManager);
        (void) CloseServiceHandle(hService);

        return NetStatus;
    }

    (void) CloseServiceHandle(hScManager);
    (void) CloseServiceHandle(hService);

    switch ( ServiceStatus.dwCurrentState ) 
    {
        case SERVICE_RUNNING:
        case SERVICE_CONTINUE_PENDING:
        case SERVICE_PAUSE_PENDING:
        case SERVICE_PAUSED:
            NetStatus = NO_ERROR;
            break;
        case SERVICE_STOPPED:
        case SERVICE_START_PENDING:
        case SERVICE_STOP_PENDING:
            if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) 
            {
                NetStatus = ServiceStatus.dwServiceSpecificExitCode;
                if ( NetStatus == NO_ERROR ) 
                {
                    NetStatus = ServiceStatus.dwWin32ExitCode;
                }
            } 
            else 
            {
                NetStatus = ServiceStatus.dwWin32ExitCode;
                if ( NetStatus == NO_ERROR ) 
                {
                    NetStatus = -1;
                }
            }
            break;
        default:
            NetStatus = ERROR_INTERNAL_ERROR;
            break;
    }

    return NetStatus;

} // IsServiceStarted



LPSTR MapTime(DWORD_PTR TimeVal)
//++
//
// Description:
//  Converts IP lease time to more human-sensible string
//
//  ENTRY   TimeVal - DWORD (time_t) time value (number of milliseconds since
//                  virtual year dot)
//
//
//  RETURNS pointer to string
// 
//  ASSUMES 1.  The caller realizes this function returns a pointer to a static
//            buffer, hence calling this function a second time, but before
//            the results from the previous call have been used, will destroy
//            the previous results
//--
{

    struct tm* pTime;
    static char timeBuf[128];
    static char oemTimeBuf[256];

    if (pTime = localtime(&TimeVal)) {

        SYSTEMTIME systemTime;
        char* pTimeBuf = timeBuf;
        int n;

        systemTime.wYear = pTime->tm_year + 1900;
        systemTime.wMonth = pTime->tm_mon + 1;
        systemTime.wDayOfWeek = (WORD)pTime->tm_wday;
        systemTime.wDay = (WORD)pTime->tm_mday;
        systemTime.wHour = (WORD)pTime->tm_hour;
        systemTime.wMinute = (WORD)pTime->tm_min;
        systemTime.wSecond = (WORD)pTime->tm_sec;
        systemTime.wMilliseconds = 0;
        n = GetDateFormat(0, DATE_LONGDATE, &systemTime, NULL, timeBuf, sizeof(timeBuf));
        timeBuf[n - 1] = ' ';
        GetTimeFormat(0, 0, &systemTime, NULL, &timeBuf[n], sizeof(timeBuf) - n);

        //
        // we have to convert the returned ANSI string to the OEM charset
        // 
        //

        if (CharToOem(timeBuf, oemTimeBuf)) {
            return oemTimeBuf;
        }

        return timeBuf;
    }
    return "";
}



//used in DCListTest and TrustTest
NTSTATUS
NettestSamConnect(
                  IN NETDIAG_PARAMS *pParams,
                  IN LPWSTR DcName,
                  OUT PSAM_HANDLE SamServerHandle
    )
/*++

Routine Description:

    Determine if the DomainSid field of the TestDomain matches the DomainSid
    of the domain.

Arguments:

    DcName - Dc to connect to

    SamServerHandle - Returns a Sam server handle

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    
    UNICODE_STRING ServerNameString;
    SAM_HANDLE LocalSamHandle = NULL;

    BOOL    fImpersonatingAnonymous = FALSE;
    HANDLE  hCurrentToken;

    //
    // Connect to the SAM server
    //

    RtlInitUnicodeString( &ServerNameString, DcName );

    Status = SamConnect(
                &ServerNameString,
                &LocalSamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                NULL);

    //
    // Consider the case where we don't have access to the DC.
    //  We might be logged on locally due to the domain sid being wrong.
    //

    if ( Status == STATUS_ACCESS_DENIED ) {

        //
        // Try impersonating the anonymous token.
        //

        //
        // Check to see if we're already impsonating
        //

        Status = NtOpenThreadToken(
                        NtCurrentThread(),
                        TOKEN_IMPERSONATE,
                        TRUE,       // as self to ensure we never fail
                        &hCurrentToken );

        if ( Status == STATUS_NO_TOKEN ) {
            //
            // We're not already impersonating
            hCurrentToken = NULL;

        } else if ( !NT_SUCCESS( Status) ) {
            PrintGuruMessage("    [WARNING] Cannot NtOpenThreadToken" );
            PrintGuru( NetpNtStatusToApiStatus( Status ), SAM_GURU );
            goto Cleanup;
        }


        //
        // Impersonate the anonymous token
        //
        Status = NtImpersonateAnonymousToken( NtCurrentThread() );

        if ( !NT_SUCCESS( Status)) {
            PrintGuruMessage("    [WARNING] Cannot NtOpenThreadToken" );
            PrintGuru( NetpNtStatusToApiStatus( Status ), SAM_GURU );
            goto Cleanup;
        }

        fImpersonatingAnonymous = TRUE;

        //
        // Try the SamConnect again
        //

        Status = SamConnect(
                    &ServerNameString,
                    &LocalSamHandle,
                    SAM_SERVER_LOOKUP_DOMAIN,
                    NULL);

        if ( Status == STATUS_ACCESS_DENIED ) {
                // One can configure SAM this way so it isn't fatal
                DebugMessage2("    [WARNING] Cannot connect to SAM on '%ws' using a NULL session.", DcName );
            goto Cleanup;
        }
    }


    if ( !NT_SUCCESS(Status)) {
        LocalSamHandle = NULL;
        DebugMessage2("    [FATAL] Cannot connect to SAM on '%ws'.", DcName );
        goto Cleanup;
    }

    //
    // Success
    //


    *SamServerHandle = LocalSamHandle;
    Status = STATUS_SUCCESS;


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( fImpersonatingAnonymous ) {
        NTSTATUS TempStatus;

        TempStatus = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hCurrentToken,
                         sizeof(HANDLE) );

        if (!NT_SUCCESS( TempStatus)) {
            DebugMessage2( "SamConnect: Unexpected error reverting to self: 0x%lx\n",
                     TempStatus );
        }

    }

    return Status;
}




//only used in Kerberos test so far
VOID
sPrintTime(
    LPSTR str,
    LARGE_INTEGER ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - GMT time to print (Nothing is printed if this is zero)

Return Value:

    None

--*/
{
    //
    // If we've been asked to convert an NT GMT time to ascii,
    //  Do so
    //

    if ( ConvertTime.QuadPart != 0 ) {
        LARGE_INTEGER LocalTime;
        TIME_FIELDS TimeFields;
        NTSTATUS Status;

        Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
        if ( !NT_SUCCESS( Status )) {
            sprintf(str, "Can't convert time from GMT to Local time" );
            LocalTime = ConvertTime;
        }

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        sprintf(str, "%ld/%ld/%ld %ld:%2.2ld:%2.2ld",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }
}


/*!--------------------------------------------------------------------------
    GetComputerNameInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetComputerNameInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    DWORD   cchSize;
    WCHAR   swzNetBiosName[MAX_COMPUTERNAME_LENGTH+1];

    cchSize = DimensionOf(swzNetBiosName);

    if ( !GetComputerNameW( swzNetBiosName, &cchSize ) )
    {
        PrintMessage(pParams, IDS_GLOBAL_NoComputerName);
        return HResultFromWin32(GetLastError());
    }

    lstrcpynW(pResults->Global.swzNetBiosName, swzNetBiosName,
              MAX_COMPUTERNAME_LENGTH+1);

    return hrOK;
}


/*!--------------------------------------------------------------------------
    GetDNSInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetDNSInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    UINT    cchSize;
    TCHAR   szDnsName[DNS_MAX_NAME_LENGTH+1];
    HRESULT hr = hrOK;
    //
    // Get the DNS host name.
    //

    memset(szDnsName,0,sizeof(TCHAR)*(DNS_MAX_NAME_LENGTH+1));
    cchSize = DimensionOf(szDnsName);


    if (!GetComputerNameExA( ComputerNameDnsFullyQualified,
                            szDnsName,
                            &cchSize))
    {
        PrintMessage(pParams, IDS_GLOBAL_ERR_NoDnsName);
    }
    else
    {
        lstrcpyn(pResults->Global.szDnsHostName, szDnsName, DNS_MAX_NAME_LENGTH+1);
        // Look for the first '.' in the name
        pResults->Global.pszDnsDomainName = strchr(pResults->Global.szDnsHostName,
                                                   _T('.'));
    

        if (pResults->Global.pszDnsDomainName != NULL)
        {
            pResults->Global.pszDnsDomainName++;
        }
    }
    return hr;
}


/*!--------------------------------------------------------------------------
    GetNetBTParameters
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetNetBTParameters(IN NETDIAG_PARAMS *pParams,
                           IN OUT NETDIAG_RESULT *pResults)
{
    LONG    err;
    HRESULT hr = hrOK;
    HKEY hkeyServices;
    HKEY hkeyNetBT;
    DWORD dwLMHostsEnabled;
    DWORD dwDnsForWINS;
    DWORD dwType;
    DWORD dwLength;

    if (!pParams->fVerbose)
        return hrOK;

    // set defaults
    pResults->Global.dwLMHostsEnabled = E_FAIL;
    pResults->Global.dwDnsForWINS = E_FAIL;
    
    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     _T("SYSTEM\\CurrentControlSet\\Services"),
                     &hkeyServices
                    );
    if (err != ERROR_SUCCESS)
    {
        pResults->Global.dwLMHostsEnabled = HResultFromWin32(err);
        pResults->Global.dwDnsForWINS = HResultFromWin32(err);

        PrintDebugSz(pParams, 0, _T("Services opening failed\n"));
    }
    else
    {           
        err = RegOpenKey(hkeyServices,
                         _T("NetBT\\Parameters"),
                         &hkeyNetBT
                        );
        if (err != ERROR_SUCCESS)
        {
            pResults->Global.dwLMHostsEnabled = HResultFromWin32(err);
            pResults->Global.dwDnsForWINS = HResultFromWin32(err);

            PrintDebugSz(pParams, 0, _T("Parameters opening failed\n"));
        }
        else
        {
            dwLength = sizeof(DWORD);
            err = RegQueryValueEx(hkeyNetBT,
                                  _T("EnableLMHOSTS"),
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&dwLMHostsEnabled,
                                  &dwLength
                                 );
            if (err != ERROR_SUCCESS)
            {
                pResults->Global.dwLMHostsEnabled = HResultFromWin32(err);
                DebugMessage("Quering EnableLMHOSTS failed !\n");
            }
            else
            {
                pResults->Global.dwLMHostsEnabled = dwLMHostsEnabled;
            }
            
            //
            //  In NT 5.0 - Dns for wins resolution is enabled by
            //  default and the "EnableDNS" key will not be found.
            //  If it is not found, we will assume its enabled.
            //  In NT 4.0 - the key will be there and its value
            //  should let us know whether the option is enabled
            //  or disabled
            //
            
            dwLength = sizeof(DWORD);
            err = RegQueryValueEx(hkeyNetBT,
                                  "EnableDNS",
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&dwDnsForWINS,
                                  &dwLength
                                 );
            
            if (err == ERROR_SUCCESS)
            {
                pResults->Global.dwDnsForWINS = dwDnsForWINS;
            }
            else
            {
                pResults->Global.dwDnsForWINS = TRUE;
            }
                        
        }
    }

    return hrOK;
}


ULONG inet_addrW(LPCWSTR pswz)
{
    ULONG   ulReturn;
    CHAR *  psaz;

    psaz = StrDupAFromW(pswz);
    if (psaz == NULL)
        return 0;

    ulReturn = inet_addrA(psaz);
    Free(psaz);
    
    return ulReturn;
}




LPTSTR
NetStatusToString(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Conver a net status code or a Windows error code to the description string.
    NOTE: The string is garuanteed to be valid only right after NetStatusToString is called. 

Arguments:

    NetStatus - The net status code to print.

Return Value:

    The status description string

--*/
{
    static TCHAR   s_szSymbolicName[MAX_NET_STATUS_LENGTH + 1];
    ZeroMemory(s_szSymbolicName, sizeof(s_szSymbolicName));

    switch (NetStatus) 
    {
    case NERR_Success:
        _tcscpy( s_szSymbolicName, _T("NERR_Success") );
        break;

    case NERR_DCNotFound:
        _tcscpy( s_szSymbolicName, _T("NERR_DCNotFound") );
        break;

    case NERR_UserNotFound:
        _tcscpy( s_szSymbolicName, _T("NERR_UserNotFound") );
        break;

    case NERR_NetNotStarted:
        _tcscpy( s_szSymbolicName, _T("NERR_NetNotStarted") );
        break;

    case NERR_WkstaNotStarted:
        _tcscpy( s_szSymbolicName, _T("NERR_WkstaNotStarted") );
        break;

    case NERR_ServerNotStarted:
        _tcscpy( s_szSymbolicName, _T("NERR_ServerNotStarted") );
        break;

    case NERR_BrowserNotStarted:
        _tcscpy( s_szSymbolicName, _T("NERR_BrowserNotStarted") );
        break;

    case NERR_ServiceNotInstalled:
        _tcscpy( s_szSymbolicName, _T("NERR_ServiceNotInstalled") );
        break;

    case NERR_BadTransactConfig:
        _tcscpy( s_szSymbolicName, _T("NERR_BadTransactConfig") );
        break;

    default:
        {
            LPSTR paszName = FindSymbolicNameForStatus( NetStatus );
            USES_CONVERSION;
            
            
            if (NULL == paszName)
            {
                _stprintf(s_szSymbolicName, _T("%X"), (DWORD)NetStatus);
            }
            else
            {
                _tcsncpy( s_szSymbolicName, A2T(paszName), MAX_NET_STATUS_LENGTH);
            }
        }
        break;

    }

    return s_szSymbolicName;
}

//Load contact info from the [NetDiagContact] section of the ini file.
//  pszTestName     [in]    short name of the test, which is also the key name in the ini file
//  pszContactInfo  [out]   the string of contact info. It will be empty string of the key cannot be found.
//  cChSize         [in]    the buffer size, in characters, of pszContactInfo
//
//  return: the number of characters copied to the buffer.
DWORD LoadContact(LPCTSTR pszTestName, LPTSTR pszContactInfo, DWORD cChSize)
{
    return GetPrivateProfileString(c_szSectionName,
                                pszTestName,
                                _T(""),
                                pszContactInfo,
                                cChSize,
                                c_szFileName);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\ndcommon.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ndcommon.h
//
//--------------------------------------------------------------------------

//
// Common include files.
//
#ifndef HEADER_COMMONTMP
#define HEADER_COMMONTMP

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>
#include <rpc.h>
#include <tchar.h>

#include <align.h>      // ROUND_UP_COUNT ...
// Porting to Source Depot - smanda #include <accessp.h>    // DsGetDc initialization
#include <dsgetdc.h>    // DsGetDcName()
#include <dsrole.h>     // DsRoleGetPrimaryDomainInfo
#include <dnsapi.h>     // DNS APIs
// #include <..\..\dns\dnslib\dnslib.h>     // Private DNS routines
// #include <dnslib.h>     // Private DNS routines
#include <icanon.h>     // NAMETYPE_* defines
#define _AVOID_IP_ADDRESS 1
//#include <ipconfig.h>   // ipconfig utility definitions
#include <lmaccess.h>   // NetLogonControl2
#include <lmapibuf.h>   // NetApiBufferFree
#include <lmerr.h>      // NERR_ equates.
#include <lmserver.h>   // Server API defines and prototypes
#include <lmuse.h>      // NetUse* API
#include <netlogon.h>   // Netlogon mailslot messages
#include <logonp.h>     // NetpLogon routines


#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <sspi.h>       // Needed by kerberos.h
#include <kerberos.h>   // Kerberos tests
// Porting to Source Depot - smanda #include <names.h>      // NetpIsDomainNameValid
#include <netlib.h>     // NetpCopy...
#include <netlibnt.h>   // NetpNtStatusToApiStatus
#include <ntddbrow.h>   // Interface to browser driver
#include <nbtioctl.h>   // Interface to netbt driver
//#include <nlcommon.h>   // DsGetDcName internal routines.
#include <ntlsa.h>      // LSA APIs
#include <ntdsapi.h>
#include <stdlib.h>     // C library functions (rand, etc)
#define _TSTR_H_INCLUDED    // Lie to prevent collision with ipconfig.h
#include <tstring.h>    // Transitional string routines.
#include <stdio.h>
#include <winldap.h>
#include <brcommon.h>
#include <lmbrowsr.h>
#include <lmremutl.h>
#include <rxserver.h>

#include <iprtrmib.h> // Rajkumar

#include <iptypes.h>
#include <llinfo.h>

#include <assert.h>
#include <ipexport.h>
#include <winsock.h>
#include <icmpapi.h>

#include "ipcfgtest.h"


/*==========================< Includes for IPX Test >=======================*/

#include "errno.h"
#include "tdi.h"
#include "isnkrnl.h"

//
//  include support code for the NetBT ioctls
//

#include <nb30.h>
#include <nbtioctl.h>

/*==========================< Includes for DHCP Test >=====================*/

//#include <dhcp.h>
//#include <dhcpdef.h>

/*==========================< Includes for IPX Test >=======================*/

#include <mprapi.h>


#define BUFF_SIZE 650


/*===========================< NetBT vars >===============================*/

#define NETBIOS_NAME_SIZE 16

#define ALL_IP_TRANSPORTS 0xFFFFFFFF
#define NL_IP_ADDRESS_LENGTH 15
#define NL_MAX_DNS_LENGTH       255

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\netstat.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      netstat.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"

#include <snmp.h>
#include "snmputil.h"
#include "tcpinfo.h"
#include "ipinfo.h"
#include "llinfo.h"


#define MAX_HOST_NAME_SIZE        ( 260)
#define MAX_SERVICE_NAME_SIZE     ( 200)
#define MAX_NUM_DIGITS              30

BOOL NumFlag = FALSE;


LPTSTR FormatNumber(DWORD dwNumber);

VOID DisplayInterface( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                       IfEntry *pEntry,  IfEntry *ListHead ); //used in DoInterface()
HRESULT DoInterface( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );

static DWORD
GenerateHostNameServiceString(
   OUT char *       pszBuffer,
   IN OUT int *     lpcbBufLen,
   IN  BOOL         fNumFlag,
   IN  BOOL         fLocalHost,
   IN  const char * pszProtocol,
   IN  ulong        uAddress,
   IN  ulong        uPort
);
void DisplayTcpConnEntry( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                          TcpConnEntry *pTcp );
void DisplayUdpConnEntry( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                          UdpConnEntry *pUdp );
HRESULT DoConnections( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );

void DisplayIP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                   IpEntry *pEntry); //called by DoIp
HRESULT DoIP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );

void DisplayTCP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                 TcpEntry *pEntry );
HRESULT DoTCP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );


VOID DisplayUDP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                 UdpEntry *pEntry ); // called by DoUDP()
HRESULT DoUDP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults ); 



void DisplayICMP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                  IcmpEntry *pEntry );
HRESULT DoICMP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );



BOOL
NetstatTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//  Description:
//      This test prints all the stats that netstat outputs
// 
//  Arguments:
//      None.
//
//  Author:
//      Rajkumar 08/04/98
//--
{

    HRESULT hr = S_OK;
    ulong Result;
    
    InitializeListHead(&pResults->Netstat.lmsgGlobalOutput);
    InitializeListHead(&pResults->Netstat.lmsgInterfaceOutput);
    InitializeListHead(&pResults->Netstat.lmsgConnectionGlobalOutput);
    InitializeListHead(&pResults->Netstat.lmsgTcpConnectionOutput);
    InitializeListHead(&pResults->Netstat.lmsgUdpConnectionOutput);
    InitializeListHead(&pResults->Netstat.lmsgIpOutput);
    InitializeListHead(&pResults->Netstat.lmsgTcpOutput);
    InitializeListHead(&pResults->Netstat.lmsgUdpOutput);
    InitializeListHead(&pResults->Netstat.lmsgIcmpOutput);

    if (!pParams->fReallyVerbose)
        return hr;

    PrintStatusMessage( pParams, 4, IDS_NETSTAT_STATUS_MSG );
    //
    // initialize the snmp interface
    //
    
    Result = InitSnmp();
  
    if( NO_ERROR != Result )
    {
        //IDS_NETSTAT_14401                  "Initialization of SNMP failed.\n" 
        AddMessageToListId( &pResults->Netstat.lmsgGlobalOutput, Nd_Quiet, IDS_NETSTAT_14401);
        return S_FALSE;
    }
    
    //
    // Show ethernet statistics
    //
    
    hr = DoInterface( pParams, pResults );
    
    //
    // Show connections
    //
    
    if( S_OK == hr )
        hr = DoConnections( pParams, pResults );
    
    
    //
    // Display IP statistics
    //
    
    if( S_OK == hr )
        hr = DoIP( pParams, pResults );
    
    //
    // Display TCP statistics
    //
    
    if( S_OK == hr )
        hr = DoTCP( pParams, pResults );
    
    //
    // Display UDP statistics
    //
    
    if( S_OK == hr )
        hr = DoUDP( pParams, pResults );
    
    //
    // Display ICMP statistics
    //
    
    if( S_OK == hr )
        hr = DoICMP( pParams, pResults );
    
    pResults->Netstat.hrTestResult = hr;
    return hr;
}


//*****************************************************************************
//
// Name:        DisplayInterface
//
// Description: Display interface statistics.
//
// Parameters:  IfEntry *pEntry: pointer to summary data entry.
//              ulong VerboseFlag: boolean indicating desire for verbosity.
//              IfEntry *ListHead: pointer to list of entries.  Used if
//                      verbosity desired.
//
// Returns:     void.
//
// History:
//  01/21/94  JayPh     Created.
//
//*****************************************************************************

VOID DisplayInterface( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                       IfEntry *pEntry,  IfEntry *ListHead )
{
    char     *TmpStr;
    IfEntry  *pIfList;
    char      PhysAddrStr[32];
    
    //IDS_NETSTAT_14402                  "\n\nInterface Statistics\n\n" 
    AddMessageToListId( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, IDS_NETSTAT_14402);

    //IDS_NETSTAT_14403                  "                                Received             Sent\n" 
    AddMessageToListId( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, IDS_NETSTAT_14403);

    //IDS_NETSTAT_14404                  "Unicast Packets             %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
                     IDS_NETSTAT_14404, 
                     pEntry->Info.if_inoctets,
                     pEntry->Info.if_outoctets );


    //IDS_NETSTAT_14405                  "Non-unicast packets         %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
                      IDS_NETSTAT_14405,
                      pEntry->Info.if_innucastpkts,
                      pEntry->Info.if_outnucastpkts );

    //IDS_NETSTAT_14406                  "Discards                    %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
            IDS_NETSTAT_14406,
            pEntry->Info.if_indiscards,
            pEntry->Info.if_outdiscards );

//IDS_NETSTAT_14407                  "Errors                      %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14407,
            pEntry->Info.if_inerrors,
            pEntry->Info.if_outerrors );


//IDS_NETSTAT_14408                  "Unknown protocols           %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14408,
            pEntry->Info.if_inunknownprotos );

    if ( pParams->fReallyVerbose)
    {
        // Also display configuration info

        // Traverse the list of interfaces, displaying config info

        pIfList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                     IfEntry,
                                     ListEntry );

        while ( pIfList != ListHead )
        {
            //IDS_NETSTAT_14409                  "\nInterface index         =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
                    IDS_NETSTAT_14409,
                    pIfList->Info.if_index );

            //IDS_NETSTAT_14410                  "Description             =  %s\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
                    IDS_NETSTAT_14410,
                    pIfList->Info.if_descr );

            //IDS_NETSTAT_14411                  "Type                    =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14411,
                    pIfList->Info.if_type );

            //IDS_NETSTAT_14412                  "MTU                     =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14412,
                    pIfList->Info.if_mtu );

            //IDS_NETSTAT_14413                  "Speed                   =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14413,
                    pIfList->Info.if_speed );


            sprintf( PhysAddrStr,
                     "%02x-%02X-%02X-%02X-%02X-%02X",
                     pIfList->Info.if_physaddr[0],
                     pIfList->Info.if_physaddr[1],
                     pIfList->Info.if_physaddr[2],
                     pIfList->Info.if_physaddr[3],
                     pIfList->Info.if_physaddr[4],
                     pIfList->Info.if_physaddr[5] );

            //IDS_NETSTAT_14414                  "Physical Address        =  %s\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14414,
                    PhysAddrStr );

            //IDS_NETSTAT_14415                  "Administrative Status   =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14415,
                    pIfList->Info.if_adminstatus );

            //IDS_NETSTAT_14416                  "Operational Status      =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14416,
                    pIfList->Info.if_operstatus );

            //IDS_NETSTAT_14417                  "Last Changed            =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14417,
                    pIfList->Info.if_lastchange );

            //IDS_NETSTAT_14418                  "Output Queue Length     =  %u\n\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14418,
                    pIfList->Info.if_outqlen );

            // Get pointer to next entry in list

            pIfList = CONTAINING_RECORD( pIfList->ListEntry.Flink,
                                         IfEntry,
                                         ListEntry );
        }
    }
}


HRESULT DoInterface( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults )
//++
// Description:
//   Displays statistics of current connections
//-- 
{

    IfEntry            *ListHead;
    IfEntry            *pIfList;
    IfEntry             SumOfEntries;
    ulong              Result;

    // Get the statistics

    ListHead = (IfEntry *)GetTable( TYPE_IF, &Result );

    if ( ListHead == NULL )
    {
        //IDS_NETSTAT_14419                  "Getting interface statistics table failed.\n" 
        AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_Quiet, IDS_NETSTAT_14419);
        return S_FALSE;
    }

    // Clear the summation structure

    ZeroMemory( &SumOfEntries, sizeof( IfEntry ) );

    // Traverse the list of interfaces, summing the different fields

    pIfList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                 IfEntry,
                                 ListEntry );

    while (pIfList != ListHead)
    {
        SumOfEntries.Info.if_inoctets += pIfList->Info.if_inoctets;
        SumOfEntries.Info.if_inucastpkts += pIfList->Info.if_inucastpkts;
        SumOfEntries.Info.if_innucastpkts += pIfList->Info.if_innucastpkts;
        SumOfEntries.Info.if_indiscards += pIfList->Info.if_indiscards;
        SumOfEntries.Info.if_inerrors += pIfList->Info.if_inerrors;
        SumOfEntries.Info.if_inunknownprotos +=
                                              pIfList->Info.if_inunknownprotos;
        SumOfEntries.Info.if_outoctets += pIfList->Info.if_outoctets;
        SumOfEntries.Info.if_outucastpkts += pIfList->Info.if_outucastpkts;
        SumOfEntries.Info.if_outnucastpkts += pIfList->Info.if_outnucastpkts;
        SumOfEntries.Info.if_outdiscards += pIfList->Info.if_outdiscards;
        SumOfEntries.Info.if_outerrors += pIfList->Info.if_outerrors;

        // Get pointer to next entry in list

        pIfList = CONTAINING_RECORD( pIfList->ListEntry.Flink,
                                     IfEntry,
                                     ListEntry );
    }

    DisplayInterface( pParams, pResults, &SumOfEntries, ListHead );

    // All done with list, free it.

    FreeTable( (GenericTable *)ListHead );

    return S_OK;
}





//*****************************************************************************
//
// Name:        DisplayTcpConnEntry
//
// Description: Display information about 1 tcp connection.
//
// Parameters:  TcpConnEntry *pTcp: pointer to a tcp connection structure.
//
// Returns:     void.
//
// History:
//
//*****************************************************************************

void DisplayTcpConnEntry( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                          TcpConnEntry *pTcp )
{
    char            LocalStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    char            RemoteStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    DWORD dwErr;
    int BufLen;
    int FlagVerbose;

    if( pTcp->Info.tct_state !=  TCP_CONN_LISTEN )
        FlagVerbose = Nd_Verbose;
    else
        FlagVerbose = Nd_ReallyVerbose;

    //IDS_NETSTAT_14420                  "TCP" 
    AddMessageToList( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                        IDS_NETSTAT_14420);

    BufLen = sizeof( LocalStr);
    dwErr = GenerateHostNameServiceString( LocalStr,
                                           &BufLen,
                                          NumFlag != 0, TRUE,
                                          "tcp",
                                          pTcp->Info.tct_localaddr,
                                          pTcp->Info.tct_localport);
    ASSERT( dwErr == NO_ERROR);

    BufLen = sizeof( RemoteStr);
    dwErr = GenerateHostNameServiceString( RemoteStr,
                                       &BufLen,
                                       NumFlag != 0, FALSE,
                                       "tcp",
                                       pTcp->Info.tct_remoteaddr,
                                       pTcp->Info.tct_remoteport );
    ASSERT( dwErr == NO_ERROR);


    //IDS_NETSTAT_14421                  "   %-20s  %-40s" 
    AddMessageToList( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                      IDS_NETSTAT_14421,LocalStr,RemoteStr);

    switch ( pTcp->Info.tct_state )
    {
    case TCP_CONN_CLOSED:
        //IDS_NETSTAT_14422                  "  CLOSED\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14422);
        break;

    case TCP_CONN_LISTEN:

        // Tcpip generates dummy sequential remote ports for
        // listening connections to avoid getting stuck in snmp.
        // MohsinA, 12-Feb-97.

        pTcp->Info.tct_remoteport = 0;

        //IDS_NETSTAT_14423                  "  LISTENING\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                          IDS_NETSTAT_14423);
        break;

    case TCP_CONN_SYN_SENT:
        //IDS_NETSTAT_14424                  "  SYN_SENT\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14424);
        break;

    case TCP_CONN_SYN_RCVD:
        //IDS_NETSTAT_14425                  "  SYN_RECEIVED\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14425); 
        break;

    case TCP_CONN_ESTAB:
        //IDS_NETSTAT_14426                  "  ESTABLISHED\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14426);
        break;

    case TCP_CONN_FIN_WAIT1:
        //IDS_NETSTAT_14427                  "  FIN_WAIT_1\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14427);
        break;

    case TCP_CONN_FIN_WAIT2:
        //IDS_NETSTAT_14428                  "  FIN_WAIT_2\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14428); 
        break;

    case TCP_CONN_CLOSE_WAIT:
        //IDS_NETSTAT_14429                  "  CLOSE_WAIT\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14429);
        break;

    case TCP_CONN_CLOSING:
        //IDS_NETSTAT_14430                  "  CLOSING\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14430);
        break;

    case TCP_CONN_LAST_ACK:
        //IDS_NETSTAT_14431                  "  LAST_ACK\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                          IDS_NETSTAT_14431);
        break;

    case TCP_CONN_TIME_WAIT:
        //IDS_NETSTAT_14432                  "  TIME_WAIT\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14432);
        break;

    default:
        DEBUG_PRINT(("DisplayTcpConnEntry: State=%d?\n ",
                     pTcp->Info.tct_state ));
    }


}


//*****************************************************************************
//
// Name:        DisplayUdpConnEntry
//
// Description: Display information on 1 udp connection
//
// Parameters:  UdpConnEntry *pUdp: pointer to udp connection structure.
//
// Returns:     void.
//
//
//*****************************************************************************

void DisplayUdpConnEntry( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                          UdpConnEntry *pUdp )
{
    char            LocalStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    int             BufLen;
    DWORD           dwErr;

    
    //IDS_NETSTAT_14433                  "UDP" 
    AddMessageToListId( &pResults->Netstat.lmsgUdpConnectionOutput, Nd_ReallyVerbose, IDS_NETSTAT_14433);

    BufLen = sizeof( LocalStr);
    dwErr = GenerateHostNameServiceString( LocalStr,
                                           &BufLen,
                                          NumFlag != 0, TRUE,
                                          "udp",
                                          pUdp->Info.ue_localaddr,
                                          pUdp->Info.ue_localport);
    ASSERT( dwErr == NO_ERROR);



    //IDS_NETSTAT_14434                  "  %-20s  %-40s\n" 
    AddMessageToList( &pResults->Netstat.lmsgUdpConnectionOutput, Nd_ReallyVerbose, IDS_NETSTAT_14434,LocalStr, _T("*:*") );
}


static DWORD
GenerateHostNameServiceString(
   OUT char *       pszBuffer,
   IN OUT int *     lpcbBufLen,
   IN  BOOL         fNumFlag,
   IN  BOOL         fLocalHost,
   IN  const char * pszProtocol,
   IN  ulong        uAddress,
   IN  ulong        uPort
)
/*++
  Description:
     Generates the <hostname>:<service-string> from the address and port
     information supplied. The result is stored in the pszBuffer passed in.
     If fLocalHost == TRUE, then the cached local host name is used to
     improve performance.

  Arguments:
    pszBuffer     Buffer to store the resulting string.
    lpcbBufLen    pointer to integer containing the count of bytes in Buffer
                   and on return contains the number of bytes written.
                   If the buffer is insufficient, then the required bytes is
                   stored here.
    fNumFlag      generates the output using numbers for host and port number.
    fLocalHost    indicates if we want the service string for local host or
                   remote host. Also for local host, this function generates
                   the local host name without FQDN.
    pszProtocol   specifies the protocol used for the service.
    uAddress      unisgned long address of the service.
    uPort         unsinged long port number.

  Returns:
    Win32 error codes. NO_ERROR on success.

  History:
      Added this function to avoid FQDNs  for local name + abstract the common
       code used multiple times in old code.
      Also this function provides local host name caching.
--*/
{
    char            LocalBuffer[MAX_HOST_NAME_SIZE];    // to hold dummy output
    char            LocalServiceEntry[MAX_SERVICE_NAME_SIZE];
    int             BufferLen;
    char  *         pszHostName = NULL;              // init a pointer.
    char  *         pszServiceName = NULL;
    DWORD           dwError = NO_ERROR;
    struct hostent * pHostEnt;
    struct servent * pServEnt;
    uchar *          pTmp;

    // for caching local host name
    static char  s_LocalHostName[MAX_HOST_NAME_SIZE];
    static  BOOL s_fLocalHostName = FALSE;


    if ( pszBuffer == NULL) {
        return ( ERROR_INSUFFICIENT_BUFFER);
    }

    *pszBuffer = '\0';         // initialize to null string

    if ( !fNumFlag) {
        if ( fLocalHost) {
            if ( s_fLocalHostName) {
                pszHostName = s_LocalHostName;   // pull from the cache
            } else {
                int Result = gethostname( s_LocalHostName,
                                         sizeof( s_LocalHostName));
                if ( Result == 0) {

                    char * pszFirstDot;

                    //
                    // Cache the copy of local host name now.
                    // Limit the host name to first part of host name.
                    // NO FQDN
                    //
                    s_fLocalHostName = TRUE;

                    pszFirstDot = strchr( s_LocalHostName, '.');
                    if ( pszFirstDot != NULL) {

                        *pszFirstDot = '\0';  // terminate string
                    }

                    pszHostName = s_LocalHostName;

                }
            } // if ( s_fLocalhost)


        } else {
            // Remote Host Name.
            pHostEnt = gethostbyaddr( (uchar *) &uAddress,
                                     4,       // IP address is 4 bytes,
                                     PF_INET);

            pszHostName = ( pHostEnt != NULL) ? pHostEnt->h_name: NULL;
        }


        pServEnt = getservbyport( htons( ( u_short) uPort), pszProtocol);
        pszServiceName = ( pServEnt != NULL) ? pServEnt->s_name : NULL;

    }  else {  // !fNumFlag

        pszServiceName = NULL;
        pszHostName = NULL;
    }


    //
    // Format the data for output.
    //

    if ( pszHostName == NULL) {

        //
        //  Print the IP address itself
        //
        uchar * pTmp = ( uchar *) & uAddress;

        pszHostName = LocalBuffer;

        sprintf(  pszHostName, "%u.%u.%u.%u",
                pTmp[0],
                pTmp[1],
                pTmp[2],
                pTmp[3]);
    }


    //  Now pszHostName has the name of the host.

    if ( pszServiceName == NULL) {

        pszServiceName = LocalServiceEntry;
        //IDS_NETSTAT_14436                  "%u" 
        sprintf(  pszServiceName, "%u", uPort);
    }

    // Now pszServiceName has the service name/portnumber

    BufferLen = strlen( pszHostName) + strlen( pszServiceName) + 2;
    // 2 bytes extra for ':' and null-character.

    if ( *lpcbBufLen < BufferLen ) {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    } else {

        sprintf(  pszBuffer, "%s:%s", pszHostName, pszServiceName);
    }

    *lpcbBufLen = BufferLen;

    return ( dwError);

} // GenerateHostNameServiceString()

HRESULT DoConnections( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults)
//++
// Description:
//   Displays ethernet statistics
// 
//-- 
{

  HRESULT       hr = S_OK;
  TcpConnEntry  *pTcpHead;
  UdpConnEntry  *pUdpHead;
  TcpConnEntry  *pTcp;
  UdpConnEntry  *pUdp;
  ulong          Result;


  //IDS_NETSTAT_14438                  "\n\nActive Connections\n" 
  AddMessageToListId( &pResults->Netstat.lmsgConnectionGlobalOutput, Nd_Verbose, IDS_NETSTAT_14438);
//IDS_NETSTAT_14439                  "\nProto Local Address         Foreign Address                           State\n" 
  AddMessageToListId( &pResults->Netstat.lmsgConnectionGlobalOutput, Nd_Verbose, IDS_NETSTAT_14439);

  // Get TCP connection table

  pTcpHead = (TcpConnEntry *)GetTable( TYPE_TCPCONN, &Result );
  if ( pTcpHead == NULL )
  {
        //IDS_NETSTAT_14440                  "Getting TCP connections failed!\n" 
        AddMessageToList( &pResults->Netstat.lmsgTcpConnectionOutput, Nd_Quiet,IDS_NETSTAT_14440);
        hr = S_FALSE;
  }
  else
  {
      // Get pointer to first entry in list
      pTcp = CONTAINING_RECORD( pTcpHead->ListEntry.Flink,
                            TcpConnEntry,
                            ListEntry );

      while (pTcp != pTcpHead)
      {
          if ( ( pTcp->Info.tct_state !=  TCP_CONN_LISTEN ) ||
              (( pTcp->Info.tct_state ==  TCP_CONN_LISTEN )) )
          {
            // Display the Tcp connection info
              DisplayTcpConnEntry( pParams, pResults, pTcp );
          }

          // Get the next entry in the table
           pTcp = CONTAINING_RECORD( pTcp->ListEntry.Flink,
                                TcpConnEntry,
                                ListEntry );
       }

       FreeTable( (GenericTable *)pTcpHead );
  }

  // Get UDP connection table

  pUdpHead = (UdpConnEntry *)GetTable( TYPE_UDPCONN, &Result );
  if ( pUdpHead == NULL )
  {
      //IDS_NETSTAT_14441                  "Getting UDP connections failed!\n" 
      AddMessageToList( &pResults->Netstat.lmsgUdpConnectionOutput, Nd_Quiet, IDS_NETSTAT_14441);
      hr = S_FALSE;
  }
  else
  {
    // Get pointer to first entry in list

    pUdp = CONTAINING_RECORD( pUdpHead->ListEntry.Flink,
                                UdpConnEntry,
                                ListEntry );

    while (pUdp != pUdpHead)
    {
       // Display the Udp connection info

       DisplayUdpConnEntry( pParams, pResults, pUdp);

       // Get the next entry in the table

       pUdp = CONTAINING_RECORD( pUdp->ListEntry.Flink,
                                 UdpConnEntry,
                                 ListEntry );
     }

     FreeTable( (GenericTable *)pUdpHead );
  }

  return hr;
}


void DisplayIP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                IpEntry *pEntry)
{
    //IDS_NETSTAT_14442                  "\n\nIP  Statistics\n\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose, 
            IDS_NETSTAT_14442);

    //IDS_NETSTAT_14443                  "Packets Received              =   %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose, 
            IDS_NETSTAT_14443, FormatNumber( pEntry->Info.ipsi_inreceives ));

    //IDS_NETSTAT_14444                  "Received Header Errors        =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14444,
            FormatNumber( pEntry->Info.ipsi_inhdrerrors ) );

    //IDS_NETSTAT_14445                  "Received Address Errors       =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14445,
            FormatNumber( pEntry->Info.ipsi_inaddrerrors ) );

    //IDS_NETSTAT_14446                  "Datagrams Forwarded           =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14446,
            FormatNumber( pEntry->Info.ipsi_forwdatagrams ) );

    //IDS_NETSTAT_14447                  "Unknown Protocols Received    =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14447,
            FormatNumber( pEntry->Info.ipsi_inunknownprotos ) );

    //IDS_NETSTAT_14448                  "Received Packets Discarded    =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14448,
            FormatNumber( pEntry->Info.ipsi_indiscards ) );

    //IDS_NETSTAT_14449                  "Received Packets Delivered    =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14449,
            FormatNumber( pEntry->Info.ipsi_indelivers ) );

    //IDS_NETSTAT_14450                  "Output Requests               =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14450,
            FormatNumber( pEntry->Info.ipsi_outrequests ) );

    //IDS_NETSTAT_14451                  "Routing Discards              =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14451,
            FormatNumber( pEntry->Info.ipsi_routingdiscards ) );

    //IDS_NETSTAT_14452                  "Discarded Output Packets      =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14452,
            FormatNumber( pEntry->Info.ipsi_outdiscards ) );

    //IDS_NETSTAT_14453                  "Output Packet No Route        =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14453,
            FormatNumber( pEntry->Info.ipsi_outnoroutes ) );

    //IDS_NETSTAT_14454                  "Reassembly  Required          =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14454,
            FormatNumber( pEntry->Info.ipsi_reasmreqds ) );


    //IDS_NETSTAT_14455                  "Reassembly Successful         =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14455,
            FormatNumber( pEntry->Info.ipsi_reasmoks ) );

    //IDS_NETSTAT_14456                  "Reassembly Failures           =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14456,
            FormatNumber( pEntry->Info.ipsi_reasmfails ));

    //IDS_NETSTAT_14457                  "Datagrams successfully fragmented  =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14457,
            FormatNumber( pEntry->Info.ipsi_fragoks ) );

    //IDS_NETSTAT_14458                  "Datagrams failing fragmentation    =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14458,
            FormatNumber( pEntry->Info.ipsi_fragfails ) );

    //IDS_NETSTAT_14459                  "Fragments Created                  =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14459,
            FormatNumber( pEntry->Info.ipsi_fragcreates ) );

    //IDS_NETSTAT_14460                  "Forwarding                        =    %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14460,
                FormatNumber( pEntry->Info.ipsi_forwarding ) );

    //IDS_NETSTAT_14461                  "Default TTL                       =    %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14461,
                FormatNumber( pEntry->Info.ipsi_defaultttl ));

    //IDS_NETSTAT_14462                  "Reassembly  timeout               =    %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14462,
                FormatNumber( pEntry->Info.ipsi_reasmtimeout ) );
}


HRESULT DoIP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults )
{
 IpEntry            *ListHead;
 IpEntry            *pIpList;
 ulong               Result;

 // Get the statistics

 ListHead = (IpEntry *)GetTable( TYPE_IP, &Result );
 if ( ListHead == NULL )
 {
     //IDS_NETSTAT_14463                  "Getting IP statistics failed.\n" 
     AddMessageToListId( &pResults->Netstat.lmsgIpOutput, Nd_Quiet, IDS_NETSTAT_14463);
     return S_FALSE;
 }

 // Traverse the list of interfaces, summing the different fields

 pIpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                              IpEntry,
                              ListEntry );

 DisplayIP( pParams, pResults, pIpList );

 // All done with list, free it.

 FreeTable( (GenericTable *)ListHead );

 return S_OK;
}


HRESULT DoTCP(NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults)
{
   TcpEntry           *ListHead;
   TcpEntry           *pTcpList;
   ulong               Result;

   // Get the statistics

   ListHead = (TcpEntry *)GetTable( TYPE_TCP, &Result );
   if ( ListHead == NULL )
   {
        //IDS_NETSTAT_14464                  "Getting TCP statistics failed.\n" 
       AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_Quiet, IDS_NETSTAT_14464);
       return S_FALSE;
   }

   // Traverse the list, summing the different fields

   pTcpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                 TcpEntry,
                                 ListEntry );

   DisplayTCP( pParams, pResults, pTcpList );

   // All done with list, free it.

   FreeTable( (GenericTable *)ListHead );

   return S_OK;
}




 
void DisplayTCP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                 TcpEntry *pEntry)
{
    //IDS_NETSTAT_14465                  "\n\nTCP Statistics \n\n" 
    AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose, IDS_NETSTAT_14465);

//    FormatNumber( pEntry->Info.ts_activeopens, szNumberBuffer, sizeof(szNumberBuffer)/sizeof(TCHAR), FALSE);
    
    //IDS_NETSTAT_14466                  "Active Opens               =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14466,
            FormatNumber( pEntry->Info.ts_activeopens ) );

    //IDS_NETSTAT_14467                  "Passive Opens              =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14467,
            FormatNumber( pEntry->Info.ts_passiveopens ) );

    //IDS_NETSTAT_14468                  "Failed Connection Attempts =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14468,
            FormatNumber( pEntry->Info.ts_attemptfails ) );

    //IDS_NETSTAT_14469                  "Reset Connections          =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14469,
            FormatNumber( pEntry->Info.ts_estabresets ) );

    //IDS_NETSTAT_14470                  "Current Connections        =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14470,
            FormatNumber( pEntry->Info.ts_currestab ) );

    
    //IDS_NETSTAT_14471                  "Received Segments          =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14471,
            FormatNumber( pEntry->Info.ts_insegs ) );

    
    //IDS_NETSTAT_14472                  "Segment Sent               =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14472,
            FormatNumber( pEntry->Info.ts_outsegs ) );

    
    //IDS_NETSTAT_14473                  "Segment Retransmitted      =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14473,
            FormatNumber( pEntry->Info.ts_retranssegs ) );


    
    //IDS_NETSTAT_14474                  "Retransmission Timeout Algorithm  =   " 
    AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14474);

    switch ( pEntry->Info.ts_rtoalgorithm )
    {
        case 1:
            //IDS_NETSTAT_14475                  "other\n" 
            AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14475);
            break;

        case 2:
            //IDS_NETSTAT_14476                  "constant\n" 
            AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14476);
            break;

        case 3:
            //IDS_NETSTAT_14477                  "rsre\n" 
            AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14477);
            break;

        case 4:
            //IDS_NETSTAT_14478                  "vanj\n " 
            AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14478);
            break;

        default:
            //IDS_NETSTAT_14479                  "unknown\n " 
            AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14479,
                    pEntry->Info.ts_rtoalgorithm );
            break;

    }

    
    //IDS_NETSTAT_14480                  "Minimum Retransmission Timeout  = %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14480,
            FormatNumber( pEntry->Info.ts_rtomin ) );

    //IDS_NETSTAT_14481                  "Maximum Retransmission Timeout  = %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14481,
                FormatNumber( pEntry->Info.ts_rtomax ) );

    //IDS_NETSTAT_14482                  "Maximum Number of Connections   = %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14482,
                FormatNumber( pEntry->Info.ts_maxconn ) );
}


HRESULT DoUDP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults )
{

 UdpEntry           *ListHead;
 UdpEntry           *pUdpList;
 ulong               Result;

 // Get the statistics

 ListHead = (UdpEntry *)GetTable( TYPE_UDP, &Result );
 if ( ListHead == NULL )
 {
    //IDS_NETSTAT_14483                  "Getting UDP statistics failed.\n" 
     AddMessageToListId( &pResults->Netstat.lmsgUdpOutput, Nd_Quiet, IDS_NETSTAT_14483 );
     return S_FALSE;
 }

 // Traverse the list of interfaces, summing the different fields

 pUdpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                               UdpEntry,
                               ListEntry );

 DisplayUDP( pParams, pResults, pUdpList );

 // All done with list, free it.

 FreeTable( (GenericTable *)ListHead );

 return S_OK;
}

VOID DisplayUDP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                 UdpEntry *pEntry) 
{


//IDS_NETSTAT_14484                  "\n\nUDP Statistics\n\n" 
  AddMessageToListId( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose, IDS_NETSTAT_14484);

//IDS_NETSTAT_14485                  "Datagrams Received    =   %s\n" 
  AddMessageToList( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose, 
          IDS_NETSTAT_14485, FormatNumber( pEntry->Info.us_indatagrams ) );

//IDS_NETSTAT_14486                  "No Ports              =   %s\n" 
  AddMessageToList( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose,
          IDS_NETSTAT_14486, FormatNumber(pEntry->Info.us_noports) );

//IDS_NETSTAT_14487                  "Receive Errors        =   %s\n" 
  AddMessageToList( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose,
          IDS_NETSTAT_14487, FormatNumber(pEntry->Info.us_inerrors) );

//IDS_NETSTAT_14488                  "Datagrams Sent        =   %s\n" 
  AddMessageToList( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose,
          IDS_NETSTAT_14488, FormatNumber(pEntry->Info.us_outdatagrams) );
}


HRESULT DoICMP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults )
{

 IcmpEntry          *ListHead;
 IcmpEntry          *pIcmpList;
 ulong              Result;

 // Get the statistics

 ListHead = (IcmpEntry *)GetTable( TYPE_ICMP, &Result );

 if ( ListHead == NULL )
   {
    //IDS_NETSTAT_14489                  "Getting ICMP statistics failed.\n" 
     AddMessageToListId( &pResults->Netstat.lmsgIcmpOutput, Nd_Quiet,
                        IDS_NETSTAT_14489);
     return S_FALSE;
   }

 // Traverse the list of interfaces, summing the different fields

 pIcmpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                               IcmpEntry,
                               ListEntry );

 DisplayICMP( pParams, pResults, pIcmpList );

 // All done with list, free it.

 FreeTable( (GenericTable *)ListHead );

 return S_OK;
}

void DisplayICMP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                  IcmpEntry *pEntry )
{

    //IDS_NETSTAT_14490                  "\n\nICMP Statistics \n\n" 
   AddMessageToListId( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose, 
            IDS_NETSTAT_14490);
    //IDS_NETSTAT_14491                  "\t\t\t  Received              Sent\n" 
   AddMessageToListId( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14491);


    //IDS_NETSTAT_14492                  "Messages                 %7s          %7s\n" 
   AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14492,
            FormatNumber(pEntry->InInfo.icmps_msgs),
            FormatNumber(pEntry->OutInfo.icmps_msgs) );

    //IDS_NETSTAT_14493                  "Errors                   %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14493,
            FormatNumber(pEntry->InInfo.icmps_errors),
            FormatNumber(pEntry->OutInfo.icmps_errors) );

    //IDS_NETSTAT_14494                  "Destination  Unreachable %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14494,
            FormatNumber(pEntry->InInfo.icmps_destunreachs),
            FormatNumber(pEntry->OutInfo.icmps_destunreachs) );

    //IDS_NETSTAT_14495                  "Time    Exceeded         %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14495,
            FormatNumber(pEntry->InInfo.icmps_timeexcds),
            FormatNumber(pEntry->OutInfo.icmps_timeexcds) );

    //IDS_NETSTAT_14496                  "Parameter Problems       %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14496,
            FormatNumber(pEntry->InInfo.icmps_parmprobs),
            FormatNumber(pEntry->OutInfo.icmps_parmprobs) );

    //IDS_NETSTAT_14497                  "Source Quenchs           %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14497,
            FormatNumber(pEntry->InInfo.icmps_srcquenchs),
            FormatNumber(pEntry->OutInfo.icmps_srcquenchs) );

    //IDS_NETSTAT_14498                  "Redirects                %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14498,
            FormatNumber(pEntry->InInfo.icmps_redirects),
            FormatNumber(pEntry->OutInfo.icmps_redirects) );

    
    //IDS_NETSTAT_14499                  "Echos                    %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14499,
            FormatNumber(pEntry->InInfo.icmps_echos),
            FormatNumber(pEntry->OutInfo.icmps_echos) );

    //IDS_NETSTAT_14500                  "Echo Replies             %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14500,
            FormatNumber(pEntry->InInfo.icmps_echoreps),
            FormatNumber(pEntry->OutInfo.icmps_echoreps) );

    //IDS_NETSTAT_14501                  "Timestamps               %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14501,
            FormatNumber(pEntry->InInfo.icmps_timestamps),
            FormatNumber(pEntry->OutInfo.icmps_timestamps) );

    //IDS_NETSTAT_14502                  "Timestamp Replies        %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14502,
            FormatNumber(pEntry->InInfo.icmps_timestampreps),
            FormatNumber(pEntry->OutInfo.icmps_timestampreps) );

    //IDS_NETSTAT_14503                  "Address Masks            %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14503,
            FormatNumber(pEntry->InInfo.icmps_addrmasks),
            FormatNumber(pEntry->OutInfo.icmps_addrmasks) );

    //IDS_NETSTAT_14504                  "Address Mask Replies     %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14504,
            FormatNumber(pEntry->InInfo.icmps_addrmaskreps),
            FormatNumber(pEntry->OutInfo.icmps_addrmaskreps) );

}


//----------------------------------------------------------------------------
// Function:    FormatNumber
//
// This function takes an integer and formats a string with the value
// represented by the number, grouping digits by powers of one-thousand
//----------------------------------------------------------------------------

LPTSTR FormatNumber(DWORD dwNumber)
{
//  assert(cchBuffer > 14);
    
    static TCHAR s_szBuffer[MAX_NUM_DIGITS];
    BOOL fSigned = TRUE;
    static TCHAR szNegativeSign[4] = TEXT("");
    static TCHAR szThousandsSeparator[4] = TEXT("");

    DWORD i, dwLength;
    TCHAR szDigits[12], pszTemp[20];
        TCHAR* pszsrc, *pszdst;



    //
    // Retrieve the thousands-separator for the user's locale
    //

    if (szThousandsSeparator[0] == TEXT('\0'))
    {
        GetLocaleInfo(
            LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szThousandsSeparator, 4
            );
    }


    //
    // If we are formatting a signed value, see if the value is negative
    //

    if (fSigned)
    {
        if ((INT)dwNumber >= 0)
            fSigned = FALSE;
        else
        {
            //
            // The value is negative; retrieve the locale's negative-sign
            //

            if (szNegativeSign[0] == TEXT('\0')) {

                GetLocaleInfo(
                    LOCALE_USER_DEFAULT, LOCALE_SNEGATIVESIGN, szNegativeSign, 4
                    );
            }

            dwNumber = abs((INT)dwNumber);
        }
    }


    //
    // Convert the number to a string without thousands-separators
    //

    _ltot(dwNumber, szDigits, 10);
    //padultoa(dwNumber, szDigits, 0);

    dwLength = lstrlen(szDigits);


    //
    // If the length of the string without separators is n,
    // then the length of the string with separators is n + (n - 1) / 3
    //

    i = dwLength;
    dwLength += (dwLength - 1) / 3;


    //
    // Write the number to the buffer in reverse
    //

    pszsrc = szDigits + i - 1; pszdst = pszTemp + dwLength;

    *pszdst-- = TEXT('\0');

    while (TRUE) {
        if (i--) { *pszdst-- = *pszsrc--; } else { break; }
        if (i--) { *pszdst-- = *pszsrc--; } else { break; }
        if (i--) { *pszdst-- = *pszsrc--; } else { break; }
        if (i) { *pszdst-- = *szThousandsSeparator; } else { break; }
    }

    s_szBuffer[0] = 0;
    
    if (fSigned)
        lstrcat(s_szBuffer, szNegativeSign);

    lstrcat(s_szBuffer, pszTemp);
    return s_szBuffer;
}


void NetstatGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (!pParams->fReallyVerbose)
        return;
    
    if (pParams->fVerbose || !FHrOK(pResults->Netstat.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_NETSTAT_LONG,
							 IDS_NETSTAT_SHORT,
                             TRUE,
                             pResults->Netstat.hrTestResult,
                             0);
    }

    PrintMessageList(pParams, &pResults->Netstat.lmsgGlobalOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgInterfaceOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgConnectionGlobalOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgTcpConnectionOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgUdpConnectionOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgIpOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgTcpOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgUdpOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgIcmpOutput);
}


void NetstatPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    if (!pParams->fReallyVerbose)
        return;
    
}


void NetstatCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Netstat.lmsgGlobalOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgInterfaceOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgConnectionGlobalOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgTcpConnectionOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgUdpConnectionOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgIpOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgTcpOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgUdpOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgIcmpOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\netdiag.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       netdiag.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_NETDIAG
#define HEADER_NETDIAG


//////////////////////////////////////////////////////////////////////////////
//
// Constants particular to the current NT development environment
//
//////////////////////////////////////////////////////////////////////////////

//
// Developers responsible for tested portions of NT
//

#define NET_GURU     "[Contact NSun]"
#define DHCP_GURU    "[Contact ThiruB/RameshV]"
#define TCPIP_GURU   "[Contact PradeepB]"
#define NETBT_GURU   "[Contact MAlam]"
#define WINSOCK_GURU "[Contact KarolyS]"
#define REDIR_GURU   "[Contact SethuR]"
#define BOWSER_GURU  "[Contact CliffV]"
#define DNS_GURU     "[Contact DnsDev]"
#define SAM_GURU     "[Contact MurliS]"
#define LSA_GURU     "[Contact MacM]"
#define DSGETDC_GURU "[Contact CliffV]"
#define NETLOGON_GURU "[Contact CliffV]"
#define KERBEROS_GURU "[Contact ChandanS]"
#define NTLM_GURU     "[Contact ChandanS]"
#define LDAP_GURU     "[Contact AnoopA]"

//////////////////////////////////////////////////////////////////////////////
//
// Constants particular to the current version of NT.
//
//////////////////////////////////////////////////////////////////////////////

#define NETBT_DEVICE_PREFIX L"\\device\\Netbt_tcpip_{"

//
// Complain about pre-IDW builds
//
#define NTBUILD_IDW 1716
#define NTBUILD_DYNAMIC_DNS 1716
#define NTBUILD_BOWSER 1716
#define NTBUILD_DNSSERVERLIST 1728


//
// New functions for displaying routing table - Rajkumar
//

#define WILD_CARD (ULONG)(-1)
#define ROUTE_DATA_STRING_SIZE 300
#define NTOA(STR,ADDR)                                         \
             strncpy( STR,                                     \
                      inet_ntoa(*(struct in_addr*)(&(ADDR))),  \
                      sizeof(STR)-1 )

#ifdef _UNICODE
#define INET_ADDR(_sz)	inet_addrW(_sz)
#else
#define INET_ADDR(_sz)	inet_addrA(_swz)
#endif

ULONG inet_addrW(LPCWSTR pswz);
#define inet_addrA(_psz)	inet_addr(_psz)



#define MAX_METRIC 9999
#define ROUTE_SEPARATOR ','

#define MAX_CONTACT_STRING 256

// Some winsock defines


//////////////////////////////////////////////////////////////////////////////
//
// Globals
//
//////////////////////////////////////////////////////////////////////////////

//extern BOOL IpConfigCalled;
//extern BOOL ProblemBased;
extern int  ProblemNumber;

//
// This has been made global so that we dump the information in WinsockTest - Rajkumar
//

//extern WSADATA wsaData;

//extern PFIXED_INFO GlobalIpconfigFixedInfo;
//extern PADAPTER_INFO GlobalIpconfigAdapterInfo;
//extern PIP_ADAPTER_INFO IpGlobalIpconfigAdapterInfo;

//extern BOOLEAN GlobalDhcpEnabled;

//
// Structure describing a single Netbt Transport
//


//extern LIST_ENTRY GlobalNetbtTransports;


//extern LIST_ENTRY GlobalTestedDomains;



//
// Globals defining the command line arguments.
//

//extern BOOL Verbose;
extern BOOL ReallyVerbose;
//extern BOOL DebugVerbose;
//extern BOOL GlobalFixProblems;
//extern BOOL GlobalDcAccountEnum;

extern PTESTED_DOMAIN GlobalQueriedDomain;

//
// Describe the domain this machine is a member of
//

//extern int GlobalNtBuildNumber;
//extern PDSROLE_PRIMARY_DOMAIN_INFO_BASIC GlobalDomainInfo;
//extern PTESTED_DOMAIN GlobalMemberDomain;

//
// Who we're currently logged on as
//

//extern PUNICODE_STRING GlobalLogonUser;
//extern PUNICODE_STRING GlobalLogonDomainName;
//extern PTESTED_DOMAIN GlobalLogonDomain;
//extern BOOLEAN GlobalLogonWithCachedCredentials;

//
// A Zero GUID for comparison
//

extern GUID NlDcZeroGuid;

//
// State determined by previous tests
//

//extern BOOL GlobalNetlogonIsRunning;   // Netlogon is running on this machine
//extern BOOL GlobalKerberosIsWorking;   // Kerberos is working

//
// Netbios name of this machine
//

//extern WCHAR GlobalNetbiosComputerName[MAX_COMPUTERNAME_LENGTH+1];
//extern CHAR GlobalDnsHostName[DNS_MAX_NAME_LENGTH+1];
//extern LPSTR GlobalDnsDomainName;

// Commented out to port to Source Depot - smanda
#ifdef SLM_TREE
extern DSGETDCNAMEW NettestDsGetDcNameW;
#else
extern DSGETDCNAMEW DsGetDcNameW;
#endif

void PrintMessage(NETDIAG_PARAMS *pParams, UINT uMessageID, ...);
void PrintMessageSz(NETDIAG_PARAMS *pParams, LPCTSTR pszMessage);

int match( const char * p, const char * s );

//only used in Kerberos test so far
VOID sPrintTime(LPSTR str, LARGE_INTEGER ConvertTime);

DWORD LoadContact(LPCTSTR pszTestName, LPTSTR pszContactInfo, DWORD cChSize);

NET_API_STATUS IsServiceStarted(IN LPTSTR pszServiceName);

VOID PrintSid(IN NETDIAG_PARAMS *pParams, IN PSID Sid OPTIONAL);

LPSTR MapTime(DWORD_PTR TimeVal);

#ifdef _UNICODE
#define IsIcmpResponse(_psz)	IsIcmpResponseW(_psz)
#else
#define IsIcmpResponse(_psz)	IsIcmpResponseA(_psz)
#endif

BOOL IsIcmpResponseW(LPCWSTR pswzIpAddrStr);
BOOL IsIcmpResponseA(LPCSTR	pszIpAddrStr);

PTESTED_DOMAIN
AddTestedDomain(
                IN NETDIAG_PARAMS *pParams,
                IN NETDIAG_RESULT *pResults,
                IN LPWSTR pswzNetbiosDomainName,
                IN LPWSTR pswzDnsDomainName,
                IN BOOL bPrimaryDomain
    );


//used in DCListTest and TrustTest
NTSTATUS NettestSamConnect(
                  IN NETDIAG_PARAMS *pParams,
                  IN LPWSTR DcName,
                  OUT PSAM_HANDLE SamServerHandle
                 );

/*---------------------------------------------------------------------------
	Misc. utilities
 ---------------------------------------------------------------------------*/
HRESULT	GetComputerNameInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
HRESULT GetDNSInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
HRESULT GetNetBTParameters(IN NETDIAG_PARAMS *pParams,
						   IN OUT NETDIAG_RESULT *pResults);
LPTSTR NetStatusToString( NET_API_STATUS NetStatus );
LPTSTR Win32ErrorToString(DWORD Id);

#define DimensionOf(rg)	(sizeof(rg) / sizeof(*rg))



/*---------------------------------------------------------------------------
	Error handling utilities
 ---------------------------------------------------------------------------*/
#define CheckHr(x) \
	if ((hr = (x)) & (0x80000000)) \
	   goto Error;

#define CheckErr(x) \
	if ((hr = HResultFromWin32(x)) & (0x80000000)) \
		goto Error;

HRESULT HResultFromWin32(DWORD dwErr);

#define FHrSucceeded(hr)	SUCCEEDED(hr)
#define FHrOK(hr)			((hr) == S_OK)
#define FHrFailed(hr)		FAILED(hr)

#define hrOK	S_OK

// if hr failed, assign hr and ids contect to the structure, and goto L_ERR
#define CHK_HR_CONTEXT(w, h, IDS){	\
	if (FAILED(h))	{\
	(w).hr = (h), (w).idsContext = (IDS); goto L_ERR;}}


/*!--------------------------------------------------------------------------
	FormatError
		This function will lookup the error message associated with
		the HRESULT.
	Author: KennT
 ---------------------------------------------------------------------------*/
void FormatError(HRESULT hr, TCHAR *pszBuffer, UINT cchBuffer);
void FormatWin32Error(DWORD dwErr, TCHAR *pszBuffer, UINT cchBuffer);




/*---------------------------------------------------------------------------
	Tracing utilites
 ---------------------------------------------------------------------------*/

void TraceBegin();
void TraceEnd();
void TraceError(LPCSTR pszString, HRESULT hr);
void TraceResult(LPCSTR pszString, HRESULT hr);
void TraceSz(LPCSTR pszString);



/*---------------------------------------------------------------------------
	Character utilities
 ---------------------------------------------------------------------------*/
LPTSTR MapGuidToAdapterName(LPCTSTR AdapterGuid);
LPTSTR MapGuidToServiceName(LPCTSTR AdapterGuid);
LPWSTR MapGuidToServiceNameW(LPCWSTR AdapterGuid);


/*---------------------------------------------------------------------------
	Memory allocation utilities
 ---------------------------------------------------------------------------*/
#define Malloc(_cb)		malloc(_cb)
#define Realloc(_pv, _cb)	realloc(_pv, _cb)
#define Free(_pv)		free(_pv)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\netcard.h ===
/*--

Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

     netcard.h

Abstract:

     Contains definitions, globals and function prototypes used by "ndis" test.

Author:
   
     4-Aug-1998 (t-rajkup)

Environment:

     User mode only.
     
Revision History:
      
     None.
--*/

#ifndef HEADER__NETCARD
#define HEADER__NETCARD

/*==========================< ndis test - includes >=======================*/
#include <wmium.h>
#include <initguid.h>
#include <ndisguid.h>
#define  WIRELESS_WAN
#include <ntddndis.h>
#include <qos.h>

/*==========================< ndis test - functions >=====================*/

ULONG
ShowGuidData(
   IN ULONG       argc,
   IN ULONG       ulOidCode,
   IN PUCHAR      pucNamePtr,
   IN PUCHAR      pucDataPtr,
   IN ULONG       ulDataSize
   );

typedef
ULONG
(*WMI_OPEN)(
   GUID        *pGuid,
   ULONG       DesiredAccess,
   WMIHANDLE   *DataBlockHandle
   );


typedef
ULONG
(*WMI_CLOSE)(
   WMIHANDLE   DataBlockHandle
   );

typedef
ULONG
(*WMI_QUERYALL)(
   WMIHANDLE   DataBlockHandle,
   PULONG      pulBufferSize,
   PVOID       pvBuffer
   );


typedef
ULONG
(*WMI_QUERYSINGLE)(
   WMIHANDLE   DataBlockHandle,
   LPCSTR      InstanceName,
   PULONG      pulBufferSize,
   PVOID       pvBuffer
   );

typedef
ULONG
(*WMI_NOTIFY)(
   LPGUID      pGuid,
   BOOLEAN     Enable,
   PVOID       DeliveryInfo,
   ULONG       DeliveryContext,
   ULONG       Flags
   );

ULONG
NdtWmiOpenBlock(
   IN GUID           *pGuid,
   IN OUT WMIHANDLE  *pWmiHandle
   );

BOOLEAN
fShowQueryInfoResults(
    PUCHAR        pucBuffer,
    ULONG         ulBytesReturned,
    NDIS_OID      ulOID,
    ULONG         argc
    );

VOID
LoadWmiLibrary(
    HINSTANCE   hWmiLib
   );

ULONG
NdtWmiQueryAllData(
   IN WMIHANDLE      WmiHandle,
   IN OUT PULONG     pulBufferSize,
   IN OUT PVOID      pvBuffer,
   IN BOOLEAN        fCheckShort
   );


VOID
_CRTAPI1
HapiPrint(PCHAR   Format,
          ...  );


VOID
_CRTAPI1
HapiPrintEx(PCHAR    Format,
            va_list  args);


VOID
ShowIrdaOids(ULONG   ulOid,
             PULONG  pulDataPtr,
             ULONG   ulBytesReturned,
             PULONG  pulTypeNeeded,
             PULONG  pulArraySize
            );


VOID
ShowWirelessWanOids(ULONG  ulOid,
                    PULONG pulDataPtr,
                    ULONG  ulBytesReturned,
                    PULONG pulTypeNeeded,
                    PULONG pulArraySize
                   );

VOID
ShowAtmOids(ULONG    ulOid,
            PULONG   pulDataPtr,
            ULONG    ulBytesReturned,
            PULONG   pulTypeNeeded,
            PULONG   pulArraySize
            );

VOID
ShowArcnetOids(ULONG    ulOid,
               PULONG   pulDataPtr,
               PULONG   pulTypeNeeded
              );


VOID
ShowFddiOids(ULONG   ulOid,
             PULONG  pulDataPtr,
             ULONG   ulBytesReturned,
             PULONG  pulTypeNeeded,
             PULONG  pulArraySize
            );

VOID
ShowTokenRingOids(ULONG    ulOid,
                  PULONG   pulDataPtr,
                  PULONG   pulTypeNeeded
                  );

VOID
ShowEthernetOids(ULONG  ulOid,
                 PULONG pulDataPtr,
                 ULONG  ulBytesReturned,
                 PULONG pulTypeNeeded,
                 PULONG pulArraySize
                );

VOID
ShowPnpPowerOids(ULONG     ulOid,
                 PULONG    pulDataPtr,
                 ULONG     ulBytesReturned,
                 PULONG    pulTypeNeeded,
                 PULONG    pulArraySize
                 );

VOID
ShowGeneralOids(ULONG   ulOid,
                PULONG  pulDataPtr,
                ULONG   ulBytesReturned,
                PULONG  pulTypeNeeded,
                PULONG  pulArraySize
                );

VOID
ShowCoGeneralOids(ULONG   ulOid,
                  PULONG  pulDataPtr,
                  ULONG   ulBytesReturned,
                  PULONG  pulTypeNeeded,
                  PULONG  pulArraySize
                  );

VOID
NdtPrintOidName(
   ULONG   ulOidCode
  );

static
VOID
ShowHardwareStatus(
   IN ULONG   ulStatus
   );

static
VOID
ShowMediaList(
   IN PULONG   pulMedia,
   IN ULONG    ulNumMedia
   );


static
VOID
ShowSupportedGuids(
   IN PVOID    pvDataPtr,
   IN ULONG    ulTotalBytes
   );

static
VOID
ShowTimeCaps(
   IN PVOID    pvDataPtr
   );

PVOID
GetEmbeddedData(
   PNDIS_VAR_DATA_DESC pNdisVarDataDesc
  );

static
VOID
FixMediaList(
   IN OUT PULONG  pulMedia,
   IN     ULONG   ulNumMedia
   );

static
VOID
EthPrintAddress(
   PUCHAR  pucAddress
   );

static
VOID
TokenRingShowAddress(
   IN PUCHAR   pucAddress,
   IN ULONG    ulLength
   );

static
VOID
FddiShowAddress(
   IN PUCHAR   pucAddress,
   IN ULONG    ulLength
   );

static
VOID
FddiShowRawData(
   IN PUCHAR   pucBuffer,
   IN ULONG    ulLength
   );


static
VOID
ShowWWHeaderFormat(
   ULONG
   ulFormat
   );

VOID
PrintWNodeHeader(
    PWNODE_HEADER   pWnodeHeader
   );

VOID
NdtPrintStatus(
   NDIS_STATUS lGeneralStatus
  );

PUCHAR
OffsetToPtr(
     PVOID pvBase,
     ULONG ulOffset
  );

ULONG
NdtWmiQuerySingleInstance(
     WMIHANDLE WmiHandle,
     PCHAR     strDeviceName,
     PULONG    pulBufferSize,
     PVOID     pvBuffer,
     BOOLEAN   fCheckShort
  );

VOID
GetMediaList(
     PULONG    pulMedia,
     ULONG     ulNumMedia
   );

int
GetNumOids(
   PNDIS_MEDIUM medium,
   int  index
   );

int
GetBaseAddr(
   PNDIS_MEDIUM medium,
   int  index
   );

typedef struct _ATM_VC_RATES_SUPPORTED
{
        ULONG                                           MinCellRate;
        ULONG                                           MaxCellRate;
} ATM_VC_RATES_SUPPORTED, *PATM_VC_RATES_SUPPORTED;

//
// ATM Service Category
//
#define ATM_SERVICE_CATEGORY_CBR        1       // Constant Bit Rate
#define ATM_SERVICE_CATEGORY_VBR        2       // Variable Bit Rate
#define ATM_SERVICE_CATEGORY_UBR        4       // Unspecified Bit Rate
#define ATM_SERVICE_CATEGORY_ABR        8       // Available Bit Rate

//
// AAL types that the miniport supports
//
#define AAL_TYPE_AAL0                   1
#define AAL_TYPE_AAL1                   2
#define AAL_TYPE_AAL34                  4
#define AAL_TYPE_AAL5                   8

typedef struct _ATM_VPIVCI
{
        ULONG                                           Vpi;
        ULONG                                           Vci;
} ATM_VPIVCI, *PATM_VPIVCI;

struct _CONSTANT_ENTRY
{
   LONG     lValue;        // integer value
   PCHAR    strName;       // constant name
};
typedef struct _CONSTANT_ENTRY *PCONSTANT_ENTRY;
typedef struct _CONSTANT_ENTRY CONSTANT_ENTRY;

/*==========================< ndis test - globals >=======================*/

#define strNtDeviceHeader  "\\DEVICE\\"

//
// Globals used in infering problems
//

BOOL     NdisFlag;
ULONG    ulFirstErrorCount;
ULONG    ulSecondErrorCount;


#define NDIS_SLEEP_TIME 2000 // 2 second
#define NDIS_MAX_ERROR_COUNT 1  // max no of error counts that can be seen between 2 successice error count readings
#define NDIS_MAX_RCV_ERROR  10000 // max no of rcv errors
#define NDIS_MAX_TX_ERROR   10000 // max no of xmit errors


#define ulNDIS_VERSION_40              40
#define ulNDIS_VERSION_50              50

//
// constants for operating system
//
#define ulINVALID_OS          0x00000000
#define ulWINDOWS_95          0x00000001
#define ulWINDOWS_NT          0x00000002

//
// hibernate/standby/wake-related constants
//
#define ulHIBERNATE     1
#define ulSTANDBY       2
#define ulWAKEUPTIMER   4

#define ulTEST_SUCCESSFUL  0x00
#define ulTEST_WARNED      0x01
#define ulTEST_FAILED     0x02
#define ulTEST_BLOCKED     0x03

//
// media type definitions for use with scripts
//


#define ulMEDIUM_ETHERNET     0x01
#define ulMEDIUM_TOKENRING    0x02
#define ulMEDIUM_FDDI         0x03
#define ulMEDIUM_ARCNET       0x04
#define ulMEDIUM_WIRELESSWAN  0x05
#define ulMEDIUM_IRDA         0x06
#define ulMEDIUM_ATM          0x07
#define ulMEDIUM_NDISWAN      0x08


// packettype
#define ulSTRESS_FIXEDSIZE    0x00000000
#define ulSTRESS_RANDOMSIZE   0x00000001
#define ulSTRESS_CYCLICAL     0x00000002
#define ulSTRESS_SMALLSIZE    0x00000003

// packet makeup
#define ulSTRESS_RAND         0x00000000
#define ulSTRESS_SMALL        0x00000010
#define ulSTRESS_ZEROS        0x00000020
#define ulSTRESS_ONES         0x00000030

// response type
#define ulSTRESS_FULLRESP     0x00000000
#define ulSTRESS_NORESP       0x00000100
#define ulSTRESS_ACK          0x00000200
#define ulSTRESS_ACK10        0x00000300


// windowing (speed control)
#define ulSTRESS_WINDOW_ON    0x00000000
#define ulSTRESS_WINDOW_OFF   0x00001000

//
// verify received packets, or just count them
// (or'ed in with main options)
//

#define ulPERFORM_VERIFYRECEIVES  0x00000008
#define ulPERFORM_INDICATE_RCV    0x00000000

//
// main performance test options
//

#define ulPERFORM_SENDONLY       0x00000000
#define ulPERFORM_SEND           0x00000001
#define ulPERFORM_BOTH           0x00000002
#define ulPERFORM_RECEIVE        0x00000003
#define ulPERFORM_MODEMASK       0x00000003

// receive-type options
// valid for both Receive and ReceivePacket
//

//
// DEFAULT
// PR -- uses lookahead if whole packet, else transfer data
// PRP -- uses packet from ReceivePacket if small (<= 256), else queues packet for DPC
//

#define ulRECEIVE_DEFAULT              0x00000000

//
// NOCOPY
// PR -- use just lookahead, even if NOT whole packet.  Used to check lookahead
// PRP -- use from ReceivePacket no matter what the size
//

#define ulRECEIVE_NOCOPY               0x00000001

//
// TRANSFER
//   PR  -- call NdisTransferData from Receive handler
//   PRP -- call NdisTransferData from ReceivePacket Handler
//

#define ulRECEIVE_TRANSFER             0x00000002

//
// PARTIAL_TRANSFER
//   same as transfer EXCEPT copies random length before transfer
//

#define ulRECEIVE_PARTIAL_TRANSFER     0x00000003
#define ulMAX_NDIS30_RECEIVE_OPTION    0x00000003

//
// following options just apply to Ndis40 (ReceivePacket handler)
//

//
// IGNORE -- used to detect what path is being used..
//    PNP -- ignore all packets
//
#define ulRECEIVE_PACKETIGNORE         0x00000004

//
//   do local copy of packet, rest of work done in DPC
//
#define ulRECEIVE_LOCCOPY              0x00000005

//
// PRP -- queues all packets for handling in DPC
//

#define ulRECEIVE_QUEUE                0x00000006


//
// double queue packet
//   PRP -- packet queued twice (on main queue, and on secondary queue where
//          all that is done with it in DPC is remove it)
//
#define ulRECEIVE_DOUBLE_QUEUE         0x00000007
//
// triple queue packet
//
#define ulRECEIVE_TRIPLE_QUEUE         0x00000008
#define ulMAX_NDIS40_RECEIVE_OPTION    0x00000008

//
// This can be ORed with any of the following.  Caused any extra
// receives to be thrown away.  Allows tests to be run on corp net
//
#define ulRECEIVE_ALLOW_BUSY_NET       0x80000000


//
// This value is passed from the script to run the particular type of test.
//
//  Type of Priority test
//
#define ulPRIORITY_TYPE_802_3          0x0001
#define ulPRIORITY_TYPE_802_1P         0x0002

//  Send Type
#define ulPRIORITY_SEND                0x0001
#define ulPRIORITY_SEND_PACKETS        0x0002


#define NDIS_STATUS_SUCCESS                  ((NDIS_STATUS)STATUS_SUCCESS)
#define NDIS_STATUS_PENDING                  ((NDIS_STATUS)STATUS_PENDING)
#define NDIS_STATUS_NOT_RECOGNIZED           ((NDIS_STATUS)0x00010001L)
#define NDIS_STATUS_NOT_COPIED               ((NDIS_STATUS)0x00010002L)
#define NDIS_STATUS_NOT_ACCEPTED             ((NDIS_STATUS)0x00010003L)

#define NDIS_STATUS_CALL_ACTIVE              ((NDIS_STATUS)0x00010007L)
#define NDIS_STATUS_ONLINE                   ((NDIS_STATUS)0x40010003L)
#define NDIS_STATUS_RESET_START              ((NDIS_STATUS)0x40010004L)
#define NDIS_STATUS_RESET_END                ((NDIS_STATUS)0x40010005L)
#define NDIS_STATUS_RING_STATUS              ((NDIS_STATUS)0x40010006L)


#define NDIS_STATUS_CLOSED                   ((NDIS_STATUS)0x40010007L)
#define NDIS_STATUS_WAN_LINE_UP              ((NDIS_STATUS)0x40010008L)
#define NDIS_STATUS_WAN_LINE_DOWN            ((NDIS_STATUS)0x40010009L)
#define NDIS_STATUS_WAN_FRAGMENT             ((NDIS_STATUS)0x4001000AL)
#define NDIS_STATUS_MEDIA_CONNECT            ((NDIS_STATUS)0x4001000BL)

#define NDIS_STATUS_MEDIA_DISCONNECT         ((NDIS_STATUS)0x4001000CL)
#define NDIS_STATUS_HARDWARE_LINE_UP         ((NDIS_STATUS)0x4001000DL)
#define NDIS_STATUS_HARDWARE_LINE_DOWN       ((NDIS_STATUS)0x4001000EL)
#define NDIS_STATUS_INTERFACE_UP             ((NDIS_STATUS)0x4001000FL)
#define NDIS_STATUS_INTERFACE_DOWN           ((NDIS_STATUS)0x40010010L)

#define NDIS_STATUS_MEDIA_BUSY               ((NDIS_STATUS)0x40010011L)
#define NDIS_STATUS_MEDIA_SPECIFIC_INDICATION ((NDIS_STATUS)0x40010012L)
#define NDIS_STATUS_WW_INDICATION            NDIS_STATUS_MEDIA_SPECIFIC_INDICATION
#define NDIS_STATUS_LINK_SPEED_CHANGE        ((NDIS_STATUS)0x40010013L)
#define NDIS_STATUS_NOT_RESETTABLE           ((NDIS_STATUS)0x80010001L)
#define NDIS_STATUS_SOFT_ERRORS              ((NDIS_STATUS)0x80010003L)
#define NDIS_STATUS_HARD_ERRORS              ((NDIS_STATUS)0x80010004L)
#define NDIS_STATUS_BUFFER_OVERFLOW          ((NDIS_STATUS)STATUS_BUFFER_OVERFLOW)

#define NDIS_STATUS_FAILURE                  ((NDIS_STATUS)STATUS_UNSUCCESSFUL)
#define NDIS_STATUS_RESOURCES                ((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
#define NDIS_STATUS_CLOSING                  ((NDIS_STATUS)0xC0010002L)
#define NDIS_STATUS_BAD_VERSION              ((NDIS_STATUS)0xC0010004L)
#define NDIS_STATUS_BAD_CHARACTERISTICS      ((NDIS_STATUS)0xC0010005L)

#define NDIS_STATUS_ADAPTER_NOT_FOUND        ((NDIS_STATUS)0xC0010006L)
#define NDIS_STATUS_OPEN_FAILED              ((NDIS_STATUS)0xC0010007L)
#define NDIS_STATUS_DEVICE_FAILED            ((NDIS_STATUS)0xC0010008L)
#define NDIS_STATUS_MULTICAST_FULL           ((NDIS_STATUS)0xC0010009L)
#define NDIS_STATUS_MULTICAST_EXISTS         ((NDIS_STATUS)0xC001000AL)

#define NDIS_STATUS_MULTICAST_NOT_FOUND      ((NDIS_STATUS)0xC001000BL)
#define NDIS_STATUS_REQUEST_ABORTED          ((NDIS_STATUS)0xC001000CL)
#define NDIS_STATUS_RESET_IN_PROGRESS        ((NDIS_STATUS)0xC001000DL)
#define NDIS_STATUS_CLOSING_INDICATING       ((NDIS_STATUS)0xC001000EL)
#define NDIS_STATUS_NOT_SUPPORTED            ((NDIS_STATUS)STATUS_NOT_SUPPORTED)


#define NDIS_STATUS_INVALID_PACKET           ((NDIS_STATUS)0xC001000FL)
#define NDIS_STATUS_OPEN_LIST_FULL           ((NDIS_STATUS)0xC0010010L)
#define NDIS_STATUS_ADAPTER_NOT_READY        ((NDIS_STATUS)0xC0010011L)
#define NDIS_STATUS_ADAPTER_NOT_OPEN         ((NDIS_STATUS)0xC0010012L)
#define NDIS_STATUS_NOT_INDICATING           ((NDIS_STATUS)0xC0010013L)

#define NDIS_STATUS_INVALID_LENGTH           ((NDIS_STATUS)0xC0010014L)
#define NDIS_STATUS_INVALID_DATA             ((NDIS_STATUS)0xC0010015L)
#define NDIS_STATUS_BUFFER_TOO_SHORT         ((NDIS_STATUS)0xC0010016L)
#define NDIS_STATUS_INVALID_OID              ((NDIS_STATUS)0xC0010017L)
#define NDIS_STATUS_ADAPTER_REMOVED          ((NDIS_STATUS)0xC0010018L)


#define NDIS_STATUS_UNSUPPORTED_MEDIA        ((NDIS_STATUS)0xC0010019L)
#define NDIS_STATUS_GROUP_ADDRESS_IN_USE     ((NDIS_STATUS)0xC001001AL)
#define NDIS_STATUS_FILE_NOT_FOUND           ((NDIS_STATUS)0xC001001BL)
#define NDIS_STATUS_ERROR_READING_FILE       ((NDIS_STATUS)0xC001001CL)
#define NDIS_STATUS_ALREADY_MAPPED           ((NDIS_STATUS)0xC001001DL)

#define NDIS_STATUS_RESOURCE_CONFLICT        ((NDIS_STATUS)0xC001001EL)
#define NDIS_STATUS_NO_CABLE                 ((NDIS_STATUS)0xC001001FL)
#define NDIS_STATUS_INVALID_SAP              ((NDIS_STATUS)0xC0010020L)
#define NDIS_STATUS_SAP_IN_USE               ((NDIS_STATUS)0xC0010021L)
#define NDIS_STATUS_INVALID_ADDRESS          ((NDIS_STATUS)0xC0010022L)


#define NDIS_STATUS_VC_NOT_ACTIVATED         ((NDIS_STATUS)0xC0010023L)
#define NDIS_STATUS_DEST_OUT_OF_ORDER        ((NDIS_STATUS)0xC0010024L) // cause 27
#define NDIS_STATUS_VC_NOT_AVAILABLE         ((NDIS_STATUS)0xC0010025L) // cause 35,45
#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE   ((NDIS_STATUS)0xC0010026L) // cause 37
#define NDIS_STATUS_INCOMPATABLE_QOS         ((NDIS_STATUS)0xC0010027L) // cause 49

#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED   ((NDIS_STATUS)0xC0010028L) // cause 93
#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION  ((NDIS_STATUS)0xC0010029L) // cause 3
#define NDIS_STATUS_TOKEN_RING_OPEN_ERROR    ((NDIS_STATUS)0xC0011000L)


CONSTANT_ENTRY NdisTestConstantTable[] =
{
   //
   //  OID definitions (from ntddndis.h)
   //
   OID_GEN_SUPPORTED_LIST              ,  "OID_GEN_SUPPORTED_LIST"            ,     // 1
   OID_GEN_HARDWARE_STATUS             ,  "OID_GEN_HARDWARE_STATUS"           ,
   OID_GEN_MEDIA_SUPPORTED             ,  "OID_GEN_MEDIA_SUPPORTED"           ,
   OID_GEN_MEDIA_IN_USE                ,  "OID_GEN_MEDIA_IN_USE"              ,     // 4
   OID_GEN_MAXIMUM_LOOKAHEAD           ,  "OID_GEN_MAXIMUM_LOOKAHEAD"         ,
   OID_GEN_MAXIMUM_FRAME_SIZE          ,  "OID_GEN_MAXIMUM_FRAME_SIZE"        ,
   OID_GEN_LINK_SPEED                  ,  "OID_GEN_LINK_SPEED"                ,
   OID_GEN_TRANSMIT_BUFFER_SPACE       ,  "OID_GEN_TRANSMIT_BUFFER_SPACE"     ,     // 8
   OID_GEN_RECEIVE_BUFFER_SPACE        ,  "OID_GEN_RECEIVE_BUFFER_SPACE"      ,
   OID_GEN_TRANSMIT_BLOCK_SIZE         ,  "OID_GEN_TRANSMIT_BLOCK_SIZE"       ,
   OID_GEN_RECEIVE_BLOCK_SIZE          ,  "OID_GEN_RECEIVE_BLOCK_SIZE"        ,
   OID_GEN_VENDOR_ID                   ,  "OID_GEN_VENDOR_ID"                 ,     // 12
   OID_GEN_VENDOR_DESCRIPTION          ,  "OID_GEN_VENDOR_DESCRIPTION"        ,
   OID_GEN_CURRENT_PACKET_FILTER       ,  "OID_GEN_CURRENT_PACKET_FILTER"     ,
   OID_GEN_CURRENT_LOOKAHEAD           ,  "OID_GEN_CURRENT_LOOKAHEAD"         ,
   OID_GEN_DRIVER_VERSION              ,  "OID_GEN_DRIVER_VERSION"            ,     // 16
   OID_GEN_MAXIMUM_TOTAL_SIZE          ,  "OID_GEN_MAXIMUM_TOTAL_SIZE"        ,
   OID_GEN_PROTOCOL_OPTIONS            ,  "OID_GEN_PROTOCOL_OPTIONS"          ,
   OID_GEN_MAC_OPTIONS                 ,  "OID_GEN_MAC_OPTIONS"               ,
   OID_GEN_MEDIA_CONNECT_STATUS        ,  "OID_GEN_MEDIA_CONNECT_STATUS"      ,     // 20
   OID_GEN_MAXIMUM_SEND_PACKETS        ,  "OID_GEN_MAXIMUM_SEND_PACKETS"      ,
   OID_GEN_VENDOR_DRIVER_VERSION       ,  "OID_GEN_VENDOR_DRIVER_VERSION"     ,
   OID_GEN_SUPPORTED_GUIDS             ,  "OID_GEN_SUPPORTED_GUIDS"           ,
   OID_GEN_NETWORK_LAYER_ADDRESSES     ,  "OID_GEN_NETWORK_LAYER_ADDRESSES"   ,     // 24

   OID_GEN_XMIT_OK                     ,  "OID_GEN_XMIT_OK"                   ,
   OID_GEN_RCV_OK                      ,  "OID_GEN_RCV_OK"                    ,
   OID_GEN_XMIT_ERROR                  ,  "OID_GEN_XMIT_ERROR"                ,
   OID_GEN_RCV_ERROR                   ,  "OID_GEN_RCV_ERROR"                 ,     // 28
   OID_GEN_RCV_NO_BUFFER               ,  "OID_GEN_RCV_NO_BUFFER"             ,

   OID_GEN_DIRECTED_BYTES_XMIT         ,  "OID_GEN_DIRECTED_BYTES_XMIT"       ,
   OID_GEN_DIRECTED_FRAMES_XMIT        ,  "OID_GEN_DIRECTED_FRAMES_XMIT"      ,
   OID_GEN_MULTICAST_BYTES_XMIT        ,  "OID_GEN_MULTICAST_BYTES_XMIT"      ,     // 32
   OID_GEN_MULTICAST_FRAMES_XMIT       ,  "OID_GEN_MULTICAST_FRAMES_XMIT"     ,
   OID_GEN_BROADCAST_BYTES_XMIT        ,  "OID_GEN_BROADCAST_BYTES_XMIT"      ,
   OID_GEN_BROADCAST_FRAMES_XMIT       ,  "OID_GEN_BROADCAST_FRAMES_XMIT"     ,
   OID_GEN_DIRECTED_BYTES_RCV          ,  "OID_GEN_DIRECTED_BYTES_RCV"        ,     // 36
   OID_GEN_DIRECTED_FRAMES_RCV         ,  "OID_GEN_DIRECTED_FRAMES_RCV"       ,
   OID_GEN_MULTICAST_BYTES_RCV         ,  "OID_GEN_MULTICAST_BYTES_RCV"       ,
   OID_GEN_MULTICAST_FRAMES_RCV        ,  "OID_GEN_MULTICAST_FRAMES_RCV"      ,
   OID_GEN_BROADCAST_BYTES_RCV         ,  "OID_GEN_BROADCAST_BYTES_RCV"       ,     // 40
   OID_GEN_BROADCAST_FRAMES_RCV        ,  "OID_GEN_BROADCAST_FRAMES_RCV"      ,
   OID_GEN_RCV_CRC_ERROR               ,  "OID_GEN_RCV_CRC_ERROR"             ,
   OID_GEN_TRANSMIT_QUEUE_LENGTH       ,  "OID_GEN_TRANSMIT_QUEUE_LENGTH"     ,
   OID_GEN_GET_TIME_CAPS               ,  "OID_GEN_GET_TIME_CAPS"             ,     // 44
   OID_GEN_GET_NETCARD_TIME            ,  "OID_GEN_GET_NETCARD_TIME"          ,     // 45

  //
  // 802.3 Objects
  //
  OID_802_3_PERMANENT_ADDRESS         ,  "OID_802_3_PERMANENT_ADDRESS"       ,     // 1
  OID_802_3_CURRENT_ADDRESS           ,  "OID_802_3_CURRENT_ADDRESS"         ,
  OID_802_3_MULTICAST_LIST            ,  "OID_802_3_MULTICAST_LIST"          ,
  OID_802_3_MAXIMUM_LIST_SIZE         ,  "OID_802_3_MAXIMUM_LIST_SIZE"       ,     // 4
  OID_802_3_MAC_OPTIONS               ,  "OID_802_3_MAC_OPTIONS"             ,

  OID_802_3_RCV_ERROR_ALIGNMENT       ,  "OID_802_3_RCV_ERROR_ALIGNMENT"     ,
  OID_802_3_XMIT_ONE_COLLISION        ,  "OID_802_3_XMIT_ONE_COLLISION"      ,
  OID_802_3_XMIT_MORE_COLLISIONS      ,  "OID_802_3_XMIT_MORE_COLLISIONS"    ,     // 8

  OID_802_3_XMIT_DEFERRED             ,  "OID_802_3_XMIT_DEFERRED"           ,
  OID_802_3_XMIT_MAX_COLLISIONS       ,  "OID_802_3_XMIT_MAX_COLLISIONS"     ,
  OID_802_3_RCV_OVERRUN               ,  "OID_802_3_RCV_OVERRUN"             ,
  OID_802_3_XMIT_UNDERRUN             ,  "OID_802_3_XMIT_UNDERRUN"           ,     // 12
  OID_802_3_XMIT_HEARTBEAT_FAILURE    ,  "OID_802_3_XMIT_HEARTBEAT_FAILURE"  ,
  OID_802_3_XMIT_TIMES_CRS_LOST       ,  "OID_802_3_XMIT_TIMES_CRS_LOST"     ,
  OID_802_3_XMIT_LATE_COLLISIONS      ,  "OID_802_3_XMIT_LATE_COLLISIONS"    ,     // 15

  //
  // 802.5 Objects
  //
  OID_802_5_PERMANENT_ADDRESS         ,  "OID_802_5_PERMANENT_ADDRESS"       ,     // 1
  OID_802_5_CURRENT_ADDRESS           ,  "OID_802_5_CURRENT_ADDRESS"         ,
  OID_802_5_CURRENT_FUNCTIONAL        ,  "OID_802_5_CURRENT_FUNCTIONAL"      ,
  OID_802_5_CURRENT_GROUP             ,  "OID_802_5_CURRENT_GROUP"           ,     // 4
  OID_802_5_LAST_OPEN_STATUS          ,  "OID_802_5_LAST_OPEN_STATUS"        ,
  OID_802_5_CURRENT_RING_STATUS       ,  "OID_802_5_CURRENT_RING_STATUS"     ,
  OID_802_5_CURRENT_RING_STATE        ,  "OID_802_5_CURRENT_RING_STATE"      ,

  OID_802_5_LINE_ERRORS               ,  "OID_802_5_LINE_ERRORS"             ,     // 8
  OID_802_5_LOST_FRAMES               ,  "OID_802_5_LOST_FRAMES"             ,

  OID_802_5_BURST_ERRORS              ,  "OID_802_5_BURST_ERRORS"            ,
  OID_802_5_AC_ERRORS                 ,  "OID_802_5_AC_ERRORS"               ,
  OID_802_5_ABORT_DELIMETERS          ,  "OID_802_5_ABORT_DELIMETERS"        ,     // 12
  OID_802_5_FRAME_COPIED_ERRORS       ,  "OID_802_5_FRAME_COPIED_ERRORS"     ,
  OID_802_5_FREQUENCY_ERRORS          ,  "OID_802_5_FREQUENCY_ERRORS"        ,
  OID_802_5_TOKEN_ERRORS              ,  "OID_802_5_TOKEN_ERRORS"            ,
  OID_802_5_INTERNAL_ERRORS           ,  "OID_802_5_INTERNAL_ERRORS"         ,     // 16

     //
   // Fddi objects
   //
   OID_FDDI_LONG_PERMANENT_ADDR        ,  "OID_FDDI_LONG_PERMANENT_ADDR"      ,     // 1
   OID_FDDI_LONG_CURRENT_ADDR          ,  "OID_FDDI_LONG_CURRENT_ADDR"        ,
   OID_FDDI_LONG_MULTICAST_LIST        ,  "OID_FDDI_LONG_MULTICAST_LIST"      ,
   OID_FDDI_LONG_MAX_LIST_SIZE         ,  "OID_FDDI_LONG_MAX_LIST_SIZE"       ,     // 4
   OID_FDDI_SHORT_PERMANENT_ADDR       ,  "OID_FDDI_SHORT_PERMANENT_ADDR"     ,
   OID_FDDI_SHORT_CURRENT_ADDR         ,  "OID_FDDI_SHORT_CURRENT_ADDR"       ,
   OID_FDDI_SHORT_MULTICAST_LIST       ,  "OID_FDDI_SHORT_MULTICAST_LIST"     ,
   OID_FDDI_SHORT_MAX_LIST_SIZE        ,  "OID_FDDI_SHORT_MAX_LIST_SIZE"      ,     // 8

   OID_FDDI_ATTACHMENT_TYPE            ,  "OID_FDDI_ATTACHMENT_TYPE"          ,
   OID_FDDI_UPSTREAM_NODE_LONG         ,  "OID_FDDI_UPSTREAM_NODE_LONG"       ,
   OID_FDDI_DOWNSTREAM_NODE_LONG       ,  "OID_FDDI_DOWNSTREAM_NODE_LONG"     ,
   OID_FDDI_FRAME_ERRORS               ,  "OID_FDDI_FRAME_ERRORS"             ,     // 12
   OID_FDDI_FRAMES_LOST                ,  "OID_FDDI_FRAMES_LOST"              ,
   OID_FDDI_RING_MGT_STATE             ,  "OID_FDDI_RING_MGT_STATE"           ,
   OID_FDDI_LCT_FAILURES               ,  "OID_FDDI_LCT_FAILURES"             ,
   OID_FDDI_LEM_REJECTS                ,  "OID_FDDI_LEM_REJECTS"              ,     // 16
   OID_FDDI_LCONNECTION_STATE          ,  "OID_FDDI_LCONNECTION_STATE"        ,
   //
   // fddi SMT/MAC/PATH/PORT/IF objects
   //
   OID_FDDI_SMT_STATION_ID             ,  "OID_FDDI_SMT_STATION_ID"           ,
   OID_FDDI_SMT_OP_VERSION_ID          ,  "OID_FDDI_SMT_OP_VERSION_ID"        ,
   OID_FDDI_SMT_HI_VERSION_ID          ,  "OID_FDDI_SMT_HI_VERSION_ID"        ,     // 20
   OID_FDDI_SMT_LO_VERSION_ID          ,  "OID_FDDI_SMT_LO_VERSION_ID"        ,
   OID_FDDI_SMT_MANUFACTURER_DATA      ,  "OID_FDDI_SMT_MANUFACTURER_DATA"    ,
   OID_FDDI_SMT_USER_DATA              ,  "OID_FDDI_SMT_USER_DATA"            ,
   OID_FDDI_SMT_MIB_VERSION_ID         ,  "OID_FDDI_SMT_MIB_VERSION_ID"       ,     // 24
   OID_FDDI_SMT_MAC_CT                 ,  "OID_FDDI_SMT_MAC_CT"               ,
   OID_FDDI_SMT_NON_MASTER_CT          ,  "OID_FDDI_SMT_NON_MASTER_CT"        ,
   OID_FDDI_SMT_MASTER_CT              ,  "OID_FDDI_SMT_MASTER_CT"            ,
   OID_FDDI_SMT_AVAILABLE_PATHS        ,  "OID_FDDI_SMT_AVAILABLE_PATHS"      ,     // 28
   OID_FDDI_SMT_CONFIG_CAPABILITIES    ,  "OID_FDDI_SMT_CONFIG_CAPABILITIES"  ,
   OID_FDDI_SMT_CONFIG_POLICY          ,  "OID_FDDI_SMT_CONFIG_POLICY"        ,
   OID_FDDI_SMT_CONNECTION_POLICY      ,  "OID_FDDI_SMT_CONNECTION_POLICY"    ,
   OID_FDDI_SMT_T_NOTIFY               ,  "OID_FDDI_SMT_T_NOTIFY"             ,     // 32
   OID_FDDI_SMT_STAT_RPT_POLICY        ,  "OID_FDDI_SMT_STAT_RPT_POLICY"      ,
   OID_FDDI_SMT_TRACE_MAX_EXPIRATION   ,  "OID_FDDI_SMT_TRACE_MAX_EXPIRATION" ,
   OID_FDDI_SMT_PORT_INDEXES           ,  "OID_FDDI_SMT_PORT_INDEXES"         ,
   OID_FDDI_SMT_MAC_INDEXES            ,  "OID_FDDI_SMT_MAC_INDEXES"          ,     // 36
   OID_FDDI_SMT_BYPASS_PRESENT         ,  "OID_FDDI_SMT_BYPASS_PRESENT"       ,
   OID_FDDI_SMT_ECM_STATE              ,  "OID_FDDI_SMT_ECM_STATE"            ,
   OID_FDDI_SMT_CF_STATE               ,  "OID_FDDI_SMT_CF_STATE"             ,
   OID_FDDI_SMT_HOLD_STATE             ,  "OID_FDDI_SMT_HOLD_STATE"           ,     // 40
   OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG , "OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG",
   OID_FDDI_SMT_STATION_STATUS         ,  "OID_FDDI_SMT_STATION_STATUS"       ,
   OID_FDDI_SMT_PEER_WRAP_FLAG         ,  "OID_FDDI_SMT_PEER_WRAP_FLAG"       ,
   OID_FDDI_SMT_MSG_TIME_STAMP         ,  "OID_FDDI_SMT_MSG_TIME_STAMP"       ,     // 44
   OID_FDDI_SMT_TRANSITION_TIME_STAMP  ,  "OID_FDDI_SMT_TRANSITION_TIME_STAMP",
   OID_FDDI_SMT_SET_COUNT              ,  "OID_FDDI_SMT_SET_COUNT"            ,
   OID_FDDI_SMT_LAST_SET_STATION_ID    ,  "OID_FDDI_SMT_LAST_SET_STATION_ID"  ,


   OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS , "OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS",     // 48
   OID_FDDI_MAC_BRIDGE_FUNCTIONS       ,  "OID_FDDI_MAC_BRIDGE_FUNCTIONS"     ,
   OID_FDDI_MAC_T_MAX_CAPABILITY       ,  "OID_FDDI_MAC_T_MAX_CAPABILITY"     ,
   OID_FDDI_MAC_TVX_CAPABILITY         ,  "OID_FDDI_MAC_TVX_CAPABILITY"       ,
   OID_FDDI_MAC_AVAILABLE_PATHS        ,  "OID_FDDI_MAC_AVAILABLE_PATHS"      ,     // 52
   OID_FDDI_MAC_CURRENT_PATH           ,  "OID_FDDI_MAC_CURRENT_PATH"         ,
   OID_FDDI_MAC_UPSTREAM_NBR           ,  "OID_FDDI_MAC_UPSTREAM_NBR"         ,
   OID_FDDI_MAC_DOWNSTREAM_NBR         ,  "OID_FDDI_MAC_DOWNSTREAM_NBR"       ,
   OID_FDDI_MAC_OLD_UPSTREAM_NBR       ,  "OID_FDDI_MAC_OLD_UPSTREAM_NBR"     ,     // 56
   OID_FDDI_MAC_OLD_DOWNSTREAM_NBR     ,  "OID_FDDI_MAC_OLD_DOWNSTREAM_NBR"   ,
   OID_FDDI_MAC_DUP_ADDRESS_TEST       ,  "OID_FDDI_MAC_DUP_ADDRESS_TEST"     ,
   OID_FDDI_MAC_REQUESTED_PATHS        ,  "OID_FDDI_MAC_REQUESTED_PATHS"      ,
   OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE   ,  "OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE" ,     // 60
   OID_FDDI_MAC_INDEX                  ,  "OID_FDDI_MAC_INDEX"                ,
   OID_FDDI_MAC_SMT_ADDRESS            ,  "OID_FDDI_MAC_SMT_ADDRESS"          ,
   OID_FDDI_MAC_LONG_GRP_ADDRESS       ,  "OID_FDDI_MAC_LONG_GRP_ADDRESS"     ,
   OID_FDDI_MAC_SHORT_GRP_ADDRESS      ,  "OID_FDDI_MAC_SHORT_GRP_ADDRESS"    ,     // 64
   OID_FDDI_MAC_T_REQ                  ,  "OID_FDDI_MAC_T_REQ"                ,
   OID_FDDI_MAC_T_NEG                  ,  "OID_FDDI_MAC_T_NEG"                ,
   OID_FDDI_MAC_T_MAX                  ,  "OID_FDDI_MAC_T_MAX"                ,
   OID_FDDI_MAC_TVX_VALUE              ,  "OID_FDDI_MAC_TVX_VALUE"            ,     // 68
   OID_FDDI_MAC_T_PRI0                 ,  "OID_FDDI_MAC_T_PRI0"               ,
   OID_FDDI_MAC_T_PRI1                 ,  "OID_FDDI_MAC_T_PRI1"               ,
   OID_FDDI_MAC_T_PRI2                 ,  "OID_FDDI_MAC_T_PRI2"               ,
   OID_FDDI_MAC_T_PRI3                 ,  "OID_FDDI_MAC_T_PRI3"               ,     // 72
   OID_FDDI_MAC_T_PRI4                 ,  "OID_FDDI_MAC_T_PRI4"               ,
   OID_FDDI_MAC_T_PRI5                 ,  "OID_FDDI_MAC_T_PRI5"               ,
   OID_FDDI_MAC_T_PRI6                 ,  "OID_FDDI_MAC_T_PRI6"               ,
   OID_FDDI_MAC_FRAME_CT               ,  "OID_FDDI_MAC_FRAME_CT"             ,     // 76
   OID_FDDI_MAC_COPIED_CT              ,  "OID_FDDI_MAC_COPIED_CT"            ,
   OID_FDDI_MAC_TRANSMIT_CT            ,  "OID_FDDI_MAC_TRANSMIT_CT"          ,
   OID_FDDI_MAC_TOKEN_CT               ,  "OID_FDDI_MAC_TOKEN_CT"             ,
   OID_FDDI_MAC_ERROR_CT               ,  "OID_FDDI_MAC_ERROR_CT"             ,     // 80
   OID_FDDI_MAC_LOST_CT                ,  "OID_FDDI_MAC_LOST_CT"              ,
   OID_FDDI_MAC_TVX_EXPIRED_CT         ,  "OID_FDDI_MAC_TVX_EXPIRED_CT"       ,
   OID_FDDI_MAC_NOT_COPIED_CT          ,  "OID_FDDI_MAC_NOT_COPIED_CT"        ,
   OID_FDDI_MAC_LATE_CT                ,  "OID_FDDI_MAC_LATE_CT"              ,     // 84
   OID_FDDI_MAC_RING_OP_CT             ,  "OID_FDDI_MAC_RING_OP_CT"           ,
   OID_FDDI_MAC_FRAME_ERROR_THRESHOLD  ,  "OID_FDDI_MAC_FRAME_ERROR_THRESHOLD",
   OID_FDDI_MAC_FRAME_ERROR_RATIO      ,  "OID_FDDI_MAC_FRAME_ERROR_RATIO"    ,
   OID_FDDI_MAC_NOT_COPIED_THRESHOLD   ,  "OID_FDDI_MAC_NOT_COPIED_THRESHOLD" ,     // 88
   OID_FDDI_MAC_NOT_COPIED_RATIO       ,  "OID_FDDI_MAC_NOT_COPIED_RATIO"     ,
   OID_FDDI_MAC_RMT_STATE              ,  "OID_FDDI_MAC_RMT_STATE"            ,
   OID_FDDI_MAC_DA_FLAG                ,  "OID_FDDI_MAC_DA_FLAG"              ,
   OID_FDDI_MAC_UNDA_FLAG              ,  "OID_FDDI_MAC_UNDA_FLAG"            ,     // 92
   OID_FDDI_MAC_FRAME_ERROR_FLAG       ,  "OID_FDDI_MAC_FRAME_ERROR_FLAG"     ,
   OID_FDDI_MAC_NOT_COPIED_FLAG        ,  "OID_FDDI_MAC_NOT_COPIED_FLAG"      ,
   OID_FDDI_MAC_MA_UNITDATA_AVAILABLE  ,  "OID_FDDI_MAC_MA_UNITDATA_AVAILABLE",
   OID_FDDI_MAC_HARDWARE_PRESENT       ,  "OID_FDDI_MAC_HARDWARE_PRESENT"     ,     // 96
   OID_FDDI_MAC_MA_UNITDATA_ENABLE     ,  "OID_FDDI_MAC_MA_UNITDATA_ENABLE"   ,

   

   OID_FDDI_PATH_INDEX                 ,  "OID_FDDI_PATH_INDEX"               ,
   OID_FDDI_PATH_RING_LATENCY          ,  "OID_FDDI_PATH_RING_LATENCY"        ,
   OID_FDDI_PATH_TRACE_STATUS          ,  "OID_FDDI_PATH_TRACE_STATUS"        ,     // 100
   OID_FDDI_PATH_SBA_PAYLOAD           ,  "OID_FDDI_PATH_SBA_PAYLOAD"         ,
   OID_FDDI_PATH_SBA_OVERHEAD          ,  "OID_FDDI_PATH_SBA_OVERHEAD"        ,
   OID_FDDI_PATH_CONFIGURATION         ,  "OID_FDDI_PATH_CONFIGURATION"       ,
   OID_FDDI_PATH_T_R_MODE              ,  "OID_FDDI_PATH_T_R_MODE"            ,     // 104
   OID_FDDI_PATH_SBA_AVAILABLE         ,  "OID_FDDI_PATH_SBA_AVAILABLE"       ,
   OID_FDDI_PATH_TVX_LOWER_BOUND       ,  "OID_FDDI_PATH_TVX_LOWER_BOUND"     ,
   OID_FDDI_PATH_T_MAX_LOWER_BOUND     ,  "OID_FDDI_PATH_T_MAX_LOWER_BOUND"   ,
   OID_FDDI_PATH_MAX_T_REQ             ,  "OID_FDDI_PATH_MAX_T_REQ"           ,     // 108

   OID_FDDI_PORT_MY_TYPE               ,  "OID_FDDI_PORT_MY_TYPE"             ,
   OID_FDDI_PORT_NEIGHBOR_TYPE         ,  "OID_FDDI_PORT_NEIGHBOR_TYPE"       ,
   OID_FDDI_PORT_CONNECTION_POLICIES   ,  "OID_FDDI_PORT_CONNECTION_POLICIES" ,
   OID_FDDI_PORT_MAC_INDICATED         ,  "OID_FDDI_PORT_MAC_INDICATED"       ,     // 112
   OID_FDDI_PORT_CURRENT_PATH          ,  "OID_FDDI_PORT_CURRENT_PATH"        ,
   OID_FDDI_PORT_REQUESTED_PATHS       ,  "OID_FDDI_PORT_REQUESTED_PATHS"     ,
   OID_FDDI_PORT_MAC_PLACEMENT         ,  "OID_FDDI_PORT_MAC_PLACEMENT"       ,
   OID_FDDI_PORT_AVAILABLE_PATHS       ,  "OID_FDDI_PORT_AVAILABLE_PATHS"     ,     // 116
   OID_FDDI_PORT_MAC_LOOP_TIME         ,  "OID_FDDI_PORT_MAC_LOOP_TIME"       ,
   OID_FDDI_PORT_PMD_CLASS             ,  "OID_FDDI_PORT_PMD_CLASS"           ,
   OID_FDDI_PORT_CONNECTION_CAPABILITIES  ,  "OID_FDDI_PORT_CONNECTION_CAPABILITIES",
   OID_FDDI_PORT_INDEX                 ,  "OID_FDDI_PORT_INDEX"               ,     // 120
   OID_FDDI_PORT_MAINT_LS              ,  "OID_FDDI_PORT_MAINT_LS"            ,
   OID_FDDI_PORT_BS_FLAG               ,  "OID_FDDI_PORT_BS_FLAG"             ,
   OID_FDDI_PORT_PC_LS                 ,  "OID_FDDI_PORT_PC_LS"               ,
   OID_FDDI_PORT_EB_ERROR_CT           ,  "OID_FDDI_PORT_EB_ERROR_CT"         ,     // 124
   OID_FDDI_PORT_LCT_FAIL_CT           ,  "OID_FDDI_PORT_LCT_FAIL_CT"         ,
   OID_FDDI_PORT_LER_ESTIMATE          ,  "OID_FDDI_PORT_LER_ESTIMATE"        ,
   OID_FDDI_PORT_LEM_REJECT_CT         ,  "OID_FDDI_PORT_LEM_REJECT_CT"       ,
   OID_FDDI_PORT_LEM_CT                ,  "OID_FDDI_PORT_LEM_CT"              ,     // 128
   OID_FDDI_PORT_LER_CUTOFF            ,  "OID_FDDI_PORT_LER_CUTOFF"          ,
   OID_FDDI_PORT_LER_ALARM             ,  "OID_FDDI_PORT_LER_ALARM"           ,
   OID_FDDI_PORT_CONNNECT_STATE        ,  "OID_FDDI_PORT_CONNNECT_STATE"      ,
   OID_FDDI_PORT_PCM_STATE             ,  "OID_FDDI_PORT_PCM_STATE"           ,     // 132
   OID_FDDI_PORT_PC_WITHHOLD           ,  "OID_FDDI_PORT_PC_WITHHOLD"         ,
   OID_FDDI_PORT_LER_FLAG              ,  "OID_FDDI_PORT_LER_FLAG"            ,
   OID_FDDI_PORT_HARDWARE_PRESENT      ,  "OID_FDDI_PORT_HARDWARE_PRESENT"    ,

   
   OID_FDDI_SMT_STATION_ACTION         ,  "OID_FDDI_SMT_STATION_ACTION"       ,     // 136
   OID_FDDI_PORT_ACTION                ,  "OID_FDDI_PORT_ACTION"              ,


   OID_FDDI_IF_DESCR                   ,  "OID_FDDI_IF_DESCR"                 ,
   OID_FDDI_IF_TYPE                    ,  "OID_FDDI_IF_TYPE"                  ,
   OID_FDDI_IF_MTU                     ,  "OID_FDDI_IF_MTU"                   ,     // 140
   OID_FDDI_IF_SPEED                   ,  "OID_FDDI_IF_SPEED"                 ,
   OID_FDDI_IF_PHYS_ADDRESS            ,  "OID_FDDI_IF_PHYS_ADDRESS"          ,
   OID_FDDI_IF_ADMIN_STATUS            ,  "OID_FDDI_IF_ADMIN_STATUS"          ,
   OID_FDDI_IF_OPER_STATUS             ,  "OID_FDDI_IF_OPER_STATUS"           ,     // 144
   OID_FDDI_IF_LAST_CHANGE             ,  "OID_FDDI_IF_LAST_CHANGE"           ,
   OID_FDDI_IF_IN_OCTETS               ,  "OID_FDDI_IF_IN_OCTETS"             ,
   OID_FDDI_IF_IN_UCAST_PKTS           ,  "OID_FDDI_IF_IN_UCAST_PKTS"         ,
   OID_FDDI_IF_IN_NUCAST_PKTS          ,  "OID_FDDI_IF_IN_NUCAST_PKTS"        ,     // 148
   OID_FDDI_IF_IN_DISCARDS             ,  "OID_FDDI_IF_IN_DISCARDS"           ,
   OID_FDDI_IF_IN_ERRORS               ,  "OID_FDDI_IF_IN_ERRORS"             ,
   OID_FDDI_IF_IN_UNKNOWN_PROTOS       ,  "OID_FDDI_IF_IN_UNKNOWN_PROTOS"     ,
   OID_FDDI_IF_OUT_OCTETS              ,  "OID_FDDI_IF_OUT_OCTETS"            ,     // 152
   OID_FDDI_IF_OUT_UCAST_PKTS          ,  "OID_FDDI_IF_OUT_UCAST_PKTS"        ,
   OID_FDDI_IF_OUT_NUCAST_PKTS         ,  "OID_FDDI_IF_OUT_NUCAST_PKTS"       ,
   OID_FDDI_IF_OUT_DISCARDS            ,  "OID_FDDI_IF_OUT_DISCARDS"          ,
   OID_FDDI_IF_OUT_ERRORS              ,  "OID_FDDI_IF_OUT_ERRORS"            ,     // 156
   OID_FDDI_IF_OUT_QLEN                ,  "OID_FDDI_IF_OUT_QLEN"              ,
   OID_FDDI_IF_SPECIFIC                ,  "OID_FDDI_IF_SPECIFIC"              ,     // 158


   //
   // WAN objects
   //

   OID_WAN_PERMANENT_ADDRESS           ,  "OID_WAN_PERMANENT_ADDRESS"         ,     // 1
   OID_WAN_CURRENT_ADDRESS             ,  "OID_WAN_CURRENT_ADDRESS"           ,
   OID_WAN_QUALITY_OF_SERVICE          ,  "OID_WAN_QUALITY_OF_SERVICE"        ,
   OID_WAN_PROTOCOL_TYPE               ,  "OID_WAN_PROTOCOL_TYPE"             ,     // 4
   OID_WAN_MEDIUM_SUBTYPE              ,  "OID_WAN_MEDIUM_SUBTYPE"            ,
   OID_WAN_HEADER_FORMAT               ,  "OID_WAN_HEADER_FORMAT"             ,
   OID_WAN_GET_INFO                    ,  "OID_WAN_GET_INFO"                  ,
   OID_WAN_SET_LINK_INFO               ,  "OID_WAN_SET_LINK_INFO"             ,     // 8
   OID_WAN_GET_LINK_INFO               ,  "OID_WAN_GET_LINK_INFO"             ,
   OID_WAN_LINE_COUNT                  ,  "OID_WAN_LINE_COUNT"                ,

   OID_WAN_GET_BRIDGE_INFO             ,  "OID_WAN_GET_BRIDGE_INFO"           ,
   OID_WAN_SET_BRIDGE_INFO             ,  "OID_WAN_SET_BRIDGE_INFO"           ,     // 12
   OID_WAN_GET_COMP_INFO               ,  "OID_WAN_GET_COMP_INFO"             ,
   OID_WAN_SET_COMP_INFO               ,  "OID_WAN_SET_COMP_INFO"             ,
   OID_WAN_GET_STATS_INFO              ,  "OID_WAN_GET_STATS_INFO"            ,     // 15

   
   //
   // ARCNET objects
   //
   OID_ARCNET_PERMANENT_ADDRESS        ,  "OID_ARCNET_PERMANENT_ADDRESS"      ,     // 1
   OID_ARCNET_CURRENT_ADDRESS          ,  "OID_ARCNET_CURRENT_ADDRESS"        ,
   OID_ARCNET_RECONFIGURATIONS         ,  "OID_ARCNET_RECONFIGURATIONS"       ,     // 3
   //
   // ATM objects
   //
   OID_ATM_SUPPORTED_VC_RATES          ,  "OID_ATM_SUPPORTED_VC_RATES"        ,     // 1
   OID_ATM_SUPPORTED_SERVICE_CATEGORY  ,  "OID_ATM_SUPPORTED_SERVICE_CATEGORY",
   OID_ATM_SUPPORTED_AAL_TYPES         ,  "OID_ATM_SUPPORTED_AAL_TYPES"       ,
   OID_ATM_HW_CURRENT_ADDRESS          ,  "OID_ATM_HW_CURRENT_ADDRESS"        ,     // 4
   OID_ATM_MAX_ACTIVE_VCS              ,  "OID_ATM_MAX_ACTIVE_VCS"            ,
   OID_ATM_MAX_ACTIVE_VCI_BITS         ,  "OID_ATM_MAX_ACTIVE_VCI_BITS"       ,
   OID_ATM_MAX_ACTIVE_VPI_BITS         ,  "OID_ATM_MAX_ACTIVE_VPI_BITS"       ,
   OID_ATM_MAX_AAL0_PACKET_SIZE        ,  "OID_ATM_MAX_AAL0_PACKET_SIZE"      ,     // 8
   OID_ATM_MAX_AAL1_PACKET_SIZE        ,  "OID_ATM_MAX_AAL1_PACKET_SIZE"      ,
   OID_ATM_MAX_AAL34_PACKET_SIZE       ,  "OID_ATM_MAX_AAL34_PACKET_SIZE"     ,
   OID_ATM_MAX_AAL5_PACKET_SIZE        ,  "OID_ATM_MAX_AAL5_PACKET_SIZE"      ,

   OID_ATM_SIGNALING_VPIVCI            ,  "OID_ATM_SIGNALING_VPIVCI"          ,     // 12
   OID_ATM_ASSIGNED_VPI                ,  "OID_ATM_ASSIGNED_VPI"              ,
   OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES,  "OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES" ,
   OID_ATM_RELEASE_ACCESS_NET_RESOURCES,  "OID_ATM_RELEASE_ACCESS_NET_RESOURCES" ,
   OID_ATM_ILMI_VPIVCI                 ,  "OID_ATM_ILMI_VPIVCI"               ,     // 16
   OID_ATM_DIGITAL_BROADCAST_VPIVCI    ,  "OID_ATM_DIGITAL_BROADCAST_VPIVCI"  ,
   OID_ATM_GET_NEAREST_FLOW            ,  "OID_ATM_GET_NEAREST_FLOW"          ,
   OID_ATM_ALIGNMENT_REQUIRED          ,  "OID_ATM_ALIGNMENT_REQUIRED"        ,
// OID_ATM_LECS_ADDRESS???
   OID_ATM_SERVICE_ADDRESS             ,  "OID_ATM_SERVICE_ADDRESS"           ,     // 20

   OID_ATM_RCV_CELLS_OK                ,  "OID_ATM_RCV_CELLS_OK"              ,
   OID_ATM_XMIT_CELLS_OK               ,  "OID_ATM_XMIT_CELLS_OK"             ,
   OID_ATM_RCV_CELLS_DROPPED           ,  "OID_ATM_RCV_CELLS_DROPPED"         ,

   OID_ATM_RCV_INVALID_VPI_VCI         ,  "OID_ATM_RCV_INVALID_VPI_VCI"       ,     // 24
   OID_ATM_CELLS_HEC_ERROR             ,  "OID_ATM_CELLS_HEC_ERROR"           ,
   OID_ATM_RCV_REASSEMBLY_ERROR        ,  "OID_ATM_RCV_REASSEMBLY_ERROR"      ,     // 26


   //
   // PCCA (Wireless) objects
   //
   // All WirelessWAN devices must support the following OIDs
   //
   OID_WW_GEN_NETWORK_TYPES_SUPPORTED  ,  "OID_WW_GEN_NETWORK_TYPES_SUPPORTED"   ,  // 1
   OID_WW_GEN_NETWORK_TYPE_IN_USE      ,  "OID_WW_GEN_NETWORK_TYPE_IN_USE"       ,
   OID_WW_GEN_HEADER_FORMATS_SUPPORTED ,  "OID_WW_GEN_HEADER_FORMATS_SUPPORTED"  ,
   OID_WW_GEN_HEADER_FORMAT_IN_USE     ,  "OID_WW_GEN_HEADER_FORMAT_IN_USE"      ,  // 4
   OID_WW_GEN_INDICATION_REQUEST       ,  "OID_WW_GEN_INDICATION_REQUEST"        ,
   OID_WW_GEN_DEVICE_INFO              ,  "OID_WW_GEN_DEVICE_INFO"               ,
   OID_WW_GEN_OPERATION_MODE           ,  "OID_WW_GEN_OPERATION_MODE"            ,
   OID_WW_GEN_LOCK_STATUS              ,  "OID_WW_GEN_LOCK_STATUS"               ,  // 8
   OID_WW_GEN_DISABLE_TRANSMITTER      ,  "OID_WW_GEN_DISABLE_TRANSMITTER"       ,
   OID_WW_GEN_NETWORK_ID               ,  "OID_WW_GEN_NETWORK_ID"                ,
   OID_WW_GEN_PERMANENT_ADDRESS        ,  "OID_WW_GEN_PERMANENT_ADDRESS"         ,
   OID_WW_GEN_CURRENT_ADDRESS          ,  "OID_WW_GEN_CURRENT_ADDRESS"           ,  // 12
   OID_WW_GEN_SUSPEND_DRIVER           ,  "OID_WW_GEN_SUSPEND_DRIVER"            ,
   OID_WW_GEN_BASESTATION_ID           ,  "OID_WW_GEN_BASESTATION_ID"            ,
   OID_WW_GEN_CHANNEL_ID               ,  "OID_WW_GEN_CHANNEL_ID"                ,
   OID_WW_GEN_ENCRYPTION_SUPPORTED     ,  "OID_WW_GEN_ENCRYPTION_SUPPORTED"      ,  // 16
   OID_WW_GEN_ENCRYPTION_IN_USE        ,  "OID_WW_GEN_ENCRYPTION_IN_USE"         ,
   OID_WW_GEN_ENCRYPTION_STATE         ,  "OID_WW_GEN_ENCRYPTION_STATE"          ,
   OID_WW_GEN_CHANNEL_QUALITY          ,  "OID_WW_GEN_CHANNEL_QUALITY"           ,
   OID_WW_GEN_REGISTRATION_STATUS      ,  "OID_WW_GEN_REGISTRATION_STATUS"       ,  // 20
   OID_WW_GEN_RADIO_LINK_SPEED         ,  "OID_WW_GEN_RADIO_LINK_SPEED"          ,
   OID_WW_GEN_LATENCY                  ,  "OID_WW_GEN_LATENCY"                   ,
   OID_WW_GEN_BATTERY_LEVEL            ,  "OID_WW_GEN_BATTERY_LEVEL"             ,
   OID_WW_GEN_EXTERNAL_POWER           ,  "OID_WW_GEN_EXTERNAL_POWER"            ,  // 24

   //
   // Network Dependent OIDs - Mobitex:
   //
   OID_WW_MBX_SUBADDR                  ,  "OID_WW_MBX_SUBADDR"                   ,
   OID_WW_MBX_FLEXLIST                 ,  "OID_WW_MBX_FLEXLIST"                  ,
   OID_WW_MBX_GROUPLIST                ,  "OID_WW_MBX_GROUPLIST"                 ,
   OID_WW_MBX_TRAFFIC_AREA             ,  "OID_WW_MBX_TRAFFIC_AREA"              ,  // 28
   OID_WW_MBX_LIVE_DIE                 ,  "OID_WW_MBX_LIVE_DIE"                  ,
   OID_WW_MBX_TEMP_DEFAULTLIST         ,  "OID_WW_MBX_TEMP_DEFAULTLIST"          ,

   //
   // Network Dependent OIDs - Pinpoint:
   //
   OID_WW_PIN_LOC_AUTHORIZE            ,  "OID_WW_PIN_LOC_AUTHORIZE"             ,
   OID_WW_PIN_LAST_LOCATION            ,  "OID_WW_PIN_LAST_LOCATION"             ,  // 32
   OID_WW_PIN_LOC_FIX                  ,  "OID_WW_PIN_LOC_FIX"                   ,

   
   //
   // Network Dependent - CDPD:
   //
   OID_WW_CDPD_SPNI                    ,  "OID_WW_CDPD_SPNI"                     ,
   OID_WW_CDPD_WASI                    ,  "OID_WW_CDPD_WASI"                     ,
   OID_WW_CDPD_AREA_COLOR              ,  "OID_WW_CDPD_AREA_COLOR"               ,  // 36
   OID_WW_CDPD_TX_POWER_LEVEL          ,  "OID_WW_CDPD_TX_POWER_LEVEL"           ,
   OID_WW_CDPD_EID                     ,  "OID_WW_CDPD_EID"                      ,
   OID_WW_CDPD_HEADER_COMPRESSION      ,  "OID_WW_CDPD_HEADER_COMPRESSION"       ,
   OID_WW_CDPD_DATA_COMPRESSION        ,  "OID_WW_CDPD_DATA_COMPRESSION"         ,  // 40
   OID_WW_CDPD_CHANNEL_SELECT          ,  "OID_WW_CDPD_CHANNEL_SELECT"           ,
   OID_WW_CDPD_CHANNEL_STATE           ,  "OID_WW_CDPD_CHANNEL_STATE"            ,
   OID_WW_CDPD_NEI                     ,  "OID_WW_CDPD_NEI"                      ,
   OID_WW_CDPD_NEI_STATE               ,  "OID_WW_CDPD_NEI_STATE"                ,  // 44
   OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER,  "OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER" ,
   OID_WW_CDPD_SLEEP_MODE              ,  "OID_WW_CDPD_SLEEP_MODE"               ,
   OID_WW_CDPD_CIRCUIT_SWITCHED        ,  "OID_WW_CDPD_CIRCUIT_SWITCHED"         ,
   OID_WW_CDPD_TEI                     ,  "OID_WW_CDPD_TEI"                      ,  // 48
   OID_WW_CDPD_RSSI                    ,  "OID_WW_CDPD_RSSI"                     ,

   //
   // Network Dependent - Ardis:
   //
   OID_WW_ARD_SNDCP                    ,  "OID_WW_ARD_SNDCP"                     ,
   OID_WW_ARD_TMLY_MSG                 ,  "OID_WW_ARD_TMLY_MSG"                  ,
   OID_WW_ARD_DATAGRAM                 ,  "OID_WW_ARD_DATAGRAM"                  ,  // 52

   //
   // Network Dependent - DataTac:
   //
   OID_WW_TAC_COMPRESSION              ,  "OID_WW_TAC_COMPRESSION"               ,
   OID_WW_TAC_SET_CONFIG               ,  "OID_WW_TAC_SET_CONFIG"                ,
   OID_WW_TAC_GET_STATUS               ,  "OID_WW_TAC_GET_STATUS"                ,
   OID_WW_TAC_USER_HEADER              ,  "OID_WW_TAC_USER_HEADER"               ,  // 56

   //
   // Network Dependent - Metricom:
   //
   OID_WW_MET_FUNCTION                 ,  "OID_WW_MET_FUNCTION"                  ,  // 57

      //
   // IRDA objects
   //
   OID_IRDA_RECEIVING                  ,  "OID_IRDA_RECEIVING"                   ,  // 1
   OID_IRDA_TURNAROUND_TIME            ,  "OID_IRDA_TURNAROUND_TIME"             ,
   OID_IRDA_SUPPORTED_SPEEDS           ,  "OID_IRDA_SUPPORTED_SPEEDS"            ,
   OID_IRDA_LINK_SPEED                 ,  "OID_IRDA_LINK_SPEED"                  ,  // 4
   OID_IRDA_MEDIA_BUSY                 ,  "OID_IRDA_MEDIA_BUSY"                  ,

   OID_IRDA_EXTRA_RCV_BOFS             ,  "OID_IRDA_EXTRA_RCV_BOFS"              ,
   OID_IRDA_RATE_SNIFF                 ,  "OID_IRDA_RATE_SNIFF"                  ,
   OID_IRDA_UNICAST_LIST               ,  "OID_IRDA_UNICAST_LIST"                ,  // 8
   OID_IRDA_MAX_UNICAST_LIST_SIZE      ,  "OID_IRDA_MAX_UNICAST_LIST_SIZE"       ,
   OID_IRDA_MAX_RECEIVE_WINDOW_SIZE    ,  "OID_IRDA_MAX_RECEIVE_WINDOW_SIZE"     ,
   OID_IRDA_MAX_SEND_WINDOW_SIZE       ,  "OID_IRDA_MAX_SEND_WINDOW_SIZE"        ,  // 11

   //
   // broadcast pc objects
   //
#ifdef   BROADCAST_PC
#ifdef   OLD_BPC
   OID_DSS_DATA_DEVICES                ,  "OID_DSS_DATA_DEVICES"                 ,
   OID_DSS_TUNING_DEVICES              ,  "OID_DSS_TUNING_DEVICES"               ,
   OID_DSS_DATA_DEVICE_CAPS            ,  "OID_DSS_DATA_DEVICE_CAPS"             ,
   OID_DSS_PROGRAM_GUIDE               ,  "OID_DSS_PROGRAM_GUIDE"                ,  // 4
   OID_DSS_LAST_STATUS                 ,  "OID_DSS_LAST_STATUS"                  ,
   OID_DSS_DATA_DEVICE_SETTINGS        ,  "OID_DSS_DATA_DEVICE_SETTINGS"         ,
   OID_DSS_DATA_DEVICE_CONNECT         ,  "OID_DSS_DATA_DEVICE_CONNECT"          ,
   OID_DSS_DATA_DEVICE_DISCONNECT      ,  "OID_DSS_DATA_DEVICE_DISCONNECT"       ,  // 8
   OID_DSS_DATA_DEVICE_ENABLE          ,  "OID_DSS_DATA_DEVICE_ENABLE"           ,
   OID_DSS_DATA_DEVICE_TUNING          ,  "OID_DSS_DATA_DEVICE_TUNING"           ,
   OID_DSS_CONDITIONAL_ACCESS          ,  "OID_DSS_CONDITIONAL_ACCESS"           ,
   OID_DSS_POOL_RETURN                 ,  "OID_DSS_POOL_RETURN"                  ,  // 12
   OID_DSS_FORCE_RECEIVE               ,  "OID_DSS_FORCE_RECEIVE"                ,
   OID_DSS_SUBSCID_FILTER              ,  "OID_DSS_SUBSCID_FILTER"               ,
   OID_DSS_TUNING_DEVICE_SETTINGS      ,  "OID_DSS_TUNING_DEVICE_SETTINGS"       ,
   OID_DSS_POOL_RESERVE                ,  "OID_DSS_POOL_RESERVE"                 ,  // 16
   OID_DSS_ADAPTER_SPECIFIC            ,  "OID_DSS_ADAPTER_SPECIFIC"             ,  // 17
   0xfedcba98                          ,  "YE_OLD_BOGUS_OID"                     ,  // so I
don't have to update count below
#else
   OID_BPC_ADAPTER_CAPS                ,  "OID_BPC_ADAPTER_CAPS"                 ,  // 1
   OID_BPC_DEVICES                     ,  "OID_BPC_DEVICES"                      ,
   OID_BPC_DEVICE_CAPS                 ,  "OID_BPC_DEVICE_CAPS"                  ,
   OID_BPC_DEVICE_SETTINGS             ,  "OID_BPC_DEVICE_SETTINGS"              ,  // 4
   OID_BPC_CONNECTION_STATUS           ,  "OID_BPC_CONNECTION_STATUS"            ,
   OID_BPC_ADDRESS_COMPARE             ,  "OID_BPC_ADDRESS_COMPARE"              ,
   OID_BPC_PROGRAM_GUIDE               ,  "OID_BPC_PROGRAM_GUIDE"                ,
   OID_BPC_LAST_ERROR                  ,  "OID_BPC_LAST_ERROR"                   ,  // 8
   OID_BPC_POOL                        ,  "OID_BPC_POOL"                         ,
   OID_BPC_PROVIDER_SPECIFIC           ,  "OID_BPC_PROVIDER_SPECIFIC"            ,
   OID_BPC_ADAPTER_SPECIFIC            ,  "OID_BPC_ADAPTER_SPECIFIC"             ,
   OID_BPC_CONNECT                     ,  "OID_BPC_CONNECT"                      ,  // 12
   OID_BPC_COMMIT                      ,  "OID_BPC_COMMIT"                       ,
   OID_BPC_DISCONNECT                  ,  "OID_BPC_DISCONNECT"                   ,
   OID_BPC_CONNECTION_ENABLE           ,  "OID_BPC_CONNECTION_ENABLE"            ,
   OID_BPC_POOL_RESERVE                ,  "OID_BPC_POOL_RESERVE"                 ,  // 16
   OID_BPC_POOL_RETURN                 ,  "OID_BPC_POOL_RETURN"                  ,
   OID_BPC_FORCE_RECEIVE               ,  "OID_BPC_FORCE_RECEIVE"                ,  // 18
#endif
#endif

   //
   //  PnP and PM OIDs
   //
   OID_PNP_CAPABILITIES                ,  "OID_PNP_CAPABILITIES"                 ,  // 1
   OID_PNP_SET_POWER                   ,  "OID_PNP_SET_POWER"                    ,
   OID_PNP_QUERY_POWER                 ,  "OID_PNP_QUERY_POWER"                  ,
   OID_PNP_ADD_WAKE_UP_PATTERN         ,  "OID_PNP_ADD_WAKE_UP_PATTERN"          ,  // 4
   OID_PNP_REMOVE_WAKE_UP_PATTERN      ,  "OID_PNP_REMOVE_WAKE_UP_PATTERN"       ,
   OID_PNP_WAKE_UP_PATTERN_LIST        ,  "OID_PNP_WAKE_UP_PATTERN_LIST"         ,
   OID_PNP_ENABLE_WAKE_UP              ,  "OID_PNP_ENABLE_WAKE_UP"               ,

   //
   //  PnP/PM Statistics (Optional).
   //
   OID_PNP_WAKE_UP_OK                  ,  "OID_PNP_WAKE_UP_OK"                   ,  // 8
   OID_PNP_WAKE_UP_ERROR               ,  "OID_PNP_WAKE_UP_ERROR"                ,  // 9

   //
   // Generic CoNdis Oids.. (note that numbers overlap Generic Oids
   //
   OID_GEN_CO_SUPPORTED_LIST           ,  "OID_GEN_CO_SUPPORTED_LIST"            ,  // 1
   OID_GEN_CO_HARDWARE_STATUS          ,  "OID_GEN_CO_HARDWARE_STATUS"           ,
   OID_GEN_CO_MEDIA_SUPPORTED          ,  "OID_GEN_CO_MEDIA_SUPPORTED"           ,
   OID_GEN_CO_MEDIA_IN_USE             ,  "OID_GEN_CO_MEDIA_IN_USE"              ,  // 4
   OID_GEN_CO_LINK_SPEED               ,  "OID_GEN_CO_LINK_SPEED"                ,
   OID_GEN_CO_VENDOR_ID                ,  "OID_GEN_CO_VENDOR_ID"                 ,
   OID_GEN_CO_VENDOR_DESCRIPTION       ,  "OID_GEN_CO_VENDOR_DESCRIPTION"        ,
   OID_GEN_CO_DRIVER_VERSION           ,  "OID_GEN_CO_DRIVER_VERSION"            ,  // 8
   OID_GEN_CO_PROTOCOL_OPTIONS         ,  "OID_GEN_CO_PROTOCOL_OPTIONS"          ,
   OID_GEN_CO_MAC_OPTIONS              ,  "OID_GEN_CO_MAC_OPTIONS"               ,
   OID_GEN_CO_MEDIA_CONNECT_STATUS     ,  "OID_GEN_CO_MEDIA_CONNECT_STATUS"      ,
   OID_GEN_CO_VENDOR_DRIVER_VERSION    ,  "OID_GEN_CO_VENDOR_DRIVER_VERSION"     ,  // 12
   OID_GEN_CO_MINIMUM_LINK_SPEED       ,  "OID_GEN_CO_MINIMUM_LINK_SPEED"        ,
   OID_GEN_CO_SUPPORTED_GUIDS          ,  "OID_GEN_CO_SUPPORTED_GUIDS"           ,

   OID_GEN_CO_GET_TIME_CAPS            ,  "OID_GEN_CO_GET_TIME_CAPS"             ,
   OID_GEN_CO_GET_NETCARD_TIME         ,  "OID_GEN_CO_GET_NETCARD_TIME"          ,  // 16

   OID_GEN_CO_XMIT_PDUS_OK             ,  "OID_GEN_CO_XMIT_PDUS_OK"              ,
   OID_GEN_CO_RCV_PDUS_OK              ,  "OID_GEN_CO_RCV_PDUS_OK"               ,
   OID_GEN_CO_XMIT_PDUS_ERROR          ,  "OID_GEN_CO_XMIT_PDUS_ERROR"           ,
   OID_GEN_CO_RCV_PDUS_ERROR           ,  "OID_GEN_CO_RCV_PDUS_ERROR"            ,  // 20
   OID_GEN_CO_RCV_PDUS_NO_BUFFER       ,  "OID_GEN_CO_RCV_PDUS_NO_BUFFER"        ,

   OID_GEN_CO_RCV_CRC_ERROR            ,  "OID_GEN_CO_RCV_CRC_ERROR"             ,
   OID_GEN_CO_TRANSMIT_QUEUE_LENGTH    ,  "OID_GEN_CO_TRANSMIT_QUEUE_LENGTH"     ,
   OID_GEN_CO_BYTES_XMIT               ,  "OID_GEN_CO_BYTES_XMIT"                ,  // 24
   OID_GEN_CO_BYTES_RCV                ,  "OID_GEN_CO_BYTES_RCV"                 ,
   OID_GEN_CO_BYTES_XMIT_OUTSTANDING   ,  "OID_GEN_CO_BYTES_XMIT_OUTSTANDING"    ,
   OID_GEN_CO_NETCARD_LOAD             ,  "OID_GEN_CO_NETCARD_LOAD"              ,
   OID_GEN_CO_DEVICE_PROFILE           ,  "OID_GEN_CO_DEVICE_PROFILE"            ,  // 28

   //
   // filter types
   //
   NDIS_PACKET_TYPE_DIRECTED           ,  "DIRECTED"                          ,
   NDIS_PACKET_TYPE_MULTICAST          ,  "MULTICAST"                         ,
   NDIS_PACKET_TYPE_ALL_MULTICAST      ,  "ALLMULTICAST"                      ,
   NDIS_PACKET_TYPE_BROADCAST          ,  "BROADCAST"                         ,
   NDIS_PACKET_TYPE_SOURCE_ROUTING     ,  "SOURCEROUTING"                     ,
   NDIS_PACKET_TYPE_PROMISCUOUS        ,  "PROMISCUOUS"                       ,
   NDIS_PACKET_TYPE_SMT                ,  "SMT"                               ,
   NDIS_PACKET_TYPE_ALL_LOCAL          ,  "ALL_LOCAL"                         ,
   NDIS_PACKET_TYPE_MAC_FRAME          ,  "MACFRAME"                          ,
   NDIS_PACKET_TYPE_FUNCTIONAL         ,  "FUNCTIONAL"                        ,
   NDIS_PACKET_TYPE_ALL_FUNCTIONAL     ,  "ALLFUNCTIONAL"                     ,
   NDIS_PACKET_TYPE_GROUP              ,  "GROUP"                             ,
   0x00000000                          ,  "NONE"                              ,

   //
   // test result returns
   //
   ulTEST_SUCCESSFUL                   ,  "TEST_SUCCESSFUL"                   ,
   ulTEST_WARNED                       ,  "TEST_WARNED"                       ,
   ulTEST_FAILED                       ,  "TEST_FAILED"                       ,
   ulTEST_BLOCKED                      ,  "TEST_BLOCKED"                      ,

   //
   // media types for return to shell
   //
   ulMEDIUM_ETHERNET                   ,  "MEDIUM_ETHERNET"                   ,
   ulMEDIUM_TOKENRING                  ,  "MEDIUM_TOKENRING"                  ,
   ulMEDIUM_FDDI                       ,  "MEDIUM_FDDI"                       ,
   ulMEDIUM_ARCNET                     ,  "MEDIUM_ARCNET"                     ,
   ulMEDIUM_WIRELESSWAN                ,  "MEDIUM_WIRELESSWAN"                ,
   ulMEDIUM_IRDA                       ,  "MEDIUM_IRDA"                       ,
   ulMEDIUM_ATM                        ,  "MEDIUM_ATM"                        ,
   ulMEDIUM_NDISWAN                    ,  "MEDIUM_NDISWAN"                    ,


#ifdef   BROADCAST_PC
   ulMEDIUM_DIX                        ,  "MEDIUM_DIX"                        ,
#endif

   //
   // stress test-type constants
   //
   ulSTRESS_FIXEDSIZE                  ,  "STRESS_FIXEDSIZE"                  ,
   ulSTRESS_RANDOMSIZE                 ,  "STRESS_RANDOMSIZE"                 ,
   ulSTRESS_CYCLICAL                   ,  "STRESS_CYCLICAL"                   ,
   ulSTRESS_SMALLSIZE                  ,  "STRESS_SMALLSIZE"                  ,

   ulSTRESS_RAND                       ,  "STRESS_RAND"                       ,
   ulSTRESS_SMALL                      ,  "STRESS_SMALL"                      ,
   ulSTRESS_ZEROS                      ,  "STRESS_ZEROS"                      ,
   ulSTRESS_ONES                       ,  "STRESS_ONES"                       ,

   ulSTRESS_FULLRESP                   ,  "STRESS_FULLRESP"                   ,
   ulSTRESS_NORESP                     ,  "STRESS_NORESP"                     ,
   ulSTRESS_ACK                        ,  "STRESS_ACK"                        ,
   ulSTRESS_ACK10                      ,  "STRESS_ACK10"                      ,

   ulSTRESS_WINDOW_ON                  ,  "STRESS_WINDOWING_ON"               ,
   ulSTRESS_WINDOW_OFF                 ,  "STRESS_WINDOWING_OFF"              ,

   //
   // perform test-type constants
   //
   ulPERFORM_VERIFYRECEIVES            ,  "PERFORM_VERIFY_RECEIVES"           ,
   ulPERFORM_INDICATE_RCV              ,  "PERFORM_INDICATE_RECEIVES"         ,
   ulPERFORM_SEND                      ,  "PERFORM_SEND"                      ,
   ulPERFORM_BOTH                      ,  "PERFORM_SEND_AND_RECEIVE"          ,
   ulPERFORM_RECEIVE                   ,  "PERFORM_RECEIVE"                   ,

   //
   // priority test-type constants
   //
   ulPRIORITY_TYPE_802_3               ,  "PRIORITY_TYPE_802_3"               ,
   ulPRIORITY_TYPE_802_1P              ,  "PRIORITY_TYPE_802_1P"              ,
   ulPRIORITY_SEND                     ,  "PRIORITY_SEND"                     ,
   ulPRIORITY_SEND_PACKETS             ,  "PRIORITY_SEND_PACKETS"             ,



   //
   // receive option constants
   //
   ulRECEIVE_DEFAULT                   ,  "RECEIVE_DEFAULT"                   ,
   ulRECEIVE_PACKETIGNORE              ,  "RECEIVE_PACKETIGNORE"              ,
   ulRECEIVE_NOCOPY                    ,  "RECEIVE_NOCOPY"                    ,
   ulRECEIVE_TRANSFER                  ,  "RECEIVE_TRANSFER"                  ,
   ulRECEIVE_PARTIAL_TRANSFER          ,  "RECEIVE_PARTIAL_TRANSFER"          ,
   ulRECEIVE_LOCCOPY                   ,  "RECEIVE_LOCCOPY"                   ,
   ulRECEIVE_QUEUE                     ,  "RECEIVE_QUEUE"                     ,
   ulRECEIVE_DOUBLE_QUEUE              ,  "RECEIVE_DOUBLE_QUEUE"              ,
   ulRECEIVE_TRIPLE_QUEUE              ,  "RECEIVE_TRIPLE_QUEUE"              ,
   ulMAX_NDIS30_RECEIVE_OPTION         ,  "MAX_NDIS30_RECEIVE_OPTION"         ,
   ulMAX_NDIS40_RECEIVE_OPTION         ,  "MAX_NDIS40_RECEIVE_OPTION"         ,
   ulRECEIVE_ALLOW_BUSY_NET            ,  "RECEIVE_ALLOW_BUSY_NET"            ,

   //
   // Ndis MAC option bits (OID_GEN_MAC_OPTIONS).
   //

   NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA ,  "NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA"  ,
   NDIS_MAC_OPTION_RECEIVE_SERIALIZED  ,  "NDIS_MAC_OPTION_RECEIVE_SERIALIZED",
   NDIS_MAC_OPTION_TRANSFERS_NOT_PEND  ,  "NDIS_MAC_OPTION_TRANSFERS_NOT_PEND",
   NDIS_MAC_OPTION_NO_LOOPBACK         ,  "NDIS_MAC_OPTION_NO_LOOPBACK"       ,
   NDIS_MAC_OPTION_FULL_DUPLEX         ,  "NDIS_MAC_OPTION_FULL_DUPLEX"       ,
   NDIS_MAC_OPTION_EOTX_INDICATION     ,  "NDIS_MAC_OPTION_EOTX_INDICATION"   ,

   //
   // NDIS.SYS versions
   //
   ulNDIS_VERSION_40                   ,  "NDIS_VERSION_4_0"                  ,
   ulNDIS_VERSION_50                   ,  "NDIS_VERSION_5_0"                  ,

   //
   // operating system constants
   //
   ulINVALID_OS                        ,  "INVALID_OPERATING_SYSTEM"          ,
   ulWINDOWS_NT                        ,  "WINDOWS_NT"                        ,
   ulWINDOWS_95                        ,  "WINDOWS_95"                        ,

   //
   // service types for flowspec
   //
   SERVICETYPE_NOTRAFFIC               ,  "NO_TRAFFIC"                        ,
   SERVICETYPE_BESTEFFORT              ,  "BEST_EFFORT"                       ,
   SERVICETYPE_CONTROLLEDLOAD          ,  "CONTROLLED_LOAD"                   ,
   SERVICETYPE_GUARANTEED              ,  "GUARANTEED"                        ,

   //
   // service types for flowspec
   //
   SERVICETYPE_NOTRAFFIC               ,  "NO_TRAFFIC"                        ,
   SERVICETYPE_BESTEFFORT              ,  "BEST_EFFORT"                       ,
   SERVICETYPE_CONTROLLEDLOAD          ,  "CONTROLLED_LOAD"                   ,
   SERVICETYPE_GUARANTEED              ,  "GUARANTEED"                        ,

   //
   // address families
   //
   0x01                                ,  "ADDRESS_FAMILY_Q2931"              ,
   0x08000                             ,  "ADDRESS_FAMILY_PROXY"              ,

   //
   // atm supported service types
   //
   ATM_SERVICE_CATEGORY_CBR            ,  "CONSTANT_BIT_RATE"                 ,
   ATM_SERVICE_CATEGORY_VBR            ,  "VARIABLE_BIT_RATE"                 ,
   ATM_SERVICE_CATEGORY_UBR            ,  "UNSPECIFIED_BIT_RATE"              ,
   ATM_SERVICE_CATEGORY_ABR            ,  "AVAILABLE_BIT_RATE"                ,

   //
   // AAL TYPES
   //
   AAL_TYPE_AAL0                       ,  "AAL_TYPE_AAL0"                     ,
   AAL_TYPE_AAL1                       ,  "AAL_TYPE_AAL1"                     ,
   AAL_TYPE_AAL34                      ,  "AAL_TYPE_AAL34"                    ,
   AAL_TYPE_AAL5                       ,  "AAL_TYPE_AAL5"                     ,

   //
   // wake up types (used with enablewakeup
   //
   NDIS_PNP_WAKE_UP_MAGIC_PACKET       ,  "WAKE_UP_MAGIC_PACKET"              ,
   NDIS_PNP_WAKE_UP_PATTERN_MATCH      ,  "WAKE_UP_PATTERN_MATCH"             ,
   NDIS_PNP_WAKE_UP_LINK_CHANGE        ,  "WAKE_UP_LINK_CHANGE"               ,

   //
   // ndis status definitions (used with startwaitforevent)
   //
   NDIS_STATUS_RESET_START             ,  "NDIS_STATUS_RESET_START"           ,
   NDIS_STATUS_RESET_END               ,  "NDIS_STATUS_RESET_END"             ,
   NDIS_STATUS_MEDIA_CONNECT           ,  "NDIS_STATUS_MEDIA_CONNECT"         ,
   NDIS_STATUS_MEDIA_DISCONNECT        ,  "NDIS_STATUS_MEDIA_DISCONNECT"      ,
   NDIS_STATUS_WAN_LINE_UP             ,  "NDIS_STATUS_WAN_LINE_UP"           ,
   NDIS_STATUS_WAN_LINE_DOWN           ,  "NDIS_STATUS_WAN_LINE_DOWN"         ,
   NDIS_STATUS_HARDWARE_LINE_UP        ,  "NDIS_STATUS_HARDWARE_LINE_UP"      ,
   NDIS_STATUS_HARDWARE_LINE_DOWN      ,  "NDIS_STATUS_HARDWARE_LINE_DOWN"    ,
   NDIS_STATUS_INTERFACE_UP            ,  "NDIS_STATUS_INTERFACE_UP"          ,
   NDIS_STATUS_INTERFACE_DOWN          ,  "NDIS_STATUS_INTERFACE_DOWN"        ,

   //
   // values in bitmask returned for getpowerstates
   //
   ulHIBERNATE                         ,  "HIBERNATE_SUPPORTED"               ,
   ulSTANDBY                           ,  "STANDBY_SUPPORTED"                 ,
   ulWAKEUPTIMER                       ,  "WAKEUP_TIMER_SUPPORTED"            ,
   //
   // script constants, for which set of tests to do
   // (used in value for G_TestOptions) -- bitmap
   //
   0x00000001                          ,  "DO_FUNCTIONAL_TESTS"               ,
   0x00000002                          ,  "DO_STRESS_TESTS"                   ,
   0x00000004                          ,  "DO_PERFORMANCE_TESTS"              ,
   0x00000008                          ,  "DO_HCT_TESTS"                      ,
   0x00000010                          ,  "DO_RUNTEST"                        ,
   0x00010000                          ,  "ENABLE_VERBOSE_FLAG"               ,
   0x00020000                          ,  "SKIP_1CARD_TESTS"                  ,

#ifdef   BROADCAST_PC
   BPC_MIN_DIM                         ,  "BPC_MIN_DIM"                       ,
#endif

   //
   // end of constants
   //
   0,  0,
};



typedef struct   OID_GUID
{
   ULONG    ulOid;
   const
   GUID     *pGuid;
} OID_GUID;

//
// Max number of OIDs for which a GUID is defined
//

#define MAX_GEN_OID_GUID         25
#define MAX_ETH_OID_GUID          8
#define MAX_TRING_OID_GUID        9
#define MAX_FDDI_OID_GUID        17

//
// Starting position of OIDs for a particular media in pLanOidGuidList array
//
#define ETH_START_INDEX           26
#define TRING_START_INDEX         34
#define FDDI_START_INDEX          43
//
// Media  supported by the card and the count of the no of medium
//

#define MAX_NO_OF_MEDIUM 10
PNDIS_MEDIUM WhichMediums;
int SupportedMediumCount;

//
// GUID list for LAN media
//
OID_GUID pLanOidGuidList[] = {
//
// required general info
//
   OID_GEN_HARDWARE_STATUS       ,  &GUID_NDIS_GEN_HARDWARE_STATUS      ,
   OID_GEN_MEDIA_SUPPORTED       ,  &GUID_NDIS_GEN_MEDIA_SUPPORTED      ,
   OID_GEN_MEDIA_IN_USE          ,  &GUID_NDIS_GEN_MEDIA_IN_USE         ,
   OID_GEN_MAXIMUM_LOOKAHEAD     ,  &GUID_NDIS_GEN_MAXIMUM_LOOKAHEAD    ,
   OID_GEN_MAXIMUM_FRAME_SIZE    ,  &GUID_NDIS_GEN_MAXIMUM_FRAME_SIZE   ,
   OID_GEN_LINK_SPEED            ,  &GUID_NDIS_GEN_LINK_SPEED           ,
   OID_GEN_TRANSMIT_BUFFER_SPACE ,  &GUID_NDIS_GEN_TRANSMIT_BUFFER_SPACE,
   OID_GEN_RECEIVE_BUFFER_SPACE  ,  &GUID_NDIS_GEN_RECEIVE_BUFFER_SPACE ,
   OID_GEN_TRANSMIT_BLOCK_SIZE   ,  &GUID_NDIS_GEN_TRANSMIT_BLOCK_SIZE  ,
   OID_GEN_RECEIVE_BLOCK_SIZE    ,  &GUID_NDIS_GEN_RECEIVE_BLOCK_SIZE   ,
   OID_GEN_VENDOR_ID             ,  &GUID_NDIS_GEN_VENDOR_ID            ,
   OID_GEN_VENDOR_DESCRIPTION    ,  &GUID_NDIS_GEN_VENDOR_DESCRIPTION   ,
   OID_GEN_CURRENT_PACKET_FILTER ,  &GUID_NDIS_GEN_CURRENT_PACKET_FILTER,
   OID_GEN_CURRENT_LOOKAHEAD     ,  &GUID_NDIS_GEN_CURRENT_LOOKAHEAD    ,
   OID_GEN_DRIVER_VERSION        ,  &GUID_NDIS_GEN_DRIVER_VERSION       ,
   OID_GEN_MAXIMUM_TOTAL_SIZE    ,  &GUID_NDIS_GEN_MAXIMUM_TOTAL_SIZE   ,
   OID_GEN_MAC_OPTIONS           ,  &GUID_NDIS_GEN_MAC_OPTIONS          ,
   OID_GEN_MEDIA_CONNECT_STATUS  ,  &GUID_NDIS_GEN_MEDIA_CONNECT_STATUS ,
   OID_GEN_MAXIMUM_SEND_PACKETS  ,  &GUID_NDIS_GEN_MAXIMUM_SEND_PACKETS ,
   OID_GEN_VENDOR_DRIVER_VERSION ,  &GUID_NDIS_GEN_VENDOR_DRIVER_VERSION,
//
// Required general statistics
//
   OID_GEN_XMIT_OK               ,  &GUID_NDIS_GEN_XMIT_OK              ,
   OID_GEN_RCV_OK                ,  &GUID_NDIS_GEN_RCV_OK               ,
   OID_GEN_XMIT_ERROR            ,  &GUID_NDIS_GEN_XMIT_ERROR           ,
   OID_GEN_RCV_ERROR             ,  &GUID_NDIS_GEN_RCV_ERROR            ,
   OID_GEN_RCV_NO_BUFFER         ,  &GUID_NDIS_GEN_RCV_NO_BUFFER        ,
//
// ethernet information
//
   OID_802_3_PERMANENT_ADDRESS      ,  &GUID_NDIS_802_3_PERMANENT_ADDRESS  ,
   OID_802_3_CURRENT_ADDRESS        ,  &GUID_NDIS_802_3_CURRENT_ADDRESS    ,
   OID_802_3_MULTICAST_LIST         ,  &GUID_NDIS_802_3_MULTICAST_LIST     ,
   OID_802_3_MAXIMUM_LIST_SIZE      ,  &GUID_NDIS_802_3_MAXIMUM_LIST_SIZE  ,
   OID_802_3_MAC_OPTIONS            ,  &GUID_NDIS_802_3_MAC_OPTIONS        ,
//
// ethernet statistics
//
   OID_802_3_RCV_ERROR_ALIGNMENT    ,  &GUID_NDIS_802_3_RCV_ERROR_ALIGNMENT,
   OID_802_3_XMIT_ONE_COLLISION     ,  &GUID_NDIS_802_3_XMIT_ONE_COLLISION ,
   OID_802_3_XMIT_MORE_COLLISIONS   ,  &GUID_NDIS_802_3_XMIT_MORE_COLLISIONS  ,
//
// Token-Ring info
//
   OID_802_5_PERMANENT_ADDRESS      ,  &GUID_NDIS_802_5_PERMANENT_ADDRESS  ,
   OID_802_5_CURRENT_ADDRESS        ,  &GUID_NDIS_802_5_CURRENT_ADDRESS    ,
   OID_802_5_CURRENT_FUNCTIONAL     ,  &GUID_NDIS_802_5_CURRENT_FUNCTIONAL ,
   OID_802_5_CURRENT_GROUP          ,  &GUID_NDIS_802_5_CURRENT_GROUP      ,
   OID_802_5_LAST_OPEN_STATUS       ,  &GUID_NDIS_802_5_LAST_OPEN_STATUS   ,
   OID_802_5_CURRENT_RING_STATUS    ,  &GUID_NDIS_802_5_CURRENT_RING_STATUS,
   OID_802_5_CURRENT_RING_STATE     ,  &GUID_NDIS_802_5_CURRENT_RING_STATE ,
//
// token ring statistics
//
   OID_802_5_LINE_ERRORS            ,  &GUID_NDIS_802_5_LINE_ERRORS        ,
   OID_802_5_LOST_FRAMES            ,  &GUID_NDIS_802_5_LOST_FRAMES        ,
//
// FDDI information
//
   OID_FDDI_LONG_PERMANENT_ADDR     ,  &GUID_NDIS_FDDI_LONG_PERMANENT_ADDR ,
   OID_FDDI_LONG_CURRENT_ADDR       ,  &GUID_NDIS_FDDI_LONG_CURRENT_ADDR   ,
   OID_FDDI_LONG_MULTICAST_LIST     ,  &GUID_NDIS_FDDI_LONG_MULTICAST_LIST ,
   OID_FDDI_LONG_MAX_LIST_SIZE      ,  &GUID_NDIS_FDDI_LONG_MAX_LIST_SIZE  ,
   OID_FDDI_SHORT_PERMANENT_ADDR    ,  &GUID_NDIS_FDDI_SHORT_PERMANENT_ADDR,
   OID_FDDI_SHORT_CURRENT_ADDR      ,  &GUID_NDIS_FDDI_SHORT_CURRENT_ADDR  ,
   OID_FDDI_SHORT_MULTICAST_LIST    ,  &GUID_NDIS_FDDI_SHORT_MULTICAST_LIST,
   OID_FDDI_SHORT_MAX_LIST_SIZE     ,  &GUID_NDIS_FDDI_SHORT_MAX_LIST_SIZE ,
//
// FDDI statistics
//

   OID_FDDI_ATTACHMENT_TYPE         ,  &GUID_NDIS_FDDI_ATTACHMENT_TYPE     ,
   OID_FDDI_UPSTREAM_NODE_LONG      ,  &GUID_NDIS_FDDI_UPSTREAM_NODE_LONG  ,
   OID_FDDI_DOWNSTREAM_NODE_LONG    ,  &GUID_NDIS_FDDI_DOWNSTREAM_NODE_LONG,
   OID_FDDI_FRAME_ERRORS            ,  &GUID_NDIS_FDDI_FRAME_ERRORS        ,
   OID_FDDI_FRAMES_LOST             ,  &GUID_NDIS_FDDI_FRAMES_LOST         ,
   OID_FDDI_RING_MGT_STATE          ,  &GUID_NDIS_FDDI_RING_MGT_STATE      ,
   OID_FDDI_LCT_FAILURES            ,  &GUID_NDIS_FDDI_LCT_FAILURES        ,
   OID_FDDI_LEM_REJECTS             ,  &GUID_NDIS_FDDI_LEM_REJECTS         ,
   OID_FDDI_LCONNECTION_STATE       ,  &GUID_NDIS_FDDI_LCONNECTION_STATE   ,
};

//
// GUID list for ATM (CoNdis) media
//
OID_GUID    pAtmOidGuidList[] = {
//
// required CoNdis info
//
   OID_GEN_CO_HARDWARE_STATUS    ,  &GUID_NDIS_GEN_CO_HARDWARE_STATUS   ,
   OID_GEN_CO_MEDIA_SUPPORTED    ,  &GUID_NDIS_GEN_CO_MEDIA_SUPPORTED   ,
   OID_GEN_CO_MEDIA_IN_USE       ,  &GUID_NDIS_GEN_CO_MEDIA_IN_USE      ,
   OID_GEN_CO_LINK_SPEED         ,  &GUID_NDIS_GEN_CO_LINK_SPEED        ,
   OID_GEN_CO_VENDOR_ID          ,  &GUID_NDIS_GEN_CO_VENDOR_ID         ,
   OID_GEN_CO_VENDOR_DESCRIPTION ,  &GUID_NDIS_GEN_CO_VENDOR_DESCRIPTION   ,
   OID_GEN_CO_DRIVER_VERSION     ,  &GUID_NDIS_GEN_CO_DRIVER_VERSION    ,
   OID_GEN_CO_MAC_OPTIONS        ,  &GUID_NDIS_GEN_CO_MAC_OPTIONS       ,
   OID_GEN_CO_MEDIA_CONNECT_STATUS, &GUID_NDIS_GEN_CO_MEDIA_CONNECT_STATUS ,
   OID_GEN_CO_VENDOR_DRIVER_VERSION,&GUID_NDIS_GEN_CO_VENDOR_DRIVER_VERSION,
   OID_GEN_CO_MINIMUM_LINK_SPEED ,  &GUID_NDIS_GEN_CO_MINIMUM_LINK_SPEED,
//
// required condis stats
//
   OID_GEN_CO_XMIT_PDUS_OK       ,  &GUID_NDIS_GEN_CO_XMIT_PDUS_OK         ,
   OID_GEN_CO_RCV_PDUS_OK        ,  &GUID_NDIS_GEN_CO_RCV_PDUS_OK          ,
   OID_GEN_CO_XMIT_PDUS_ERROR    ,  &GUID_NDIS_GEN_CO_XMIT_PDUS_ERROR      ,
   OID_GEN_CO_RCV_PDUS_ERROR     ,  &GUID_NDIS_GEN_CO_RCV_PDUS_ERROR       ,
   OID_GEN_CO_RCV_PDUS_NO_BUFFER ,  &GUID_NDIS_GEN_CO_RCV_PDUS_NO_BUFFER   ,

//
// ATM information
//
   OID_ATM_SUPPORTED_VC_RATES       ,  &GUID_NDIS_ATM_SUPPORTED_VC_RATES   ,
   OID_ATM_SUPPORTED_SERVICE_CATEGORY, &GUID_NDIS_ATM_SUPPORTED_SERVICE_CATEGORY ,
   OID_ATM_SUPPORTED_AAL_TYPES      ,  &GUID_NDIS_ATM_SUPPORTED_AAL_TYPES  ,
   OID_ATM_HW_CURRENT_ADDRESS       ,  &GUID_NDIS_ATM_HW_CURRENT_ADDRESS   ,
   OID_ATM_MAX_ACTIVE_VCS           ,  &GUID_NDIS_ATM_MAX_ACTIVE_VCS       ,
   OID_ATM_MAX_ACTIVE_VCI_BITS      ,  &GUID_NDIS_ATM_MAX_ACTIVE_VCI_BITS  ,
   OID_ATM_MAX_ACTIVE_VPI_BITS      ,  &GUID_NDIS_ATM_MAX_ACTIVE_VPI_BITS  ,
   OID_ATM_MAX_AAL0_PACKET_SIZE     ,  &GUID_NDIS_ATM_MAX_AAL0_PACKET_SIZE ,
   OID_ATM_MAX_AAL1_PACKET_SIZE     ,  &GUID_NDIS_ATM_MAX_AAL1_PACKET_SIZE ,
   OID_ATM_MAX_AAL34_PACKET_SIZE    ,  &GUID_NDIS_ATM_MAX_AAL34_PACKET_SIZE,
   OID_ATM_MAX_AAL5_PACKET_SIZE     ,  &GUID_NDIS_ATM_MAX_AAL5_PACKET_SIZE ,
//
// ATM STATS
//
   OID_ATM_RCV_CELLS_OK             ,  &GUID_NDIS_ATM_RCV_CELLS_OK         ,
   OID_ATM_XMIT_CELLS_OK            ,  &GUID_NDIS_ATM_XMIT_CELLS_OK        ,
   OID_ATM_RCV_CELLS_DROPPED        ,  &GUID_NDIS_ATM_RCV_CELLS_DROPPED
};


//
// GUID list for status indications
//
OID_GUID    pStatusGuidList[] = {

   NDIS_STATUS_RESET_START          ,  &GUID_NDIS_STATUS_RESET_START       ,
   NDIS_STATUS_RESET_END            ,  &GUID_NDIS_STATUS_RESET_END         ,
   NDIS_STATUS_MEDIA_CONNECT        ,  &GUID_NDIS_STATUS_MEDIA_CONNECT     ,
   NDIS_STATUS_MEDIA_DISCONNECT     ,  &GUID_NDIS_STATUS_MEDIA_DISCONNECT  ,
   NDIS_STATUS_MEDIA_SPECIFIC_INDICATION  ,  &GUID_NDIS_STATUS_MEDIA_SPECIFIC_INDICATION,
   NDIS_STATUS_LINK_SPEED_CHANGE    ,  &GUID_NDIS_STATUS_LINK_SPEED_CHANGE
};


const ULONG ulStatusListSize = sizeof(pStatusGuidList) / sizeof(OID_GUID);
HINSTANCE         hNdtWmiLib;

WMI_OPEN          pWmiOpenBlock;
WMI_CLOSE         pWmiCloseBlock;
WMI_QUERYALL      pWmiQueryAllData;
WMI_QUERYSINGLE   pWmiQuerySingleInstance;
WMI_NOTIFY        pWmiNotificationRegistration;

#define ulNETWORK_ADDRESS_LENGTH        6
#define ulMAX_INFOBUFFER_BYTES         (ulNETWORK_ADDRESS_LENGTH * 256)


BOOLEAN        gfUseCoNdisOids = FALSE;

#define ulFUNCTIONAL_ADDRESS_LENGTH     4

#define ulOID_STATS_MASK      0x00030000
#define ulOID_QUERYSMT        0x00030000


struct   NETADDR
{
   UCHAR    padrNet[ulNETWORK_ADDRESS_LENGTH];
   UCHAR    ucSubType;
};


typedef struct NETADDR   *PNETADDR;


#define ulNumGenOids       45
#define ulNumEthOids       15
#define ulNumTrOids        16
#define ulNumFddiOids      158
#define ulNumArcnetOids    3
#define ulNumAtmOids       26
#define ulNumWirelessOids  57
#define ulNumIrdaOids      11
#define ulNumCoGenOids     28
#define ulNumNdisWanOids   15
#define ulNumPnpOids       9

CONSTANT_ENTRY *pceOidEntry = &NdisTestConstantTable[0];
ULONG          ulOidEntryLength  = ulNumGenOids
                                 + ulNumEthOids
                                 + ulNumTrOids
                                 + ulNumFddiOids
                                 + ulNumArcnetOids
                                 + ulNumAtmOids
                                 + ulNumNdisWanOids
                                 + ulNumWirelessOids
#ifdef   BROADCAST_PC
                                 + ulNumDssOids
#endif
                                 + ulNumPnpOids
                                 + ulNumIrdaOids;

CONSTANT_ENTRY *pceCoOidEntry = &NdisTestConstantTable[ulNumGenOids];
ULONG          ulCoOidEntryLength = ulNumCoGenOids
                                  + ulNumEthOids
                                  + ulNumTrOids
                                  + ulNumFddiOids
                                  + ulNumArcnetOids
                                  + ulNumAtmOids
                                  + ulNumNdisWanOids
                                  + ulNumWirelessOids
#ifdef   BROADCAST_PC
                                  + ulNumDssOids
#endif
                                  + ulNumPnpOids
                                  + ulNumIrdaOids;


#define ulNEED_TYPE_INVALID   0
#define ulNEED_FUNCT_ADDR     1
#define ulNEED_FULL_ADDR      2
#define ulNEED_WORD           3
#define ulNEED_DWORD          4
#define ulNEED_ARCNET_ADDR    5
#define ulNEED_SHORT_ADDR     6
#define ulNEED_GUID           7

#define ulELEMENT_ARG         3

//
// OID-related constants
// most significant byte = media type
//


#define ulOID_MEDIA_MASK      0xFF000000
#define ulOID_ALL_MEDIA       0x00000000
#define ulOID_ETHERNET        0x01000000
#define ulOID_TOKENRING       0x02000000
#define ulOID_FDDI            0x03000000
#define ulOID_ARCNET          0x06000000
#define ulOID_ATM             0x08000000
#define ulOID_WIRELESSWAN     0x09000000
#define ulOID_IRDA            0x0A000000
#define ulOID_PNP_POWER       0xFD000000
#define ulOID_PRIVATE         0xFF000000

#ifdef   BROADCAST_PC
#define ulMEDIUM_DIX          0x09
#endif


#define  NDT_STATUS_NO_SERVERS            ((NDIS_STATUS)0x4001FFFFL)
#define  NDT_STATUS_TIMEDOUT              ((NDIS_STATUS)0x4001FFFDL)

//
// Sturctures used in looking up what media specific oids must be queried
//

typedef struct _MEDIA_OID_TABLE {
  NDIS_MEDIUM medium;
  int         start_index; // starting index of the media specific oids in pLanOidGuidList
  int         max_oids;
} MEDIA_OID_TABLE, *PMEDIA_OID_TABLE;

MEDIA_OID_TABLE pMediaOidTable[] = {
//  medium, starting position in the array, max no of oids
    NdisMedium802_3, ETH_START_INDEX, MAX_ETH_OID_GUID,
    NdisMedium802_5, TRING_START_INDEX, MAX_TRING_OID_GUID,
    NdisMediumFddi, FDDI_START_INDEX, MAX_FDDI_OID_GUID,
};

#define MAX_MEDIA_OID_TABLE_ENTRY            3

/*=========================< ndis test - macros >============================*/

#define PRINT(_args_)                  \
   {                                   \
         HapiPrint _args_;             \
   }

#define  IS_NETADDR(arg)    (argv[arg]->ulTypeId == ulNETADDR_TYPE)   
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\nettest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      nettest.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information.
//--

//
// Common include files.
//
#include "precomp.h"

#include "ipxtest.h"
#include "ipcfgtest.h"
#include "machine.h"
#include "global.h"
#include "crtdbg.h"
#include <locale.h>


//////////////////////////////////////////////////////////////////////////////
//
// Globals
//
//////////////////////////////////////////////////////////////////////////////

const TCHAR   c_szLogFileName[] = _T("NetDiag.log");

//BOOL IpConfigCalled = FALSE;
//BOOL ProblemBased   = FALSE;
int  ProblemNumber;


//
// New functions for displaying routing table - Rajkumar
//

#define WILD_CARD (ULONG)(-1)
#define ROUTE_DATA_STRING_SIZE 300
#define MAX_METRIC 9999
#define ROUTE_SEPARATOR ','

int match( const char * p, const char * s );





// Replaced by pResults->IpConfig.pFixedInfo
//PFIXED_INFO GlobalIpconfigFixedInfo = NULL;

// Replaced by per-adapter info, pResults->pArrayInterface[i].IpConfig
//PADAPTER_INFO GlobalIpconfigAdapterInfo = NULL;

// Replaced by per-adapter info, pResults->pArrayInterface[i].IpConfig.pAdapterInfo
//PIP_ADAPTER_INFO IpGlobalIpconfigAdapterInfo = NULL;

// See pResults->IpConfig.fDhcpEnabled
//BOOLEAN GlobalDhcpEnabled;

// See pResults->NetBt.Transports
//LIST_ENTRY GlobalNetbtTransports;

// See pResults->NetBt.cTransportCount
//ULONG GlobalNetbtTransportCount;

// !!! not replaced yet
// See pResults->Global.listTestedDomains
//LIST_ENTRY GlobalTestedDomains;



//
// Globals defining the command line arguments.
//

// Replaced by pParams->fVerbose
//BOOL Verbose;

// Replaced by pParams->fReallyVerbose
// Maintain this global variable so that we don't mess up the compiling
// of getdcnam.c
BOOL ReallyVerbose;

// Replaced by pParams->fDebugVerbose
//BOOL DebugVerbose;

// Replaced by pParams->fFixProblems
//BOOL GlobalFixProblems;

// Replaced by pParams->fDcAccountEnum
//BOOL GlobalDcAccountEnum;


// !!! not replaced yet
//PTESTED_DOMAIN GlobalQueriedDomain;

//
// Describe the domain this machine is a member of
//

// Replaced by pResults->Global.pszCurrentBuildNumber
//int GlobalNtBuildNumber;

// Replaced by pResults->Global.pPrimaryDomainInfo
//PDSROLE_PRIMARY_DOMAIN_INFO_BASIC GlobalDomainInfo = NULL;

// Replaced by pResults->Global.pMemberDomain
//PTESTED_DOMAIN GlobalMemberDomain;

//
// Who we're currently logged on as
//

// Replaced by pResults->Global.pLogonUser
//PUNICODE_STRING GlobalLogonUser;

// Replaced by pResults->Global.pLogonDomainName
//PUNICODE_STRING GlobalLogonDomainName;

// Replaced by pResults->Global.pLogonDomain
//PTESTED_DOMAIN GlobalLogonDomain;

// Replaced by pResults->Global.fLogonWithCachedCredentials
//BOOLEAN GlobalLogonWithCachedCredentials = FALSE;

//
// A Zero GUID for comparison
//

GUID NlDcZeroGuid;

//
// State determined by previous tests
//

// Replaced by pResults->Global.fNetlogonIsRunning
//BOOL GlobalNetlogonIsRunning = FALSE;   // Netlogon is running on this machine

// !!! not replaced yet
// Replaced by pResults->Global.fKerberosIsWorking
//BOOL GlobalKerberosIsWorking = FALSE;   // Kerberos is working

//
// Netbios name of this machine
//

// Replaced by pResults->Global.swzNetBiosName
//WCHAR GlobalNetbiosComputerName[MAX_COMPUTERNAME_LENGTH+1];

// Replaced by pResults->Global.szDnsHostName
//CHAR GlobalDnsHostName[DNS_MAX_NAME_LENGTH+1];

// Replaced by pResults->Global.pszDnsDomainName
//LPSTR GlobalDnsDomainName;


//(nsun) this macro already exists in <objbase.h>
//
// Macro for comparing GUIDs
//
/*
#define InlineIsEqualGUID(rguid1, rguid2)  \
        (((PLONG) rguid1)[0] == ((PLONG) rguid2)[0] &&   \
        ((PLONG) rguid1)[1] == ((PLONG) rguid2)[1] &&    \
        ((PLONG) rguid1)[2] == ((PLONG) rguid2)[2] &&    \
        ((PLONG) rguid1)[3] == ((PLONG) rguid2)[3])

#define IsEqualGUID(rguid1, rguid2) InlineIsEqualGUID(rguid1, rguid2)
*/

DSGETDCNAMEW NettestDsGetDcNameW;

PFNGUIDTOFRIENDLYNAME pfnGuidToFriendlyName = NULL;


/*---------------------------------------------------------------------------
    Function prototypes
 ---------------------------------------------------------------------------*/
HRESULT LoadNamesForListOfTests();
void    FreeNamesForListOfTests();
void DoGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
void DoPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);



/*---------------------------------------------------------------------------
    Functions provided by ipconfig
 ---------------------------------------------------------------------------*/

#define DECLARE_TEST_FUNCTIONS(_test) \
    HRESULT _test##Test(NETDIAG_PARAMS *, NETDIAG_RESULT *); \
    void _test##GlobalPrint(NETDIAG_PARAMS *, NETDIAG_RESULT *); \
    void _test##PerInterfacePrint(NETDIAG_PARAMS *, NETDIAG_RESULT *, INTERFACE_RESULT *); \
    void _test##Cleanup(NETDIAG_PARAMS *, NETDIAG_RESULT *);


DECLARE_TEST_FUNCTIONS(IpConfig);
DECLARE_TEST_FUNCTIONS(Member);
DECLARE_TEST_FUNCTIONS(IpLoopBk);
DECLARE_TEST_FUNCTIONS(NetBT);
DECLARE_TEST_FUNCTIONS(Autonet);
DECLARE_TEST_FUNCTIONS(DefGw);
DECLARE_TEST_FUNCTIONS(NbtNm);
DECLARE_TEST_FUNCTIONS(Wins);
DECLARE_TEST_FUNCTIONS(Bindings);
DECLARE_TEST_FUNCTIONS(Dns);
DECLARE_TEST_FUNCTIONS(Browser);
DECLARE_TEST_FUNCTIONS(Winsock);
DECLARE_TEST_FUNCTIONS(Route);
DECLARE_TEST_FUNCTIONS(Netstat);
DECLARE_TEST_FUNCTIONS(Ndis);
DECLARE_TEST_FUNCTIONS(WAN);
#ifndef _WIN64
//Netware and IPX support is removed from WIN64
DECLARE_TEST_FUNCTIONS(Netware);
DECLARE_TEST_FUNCTIONS(Ipx);
#endif
DECLARE_TEST_FUNCTIONS(Trust);
DECLARE_TEST_FUNCTIONS(Modem);
DECLARE_TEST_FUNCTIONS(Kerberos);
DECLARE_TEST_FUNCTIONS(DcList);
DECLARE_TEST_FUNCTIONS(LDAP);
DECLARE_TEST_FUNCTIONS(DsGetDc);
DECLARE_TEST_FUNCTIONS(IPSec);


//////////////////////////////////////////////////////////////////////////////
//
// List of tests to run
//
//////////////////////////////////////////////////////////////////////////////

typedef struct
{
    // Each of these strings has a max of 256 characters
    UINT    uIdsShortName;      // ID of the string for the short name
    UINT    uIdsLongName;       // ID of the string for the long name

    HRESULT (*TestProc)(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults);
    void (*SystemPrintProc)(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pRes);
    void (*GlobalPrintProc)(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pRes);
    void (*PerInterfacePrintProc)(NETDIAG_PARAMS *pParams,
                                  NETDIAG_RESULT *pRes,
                                  INTERFACE_RESULT *pIfRes);
    void (*CleanupProc)(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
    BOOL    fSkippable;
    BOOL    fPerDomainTest;
    BOOL     fSkipped;
    BOOL    fPerformed;

    // We will call LoadString() on the id's above to get these
    // strings.
    LPTSTR  pszShortName;
    LPTSTR  pszLongName;
} TEST_INFO;


#define EACH_TEST(_szID, _uShortIDS, _uLongIDS, _skip, _perdomain) \
{ _uShortIDS, _uLongIDS, _szID##Test, NULL, _szID##GlobalPrint, \
    _szID##PerInterfacePrint, _szID##Cleanup, _skip, _perdomain, \
    FALSE, FALSE, NULL, NULL}

#define SYSTEM_PRINT_TEST(_szID, _uShortIDS, _uLongIDS, _skip, _perdomain) \
{ _uShortIDS, _uLongIDS, _szID##Test, _szID##GlobalPrint, NULL, \
    _szID##PerInterfacePrint, _szID##Cleanup, _skip, _perdomain, \
    FALSE, FALSE, NULL, NULL}

//
// Tests below are marked "skippable" unless subsequent tests will AV if the
// test isn't run.
//
static TEST_INFO s_rgListOfTests[] =
{
    // IP Configuration
    SYSTEM_PRINT_TEST( Ndis,    IDS_NDIS_SHORT, IDS_NDIS_LONG, FALSE, FALSE),
    EACH_TEST( IpConfig,IDS_IPCONFIG_SHORT, IDS_IPCONFIG_LONG,  TRUE, FALSE),
    EACH_TEST( Member,  IDS_MEMBER_SHORT,   IDS_MEMBER_LONG,    FALSE,FALSE),
    EACH_TEST( NetBT,   IDS_NETBT_SHORT,    IDS_NETBT_LONG,     FALSE,FALSE),
    EACH_TEST( Autonet, IDS_AUTONET_SHORT,  IDS_AUTONET_LONG,   TRUE, FALSE),
    EACH_TEST( IpLoopBk,IDS_IPLOOPBK_SHORT, IDS_IPLOOPBK_LONG,  TRUE, FALSE),
    EACH_TEST( DefGw,   IDS_DEFGW_SHORT,    IDS_DEFGW_LONG,     TRUE, FALSE),
    EACH_TEST( NbtNm,   IDS_NBTNM_SHORT,    IDS_NBTNM_LONG,     TRUE, FALSE),
    EACH_TEST( Wins,    IDS_WINS_SHORT,     IDS_WINS_LONG,      TRUE, FALSE),
    EACH_TEST( Winsock, IDS_WINSOCK_SHORT,  IDS_WINSOCK_LONG,   TRUE, FALSE),
    EACH_TEST( Dns,     IDS_DNS_SHORT,      IDS_DNS_LONG,       TRUE, FALSE),
    EACH_TEST( Browser, IDS_BROWSER_SHORT,  IDS_BROWSER_LONG,   TRUE, FALSE),
    EACH_TEST( DsGetDc, IDS_DSGETDC_SHORT,  IDS_DSGETDC_LONG,   TRUE, TRUE ),
    EACH_TEST( DcList,  IDS_DCLIST_SHORT,   IDS_DCLIST_LONG,    TRUE, TRUE ),
    EACH_TEST( Trust,   IDS_TRUST_SHORT,    IDS_TRUST_LONG,     TRUE, FALSE),
    EACH_TEST( Kerberos,IDS_KERBEROS_SHORT, IDS_KERBEROS_LONG,  TRUE, FALSE ),
    EACH_TEST( LDAP,    IDS_LDAP_SHORT, IDS_LDAP_LONG,          TRUE,  TRUE ),
    EACH_TEST( Route,   IDS_ROUTE_SHORT, IDS_ROUTE_LONG, TRUE, FALSE ),
    EACH_TEST( Netstat, IDS_NETSTAT_SHORT, IDS_NETSTAT_LONG, TRUE, FALSE),
    EACH_TEST( Bindings,IDS_BINDINGS_SHORT, IDS_BINDINGS_LONG,  TRUE, FALSE),
    EACH_TEST( WAN,     IDS_WAN_SHORT,      IDS_WAN_LONG,       TRUE, FALSE),
    EACH_TEST( Modem,   IDS_MODEM_SHORT,    IDS_MODEM_LONG,     TRUE, FALSE),
#ifndef _WIN64
//Netware and IPX support is removed from WIN64
    EACH_TEST( Netware, IDS_NETWARE_SHORT,  IDS_NETWARE_LONG,   TRUE, FALSE),
    EACH_TEST( Ipx,     IDS_IPX_SHORT,      IDS_IPX_LONG,       TRUE, FALSE),
#endif
    EACH_TEST( IPSec,   IDS_IPSEC_SHORT,    IDS_IPSEC_LONG,     TRUE, FALSE)

};


/////////////////////////////////////////////////////////////////////////////
//
// List of problems and the corresponding tests to run
//
/////////////////////////////////////////////////////////////////////////////


// max no of tests
#define NO_OF_TESTS 25

typedef BOOL (*FuncPtr)(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults);

typedef struct _A_PROBLEM {
    LPTSTR problem; // Problem description
    LONG n; // no of tests
    FuncPtr TestProc[NO_OF_TESTS];
} A_PROBLEM;

// Number of problems defined
#define NO_OF_PROBLEMS 2

A_PROBLEM ListOfProblems[] = {
    _T("Fake test"),  1 , IpConfigTest, NULL, NULL,NULL,NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL
//    "Not Able to Reach Other Segments Of the Network",  1 , DefGwTest, NULL, NULL,NULL,NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
//    "Not Able to Resolve NetBios Names",  1 , WINSTest, NULL, NULL,NULL,NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL
};


/*!--------------------------------------------------------------------------
    ParseArgs

    Routine Description:
        Parse the command line arguments

    Arguments:
        argc - the number of command-line arguments.
        argv - an array of pointers to the arguments.
        pParams - this function sets these values
        pResults - additional output

    Return Value:
        0: All OK
        Exit status
    Author: KennT
 ---------------------------------------------------------------------------*/
int
ParseArgs(
          IN int argc,
          IN TCHAR ** argv,
          IN OUT NETDIAG_PARAMS *pParams,
          IN OUT NETDIAG_RESULT *pResults
         )
{
    LPSTR pszArgument;
    LPSTR TestName;
    int ArgumentIndex;
    ULONG i;
    BOOL  SeenTestOption = FALSE;
    PTESTED_DOMAIN pQueriedDomain;

    //
    // Flags used by problem option
    //

    BOOL OtherOptions = FALSE;

    //
    // Set the defaults
    //

    pParams->fVerbose = TRUE;
    pParams->fReallyVerbose = FALSE;
    pParams->fDebugVerbose = FALSE;
    pParams->fFixProblems = FALSE;
    pParams->fDcAccountEnum = FALSE;

    pParams->fProblemBased = FALSE;
    pParams->nProblemNumber = 0;


    //
    // Loop through the arguments handle each in turn
    //

    for ( ArgumentIndex=1; ArgumentIndex<argc; ArgumentIndex++ ) {

        pszArgument = argv[ArgumentIndex];

        if ( StriCmp( pszArgument, _T("/q") ) == 0 ||
             StriCmp( pszArgument, _T("-q") ) == 0 )
        {
            if ( pParams->fReallyVerbose || pParams->fProblemBased )
            {
                goto Usage;
            }
            pParams->fVerbose = FALSE;
            OtherOptions = TRUE;
        }
        else if ( StriCmp( pszArgument, _T("/v") ) == 0 ||
                  StriCmp( pszArgument, _T("-v") ) == 0 )
        {
            if ( !pParams->fVerbose || pParams->fProblemBased)
            {
                goto Usage;
            }
            pParams->fVerbose = TRUE;
            pParams->fReallyVerbose = TRUE;
            OtherOptions = TRUE;

        }
        else if ( StriCmp( pszArgument, _T("/debug") ) == 0 ||
                  StriCmp( pszArgument, _T("-debug") ) == 0 )
        {
            if ( !pParams->fVerbose || pParams->fProblemBased)
            {
                goto Usage;
            }
            pParams->fVerbose = TRUE;
            pParams->fReallyVerbose = TRUE;
            pParams->fDebugVerbose = TRUE;
            OtherOptions = TRUE;

        }
        else if ( StriCmp( pszArgument, _T("/fix") ) == 0 ||
                  StriCmp( pszArgument, _T("-fix") ) == 0 )
        {
            if (pParams->fProblemBased)
               goto Usage;

            pParams->fFixProblems = TRUE;
            OtherOptions = TRUE;

        }
        else if ( StriCmp( pszArgument, _T("/DcAccountEnum") ) == 0 ||
                  StriCmp( pszArgument, _T("-DcAccountEnum") ) == 0 )
        {
            if (pParams->fProblemBased)
               goto Usage;

            pParams->fDcAccountEnum = TRUE;
            OtherOptions = TRUE;

        //
        // Allow the caller to specify the name of a domain to query.
        //
        }
        else if ( StrniCmp( pszArgument, _T("/d:"), 3 ) == 0 ||
                  StrniCmp( pszArgument, _T("-d:"), 3 ) == 0 )
        {
            WCHAR UnicodeDomainName[MAX_PATH+1];

            if (pParams->fProblemBased)
                goto Usage;

            OtherOptions = TRUE;
            NetpCopyStrToWStr( UnicodeDomainName, &pszArgument[3] );

            pQueriedDomain = AddTestedDomain(pParams, pResults,
                UnicodeDomainName, NULL, FALSE );

            if ( pQueriedDomain == NULL )
            {
                goto Usage;
            }

        //
        // Allow the caller to skip certain tests
        //

        }
        else if ( StrniCmp( pszArgument, _T("/skip:"), 6 ) == 0 ||
                  StrniCmp( pszArgument, _T("-skip:"), 6 ) == 0 )
        {

            TestName = &pszArgument[6];
            OtherOptions = TRUE;

            if (pParams->fProblemBased)
                goto Usage;

            for ( i=0; i < DimensionOf(s_rgListOfTests); i++)
            {
                if ( StriCmp( s_rgListOfTests[i].pszShortName, TestName ) == 0 )
                {
                    //
                    // If the caller specified a non-optional test,
                    //  tell him.
                    //

                    if ( !s_rgListOfTests[i].fSkippable )
                    {
                        //IDS_GLOBAL_NOT_OPTIONAL        "'%s' is not an optional test.\n"
                        PrintMessage(pParams, IDS_GLOBAL_NOT_OPTIONAL, TestName );
                        goto Usage;
                    }

                    s_rgListOfTests[i].fSkipped = TRUE;
                    break;
                }
            }

            if ( i >= DimensionOf(s_rgListOfTests) )
            {
                //IDS_GLOBAL_NOT_VALID_TEST     "'%s' is not an valid test name.\n"
                PrintMessage( pParams, IDS_GLOBAL_NOT_VALID_TEST, TestName );
                goto Usage;
            }

        //
        // Handle all other parameters
        //

        }
        else if ( StrniCmp( pszArgument, _T("/test:"),6 ) == 0 ||
                  StrniCmp( pszArgument, _T("-test:"),6 ) == 0 )
        {

            TestName = &pszArgument[6];
            OtherOptions = TRUE;

            if (pParams->fProblemBased)
                goto Usage;

            for ( i =0; i < DimensionOf(s_rgListOfTests); i++)
            {
                if ( StriCmp( s_rgListOfTests[i].pszShortName, TestName ) == 0)
                       s_rgListOfTests[i].fSkipped = FALSE;
                else {
                   if (!SeenTestOption && s_rgListOfTests[i].fSkippable)
                       s_rgListOfTests[i].fSkipped = TRUE;
               }
            }
           SeenTestOption = TRUE;
        }
        else if( StrniCmp( pszArgument, _T("/l"), 5) == 0 ||
                 StrniCmp( pszArgument, _T("-l"), 5) == 0 )
        {
			/* We change to always log the output
            pParams->pfileLog = fopen(c_szLogFileName, "wt");
            if( NULL == pParams->pfileLog )
            {
                //IDS_NETTEST_LOGFILE_ERROR "[ERROR]    Cannot open %s to log output!\n"
                PrintMessage(pParams, IDS_NETTEST_LOGFILE_ERROR, c_szLogFileName);
                return 1;
            }
            else
            {
                pParams->fLog = TRUE;
            }
			*/
        }
/*$REVIEW (nsun) we won't support problem configuration for NT5.0
        else if ( StrniCmp( pszArgument, _T("/problem:"),9) == 0 ||
                  StrniCmp( pszArgument, _T("-problem:"),9) == 0 )
        {

           TestName = &pszArgument[9];

           i = atoi(TestName);

           if ( i > NO_OF_PROBLEMS)
           {
              printf("Incorrect problem number\n");
              exit(0);
           }

           if (OtherOptions)
              goto Usage;

           pParams->fProblemBased = TRUE;
           pParams->nProblemNumber = i-1;
        }
*/
        else
        {
Usage:
            // IDS_NETTEST_17000 "\nUsage: %s [/Options]>\n", argv[0] );
            // IDS_NETTEST_17001 "   /q - Quiet output (errors only)\n" );
            // IDS_NETTEST_17002 "   /v - Verbose output \n");
            // IDS_NETTEST_LOG   "   /l - Log output to NetDiag.log \n"
            // IDS_NETTEST_17003 "   /debug - Even more verbose.\n");
            // IDS_NETTEST_17004 "   /d:<DomainName> - Find a DC in the specified domain.\n");
            // IDS_NETTEST_17005 "   /fix - fix trivial problems.\n");
            // IDS_NETTEST_17006 "   /DcAccountEnum - Enumerate DC machine accounts.\n");
            // IDS_NETTEST_17007 "   /test:<test name>  - tests only this test. Non - skippable tests will still be run\n");
            // IDS_NETTEST_17008 "   Valid tests are :-\n");
            PrintMessage(pParams, IDS_NETTEST_17000, argv[0]);
            PrintMessage(pParams, IDS_NETTEST_17001);
            PrintMessage(pParams, IDS_NETTEST_17002);
            PrintMessage(pParams, IDS_NETTEST_LOG);
            PrintMessage(pParams, IDS_NETTEST_17003);
            PrintMessage(pParams, IDS_NETTEST_17004);
            PrintMessage(pParams, IDS_NETTEST_17005);
            PrintMessage(pParams, IDS_NETTEST_17006);
            PrintMessage(pParams, IDS_NETTEST_17007);
            PrintMessage(pParams, IDS_NETTEST_17008);

            for ( i =0; i < DimensionOf(s_rgListOfTests); i++)
            {
                // IDS_GLOBAL_TEST_NAME     "        %s - %s Test\n"
                PrintMessage(pParams, IDS_GLOBAL_TEST_NAME,
                       s_rgListOfTests[i].pszShortName,
                       s_rgListOfTests[i].pszLongName);
            }

            // IDS_GLOBAL_SKIP              "   /skip:<TestName> - skip the named test.  Valid tests are:\n"
            PrintMessage( pParams, IDS_GLOBAL_SKIP_OPTION);
            for ( i =0; i < DimensionOf(s_rgListOfTests); i++)
            {
                if ( s_rgListOfTests[i].fSkippable )
                {
                    // IDS_GLOBAL_TEST_NAME     "        %s - %s Test\n"
                    PrintMessage( pParams,
                           IDS_GLOBAL_TEST_NAME,
                           s_rgListOfTests[i].pszShortName,
                           s_rgListOfTests[i].pszLongName );
                }
            }
            return 1;
        }
    }

    return 0;
}





int __cdecl
main(
    IN int argc,
    IN TCHAR ** argv
    )
{
    int RetVal;
    LONG i;
    LONG err;
    BOOL Failed = FALSE;
    int     iWSAStatus;
    HRESULT hr = hrOK;

    NETDIAG_PARAMS Params;
    NETDIAG_RESULT Results;

	// set the locale to the system default
	setlocale( LC_ALL, "");

    // Turn on debug checking
    // ----------------------------------------------------------------
#ifdef _DEBUG
    int     tmpFlag;

    tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

    tmpFlag |= _CRTDBG_CHECK_ALWAYS_DF;
    tmpFlag |= _CRTDBG_DELAY_FREE_MEM_DF;
    tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

//  _CrtSetDbgFlag( tmpFlag );
#endif

    // Global initialization.
    // ----------------------------------------------------------------
    RtlZeroMemory( &NlDcZeroGuid, sizeof(NlDcZeroGuid) );
    ZeroMemory(&Params, sizeof(NETDIAG_PARAMS));
    ZeroMemory(&Results, sizeof(NETDIAG_RESULT));

    InitializeListHead( &Results.NetBt.Transports );
//    InitializeListHead( &GlobalNetbtTransports );
//    InitializeListHead( &GlobalTestedDomains );
    InitializeListHead( &Results.Global.listTestedDomains );
//    GlobalDnsHostName[0] = 0;
//    GlobalDhcpEnabled = FALSE;
//    GlobalDnsDomainName = NULL;

    // Load the names of all the tests (this is used by the ParseArgs).
    // which is why it needs to get loaded first.
    // ----------------------------------------------------------------
    CheckHr( LoadNamesForListOfTests() );

    // Parse input flags.
    // ----------------------------------------------------------------
    RetVal = ParseArgs( argc, argv, &Params, &Results);
    if ( RetVal != 0 )
    {
        return 1;
    }

	Params.pfileLog = fopen(c_szLogFileName, "wt");
    if( NULL == Params.pfileLog )
    {
        //IDS_NETTEST_LOGFILE_ERROR "[ERROR]    Cannot open %s to log output!\n"
        PrintMessage(&Params, IDS_NETTEST_LOGFILE_ERROR, c_szLogFileName);
    }
    else
    {
        Params.fLog = TRUE;
    }


    // Initialize Winsock
    // ----------------------------------------------------------------
    iWSAStatus = WsaInitialize(&Params, &Results);
    if ( iWSAStatus )
    {
        return 1;
    }

/*
   if (pParams->fProblemBased) {
    for (i =0; i < ListOfProblems[pParams->nProblemNumber].n; i++) {
       if ( !(*ListOfProblems[pParams->nProblemNumber].TestProc[i])((PVOID)NULL) )
            Failed = TRUE;
     }

   if (Failed)
      PrintMessage(pParams, IDS_GLOBAL_Problem);
   else
      PrintMessage(pParams, IDS_GLOBAL_NoProblem);
   return 0;
   }
*/

    // Get the NetBIOS computer name of this computer
    // ----------------------------------------------------------------
    CheckHr( GetComputerNameInfo(&Params, &Results) );


    // Get the DNS host name and DNS domain.
    // ----------------------------------------------------------------
    CheckHr( GetDNSInfo(&Params, &Results) );


    // Get OS-version info, etc..
    // ----------------------------------------------------------------
    CheckHr( GetMachineSpecificInfo(&Params, &Results) );


    // Other non-ip config info - Rajkumar
    // ----------------------------------------------------------------
    CheckHr( GetNetBTParameters(&Params, &Results) );

    if ( Params.fVerbose )
    {
        PrintNewLine(&Params, 1);
    }

    //
    // Grab all the information from the registry that 'ipconfig /all'
    //  would print.
    //
    // This routine doesn't always return on fatal errors.
    //

    hr = InitIpconfig(&Params, &Results);
    if (!FHrSucceeded(hr))
    {
        PrintMessage(&Params, IDS_GLOBAL_NoIpCfg);
        CheckHr( hr );
    }

#ifndef _WIN64
    hr = InitIpxConfig(&Params, &Results);
    if (!FHrSucceeded(hr))
    {
        CheckHr( hr );
    }
#endif

    //
    // Determine if any adapter has DHCP enabled.
    //
    for ( i = 0; i<Results.cNumInterfaces; i++)
    {
        if (Results.pArrayInterface[i].IpConfig.fActive &&
            Results.pArrayInterface[i].IpConfig.pAdapterInfo->DhcpEnabled)
        {
            Results.IpConfig.fDhcpEnabled = TRUE;
            break;
        }
    }

    //if to detect a predefined problem
    if (Params.fProblemBased) {
        for (i =0; i < ListOfProblems[Params.nProblemNumber].n; i++) {
            if ( !(*ListOfProblems[Params.nProblemNumber].TestProc[i])(&Params, &Results) )
                Failed = TRUE;
        }

        if (Failed)
            PrintMessage(&Params, IDS_GLOBAL_Problem);
        else
            PrintMessage(&Params, IDS_GLOBAL_NoProblem);
        return 0;
    }

    //
    // Test individual components
    //

    for ( i=0; i < DimensionOf(s_rgListOfTests); i++ )
    {
        // If the caller wanted to skip this test,
        //  do so now.
        // ------------------------------------------------------------
        if ( s_rgListOfTests[i].fSkipped )
            continue;


        //We will perform this test
        s_rgListOfTests[i].fPerformed = TRUE;

        //
        // If the test is to be run for each tested domain,
        //  do so.
        //

        if ( s_rgListOfTests[i].fPerDomainTest )
        {
            PTESTED_DOMAIN TestedDomain;
            PLIST_ENTRY pListEntry;


            //
            // Loop through the list of tested domains
            //

            for ( pListEntry = Results.Global.listTestedDomains.Flink ;
                  pListEntry != &Results.Global.listTestedDomains ;
                  pListEntry = pListEntry->Flink ) {

                //
                // If the entry is found,
                //  use it.
                //

                TestedDomain = CONTAINING_RECORD( pListEntry, TESTED_DOMAIN, Next );

                Params.pDomain = TestedDomain;

                //
                // Run this test.
                //

                if ( FHrFailed((*s_rgListOfTests[i].TestProc)(&Params, &Results))) {
                    Failed = TRUE;
                }
            }

            //
            // If any test failed,
            //  we're done.
            //

            if ( Failed ) {
                goto Print_Results;
            }

        //
        // If the test is to be run just once,
        //  do it.
        //

        } else {

            //
            // Run this test.
            //

            if ( FHrFailed((*s_rgListOfTests[i].TestProc)(&Params, &Results)))
            {
                goto Print_Results;
            }
        }
    }


Print_Results:
    // Now that we've run through all of the tests, run through the
    // print outs


    if (Params.fReallyVerbose)
    {
        // IDS_GLOBAL_COMPLETE      "\n    Tests complete.\n\n\n"
        PrintMessage( &Params, IDS_GLOBAL_COMPLETE );
    }
    else
    {
        PrintNewLine(&Params, 2);
    }

    DoSystemPrint(&Params, &Results);

    DoPerInterfacePrint(&Params, &Results);

    DoGlobalPrint(&Params, &Results);

    //
    // All tests passed.
    //
    // IDS_GLOBAL_SUCCESS       "\nThe command completed successfully\n"

    PrintMessage( &Params, IDS_GLOBAL_SUCCESS);

Error:
    FreeNamesForListOfTests();

    if(Params.pfileLog != NULL && Params.fLog)
    {
        fclose(Params.pfileLog);
    }

    ResultsCleanup(&Params, &Results);

    return hr != S_OK;

}



HRESULT LoadNamesForListOfTests()
{
    int     i;
    TCHAR   szBuffer[256];

    for (i=0; i < DimensionOf(s_rgListOfTests); i++)
    {
        szBuffer[0] = 0;
        LoadString(NULL, s_rgListOfTests[i].uIdsShortName, szBuffer,
                   DimensionOf(szBuffer));
        s_rgListOfTests[i].pszShortName = _tcsdup(szBuffer);

        szBuffer[0] = 0;
        LoadString(NULL, s_rgListOfTests[i].uIdsLongName, szBuffer,
                   DimensionOf(szBuffer));
        s_rgListOfTests[i].pszLongName = StrDup(szBuffer);
    }
    return hrOK;
}

void FreeNamesForListOfTests()
{
    int     i;

    for (i=0; i < DimensionOf(s_rgListOfTests); i++)
    {
        Free(s_rgListOfTests[i].pszShortName);
        s_rgListOfTests[i].pszShortName = NULL;

        Free(s_rgListOfTests[i].pszLongName);
        s_rgListOfTests[i].pszLongName = NULL;
    }
}


void DoSystemPrint(IN NETDIAG_PARAMS *pParams,
                   IN NETDIAG_RESULT *pResults)
{
    int     cInstalled;
    int     i;
    int     ids;
    
    PrintMessage(pParams, IDSWSZ_GLOBAL_ComputerName, pResults->Global.swzNetBiosName);
    PrintMessage(pParams, IDSSZ_GLOBAL_DnsHostName, pResults->Global.szDnsHostName );
    if (pParams->fReallyVerbose)
        PrintMessage(pParams, IDSSZ_DnsDomainName,
                     pResults->Global.pszDnsDomainName);
    
    // "    System info : %s (Build %s)\n" 
    PrintMessage(pParams, IDS_MACHINE_15801,
           pResults->Global.pszServerType,
           pResults->Global.pszCurrentBuildNumber);
    
    // "    Processor : %s\n" 
    PrintMessage(pParams, IDS_MACHINE_15802,
           pResults->Global.pszProcessorInfo);

    if (pResults->Global.cHotFixes == 0)
        // "    Hotfixes : none detected\n" 
        PrintMessage(pParams, IDS_MACHINE_15803);
    else
    {
        // If in Verbose mode, only print out the hotfixes that are
        // installed

        if (pParams->fReallyVerbose)
        {
            // print out a list of all hotfixes
            // "    Hotfixes :\n" 
            PrintMessage(pParams, IDS_MACHINE_15804);
            
            // "        Installed?      Name\n" 
            PrintMessage(pParams, IDS_MACHINE_15805);
            for (i=0; i<pResults->Global.cHotFixes; i++)
            {
                if (pResults->Global.pHotFixes[i].fInstalled)
                    ids = IDS_MACHINE_YES_INSTALLED;
                else
                    ids = IDS_MACHINE_NO_INSTALLED;
                    PrintMessage(pParams, ids,
                                 pResults->Global.pHotFixes[i].pszName);
            }
        }
        else
        {
            // print out a list of the installed hotfixes
            // count the number of installed hotfixes
            cInstalled = 0;
            for (i=0; i<pResults->Global.cHotFixes; i++)
            {
                if (pResults->Global.pHotFixes[i].fInstalled)
                    cInstalled++;
            }

            if (cInstalled == 0)
            {
                // "    Hotfixes : not hotfixes have been installed\n" 
                PrintMessage(pParams, IDS_MACHINE_15806);
            }
            else
            {
                // "    List of installed hotfixes : \n" 
                PrintMessage(pParams, IDS_MACHINE_15807);
                for (i=0; i<pResults->Global.cHotFixes; i++)
                {
                    if (pResults->Global.pHotFixes[i].fInstalled)
                    {
                        //  "        %s\n" 
                        PrintMessage(pParams, IDS_MACHINE_15808, pResults->Global.pHotFixes[i].pszName);
                    }
                }
            }
        }
    }   


    for ( i=0; i < DimensionOf(s_rgListOfTests); i++ )
    {
        // If the caller wanted to skip this test,
        //  do so now.
        // ------------------------------------------------------------
        if ( s_rgListOfTests[i].fSkipped  || !s_rgListOfTests[i].fPerformed)
            continue;

        if(s_rgListOfTests[i].SystemPrintProc)
            s_rgListOfTests[i].SystemPrintProc(pParams, pResults);
    }
    PrintNewLine(pParams, 1);

}


void DoGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    int     i;

    // IDS_GLOBAL_RESULTS       "\nGlobal results\n\n"
    PrintMessage( pParams, IDS_GLOBAL_RESULTS );
    for ( i=0; i < DimensionOf(s_rgListOfTests); i++ )
    {
        // If the caller wanted to skip this test,
        //  do so now.
        // ------------------------------------------------------------
        if ( s_rgListOfTests[i].fSkipped || !s_rgListOfTests[i].fPerformed)
            continue;

        if(s_rgListOfTests[i].GlobalPrintProc)
            s_rgListOfTests[i].GlobalPrintProc(pParams, pResults);
    }
    PrintNewLine(pParams, 1);
}

void DoPerInterfacePrint(NETDIAG_PARAMS *pParams,
                         NETDIAG_RESULT *pResults)
{
    int     i, iIf;
    INTERFACE_RESULT *  pIfResult;

    //IDS_GLOBAL_INTERFACE_RESULTS  "\nPer interface results:\n\n"
    PrintMessage( pParams, IDS_GLOBAL_INTERFACE_RESULTS );
    // Loop through the interfaces
    for ( iIf = 0; iIf < pResults->cNumInterfaces; iIf++)
    {
        pIfResult = pResults->pArrayInterface + iIf;

        if (!pIfResult->fActive)
            continue;

        PrintNewLine(pParams, 1);

        // Print out the interface name
        PrintMessage(pParams, IDSSZ_IPCFG_Adapter,
                     pResults->pArrayInterface[iIf].pszFriendlyName ?
                     pResults->pArrayInterface[iIf].pszFriendlyName :
                     MapGuidToAdapterName(pIfResult->IpConfig.pAdapterInfo->AdapterName));

        if (pParams->fReallyVerbose)
            PrintMessage(pParams, IDS_IPCFG_10004,
                         pResults->pArrayInterface[iIf].pszName);

        for ( i=0; i < DimensionOf(s_rgListOfTests); i++ )
        {
            // If the caller wanted to skip this test,
            //  do so now.
            // ------------------------------------------------------------
            if ( s_rgListOfTests[i].fSkipped || !s_rgListOfTests[i].fPerformed )
                continue;

            s_rgListOfTests[i].PerInterfacePrintProc(pParams, pResults,
                pIfResult);
        }

        fflush(stdout);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\nettst.h ===
/*

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

           nettst.h

Abstract:

           This will be the header file for nettest.dll
           It is intended to be used by both the user of the dll and the source code
           for the dll.

Author:
           Aug-13-1998 ( t-rajkup )

*/


//
// Before including this file, the source files for dll will redefine NETTESTAPI
// to _declspec(dllexport)
//    - Rajkumar 
//

#ifndef NETTESTAPI
#define NETTESTAPI _declspec(dllimport)
#endif

/*=============================< Defines >=======================================*/

// defines used in ipconfig structures
#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arb.
#define MAX_ADAPTER_NAME_LENGTH         256 // arb.
#define MAX_ADAPTER_ADDRESS_LENGTH      8   // arb.
#define MAX_HOSTNAME_LEN                128 // arb.
#define MAX_DOMAIN_NAME_LEN             128 // arb.
#define MAX_SCOPE_ID_LEN                256 // arb.

// defines used in  dhcp response info

#define MAX_SUBNET_MASK                 32  // arb.
#define MAX_IP_ADDR                     32  // arb.
#define MAX_EXPIRY_TIME_LEN             128 // arb.
#define DHCP_BOOT_REPLY                 2   // arb.

// defines used in wins test

// status values returned by wins name query test 
#define WINS_QUERY_SUCCEEDED                 0x00000001
#define WINS_QUERY_FAILED                    0x00000002

// defines used in netstat test
#define        MAX_PHYSADDR_SIZE       8


// defines used in dhcp test
#define  EXPIRY_TIME_LEN         128 //arb.

/*=============================< Data Structures >================================*/

// NOTE: Need to include iptypes.h for definition of IP_ADDR_STRING.

// This structure contains the fixed information returned by ipconfig test

typedef struct _IPCONFIG_FIXED_INFO {
  char    HostName[MAX_HOSTNAME_LEN + 4] ;
  char    DomainName[MAX_DOMAIN_NAME_LEN + 4];
  PIP_ADDR_STRING     CurrentDnsServer;
  IP_ADDR_STRING      DnsServerList;
  UINT    NodeType; // see node type related definitions in iptypes.h
  char    ScopeId[MAX_SCOPE_ID_LEN + 4];
  UINT    EnableRouting;
  UINT    EnableProxy;
  UINT    EnableDns; 
} IPCONFIG_FIXED_INFO, *PIPCONFIG_FIXED_INFO;


// This structure contains per adapter information returned by ipconfig test

typedef struct _IPCONFIG_ADAPTER_INFO {
  struct _IPCONFIG_ADAPTER_INFO *Next;
  char      AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];
  char      Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];
  UINT      AddressLength;
  BYTE      Address[MAX_ADAPTER_ADDRESS_LENGTH];
  DWORD     Index;
  UINT      Type; // adapter type.  See iptypes for definitions on type of adapters
  UINT      DhcpEnabled;
  PIP_ADDR_STRING   CurrentIpAddress;
  IP_ADDR_STRING    IpAddressList;
  IP_ADDR_STRING    GatewayList;
  IP_ADDR_STRING    DhcpServer;
  BOOL              PingDhcp; // whether pinging of dhcp server succeeded
  BOOL      HaveWins;
  //
  // NOTE: According to KarolyS, it is possible to list upto 12 wins servers
  // and this is supposed to be included in nettest code. -  Rajkumar
  //
  IP_ADDR_STRING    PrimaryWinsServer;
  BOOL              PingPrimary; // whether pinging of primary WINS succeeded
  IP_ADDR_STRING    SecondaryWinsServer;
  BOOL              PingSecondary; // whether pinging of secondary WINS succeeded
  time_t    LeaseObtained;
  time_t    LeaseExpires;
  char      DhcpClassID[MAX_DOMAIN_NAME_LEN];
  UINT      AutoconfigEnabled; // is autoconfiguration possible ?
  UINT      AutoconfigActive;  // is the adapter currently autoconfigured ?
  UINT      NodeType;
  char      DomainName[MAX_DOMAIN_NAME_LEN + 1];
  IP_ADDR_STRING    DnsServerList;
} IPCONFIG_ADAPTER_INFO, *PIPCONFIG_ADAPTER_INFO;

//
// Structure used in dhcp response
//
typedef struct _DHCP_RESPONSE_INFO {
  USHORT MessageType; // BOOT_REPLY always
  struct in_addr SubnetMask; 
  struct in_addr ServerIp;
  struct in_addr DomainName;
  char   ExpiryTime[EXPIRY_TIME_LEN]; 
} DHCP_RESPONSE_INFO, *PDHCP_RESPONSE_INFO;

//
// structures returned by netstat test
// 

typedef struct _INTERFACESTATS{
        ulong         if_index;
        ulong         if_type;
        ulong         if_mtu;
        ulong         if_speed;
        ulong         if_physaddrlen;
        uchar         if_physaddr[MAX_PHYSADDR_SIZE];
        ulong         if_adminstatus;
        ulong         if_operstatus;
        ulong         if_lastchange;
        ulong         if_inoctets;
        ulong         if_inucastpkts;
        ulong         if_innucastpkts;
        ulong         if_indiscards;
        ulong         if_inerrors;
        ulong         if_inunknownprotos;
        ulong         if_outoctets;
        ulong         if_outucastpkts;
        ulong         if_outnucastpkts;
        ulong         if_outdiscards;
        ulong         if_outerrors;
        ulong         if_outqlen;
        ulong         if_descrlen;
        uchar         if_descr[1];
} INTERFACESTATS, *PINTERFACESTATS;

typedef struct _TCPCONNECTIONSTATS {
    ulong       tct_state;
    ulong       tct_localaddr;
    ulong       tct_localport;
    ulong       tct_remoteaddr;
    ulong       tct_remoteport;
    struct _TCPCONNECTIONSTATS *Next; 
} TCPCONNECTIONSTATS, *PTCPCONNECTIONSTATS;

typedef struct _UDPCONNECTIONSTATS {
    ulong       ue_localaddr;
    ulong       ue_localport;
    struct _UDPCONNECTIONSTATS *Next;
} UDPCONNECTIONSTATS, *PUDPCONNECTIONSTATS;


typedef struct _IPINFO  {
    ulong      ipsi_forwarding;
    ulong      ipsi_defaultttl;
    ulong      ipsi_inreceives;
    ulong      ipsi_inhdrerrors;
    ulong      ipsi_inaddrerrors;
    ulong      ipsi_forwdatagrams;
    ulong      ipsi_inunknownprotos;
    ulong      ipsi_indiscards;
    ulong      ipsi_indelivers;

    ulong      ipsi_outrequests;
    ulong      ipsi_routingdiscards;
    ulong      ipsi_outdiscards;
    ulong      ipsi_outnoroutes;
    ulong      ipsi_reasmtimeout;
    ulong      ipsi_reasmreqds;
    ulong      ipsi_reasmoks;
    ulong      ipsi_reasmfails;
    ulong      ipsi_fragoks;
    ulong      ipsi_fragfails;
    ulong      ipsi_fragcreates;
    ulong      ipsi_numif;
    ulong      ipsi_numaddr;
    ulong      ipsi_numroutes;
} IPINFO, *PIPINFO;

typedef struct _TCP_STATS {
    ulong       ts_rtoalgorithm;
    ulong       ts_rtomin;
    ulong       ts_rtomax;
    ulong       ts_maxconn;
    ulong       ts_activeopens;
    ulong       ts_passiveopens;
    ulong       ts_attemptfails;
    ulong       ts_estabresets;
    ulong       ts_currestab;
    ulong       ts_insegs;
    ulong       ts_outsegs;
    ulong       ts_retranssegs;
    ulong       ts_inerrs;
    ulong       ts_outrsts;
    ulong       ts_numconns;
} TCP_STATS, *PTCP_STATS;

typedef struct _UDP_STATS {
    ulong       us_indatagrams; // datagrams received
    ulong       us_noports; // no ports
    ulong       us_inerrors; // Receive Errors
    ulong       us_outdatagrams; // datagrams sent
} UDP_STATS, *PUDP_STATS;

typedef struct _ICMPSTATS {
    ulong       icmps_msgs; // messages
    ulong       icmps_errors; // Errors
    ulong       icmps_destunreachs; // destination unreachable
    ulong       icmps_timeexcds; // time exceedeed
    ulong       icmps_parmprobs; // parameter problems
    ulong       icmps_srcquenchs; // source quenchs
    ulong       icmps_redirects; // redirects
    ulong       icmps_echos; // echos
    ulong       icmps_echoreps; // echo replies
    ulong       icmps_timestamps; // timestamps
    ulong       icmps_timestampreps; // timestamps replies
    ulong       icmps_addrmasks; // address masks
    ulong       icmps_addrmaskreps; // address mask replies
} ICMPSTATS, *PICMPSTATS;

/*================================< Entry Points >===============================*/

// The user of this entry point must allocate memory for these structures
NETTESTAPI    BOOL IpConfigTest(PIPCONFIG_FIXED_INFO pIpFixedInfo,
                                PULONG               pFixedSize,
                                PIPCONFIG_ADAPTER_INFO pIpAdapterInfo,
                                PULONG               pAdapterInfo);

NETTESTAPI    BOOL CheckDhcp(PIPCONFIG_ADAPTER_INFO pIpAdapterInfo,PDHCP_RESPONSE_INFO pDhcpResponse);

NETTESTAPI    DWORD QueryWINS(PIP_ADDRESS_STRING WinsServerAddr);

//
// This entry point will allocate the memory needed. It will not expect the user
// to allocate memory for these structures. Freeing of this allcoated memory is
// user's reponsibility. There can be additional entry points which can be supplied
// which can be used to free this memory
//

NETTESTAPI    BOOL NetstatInfo(PINTERFACESTATS pIfcStat,
                               PTCPCONNECTIONSTATS   pTcpConnStats,
                               PUDPCONNECTIONSTATS   pUdpConnStats,
                               PIPINFO               pIpInfo,
                               PTCP_STATS            pTcpStats,
                               PUDP_STATS            pUdpStats,
                               ICMPSTATS             pIcmpStats);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\nstest.h ===
/*++
Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

   nstest.h

Abstract:

   Header file for netstat test.

Author:
   
   4-Aug-1998 Rajkumar ( 08/04/98 ).
++*/

#ifndef HEADER_NSTEST
#define HEADER_NSTEST

#include <snmp.h>

#include "common2.h"
#include "tcpinfo.h"
#include "ipinfo.h"
//#include "tcpcmd.h"
#include "llinfo.h"

/*==========================<Function prototypes>=============================*/




#define MAX_HOST_NAME_SIZE        ( 260)
#define MAX_SERVICE_NAME_SIZE     ( 200)

extern BOOL NumFlag = FALSE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\nwtest.h ===
/*--

Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

    nwtest.h

Abstract:

    This module contains definitions, includes and function prototypes needed for
    the netware test.

Environment:

    User mode.

Revision History:

    4-Aug-1998 (t-rajkup)

--*/

#ifndef HEADER_NWTEST
#define NWTEST

#include <ntregapi.h> //KEY_READ define
#include <nwrnames.h> // NW_SERVER_VALUENAME & NW_PRINT_OPTION_DEFAULT
#include <winreg.h>
// porting to Source Depot - smanda #include <ntddnwfs.h>
// porting to Source Depot - smanda #include <nwutil.h> // TWO_KB
// porting to Source Depot - smanda #include <ndsapi32.h> // HANDLE_TYPE_NCP_SERVER
#include <winuser.h>

// includes for WNet API calls
#include <nspapi.h>
#include <winnetwk.h>

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#endif

#define TREECHAR   L'*'

#define NW_MESSAGE_NOT_LOGGED_IN_TREE                  1
#define NW_MESSAGE_NOT_LOGGED_IN_SERVER                2
#define NW_MESSAGE_LOGGED_IN_SERVER                    3
#define NW_MESSAGE_LOGGED_IN_TREE                      4

#define  EXTRA_BYTES  256
#define TWO_KB   2048

//
// Flags used for the function NwParseNdsUncPath()
//
#define  PARSE_NDS_GET_TREE_NAME    0
#define  PARSE_NDS_GET_PATH_NAME    1
#define  PARSE_NDS_GET_OBJECT_NAME  2

//
// Commonly reference value for NCP Server name length
//
#define NW_MAX_SERVER_LEN      48



//
// CONN_STATUS structures for the new shell.
//

typedef struct _CONN_STATUS {
    DWORD   dwTotalLength;     // The total length including packed strings.
    LPWSTR  pszServerName;     // The server name.
    LPWSTR  pszUserName;       // The user name.
    LPWSTR  pszTreeName;       // The tree name or NULL for a 2.x or 3.x server.
    DWORD   nConnNum;          // The connection number used on nw srv.
    BOOL    fNds;              // TRUE if NDS, False for Bindery servers
    BOOL    fPreferred;        // TRUE if the connection is a preferred server with no explicit uses.
    DWORD   dwConnType;        // Authentication status of the connection.
} CONN_STATUS, *PCONN_STATUS;

#define NW_CONN_NOT_AUTHENTICATED            0x00000000
#define NW_CONN_BINDERY_LOGIN                0x00000001
#define NW_CONN_NDS_AUTHENTICATED_NO_LICENSE 0x00000002
#define NW_CONN_NDS_AUTHENTICATED_LICENSED   0x00000003
#define NW_CONN_DISCONNECTED                 0x00000004

//
// NtDeviceIoControlFile/NtFsControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_NWRDR_BASE                  FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _NWRDR_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_NWRDR_BASE, request, method, access)

#define FSCTL_NWR_START                 _NWRDR_CONTROL_CODE(200, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_NWR_STOP                  _NWRDR_CONTROL_CODE(201, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_LOGON                 _NWRDR_CONTROL_CODE(202, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_LOGOFF                _NWRDR_CONTROL_CODE(203, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONNECTION        _NWRDR_CONTROL_CODE(204, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_ENUMERATE_CONNECTIONS _NWRDR_CONTROL_CODE(205, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_DELETE_CONNECTION     _NWRDR_CONTROL_CODE(207, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_BIND_TO_TRANSPORT     _NWRDR_CONTROL_CODE(208, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_CHANGE_PASS           _NWRDR_CONTROL_CODE(209, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_SET_INFO              _NWRDR_CONTROL_CODE(211, METHOD_BUFFERED,  FILE_ANY_ACCESS)

#define FSCTL_NWR_GET_USERNAME          _NWRDR_CONTROL_CODE(215, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_CHALLENGE             _NWRDR_CONTROL_CODE(216, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_DETAILS      _NWRDR_CONTROL_CODE(217, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_MESSAGE           _NWRDR_CONTROL_CODE(218, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_STATISTICS        _NWRDR_CONTROL_CODE(219, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_STATUS       _NWRDR_CONTROL_CODE(220, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_INFO         _NWRDR_CONTROL_CODE(221, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_PREFERRED_SERVER  _NWRDR_CONTROL_CODE(222, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_PERFORMANCE  _NWRDR_CONTROL_CODE(223, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_SET_SHAREBIT          _NWRDR_CONTROL_CODE(224, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_DETAILS2     _NWRDR_CONTROL_CODE(225, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_CLOSEALL              _NWRDR_CONTROL_CODE(226, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_NWR_NDS_SETCONTEXT        NWR_ANY_NDS(1)
#define FSCTL_NWR_NDS_GETCONTEXT        NWR_ANY_NDS(2)
#define FSCTL_NWR_NDS_VERIFY_TREE       NWR_ANY_NDS(3)
#define FSCTL_NWR_NDS_RESOLVE_NAME      NWR_ANY_NDS(4)
#define FSCTL_NWR_NDS_LIST_SUBS         NWR_ANY_NDS(5)
#define FSCTL_NWR_NDS_READ_INFO         NWR_ANY_NDS(6)
#define FSCTL_NWR_NDS_READ_ATTR         NWR_ANY_NDS(7)
#define FSCTL_NWR_NDS_OPEN_STREAM       NWR_ANY_NDS(8)
#define FSCTL_NWR_NDS_GET_QUEUE_INFO    NWR_ANY_NDS(9)
#define FSCTL_NWR_NDS_GET_VOLUME_INFO   NWR_ANY_NDS(10)
#define FSCTL_NWR_NDS_RAW_FRAGEX        NWR_ANY_NDS(11)
#define FSCTL_NWR_NDS_CHANGE_PASS       NWR_ANY_NDS(12)
#define FSCTL_NWR_NDS_LIST_TREES        NWR_ANY_NDS(13)

#define IOCTL_NWR_RAW_HANDLE            _NWRDR_CONTROL_CODE(1002,METHOD_NEITHER,   FILE_ANY_ACCESS)

//
//  UserNcp control code definitions. The parameter (X) to NWR_ANY_NCP
//  is the function code to be placed in the NCP.
//

#define NWR_ANY_NCP(X)                  _NWRDR_CONTROL_CODE(0x400 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_F2_NCP(X)               _NWRDR_CONTROL_CODE(0x500 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_HANDLE_NCP(X)           _NWRDR_CONTROL_CODE(0x600 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_NDS(X)                  _NWRDR_CONTROL_CODE(0x700 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)

#define FSCTL_NWR_NCP_E3H               NWR_ANY_NCP(0x17)
#define FSCTL_NWR_NCP_E2H               NWR_ANY_NCP(0x16)
#define FSCTL_NWR_NCP_E1H               NWR_ANY_NCP(0x15)
#define FSCTL_NWR_NCP_E0H               NWR_ANY_NCP(0x14)

//
// Redirector Request Packet used by the Workstation service
// to pass parameters to the Redirector through Buffer 1 of
// NtFsControlFile.
//
// Additional output of each FSCtl is found in Buffer 2.
//

#define REQUEST_PACKET_VERSION  0x00000001L // Structure version.

typedef struct _NWR_REQUEST_PACKET {

    ULONG Version;                      // Version of structure in Buffer 2

    union {


        //
        // For FSCTL_NWR_BIND_TO_TRANSPORT
        //
        struct {
            ULONG QualityOfService;     // Quality of service indicator   IN
            ULONG TransportNameLength;  // Not including terminator       IN
            WCHAR TransportName[1];     // Name of transport provider     IN
        } Bind;


        //
        // For FSCTL_NWR_LOGON
        //
        struct {
            LUID LogonId;               // User logon session identifier  IN
            ULONG UserNameLength;       // Byte count not including NULL  IN
            ULONG PasswordLength;       // Byte count not including NULL  IN
            ULONG ServerNameLength;     // Byte count not including NULL  IN
            ULONG ReplicaAddrLength;    // IPX address of the nearest dir server
                                        // replica (for NDS login only).
                                        // It's either sizeof(TDI_ADDRESS_IPX)
                                        // or 0.                          IN
            ULONG PrintOption;          // Print options for user         IN
            WCHAR UserName[1];          // User name not NULL terminated. IN

            // Password string          // Default password for connection,
                                        //    not NULL terminated, packed
                                        //    in buffer immediately after
                                        //    UserName.                   IN

            // ServerName               // Preferred server name packed in
                                        //    buffer immediately after
                                        //    Password.                   IN

            // IpxAddress               // Address copied from the SAP response
                                        // packet, packed immediately after
                                        // the servername.                IN
        } Logon;

        //
        // For FSCTL_NWR_CHANGE_PASS
        //
        struct {

            ULONG UserNameLength;
            ULONG PasswordLength;
            ULONG ServerNameLength;
            WCHAR UserName[1];

            // Password string          // New password.                  IN

            // ServerName               // Server with the new password   IN

        } ChangePass;

        //
        // For FSCTL_NWR_LOGOFF
        //
        struct {
            LUID LogonId;               // User logon session identifier  IN
        } Logoff;

        //
        // For FSCTL_NWR_DELETE_CONNECTION
        //
        struct {
            BOOLEAN UseForce;           // Force flag                     IN
        } DeleteConn;

        //
        // For FSCTL_NWR_GET_CONNECTION
        //
        struct {
            ULONG BytesNeeded;          // Size (byte count) required of
                                        //    output buffer including
                                        //    terminator                  OUT
            ULONG DeviceNameLength;     // Not including terminator       IN
            WCHAR DeviceName[4];        // Name of DOS device             IN
        } GetConn;

        //
        // FSCTL_NWR_ENUMERATE_CONNECTIONS
        //
        struct {
            ULONG EntriesRequested;    // Number of entries to get        IN
            ULONG EntriesReturned;     // Entries returned in respose buf OUT
            ULONG_PTR ResumeKey;       // Handle to next entry to get     IN OUT
            ULONG BytesNeeded;         // Size (byte count) of next entry OUT
            ULONG ConnectionType;      // Resource type requested         IN
            LUID  Uid;                 // Uid to search for               IN
        } EnumConn;

        //
        // FSCTL_NWR_SET_INFO
        //
        struct {
            ULONG PrintOption;
            ULONG MaximumBurstSize;

            ULONG PreferredServerLength; // Byte count not including NULL  IN
            ULONG ProviderNameLength;    // Byte count not including NULL  IN
            WCHAR PreferredServer[1];    // Preferred server name not NULL
                                         // terminated.
            // ProviderName string       // Provider name not NULL terminated.
                                         // Packed in buffer immediately
                                         // after PreferredServer

        } SetInfo;

        //
        // FSCTL_NWR_GET_CONN_STATUS
        //
        struct {
            ULONG ConnectionNameLength; // IN: Length of the connection name we want.
            ULONG_PTR ResumeKey;        // IN: Resume key for a continued request.
            ULONG EntriesReturned;      // OUT: Entries returned in respose buffer.
            ULONG BytesNeeded;          // OUT: Size (byte count) of next entry.
            WCHAR ConnectionName[1];    // IN: Connection name described above.
        } GetConnStatus;

        //
        // FSCTL_NWR_GET_CONN_INFO
        //
        struct {
            ULONG ConnectionNameLength; // IN: Length of the connection name we want.
            WCHAR ConnectionName[1];    // IN: Connection name described above.
        } GetConnInfo;

        //
        // FSCTL_NWR_GET_CONN_PERFORMANCE
        //
        struct {

            //
            // These are the fields for the NETCONNECTINFOSTRUCT.
            //

            DWORD dwFlags;
            DWORD dwSpeed;
            DWORD dwDelay;
            DWORD dwOptDataSize;

            //
            // This is the remote name in question.
            //

            ULONG RemoteNameLength;
            WCHAR RemoteName[1];
        } GetConnPerformance;

        struct {
            ULONG DebugFlags;           // Value for NwDebug
        } DebugValue;

    } Parameters;

} NWR_REQUEST_PACKET, *PNWR_REQUEST_PACKET;

typedef struct _NWR_NDS_REQUEST_PACKET {

    //
    // Version of structure in Buffer 2.
    //

    ULONG Version;

    union {

        //
        //  For FSCTL_NWR_NDS_RESOLVE_NAME
        //

        struct {
            ULONG ObjectNameLength;         // IN
            DWORD ResolverFlags;            // IN
            DWORD BytesWritten;             // OUT
            WCHAR ObjectName[1];            // IN
        } ResolveName;

        //
        //  For FSCTL_NWR_NDS_READ_INFO
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD BytesWritten;             // OUT
        } GetObjectInfo;

        //
        //  For FSCTL_NWR_NDS_LIST_SUBS
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD_PTR IterHandle;           // IN
            DWORD BytesWritten;             // OUT
        } ListSubordinates;

        //
        // For FSCTL_NWR_NDS_READ_ATTR
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD_PTR IterHandle;           // IN
            DWORD BytesWritten;             // OUT
            DWORD AttributeNameLength;      // IN
            WCHAR AttributeName[1];         // IN
        } ReadAttribute;

        //
        // For FSCTL_NWR_NDS_OPEN_STREAM
        //

        struct {
            DWORD FileLength;                 // OUT
            DWORD StreamAccess;               // IN
            DWORD ObjectOid;                  // IN
            UNICODE_STRING StreamName;        // IN
            WCHAR StreamNameString[1];        // IN
        } OpenStream;

        //
        // For FSCTL_NWR_NDS_SET_CONTEXT
        //

        struct {
            DWORD TreeNameLen ;               // IN
            DWORD ContextLen;                 // IN
            WCHAR TreeAndContextString[1];    // IN
        } SetContext;

        //
        // For FSCTL_NWR_NDS_GET_CONTEXT
        //

        struct {
            UNICODE_STRING Context;           // OUT
            DWORD TreeNameLen ;               // IN
            WCHAR TreeNameString[1];          // IN
        } GetContext;

        //
        // For FSCTL_NWR_NDS_VERIFY_TREE
        //

        struct {
            UNICODE_STRING TreeName;          // IN
            WCHAR NameString[1];              // IN
        } VerifyTree;

        //
        // For FSCTL_NWR_NDS_GET_QUEUE_INFO
        //

        struct {
            UNICODE_STRING QueueName;          // IN
            UNICODE_STRING HostServer;         // OUT
            DWORD QueueId;                     // OUT
        } GetQueueInfo;

        //
        // For FSCTL_NWR_NDS_GET_VOLUME_INFO
        //

        struct {
            DWORD ServerNameLen;    // OUT
            DWORD TargetVolNameLen; // OUT
            DWORD VolumeNameLen;    // IN
            WCHAR VolumeName[1];    // IN
        } GetVolumeInfo;

        //
        // For FSCTL_NWR_NDS_RAW_FRAGEX
        //

        struct {
            DWORD NdsVerb;          // IN
            DWORD RequestLength;    // IN
            DWORD ReplyLength;      // OUT
            BYTE  Request[1];       // IN
        } RawRequest;

        //
        // For FSCTL_NWR_NDS_CHANGE_PASS
        //

        struct {

            DWORD NdsTreeNameLength;
            DWORD UserNameLength;
            DWORD CurrentPasswordLength;
            DWORD NewPasswordLength;

            //
            // The above strings should be end to
            // end starting at StringBuffer.
            //

            WCHAR StringBuffer[1];
        } ChangePass;

        //
        // For FSCTL_NWR_NDS_LIST_TREES
        //

        struct {

            DWORD NtUserNameLength;   // IN
            LARGE_INTEGER UserLuid;   // OUT
            DWORD TreesReturned;      // OUT
            WCHAR NtUserName[1];      // IN
        } ListTrees;

    } Parameters;

} NWR_NDS_REQUEST_PACKET, *PNWR_NDS_REQUEST_PACKET;


NTSTATUS
NwNdsOpenTreeHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT PHANDLE  phNwRdrHandle
);

// NwNdsOpenTreeHandle( PUNICODE_STRING, PHANDLE )
//
// Given an NDS tree name, this opens a handle the the redirector
// for accessing that tree.  The handle should closed using the
// standard NT CloseHandle() call. This function is only a
// simple wrapper around NT OpenFile().

//
// Administrativa.
//

#define HANDLE_TYPE_NCP_SERVER  1
#define HANDLE_TYPE_NDS_TREE    2


NTSTATUS
NwNdsOpenGenericHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwRdrHandle
);

// NwNdsOpenGenericHandle( PUNICODE_STRING, LPDWORD, PHANDLE )
//
// Given a name, this opens a handle the the redirector for accessing that
// named tree or server. lpdwHandleType is set to either HANDLE_TYPE_NCP_SERVER
// or HANDLE_TYPE_NDS_TREE accordingly. The handle should be closed using
// the standard NT CloseHandle() call. This function is only a simple
// wrapper around NT OpenFile().

NTSTATUS
NwNdsResolveName (
    IN HANDLE           hNdsTree,
    IN PUNICODE_STRING  puObjectName,
    OUT DWORD           *dwObjectId,
    OUT PUNICODE_STRING puReferredServer,
    OUT PBYTE           pbRawResponse,
    IN DWORD            dwResponseBufferLen
);

// NwNdsResolveName(HANDLE, PUNICODE_STRING, PDWORD)
//
// Resolve the given name to an NDS object id.  This utilizes
// NDS verb 1.
//
// There is currently no interface for canonicalizing names.
// This call will use the default context if one has been set
// for this NDS tree.
//
// puReferredServer must point to a UNICODE_STRING with enough
// space to hold a server name (MAX_SERVER_NAME_LENGTH) *
// sizeof( WCHAR ).
//
// If dwResponseBufferLen is not 0, and pbRawResponse points
// to a writable buffer of length dwResponseBufferLen, then
// this routine will also return the entire NDS response in
// the raw response buffer.  The NDS response is described
// by NDS_RESPONSE_RESOLVE_NAME.
//
// Arguments:
//
//     HANDLE hNdsTree - The name of the NDS tree that we are interested in looking into.
//     PUNICODE_STRING puObjectName - The name that we want resolved into an object id.
//     DWORD *dwObjectId - The place where we will place the object id.
//     BYTE *pbRawResponse - The raw response buffer, if desired.
//     DWORD dwResponseBufferLen - The length of the raw response buffer.

WORD
NwParseNdsUncPath(
    IN OUT LPWSTR * Result,
    IN LPWSTR ContainerName,
    IN ULONG flag
);

NTSTATUS NwNdsOpenRdrHandle(
    OUT PHANDLE  phNwRdrHandle
);

NTSTATUS
NwNdsGetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    OUT PUNICODE_STRING puContext
);

VOID
NwAbbreviateUserName(
    IN  LPWSTR pszFullName,
    OUT LPWSTR pszUserName
);

VOID
NwMakePrettyDisplayName(
    IN  LPWSTR pszName
);

DWORD
NWPGetConnectionStatus(
    IN     LPWSTR  pszRemoteName,
    IN OUT PDWORD_PTR ResumeKey,
    OUT    LPBYTE  Buffer,
    IN     DWORD   BufferSize,
    OUT    PDWORD  BytesNeeded,
    OUT    PDWORD  EntriesRead
);

BOOL
NwIsNdsSyntax(
    IN LPWSTR lpstrUnc
);

DWORD
NwOpenAndGetTreeInfo(
    LPWSTR pszNdsUNCPath,
    HANDLE *phTreeConn,
    DWORD  *pdwOid
);

static
DWORD
NwRegQueryValueExW(
    IN HKEY hKey,
    IN LPWSTR lpValueName,
    OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE  lpData,
    IN OUT LPDWORD lpcbData
    );

DWORD
NwReadRegValue(
    IN HKEY Key,
    IN LPWSTR ValueName,
    OUT LPWSTR *Value
    );

DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    );

DWORD
NwQueryInfo(
    OUT PDWORD pnPrintOptions,
    OUT LPWSTR *ppszPreferredSrv
    );

DWORD
NwGetConnectionStatus(
    IN  LPWSTR  pszRemoteName,
    OUT PDWORD_PTR ResumeKey,
    OUT LPBYTE  *Buffer,
    OUT PDWORD  EntriesRead
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\nwtest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      nwtest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#include "nwtest.h"

HRESULT
NetwareTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//
//   Description:
//   This routine enumerates bindery or tree logins and in the case of tree login gives the
//   default context.
//   It also gets the server attached to.
//
//   Argument:
//   None.
//
//   Author:
//   Rajkumar .P 07/21/98
//
{
//    PTESTED_DOMAIN Context = pParams->pDomain;

    LPWSTR pszCurrentContext = NULL;
    DWORD dwPrintOptions;

    LPWSTR pszName;
    WCHAR  szUserName[MAX_PATH+1] = L"";
    WCHAR  szNoName[2] = L"";
    DWORD_PTR ResumeKey = 0;
    LPBYTE pBuffer = NULL;
    DWORD  EntriesRead = 0;

    DWORD  dwMessageId;

    UNICODE_STRING uContext;
    WCHAR  szContext[MAX_PATH+1];
    LPWSTR pszTemp;

    // Get the current default tree or server name
    DWORD err ;
    PCONN_STATUS pConnStatus = NULL;
    DWORD i;
    PCONN_STATUS pConnStatusTmp;
    PCONN_STATUS pConnStatusUser;
    PCONN_STATUS pConnStatusNoUser;
    HANDLE handleRdr;
    LPWSTR pszText;

    // WNet calls related declarations;
    DWORD dwError;
    LPNETRESOURCE lpNetResource = NULL;
    HANDLE  hEnum;
    DWORD   dwCount;
    LPNETRESOURCE lpBuffer;
    DWORD         BufferSize;

	HRESULT			hr = hrOK;


	InitializeListHead( &pResults->Netware.lmsgOutput );

	PrintStatusMessage(pParams, 4, IDS_NETWARE_STATUS_MSG);
	
    //
    // Check if client services for netware has been installed
    //
/*
	dwError = WNetOpenEnum(
							RESOURCE_GLOBALNET,
							RESOURCETYPE_ANY | RESOURCETYPE_PRINT | RESOURCETYPE_DISK,
							0,
							lpNetResource,
							&hEnum);

	if (dwError != NO_ERROR) {
       if (dwError == ERROR_NO_NETWORK)
          printf("No Network is present\n");
       printf("WNetOpenEnum failed. Not Able to determine client services for netware is installed\n");
       return FALSE;
    }

    lpBuffer = LocalAlloc(LMEM_ZEROINIT,sizeof(NETRESOURCE) * 100); // arbit

    dwError = WNetEnumResource(
                     hEnum,
                     &dwCount,
                     lpBuffer,
                     &BufferSize);


    if (dwError != NO_ERROR) {

       if (DebugVerbose)
           printf("Error: WNetEnumResource\n");

       if (dwError == ERROR_NO_MORE_ITEMS)
         printf("ERROR_NO_MORE_ITEM\n");

       dwError = GetLastError();

       if (dwError == ERROR_MORE_DATA) {
         if (DebugVerbose)
           printf("ERROR_MORE_DATA\n");
       }

       if (dwError == ERROR_INVALID_HANDLE)
          printf("ERROR_INVALID_HANDLE\n");

       if (dwError == ERROR_NO_NETWORK)
          printf("ERROR_NO_NETWORK\n");

       if (dwError == ERROR_EXTENDED_ERROR)
          printf("ERROR_EXTENDED_ERROR\n");
    }
    else {
        printf("dwCount %d \n",dwCount);
    }

    LocalFree(lpBuffer);
*/

    // end of WNet calls

	err = NwQueryInfo( &dwPrintOptions, &pszCurrentContext );
	
	if ( err == NO_ERROR )
	{
		
		szContext[0] = 0;
		uContext.Buffer = szContext;
		uContext.Length = uContext.MaximumLength
						  = sizeof(szContext)/sizeof(szContext[0]);
		
		if ( pszCurrentContext )
		{
			pszName = pszCurrentContext;
		}
		else
		{
			pszName = szNoName;
		}
		
		if ( pszName[0] == TREECHAR )
		{
			// Get the tree name from the full name *TREE\CONTEXT
			
			if ( pszTemp = wcschr( pszName, L'\\' ))
				*pszTemp = 0;
			
			dwMessageId = NW_MESSAGE_NOT_LOGGED_IN_TREE;
		}
		else
		{
			dwMessageId = NW_MESSAGE_NOT_LOGGED_IN_SERVER;
		}
		
		if ( pszName[0] != 0 )  // there is preferred server/tree
		{
			err = NwGetConnectionStatus( pszName,
										 &ResumeKey,
										 &pBuffer,
										 &EntriesRead );
		}
		
		if ( err == NO_ERROR  && EntriesRead > 0 )
			// For trees, we'll get more than one entry
		{
			pConnStatus = (PCONN_STATUS) pBuffer;
			
			if ( EntriesRead > 1 && pszName[0] == TREECHAR )
			{
				// If there is more than one entry for trees,
				// then we need to find one entry where username is not null.
				// If we cannot find one, then just use the first one.
				
				pConnStatusTmp = pConnStatus;
				pConnStatusUser = NULL;
				pConnStatusNoUser = NULL;
				
				for ( i = 0; i < EntriesRead ; i++ )
				{
					if ( pConnStatusTmp->fNds )
					{
						pConnStatusNoUser = pConnStatusTmp;
						
						if (  ( pConnStatusTmp->pszUserName != NULL )
							  && (  ( pConnStatusTmp->dwConnType
									  == NW_CONN_NDS_AUTHENTICATED_NO_LICENSE )
									|| ( pConnStatusTmp->dwConnType
										 == NW_CONN_NDS_AUTHENTICATED_LICENSED )
								 )
						   )
						{
							// Found it
							pConnStatusUser = pConnStatusTmp;
							break;
						}
					}
					
					// Continue with the next item
					pConnStatusTmp = (PCONN_STATUS)
									 ( (DWORD_PTR) pConnStatusTmp
									   + pConnStatusTmp->dwTotalLength);
				}
				
				if ( pConnStatusUser )
				{
					// found one nds entry with a user name
					pConnStatus = pConnStatusUser;
				}
				else if ( pConnStatusNoUser )
				{
					// use an nds entry with no user name
					pConnStatus = pConnStatusNoUser;
				}
				// else use the first entry
			}
			
			if (  ( pConnStatus->pszUserName )
				  && ( pConnStatus->pszUserName[0] != 0 )
			   )
			{
				NwAbbreviateUserName( pConnStatus->pszUserName,
									  szUserName);
				
				NwMakePrettyDisplayName( szUserName );
				
				if ( pszName[0] != TREECHAR )
				{
					dwMessageId = NW_MESSAGE_LOGGED_IN_SERVER;
				}
				else
				{
					dwMessageId = NW_MESSAGE_LOGGED_IN_TREE;
				}
			}
			
			if ( pszName[0] == TREECHAR )
			{
				// For trees, we need to get the current context
				
				// Open a handle to the redirector
				handleRdr = NULL;
				err = RtlNtStatusToDosError(
											 NwNdsOpenRdrHandle( &handleRdr ));
				
				if ( err == NO_ERROR )
				{
					UNICODE_STRING uTree;
					RtlInitUnicodeString( &uTree, pszName+1 ); // get past '*'
					
					// Get the current context in the default tree
					err = RtlNtStatusToDosError(
												NwNdsGetTreeContext( handleRdr,
						&uTree,
						&uContext));
				}
				
				if ( handleRdr != NULL )
					NtClose( handleRdr );
			}
		}
		
		if ( !err )
		{
			switch (dwMessageId)
			{
				case NW_MESSAGE_NOT_LOGGED_IN_TREE:
					// "You are not logged in to the directory tree %s. "
					AddMessageToList(&pResults->Netware.lmsgOutput,
									 Nd_Quiet,
									 IDS_NETWARE_NOT_LOGGED_IN_TREE,
									 pszName[0] == TREECHAR ? pszName + 1: pszName);
					hr = S_FALSE;
					break;
				case NW_MESSAGE_NOT_LOGGED_IN_SERVER:
					// "You are not logged in to your preferred server %s.\n"
					AddMessageToList(&pResults->Netware.lmsgOutput,
									 Nd_Quiet,
									 IDS_NETWARE_NOT_LOGGED_IN_SERVER,
									 pszName[0] == TREECHAR ? pszName + 1: pszName);
					hr = S_FALSE;
					break;
				case NW_MESSAGE_LOGGED_IN_SERVER:
					// "You are logged in to the server %s with user name %s.\n"
					AddMessageToList(&pResults->Netware.lmsgOutput,
									 Nd_Verbose,
									 IDS_NETWARE_LOGGED_IN_SERVER,
									 pszName[0] == TREECHAR ? pszName + 1: pszName,
									 szUserName);
					pResults->Netware.pszServer = StrDupTFromW(pszName[0] == TREECHAR ?
						pszName + 1 : pszName);
					pResults->Netware.pszUser = StrDupTFromW(szUserName);
					pResults->Netware.pszTree = StrDup(_T(""));
					pResults->Netware.pszContext = StrDup(_T(""));
					break;
				case NW_MESSAGE_LOGGED_IN_TREE:
					// "You are logged in to the directory tree %s with user name %s.\nThe current workstation name context is %s.\n"
					AddMessageToList(&pResults->Netware.lmsgOutput,
									 Nd_Verbose,
									 IDS_NETWARE_LOGGED_IN_TREE,
									 pszName[0] == TREECHAR ? pszName + 1: pszName,
									 szUserName,
									 szContext);
					pResults->Netware.pszTree = StrDupTFromW(pszName[0] == TREECHAR ?
						pszName + 1 : pszName);
					pResults->Netware.pszUser = StrDupTFromW(szUserName);
					pResults->Netware.pszContext = StrDupTFromW(szContext);
					pResults->Netware.pszServer = StrDup(_T(""));
			}

			// Read from the conn status if possible
			if (pConnStatus)
			{
				pResults->Netware.fConnStatus = TRUE;

				if (pConnStatus->pszUserName)
				{
					Free(pResults->Netware.pszUser);
					pResults->Netware.pszUser =
						StrDupTFromW(pConnStatus->pszUserName);
				}

				if (pConnStatus->pszServerName)
				{
					Free(pResults->Netware.pszServer);
					pResults->Netware.pszServer =
						StrDupTFromW(pConnStatus->pszServerName);
				}
				
				if (pConnStatus->pszTreeName)
				{
					Free(pResults->Netware.pszTree);
					pResults->Netware.pszTree =
						StrDupTFromW(pConnStatus->pszTreeName);
				}

				pResults->Netware.fNds = pConnStatus->fNds;
				pResults->Netware.dwConnType = pConnStatus->dwConnType;
			}
			else
				pResults->Netware.fConnStatus = FALSE;
			
		}
		
		if ( pBuffer != NULL )
		{
			LocalFree( pBuffer );
			pBuffer = NULL;
		}
	}
	
	if ( pszCurrentContext != NULL )
	{
		LocalFree( pszCurrentContext );
		pszCurrentContext = NULL;
	}
	
	if ( err != NO_ERROR )
	{
//		if (DebugVerbose)
//			printf("Error %s occurred while trying to get connection information.\n",err);
//		printf("Error getting connection information\n");
		hr = S_FALSE;
	}
		
	return hr;
	
}




WORD
NwParseNdsUncPath(
    IN OUT LPWSTR * Result,
    IN LPWSTR ContainerName,
    IN ULONG flag
)
/*++

Routine Description:

    This function is used to extract either the tree name, fully distinguished
    name path to an object, or object name, out of a complete NDS UNC path.

Arguments:

    Result - parsed result buffer.
    ContainerName - Complete NDS UNC path that is to be parsed.
    flag - Flag indicating operation to be performed:

         PARSE_NDS_GET_TREE_NAME
         PARSE_NDS_GET_PATH_NAME
         PARSE_NDS_GET_OBJECT_NAME


Return Value:

    Length of string in result buffer. If error occured, 0 is returned.

--*/ // NwParseNdsUncPath
{
    USHORT length = 2;
    USHORT totalLength = (USHORT) wcslen( ContainerName );

    if ( totalLength < 2 )
        return 0;

    //
    // First get length to indicate the character in the string that indicates the
    // "\" in between the tree name and the rest of the UNC path.
    //
    // Example:  \\<tree name>\<path to object>[\|.]<object>
    //                        ^
    //                        |
    //
    while ( length < totalLength && ContainerName[length] != L'\\' )
    {
        length++;
    }

    if ( flag == PARSE_NDS_GET_TREE_NAME )
    {
        *Result = (LPWSTR) ( ContainerName + 2 );

        return ( length - 2 ) * sizeof( WCHAR ); // Take off 2 for the two \\'s
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME && length == totalLength )
    {
        *Result = ContainerName;

        return 0;
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME )
    {
        *Result = ContainerName + length + 1;

        return ( totalLength - length - 1 ) * sizeof( WCHAR );
    }

    *Result = ContainerName + totalLength - 1;
    length = 1;

    while ( **Result != L'\\' )
    {
        *Result--;
        length++;
    }

    *Result++;
    length--;

    return length * sizeof( WCHAR );
}


NTSTATUS NwNdsOpenRdrHandle(
    OUT PHANDLE  phNwRdrHandle
)
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | GENERIC_READ;

    WCHAR NameStr[] = L"\\Device\\NwRdr\\*";
    UNICODE_STRING uOpenName;

    //
    // Prepare the open name.
    //

    RtlInitUnicodeString( &uOpenName, NameStr );

   //
   // Set up the object attributes.
   //

   InitializeObjectAttributes(
       &ObjectAttributes,
       &uOpenName,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL );

   ntstatus = NtOpenFile(
                  phNwRdrHandle,
                  DesiredAccess,
                  &ObjectAttributes,
                  &IoStatusBlock,
                  FILE_SHARE_VALID_FLAGS,
                  FILE_SYNCHRONOUS_IO_NONALERT );

   if ( !NT_ERROR(ntstatus) &&
        !NT_INFORMATION(ntstatus) &&
        !NT_WARNING(ntstatus))  {

       return IoStatusBlock.Status;

   }

   return ntstatus;
}

NTSTATUS
NwNdsGetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    OUT PUNICODE_STRING puContext
)
/*+++

    This gets the current context of the requested tree.

---*/
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD RrpSize;

    //
    // Set up the request.
    //

    RrpSize = sizeof( NWR_NDS_REQUEST_PACKET ) + puTree->Length;

    Rrp = LocalAlloc( LMEM_ZEROINIT, RrpSize );

    if ( !Rrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        (Rrp->Parameters).GetContext.TreeNameLen = puTree->Length;

        RtlCopyMemory( (BYTE *)(Rrp->Parameters).GetContext.TreeNameString,
                       puTree->Buffer,
                       puTree->Length );

        (Rrp->Parameters).GetContext.Context.MaximumLength = puContext->MaximumLength;
        (Rrp->Parameters).GetContext.Context.Length = 0;
        (Rrp->Parameters).GetContext.Context.Buffer = puContext->Buffer;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    try {

        ntstatus = NtFsControlFile( hNdsRdr,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_GETCONTEXT,
                                    (PVOID) Rrp,
                                    RrpSize,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = GetExceptionCode();
        goto ExitWithCleanup;
    }

    //
    // Copy out the length; the buffer has already been written.
    //

    puContext->Length = (Rrp->Parameters).GetContext.Context.Length;

ExitWithCleanup:

    LocalFree( Rrp );
    return ntstatus;
}



DWORD
NwGetConnectionStatus(
    IN  LPWSTR  pszRemoteName,
    OUT PDWORD_PTR ResumeKey,
    OUT LPBYTE  *Buffer,
    OUT PDWORD  EntriesRead
)
{
    DWORD err = NO_ERROR;
    DWORD dwBytesNeeded = 0;
    DWORD dwBufferSize  = TWO_KB;

    *Buffer = NULL;
    *EntriesRead = 0;

    do {

        *Buffer = (LPBYTE) LocalAlloc( LMEM_ZEROINIT, dwBufferSize );

        if ( *Buffer == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        err = NWPGetConnectionStatus( pszRemoteName,
                                      ResumeKey,
                                      *Buffer,
                                      dwBufferSize,
                                      &dwBytesNeeded,
                                      EntriesRead );

        if ( err == ERROR_INSUFFICIENT_BUFFER )
        {
            dwBufferSize = dwBytesNeeded + EXTRA_BYTES;
            LocalFree( *Buffer );
            *Buffer = NULL;
        }

    } while ( err == ERROR_INSUFFICIENT_BUFFER );

    if ( err == ERROR_INVALID_PARAMETER )  // not attached
    {
        err = NO_ERROR;
        *EntriesRead = 0;
    }

    return err;
}

VOID
NwAbbreviateUserName(
    IN  LPWSTR pszFullName,
    OUT LPWSTR pszUserName
)
{
    LPWSTR pszTemp;
    LPWSTR pszLast;
    WCHAR NextChar;

    if ( pszUserName == NULL )
        return;

    pszTemp = pszFullName;
    pszLast = pszTemp;

    *pszUserName = 0;

    while ( pszTemp = wcschr( pszTemp, L'='))
    {

        NextChar = *(++pszTemp);

        while ( NextChar != 0 && NextChar != L'.' )
        {
            *(pszUserName++) = *pszTemp;
             NextChar = *(++pszTemp);
        }

        if ( NextChar == 0 )
        {
            pszLast = NULL;
            break;
        }

        *(pszUserName++) = *pszTemp;   // put back the '.'
        pszLast = ++pszTemp;
    }

    if ( pszLast != NULL )
    {
        while ( *pszLast != 0 )
           *(pszUserName++) = *(pszLast++);
    }

    *pszUserName = 0;
}

VOID
NwMakePrettyDisplayName(
    IN  LPWSTR pszName
)
{

    if ( pszName )
    {
        CharLower((LPSTR)pszName );
        CharUpperBuff( (LPSTR)pszName, 1);
    }
}


DWORD
NWPGetConnectionStatus(
    IN     LPWSTR  pszRemoteName,
    IN OUT PDWORD_PTR ResumeKey,
    OUT    LPBYTE  Buffer,
    IN     DWORD   BufferSize,
    OUT    PDWORD  BytesNeeded,
    OUT    PDWORD  EntriesRead
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    uRdrName;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";

    PNWR_REQUEST_PACKET RequestPacket = NULL;
    DWORD             RequestPacketSize = 0;
    DWORD             dwRemoteNameLen = 0;

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    dwRemoteNameLen = pszRemoteName? wcslen(pszRemoteName)*sizeof(WCHAR) : 0;

    RequestPacketSize = sizeof( NWR_REQUEST_PACKET ) + dwRemoteNameLen;

    RequestPacket = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT,
                                                      RequestPacketSize );

    if ( RequestPacket == NULL )
    {
        ntstatus = STATUS_NO_MEMORY;
        goto CleanExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_STATUS.
    //

    RequestPacket->Parameters.GetConnStatus.ResumeKey = *ResumeKey;

    RequestPacket->Version = REQUEST_PACKET_VERSION;
    RequestPacket->Parameters.GetConnStatus.ConnectionNameLength = dwRemoteNameLen;

    RtlCopyMemory( &(RequestPacket->Parameters.GetConnStatus.ConnectionName[0]),
                   pszRemoteName,
                   dwRemoteNameLen );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_STATUS,
                                (PVOID) RequestPacket,
                                RequestPacketSize,
                                (PVOID) Buffer,
                                BufferSize );

    if ( NT_SUCCESS( ntstatus ))
        ntstatus = IoStatusBlock.Status;

    *EntriesRead = RequestPacket->Parameters.GetConnStatus.EntriesReturned;
    *ResumeKey   = RequestPacket->Parameters.GetConnStatus.ResumeKey;
    *BytesNeeded = RequestPacket->Parameters.GetConnStatus.BytesNeeded;

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    if ( RequestPacket != NULL )
        LocalFree( RequestPacket );

    return RtlNtStatusToDosError( ntstatus );
}


BOOL
NwIsNdsSyntax(
    IN LPWSTR lpstrUnc
)
{
    HANDLE hTreeConn;
    DWORD  dwOid;
    DWORD  status = NO_ERROR;

    if ( lpstrUnc == NULL )
        return FALSE;

    status = NwOpenAndGetTreeInfo( lpstrUnc, &hTreeConn, &dwOid );

    if ( status != NO_ERROR )
    {
        return FALSE;
    }

    CloseHandle( hTreeConn );

    return TRUE;
}

DWORD
NwOpenAndGetTreeInfo(
    LPWSTR pszNdsUNCPath,
    HANDLE *phTreeConn,
    DWORD  *pdwOid
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    WCHAR          lpServerName[NW_MAX_SERVER_LEN];
    UNICODE_STRING ServerName;

    UNICODE_STRING ObjectName;

    *phTreeConn = NULL;

    ServerName.Length = 0;
    ServerName.MaximumLength = sizeof( lpServerName );
    ServerName.Buffer = lpServerName;

    ObjectName.Buffer = NULL;
    ObjectName.MaximumLength = ( wcslen( pszNdsUNCPath) + 1 ) * sizeof( WCHAR );

    ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                           pszNdsUNCPath,
                                           PARSE_NDS_GET_TREE_NAME );

    if ( ObjectName.Length == 0 || ObjectName.Buffer == NULL )
    {
        return ERROR_PATH_NOT_FOUND;
    }

    //
    // Open a NDS tree connection handle to \\treename
    //
    ntstatus = NwNdsOpenTreeHandle( &ObjectName, phTreeConn );

    if ( !NT_SUCCESS( ntstatus ))
    {
        return RtlNtStatusToDosError( ntstatus );
    }

    //
    // Get the path to the container to open.
    //
    ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                           pszNdsUNCPath,
                                           PARSE_NDS_GET_PATH_NAME );

    if ( ObjectName.Length == 0 )
    {
        UNICODE_STRING Root;

        RtlInitUnicodeString(&Root, L"[Root]");

        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( *phTreeConn,
                                      &Root,
                                      pdwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

    }
    else
    {
        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( *phTreeConn,
                                      &ObjectName,
                                      pdwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

    }

    if ( ntstatus == STATUS_SUCCESS && ServerName.Length )
    {
        DWORD    dwHandleType;

        //
        // NwNdsResolveName succeeded, but we were referred to
        // another server, though pdwOid is still valid.

        if ( *phTreeConn )
            CloseHandle( *phTreeConn );

        *phTreeConn = NULL;

        //
        // Open a NDS generic connection handle to \\ServerName
        //
        ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                           &dwHandleType,
                                           phTreeConn );

        if ( ntstatus != STATUS_SUCCESS )
        {
            return RtlNtStatusToDosError(ntstatus);
        }

        ASSERT( dwHandleType != HANDLE_TYPE_NCP_SERVER );
    }

    if ( !NT_SUCCESS( ntstatus ))
    {

        if ( *phTreeConn != NULL )
        {
            CloseHandle( *phTreeConn );
            *phTreeConn = NULL;
        }
        return RtlNtStatusToDosError(ntstatus);
    }

    return NO_ERROR;

}


static
DWORD
NwRegQueryValueExW(
    IN HKEY hKey,
    IN LPWSTR lpValueName,
    OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE  lpData,
    IN OUT LPDWORD lpcbData
    )
/*++

Routine Description:

    This routine supports the same functionality as Win32 RegQueryValueEx
    API, except that it works.  It returns the correct lpcbData value when
    a NULL output buffer is specified.

    This code is stolen from the service controller.

Arguments:

    same as RegQueryValueEx

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    UNICODE_STRING ValueName;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    DWORD BufSize;


    UNREFERENCED_PARAMETER(lpReserved);

    //
    // Make sure we have a buffer size if the buffer is present.
    //
    if ((ARGUMENT_PRESENT(lpData)) && (! ARGUMENT_PRESENT(lpcbData))) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&ValueName, lpValueName);

    //
    // Allocate memory for the ValueKeyInfo
    //
    BufSize = *lpcbData + sizeof(KEY_VALUE_FULL_INFORMATION) +
              ValueName.Length
              - sizeof(WCHAR);  // subtract memory for 1 char because it's included
                                // in the sizeof(KEY_VALUE_FULL_INFORMATION).

    KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION) LocalAlloc(
                                                     LMEM_ZEROINIT,
                                                     (UINT) BufSize
                                                     );

    if (KeyValueInfo == NULL) {
//        if (DebugVerbose)
//           printf("NWWORKSTATION: NwRegQueryValueExW: LocalAlloc failed %lu\n",
//                 GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ntstatus = NtQueryValueKey(
                   hKey,
                   &ValueName,
                   KeyValueFullInformation,
                   (PVOID) KeyValueInfo,
                   (ULONG) BufSize,
                   (PULONG) &BufSize
                   );

    if ((NT_SUCCESS(ntstatus) || (ntstatus == STATUS_BUFFER_OVERFLOW))
          && ARGUMENT_PRESENT(lpcbData)) {

        *lpcbData = KeyValueInfo->DataLength;
    }

    if (NT_SUCCESS(ntstatus)) {

        if (ARGUMENT_PRESENT(lpType)) {
            *lpType = KeyValueInfo->Type;
        }


        if (ARGUMENT_PRESENT(lpData)) {
            memcpy(
                lpData,
                (LPBYTE)KeyValueInfo + KeyValueInfo->DataOffset,
                KeyValueInfo->DataLength
                );
        }
    }

    (void) LocalFree((HLOCAL) KeyValueInfo);

    return RtlNtStatusToDosError(ntstatus);

}


DWORD
NwReadRegValue(
    IN HKEY Key,
    IN LPWSTR ValueName,
    OUT LPWSTR *Value
    )
/*++

Routine Description:

    This function allocates the output buffer and reads the requested
    value from the registry into it.

Arguments:

    Key - Supplies opened handle to the key to read from.

    ValueName - Supplies name of the value to retrieve data.

    Value - Returns a pointer to the output buffer which points to
        the memory allocated and contains the data read in from the
        registry.  This pointer must be freed with LocalFree when done.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - Failed to create buffer to read value into.

    Error from registry call.

--*/
{
    LONG    RegError;
    DWORD   NumRequired = 0;
    DWORD   ValueType;


    //
    // Set returned buffer pointer to NULL.
    //
    *Value = NULL;

    RegError = NwRegQueryValueExW(
                   Key,
                   ValueName,
                   NULL,
                   &ValueType,
                   (LPBYTE) NULL,
                   &NumRequired
                   );

    if (RegError != ERROR_SUCCESS && NumRequired > 0) {

        if ((*Value = (LPWSTR) LocalAlloc(
                                      LMEM_ZEROINIT,
                                      (UINT) NumRequired
                                      )) == NULL) {

//        if (DebugVerbose)
//            printf("NWWORKSTATION: NwReadRegValue: LocalAlloc of size %lu failed %lu\n", NumRequired, GetLastError());
//
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RegError = NwRegQueryValueExW(
                       Key,
                       ValueName,
                       NULL,
                       &ValueType,
                       (LPBYTE) *Value,
                       &NumRequired
                       );
    }
    else if (RegError == ERROR_SUCCESS) {
//        if (DebugVerbose)
//        printf("NWWORKSTATION: NwReadRegValue got SUCCESS with NULL buffer.");
        return ERROR_FILE_NOT_FOUND;
    }

    if (RegError != ERROR_SUCCESS) {

        if (*Value != NULL) {
            (void) LocalFree((HLOCAL) *Value);
            *Value = NULL;
        }

        return (DWORD) RegError;
    }

    return NO_ERROR;
}



DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    )
/*++

Routine Description:

    This routine opens the current user's registry key under
    \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NWCWorkstation\Parameters

Arguments:

    DesiredAccess - The access mask to open the key with

    phKeyCurrentUser - Receives the opened key handle

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD err;
    HKEY hkeyWksta;
    LPWSTR CurrentUser;
    DWORD Disposition;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    err = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &hkeyWksta
                   );

    if ( err ) {
//        if (DebugVerbose)
//           printf("NWPROVAU: NwGetCurrentUserRegKey open Paramters key unexpected error %lu!\n",err);
        return err;
    }
    //
    // Get the current user's SID string.
    //
    err = NwReadRegValue(
              hkeyWksta,
              NW_CURRENTUSER_VALUENAME,
              &CurrentUser
              );


    if ( err ) {
//        if (DebugVerbose)
//           printf("NWPROVAU: NwGetCurrentUserRegKey read CurrentUser value unexpected error %lu !\n", err);
 (void) RegCloseKey( hkeyWksta );
        return err;
    }

    (void) RegCloseKey( hkeyWksta );

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    err = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_OPTION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &hkeyWksta
                   );
    if ( err ) {
//        if (DebugVerbose)
//           printf("NWPROVAU: NwGetCurrentUserRegKey open Parameters\\Option key unexpected error %lu!\n", err);
        return err;
    }

    //
    // Open current user's key
    //
    err = RegOpenKeyExW(
              hkeyWksta,
              CurrentUser,
              REG_OPTION_NON_VOLATILE,
              DesiredAccess,
              phKeyCurrentUser
              );

    if ( err == ERROR_FILE_NOT_FOUND)
    {

        //
        // Create <NewUser> key under NWCWorkstation\Parameters\Option
        //
        err = RegCreateKeyExW(
                  hkeyWksta,
                  CurrentUser,
                  0,
                  WIN31_CLASS,
                  REG_OPTION_NON_VOLATILE,
                  DesiredAccess,
                  NULL,                      // security attr
                  phKeyCurrentUser,
                  &Disposition
                  );

    }

    if ( err ) {
//        if (DebugVerbose)
//           printf("NWPROVAU: NwGetCurrentUserRegKey open or create of Parameters\\Option\\%ws key failed %lu\n", CurrentUser, err);
    }

    (void) RegCloseKey( hkeyWksta );
    (void) LocalFree((HLOCAL)CurrentUser) ;
    return err;
}


DWORD
NwQueryInfo(
    OUT PDWORD pnPrintOptions,
    OUT LPWSTR *ppszPreferredSrv
    )
/*++

Routine Description:
    This routine gets the user's preferred server and print options from
    the registry.

Arguments:

    pnPrintOptions - Receives the user's print option

    ppszPreferredSrv - Receives the user's preferred server


Return Value:

    Returns the appropriate Win32 error.

--*/
{

    HKEY hKeyCurrentUser = NULL;
    DWORD BufferSize;
    DWORD BytesNeeded;
    DWORD PrintOption;
    DWORD ValueType;
    LPWSTR PreferredServer ;
    DWORD err ;

    //
    // get to right place in registry and allocate dthe buffer
    //
    if (err = NwpGetCurrentUserRegKey( KEY_READ, &hKeyCurrentUser))
    {
        //
        // If somebody mess around with the registry and we can't find
        // the registry, just use the defaults.
        //
        *ppszPreferredSrv = NULL;
   //     *pnPrintOptions = NW_PRINT_OPTION_DEFAULT;
        return NO_ERROR;
    }

    BufferSize = sizeof(WCHAR) * (MAX_PATH + 2) ;
    PreferredServer = (LPWSTR) LocalAlloc(LPTR, BufferSize) ;
    if (!PreferredServer)
        return (GetLastError()) ;

    //
    // Read PreferredServer value into Buffer.
    //
    BytesNeeded = BufferSize ;

    err = RegQueryValueExW( hKeyCurrentUser,
                            NW_SERVER_VALUENAME,
                            NULL,
                            &ValueType,
                            (LPBYTE) PreferredServer,
                            &BytesNeeded );

    if (err != NO_ERROR)
    {
        //
        // set to empty and carry on
        //
        PreferredServer[0] = 0;
    }


    if (hKeyCurrentUser != NULL)
        (void) RegCloseKey(hKeyCurrentUser) ;

    *ppszPreferredSrv = PreferredServer ;
    return NO_ERROR ;
}


/*!--------------------------------------------------------------------------
	NetwareGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void NetwareGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	int		ids;
	LPTSTR	pszConnType;
	
	if (!pResults->Ipx.fEnabled)
	{
		return;
	}
	
	if (pParams->fVerbose || !FHrOK(pResults->Netware.hr))
	{
		BOOL		fVerboseT, fReallyVerboseT;
		
		PrintNewLine(pParams, 2);
		PrintMessage(pParams, IDS_NETWARE_TITLE_MSG);

		fVerboseT = pParams->fVerbose;
		fReallyVerboseT = pParams->fReallyVerbose;
		pParams->fReallyVerbose = TRUE;

		PrintMessageList(pParams, &pResults->Netware.lmsgOutput);

		pParams->fReallyVerbose = fReallyVerboseT;
		pParams->fVerbose = fVerboseT;


		// Now print out the results
		if (FHrOK(pResults->Netware.hr))
		{
			// Print out the user name, server name, tree and context
			PrintMessage(pParams,
						 IDS_NETWARE_USER_NAME,
						 pResults->Netware.pszUser == 0 ? _T("") : pResults->Netware.pszUser);
			PrintMessage(pParams,
						 IDS_NETWARE_SERVER_NAME,
						 pResults->Netware.pszServer == 0 ? _T("") : pResults->Netware.pszServer);
			PrintMessage(pParams,
						 IDS_NETWARE_TREE_NAME,
						 pResults->Netware.pszTree == 0 ? _T("") : pResults->Netware.pszTree);
			PrintMessage(pParams,
						 IDS_NETWARE_CONTEXT,
						 pResults->Netware.pszContext == 0 ? _T("") : pResults->Netware.pszContext);

			// Print out the connection type and nds
			if (pResults->Netware.fConnStatus)
			{
				PrintMessage(pParams,
							 IDS_NETWARE_NDS,
							 MAP_YES_NO(pResults->Netware.fNds));

				switch (pResults->Netware.dwConnType)
				{
					case NW_CONN_NOT_AUTHENTICATED:
						ids = IDS_NETWARE_CONN_NOT_AUTHENTICATED;
						break;
					case NW_CONN_BINDERY_LOGIN:
						ids = IDS_NETWARE_CONN_BINDERY_LOGIN;
						break;
					case NW_CONN_NDS_AUTHENTICATED_NO_LICENSE:
						ids = IDS_NETWARE_CONN_NDS_AUTHENTICATED_NO_LICENSE;
						break;
					case NW_CONN_NDS_AUTHENTICATED_LICENSED:
						ids = IDS_NETWARE_CONN_NDS_AUTHENTICATED_LICENSED;
						break;
					case NW_CONN_DISCONNECTED:
						ids = IDS_NETWARE_CONN_DISCONNECTED;
						break;
					default:
						ids = IDS_NETWARE_CONN_UNKNOWN;
						break;
				}
				PrintMessage(pParams,
							 ids,
							 pResults->Netware.dwConnType);
			}
		}
	}
}

/*!--------------------------------------------------------------------------
	NetwarePerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void NetwarePerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	NetwareCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void NetwareCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	Free(pResults->Netware.pszUser);
	pResults->Netware.pszUser = NULL;
	
	Free(pResults->Netware.pszServer);
	pResults->Netware.pszServer = NULL;
	
	Free(pResults->Netware.pszTree);
	pResults->Netware.pszTree = NULL;
	
	Free(pResults->Netware.pszContext);
	pResults->Netware.pszContext = NULL;
	
	MessageListCleanUp(&pResults->Netware.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\params.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       params.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_PARAMS
#define HEADER_PARAMS

//////////////////////////////////////////////////////////////////////////////

//most user defined parameters, this will be passed to each test routine
typedef struct {
    PTESTED_DOMAIN pDomain;
    BOOL    fVerbose;
    BOOL    fReallyVerbose;
    BOOL    fDebugVerbose;
    BOOL    fFixProblems; //GlobalFixProblems;
    BOOL    fDcAccountEnum;   //GlobalDcAccountEnum;
    BOOL    fProblemBased;  // ProblemBased
    int     nProblemNumber; // ProblemNumber
    FILE*   pfileLog;       // pointer to the log file
    BOOL    fLog;
} NETDIAG_PARAMS;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\polprn.h ===
#ifndef HEADER_POLPRN
#define HEADER_POLPRN

#include "spdcheck.h"

#define MAX_STR_LEN						1024



typedef struct _DNSIPADDR {
	LPTSTR		pszDomainName;
	DWORD		dwNumIpAddresses;
	PULONG		puIpAddr;
}DNSIPADDR, *PDNSIPADDR;


typedef struct _FilterDNS {
	DWORD FilterSrcNameID;
	DWORD FilterDestNameID;
} FILTERDNS, *PFILTERDNS;

#define PROT_ID_ANY			 0					// Protocol IDs
#define PROT_ID_ICMP	 1
#define PROT_ID_TCP	 	6
#define PROT_ID_EGP	 	8
#define PROT_ID_UDP	 	17
#define PROT_ID_HMP	 	20
#define PROT_ID_XNS_IDP 22
#define PROT_ID_RDP		 27
#define PROT_ID_RVD	 	66
#define PROT_ID_RAW	 255

//Filter DNS IDs

#define FILTER_MYADDRESS    111
#define FILTER_ANYADDRESS   112
#define FILTER_DNSADDRESS   113
#define FILTER_IPADDRESS    114
#define FILTER_IPSUBNET     115

#define BUFFER_SIZE    	  2048

//macros
#define FreeP(_pzstr)\
	if(_pzstr){\
		free(_pzstr);\
		_pzstr = NULL;\
	}\


//function prototypes
/*
VOID PrintPolicyList(
	IN PIPSEC_POLICY_DATA pPolicy,
	IN BOOL bVerb,
	IN BOOL bAssigned,
	IN BOOL bWide);

VOID PrintRuleList(
	IN PIPSEC_NFA_DATA pIpsecNFAData,
	IN BOOL bVerb,
	IN BOOL bWide);
*/
DWORD ConverWideToMultibyte(LPWSTR pwch, char **ppmbbuf);

BOOL PrintAuthMethodsList(
	CHECKLIST *pcheckList,
	IN PIPSEC_AUTH_METHOD pIpsecAuthData);

BOOL PrintNegPolDataList(
	IN PCHECKLIST pCheckList,
	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData);

BOOL CheckSoft(
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods);

HRESULT FormatTime(
	IN time_t t,
	OUT LPTSTR pszTimeStr);

VOID PrintSecurityMethodsTable(
	CHECKLIST* pcheckList,
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods);

VOID PrintStorageInfoList(
	CHECKLIST* pcheckList,
	IN BOOL bDeleteAll);
VOID PrintAlgoInfoTable(
	CHECKLIST* pcheckList,
	IN PIPSEC_ALGO_INFO   Algos,
	IN DWORD dwNumAlgos);
VOID  PrintLifeTimeTable(
	CHECKLIST* pcheckList,
	IN LIFETIME LifeTime);




/*VOID
PrintSecurityMethodsList(
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods
	);

VOID PrintAlgoInfoList(
	IN PIPSEC_ALGO_INFO   Algos,
	IN DWORD dwNumAlgos);


VOID PrintLifeTimeList(
	IN LIFETIME LifeTime);

VOID PrintFilterDataList(
	IN PIPSEC_FILTER_DATA pIpsecFilterData,
	IN BOOL bVerb,
	IN BOOL bResolveDNS,
	IN BOOL bWide);
*/
BOOL PrintFilterSpecList(
	CHECKLIST *pcheckList,
	IN PIPSEC_FILTER_SPEC pIpsecFilterSpec,
	IN PIPSEC_NFA_DATA pIpsecNFAData);

VOID PrintResolveDNS(
	CHECKLIST * pcheckList,
	LPWSTR pszDNSName	);

VOID PrintProtocolNameList(
	CHECKLIST* pcheckList,
	DWORD dwProtocol);

BOOL PrintISAKMPDataList(
	CHECKLIST* pcheckList,
	IN PIPSEC_ISAKMP_DATA pIpsecISAKMPData);

VOID PrintISAKAMPSecurityMethodsList(
	CHECKLIST* pcheckList,
	IN CRYPTO_BUNDLE SecurityMethods);
/*
VOID PrintGPOList(
	CHECKLIST* pcheckList,
	IN PGPO pGPO);

*/
VOID PrintIPAddrList(CHECKLIST* pcheckList, IN DWORD dwAddr);


VOID PrintIPAddrDNS(
	CHECKLIST* pcheckList,
	IN DWORD dwAddr);

VOID GetFilterDNSDetails(
	IN PIPSEC_FILTER_SPEC pFilterData,
	IN OUT PFILTERDNS pFilterDNS);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\precomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       precomp.h
//
//--------------------------------------------------------------------------

#include "ndcommon.h"
// Porting to Source Depot - smanda #include <nlcommon.h>
#include <winsock2.h>
#include "ndstruct.h"
#include "params.h"
#include "results.h"
#include "netdiag.h"
#include "resource.h"

#include "dcutil.h"
#include "domutil.h"

#include "xportst.h"
#include "format.h"

#include "tfschar.h"

#include "polprn.h"
#include "spdcheck.h"
#include "spdres.h"
#include "spdprint.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\polprn.c ===
#include "precomp.h"
DWORD ConverWideToMultibyte(LPWSTR pwch, char **ppmbbuf)
//++
//Description:
//Converts wide to multibyte
//
//Arguments:
//	IN LPWSTR
//	IN car **
//	
//Return:
//	Success or failure
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	char *ptempmbbuf = NULL;	
	DWORD dwError = ERROR_SUCCESS;
	size_t size;
	
	size= wcstombs( NULL,
           				   pwch,
           				   wcslen(pwch));		
	ptempmbbuf = (char *)malloc(size+1);
	//ptempmbbuf = (char *)malloc((sizeof(char)) * dwError);
	if(!ptempmbbuf)
		 return GetLastError();

	size= wcstombs( ptempmbbuf,
           			    pwch,
           			   size);
	//strncpy(ptemp, ptempmbbuf, dwError);
	ptempmbbuf[size] = '\0';
	*ppmbbuf = ptempmbbuf;
	return dwError;
}

BOOL PrintNegPolDataList(
	CHECKLIST* pcheckList,
	IN PIPSEC_NEGPOL_DATA pIpsecNegPolData)
//++
//Description:
//Prints Negotiation Policies
//
//Arguments:
//	IN CHECKLIST
//	IN PIPSEC_NEGPOL_DATA
//	
//Return:
//	Success or failure
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{

	BOOL bSoft=FALSE;
	wchar_t pszGUIDStr[BUFFER_SIZE]={0};
	_TCHAR pszStrTime[BUFFER_SIZE]={0};
	char * pmbbuf = NULL;
	//_TCHAR pszStrTruncated[BUFFER_SIZE]={0};
	DWORD i=0,
		dwError = 0;
	DWORD cnt;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	

	if(pIpsecNegPolData)
	{	
		if(pIpsecNegPolData->pszIpsecName){
			dwError = ConverWideToMultibyte(pIpsecNegPolData->pszIpsecName, &pmbbuf);
			if(dwError){
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
								Nd_Verbose, IDS_SPD_MEM_ERROR,
								dwError);
				return S_FALSE ;
			}
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
							Nd_Verbose, SHW_STATIC_PRTNEGPOL_1,
							pmbbuf);	
			FreeP(pmbbuf);	
		}
		else
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_2);
		
		

		if(pIpsecNegPolData->pszDescription){
			dwError = ConverWideToMultibyte(pIpsecNegPolData->pszDescription, &pmbbuf);
			if(dwError){
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
							Nd_Verbose, IDS_SPD_MEM_ERROR,
							dwError);
				return S_FALSE ;
			}
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							SHW_STATIC_PRTPOLICY_4,pmbbuf);
			FreeP(pmbbuf);	
		}
		else
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							SHW_STATIC_PRTPOLICY_5);

		 
		PrintStorageInfoList(pcheckList, FALSE);
		
		if (!(IsEqualGUID(&pIpsecNegPolData->NegPolType,&GUID_NEGOTIATION_TYPE_DEFAULT)))
		{
			if(IsEqualGUID(&pIpsecNegPolData->NegPolAction,&GUID_NEGOTIATION_ACTION_NO_IPSEC))
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_3);
			else if(IsEqualGUID(&pIpsecNegPolData->NegPolAction,&GUID_NEGOTIATION_ACTION_BLOCK))
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_4);
			else
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_5);
		}


		for (cnt=0;cnt<pIpsecNegPolData->dwSecurityMethodCount;cnt++)
			if (CheckSoft(pIpsecNegPolData->pIpsecSecurityMethods[cnt]))  
			{ 
				bSoft=TRUE; 
				break;
			}

		if(bSoft)
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_8);
		else
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_9);

		if(IsEqualGUID(&pIpsecNegPolData->NegPolAction,&GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU))
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_6);
		else
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_7);

		if (pIpsecNegPolData->dwSecurityMethodCount )
		{
			if(pIpsecNegPolData->pIpsecSecurityMethods && pIpsecNegPolData->pIpsecSecurityMethods[0].PfsQMRequired)
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_16);
			else
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTNEGPOL_17);
		}		

		FormatTime((time_t)pIpsecNegPolData->dwWhenChanged, pszStrTime);
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTERDATA_10,pszStrTime);

		i = BUFFER_SIZE;

		i=StringFromGUID2( &pIpsecNegPolData->NegPolIdentifier,
						   (LPOLESTR)pszGUIDStr,i);
		dwError = ConverWideToMultibyte(pszGUIDStr, &pmbbuf);
		if(dwError){
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
							Nd_Verbose, IDS_SPD_MEM_ERROR,
							dwError);
			return S_FALSE ;
		}
		if(i>0 && (wcscmp(pszGUIDStr,L"")!=0))
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							SHW_STATIC_PRTFILTERDATA_9,pmbbuf);
		FreeP(pmbbuf);	

		if (pIpsecNegPolData->dwSecurityMethodCount)
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTNEGPOL_11);
			//AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTNEGPOL_12);
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTNEGPOL_13);
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTNEGPOL_14);
		}
		for (cnt=0;cnt<pIpsecNegPolData->dwSecurityMethodCount;cnt++)
			if(pIpsecNegPolData->pIpsecSecurityMethods)
				PrintSecurityMethodsTable(
					pcheckList, 
					pIpsecNegPolData->pIpsecSecurityMethods[cnt]);
		

	}	
	return S_OK;
}

VOID PrintAlgoInfoTable(
	CHECKLIST* pcheckList,
	IN PIPSEC_ALGO_INFO   Algos,
	IN DWORD dwNumAlgos)
//++
//Description:
//Prints AlgoInformation 
//
//Arguments:
//	IN CHECKLIST
//	IN PIPSEC_ALGO_INFO
//	IN DWORD
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	

{
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	if(dwNumAlgos==1)
	{
		if (Algos[0].operation==AUTHENTICATION)
		{
			if(Algos[0].algoIdentifier==AUTH_ALGO_MD5)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_1);
			}
			else if(Algos[0].algoIdentifier==AUTH_ALGO_SHA1)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_2);
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_3);
			}
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_4);
		}
		else if (Algos[0].operation==ENCRYPTION)
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_3);

			if(Algos[0].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_MD5)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_8);
			}
			else if(Algos[0].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_SHA1)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_9);
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_10);
			}

			if(Algos[0].algoIdentifier==CONF_ALGO_DES)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_11);
			}
			else if(Algos[0].algoIdentifier==CONF_ALGO_3_DES)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_12);
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_13);
			}
		}
	}

	else if(dwNumAlgos==2)
	{
		if (Algos[0].operation==ENCRYPTION)
		{
			if (Algos[1].operation==AUTHENTICATION)
			{
				if(Algos[1].algoIdentifier==AUTH_ALGO_MD5)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_1);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_2);
				}
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_3);
			}

			if(Algos[0].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_MD5)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_8);
			}
			else if(Algos[0].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_SHA1)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_9);
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_10);
			}

			if(Algos[0].algoIdentifier==CONF_ALGO_DES)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_11);
			}
			else if(Algos[0].algoIdentifier==CONF_ALGO_3_DES)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_12);
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_13);
			}
		}
		else
		{
			if (Algos[0].operation==AUTHENTICATION)
			{
				if(Algos[0].algoIdentifier==AUTH_ALGO_MD5)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_1);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_2);
				}
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_3);
			}

			if(Algos[1].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_MD5)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_8);
			}
			else if(Algos[1].secondaryAlgoIdentifier==HMAC_AUTH_ALGO_SHA1)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_9);
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_10);
			}

			if(Algos[1].algoIdentifier==CONF_ALGO_DES)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_11);
			}
			else if(Algos[1].algoIdentifier==CONF_ALGO_3_DES)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_12);
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_TAB_PRTALGO_13);
			}
		}
	}
}


VOID  PrintLifeTimeTable(
	CHECKLIST* pcheckList,
	IN LIFETIME LifeTime)
//++
//Description:
//Prints Life Time Table
//
//Arguments:
//	IN CHECKLIST
//	IN LIFETIME
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
					Nd_Verbose, SHW_STATIC_TAB_PRTLIFE_1,
					LifeTime.KeyExpirationTime,LifeTime.KeyExpirationBytes);
}



VOID PrintSecurityMethodsTable(
	CHECKLIST* pcheckList,
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods)
//++
//Description:
//Prints Security Method Table
//
//Arguments:
//	IN CHECKLIST
//	IN IPSEC_SECURITY_METHOD
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	if (!CheckSoft(IpsecSecurityMethods))
	{
		if(IpsecSecurityMethods.Algos)
		{
			PrintAlgoInfoTable( pcheckList, 
							     IpsecSecurityMethods.Algos,
							     IpsecSecurityMethods.Count);
		}
		PrintLifeTimeTable(pcheckList, IpsecSecurityMethods.Lifetime);
	}
}

BOOL CheckSoft(
	IN IPSEC_SECURITY_METHOD IpsecSecurityMethods)
//++
//Description:
//Checks for soft SA
//
//Arguments:
//	IN IPSEC_SECURITY_METHOD
//	
//Return:
//	TRUE or FALSE
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	BOOL bSoft=FALSE;

	if (IpsecSecurityMethods.Count==0)
	{
		bSoft=TRUE;
	}

	return bSoft;
}

HRESULT FormatTime(
	IN time_t t,
	OUT LPTSTR pszTimeStr)
//++
//Description:
//Formats Time
//
//Arguments:
//	IN time_t
//	OUT LPTSTR
//	
//Return:
//	HRESULT
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	

{

    time_t timeCurrent = time(NULL);
    LONGLONG llTimeDiff = 0;
    FILETIME ftCurrent = {0};
    FILETIME ftLocal = {0};
    SYSTEMTIME SysTime;
    _TCHAR szBuff[256] = {0};

    _tcscpy(pszTimeStr, _TEXT(""));
    GetSystemTimeAsFileTime(&ftCurrent);
    llTimeDiff = (LONGLONG)t - (LONGLONG)timeCurrent;
    llTimeDiff *= 10000000;

    *((LONGLONG UNALIGNED64 *)&ftCurrent) += llTimeDiff;
    if (!FileTimeToLocalFileTime(&ftCurrent, &ftLocal ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (!FileTimeToSystemTime( &ftLocal, &SysTime ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (0 == GetDateFormat(LOCALE_USER_DEFAULT,
                        0,
                        &SysTime,
                        NULL,
                        szBuff,
                        sizeof(szBuff)))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    _tcscat(pszTimeStr,szBuff);
    _tcscat(pszTimeStr, _TEXT(" "));

    ZeroMemory(szBuff, sizeof(szBuff));
    if (0 == GetTimeFormat(LOCALE_USER_DEFAULT,
                        0,
                        &SysTime,
                        NULL,
                        szBuff,
                        sizeof(szBuff)))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    _tcscat(pszTimeStr,szBuff);
    return S_OK;
}

BOOL PrintAuthMethodsList(
	CHECKLIST *pcheckList,
	IN PIPSEC_AUTH_METHOD pIpsecAuthData)
//++
//Description:
//Prints Auth Method List
//
//Arguments:
//	IN CHECKLIST
//	OUT PIPSEC_AUTH_METHOD
//	
//Return:
//	TRUE or FALSE
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwError = ERROR_SUCCESS;
	char * pmbbuf = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	if(pIpsecAuthData)
	{
		if(pIpsecAuthData->dwAuthType==IKE_SSPI)
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
							Nd_Verbose,SHW_STATIC_PRTAUTH_1);
		else if( pIpsecAuthData->dwAuthType==IKE_RSA_SIGNATURE && 
				pIpsecAuthData->pszAuthMethod)
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
							Nd_Verbose,SHW_STATIC_PRTAUTH_2,
							pIpsecAuthData->pszAuthMethod);
		else if ( pIpsecAuthData->dwAuthType==IKE_PRESHARED_KEY && 
			      pIpsecAuthData->pszAuthMethod){

			      dwError = ConverWideToMultibyte( pIpsecAuthData->pszAuthMethod, 
			      									&pmbbuf);
				if(dwError){
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
							Nd_Verbose, IDS_SPD_MEM_ERROR,
							dwError);
					return S_FALSE ;
				}
			
			      
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
							Nd_Verbose,SHW_STATIC_PRTAUTH_3,
							pmbbuf);
				FreeP(pmbbuf);
		}
		else
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
							Nd_Verbose,SHW_STATIC_PRTAUTH_4);
	}
	return S_OK;
}

BOOL PrintFilterSpecList(
	CHECKLIST* pcheckList,
	IN PIPSEC_FILTER_SPEC pIpsecFilterSpec,
	IN PIPSEC_NFA_DATA pIpsecNFAData)
//++
//Description:
//Prints Filter Spec  List
//
//Arguments:
//	IN CHECKLIST
//	IN PIPSEC_FILTER_SPEC
//	IN PIPSEC_NFA_DATA
//	
//Return:
//	S_OK or S_FALSE
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwError = ERROR_SUCCESS;
	char *pmbbuf = NULL;
	PFILTERDNS pFilterDNS= NULL;
	//_TCHAR pszStrTruncated[BUFFER_SIZE]={0};

	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	

	pFilterDNS = (PFILTERDNS)malloc(sizeof(FILTERDNS));
	if(!pFilterDNS){
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_SPD_MEM_ERROR );		
		return S_FALSE;
	}

	GetFilterDNSDetails(pIpsecFilterSpec, pFilterDNS);

	if (pFilterDNS)
	{
		if ( _tcscmp((const char *)pIpsecFilterSpec->pszDescription,_TEXT(""))!=0){
			dwError = ConverWideToMultibyte( pIpsecFilterSpec->pszDescription, 
											&pmbbuf);
			if(dwError){
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
							Nd_Verbose, IDS_SPD_MEM_ERROR,
							dwError);
				return S_FALSE ;
			}

			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
							Nd_Verbose, SHW_STATIC_PRTPOLICY_4, 
							pmbbuf);
			FreeP(pmbbuf);
		}
		
		else
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
							Nd_Verbose, SHW_STATIC_PRTPOLICY_5);		
		if ((pFilterDNS->FilterSrcNameID==FILTER_MYADDRESS) && 
		    (pIpsecFilterSpec->Filter.SrcAddr==0))
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							SHW_STATIC_PRTFILTER_1);

		else if ((pFilterDNS->FilterSrcNameID == FILTER_ANYADDRESS) && 
			      (pIpsecFilterSpec->Filter.SrcAddr==0))
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							SHW_STATIC_PRTFILTER_2);

		else
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							SHW_STATIC_PRTFILTER_3);
			if(_tcscmp((const char *)pIpsecFilterSpec->pszSrcDNSName,_TEXT("")) != 0)
			{
				PrintIPAddrDNS(pcheckList, pIpsecFilterSpec->Filter.SrcAddr);
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
								SHW_STATIC_PRTFILTER_16,
								pIpsecFilterSpec->pszSrcDNSName);
			}
			else
				PrintIPAddrList(pcheckList, pIpsecFilterSpec->Filter.SrcAddr);
		}

		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_4);	
		PrintIPAddrList(pcheckList, pIpsecFilterSpec->Filter.SrcMask);

		switch(pFilterDNS->FilterSrcNameID)
		{
			case FILTER_MYADDRESS :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_1);
				break;
			case FILTER_DNSADDRESS:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_15, pIpsecFilterSpec->pszSrcDNSName);
				PrintResolveDNS(pcheckList, pIpsecFilterSpec->pszSrcDNSName);								
				break;
			case FILTER_ANYADDRESS:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_3);
				break;
			case FILTER_IPADDRESS :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_4);
				break;
			case FILTER_IPSUBNET  :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_5);
				break;
			default:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_3);
				break;
		};

		if ((pFilterDNS->FilterDestNameID==FILTER_MYADDRESS)&&(pIpsecFilterSpec->Filter.DestAddr==0))
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_5);

		else if ((pFilterDNS->FilterDestNameID==FILTER_ANYADDRESS)&&(pIpsecFilterSpec->Filter.DestAddr==0))
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_6);
		else
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_7);
			if(_tcscmp((const char *)pIpsecFilterSpec->pszDestDNSName,_TEXT("")) != 0)
			{
				PrintIPAddrDNS(pcheckList, pIpsecFilterSpec->Filter.DestAddr);
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
								SHW_STATIC_PRTFILTER_16,
								pIpsecFilterSpec->pszDestDNSName);
			}
			else
				PrintIPAddrList(pcheckList, pIpsecFilterSpec->Filter.DestAddr);
		}
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						SHW_STATIC_PRTFILTER_8);	
		PrintIPAddrList(pcheckList, pIpsecFilterSpec->Filter.DestMask);
		switch(pFilterDNS->FilterDestNameID)
		{
			case FILTER_MYADDRESS :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_7);
				break;
			case FILTER_DNSADDRESS:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_16, pIpsecFilterSpec->pszDestDNSName);
				PrintResolveDNS(pcheckList, 
								pIpsecFilterSpec->pszDestDNSName);					
				break;
			case FILTER_ANYADDRESS:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_9);
				break;
			case FILTER_IPADDRESS :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_10);
				break;
			case FILTER_IPSUBNET  :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_11);
				break;
			default:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFSPEC_9);
				break;
		};

		//print tunnel endpoint
		if(pIpsecNFAData->dwTunnelFlags){
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_13);
			PrintIPAddrList(pcheckList, pIpsecNFAData->dwTunnelIpAddr);
		}

		PrintProtocolNameList(pcheckList, pIpsecFilterSpec->Filter.Protocol);

		if(pIpsecFilterSpec->Filter.SrcPort)
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_9,pIpsecFilterSpec->Filter.SrcPort);
		else
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_10);

		if(pIpsecFilterSpec->Filter.DestPort)
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_11,pIpsecFilterSpec->Filter.DestPort);
		else
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_12);
		if(pIpsecFilterSpec->dwMirrorFlag)
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
							Nd_Verbose, SHW_STATIC_PRTFSPEC_13);
		else
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
							Nd_Verbose, SHW_STATIC_PRTFSPEC_14);

		if(pFilterDNS){
			free(pFilterDNS);
			pFilterDNS = NULL;
		}
	}
	return S_OK;
}

VOID GetFilterDNSDetails(
	IN PIPSEC_FILTER_SPEC pFilterData,
	IN OUT PFILTERDNS pFilterDNS)
//++
//Description:
//Gets Filter DNS Details
//
//Arguments:
//	IN PIPSEC_FILTER_SPEC
//	IN/OUT  PFILTERDNS
//	
//Return:
//	None
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
 {
	 if ((pFilterData->Filter.SrcAddr == 0) && 
	 	(pFilterData->Filter.SrcMask == 0xffffffff) &&
	 	(_tcscmp((const char*)pFilterData->pszSrcDNSName,_TEXT("")) == 0))
	 {
		 pFilterDNS->FilterSrcNameID=FILTER_MYADDRESS;
	 }
	 else
	 {
		 if (_tcscmp((const char *)pFilterData->pszSrcDNSName,_TEXT("")) != 0)
		 {
			 pFilterDNS->FilterSrcNameID=FILTER_DNSADDRESS;
		 }
		 else if ((pFilterData->Filter.SrcAddr == 0) && 
		 		(pFilterData->Filter.SrcMask == 0))
		 {
			pFilterDNS->FilterSrcNameID=FILTER_ANYADDRESS;
		 }
		 else if ((pFilterData->Filter.SrcAddr != 0) && 
		 		(pFilterData->Filter.SrcMask == 0xffffffff))
		 {
			 pFilterDNS->FilterSrcNameID=FILTER_IPADDRESS;
		 }
		 else if ((pFilterData->Filter.SrcAddr != 0) && 
		 		(pFilterData->Filter.SrcMask != 0))
		 {
			 pFilterDNS->FilterSrcNameID=FILTER_IPSUBNET;
		 }
		 else
		 {
			  pFilterDNS->FilterSrcNameID=FILTER_ANYADDRESS;
		 }
	 }

	 if ((pFilterData->Filter.DestAddr == 0) && 
	 	(pFilterData->Filter.DestMask == 0) && 
	 	((_tcscmp((const char*)pFilterData->pszDestDNSName,_TEXT("")) == 0) == 0))
	 {
		 pFilterDNS->FilterDestNameID= FILTER_ANYADDRESS;
	 }
	 else
	 {
		 if (_tcscmp((const char *)pFilterData->pszDestDNSName,_TEXT("")) != 0)
		 {
			 pFilterDNS->FilterDestNameID = FILTER_DNSADDRESS;
		 }
		 else if ((pFilterData->Filter.DestAddr == 0) && (pFilterData->Filter.DestMask == 0xffffffff))
		 {
			 pFilterDNS->FilterDestNameID = FILTER_MYADDRESS;
		 }
		 else if ((pFilterData->Filter.DestAddr != 0) && (pFilterData->Filter.DestMask == 0xffffffff))
		 {
			 pFilterDNS->FilterDestNameID = FILTER_IPADDRESS;
		 }
		 else if ((pFilterData->Filter.DestAddr != 0) && (pFilterData->Filter.DestMask != 0))
		 {
			 pFilterDNS->FilterDestNameID =FILTER_IPSUBNET;
		 }
		 else
		 {
			 pFilterDNS->FilterDestNameID = FILTER_ANYADDRESS;
		 }
	 }
	 return;
 }


VOID PrintProtocolNameList(
	CHECKLIST* pcheckList,
	DWORD dwProtocol)
//++
//Description:
//Print Protocol Name List
//
//Arguments:
//	IN CHECKLIST
//	IN DWORD
//	
//Return:
//	None
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	switch(dwProtocol)
	{

		case PROT_ID_ICMP   :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_1);
				break;

		case PROT_ID_TCP    :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_2);
				break;

		case PROT_ID_EGP    :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_3);
				break;

		case PROT_ID_UDP    :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_4);
				break;

		case PROT_ID_HMP    :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_5);
				break;

		case PROT_ID_XNS_IDP:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_6);
				break;

		case PROT_ID_RDP    :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_7);
				break;

		case PROT_ID_RVD    :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_8);
				break;

		case PROT_ID_RAW    :
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_9);
				break;

		default:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTPROTOCOL_10);
				break;

	};

}

BOOL PrintISAKMPDataList(
	CHECKLIST* pcheckList,
	IN PIPSEC_ISAKMP_DATA pIpsecISAKMPData	)
//++
//Description:
//Print Protocol Name List
//
//Arguments:
//	IN CHECKLIST
//	IN PIPSEC_ISAKMP_DATA
//	
//Return:
//	S_OK or S_FALSE
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwLoop = 0;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	if(pIpsecISAKMPData)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMP_3);
		//AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMP_2);
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMP_5);
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMP_6);
		for ( dwLoop=0;dwLoop<pIpsecISAKMPData->dwNumISAKMPSecurityMethods;dwLoop++)
			if(pIpsecISAKMPData->pSecurityMethods)
				PrintISAKAMPSecurityMethodsList( pcheckList, 
												 pIpsecISAKMPData->pSecurityMethods[dwLoop]);
	}
	return S_OK;
}

VOID PrintISAKAMPSecurityMethodsList(
	CHECKLIST* pcheckList,
	IN CRYPTO_BUNDLE SecurityMethods)
//++
//Description:
//Print ISAKMP Security Method List
//
//Arguments:
//	IN CHECKLIST
//	IN CRYPTO_BUNDLE
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
   NETDIAG_PARAMS* pParams = pcheckList->pParams;
   NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
    if(SecurityMethods.EncryptionAlgorithm.AlgorithmIdentifier==CONF_ALGO_DES)
 	   AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMPSEC_1);
    else
 	   AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMPSEC_2);

    if(SecurityMethods.HashAlgorithm.AlgorithmIdentifier==AUTH_ALGO_SHA1)
       	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMPSEC_3);
    else
    	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMPSEC_4);

    if(SecurityMethods.OakleyGroup==DH_GROUP_1)
       	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMPSEC_5);
    else if (SecurityMethods.OakleyGroup==DH_GROUP_2)
    	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMPSEC_6);
    else
    	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTISAKMPSEC_7);
}

VOID PrintIPAddrList(CHECKLIST * pcheckList,
					     IN DWORD dwAddr)
//++
//Description:
//Print IP Address List
//
//Arguments:
//	IN CHECKLIST
//	IN DWORD
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTIP_1, (dwAddr & 0x000000FFL)         );
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTIP_1, ((dwAddr & 0x0000FF00L) >>  8) );
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTIP_1, ((dwAddr & 0x00FF0000L) >> 16) );
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTIP_2,((dwAddr & 0xFF000000L) >> 24) );
}

VOID PrintStorageInfoList(
	CHECKLIST* pcheckList,
	IN BOOL bDeleteAll)
//++
//Description:
//Print Storage Info List
//
//Arguments:
//	IN CHECKLIST
//	IN BOOL
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	_TCHAR  pszLocalMachineName[MAXSTRLEN] = {0};
	LPTSTR pszDomainName=NULL;
	DWORD MaxStringLen=MAXSTRLEN;
	PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;	
	DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY;
	HRESULT hr = ERROR_SUCCESS;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	


	if(piAssignedPolicy.iPolicySource==PS_LOC_POLICY)
	{
			
			GetComputerName(pszLocalMachineName,&MaxStringLen);

			if(!bDeleteAll)
			{
				if(_tcscmp((const char *)pszLocalMachineName,_TEXT(""))!=0)
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
									Nd_Verbose, SHW_STATIC_POLICY_7,
									pszLocalMachineName);
				else
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
									Nd_Verbose, SHW_STATIC_POLICY_10);
			}
			else
			{
				if(_tcscmp((const char *)pszLocalMachineName,_TEXT(""))!=0)
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
									Nd_Verbose, SHW_STATIC_POLICY_13,
									pszLocalMachineName);
				else
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
									Nd_Verbose, SHW_STATIC_POLICY_16);
			}

		
	}
	else if(piAssignedPolicy.iPolicySource==PS_DS_POLICY)
	{
			
			hr = DsGetDcName(NULL, //machine name
						   NULL,
						   NULL,
						   NULL,
						   Flags,
						   &pDomainControllerInfo
						   ) ;

			if(hr==NO_ERROR && pDomainControllerInfo && pDomainControllerInfo->DomainName)
			{
				pszDomainName =(LPTSTR) malloc(sizeof(LPSTR)*(
								_tcslen((const char *)pDomainControllerInfo->DomainName)+1));
				//pszDomainName= new _TCHAR[_tcslen(pDomainControllerInfo->DomainName)+1];
				if(!pszDomainName){
				
    					//reportErr(IDS_SPD_MEM_ERROR);
    					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 							Nd_Verbose, IDS_SPD_MEM_ERROR);
    					gErrorFlag = 1;    					
    					goto error;
				}
				_tcscpy(pszDomainName,
					     pDomainControllerInfo->DomainName);
			}

			if (pDomainControllerInfo)
				NetApiBufferFree(pDomainControllerInfo);
			if(!bDeleteAll)
			{
				if(pszDomainName)
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_POLICY_9,pszDomainName);
				else
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_POLICY_11);
			}
			else
			{
				if(pszDomainName)
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_POLICY_15,pszDomainName);
				else
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_POLICY_17);
			}

			if(pszDomainName) {
				free(pszDomainName);		
				pszDomainName = NULL;
			}
	}
	error:
		return;
}


VOID PrintIPAddrDNS(CHECKLIST* pcheckList, IN DWORD dwaddr)
//++
//Description:
//Print IP Address DNS List
//
//Arguments:
//	IN CHECKLIST
//	IN DWORD
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTIP_1, (dwaddr & 0x000000FFL)         );
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTIP_1, ((dwaddr & 0x0000FF00L) >>  8) );
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTIP_1, ((dwaddr & 0x00FF0000L) >> 16) );
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTIP_3,((dwaddr & 0xFF000000L) >> 24) );	
}


VOID PrintResolveDNS(
	CHECKLIST* pcheckList,
	LPWSTR pszDNSName)
//++
//Description:
//Print DNS List
//
//Arguments:
//	IN CHECKLIST
//	IN LPWSTR
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DNSIPADDR *pAddress=NULL;
	LPSTR pszDomainName=NULL;
	struct hostent *pHostEnt = NULL;
	char DNSName[MAX_STR_LEN] = {0};
	DWORD dwLen = 0,i=0,n=0;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	

	if(pszDNSName && _tcscmp((const char *)pszDNSName,_TEXT(""))!=0)
	{
		pAddress=(DNSIPADDR*)malloc(sizeof(DNSIPADDR));

		dwLen = _tcslen((const char *)pszDNSName);

		for (i=0;i<dwLen;i++)
			DNSName[i] = (char)(pszDNSName[i]);				// 	upgrade to UNICODE compliance

			DNSName[i]='\0';

		pHostEnt = gethostbyname((const LPSTR)DNSName);	// 	For Microsoft to take care !

		if (pHostEnt)
		{
			for(i=0;pHostEnt->h_addr_list[i];i++);

			pAddress->dwNumIpAddresses = i;

			pAddress->puIpAddr =(PULONG)malloc(sizeof(ULONG)*pAddress->dwNumIpAddresses); 				
			if(!pAddress){
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
								Nd_Verbose, IDS_SPD_MEM_ERROR);		
				return;
			}

			for(n=0;n< i;n++)
			{
				memcpy(&(pAddress->puIpAddr[n]),(ULONG *)pHostEnt->h_addr_list[n], sizeof(ULONG));
				PrintIPAddrDNS(pcheckList, pAddress->puIpAddr[n]);

				if(n<(i-1))
					_tprintf(_TEXT(" , "));
				else
					_tprintf(_TEXT("\n"));
			}
		}
		else
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, SHW_STATIC_PRTFILTER_17);
		}
		if(pAddress){
			free(pAddress);
			pAddress = NULL;
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\regutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       regutil.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_REGUTIL
#define HEADER_REGUTIL


BOOL
OpenAdapterKey(
  const LPTSTR Name,
  PHKEY Key
  );

BOOL 
ReadRegistryDword(HKEY Key,
                       LPCTSTR ParameterName,
                       LPDWORD Value);

BOOL ReadRegistryOemString(HKEY Key, 
                           LPWSTR ParameterName,
                           LPTSTR String,
                           LPDWORD Length);

BOOL ReadRegistryIpAddrString(HKEY Key,
                              LPCTSTR ParameterName,
                              PIP_ADDR_STRING IpAddr);

BOOL ReadRegistryString(HKEY Key,
                        LPCTSTR ParameterName,
                        LPTSTR String,
                        LPDWORD Length);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\regutil.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      regutil.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "ipcfg.h"

//Registry Reading functions, should be able to be replaced by HrReg... standard routines

BOOL ReadRegistryString(HKEY Key, LPCTSTR ParameterName, LPTSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;

    *String = '\0';
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)String,
                          Length
                          );

    if (err == ERROR_SUCCESS) {

        ASSERT(valueType == REG_SZ || valueType == REG_MULTI_SZ);

        DEBUG_PRINT(("ReadRegistryString(%s): val = \"%s\", type = %d, len = %d\n",
                    ParameterName,
                    String,
                    valueType,
                    *Length
                    ));


    } else {

        DEBUG_PRINT(("ReadRegistryString(%s): err = %d\n", ParameterName, err));

    }

    return ((err == ERROR_SUCCESS) && (*Length > sizeof('\0')));
}



BOOL ReadRegistryIpAddrString(HKEY Key, LPCTSTR ParameterName, PIP_ADDR_STRING IpAddr)
{

    LONG err;
    DWORD valueLength = 0;
    DWORD valueType;
    LPBYTE valueBuffer;
    
    UINT stringCount;
    LPTSTR stringPointer;
    LPTSTR stringAddress[MAX_STRING_LIST_LENGTH + 1];
    UINT i;
    
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          NULL,
                          &valueLength
                         );
    if ((err == ERROR_SUCCESS)) 
    {
        if((valueLength > 1) && (valueType == REG_SZ)
           || (valueLength > 2) && (valueType == REG_MULTI_SZ) ) 
        {
            valueBuffer = Malloc(valueLength);
            if( NULL == valueBuffer) 
            {
                DebugMessage("Out of Memory!");
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }
            err = RegQueryValueEx(Key,
                                  ParameterName,
                                  NULL, // reserved
                                  &valueType,
                                  valueBuffer,
                                  &valueLength
                                 );
            
            if ((err == ERROR_SUCCESS) && (valueLength > 1)) 
            {
                stringPointer = valueBuffer;
                
                DEBUG_PRINT(("ReadRegistryIpAddrString(%s): \"%s\", len = %d\n",
                             ParameterName,
                             valueBuffer,
                             valueLength
                            ));
                
                if( REG_SZ == valueType ) 
                {
                    stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
                    stringAddress[0] = stringPointer;
                    stringCount = 1;
                    while (stringPointer = strpbrk(stringPointer, STRING_ARRAY_DELIMITERS)) 
                    {
                        *stringPointer++ = '\0';
                        stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
                        stringAddress[stringCount] = stringPointer;
                        if (*stringPointer) 
                        {
                            ++stringCount;
                        }
                    }
                    
                    for (i = 0; i < stringCount; ++i) 
                    {
                        AddIpAddressString(IpAddr, stringAddress[i], "");
                    }
                } 
                else if( REG_MULTI_SZ == valueType ) 
                {
                    stringCount = 0;
                    while(strlen(stringPointer)) 
                    {
                        AddIpAddressString(IpAddr, stringPointer, "");
                        stringPointer += 1+strlen(stringPointer);
                        stringCount ++;
                    }
                    if( 0 == stringCount ) 
                        err = ERROR_PATH_NOT_FOUND;
                } 
                else 
                {
                    err = ERROR_PATH_NOT_FOUND;
                }
            } 
            else 
            {
                
                DEBUG_PRINT(("ReadRegistryIpAddrString(%s): err = %d, len = %d\n",
                             ParameterName,
                             err,
                             valueLength
                            ));
                
                err = ERROR_PATH_NOT_FOUND;
            }
            
            Free(valueBuffer);
        } 
        else 
        {
            
            DEBUG_PRINT(("ReadRegistryIpAddrString(%s): err = %d, type = %d, len = %d\n",
                         ParameterName,
                         err,
                         valueType,
                         valueLength
                        ));
            
            err = ERROR_PATH_NOT_FOUND;
        }
    }
Error:
    return (err == ERROR_SUCCESS);
}

BOOL ReadRegistryOemString(HKEY Key, LPWSTR ParameterName, LPTSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;
    DWORD valueLength = 0;

    //
    // first, get the length of the string
    //

    *String = '\0';
    err = RegQueryValueExW(Key,
                           ParameterName,
                           NULL, // reserved
                           &valueType,
                           NULL,
                           &valueLength
                           );
    if ((err == ERROR_SUCCESS) && (valueType == REG_SZ)) 
    {
        if ((valueLength <= *Length) && (valueLength > sizeof(L'\0'))) 
        {

            UNICODE_STRING unicodeString;
            OEM_STRING oemString;
            LPWSTR str = (LPWSTR)Malloc(valueLength);

            if(NULL == str)
            {
                assert(FALSE);
                DebugMessage("Out of memory!\n");
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }

            //
            // read the UNICODE string into allocated memory
            //

            err = RegQueryValueExW(Key,
                                   ParameterName,
                                   NULL,
                                   &valueType,
                                   (LPBYTE)str,
                                   &valueLength
                                   );
            if (err == ERROR_SUCCESS) {

                //
                // convert the UNICODE string to OEM character set
                //
                RtlInitUnicodeString(&unicodeString, str);
                if ( RtlUnicodeStringToOemString(&oemString, &unicodeString, TRUE) == STATUS_SUCCESS)
                {
                   if (oemString.Buffer != NULL)
                   {
                      strcpy(String, oemString.Buffer);
                      DEBUG_PRINT(("ReadRegistryOemString(%ws): val = \"%s\", len = %d\n",
                              ParameterName,
                              String,
                              valueLength
                              ));
                   }
                   RtlFreeOemString(&oemString);
                }

            } else {

                DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                            ParameterName,
                            err,
                            valueType,
                            valueLength
                            ));

            }

            Free(str);

        } 
        else 
        {
            DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                        ParameterName,
                        err,
                        valueType,
                        valueLength
                        ));

            err = !ERROR_SUCCESS;
        }
    } else {

        DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                    ParameterName,
                    err,
                    valueType,
                    valueLength
                    ));

        err = !ERROR_SUCCESS;
    }
Error:

    return (err == ERROR_SUCCESS);
}

BOOL ReadRegistryDword(HKEY Key, LPCTSTR ParameterName, LPDWORD Value)
{

    LONG err;
    DWORD valueLength;
    DWORD valueType;

    valueLength = sizeof(*Value);
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)Value,
                          &valueLength
                          );
    if ((err == ERROR_SUCCESS) && (valueType == REG_DWORD) && (valueLength == sizeof(DWORD)))
{

        DEBUG_PRINT(("ReadRegistryDword(%s): val = %d, type = %d, len = %d\n",
                    ParameterName,
                    *Value,
                    valueType,
                    valueLength
                    ));

    } else {

        DEBUG_PRINT(("ReadRegistryDword(%d,%s): err = %d\n",
                     Key, ParameterName, err));

        err = !ERROR_SUCCESS;
    }

    return (err == ERROR_SUCCESS);
}

BOOL
OpenAdapterKey(
  const LPTSTR AdapterName,
  PHKEY Key
 )
{
   LONG err;
   CHAR keyName[MAX_ADAPTER_NAME_LENGTH + sizeof(TCPIP_PARAMS_INTER_KEY)];
   HKEY ServicesKey;

   if (NULL == AdapterName) {
	   DEBUG_PRINT("No Adapter Name");
	   return FALSE;
   }

   //
   // open the handle to this adapter's TCPIP parameter key
   //

   strcpy(keyName, TCPIP_PARAMS_INTER_KEY );
   strcat(keyName, AdapterName);

   err = RegOpenKey(HKEY_LOCAL_MACHINE,SERVICES_KEY,&ServicesKey);

   if (err != ERROR_SUCCESS) {
     DEBUG_PRINT("Opening Services key failed!\n");
     return FALSE;
   }

   err = RegOpenKey(ServicesKey, keyName, Key );

   if( err != ERROR_SUCCESS ){
       DEBUG_PRINT(("OpenAdapterKey: RegOpenKey ServicesKey %s, err=%d\n",
                    keyName, GetLastError() ));
   }else{
       TRACE_PRINT(("Exit OpenAdapterKey: %s ok\n", keyName ));
   }

   return (err == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by netdiag.rc
//

// Test IDs are in 9000-9999
#define IDS_IPCONFIG_SHORT              9000
#define IDS_IPCONFIG_LONG               9001
#define IDS_MEMBER_SHORT                9002
#define IDS_MEMBER_LONG                 9003   
#define IDS_NETBT_SHORT                 9004
#define IDS_NETBT_LONG                  9005   
#define IDS_AUTONET_SHORT               9006
#define IDS_AUTONET_LONG                9007   
#define IDS_IPLOOPBK_SHORT              9008
#define IDS_IPLOOPBK_LONG               9009   
#define IDS_DEFGW_SHORT                 9010
#define IDS_DEFGW_LONG                  9011   
#define IDS_NBTNM_SHORT                 9012
#define IDS_NBTNM_LONG                  9013   
#define IDS_WINS_SHORT                  9014
#define IDS_WINS_LONG                   9015   
#define IDS_WINSOCK_SHORT               9016
#define IDS_WINSOCK_LONG                9017   
#define IDS_DNS_SHORT                   9018
#define IDS_DNS_LONG                    9019   
#define IDS_BROWSER_SHORT               9020
#define IDS_BROWSER_LONG                9021   
#define IDS_DSGETDC_SHORT               9022
#define IDS_DSGETDC_LONG                9023   
#define IDS_DCLIST_SHORT                9024
#define IDS_DCLIST_LONG                 9025   
#define IDS_TRUST_SHORT                 9026
#define IDS_TRUST_LONG                  9027   
#define IDS_KERBEROS_SHORT              9028
#define IDS_KERBEROS_LONG               9029   
#define IDS_LDAP_SHORT                  9030
#define IDS_LDAP_LONG                   9031   
#define IDS_ROUTE_SHORT                 9032
#define IDS_ROUTE_LONG                  9033   
#define IDS_NETSTAT_SHORT               9034
#define IDS_NETSTAT_LONG                9035   
#define IDS_NDIS_SHORT                  9036
#define IDS_NDIS_LONG                   9037   
#define IDS_BINDINGS_SHORT              9038
#define IDS_BINDINGS_LONG               9039   
#define IDS_WAN_SHORT                   9040
#define IDS_WAN_LONG                    9041   
#define IDS_MODEM_SHORT                 9042
#define IDS_MODEM_LONG                  9043   
#define IDS_NETWARE_SHORT               9044
#define IDS_NETWARE_LONG                9045   
#define IDS_IPX_SHORT                   9046
#define IDS_IPX_LONG                    9047
#define IDS_IPSEC_SHORT                 9048
#define IDS_IPSEC_LONG                  9049



//Global String IDs should be 10001 - 11000
#define IDS_GLOBAL_EmptyLine                        10001
#define IDSSZ_GLOBAL_StringLine                     10002
#define IDS_GLOBAL_Problem                          10003
#define IDS_GLOBAL_NoProblem                        10004
#define IDS_GLOBAL_NoComputerName                   10005
#define IDSWSZ_GLOBAL_ComputerName                  10006
#define IDSSZ_GLOBAL_DnsHostName                    10007
#define IDSSZ_DnsDomainName                         10008
#define IDS_GLOBAL_NoIpCfg                          10009
#define IDS_GLOBAL_WSA_WSAStartup_Failed            10010
#define IDS_GLOBAL_WSA_BadWSAVersion                10011
#define IDS_GLOBAL_OutOfMemory                      10012
#define IDS_GLOBAL_ERR_NoDnsName                    10013
#define IDS_GLOBAL_ERR_InitIpConfig                 10014
#define IDS_GLOBAL_ERR_GetAdaptersInfo              10015
#define IDSSZ_GLOBAL_String                         10016
#define IDS_GLOBAL_PASS                             10017
#define IDS_GLOBAL_FAIL                             10018
#define IDS_GLOBAL_PASS_NL                          10019
#define IDS_GLOBAL_FAIL_NL                          10020
#define IDS_GLOBAL_INDENT                           10021
#define IDS_GLOBAL_YES_NL                           10022
#define IDS_GLOBAL_NO_NL                            10023
#define IDS_GLOBAL_ENABLED_NL                       10024
#define IDS_GLOBAL_DISABLED_NL                      10025
#define IDS_GLOBAL_YES                              10026
#define IDS_GLOBAL_NO                               10027
#define IDS_GLOBAL_BROADCAST_NODE                   10028
#define IDS_GLOBAL_PEER_PEER_NODE                   10029
#define IDS_GLOBAL_MIXED_NODE                       10030
#define IDS_GLOBAL_HYBRID_NODE                      10031
#define IDS_GLOBAL_ADAPTER_OTHER                    10032
#define IDS_GLOBAL_ADAPTER_ETHERNET                 10033
#define IDS_GLOBAL_ADAPTER_TOKEN_RING               10034
#define IDS_GLOBAL_ADAPTER_FDDI                     10035
#define IDS_GLOBAL_ADAPTER_PPP                      10036
#define IDS_GLOBAL_ADAPTER_LOOPBACK                 10037
#define IDS_GLOBAL_ADAPTER_SLIP                     10038
#define IDS_GLOBAL_ADAPTER_UNKNOWN                  10039
#define IDS_GLOBAL_ON                               10040
#define IDS_GLOBAL_OFF                              10041
#define IDS_GLOBAL_WSTRING                          10042
#define IDS_GLOBAL_UNICODE_STRING                   10043
#define IDS_GLOBAL_NOT_OPTIONAL                     10044
#define IDS_GLOBAL_NOT_VALID_TEST                   10045
#define IDS_GLOBAL_TEST_NAME                        10046
#define IDS_GLOBAL_SKIP_OPTION                      10047
#define IDS_GLOBAL_SUCCESS                          10048
#define IDS_GLOBAL_COMPLETE                         10049

#define IDS_GLOBAL_INTERFACE_RESULTS                10051
#define IDS_GLOBAL_RESULTS                          10052
#define IDS_GLOBAL_STATUS                           10053
#define IDS_GLOBAL_DC_DOWN                          10054
#define IDS_GLOBAL_SKIP                             10055
#define IDS_GLOBAL_SKIP_NL                          10056
#define IDS_CONTACT                                 10057
#define IDS_DCTYPE_DC                               10058
#define IDS_DCTYPE_PDC                              10059
#define IDS_DCTYPE_W2K_DC                           10060

#define IDS_GLOBAL_NO_MACHINE_INFO                  10061

#define IDS_GLOBAL_PROFESSIONAL                     10062
#define IDS_GLOBAL_SERVER                           10063



//IpConfig test String IDs should be 11000-11200
#define IDSSZ_IPCFG_NODETYPE                         11001
#define IDSSZ_IPCFG_NBTSCOPEID                       11002
#define IDSSZ_IPCFG_RoutingEnabled                   11003
#define IDSSZ_IPCFG_WinsProxyEnabled                 11004
#define IDSSZ_IPCFG_DnsForNetBios                    11005
#define IDSSZ_IPCFG_Adapter                          11006
#define IDSSZ_IPCFG_HostName                         11007
#define IDS_IPCFG_DnsServers                         11008
#define IDS_IPCFG_STATUS_MSG                         11009
#define IDS_IPCFG_WINS_STATUS_MSG                   11010
#define IDS_IPCFG_WINS2_STATUS_MSG                  11011
#define IDS_IPCFG_PING_WINS                         11012
#define IDS_IPCFG_PING_WINS2                        11013
#define IDS_IPCFG_PING_WINS_FAIL                    11014
#define IDS_IPCFG_PING_WINS2_FAIL                   11015
#define IDS_IPCFG_10003                             11016
#define IDS_IPCFG_10004                             11017
#define IDS_IPCFG_10005                             11018 
#define IDS_IPCFG_10006                             11019 
#define IDS_IPCFG_10009                             11020 
#define IDS_IPCFG_10012                             11021 
#define IDS_IPCFG_10013                             11022 
#define IDS_IPCFG_10014                             11023 
#define IDS_IPCFG_10015                             11024 
#define IDS_IPCFG_10016                             11025 
#define IDS_IPCFG_10017                             11026 
#define IDS_IPCFG_10018                             11027 
#define IDS_IPCFG_10019                             11028 
#define IDS_IPCFG_10020                             11029 
#define IDS_IPCFG_10021                             11030 
#define IDS_IPCFG_10022                             11031 
#define IDS_IPCFG_10023                             11032 
#define IDS_IPCFG_10024                             11033 
#define IDS_IPCFG_10025                             11034 
#define IDS_IPCFG_10026                             11035 
#define IDS_IPCFG_10027                             11036 
#define IDS_IPCFG_10029                             11037
#define IDS_IPCFG_PING_DHCP_OK                      11038
#define IDS_IPCFG_PING_DHCP_BAD                     11039
#define IDS_IPCFG_CANNOT_GET_IP_INFO                11040
#define IDS_IPCFG_INVALID_DHCP_ADDRESS              11041
#define IDS_IPCFG_WARNING_BOGUS_SUBNET              11042
#define IDS_IPCFG_WARNING_BOGUS_SUBNET_DHCP         11043
#define IDS_IPCFG_NBT_DISABLED                      11044

//Member test 11201 - 11400
#define IDS_MEMBER_STATUS_MSG               11201
#define IDS_MEMBER_CANNOT_DETERMINE_BUILD   11202
#define IDS_MEMBER_CANNOT_DETERMINE_DOMAIN  11203
#define IDS_MEMBER_NETLOGON_NOT_RUNNING     11204
#define IDS_MEMBER_UNKNOWN_LOGON            11205
#define  IDS_MEMBER_11206                  11206 
#define  IDS_MEMBER_11207                  11207 
#define  IDS_MEMBER_11208                  11208 
#define  IDS_MEMBER_11209                  11209 
#define  IDS_MEMBER_11210                  11210 
#define  IDS_MEMBER_11211                  11211 
#define  IDS_MEMBER_11212                  11212 
#define  IDS_MEMBER_11213                  11213 
#define  IDS_MEMBER_11214                  11214 
#define  IDS_MEMBER_11215                  11215
#define  IDS_MEMBER_11216                  11216
#define  IDS_MEMBER_11217                  11217 
#define  IDS_MEMBER_11218                  11218 
#define  IDS_MEMBER_11219                  11219 
#define  IDS_MEMBER_11220                  11220 
#define  IDS_MEMBER_11221                  11221 
#define  IDS_MEMBER_11222                  11222 
#define  IDS_MEMBER_11223                  11223 
#define  IDS_MEMBER_11227                  11227 
#define  IDS_MEMBER_11228                  11228 
#define  IDS_MEMBER_11229                  11229 
#define  IDS_MEMBER_11230                  11230 
#define  IDS_MEMBER_11231                  11231 
#define  IDS_MEMBER_11232                  11232
#define  IDS_MEMBER_SYSVOL_NOT_READY       11233

//NetBT Transports test  11401 - 11600
#define IDS_NETBT_STATUS_MSG                11401
#define IDS_NETBT_DUPLICATE                 11402
#define IDS_NETBT_11403                     11403
#define IDS_NETBT_11404                     11404
#define IDS_NETBT_11405                     11405
#define IDS_NETBT_11406                     11406
#define IDS_NETBT_11407                     11407
#define IDS_NETBT_11408                     11408
#define IDS_NETBT_11409                     11409
#define IDS_NETBT_SKIP                      11410
#define IDS_NETBT_11411                     11411
#define IDS_NETBT_11412                     11412

//AutoNet test 11601 - 11800
#define  IDS_AUTONET_11601                  11601 
#define  IDS_AUTONET_11602                  11602 
#define  IDS_AUTONET_11603                  11603 
#define  IDS_AUTONET_11604                  11604 
#define  IDS_AUTONET_11605                  11605 
#define  IDS_AUTONET_11606                  11606 
#define  IDS_AUTONET_STATUS_MSG             11607

//LpLoopBk test 11801 - 12000
#define IDS_IPLOOPBK_STATUS_MSG             11801
#define IDS_IPLOOPBK_NO_IP                  11802
#define IDS_IPLOOPBK_PASS                   11803
#define IDS_IPLOOPBK_FAIL                   11804

//Default gateway (DefGW) test 12001 - 12200
#define  IDS_DEFGW_12001                  12001
#define  IDS_DEFGW_12002                  12002 
#define  IDS_DEFGW_12003                  12003 
#define  IDS_DEFGW_12004                  12004 
#define  IDS_DEFGW_12005                  12005 
#define  IDS_DEFGW_12006                  12006 
#define  IDS_DEFGW_12007                  12007 
#define  IDS_DEFGW_12008                  12008 
#define  IDS_DEFGW_12009                  12009 
#define  IDS_DEFGW_12010                  12010 
#define  IDS_DEFGW_12011                  12011 
#define  IDS_DEFGW_12012                  12012
#define  IDS_DEFGW_STATUS_MSG           12399


//NbtNm test 12201 - 12400
#define  IDS_NBTNM_12201                  12201 
#define  IDS_NBTNM_12202                  12202 
#define  IDS_NBTNM_12203                  12203 
#define  IDS_NBTNM_12204                  12204 
#define  IDS_NBTNM_12205                  12205 
#define  IDS_NBTNM_12206                  12206 
#define  IDS_NBTNM_12207                  12207 
#define  IDS_NBTNM_12208                  12208 
#define  IDS_NBTNM_12209                  12209 
#define  IDS_NBTNM_12210                  12210 
#define  IDS_NBTNM_12211                  12211 
#define  IDS_NBTNM_12212                  12212 
#define  IDS_NBTNM_12214                  12214 
#define  IDS_NBTNM_12215                  12215 
#define  IDS_NBTNM_12216                  12216 
#define  IDS_NBTNM_12217                  12217 
#define  IDS_NBTNM_12218                  12218 
#define  IDS_NBTNM_12219                  12219 
#define  IDS_NBTNM_12220                  12220 
#define  IDS_NBTNM_12221                  12221 
#define  IDS_NBTNM_12222                  12222 
#define  IDS_NBTNM_ALL_DISABELED          12223
#define  IDS_NBTNM_12224                  12224 
#define  IDS_NBTNM_12225                  12225 
#define  IDS_NBTNM_12226                  12226 
#define  IDS_NBTNM_12227                  12227 
#define  IDS_NBTNM_12228                  12228 
#define  IDS_NBTNM_12229                  12229 
#define  IDS_NBTNM_12231                  12231 
#define  IDS_NBTNM_12233                  12233 
#define  IDS_NBTNM_12234                  12234 
#define  IDS_NBTNM_12235                  12235 
#define  IDS_NBTNM_12236                  12236
#define  IDS_NBTNM_STATUS_MSG             12237 
#define  IDS_NBTNM_03PROBLEM              12238
#define  IDS_NBTNM_IF_DISABLED            12239


//WINS test 12401 - 12600
#define IDS_WINS_QUERY_NO_PRIMARY           12401
#define IDS_WINS_QUERY_PRIMARY              12402
#define IDS_WINS_QUERY_NO_SECONDARY         12403
#define IDS_WINS_QUERY_SECONDARY            12404
#define IDS_WINS_STATUS_MSG                 12405 
#define IDS_WINS_12406                      12406 
#define IDS_WINS_12407                      12407 
#define IDS_WINS_12408                      12408 
#define IDS_WINS_12409                      12409 
#define IDS_WINS_12413                      12413 
#define IDS_WINS_12414                      12414 
#define IDS_WINS_12415                      12415
#define IDS_WINS_12416                      12416
#define IDS_WINS_NBT_DISABLED               12417


//Winsock test 12601 - 12800
#define IDS_WINSOCK_FAILED_START            12601
#define IDS_WINSOCK_FAILED_ENUM             12602
#define IDS_WINSOCK_FAILED_UDPSOCKET        12603
#define IDS_WINSOCK_STATUS_MSG              12604
#define  IDS_WINSOCK_12605                  12605 
#define  IDS_WINSOCK_12606                  12606 
#define  IDS_WINSOCK_12607                  12607 
#define  IDS_WINSOCK_12608                  12608 
#define  IDS_WINSOCK_12609                  12609 
#define  IDS_WINSOCK_12610                  12610 
#define  IDS_WINSOCK_12611                  12611 

//DNS test 12801 - 13000
#define IDS_DNS_CHECKING_DNS_SERVERS        12801
#define IDS_DNS_SERVER_IS_UP                12802
#define IDS_DNS_CANNOT_TEST_DNS             12803
#define IDS_DNS_CANNOT_CONVERT_DNS_ADDRESS  12804
#define IDS_DNS_SERVER_IS_DOWN              12805
#define IDS_DNS_THINKS_IP_IS_UNCONFIGURED   12806
#define IDS_DNS_IS_UNCONFIGURED             12807
#define IDS_DNS_HAS_NO_RECORD               12808
#define IDS_DNS_CANNOT_QUERY                12809
#define IDS_DNS_HAS_A_RECORD                12810
#define IDS_DNS_HAS_NO_A_RECORD             12811
#define IDS_DNS_STATUS_MSG                  12812
#define IDS_DNS_RESOLVER_CACHE_IS_OFF       12813
#define IDS_DNS_CANNOT_PING                 12814
#define IDS_DNS_NAME_VALID_NT5_ONLY         12817
#define IDS_DNS_NAME_INVALID                12818
#define IDS_DNS_12819                       12819 
#define IDS_DNS_12820                       12820 
#define IDS_DNS_12821                       12821 
#define IDS_DNS_12822                       12822 
#define IDS_DNS_12823                       12823 
#define IDS_DNS_12825                       12825 
#define IDS_DNS_12826                       12826 
#define IDS_DNS_12827                       12827 
#define IDS_DNS_12828                       12828 
#define IDS_DNS_12829                       12829 
#define IDS_DNS_12830                       12830 
#define IDS_DNS_12831                       12831 
#define IDS_DNS_12832                       12832 
#define IDS_DNS_12833                       12833 
#define IDS_DNS_12834                       12834 
#define IDS_DNS_12835                       12835 
#define IDS_DNS_12836                       12836 
#define IDS_DNS_12837                       12837 
#define IDS_DNS_12838                       12838 
#define IDS_DNS_12839                       12839 
#define IDS_DNS_12840                       12840 
#define IDS_DNS_12841                       12841 
#define IDS_DNS_12842                       12842 
#define IDS_DNS_12843                       12843 
#define IDS_DNS_12844                       12844 
#define IDS_DNS_12845                       12845 
#define IDS_DNS_12846                       12846 
#define IDS_DNS_12847                       12847 
#define IDS_DNS_12848                       12848 
#define IDS_DNS_12849                       12849 
#define IDS_DNS_12850                       12850 
#define IDS_DNS_12851                       12851 
#define IDS_DNS_12852                       12852 
#define IDS_DNS_12853                       12853 
#define IDS_DNS_12854                       12854 
#define IDS_DNS_12855                       12855 
#define IDS_DNS_12856                       12856 
#define IDS_DNS_12857                       12857 
#define IDS_DNS_12858                       12858 
#define IDS_DNS_12859                       12859 
#define IDS_DNS_12860                       12860 
#define IDS_DNS_12861                       12861 
#define IDS_DNS_12862                       12862 
#define IDS_DNS_12863                       12863 
#define IDS_DNS_12864                       12864 
#define IDS_DNS_12865                       12865 
#define IDS_DNS_12866                       12866 
#define IDS_DNS_12867                       12867 
#define IDS_DNS_12868                       12868 
#define IDS_DNS_12869                       12869 
#define IDS_DNS_12870                       12870 
#define IDS_DNS_12871                       12871
#define IDS_DNS_12872                       12872
#define IDS_DNS_12873                       12873
#define IDS_DNS_12874                       12874
#define IDS_DNS_DC_FAILURE                  12875
#define IDS_DNS_IPADDR_ERR                  12876
// new
#define IDS_DNS_12877                       12877
#define IDS_DNS_12878                       12878 
#define IDS_DNS_12879                       12879 
#define IDS_DNS_12880                       12880 
#define IDS_DNS_12881                       12881 
#define IDS_DNS_12882                       12882 
#define IDS_DNS_12883                       12883 
#define IDS_DNS_12884                       12884 
#define IDS_DNS_12885                       12885 
#define IDS_DNS_12886                       12886 
#define IDS_DNS_12887                       12887 
#define IDS_DNS_12888                       12888 
#define IDS_DNS_12889                       12889 
#define IDS_DNS_12890                       12890 
#define IDS_DNS_12891                       12891 
#define IDS_DNS_12892                       12892 
#define IDS_DNS_12893                       12893 
#define IDS_DNS_12894                       12894 
#define IDS_DNS_12895                       12895 
#define IDS_DNS_12896                       12896 
#define IDS_DNS_12897                       12897 
#define IDS_DNS_12898                       12898 
#define IDS_DNS_12899                       12899 
#define IDS_DNS_12900                       12900 
#define IDS_DNS_12901                       12901 
#define IDS_DNS_12902                       12902 
#define IDS_DNS_12903                       12903 
#define IDS_DNS_12904                       12904 
#define IDS_DNS_12905                       12905 
#define IDS_DNS_12906                       12906 
#define IDS_DNS_12907                       12907 
#define IDS_DNS_12908                       12908 
#define IDS_DNS_12909                       12909 
#define IDS_DNS_12910                       12910 
#define IDS_DNS_12911                       12911 
#define IDS_DNS_12912                       12912 
#define IDS_DNS_12913                       12913 
#define IDS_DNS_12914                       12914 
#define IDS_DNS_12915                       12915 
#define IDS_DNS_12916                       12916 
#define IDS_DNS_12917                       12917 
#define IDS_DNS_12918                       12918 
#define IDS_DNS_12919                       12919 
#define IDS_DNS_12920                       12920 
#define IDS_DNS_12921                       12921 
#define IDS_DNS_12922                       12922 
#define IDS_DNS_12923                       12923 
#define IDS_DNS_12924                       12924 
#define IDS_DNS_12939                       12939
#define IDS_DNS_12940                       12940
#define IDS_DNS_12941                       12941 
#define IDS_DNS_12942                       12942 
#define IDS_DNS_12943                       12943 
#define IDS_DNS_12944                       12944 
#define IDS_DNS_12945                       12945 
#define IDS_DNS_12946                       12946 
#define IDS_DNS_12947                       12947
#define IDS_DNS_12948                       12948
#define IDS_DNS_12949                       12949
#define IDS_DNS_NO_HOSTNAME                 12950
#define IDS_DNS_12951                       12951 

//Browser test 13001 - 13200
#define  IDS_BROWSER_13001                  13001 
#define  IDS_BROWSER_13002                  13002 
#define  IDS_BROWSER_13003                  13003 
#define  IDS_BROWSER_13004                  13004 
#define  IDS_BROWSER_13005                  13005 
#define  IDS_BROWSER_13006                  13006 
#define  IDS_BROWSER_13007                  13007 
#define  IDS_BROWSER_13008                  13008 
#define  IDS_BROWSER_13009                  13009 
#define  IDS_BROWSER_13010                  13010 
#define  IDS_BROWSER_13011                  13011 
#define  IDS_BROWSER_13012                  13012 
#define  IDS_BROWSER_13013                  13013 
#define  IDS_BROWSER_13014                  13014 
#define  IDS_BROWSER_13015                  13015 
#define  IDS_BROWSER_13016                  13016 
#define  IDS_BROWSER_13017                  13017 
#define  IDS_BROWSER_13018                  13018 
#define  IDS_BROWSER_13019                  13019 
#define  IDS_BROWSER_13020                  13020 
#define  IDS_BROWSER_13021                  13021 
#define  IDS_BROWSER_13022                  13022 
#define  IDS_BROWSER_13023                  13023 
#define  IDS_BROWSER_13024                  13024 
#define  IDS_BROWSER_13025                  13025 
#define  IDS_BROWSER_13026                  13026 
#define  IDS_BROWSER_STATUS_MSG             13027
#define IDS_BROWSER_NETBT_DISABLED          13028

//DsGetDc test 13201 - 13400
#define IDS_DSGETDC_STATUS_MSG              13201
#define IDS_DSGETDC_STATUS_DC               13202
#define IDS_DSGETDC_STATUS_PDC              13203
#define IDS_DSGETDC_STATUS_NT5DC            13204
#define IDS_DSGETDC_FATAL_GUID              13205
#define  IDS_DSGETDC_13206                  13206 
#define  IDS_DSGETDC_13207                  13207 
#define  IDS_DSGETDC_13208                  13208 
#define  IDS_DSGETDC_13209                  13209 
#define  IDS_DSGETDC_13210                  13210 
#define  IDS_DSGETDC_13211                  13211 
#define  IDS_DSGETDC_13212                  13212 
#define  IDS_DSGETDC_13213                  13213 
#define  IDS_DSGETDC_13214                  13214 
#define  IDS_DSGETDC_13215                  13215 
#define  IDS_DSGETDC_13216                  13216 
#define  IDS_DSGETDC_13217                  13217 
#define  IDS_DSGETDC_13218                  13218 
#define  IDS_DSGETDC_13219                  13219 
#define  IDS_DSGETDC_13220                  13220 
#define  IDS_DSGETDC_13221                  13221 
#define  IDS_DSGETDC_13222                  13222 
#define  IDS_DSGETDC_13223                  13223 
#define  IDS_DSGETDC_13224                  13224 
#define  IDS_DSGETDC_13225                  13225 
#define  IDS_DSGETDC_13226                  13226 
#define  IDS_DSGETDC_13227                  13227 
#define  IDS_DSGETDC_13228                  13228 
#define  IDS_DSGETDC_13229                  13229 
#define  IDS_DSGETDC_13230                  13230 
#define  IDS_DSGETDC_13231                  13231 
#define  IDS_DSGETDC_13232                  13232 
#define  IDS_DSGETDC_13233                  13233 
#define  IDS_DSGETDC_13234                  13234 
#define  IDS_DSGETDC_13235                  13235 
#define  IDS_DSGETDC_13236                  13236 
#define  IDS_DSGETDC_13237                  13237 
#define  IDS_DSGETDC_13238                  13238 
#define  IDS_DSGETDC_13239                  13239 
#define  IDS_DSGETDC_13240                  13240 
#define  IDS_DSGETDC_13241                  13241 
#define  IDS_DSGETDC_13242                  13242 
#define  IDS_DSGETDC_13243                  13243 
#define  IDS_DSGETDC_13244                  13244 
#define  IDS_DSGETDC_13245                  13245 
#define  IDS_DSGETDC_13246                  13246 
#define  IDS_DSGETDC_13247                  13247 
#define  IDS_DSGETDC_13248                  13248 
#define  IDS_DSGETDC_13249                  13249 
#define  IDS_DSGETDC_13250                  13250 
#define  IDS_DSGETDC_NT4_PDC                13251

//DCList test 13401 - 13600
#define IDS_DCLIST_NETSERVERENUM_FAILED     13401
#define IDS_DCLIST_DOMAIN_HEADER            13402
#define IDS_DCLIST_DC_INFO                  13403
#define IDS_DCLIST_DC_IS_DOWN               13404
#define IDS_DCLIST_DC_FAILED_PING           13405
#define IDS_DCLIST_STATUS_MSG               13406
#define IDS_DCLIST_NOT_A_NETBIOS_DOMAIN     13407
#define IDS_DCLIST_DOMAIN_SID               13413
#define IDS_DCLIST_RID                      13414
#define IDS_DCLIST_NO_DC                    13415
#define IDS_DCLIST_NO_DC_UP                 13416
#define IDS_DCLIST_NO_ACCESS_DSBIND         13417
#define IDS_DCLIST_ERR_DSBIND               13418
#define IDS_DCLIST_ERR_GETDCINFO            13419
#define IDS_DCLIST_DCS                      13420
#define IDS_DCLIST_13421                    13421 
#define IDS_DCLIST_13422                    13422 
#define IDS_DCLIST_13423                    13423 
#define IDS_DCLIST_13424                    13424 
#define IDS_DCLIST_13425                    13425 
#define IDS_DCLIST_13426                    13426 
#define IDS_DCLIST_13427                    13427 
#define IDS_DCLIST_13428                    13428 
#define IDS_DCLIST_13429                    13429 
#define IDS_DCLIST_13430                    13430 
#define IDS_DCLIST_13431                    13431 
#define IDS_DCLIST_13432                    13432 
#define IDS_DCLIST_13433                    13433 
#define IDS_DCLIST_13434                    13434 
#define IDS_DCLIST_13435                    13435 
#define IDS_DCLIST_NT4_PDC                  13436 


//Trust test 13601 - 13800
#define IDS_TRUST_FAILED_CHANNEL            13601
#define IDS_TRUST_FAILED_LISTDOMAINS        13602
#define IDS_TRUST_FAILED_SECURECHANNEL      13603
#define IDS_TRUST_SECURECHANNEL_TO          13604
#define IDS_TRUST_FAILED_CHANNEL_PDC        13605
#define IDS_TRUST_SECURECHANNEL_TOPDC       13606
#define IDS_TRUST_NOTESTASITSDOWN           13607
#define IDS_TRUST_FAILED_TODCS              13608
#define IDS_TRUST_FAILED_CHANNEL_DCS        13609
#define IDS_TRUST_CHANNEL_DC                13610
#define IDS_TRUST_ENSURESID                 13611
#define IDS_TRUST_MISSINGSID                13612
#define IDS_TRUST_NODC                      13613
#define IDS_TRUST_WRONGSID                  13614
#define IDS_TRUST_FAILED_SAMOPEN            13615
#define IDS_TRUST_STATUS_MSG                13616
#define IDS_TRUST_NO_NBT_DOMAIN             13617
#define IDS_TRUST_NODC_UP                   13618
#define IDS_TRUST_NO_ACCESS                 13619
#define IDS_TRUST_NOT_ADMIN                 13620
#define IDS_TRUST_TODCS_NOT_ADMIN           13621
#define IDS_TRUST_CHANNEL_BROKEN            13622

//Kerberos test 13801 - 14000
#define IDS_KERBEROS_LOCALUSER              13801 
#define IDS_KERBEROS_CACHED                 13802 
#define IDS_KERBEROS_NODC                   13803 
#define IDS_KERBEROS_NOKDC                  13804 
#define IDS_KERBEROS_NOLSA                  13805 
#define IDS_KERBEROS_NOPACKAGE              13806 
#define IDS_KERBEROS_HRERROR                13807 
#define IDS_KERBEROS_NOCACHE                13808 
#define IDS_KERBEROS_CACHEDTICKER           13809
#define IDS_KERBEROS_NOTICKET               13810 
#define IDS_KERBEROS_SERVER                 13811 
#define IDS_KERBEROS_ENDTIME                13812 
#define IDS_KERBEROS_RENEWTIME              13813
#define IDS_KERBEROS_STATUS_MSG             13814
#define IDS_KERBEROS_NOT_W2K_PRIMARY_DOMAIN 13815

//LDAP test 14001 - 14200
#define IDS_LDAP_NODC                       14001
#define IDS_LDAP_NOTRUNNINGDS               14002
#define IDS_LDAP_NOTRUNNINGDS_SKIP          14003
#define IDS_LDAP_NOLDAPSERVERSWORK          14004
#define IDS_LDAP_DCDOWN                     14005
#define IDS_LDAP_NOIPADDR                   14006
#define IDS_LDAP_LOGONASLOCALUSER           14007
#define IDS_LDAP_DOAUTHEN                   14008
#define IDS_LDAP_CANNOTOPEN                 14009
#define IDS_LDAP_CANNOTBIND                 14010
#define IDS_LDAP_CANNOTSEARCH               14011
#define IDS_LDAP_ENTRIES                    14012
#define IDS_LDAP_CANNOTFIRSTENTRY           14013
#define IDS_LDAP_CANNOTFIRSTATTR            14014
#define IDS_LDAP_ATTR                       14015
#define IDS_LDAP_CANNOTLEN                  14016
#define IDS_LDAP_VAL                        14017
#define IDS_LDAP_STATUS_MSG                 14018
#define IDS_LDAP_REG_SPN                    14019
#define IDS_LDAP_SPN_NAME                   14020
#define IDS_LDAP_SPN_FAILURE                14021
#define IDS_LDAP_SPN_MISSING                14022
#define IDS_LDAP_NO_SPN                     14023




//Route test 14201 - 14400
#define  IDS_ROUTE_14201                  14201 
#define  IDS_ROUTE_14202                  14202 
#define  IDS_ROUTE_14203                  14203 
#define  IDS_ROUTE_14204                  14204 
#define  IDS_ROUTE_14205                  14205 
#define  IDS_ROUTE_14206                  14206 
#define  IDS_ROUTE_14207                  14207 
#define  IDS_ROUTE_14208                  14208 
#define  IDS_ROUTE_STATUS_MSG             14209

//NetStat test 14401 - 14600
#define  IDS_NETSTAT_14401                  14401 
#define  IDS_NETSTAT_14402                  14402 
#define  IDS_NETSTAT_14403                  14403 
#define  IDS_NETSTAT_14404                  14404 
#define  IDS_NETSTAT_14405                  14405 
#define  IDS_NETSTAT_14406                  14406 
#define  IDS_NETSTAT_14407                  14407 
#define  IDS_NETSTAT_14408                  14408 
#define  IDS_NETSTAT_14409                  14409 
#define  IDS_NETSTAT_14410                  14410 
#define  IDS_NETSTAT_14411                  14411 
#define  IDS_NETSTAT_14412                  14412 
#define  IDS_NETSTAT_14413                  14413 
#define  IDS_NETSTAT_14414                  14414 
#define  IDS_NETSTAT_14415                  14415 
#define  IDS_NETSTAT_14416                  14416 
#define  IDS_NETSTAT_14417                  14417 
#define  IDS_NETSTAT_14418                  14418 
#define  IDS_NETSTAT_14419                  14419 
#define  IDS_NETSTAT_14420                  14420 
#define  IDS_NETSTAT_14421                  14421 
#define  IDS_NETSTAT_14422                  14422 
#define  IDS_NETSTAT_14423                  14423 
#define  IDS_NETSTAT_14424                  14424 
#define  IDS_NETSTAT_14425                  14425 
#define  IDS_NETSTAT_14426                  14426 
#define  IDS_NETSTAT_14427                  14427 
#define  IDS_NETSTAT_14428                  14428 
#define  IDS_NETSTAT_14429                  14429 
#define  IDS_NETSTAT_14430                  14430 
#define  IDS_NETSTAT_14431                  14431 
#define  IDS_NETSTAT_14432                  14432 
#define  IDS_NETSTAT_14433                  14433 
#define  IDS_NETSTAT_14434                  14434 
#define  IDS_NETSTAT_14438                  14438 
#define  IDS_NETSTAT_14439                  14439 
#define  IDS_NETSTAT_14440                  14440 
#define  IDS_NETSTAT_14441                  14441 
#define  IDS_NETSTAT_14442                  14442 
#define  IDS_NETSTAT_14443                  14443 
#define  IDS_NETSTAT_14444                  14444 
#define  IDS_NETSTAT_14445                  14445 
#define  IDS_NETSTAT_14446                  14446 
#define  IDS_NETSTAT_14447                  14447 
#define  IDS_NETSTAT_14448                  14448 
#define  IDS_NETSTAT_14449                  14449 
#define  IDS_NETSTAT_14450                  14450 
#define  IDS_NETSTAT_14451                  14451 
#define  IDS_NETSTAT_14452                  14452 
#define  IDS_NETSTAT_14453                  14453 
#define  IDS_NETSTAT_14454                  14454 
#define  IDS_NETSTAT_14455                  14455 
#define  IDS_NETSTAT_14456                  14456 
#define  IDS_NETSTAT_14457                  14457 
#define  IDS_NETSTAT_14458                  14458 
#define  IDS_NETSTAT_14459                  14459 
#define  IDS_NETSTAT_14460                  14460 
#define  IDS_NETSTAT_14461                  14461 
#define  IDS_NETSTAT_14462                  14462 
#define  IDS_NETSTAT_14463                  14463 
#define  IDS_NETSTAT_14464                  14464 
#define  IDS_NETSTAT_14465                  14465 
#define  IDS_NETSTAT_14466                  14466 
#define  IDS_NETSTAT_14467                  14467 
#define  IDS_NETSTAT_14468                  14468 
#define  IDS_NETSTAT_14469                  14469 
#define  IDS_NETSTAT_14470                  14470 
#define  IDS_NETSTAT_14471                  14471 
#define  IDS_NETSTAT_14472                  14472 
#define  IDS_NETSTAT_14473                  14473 
#define  IDS_NETSTAT_14474                  14474 
#define  IDS_NETSTAT_14475                  14475 
#define  IDS_NETSTAT_14476                  14476 
#define  IDS_NETSTAT_14477                  14477 
#define  IDS_NETSTAT_14478                  14478 
#define  IDS_NETSTAT_14479                  14479 
#define  IDS_NETSTAT_14480                  14480 
#define  IDS_NETSTAT_14481                  14481 
#define  IDS_NETSTAT_14482                  14482 
#define  IDS_NETSTAT_14483                  14483 
#define  IDS_NETSTAT_14484                  14484 
#define  IDS_NETSTAT_14485                  14485 
#define  IDS_NETSTAT_14486                  14486 
#define  IDS_NETSTAT_14487                  14487 
#define  IDS_NETSTAT_14488                  14488 
#define  IDS_NETSTAT_14489                  14489 
#define  IDS_NETSTAT_14490                  14490 
#define  IDS_NETSTAT_14491                  14491 
#define  IDS_NETSTAT_14492                  14492 
#define  IDS_NETSTAT_14493                  14493 
#define  IDS_NETSTAT_14494                  14494 
#define  IDS_NETSTAT_14495                  14495 
#define  IDS_NETSTAT_14496                  14496 
#define  IDS_NETSTAT_14497                  14497 
#define  IDS_NETSTAT_14498                  14498 
#define  IDS_NETSTAT_14499                  14499 
#define  IDS_NETSTAT_14500                  14500 
#define  IDS_NETSTAT_14501                  14501 
#define  IDS_NETSTAT_14502                  14502 
#define  IDS_NETSTAT_14503                  14503 
#define  IDS_NETSTAT_14504                  14504 
#define  IDS_NETSTAT_STATUS_MSG             14505

//NDIS test 16000- 17000   huge test, need more IDs
#define  IDS_NDIS_16000                  16000 
#define  IDS_NDIS_16001                  16001 
#define  IDS_NDIS_16002                  16002 
#define  IDS_NDIS_16003                  16003 
#define  IDS_NDIS_16004                  16004 
#define  IDS_NDIS_16005                  16005 
#define  IDS_NDIS_16006                  16006 
#define  IDS_NDIS_16007                  16007 
#define  IDS_NDIS_16008                  16008 
#define  IDS_NDIS_16009                  16009 
#define  IDS_NDIS_16010                  16010 
#define  IDS_NDIS_16011                  16011 
#define  IDS_NDIS_16012                  16012 
#define  IDS_NDIS_16013                  16013 
#define  IDS_NDIS_16014                  16014 
#define  IDS_NDIS_16015                  16015 
#define  IDS_NDIS_16016                  16016 
#define  IDS_NDIS_16017                  16017 
#define  IDS_NDIS_16018                  16018 
#define  IDS_NDIS_16019                  16019 
#define  IDS_NDIS_16020                  16020 
#define  IDS_NDIS_16021                  16021 
#define  IDS_NDIS_16022                  16022 
#define  IDS_NDIS_16023                  16023 
#define  IDS_NDIS_16024                  16024 
#define  IDS_NDIS_16025                  16025 
#define  IDS_NDIS_16026                  16026 
#define  IDS_NDIS_16027                  16027 
#define  IDS_NDIS_STATUS_MSG             16028
#define  IDS_NDIS_16029                  16029
#define  IDS_NDIS_16030                  16030
#define  IDS_NDIS_CONNECTED              16031
#define  IDS_NDIS_DISCONNECTED           16032
#define  IDS_NDIS_UNKNOWN                16033
#define  IDS_NDIS_ALL_CARD_DOWN          16034
#define  IDS_NDIS_CARD_DOWN              16035
#define  IDS_NDIS_NO_RCV                 16036


//BINDINGS 14801 - 15000
#define  IDS_BINDINGS_14801                  14801 
#define  IDS_BINDINGS_14802                  14802 
#define  IDS_BINDINGS_14804                  14804 
#define  IDS_BINDINGS_14805                  14805 
#define  IDS_BINDINGS_14806                  14806 
#define  IDS_BINDINGS_14807                  14807 
#define  IDS_BINDINGS_14808                  14808 
#define  IDS_BINDINGS_14810                  14810 
#define  IDS_BINDINGS_14811                  14811 
#define  IDS_BINDINGS_14812                  14812
#define  IDS_BINDINGS_STATUS_MSG             14813

//WAN test 15001 - 15200
#define  IDS_WAN_15001                  15001 
#define  IDS_WAN_15002                  15002 
#define  IDS_WAN_15003                  15003 
#define  IDS_WAN_15004                  15004 
#define  IDS_WAN_15005                  15005 
#define  IDS_WAN_15006                  15006 
#define  IDS_WAN_15008                  15008 
#define  IDS_WAN_15009                  15009 
#define  IDS_WAN_15010                  15010 
#define  IDS_WAN_15011                  15011 
#define  IDS_WAN_15012                  15012 
#define  IDS_WAN_15013                  15013 
#define  IDS_WAN_15014                  15014 
#define  IDS_WAN_15015                  15015 
#define  IDS_WAN_15016                  15016 
#define  IDS_WAN_15017                  15017 
#define  IDS_WAN_15018                  15018 
#define  IDS_WAN_DISABLED               15019 
#define  IDS_WAN_ENABLED                15020 
#define  IDS_WAN_15021                  15021 
#define  IDS_WAN_15024                  15024 
#define  IDS_WAN_15025                  15025 
#define  IDS_WAN_15026                  15026 
#define  IDS_WAN_15027                  15027 
#define  IDS_WAN_15028                  15028 
#define  IDS_WAN_15029                  15029 
#define  IDS_WAN_15030                  15030 
#define  IDS_WAN_15031                  15031 
#define  IDS_WAN_15032                  15032 
#define  IDS_WAN_15033                  15033 
#define  IDS_WAN_15034                  15034 
#define  IDS_WAN_15035                  15035 
#define  IDS_WAN_15036                  15036 
#define  IDS_WAN_15037                  15037 
#define  IDS_WAN_15038                  15038 
#define  IDS_WAN_15039                  15039 
#define  IDS_WAN_15040                  15040 
#define  IDS_WAN_15041                  15041 
#define  IDS_WAN_15042                  15042 
#define  IDS_WAN_15043                  15043 
#define  IDS_WAN_15044                  15044 
#define  IDS_WAN_15045                  15045 
#define  IDS_WAN_15046                  15046 
#define  IDS_WAN_15047                  15047 
#define  IDS_WAN_15048                  15048 
#define  IDS_WAN_15049                  15049 
#define  IDS_WAN_15050                  15050 
#define  IDS_WAN_15051                  15051 
#define  IDS_WAN_15052                  15052 
#define  IDS_WAN_15053                  15053 
#define  IDS_WAN_15054                  15054 
#define  IDS_WAN_15055                  15055
#define  IDS_WAN_15056                  15056
#define  IDS_WAN_STATUS_MSG             15057

//Modem test 15201 - 15400
#define IDS_MODEM_STATUS_MSG            15201
#define IDS_MODEM_LINEINIT_FAILED       15202
#define IDS_MODEM_NO_DEVICES            15203
#define IDS_MODEM_DEVICEID              15204
#define IDS_MODEM_COMPRESSION           15205
#define IDS_MODEM_ERROR_CONTROL         15206
#define IDS_MODEM_FORCED_EC             15207
#define IDS_MODEM_CELLULAR              15208
#define IDS_MODEM_FLOWCONTROL_HARD      15209
#define IDS_MODEM_FLOWCONTROL_SOFT      15210
#define IDS_MODEM_CCITT_OVERRIDE        15211
#define IDS_MODEM_SPEED_ADJUST          15212
#define IDS_MODEM_TONE_DIAL             15213
#define IDS_MODEM_BLIND_DIAL            15214
#define IDS_MODEM_V23_OVERRIDE          15215
#define IDS_MODEM_NEGOTIATED_SPEED      15216
#define IDS_MODEM_PORT                  15217
#define IDS_MODEM_NAME                  15218

//Netware test 15401 - 15600
#define IDS_NETWARE_NOT_LOGGED_IN_TREE  15401
#define IDS_NETWARE_NOT_LOGGED_IN_SERVER    15402
#define IDS_NETWARE_LOGGED_IN_SERVER    15403
#define IDS_NETWARE_LOGGED_IN_TREE      15404
#define IDS_NETWARE_USER_NAME           15405
#define IDS_NETWARE_SERVER_NAME         15406
#define IDS_NETWARE_TREE_NAME           15407
#define IDS_NETWARE_CONTEXT             15408
#define IDS_NETWARE_CONNECTION_TYPE     15409
#define IDS_NETWARE_NDS                 15410
#define IDS_NETWARE_CONN_TYPE           15411
#define IDS_NETWARE_CONN_NOT_AUTHENTICATED 15412
#define IDS_NETWARE_CONN_BINDERY_LOGIN  15413
#define IDS_NETWARE_CONN_NDS_AUTHENTICATED_NO_LICENSE 15414
#define IDS_NETWARE_CONN_NDS_AUTHENTICATED_LICENSED 15415
#define IDS_NETWARE_CONN_DISCONNECTED   15416
#define IDS_NETWARE_CONN_UNKNOWN        15417
#define IDS_NETWARE_STATUS_MSG          15418
#define IDS_NETWARE_TITLE_MSG           15419

//IPX test 15601 - 15800
#define IDS_IPX_STATUS_MSG              15601
#define IDS_IPX_INTERNAL                15602
#define  IDS_IPX_15603                  15603 
#define  IDS_IPX_15604                  15604 
#define  IDS_IPX_15605                  15605 
#define  IDS_IPX_15606                  15606 
#define  IDS_IPX_15607                  15607 
#define  IDS_IPX_15608                  15608 
#define  IDS_IPX_15609                  15609 
#define  IDS_IPX_15610                  15610 
#define  IDS_IPX_15611                  15611 
#define  IDS_IPX_15612                  15612 
#define  IDS_IPX_15613                  15613
#define IDS_IPX_ETHERNET_II             15614
#define IDS_IPX_802_3                   15615
#define IDS_IPX_802_2                   15616
#define IDS_IPX_SNAP                    15617
#define IDS_IPX_ARCNET                  15618
#define IDS_IPX_UNKNOWN                 15619


// IDS for machine-specific info 15801 - 16000
#define  IDS_MACHINE_15801                  15801 
#define  IDS_MACHINE_15802                  15802 
#define  IDS_MACHINE_15803                  15803 
#define  IDS_MACHINE_15804                  15804 
#define  IDS_MACHINE_15805                  15805 
#define  IDS_MACHINE_15806                  15806 
#define  IDS_MACHINE_15807                  15807 
#define  IDS_MACHINE_15808                  15808
#define IDS_MACHINE_YES_INSTALLED       15809
#define IDS_MACHINE_NO_INSTALLED        15810

// IPSec test 17500 - 18000
#define IDS_IPSEC_STATUS_MSG            17500
#define IDS_IPSEC_PA_NOT_STARTED        17501
#define IDS_IPSEC_ERROR_MSG             17502
#define IDS_IPSEC_NO_POLICY_INFO        17503
#define IDS_IPSEC_NO_POLICY             17504
#define IDS_IPSEC_DS_POLICY             17505
#define IDS_IPSEC_LOC_POLICY            17506
#define IDS_IPSEC_POLICY_NAME           17507
#define IDS_IPSEC_POLICY_PATH           17508
#define IDS_IPSEC_PA_NOT_INSTALLED      17509
#define IDS_IPSEC_PA_NO_INFO            17510
#define IDS_IPSEC_PA_STATUS             17511
#define IDS_IPSEC_PA_STARTUP            17512
#define IDS_IPSEC_PA_STARTED            17513
#define IDS_IPSEC_PA_STOPPED            17514
#define IDS_IPSEC_PA_PAUSED             17515
#define IDS_IPSEC_PA_AUTOMATIC          17516
#define IDS_IPSEC_PA_MANUAL             17517
#define IDS_IPSEC_PA_DISABLED           17518
#define IDS_IPSEC_NSHIPSEC              17519
#define IDS_IPSEC_DESCRIPTION           17520
#define IDS_IPSEC_TIMESTAMP             17521
#define IDS_IPSEC_LOCAL_PATH            17522
#define IDS_IPSEC_GPO                   17523
#define IDS_IPSEC_OU                    17524
//SPD Check 
#define IDS_IPSEC_SPD_STATUS 	17525
#define IDS_SPD_ERR_STATUS1	17526
#define IDS_SPD_ERR_STATUS2	17527
//#define IDS_SPD_POLICYSTORE_ERROR 17528
//#define IDS_SPD_ERROR			17529
//#define IDS_SPD_DP_ERROR		17530
#define IDS_SPD_LP_ERROR		17531
#define IDS_SPD_MEM_ERROR		17532
#define IDS_SPD_NEG_POLICY		17533
#define IDS_SPD_MM_POLICY		17534
#define IDS_SPD_FILTER			17535
#define IDS_SPD_STORAGE_FILTER	17536
#define IDS_SPD					17537
#define IDS_SPD_FILTER_ABSENT	17538
#define IDS_SPD_MM_POLICY_ABSENT 17539
#define IDS_SPD_NEG_POLICY_ABSENT 	17540
#define IDS_SPD_SUCC_STATUS	17541
#define IDS_SPD_AUTH_ABSENT	17542
#define IDS_SPD_AUTH_ERROR	17543


// the nettest.exe/netdiag.exe strings
// nettest 17000 - 17499
#define IDS_NETTEST_17000               17000
#define IDS_NETTEST_17001               17001
#define IDS_NETTEST_17002               17002
#define IDS_NETTEST_17003               17003
#define IDS_NETTEST_17004               17004
#define IDS_NETTEST_17005               17005
#define IDS_NETTEST_17006               17006
#define IDS_NETTEST_17007               17007
#define IDS_NETTEST_17008               17008
#define IDS_NETTEST_LOG                 17009
#define IDS_NETTEST_LOGFILE_ERROR       17010


// utilitis
#define IDS_UTIL_SID_NULL               18000
#define IDS_UTIL_SID_INVALID            18001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\route.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      route.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"

//
// Rajkumar - Two Functions from iphlpapi.dll
//

DWORD
WINAPI
GetIpAddrTable(
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PULONG           pdwSize,
    IN     BOOL             bOrder
    );

DWORD
InternalGetIpForwardTable(
    OUT   MIB_IPFORWARDTABLE    **ppIpForwardTable,
    IN    HANDLE                hHeap,
    IN    DWORD                 dwAllocFlags
    );
//--------------------------------------------------------


//functions defined in this file
void MapInterface(char *IPAddr, ULONG IfIndex);
BOOLEAN ImprovedInetAddr(char  *AddressString, ULONG *AddressValue);

HRESULT
PrintRoute(
    NETDIAG_RESULT  *pResults,
    char            *Dest,
    ULONG            DestVal,
    char            *Gate,
    ULONG            GateVal,
    BOOLEAN          Persistent,
    const char     * DestPat
    );

LPCTSTR
PrintRouteEntry(
         ULONG Dest,
         ULONG Mask,
         ULONG Gate,
         ULONG Interface,
         ULONG Metric1
         );

HRESULT
PrintPersistentRoutes(
    NETDIAG_RESULT  *pResults,
    char* Dest,
    ULONG DestVal,
    char* Gate,
    ULONG GateVal
   );


BOOL
RouteTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
/*++

Routine Description:

   Enumerate the static and persistent entries in the routing table

Arguments:

   None.

Return Value:
   TRUE

Author:
   Rajkumar 06/27/98

--*/
{
    HRESULT hr = S_OK;

    //$REVIEW only perform the test when is really verbose
    if (!pParams->fReallyVerbose)
        return hr;

    PrintStatusMessage( pParams, 4, IDS_ROUTE_STATUS_MSG );
   //
   // Print all static entries in the ip forward table
   //



   hr = PrintRoute(pResults,
              "*",
              WILD_CARD,
              "*",
              WILD_CARD,
              TRUE,
              "*"
             );

   //
   // Print all the persistent route entries
   //

   if( S_OK == hr )
        hr = PrintPersistentRoutes(pResults,
                                   "*",
                                   WILD_CARD,
                                   "*",
                                   WILD_CARD
                                   );


   pResults->Route.hrTestResult = hr;
   return hr;

}


HRESULT
PrintRoute(
    NETDIAG_RESULT  *pResults,
    char            *Dest,
    ULONG            DestVal,
    char            *Gate,
    ULONG            GateVal,
    BOOLEAN          Persistent,
    const char     * DestPat
    )
/*++

Routine Description:
    This routine prints all the static entries in then IP forward table.
    The entry in the routing table is declared static if  the type of the
    entry is MIB_IPPROTO_LOCAL.

Arguments:

    char *Dest: pointer to destination IP address string.  This
        is NULL if no value was provided/no filtering desired.
    ULONG DestVal: value of destination IP address to filter route
        table with.  If Dest is NULL, this is ignored.
    char *Gate: pointer to gateway IP address string. This is NULL
        if no value was provided/no filtering desired.
    ULONG GateVal: value of gateway IP address to filter route
        table with.  If Gate is NULL, this is ignored.
    BOOL  Persistent: set if persistent routes are to be printed.
Returns: ULONG

Can also be found in nt\private\net\sockets\tcpcmd\route\route.c
  --*/
{
    int                     printcount = 0;
    int                     dwResult, j, k, err, alen;
    DWORD                   i;
    PMIB_IPFORWARDTABLE     prifRouteTable = NULL;
    PMIB_IFTABLE            pIfTable       = NULL;

    // ====================================================================
    // Get Route Table.

    pResults->Route.dwNumRoutes = 0;
    InitializeListHead(&pResults->Route.lmsgRoute);

    dwResult = InternalGetIpForwardTable(&prifRouteTable,
                                         GetProcessHeap(), HEAP_NO_SERIALIZE );

    if(dwResult || !prifRouteTable){
        DEBUG_PRINT(("GetIpForwardTable/2: err=%d, dwResult=%d\n",
                     GetLastError(), dwResult ));
        return S_FALSE;
    }

    if( ! prifRouteTable->dwNumEntries )
    {
        return S_OK;
    }


    for(i = 0; i < prifRouteTable->dwNumEntries; i++)
    {
        PMIB_IPFORWARDROW pfr = &prifRouteTable->table[i];

        // Only print this entry if the destination matches the parameter

        if( ( Dest != NULL )
            &&  ( DestVal != WILD_CARD )
            &&  ( pfr->dwForwardDest != DestVal )
            &&  ( DestPat == NULL )
            )
            continue;

        // Only print this entry if the Gateway matches the parameter

        if( ( Gate != NULL )
            && ( GateVal != WILD_CARD  )
            && ( pfr->dwForwardNextHop != GateVal )
            )
            continue;

        if( DestPat )
        {
            char DestStr[32];
            NetpIpAddressToStr( pfr->dwForwardDest, DestStr );
            if( ! match( DestPat, DestStr ) )
            {
                TRACE_PRINT(("PrintRoute: skipping %s !~ %s\n",
                             DestPat, DestStr ));
                continue;
            }
        }

        // Either we have a match on Dest/Gateway or they are
        // wildcard/don't care.

        // Display the header first time.

        // We are going to display only static routes

        if ( printcount++ < 1 )
            //IDS_ROUTE_14203                  "Network Destination          Netmask             Gateway           Interface    Metric\n"
           AddMessageToListId( &pResults->Route.lmsgRoute, Nd_ReallyVerbose, IDS_ROUTE_14203);

       //IDS_ROUTE_14204                  "%s\n"
        AddMessageToList( &pResults->Route.lmsgRoute, Nd_ReallyVerbose,
                          IDS_ROUTE_14204,
                          PrintRouteEntry( pfr->dwForwardDest,
                                pfr->dwForwardMask,
                                pfr->dwForwardNextHop,
                                pfr->dwForwardIfIndex,
                                pfr->dwForwardMetric1)
              );
    }

    pResults->Route.dwNumRoutes = printcount;

    HeapFree( GetProcessHeap(), HEAP_NO_SERIALIZE, pIfTable );
    HeapFree( GetProcessHeap(), HEAP_NO_SERIALIZE, prifRouteTable);

    return ( NO_ERROR );
}


LPCTSTR
PrintRouteEntry(
         ULONG Dest,
         ULONG Mask,
         ULONG Gate,
         ULONG Interface,
         ULONG Metric1
         )
/*++
Description:
Formats and displays a single route entry.

Arguments:
Dest:      The destination address.
Mask:      The destination netmask.
Gate:      The first hop gateway address.
Interface: The interface address for the gateway net.
Metric1:   The primary route metric.

Author:
 07/01/98 Rajkumar

--*/
{
    static TCHAR  s_szBuffer[512];
    TCHAR   szFormat[128];
    char   DestStr[32];
    char   GateStr[32];
    char   NetmaskStr[32];
    char   MetricStr[32];
    char   IfStr[32];

    NetpIpAddressToStr( Dest, DestStr);
    NetpIpAddressToStr( Gate, GateStr);
    NetpIpAddressToStr( Mask, NetmaskStr);


    MapInterface(IfStr,Interface);

    if( Metric1 > MAX_METRIC )    Metric1 = MAX_METRIC;

    sprintf( MetricStr, "%u", Metric1 );

    //IDS_ROUTE_14205       "%16s  %16s  %16s  %16s  %6s"
    LoadString(NULL, IDS_ROUTE_14205, szFormat, DimensionOf(szFormat));
    assert(szFormat[0]);
    _stprintf(s_szBuffer, szFormat, DestStr,
              NetmaskStr, GateStr, IfStr, MetricStr);
    return s_szBuffer;

}



BOOLEAN
ExtractRoute(
    char  *RouteString,
    ULONG *DestVal,
    ULONG *MaskVal,
    ULONG *GateVal,
    ULONG *MetricVal
    )
/*++
Description:
Extracts the dest, mask, and gateway from a persistent
route string, as stored in the registry.

Arguments:
RouteString : The string to parse.
DestVal     : The place to put the extracted destination
MaskVal     : The place to put the extracted mask
GateVal     : The place to put the extracted gateway
MetricVal   : The place to put the extracted metric


Author:
 07/01/98 Rajkumar . Created.

--*/
{
    char  *addressPtr = RouteString;
    char  *indexPtr = RouteString;
    ULONG  address;
    ULONG  i;
    char   saveChar;
    BOOLEAN EndOfString=FALSE;

    //
    // The route is laid out in the string as "Dest,Mask,Gateway,Mertic".
    //


    //
    // set MetricVal to 1 to take care of persistent routes without the
    // metric value
    //

    *MetricVal = 1;

    for (i=0; i<4 && !EndOfString; i++) {
        //
        // Walk the string to the end of the current item.
        //

        while (1) {

            if (*indexPtr == '\0') {

                if ((i >= 2) && (indexPtr != addressPtr)) {
                    //
                    // End of string
                    //
                    EndOfString = TRUE;
                    break;
                }

                return(FALSE);
            }

            if (*indexPtr == ROUTE_SEPARATOR) {
                break;
            }

            indexPtr++;
        }

        //
        // NULL terminate the current substring and extract the address value.
        //
        saveChar = *indexPtr;

        *indexPtr = '\0';

        if (i==3) {
           address = atoi (addressPtr);
        } else if (!ImprovedInetAddr(addressPtr, &address)) {
            *indexPtr = saveChar;
            return(FALSE);
        }

        *indexPtr = saveChar;

        switch(i) {
        case 0:    *DestVal = address;   break;
        case 1:    *MaskVal = address;   break;
        case 2:    *GateVal = address;   break;
        case 3:    *MetricVal = address; break;
        default:   return FALSE;
        }
        addressPtr = ++indexPtr;
    }

    return(TRUE);
}

//
// Rajkumar - This function is based on route implementation
//

HRESULT
PrintPersistentRoutes(
    NETDIAG_RESULT  *pResults,
    char* Dest,
    ULONG DestVal,
    char* Gate,
    ULONG GateVal
   )
/*++
Routine Description:
Displays the list of persistent routes


Arguments:  Dest     : The destination string. (display filter)
            DestVal  : The numeric destination value. (display filter)
            Gate     : The gateway string. (display filter)
            GateVal  : The numeric gateway value. (display filter)

Returns: None


--*/
{
    //
    // Delete this route from the PersistentRoutes list in the
    // registry if it is there.
    //
    DWORD     status;
    HKEY      key;
    char      valueString[ROUTE_DATA_STRING_SIZE];
    DWORD     valueStringSize;
    DWORD     valueType;
    DWORD     index = 0;
    ULONG     dest, mask, gate, metric;
    BOOLEAN   headerPrinted = FALSE;
    BOOLEAN   match;

    pResults->Route.dwNumPersistentRoutes = 0;
    InitializeListHead(&pResults->Route.lmsgPersistentRoute);

    status = RegOpenKeyA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\PersistentRoutes", &key);

    if (status == ERROR_SUCCESS)
    {

        while(1) {


            valueStringSize = ROUTE_DATA_STRING_SIZE - 1;

            status = RegEnumValueA(
                                   key,
                                   index++,
                                   valueString,
                                   &valueStringSize,
                                   NULL,
                                   &valueType,
                                   NULL,
                                   0
                                   );


            if (status != ERROR_SUCCESS)
            {
                if ((status == ERROR_BUFFER_OVERFLOW) ||
                    (status == ERROR_MORE_DATA) )
                {
                    continue;
                }
                else
                    break;
            }

            if (valueType != REG_SZ)
                continue;


            valueString[valueStringSize++] = '\0';


            if ( !ExtractRoute(
                               valueString,
                               &dest,
                               &mask,
                               &gate,
                               &metric
                               )
                )
              {
                  continue;
              }


              //IDS_ROUTE_14207                  "%s\n"
              AddMessageToList( &pResults->Route.lmsgPersistentRoute, Nd_ReallyVerbose,
                                IDS_ROUTE_14207,
                                PrintRouteEntry(dest, mask, gate, 0, metric));

              pResults->Route.dwNumPersistentRoutes++;

        } // end while

        CloseHandle(key);
    }
    else
    {
        DebugMessage2("RegOpenKeyA %s failed\n","Tcpip\\Parameters\\Persistent");
        return S_FALSE;
    }

    return S_OK;
}


void MapInterface(char *IPAddr, ULONG IfIndex)
{

    DWORD IpAddrTableSize=0;
    PMIB_IPADDRTABLE pIpAddrTable=NULL;
    char *TempBuf;
    BOOL bOrder=TRUE;
    HRESULT hr;
    DWORD i;


    sprintf(IPAddr,"%x",IfIndex);

    hr=GetIpAddrTable(NULL,
                      &IpAddrTableSize,
                      bOrder);

    if (hr != ERROR_SUCCESS && hr != ERROR_INSUFFICIENT_BUFFER) {
        DebugMessage("GetIpAddrTable() failed.\n");
        return;
    }

    pIpAddrTable=(PMIB_IPADDRTABLE) Malloc(IpAddrTableSize);

    if (pIpAddrTable == NULL) {
        DebugMessage("Out of Memory in RouteTest::MapInterface().\n");
        return;
    }

    ZeroMemory( pIpAddrTable, IpAddrTableSize );

    hr=GetIpAddrTable(pIpAddrTable,
                          &IpAddrTableSize,
                          bOrder);


    if (hr != ERROR_SUCCESS)
    {
        DebugMessage("GetIpAddrTable() failed.\n");
        Free(pIpAddrTable);
        return;
    }


    for (i=0; i < pIpAddrTable->dwNumEntries; i++)
    {
        if ((pIpAddrTable->table[i].dwIndex == IfIndex) && (pIpAddrTable->table[i].dwAddr != 0) && (pIpAddrTable->table[i].wType & MIB_IPADDR_PRIMARY))
        {
            TempBuf=inet_ntoa(*(struct in_addr*)&pIpAddrTable->table[i].dwAddr);
            if (!TempBuf) {
                break;;
            }
            strcpy(IPAddr, TempBuf);
            break;
        }

    }

    Free(pIpAddrTable);
    return;
}


BOOLEAN
ImprovedInetAddr(
    char  *AddressString,
    ULONG *AddressValue
)
/*++

Description:
Converts an IP address string to its numeric equivalent.

Arguments:
 char *AddressString: The string to convert
 ULONG AddressValue : The place to store the converted value.

Returns: TRUE

Author:
  07/01/98 Rajkumar . Created.
--*/
{
    ULONG address = inet_addr(AddressString);

    if (address == 0xFFFFFFFF) {
        if (strcmp(AddressString, "255.255.255.255") == 0) {
           *AddressValue = address;
           return(TRUE);
        }

        return(FALSE);
    }

    *AddressValue = address;
    return TRUE;
}



void RouteGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (!pParams->fReallyVerbose)
        return;

    if (pParams->fReallyVerbose || !FHrOK(pResults->Route.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_ROUTE_LONG,
							 IDS_ROUTE_SHORT,
							 TRUE,
                             pResults->Route.hrTestResult,
                             0);
    }

    if( pParams->fReallyVerbose)
    {
        if( 0 == pResults->Route.dwNumRoutes)
        {
            //IDS_ROUTE_14201                  "No Entries in the IP Forward Table\n"
            PrintMessage( pParams, IDS_ROUTE_14201);
        }
        else
        {
            //IDS_ROUTE_14202                  "Active Routes :\n"
            PrintMessage( pParams, IDS_ROUTE_14202);
            PrintMessageList(pParams, &pResults->Route.lmsgRoute);
        }

        if( 0 == pResults->Route.dwNumPersistentRoutes)
        {
             //IDS_ROUTE_14208                  "No persistent route entries.\n"
             PrintMessage( pParams, IDS_ROUTE_14208);

        }
        else
        {
            //IDS_ROUTE_14206                  "\nPersistent Route Entries: \n"
            PrintMessage( pParams, IDS_ROUTE_14206);
            PrintMessageList(pParams, &pResults->Route.lmsgPersistentRoute);
        }
    }

}


void RoutePerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    if (!pParams->fReallyVerbose)
        return;

}


void RouteCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Route.lmsgRoute);
    MessageListCleanUp(&pResults->Route.lmsgPersistentRoute);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\sample.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      sample.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--


#include "precomp.h"

HRESULT SamplePassTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	if (pParams->fReallyVerbose)
	{
		printf("    Performing the sample pass test... pass\n");
	}
    return S_OK;

} /* END OF SamplePassTest() */


/*!--------------------------------------------------------------------------
	SamplePassGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SamplePassGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	if (pParams->fVerbose)
	{
		printf(" Sample Pass Test : pass\n");
	}
	if (pParams->fReallyVerbose)
	{
		printf("    more text\n");
	}
}

/*!--------------------------------------------------------------------------
	SamplePassPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SamplePassPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	SamplePassCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SamplePassCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
}



HRESULT SampleFailTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	if (pParams->fReallyVerbose)
	{
		printf("    Performing the sample fail test... fail\n");
	}
    return S_FALSE;

} /* END OF SampleFailTest() */


/*!--------------------------------------------------------------------------
	SampleFailGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SampleFailGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	printf(" Sample Fail Test : fail\n");
	printf("    more text\n");
}

/*!--------------------------------------------------------------------------
	SampleFailPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SampleFailPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	SampleFailCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SampleFailCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\results.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      results.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//		the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information. 
//--

//
// Common include files.
//
#include "precomp.h"
#include "netdiag.h"
#include "ipcfg.h"



static TCHAR	s_szBuffer[4096];
static TCHAR	s_szFormat[4096];

const TCHAR	c_szWaitDots[] = _T(".");


void PrintMessage(NETDIAG_PARAMS *pParams, UINT uMessageID, ...)
{
    UINT nBuf;
    va_list args;

    va_start(args, uMessageID);

    LoadString(NULL, uMessageID, s_szFormat, sizeof(s_szFormat));

    nBuf = _vstprintf(s_szBuffer, s_szFormat, args);
    assert(nBuf < DimensionOf(s_szBuffer));

    va_end(args);
    
    PrintMessageSz(pParams, s_szBuffer);
}

void PrintMessageSz(NETDIAG_PARAMS *pParams, LPCTSTR pszMessage)
{
    if(pParams->fLog)
    {
        _ftprintf( pParams->pfileLog, pszMessage );
    }

	_tprintf(pszMessage);
    fflush(stdout);
}


/*!--------------------------------------------------------------------------
	ResultsCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ResultsCleanup(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	int		i;
	
	// Clean up the global variables
	Free( pResults->Global.pszCurrentVersion );
	pResults->Global.pszCurrentVersion = NULL;
	
	Free( pResults->Global.pszCurrentBuildNumber );
	pResults->Global.pszCurrentBuildNumber = NULL;
	
	Free( pResults->Global.pszCurrentType );
	pResults->Global.pszCurrentType = NULL;

	Free( pResults->Global.pszProcessorInfo );
	pResults->Global.pszProcessorInfo = NULL;

	Free( pResults->Global.pszServerType );
	pResults->Global.pszServerType = NULL;

	// delete the individual strings
	for (i=0; i<pResults->Global.cHotFixes; i++)
		Free(pResults->Global.pHotFixes[i].pszName);
	Free( pResults->Global.pHotFixes );
	pResults->Global.pHotFixes = NULL;
	pResults->Global.cHotFixes = 0;

	// Do NOT free this up.  This will get freed up with the list
	// of domains.
	// pResults->Global.pMemberDomain
	// pResults->Global.pLogonDomain
	if (pResults->Global.pMemberDomain)
	{
		Free( pResults->Global.pMemberDomain->DomainSid );
		pResults->Global.pMemberDomain->DomainSid = NULL;
	}

	LsaFreeMemory(pResults->Global.pLogonUser);
	pResults->Global.pLogonUser = NULL;
	LsaFreeMemory(pResults->Global.pLogonDomainName);
	pResults->Global.pLogonDomainName = NULL;
	
	if (pResults->Global.pPrimaryDomainInfo)
	{
		DsRoleFreeMemory(pResults->Global.pPrimaryDomainInfo);
		pResults->Global.pPrimaryDomainInfo = NULL;
	}

	Free( pResults->Global.pswzLogonServer );

	
	IpConfigCleanup(pParams, pResults);

	for (i=0; i<pResults->cNumInterfaces; i++)
	{
		Free(pResults->pArrayInterface[i].pszName);
		pResults->pArrayInterface[i].pszName = NULL;
		
		Free(pResults->pArrayInterface[i].pszFriendlyName);
		pResults->pArrayInterface[0].pszFriendlyName = NULL;
	}

	Free(pResults->pArrayInterface);
	pResults->pArrayInterface = NULL;
	pResults->cNumInterfaces = 0;

}



/*!--------------------------------------------------------------------------
	SetMessageId
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SetMessageId(NdMessage *pNdMsg, NdVerbose ndv, UINT uMessageId)
{
	assert(pNdMsg);
	ClearMessage(pNdMsg);

	pNdMsg->ndVerbose = ndv;
	pNdMsg->uMessageId = uMessageId;
}


/*!--------------------------------------------------------------------------
	SetMessageSz
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SetMessageSz(NdMessage *pNdMsg, NdVerbose ndv, LPCTSTR pszMessage)
{
	assert(pNdMsg);
	ClearMessage(pNdMsg);
	
	pNdMsg->ndVerbose = ndv;
	pNdMsg->pszMessage = _tcsdup(pszMessage);
    pNdMsg->uMessageId = 0;
}

/*!--------------------------------------------------------------------------
	SetMessage
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SetMessage(NdMessage *pNdMsg, NdVerbose ndv, UINT uMessageId, ...)
{
    UINT nBuf;
    va_list args;

    va_start(args, uMessageId);

    LoadString(NULL, uMessageId, s_szFormat, sizeof(s_szFormat));

    nBuf = _vstprintf(s_szBuffer, s_szFormat, args);
    assert(nBuf < sizeof(s_szBuffer));

    va_end(args);
	SetMessageSz(pNdMsg, ndv, s_szBuffer);
}

/*!--------------------------------------------------------------------------
	ClearMessage
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ClearMessage(NdMessage *pNdMsg)
{
	if (pNdMsg == NULL)
		return;

	if (pNdMsg->pszMessage)			
		Free(pNdMsg->pszMessage);

	ZeroMemory(pNdMsg, sizeof(*pNdMsg));
}


/*!--------------------------------------------------------------------------
	PrintNdMessage
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void PrintNdMessage(NETDIAG_PARAMS *pParams, NdMessage *pNdMsg)
{
	LPCTSTR	pszMsg = NULL;

	assert(pParams);

	if (pNdMsg == NULL)
		return;

	// test verbosity level
	if ((pNdMsg->ndVerbose == Nd_DebugVerbose) &&
		!pParams->fDebugVerbose)
		return;

	if ((pNdMsg->ndVerbose == Nd_ReallyVerbose) &&
		!pParams->fReallyVerbose)
		return;

	if ((pNdMsg->ndVerbose == Nd_Verbose) &&
		!pParams->fVerbose)
		return;

	// get the message to print
	if (pNdMsg->uMessageId)
	{
		LoadString(NULL, pNdMsg->uMessageId, s_szBuffer,
				   DimensionOf(s_szBuffer));
		assert(s_szBuffer[0]);
		pszMsg = s_szBuffer;
	}
	else
		pszMsg = pNdMsg->pszMessage;

	if (pszMsg)
		PrintMessageSz(pParams, pszMsg);

	fflush(stdout);
}


//---------------------------------------------------------------
//  AddMessageToListSz
//      Add a string based message at tail of the list. 
//  Author  NSun
//---------------------------------------------------------------
void AddMessageToListSz(PLIST_ENTRY plistHead, NdVerbose ndv, LPCTSTR pszMsg)
{
    NdMessageList *plMessage = NULL;

    if( NULL == plistHead || NULL == pszMsg )
        return;

    plMessage = Malloc(sizeof(NdMessageList));

    assert(plMessage);
	if (plMessage)
	{
		ZeroMemory(plMessage, sizeof(NdMessageList));

		SetMessageSz(&plMessage->msg, ndv, pszMsg);

		InsertTailList(plistHead, &plMessage->listEntry);
	}
}

void AddIMessageToListSz(PLIST_ENTRY plistHead, NdVerbose ndv, int nIndent, LPCTSTR pszMsg)
{
	TCHAR	szBuffer[4096];
	int		i;
    NdMessageList *plMessage = NULL;

    if( NULL == plistHead || NULL == pszMsg )
        return;

	assert(nIndent < 4096);
	assert((nIndent + StrLen(pszMsg)) < (DimensionOf(szBuffer)-1));

	for (i=0; i<nIndent; i++)
		szBuffer[i] = _T(' ');
	szBuffer[i] = 0;

	StrCat(szBuffer, pszMsg);
	
    plMessage = Malloc(sizeof(NdMessageList));

    assert(plMessage);
	if (plMessage)
	{
		ZeroMemory(plMessage, sizeof(NdMessageList));

		SetMessageSz(&plMessage->msg, ndv, szBuffer);
		
		InsertTailList(plistHead, &plMessage->listEntry);
	}
}


//---------------------------------------------------------------
//  AddMessageToListId
//      Add an ID based message at tail of the list. 
//  Author  NSun
//---------------------------------------------------------------
void AddMessageToListId(PLIST_ENTRY plistHead, NdVerbose ndv, UINT uMessageId)
{
    NdMessageList *plMsg = NULL;
    
    if( NULL == plistHead )
        return;
    
    plMsg = Malloc(sizeof(NdMessageList));
    assert(plMsg); 
    if (plMsg)
    {
       ZeroMemory(plMsg, sizeof(NdMessageList));

       SetMessageId(&plMsg->msg, ndv, uMessageId);

       InsertTailList(plistHead, &plMsg->listEntry);
    }
}


//---------------------------------------------------------------
//  AddMessageToList
//      Add a message based on message ID and optional parameters 
//      at tail of the list. 
//  Author  NSun
//---------------------------------------------------------------
void AddMessageToList(PLIST_ENTRY plistHead, NdVerbose ndv, UINT uMessageId, ...)
{
    NdMessageList *plMessage = NULL;
    UINT nBuf;
    va_list args;

    if(NULL == plistHead) 
        return;

    plMessage = Malloc(sizeof(NdMessageList));

    assert(plMessage); 
    if (plMessage)
    {
       ZeroMemory(plMessage, sizeof(NdMessageList));

       va_start(args, uMessageId);

       LoadString(NULL, uMessageId, s_szFormat, sizeof(s_szFormat));

       nBuf = _vstprintf(s_szBuffer, s_szFormat, args);
       assert(nBuf < sizeof(s_szBuffer));

       va_end(args);
       SetMessageSz(&plMessage->msg, ndv, s_szBuffer);

       InsertTailList(plistHead, &plMessage->listEntry);
    }
}



void AddIMessageToList(PLIST_ENTRY plistHead, NdVerbose ndv, int nIndent, UINT uMessageId, ...)
{
    NdMessageList *plMessage = NULL;
    UINT nBuf;
	LPTSTR		pszFormat;
    va_list args;
	int		i;

    if(NULL == plistHead)
        return;

    plMessage = Malloc(sizeof(NdMessageList));

	for (i=0; i<nIndent; i++)
		s_szFormat[i] = _T(' ');
	s_szFormat[i] = 0;
	pszFormat = s_szFormat + nIndent;

    assert(plMessage); 
    if (plMessage)
    {
       ZeroMemory(plMessage, sizeof(NdMessageList));

       va_start(args, uMessageId);

       LoadString(NULL, uMessageId, pszFormat, 4096 - nIndent);

       nBuf = _vstprintf(s_szBuffer, s_szFormat, args);
       assert(nBuf < sizeof(s_szBuffer));

       va_end(args);
       SetMessageSz(&plMessage->msg, ndv, s_szBuffer);

       InsertTailList(plistHead, &plMessage->listEntry);
    }
}




//---------------------------------------------------------------
//  PrintMessageList
//  
//  Author  NSun
//---------------------------------------------------------------
void PrintMessageList(NETDIAG_PARAMS *pParams, PLIST_ENTRY plistHead)
{
    NdMessageList* plMsg;
    PLIST_ENTRY plistEntry = plistHead->Flink;
    
    if( NULL == plistEntry ) return;
    
    for(; plistEntry != plistHead; plistEntry = plistEntry->Flink)
    {
        assert(plistEntry);
        plMsg = CONTAINING_RECORD( plistEntry, NdMessageList, listEntry );
        PrintNdMessage(pParams, &plMsg->msg);
    }
}


//---------------------------------------------------------------
//  MessageListCleanUp
//  
//  Author  NSun
//---------------------------------------------------------------
void MessageListCleanUp(PLIST_ENTRY plistHead)
{
    PLIST_ENTRY plistEntry = plistHead->Flink;
    NdMessageList* plMsg;
    
    if( NULL == plistEntry ) 
		return;

    while(plistEntry != plistHead)
    {
        assert(plistEntry);
        plMsg = CONTAINING_RECORD( plistEntry, NdMessageList, listEntry );
        plistEntry = plistEntry->Flink;
        ClearMessage(&plMsg->msg);
        Free(plMsg);
    }
}


void PrintStatusMessage(NETDIAG_PARAMS *pParams, int iIndent, UINT uMessageId, ...)
{
	INT nBuf;
    va_list args;
	int	i;

	//if not in really verbose mode, print wait dots
	PrintWaitDots(pParams);

	if (pParams->fReallyVerbose)
	{
		va_start(args, uMessageId);
		
		LoadString(NULL, uMessageId, s_szFormat, sizeof(s_szFormat));
		
		nBuf = _vsntprintf(s_szBuffer, DimensionOf(s_szBuffer), s_szFormat, args);
		assert(nBuf > 0);
		s_szBuffer[DimensionOf(s_szBuffer)-1] = 0;
		assert(nBuf < sizeof(s_szBuffer));
		
		va_end(args);

		if (iIndent)
		{
			for (i=0; i<iIndent; i++)
				s_szFormat[i] = _T(' ');
			s_szFormat[i] = 0;
			PrintMessageSz(pParams, s_szFormat);
		}
		
		PrintMessageSz(pParams, s_szBuffer);
	}
}

void PrintStatusMessageSz(NETDIAG_PARAMS *pParams, int iIndent, LPCTSTR pszMessage)
{
	int		i;
	
	if (pParams->fReallyVerbose)
	{
		if (iIndent)
		{
			for (i=0; i<iIndent; i++)
				s_szFormat[i] = _T(' ');
			s_szFormat[i] = 0;
			PrintMessageSz(pParams, s_szFormat);
		}
		
		PrintMessageSz(pParams, pszMessage);
	}
}


void PrintDebug(NETDIAG_PARAMS *pParams, int iIndent, UINT uMessageId, ...)
{
	INT nBuf;
    va_list args;
	int	i;

	if (pParams->fDebugVerbose)
	{
		va_start(args, uMessageId);
		
		LoadString(NULL, uMessageId, s_szFormat, sizeof(s_szFormat));
		
		nBuf = _vsntprintf(s_szBuffer, DimensionOf(s_szBuffer), s_szFormat, args);
		assert(nBuf > 0);
		s_szBuffer[DimensionOf(s_szBuffer)-1] = 0;
		assert(nBuf < sizeof(s_szBuffer));
		
		va_end(args);

		if (iIndent)
		{
			for (i=0; i<iIndent; i++)
				s_szFormat[i] = _T(' ');
			s_szFormat[i] = 0;
			PrintMessageSz(pParams, s_szFormat);
		}
		
		PrintMessageSz(pParams, s_szBuffer);
	}
}


void PrintDebugSz(NETDIAG_PARAMS *pParams, int iIndent, LPCTSTR pszFormat, ...)
{
	INT nBuf;
    va_list args;
	int	i;

	if (pParams->fDebugVerbose)
	{
		va_start(args, pszFormat);
		
		nBuf = _vsntprintf(s_szBuffer, DimensionOf(s_szBuffer), pszFormat, args);
		assert(nBuf > 0);
		s_szBuffer[DimensionOf(s_szBuffer)-1] = 0;
		assert(nBuf < sizeof(s_szBuffer));
		
		va_end(args);

		if (iIndent)
		{
			for (i=0; i<iIndent; i++)
				s_szFormat[i] = _T(' ');
			s_szFormat[i] = 0;
			PrintMessageSz(pParams, s_szFormat);
		}
		
		PrintMessageSz(pParams, s_szBuffer);
	}
}



VOID
_PrintGuru(
    IN NETDIAG_PARAMS * pParams,
    IN NET_API_STATUS NetStatus,
    IN LPSTR DefaultGuru
    )
/*++

Routine Description:

    Print the Status and the name of the guru handling the status.

Arguments:

    NetStatus - Status used to differentiate
        0:  Just print the guru name
        -1: Just print the guru name

    DefaultGuru - Guru to return if no other guru can be found

Return Value:

    Name of Guru responsible for the specified status

--*/
{
    LPTSTR Guru;

    //
    // If a status was given,
    //  print it.
    //
    if ( NetStatus != 0 && NetStatus != -1) 
    {
        PrintMessageSz( pParams, NetStatusToString(NetStatus) );
    }

    //
    // Some status codes can be attributed base on the value of the status code.
    //
    if ( NetStatus >= WSABASEERR && NetStatus <= WSABASEERR + 2000 ) 
    {
        Guru = WINSOCK_GURU;
    } else if ( NetStatus >= DNS_ERROR_RESPONSE_CODES_BASE && NetStatus <= DNS_ERROR_RESPONSE_CODES_BASE + 1000 ) {
        Guru = DNS_GURU;
    } else {
        Guru = DefaultGuru;
    }

    PrintMessageSz( pParams, Guru );
    PrintNewLine( pParams, 1 );
}


void PrintWaitDots(NETDIAG_PARAMS *pParams)
{
	if (!pParams->fReallyVerbose && !pParams->fDebugVerbose)
	{
		_tprintf(c_szWaitDots);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\results.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       results.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_RESULTS
#define HEADER_RESULTS

#ifdef _DEBUG
    #define DebugMessage(str) printf(str)
    #define DebugMessage2(format, arg) printf(format, arg)
    #define DebugMessage3(format, arg1, arg2) printf(format, arg1, arg2)
#else
    #define DebugMessage(str)
    #define DebugMessage2(format, arg)
    #define DebugMessage3(format, arg1, arg2)
#endif

#ifdef _SHOW_GURU
    #define PrintGuru(status, guru) _PrintGuru(status, guru)
    #define PrintGuruMessage         printf
    #define PrintGuruMessage2        printf
    #define PrintGuruMessage3        printf
#else
    #define PrintGuru(status, guru)
    #define PrintGuruMessage( str )
    #define PrintGuruMessage2( format, arg )
    #define PrintGuruMessage3(format, arg1, arg2)
#endif

#define NETCARD_CONNECTED		0
#define NETCARD_DISCONNECTED	1
#define NETCARD_STATUS_UNKNOWN	2

/*---------------------------------------------------------------------------
	Struct:	HotFixInfo

	This structure holds the information about a single Hotfix.
 ---------------------------------------------------------------------------*/
typedef struct
{
	BOOL	fInstalled;
	LPTSTR	pszName;		// use Free() to free
}	HotFixInfo;



/*---------------------------------------------------------------------------
	NdMessage

	This provides for an easier way to pass messages along.
 ---------------------------------------------------------------------------*/

typedef enum {
	Nd_Quiet = 0,			// i.e. always print
	Nd_Verbose = 1,
	Nd_ReallyVerbose = 2,
	Nd_DebugVerbose = 3,
} NdVerbose;

typedef struct
{
	NdVerbose	ndVerbose;

	// possible combinations
	//		uMessageId == 0, pszMessage == NULL		-- assume not set
	//		uMessageId != 0, pszMessage == NULL		-- use string id
	//		uMessageId == 0, pszMessage != NULL		-- use string
	//		uMessageId != 0, pszMessage != NULL		-- use string id
	//

	// Note: the maximum size for a string loaded through this is 4096!
	UINT	uMessageId;
	LPTSTR	pszMessage;
} NdMessage;

typedef struct ND_MESSAGE_LIST
{
    LIST_ENTRY listEntry;
    NdMessage msg;
}NdMessageList;

void SetMessageId(NdMessage *pNdMsg, NdVerbose ndv, UINT uMessageId);
void SetMessage(NdMessage *pNdMsg, NdVerbose ndv, UINT uMessageId, ...);
void SetMessageSz(NdMessage *pNdMsg, NdVerbose ndv, LPCTSTR pszMessage);
void ClearMessage(NdMessage *pNdMsg);

void PrintNdMessage(NETDIAG_PARAMS *pParams, NdMessage *pNdMsg);

void AddIMessageToList(PLIST_ENTRY plistHead, NdVerbose ndv, int nIndent, UINT uMessageId, ...);
void AddIMessageToListSz(PLIST_ENTRY plistHead, NdVerbose ndv, int nIndent, LPCTSTR pszMsg);

void AddMessageToList(PLIST_ENTRY plistHead, NdVerbose ndv, UINT uMessageId, ...);
void AddMessageToListSz(PLIST_ENTRY plistHead, NdVerbose ndv, LPCTSTR pszMsg);
void AddMessageToListId(PLIST_ENTRY plistHead, NdVerbose ndv, UINT uMessageId);
void PrintMessageList(NETDIAG_PARAMS *pParams, PLIST_ENTRY plistHead);
void MessageListCleanUp(PLIST_ENTRY plistHead);


// These functions are for status messages (the messages that appear at the
// top).
void PrintStatusMessage(NETDIAG_PARAMS *pParams, int iIndent, UINT uMessageId, ...);
void PrintStatusMessageSz(NETDIAG_PARAMS *pParams, int iIndent, LPCTSTR pszMessage);


// Use this for printing debug messages (messages that require fDebugVerbose)
void PrintDebug(NETDIAG_PARAMS *pParams, int nIndent, UINT uMessageId, ...);
void PrintDebugSz(NETDIAG_PARAMS *pParams, int nIndent, LPCTSTR pszMessage, ...);



/*---------------------------------------------------------------------------
	Struct:		GLOBAL_RESULT
 ---------------------------------------------------------------------------*/
typedef struct {
	WCHAR	swzNetBiosName[MAX_COMPUTERNAME_LENGTH+1];
	TCHAR	szDnsHostName[DNS_MAX_NAME_LENGTH+1];
	LPTSTR	pszDnsDomainName;	// this points to a string in szDnsHostName
	
	WSADATA	wsaData;

	// NetBT parameters
	DWORD	dwLMHostsEnabled;	// TRUE, FALSE, or HRESULT on error to read
	DWORD	dwDnsForWINS;	// TRUE, FALSE, or HRESULT on error to read

	// Server/OS information (such as version, build no, etc...)
	LPTSTR	pszCurrentVersion;
	LPTSTR	pszCurrentBuildNumber;
	LPTSTR	pszCurrentType;
	LPTSTR	pszProcessorInfo;
	LPTSTR	pszServerType;
	int		cHotFixes;
	HotFixInfo * pHotFixes;

	// List of domains to be tested
	LIST_ENTRY		listTestedDomains;

	// Domain member information
	// the primary domain info got by using DsRoleGetPrimaryDomainInformation()
	PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo;

	PTESTED_DOMAIN	pMemberDomain;	//the primary domain info in the TESTED_DOMAIN struct

	BOOL			fNetlogonIsRunning;
	HRESULT			hrMemberTestResult;		// result of the test

	// Logon information (who we're logged on as)
	PUNICODE_STRING	pLogonUser;
	PUNICODE_STRING	pLogonDomainName;
	PTESTED_DOMAIN	pLogonDomain;
	BOOL			fLogonWithCachedCredentials;
	LPWSTR			pswzLogonServer;

	BOOL			fKerberosIsWorking;
	BOOL			fSysVolNotReady;

	// Is there any interfaces that are NetBT enabled
	BOOL	fHasNbtEnabledInterface;

	
} GLOBAL_RESULT;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_IPCONFIG
 ---------------------------------------------------------------------------*/
typedef struct {
	// set to TRUE if InitIpconfig has been run
	BOOL	fInitIpconfigCalled;

	// Is IPX actually up and running?
	BOOL	fEnabled;

	//
	// IP-related info (non-DHCP related)
	//
	FIXED_INFO *	pFixedInfo;

	//
	// This is a pointer to the beginning of the adapter list
	// (Use this to free up the list of interfaces)
	//
	IP_ADAPTER_INFO *	pAdapterInfoList;

	// Is DHCP enabled? (on any adapter)
	BOOL				fDhcpEnabled;
} GLOBAL_IPCONFIG;



/*---------------------------------------------------------------------------
	Struct:	IPCONFIG_TST
 ---------------------------------------------------------------------------*/
typedef struct {

	// IP is active on this interface
	BOOL			fActive;

	//
	// Pointer to the IP adapter info for this interface
	// Do NOT free this up!  (free up the entire list by freeing
	// up GLOBAL_IPCONFIG::pAdapterInfoList
	//
	IP_ADAPTER_INFO *	pAdapterInfo;

	TCHAR				szDhcpClassID[MAX_DOMAIN_NAME_LEN];

	// Is autoconfiguration possible?
	DWORD				fAutoconfigEnabled;

	// is the adapter currently autoconfigured?
	DWORD				fAutoconfigActive;

	// WINS node type?
	UINT				uNodeType;

	TCHAR				szDomainName[MAX_DOMAIN_NAME_LEN+1];

	IP_ADDR_STRING		DnsServerList;

	// Can we ping the DHCP server?
	HRESULT				hrPingDhcpServer;
	NdMessage			msgPingDhcpServer;

	// Can we ping the WINS servers?
	HRESULT				hrPingPrimaryWinsServer;
	NdMessage			msgPingPrimaryWinsServer;
	HRESULT				hrPingSecondaryWinsServer;
	NdMessage			msgPingSecondaryWinsServer;

	// hrOK if the default gateway is on the same subnet as the ip address
	HRESULT				hrDefGwSubnetCheck;

	// Test result
	HRESULT				hr;
	
} IPCONFIG_TST;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_LOOPBACK
 ---------------------------------------------------------------------------*/
typedef struct
{
	NdMessage		msgLoopBack;
	HRESULT			hr;
} GLOBAL_LOOPBACK;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_IPX
 ---------------------------------------------------------------------------*/
typedef struct
{
	// TRUE if IPX is installed, FALSE otherwise
	BOOL			fInstalled;

	// Is IPX actually up and running?
	BOOL	fEnabled;

	// Handle to IPX
	HANDLE			hIsnIpxFd;
	
	HRESULT			hr;
} GLOBAL_IPX;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_NETBT_TRANSPORTS
 ---------------------------------------------------------------------------*/
typedef struct
{
	LONG			cTransportCount;
	LIST_ENTRY		Transports;
	
	HRESULT			hr;
	BOOL		fPerformed; //FALSE: there are no inerfaces that are NetBT enabled. Test skipped.

	NdMessage		msgTestResult;
} GLOBAL_NETBT_TRANSPORTS;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_DEFGW
 ---------------------------------------------------------------------------*/
typedef struct
{
	// S_FALSE if no default gateways were reachable
	// S_OK if at least one default gateway was reached
	HRESULT	hrReachable;
} GLOBAL_DEFGW;

/*---------------------------------------------------------------------------
	Struct:	GLOBAL_AUTONET
 ---------------------------------------------------------------------------*/
typedef struct
{
    BOOL    fAllAutoConfig;
} GLOBAL_AUTONET;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_NETBTNM
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY  lmsgGlobalOutput;
    HRESULT hrTestResult;
} GLOBAL_NBTNM;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_BROWSER
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY  lmsgOutput;
    HRESULT hrTestResult;
	BOOL	fPerformed;		//test will be skipped if no interfaces have NetBT enabled
} GLOBAL_BROWSER;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_BINDINGS
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY lmsgOutput;
    HRESULT hrTestResult;
} GLOBAL_BINDINGS;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_WAN
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY	lmsgOutput;
	HRESULT		hr;
	BOOL		fPerformed; //FALSE: there are no active RAS connections. Test skipped.
} GLOBAL_WAN;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_WINSOCK
 ---------------------------------------------------------------------------*/
typedef struct
{
	UINT				idsContext;// str ID of context, which has %s to take the cause of failure
	HRESULT				hr;	// 0: success, otherwise failed
	DWORD				dwMaxUDP;	// max size of UDP packets, 0 
	DWORD				dwProts;	// number of protocols providers
    LPWSAPROTOCOL_INFO	pProtInfo;	// information on the providers
} GLOBAL_WINSOCK;


typedef struct
{
    DWORD       dwNumRoutes;
    LIST_ENTRY  lmsgRoute;
    DWORD       dwNumPersistentRoutes;
    LIST_ENTRY  lmsgPersistentRoute;
    HRESULT     hrTestResult;
} GLOBAL_ROUTE;

typedef struct
{
    LIST_ENTRY  lmsgOutput;
    HRESULT     hrTestResult;
} GLOBAL_NDIS;

typedef struct
{
    LIST_ENTRY  lmsgGlobalOutput;
    LIST_ENTRY  lmsgInterfaceOutput;   //Interface statistics
    LIST_ENTRY  lmsgConnectionGlobalOutput;
    LIST_ENTRY  lmsgTcpConnectionOutput;    
    LIST_ENTRY  lmsgUdpConnectionOutput;
    LIST_ENTRY  lmsgIpOutput;       // IP statistics
    LIST_ENTRY  lmsgTcpOutput;      // TCP statistics
    LIST_ENTRY  lmsgUdpOutput;      // UDP statistics
    LIST_ENTRY  lmsgIcmpOutput;     // ICMP statistics
    HRESULT     hrTestResult;
} GLOBAL_NETSTAT;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_IPSEC
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY  lmsgGlobalOutput;
    LIST_ENTRY  lmsgAdditOutput;
} GLOBAL_IPSEC;

/*---------------------------------------------------------------------------
	Struct:	GLOBAL_DNS
 ---------------------------------------------------------------------------*/

typedef struct {
	HRESULT				hr;
	BOOL				fOutput;
    LIST_ENTRY			lmsgOutput;
} GLOBAL_DNS;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_NETWARE
 ---------------------------------------------------------------------------*/
typedef struct {
	LPTSTR				pszUser;
	LPTSTR				pszServer;
	LPTSTR				pszTree;
	LPTSTR				pszContext;

	BOOL				fConnStatus;
	BOOL				fNds;
	DWORD				dwConnType;
	
	
    LIST_ENTRY			lmsgOutput;
	HRESULT				hr;
} GLOBAL_NETWARE;


/*---------------------------------------------------------------------------
	Struct:	MODEM_DEVICE
 ---------------------------------------------------------------------------*/
typedef struct
{
	DWORD				dwNegotiatedSpeed;
	DWORD				dwModemOptions;
	DWORD				dwDeviceID;
	LPTSTR				pszPort;
	LPTSTR				pszName;
} MODEM_DEVICE;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_MODEM
 ---------------------------------------------------------------------------*/
typedef struct {
	NdMessage			ndOutput;

	int					cModems;
	MODEM_DEVICE *		pModemDevice;
	HRESULT				hr;
	BOOL				fPerformed; //FALSE: the machine has no line device, test skipped
} GLOBAL_MODEM;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_DCLIST
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY			lmsgOutput;

	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
	NdMessage			msgErr;
	HRESULT				hr;
} GLOBAL_DCLIST;



/*---------------------------------------------------------------------------
	Struct:	GLOBAL_TRUST
 ---------------------------------------------------------------------------*/
typedef struct
{
	LPTSTR				pszContext; // context of failure
	HRESULT				hr;	// 0: success, otherwise failed
	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
    LIST_ENTRY			lmsgOutput;
} GLOBAL_TRUST;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_KERBEROS
 ---------------------------------------------------------------------------*/
typedef struct
{
	UINT				idsContext;// str ID of context, which has %s to take the cause of failure
	HRESULT				hr;	// 0: success, otherwise failed
	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
    LIST_ENTRY			lmsgOutput;
} GLOBAL_KERBEROS;

/*---------------------------------------------------------------------------
	Struct:	GLOBAL_LDAP
 ---------------------------------------------------------------------------*/
typedef struct
{
	UINT				idsContext;// str ID of context, which has %s to take the cause of failure
	HRESULT				hr;	// 0: success, otherwise failed
	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
    LIST_ENTRY			lmsgOutput;
} GLOBAL_LDAP;


typedef struct
{
	HRESULT				hr;
	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
	LIST_ENTRY			lmsgOutput;
}	GLOBAL_DSGETDC;



/*---------------------------------------------------------------------------
	Struct:	AUTONET_TST
 ---------------------------------------------------------------------------*/
typedef struct {
    BOOL    fAutoNet;
} AUTONET_TST;


/*---------------------------------------------------------------------------
	Struct:	DEF_GW_TST
 ---------------------------------------------------------------------------*/
typedef struct {
    BOOL dwNumReachable;
    LIST_ENTRY lmsgOutput;
} DEF_GW_TST;


/*---------------------------------------------------------------------------
	Struct:	NBT_NM_TST
 ---------------------------------------------------------------------------*/
typedef struct {
    LIST_ENTRY lmsgOutput;
    BOOL    fActive;     //used for additional Nbt interfaces whose pResults->fActive == FALSE
    BOOL    fQuietOutput;
} NBT_NM_TST;


/*---------------------------------------------------------------------------
	Struct:	WINS_TST
 ---------------------------------------------------------------------------*/
typedef struct {
	LIST_ENTRY  	lmsgPrimary;
	LIST_ENTRY  	lmsgSecondary;

	// Test result
	HRESULT			hr;
	BOOL			fPerformed; //if FALSE: there is no WINS servier configured for this interface, test skipped
}WINS_TST;


/*---------------------------------------------------------------------------
	Struct:	DNS_TST
 ---------------------------------------------------------------------------*/
typedef struct {
	// Set to TRUE if there is non-verbose output (i.e. errors)
	BOOL		fOutput;
	LIST_ENTRY	lmsgOutput;
} DNS_TST;

typedef struct {
    int garbage;
} NDIS_TST;


typedef struct ___IPX_TEST_FRAME__ {
	// returns 0-3
	ULONG		uFrameType;

	// returns virtual net if NicId = 0
	ULONG		uNetworkNumber;

	// adapter's MAC address
	UCHAR		Node[6];

	LIST_ENTRY	list_entry;
} IPX_TEST_FRAME;

/*---------------------------------------------------------------------------
	Struct:	IPX_TST
 ---------------------------------------------------------------------------*/
typedef struct {
	// Is this interface enabled for IPX?
	BOOL		fActive;

	// passed into various functions
	USHORT		uNicId;

	// Returns TRUE if set
	BOOL		fBindingSet;

	// 1 = lan, 2 = up wan, 3 = down wan
	UCHAR		uType;

	// to support more than one FRAME type
	LIST_ENTRY	list_entry_Frames;	// it's ZeroMemoryed during init

} IPX_TST;



/*---------------------------------------------------------------------------
	Struct:	INTERFACE_RESULT
 ---------------------------------------------------------------------------*/
typedef struct {

	// If this is set to TRUE, show the data for this interface
	BOOL				fActive;

	// The media-sense status of this card
	DWORD				dwNetCardStatus;

	// Name (or ID) of this adapter (typically a GUID)
	LPTSTR				pszName;
	
	// Friendly name for this adapter
	LPTSTR				pszFriendlyName;

	//if NetBT is enabled
	BOOL				fNbtEnabled;
	
    IPCONFIG_TST        IpConfig;
    AUTONET_TST         AutoNet;
    DEF_GW_TST          DefGw;
    NBT_NM_TST          NbtNm;
    WINS_TST            Wins;
	DNS_TST				Dns;
    NDIS_TST            Ndis;
    IPX_TST             Ipx;    
} INTERFACE_RESULT;



/*---------------------------------------------------------------------------
	Struct:	NETDIAG_RESULT
 ---------------------------------------------------------------------------*/
typedef struct {
    GLOBAL_RESULT		Global;
	GLOBAL_IPCONFIG		IpConfig;
    GLOBAL_LOOPBACK		LoopBack;
	GLOBAL_NETBT_TRANSPORTS	NetBt;
    GLOBAL_DEFGW        DefGw;
    GLOBAL_AUTONET      AutoNet;
    GLOBAL_NBTNM        NbtNm;
    GLOBAL_BROWSER      Browser;
    GLOBAL_BINDINGS     Bindings;
	GLOBAL_WINSOCK		Winsock;
    GLOBAL_WAN          Wan;
	GLOBAL_IPX			Ipx;
	GLOBAL_DNS			Dns;
    GLOBAL_ROUTE        Route;
    GLOBAL_NDIS         Ndis;
    GLOBAL_NETSTAT      Netstat;
	GLOBAL_NETWARE		Netware;
	GLOBAL_TRUST		Trust;
	GLOBAL_MODEM		Modem;
	GLOBAL_KERBEROS		Kerberos;
	GLOBAL_DCLIST		DcList;
	GLOBAL_LDAP			LDAP;
	GLOBAL_DSGETDC		DsGetDc;
	GLOBAL_IPSEC		IPSec;
	
	LONG				cNumInterfaces;
	LONG				cNumInterfacesAllocated;
    INTERFACE_RESULT*	pArrayInterface;
	
} NETDIAG_RESULT;

void ResultsInit(NETDIAG_RESULT* pResults);
void PrintGlobalResults(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
void PrintPerInterfaceResults(NETDIAG_PARAMS *pParams,
							  NETDIAG_RESULT *pResults,
							  INTERFACE_RESULT *pIfRes);
void FindInterface(NETDIAG_RESULT *pResult, INTERFACE_RESULT **ppIf);
void ResultsCleanup(NETDIAG_PARAMS *pParams, NETDIAG_RESULT* pResults);

void PrintWaitDots(NETDIAG_PARAMS *pParams);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\spdcheck.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 2001
//
//  Module Name:
//
//      spdcheck.c
//
//  Abstract:
//
//      SPD Check stats for netdiag
//
//  Author:
//
//      Madhurima Pawar (mpawar)  - 10/15/2001
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//

#include "precomp.h"

#include <snmp.h>
#include <tcpinfo.h>
#include <ipinfo.h>
#include <llinfo.h>

#include <windows.h>
#include <winsock2.h>
#include <ipexport.h>
#include <icmpapi.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <wincrypt.h>
#include <stdio.h>
#include <objbase.h>
#include <dsgetdc.h>
#include <lm.h>
#include <userenv.h>

#include<crtdbg.h>

////////////////////////////////////////////////////////////////////////////////////////////////////	
//++
//function prototypes
//--
DWORD IPSecGetAssignedDirectoryPolicyData(CHECKLIST *pcheckList, HANDLE hPolicyStore, PIPSEC_POLICY_DATA *ppIpsecPolicyData );
void MMPolicyCheck(CHECKLIST *pcheckList, 
					    HANDLE hPolicyStore, 
					    IPSEC_POLICY_DATA *pIpsecPolicyData );
void CompareMMPolicies(CHECKLIST *pcheckList,
						     IPSEC_ISAKMP_DATA *pIpsecISAKMPData, 
						     IPSEC_MM_POLICY *pMMPolicy);
void NFAProcess(CHECKLIST *pcheckList, HANDLE hPolicyStore, IPSEC_POLICY_DATA *pIpsecPolicyData );
void DefaultRuleCheck( PIPSEC_NFA_DATA pIpsecNFAData, 
						  PPOLICYPARAMS ppolicyParams);
void MMAuthCheck(CHECKLIST *pcheckList,  
						PIPSEC_NFA_DATA pIpsecNFAData, 
						GUID gMMAuthID,
						PPOLICYPARAMS ppolicyParams );
void QMPolicyCheck(CHECKLIST *pcheckList, 
						  PIPSEC_NFA_DATA pIpsecNFAData, 
						  GUID gPolicyID,
						  PPOLICYPARAMS ppolicyParams);
DWORD CompareQMPolicies(CHECKLIST *pcheckList,
						     PPOLICYPARAMS ppolicyParams,
						     DWORD dwTunnelFlag, 							    
						     IPSEC_NEGPOL_DATA *pIpsecNegPolData, 
						     IPSEC_QM_POLICY *pQMPolicy);
DWORD CompareQMOffers(PIPSEC_SECURITY_METHOD pTempMethod,  PIPSEC_QM_OFFER  pTempOffer);
DWORD TransportFilterCheck(CHECKLIST* pcheckList, POLICYPARAMS *ppolicyParams, PIPSEC_NFA_DATA pIpsecNFAData);
DWORD CompareTransportFilter(CHECKLIST* pcheckList, POLICYPARAMS *ppolicyParams,PIPSEC_NFA_DATA pIpsecNFAData, IPSEC_FILTER_SPEC *pFilterSpec, TRANSPORT_FILTER *pTxFilter);
DWORD ComparePAInterfaceType(CHECKLIST* pcheckList, DWORD dwInterfaceType, IF_TYPE InterfaceType);
DWORD ComparePAAddress(CHECKLIST* pcheckList, ULONG uMask, ULONG uAddr, ADDR addr );
DWORD CompareFilterActions(CHECKLIST* pcheckList, POLICYPARAMS *ppolicyParams, FILTER_ACTION InboundFilterFlag, FILTER_ACTION OutboundFilterFlag);
DWORD TunnelFilterCheck(CHECKLIST* pcheckList, 
							POLICYPARAMS *ppolicyParams, 
							PIPSEC_NFA_DATA pIpsecNFAData);
DWORD CompareTunnelFilter(CHECKLIST* pcheckList, 
							POLICYPARAMS *ppolicyParams,
							PIPSEC_NFA_DATA pIpsecNFAData,
							IPSEC_FILTER_SPEC *pFilterSpec, 
					 	 	TUNNEL_FILTER *pTnFilter);
DWORD ComparePATunnelAddress(CHECKLIST* pcheckList, ULONG uAddr, ADDR addr );
void  MMFilterCheck(CHECKLIST *pcheckList, 
 					POLICYPARAMS *ppolicyParams,
					 PIPSEC_NFA_DATA pIpsecNFAData,
					 IPSEC_FILTER_SPEC *pFilterSpec);
DWORD CompareMMFilter(CHECKLIST* pcheckList, 
						POLICYPARAMS *ppolicyParams,
						PIPSEC_NFA_DATA pIpsecNFAData,
						IPSEC_FILTER_SPEC *pFilterSpec, 
					 	MM_FILTER *pMMFilter);

DWORD CompareAddress(IPSEC_FILTER ListFilter, IPSEC_FILTER Filter);
DWORD CheckFilterList(IPSEC_FILTER Filter);
FILTERLIST * GetNode(CHECKLIST* pcheckList, IPSEC_FILTER Filter);
void AddNodeToList(FILTERLIST *pList);

/////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL  SPDCheckTEST(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//Description:
//This is part of the ipsec test for netdiag.
//
//Arguments:
//	IN/OUT NETDIAG_PARAMS 
//	IN/OUT NETDIAG_RESULT
//Return:
//	S_OK or S_FALSE
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	HANDLE hPolicyStore = NULL;
	HKEY    hRegKey;
	      

	DWORD dwError = ERROR_SUCCESS;
	       
	//polstore data
	IPSEC_POLICY_DATA *pIpsecPolicyData = NULL;						
	
	CHECKLIST checkList;		
	
	//initialize checklist
	checkList.pParams = pParams;
	checkList.pResults = pResults;	
	gErrorFlag = 0;
	
	//open the polstore
	switch(piAssignedPolicy.iPolicySource)
	{

		case PS_DS_POLICY:
			dwError = IPSecOpenPolicyStore(NULL,
						               IPSEC_DIRECTORY_PROVIDER,
						               NULL,
						               &hPolicyStore
						             );
			reportErr();			
            		piAssignedPolicy.iPolicySource = PS_DS_POLICY;            		
            		dwError = IPSecGetAssignedDirectoryPolicyData(&checkList, 
            													  hPolicyStore,
            													  &pIpsecPolicyData);
            		BAIL_ON_WIN32_ERROR(dwError);            		
            		break;
			
		case PS_LOC_POLICY:
			dwError = IPSecOpenPolicyStore(NULL,
						               IPSEC_REGISTRY_PROVIDER,
						               NULL,
						               &hPolicyStore);
			
		 	//BAIL_ON_WIN32_ERROR(dwError);
		 	reportErr();
            		piAssignedPolicy.iPolicySource = PS_LOC_POLICY;            		
 			dwError = IPSecGetAssignedPolicyData(hPolicyStore,
 							      &pIpsecPolicyData
 							      ); 			
 			reportErr();
 			
 			//make sure it is the same as in registry
 			if(!IsEqualGUID(&(pIpsecPolicyData->PolicyIdentifier),&(piAssignedPolicy.policyGUID)))		
 				//reportErr(IDS_SPD_LP_ERROR);
 				//list the policy in polstore that is absent
 			
			break;
	}
 	_ASSERT(pIpsecPolicyData);

 	//check for MM policy in SPD
 	MMPolicyCheck(&checkList,hPolicyStore,pIpsecPolicyData);

 	//perform checks for all the filters in the rule
 	NFAProcess(&checkList,hPolicyStore, pIpsecPolicyData);

	if(gErrorFlag){
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, IDS_SPD_ERR_STATUS1);
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, IDS_SPD_ERR_STATUS2);
	}else{
 		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, IDS_SPD_SUCC_STATUS);	
	}//end else
	error:
		
	if(pIpsecPolicyData){
 		IPSecFreePolMem(pIpsecPolicyData);
 		pIpsecPolicyData = NULL;
		}
 	
 	//closing the polstore
 	if (hPolicyStore) {
    		(VOID) IPSecClosePolicyStore(hPolicyStore); 	 	
    		hPolicyStore = NULL;
 	}
 	if(gpFilterList){
 		Free(gpFilterList);
 		gpFilterList = NULL;
 	}
 	if(gErrorFlag)
 		return S_FALSE;
 	
 	return S_OK;

}

DWORD IPSecGetAssignedDirectoryPolicyData(CHECKLIST *pcheckList, 
												   HANDLE hPolicyStore, 
												   PIPSEC_POLICY_DATA *ppIpsecPolicyData)
//++
//Description:
//	This funtion gets assigned directory policy 
//
//Arguments:
//	IN/OUT CHECKLIST
//	IN hPolicyStore
//	IN PIPSEC_POLICY_DATA
//
//Return:
//	failure or ERROR_SUCCESS
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	DWORD dwError = ERROR_SUCCESS,
			dwNumPolicyObjects = 0,
			i = 0;
	PIPSEC_POLICY_DATA *ppIpsecTempPolicyData = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	

	dwError = IPSecEnumPolicyData(
								hPolicyStore,
								&ppIpsecTempPolicyData,
								&dwNumPolicyObjects
								);
	reportErr();
	_ASSERT(ppIpsecTempPolicyData);

	// find the applied directory policy in polstore
	for(i = 0; i <dwNumPolicyObjects; i++)
	{
		if(IsEqualGUID(&(ppIpsecTempPolicyData[i]->PolicyIdentifier),&(piAssignedPolicy.policyGUID)))
		{
			dwError = IPSecCopyPolicyData(ppIpsecTempPolicyData[i], ppIpsecPolicyData );
			reportErr();
			break;
		}
	}

	if(!(*ppIpsecPolicyData))
			reportErr();
	
	
	error:
	if(ppIpsecTempPolicyData){
		IPSecFreeMulPolicyData(ppIpsecTempPolicyData, dwNumPolicyObjects);
		ppIpsecTempPolicyData = NULL;
	}
	return dwError;
}


void MMPolicyCheck(CHECKLIST *pcheckList, 
					    HANDLE hPolicyStore, 
					    IPSEC_POLICY_DATA *pIpsecPolicyData )
//++
//Description:
//Performs Main Mode Policy Check
//
//Arguments:
//	IN/OUT checklist
//	IN hPolicyStore
//	IN pIpsecPolicyData
//
//Return:
//	none
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	DWORD dwError = ERROR_SUCCESS;
	IPSEC_ISAKMP_DATA *pIpsecISAKMPData = NULL;
	IPSEC_MM_POLICY *pMMPolicy = NULL;

	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
		
	//get the policy data from Polstore
 	dwError = IPSecGetISAKMPData(hPolicyStore,
 							      pIpsecPolicyData->ISAKMPIdentifier,
 							      &pIpsecISAKMPData);	
	reportErr();
	
 	_ASSERT(pIpsecISAKMPData);
 	
 	
 	//get MM policy from SPD
 	dwError = GetMMPolicyByID(NULL,
 						0,
 						pIpsecPolicyData->ISAKMPIdentifier,
 						&pMMPolicy,
 						NULL);
 	
 	if(dwError)
 	{
 			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 							Nd_Verbose, IDS_SPD_MM_POLICY_ABSENT);		
 			PrintISAKMPDataList(pcheckList, 
    							pIpsecISAKMPData);
    				
    			gErrorFlag = 1;
 			goto error; 		
 	}
 	_ASSERT(pMMPolicy);

	CompareMMPolicies( pcheckList, pIpsecISAKMPData, pMMPolicy);
	
 	error:
 		
	if(pMMPolicy){
 		SPDApiBufferFree((LPVOID)pMMPolicy);
 		pMMPolicy = NULL;
	}
 	if(pIpsecISAKMPData){
 		IPSecFreeISAKMPData(pIpsecISAKMPData); 	
 		pIpsecISAKMPData = NULL;
 	}
 	return ;
}		

void CompareMMPolicies(CHECKLIST *pcheckList,
						     IPSEC_ISAKMP_DATA *pIpsecISAKMPData, 
						     IPSEC_MM_POLICY *pMMPolicy)
//++
//Description:
//Compares MM Policies with the Polsore ISAKMP Data
//
//Arguments:
//	IN IPSEC_ISAKMP_DATA
//	IN IPSEC_MM_POLICY
//
//Return:
//	none
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD i = 0,
		dwErrorFlag = 0;
	PCRYPTO_BUNDLE pBundle = NULL;
	PIPSEC_MM_OFFER pOffer = NULL;

	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
		

	if(pMMPolicy->dwOfferCount != pIpsecISAKMPData->dwNumISAKMPSecurityMethods)
		dwErrorFlag = 1;
	
	pBundle = pIpsecISAKMPData->pSecurityMethods;
	pOffer = pMMPolicy->pOffers;
	
	//comparing the security methods
	for (i = 0; i < pIpsecISAKMPData->dwNumISAKMPSecurityMethods; i++) 
	{

		if(pOffer->Lifetime.uKeyExpirationKBytes != pBundle->Lifetime.KBytes)
			dwErrorFlag = 1;
    		if(pOffer->Lifetime.uKeyExpirationTime != pBundle->Lifetime.Seconds)
			dwErrorFlag = 1;
		if(pOffer->dwQuickModeLimit != pBundle->QuickModeLimit)
			dwErrorFlag = 1;
		switch(pBundle->OakleyGroup)
		{
			case DH_GROUP_1:
			case DH_GROUP_2:
				if(pOffer->dwDHGroup != pBundle->OakleyGroup)				
					dwErrorFlag = 1;
				break;
			default:
				if(pOffer->dwDHGroup != DH_GROUP_1)
					dwErrorFlag = 1;
				break;
				
		}//end switch

		switch (pBundle->EncryptionAlgorithm.AlgorithmIdentifier) 
		{
			case IPSEC_ESP_DES:
			        if(pOffer->EncryptionAlgorithm.uAlgoIdentifier != CONF_ALGO_DES)
			        	dwErrorFlag = 1;
			        break;
    			case IPSEC_ESP_DES_40:
        			if(pOffer->EncryptionAlgorithm.uAlgoIdentifier != CONF_ALGO_DES)
        				dwErrorFlag = 1;
        			break;
    			case IPSEC_ESP_3_DES:
			        if(pOffer->EncryptionAlgorithm.uAlgoIdentifier != CONF_ALGO_3_DES)
			        	dwErrorFlag = 1;
			        break;
			default:
			        if(pOffer->EncryptionAlgorithm.uAlgoIdentifier != CONF_ALGO_NONE)
			        	dwErrorFlag = 1;
			        break;
    		}//end of switch
    		 if(pOffer->HashingAlgorithm.uAlgoKeyLen != pBundle->HashAlgorithm.KeySize)
    			dwErrorFlag = 1;
   		if( pOffer->HashingAlgorithm.uAlgoRounds != pBundle->HashAlgorithm.Rounds)
		   	dwErrorFlag = 1;


    		switch(pBundle->HashAlgorithm.AlgorithmIdentifier) 
    		{
    			case IPSEC_AH_MD5:
        			if(pOffer->HashingAlgorithm.uAlgoIdentifier != AUTH_ALGO_MD5)
        				dwErrorFlag = 1;
				break;
			case IPSEC_AH_SHA:
		       	if(pOffer->HashingAlgorithm.uAlgoIdentifier != AUTH_ALGO_SHA1)
		       		dwErrorFlag = 1;
        			break;
    			default:
        			if(pOffer->HashingAlgorithm.uAlgoIdentifier != AUTH_ALGO_NONE)
        				dwErrorFlag = 1;
        			break;
    		}//end of switch  

    	}//end of for

    	if(dwErrorFlag){
    		//print the error message for MM Policy Check
    		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 							Nd_Verbose, IDS_SPD_MM_POLICY);	
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD_STORAGE_FILTER);	
		PrintISAKMPDataList(pcheckList, 
    							pIpsecISAKMPData);
    		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD);
		PrintMMPolicy(pcheckList, *pMMPolicy);
    		gErrorFlag = 1;
    	}
	return;
}
void NFAProcess(CHECKLIST *pcheckList, HANDLE hPolicyStore, IPSEC_POLICY_DATA *pIpsecPolicyData )
//++
//Description:
//Performs Check for all the rules of the active policy
//
//Arguments:
//	IN/OUT checklist
//	IN hPolicyStore
//	IN pIpsecPolicyData
//
//Return:
// 	none
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	POLICYPARAMS policyParams;
	DWORD dwError = ERROR_SUCCESS,
			i = 0,
			dwNumNFAObjects = 0,
			dwFlag = 0;
	PIPSEC_NFA_DATA *ppIpsecNFAData = NULL;

	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
		

	//get all the rules from SPD for the assigned policy
 	dwError = IPSecEnumNFAData(hPolicyStore,
                            			pIpsecPolicyData->PolicyIdentifier,
                            			&ppIpsecNFAData,
                            			&dwNumNFAObjects
							);
	reportErr();
    	
    	_ASSERT(ppIpsecNFAData);

    	//initialize the filter list
    	gpFilterList = NULL;
    	dwNumofFilters = 0;
  
 	for(i = 0; i <dwNumNFAObjects; i++ )
 	{
 		//initialize the filterParams
 		policyParams.hPolicyStore = hPolicyStore;
    		policyParams.dwFlags= 0;
 			
 		//check if the rule is active
 		if(!ppIpsecNFAData[i]->dwActiveFlag)
 			continue;
		
 		DefaultRuleCheck(ppIpsecNFAData[i], &policyParams);
 		
		//if rule is default, no filters present
		//check for default auth methods and QM Policies
		dwFlag = policyParams.dwFlags & PROCESS_NONE;
 		if(PROCESS_NONE == dwFlag){
 			MMAuthCheck(pcheckList,
 						   ppIpsecNFAData[i],
 						   ppIpsecNFAData[i]->NFAIdentifier, 
 						   &policyParams);
 			QMPolicyCheck(pcheckList, 
						      ppIpsecNFAData[i], 
						      ppIpsecNFAData[i]->NegPolIdentifier, 
						      &policyParams); 			
 			continue;
 		}
		
 		switch(ppIpsecNFAData[i]->dwTunnelFlags)
 		{
 			case 0:
 				dwError = TransportFilterCheck(pcheckList, &policyParams, ppIpsecNFAData[i]);
 				break;
 			case 1: 				
 				dwError = TunnelFilterCheck(pcheckList, &policyParams, ppIpsecNFAData[i]);
 				break;	
 				
 		}//end  switch								
 	}//end for
 		
 	error:
 	if(ppIpsecNFAData){
 		IPSecFreeMulNFAData(ppIpsecNFAData, dwNumNFAObjects);
 		ppIpsecNFAData = NULL;
 	}
	return ;
		
}
void MMAuthCheck(CHECKLIST *pcheckList,  
					PIPSEC_NFA_DATA pIpsecNFAData, 
					GUID gMMAuthID,
					PPOLICYPARAMS ppolicyParams )
//++
//Description:
//Performs Main Mode Authentication Check
//
//Arguments:
//	IN/OUT checklist
//	IN PIPSEC_NFA_DATA
//	IN gMMAuthID
//	IN/OUT PPOLICYPARAMS
//
//Return:
//	none
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	PIPSEC_AUTH_METHOD pAuthMethod = NULL,
						*ppTempAuthMethods = NULL;
	PMM_AUTH_METHODS pMMAuthMethods = NULL;
	PINT_MM_AUTH_METHODS pIntMMAuthMethods = NULL;
	PINT_IPSEC_MM_AUTH_INFO pTempAuthInfo = NULL;
	PBYTE pEncodedName = NULL;
    	DWORD dwError = ERROR_SUCCESS,
		     dwAuthMethodCount = 0,
		     dwFlag = 0,
		     i = 0,
		     dwEncodedLength;

    	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	

    	//initialize variables
    	pEncodedName = (PBYTE)malloc(sizeof(BYTE));
    	if(!pEncodedName){
    		//reportErr(IDS_SPD_MEM_ERROR);
    		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 							Nd_Verbose, IDS_SPD_MEM_ERROR);
    		gErrorFlag = 1;
    		goto error;
    	}    	

    	//get MM Auth methods from SPD
	dwError = GetMMAuthMethods(NULL,
							   0,
							   gMMAuthID,
							   &pMMAuthMethods,
							   NULL);
    	if(dwError)
 	{
 		for (i=0;i<(pIpsecNFAData->dwAuthMethodCount);i++)
		{
			if(pIpsecNFAData->ppAuthMethods[i]){
				PrintAuthMethodsList( pcheckList, 
    							  pAuthMethod);
			}
		}
    		gErrorFlag = 1;
    		goto error;
    	}//end of dwError
    	
	_ASSERT(pMMAuthMethods);

	//convert the ext auth structure to int auth structure
	if ((dwError =  ConvertExtMMAuthToInt(pMMAuthMethods, &pIntMMAuthMethods)) != ERROR_SUCCESS)
		reportErr();
	
	//check for default rule
	dwFlag = ppolicyParams->dwFlags & PROCESS_NONE;
	if(PROCESS_NONE == dwFlag){
		dwFlag = pIntMMAuthMethods->dwFlags & IPSEC_MM_AUTH_DEFAULT_AUTH;
		if(IPSEC_MM_AUTH_DEFAULT_AUTH != dwFlag )
			dwError = -1;
	}else{
		if(pIntMMAuthMethods->dwFlags)
			dwError = -1;
	}//end else

	//check for auth method count
	if(pIpsecNFAData->dwAuthMethodCount != pIntMMAuthMethods->dwNumAuthInfos)
		dwError = -1;

	ppTempAuthMethods = pIpsecNFAData->ppAuthMethods;
	pTempAuthInfo = pIntMMAuthMethods->pAuthenticationInfo;

	for (i = 0; i < pIntMMAuthMethods->dwNumAuthInfos; i++) {

       	pAuthMethod = *(ppTempAuthMethods + i);
       	
       	if(pTempAuthInfo->AuthMethod != (MM_AUTH_ENUM) pAuthMethod->dwAuthType)
       		dwError = -1;

        	switch((MM_AUTH_ENUM) pAuthMethod->dwAuthType) {
	       	case IKE_SSPI:
            			if(pTempAuthInfo->dwAuthInfoSize)
            				dwError = -1;
            			if(pTempAuthInfo->pAuthInfo)
            				dwError = -1;
            			break;

        		case IKE_RSA_SIGNATURE:
            			if (pAuthMethod->dwAltAuthLen && pAuthMethod->pAltAuthMethod) {
                			if(pTempAuthInfo->dwAuthInfoSize != pAuthMethod->dwAltAuthLen)
                				dwError = -1;        
                    			if(memcmp(pTempAuthInfo->pAuthInfo,pAuthMethod->pAltAuthMethod,pAuthMethod->dwAuthLen))
                    				dwError = -1;
            			}else {
            				if (!CertStrToName(X509_ASN_ENCODING,
             								  (LPCSTR)pAuthMethod->pszAuthMethod,
             								  CERT_X500_NAME_STR,
             								  NULL,
             								  NULL,
             								  &dwEncodedLength,
             								  NULL)) {
        					reportErr();
            				}//end if
            				if(dwEncodedLength != pTempAuthInfo->dwAuthInfoSize)
            					dwError = -1;
            				if (!CertStrToName(X509_ASN_ENCODING,
            								  (LPCSTR)pAuthMethod->pszAuthMethod,
            								  CERT_X500_NAME_STR,
            								  NULL,
            								  pEncodedName,
            								  &dwEncodedLength,
            								  NULL)) {
            					reportErr();        					
        				}//end if   
        				if(memcmp(pEncodedName, pTempAuthInfo->pAuthInfo,dwEncodedLength))
        					dwError = -1;
               		}//end else
            			break;

        		default:
            			if(pTempAuthInfo->dwAuthInfoSize != ((pAuthMethod->dwAuthLen)*sizeof(WCHAR)))
            				dwError = -1;
            			if(memcmp(pTempAuthInfo->pAuthInfo, 
            					    (LPBYTE)pAuthMethod->pszAuthMethod, 
            					    (pAuthMethod->dwAuthLen)*sizeof(WCHAR)))
            					   dwError = -1;
            			break;

        	}//end switch
        	pTempAuthInfo++;
    	}//end for	

    	if(dwError){
    		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 							Nd_Verbose, IDS_SPD_AUTH_ERROR);
    		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 							Nd_Verbose, IDS_SPD_STORAGE_FILTER);
    		for (i=0;i<(pIpsecNFAData->dwAuthMethodCount);i++)
		{
			if(pIpsecNFAData->ppAuthMethods[i]){
				PrintAuthMethodsList( pcheckList, pAuthMethod);
			}
		}//end of for
    		gErrorFlag = 1;
		//print Error
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 							Nd_Verbose, IDS_SPD);
		//print from SPD
    		if((PrintMMAuth(pcheckList, pIntMMAuthMethods)) ==S_FALSE)
    			reportErr();

		gErrorFlag = 1;
    	}
	
	error:
	if(pMMAuthMethods){
		SPDApiBufferFree((LPVOID)pMMAuthMethods);
		pMMAuthMethods = NULL;
	}
	if(pIntMMAuthMethods){
		FreeIntMMAuthMethods(pIntMMAuthMethods);
		pIntMMAuthMethods = NULL;
	}
	if(pEncodedName){
		Free(pEncodedName);
		pEncodedName = NULL;
	}
	return ;
}

void DefaultRuleCheck( PIPSEC_NFA_DATA pIpsecNFAData, 
						  PPOLICYPARAMS ppolicyParams)
 //++
//Description:
//Performs Check for presence of Default Rule and permit/block filters
//
//Arguments:
//	IN PIPSEC_NFA_DATA
//	IN/OUT PPOLICYPARAMS
//
//Return:
//	none
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
						  
{
	DWORD dwError = ERROR_SUCCESS;			
	IPSEC_NEGPOL_DATA *pIpsecNegPolData = NULL;

	//get the negpolicy from Polstore
	dwError = IPSecGetNegPolData(ppolicyParams->hPolicyStore,
						pIpsecNFAData->NegPolIdentifier,//negPolIndentifier
						&pIpsecNegPolData);
	if(dwError)
 	{
 		_tprintf(TEXT("Error: %d NegPolicy absent in Polstore\n"), dwError);
 		goto error;
 	}//end dwError
	_ASSERT(pIpsecNegPolData);

	if(IsEqualGUID(&(GUID_NEGOTIATION_ACTION_NO_IPSEC), 
 				&(pIpsecNegPolData->NegPolAction)) ||
 				IsEqualGUID(&(pIpsecNegPolData->NegPolAction),
 				&(GUID_NEGOTIATION_ACTION_BLOCK))){
 		ppolicyParams->dwFlags |= PROCESS_QM_FILTER;
	}else if(IsEqualGUID(&(GUID_NEGOTIATION_TYPE_DEFAULT),
					    &(pIpsecNegPolData->NegPolType)))
		ppolicyParams->dwFlags |= PROCESS_NONE;
	else
		ppolicyParams->dwFlags |= PROCESS_BOTH;

	//NegPolAction requred while checking for Filter Action (block/permit)
	ppolicyParams->gNegPolAction = pIpsecNegPolData->NegPolAction;

	error:
	if(pIpsecNegPolData){
	 	IPSecFreeNegPolData(pIpsecNegPolData);
	 	pIpsecNegPolData = NULL;
	}	
	return;
}


void QMPolicyCheck(CHECKLIST *pcheckList, 
						  PIPSEC_NFA_DATA pIpsecNFAData, 
						  GUID gPolicyID,
						  PPOLICYPARAMS ppolicyParams)
//++
//Description:
//Performs Quick Mode Policy Check
//
//Arguments:
//	IN/OUT checklist
//	IN pIpsecNFAData
//	IN gPolicyID
//	OUT ppolicyParams
//
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwError = ERROR_SUCCESS;
	IPSEC_QM_POLICY *pQMPolicy = NULL;
	IPSEC_NEGPOL_DATA *pIpsecNegPolData = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
		

	//get the negpolicy from Polstore
	dwError = IPSecGetNegPolData(ppolicyParams->hPolicyStore,
						pIpsecNFAData->NegPolIdentifier,//negPolIndentifier
						&pIpsecNegPolData);
	reportErr();
	_ASSERT(pIpsecNegPolData);
	
	dwError = GetQMPolicyByID(NULL,
 						0,
 						gPolicyID,
 						0,
 						&pQMPolicy,
 						NULL);	
	if(dwError)
 	{		
 		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 						Nd_Verbose, IDS_SPD_NEG_POLICY_ABSENT);		
 		PrintNegPolDataList( pcheckList,
							pIpsecNegPolData);
 		gErrorFlag = 1; 		
 		goto error;
 	}//end of if dwError*/
	_ASSERT(pQMPolicy);

	if(CompareQMPolicies(pcheckList, 
					     ppolicyParams,
				  	     pIpsecNFAData->dwTunnelFlags,
				   	     pIpsecNegPolData, 
				   	     pQMPolicy))
	{
		//report error
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 							Nd_Verbose, IDS_SPD_NEG_POLICY);	
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD_STORAGE_FILTER);	
	
 			
		PrintNegPolDataList( pcheckList,
							pIpsecNegPolData);
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD);	
		PrintFilterAction(pcheckList, *pQMPolicy);	
		gErrorFlag = 1;
		
	}
 			
	error:
	if(pIpsecNegPolData){
	 	IPSecFreeNegPolData(pIpsecNegPolData);
	 	pIpsecNegPolData = NULL;
	}
	if(pQMPolicy){
	 	SPDApiBufferFree((LPVOID)pQMPolicy);
	 	pQMPolicy= NULL;
	}
	return;
}

DWORD CompareQMPolicies(CHECKLIST *pcheckList,
						     PPOLICYPARAMS ppolicyParams,
						     DWORD dwTunnelFlag, 							    
						     IPSEC_NEGPOL_DATA *pIpsecNegPolData, 
						     IPSEC_QM_POLICY *pQMPolicy)
//++
//Description:
//Compares QM Policies with the Polsore NegPolicyData
//
//Arguments:
//	IN/OUT CHECKLIST
//	IN PPOLICYPARAMS
//	IN dwTunnelFlag
//	IN IPSEC_NEGPOL_DATA
//	IN IPSEC_QM_POLICY
//
//Return:
// success or failure code
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	DWORD dwFlag = 0,
		i = 0,
		dwOfferCount = 0,
		dwTempOfferCount = 0;
	PIPSEC_SECURITY_METHOD pIpsecSecurityMethods = NULL,
		pTempMethod = NULL;
	BOOL bAllowsSoft = FALSE;
	PIPSEC_QM_OFFER pTempOffer = NULL;

	if (pIpsecNegPolData->dwSecurityMethodCount > IPSEC_MAX_QM_OFFERS) {
       	dwTempOfferCount = IPSEC_MAX_QM_OFFERS;
    	}
   	else {
       	dwTempOfferCount = pIpsecNegPolData->dwSecurityMethodCount;
    	}

    	pTempMethod = pIpsecNegPolData->pIpsecSecurityMethods;
 
    	for (i = 0; i < dwTempOfferCount; i++) {
        if (pTempMethod->Count == 0) {
            bAllowsSoft = TRUE;
        }//end if
        else {
            dwOfferCount++;
        }//end else
        pTempMethod++;
    	}//end for

	//comparing offers
    	pTempOffer = pQMPolicy->pOffers;
    	pTempMethod = pIpsecNegPolData->pIpsecSecurityMethods;
    	i = 0;

    	while (i < dwOfferCount) {

        if (pTempMethod->Count) {

            if(CompareQMOffers(pTempMethod, pTempOffer))
            	return -1;
            i++;
            pTempOffer++;
        }
        pTempMethod++;

    }//end of while

    if(dwOfferCount != pQMPolicy->dwOfferCount)
    	return -1;
 
	//
    	if (!memcmp(&(pIpsecNegPolData->NegPolType), &(GUID_NEGOTIATION_TYPE_DEFAULT), sizeof(GUID))){
    		dwFlag = pQMPolicy->dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY;
        	if(dwFlag != IPSEC_QM_POLICY_DEFAULT_POLICY)
        		return -1;
        }

    	if (dwTunnelFlag) {
    		dwFlag = pQMPolicy->dwFlags & IPSEC_QM_POLICY_TUNNEL_MODE;
       	 if(dwFlag != IPSEC_QM_POLICY_TUNNEL_MODE)
        		return -1;
    	}
	dwFlag =  ppolicyParams->dwFlags & ALLOW_SOFT;
    	if (ALLOW_SOFT == dwFlag) {    	
    		dwFlag = pQMPolicy->dwFlags & IPSEC_QM_POLICY_ALLOW_SOFT;
        	if(dwFlag != IPSEC_QM_POLICY_ALLOW_SOFT)
        		return -1;        	
    	}//end if ALLOW_SOFT

    if(0 != pQMPolicy->dwReserved)
    	return -1;

	return 0;
}

DWORD CompareQMOffers(PIPSEC_SECURITY_METHOD pMethod,  PIPSEC_QM_OFFER  pOffer)
//++
//Description:
//Compares QM offers in SPD Polsore 
//
//Arguments:
//	IN PIPSEC_SECURITY_METHOD
//	IN PIPSEC_QM_OFFER
//
//Return:
//	success or failure
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	DWORD i = 0,
    		j = 0,
    		k = 0;
	
	if(pOffer->Lifetime.uKeyExpirationKBytes != pMethod->Lifetime.KeyExpirationBytes)
		return -1;
    	if(pOffer->Lifetime.uKeyExpirationTime != pMethod->Lifetime.KeyExpirationTime)
    		return -1;
    	if(pOffer->dwFlags != pMethod->Flags)
    		return -1;
    	if(pOffer->bPFSRequired != pMethod->PfsQMRequired)
    		return -1;

    	if (pMethod->PfsQMRequired) {
       	if(PFS_GROUP_MM != pOffer->dwPFSGroup )
       		return -1;
       }
    	else {
        if(PFS_GROUP_NONE != pOffer->dwPFSGroup)
        	return -1;
    	}

    	i = 0;

    	for (j = 0; (j < pMethod->Count) && (i < QM_MAX_ALGOS) ; j++) {
    		switch (pMethod->Algos[j].operation) {
       		case Auth:
            			switch (pMethod->Algos[j].algoIdentifier) {
            				case IPSEC_AH_MD5:
                				if(AUTH_ALGO_MD5 != pOffer->Algos[i].uAlgoIdentifier)
                					return -1;
                				break;
            				case IPSEC_AH_SHA:
                				if(AUTH_ALGO_SHA1 != pOffer->Algos[i].uAlgoIdentifier)
                					return -1;
                				break;
            				default:
                				if(AUTH_ALGO_NONE != pOffer->Algos[i].uAlgoIdentifier)
                					return -1;
               				break;
            			}//end switch(pMethod->Algos[j].algoIdentifier)

            			if(HMAC_AUTH_ALGO_NONE != pOffer->Algos[i].uSecAlgoIdentifier)
            				return -1;
            			if(AUTHENTICATION != pOffer->Algos[i].Operation)
            				return -1;
            			if(pOffer->Algos[i].uAlgoKeyLen != pMethod->Algos[j].algoKeylen)
            				return -1;
            			if(pOffer->Algos[i].uAlgoRounds != pMethod->Algos[j].algoRounds)
            				return -1;
            			if(0 != pOffer->Algos[i].uSecAlgoKeyLen)
            				return -1;
            			if(0 != pOffer->Algos[i].uSecAlgoRounds)
            				return -1;
            			if(0 != pOffer->Algos[i].MySpi)
            				return -1;
            			if(0 != pOffer->Algos[i].PeerSpi )
            				return -1;
            			i++;
            			break;
        		case Encrypt:
            			switch (pMethod->Algos[j].algoIdentifier) {
            				case IPSEC_ESP_DES:
                				if(CONF_ALGO_DES != pOffer->Algos[i].uAlgoIdentifier)
                					return -1;
                				break;
            				case IPSEC_ESP_DES_40:
                				if(CONF_ALGO_DES != pOffer->Algos[i].uAlgoIdentifier)
                					return -1;
                				break;
            				case IPSEC_ESP_3_DES:
                				if(CONF_ALGO_3_DES != pOffer->Algos[i].uAlgoIdentifier)
                					return -1;
                				break;
            				default:
               			 	if(CONF_ALGO_NONE != pOffer->Algos[i].uAlgoIdentifier)
               			 		return -1;
               			 	break;
            			}//end switch (pMethod->Algos[j].algoIdentifier) 

            			switch (pMethod->Algos[j].secondaryAlgoIdentifier) {
            				case IPSEC_AH_MD5:
                				if(HMAC_AUTH_ALGO_MD5 != pOffer->Algos[i].uSecAlgoIdentifier)
                					return -1;
                				break;
            				case IPSEC_AH_SHA:
                				if(HMAC_AUTH_ALGO_SHA1 != pOffer->Algos[i].uSecAlgoIdentifier)
                					return -1;
                				break;
            				default:
                				if(HMAC_AUTH_ALGO_NONE != pOffer->Algos[i].uSecAlgoIdentifier)
                					return -1;
                				break;
            			}//end switch (pMethod->Algos[j].secondaryAlgoIdentifier)

            			if(ENCRYPTION != pOffer->Algos[i].Operation)
            				return -1;
            			if(pOffer->Algos[i].uAlgoKeyLen != pMethod->Algos[j].algoKeylen)
            				return -1;
            			if(pOffer->Algos[i].uAlgoRounds != pMethod->Algos[j].algoRounds)
            				return -1;
            			if(0 != pOffer->Algos[i].uSecAlgoKeyLen)
            				return -1;
            			if(0 != pOffer->Algos[i].uSecAlgoRounds)
            				return -1;
            			if(0 != pOffer->Algos[i].MySpi)
            				return -1;
            			if(0 != pOffer->Algos[i].PeerSpi)
            				return -1;
            			i++;
           			break;

        		case None:
        		case Compress:
        		default:
            			break;
        	}//end switch (pMethod->Algos[j].operation)
    	}//end for

    	if(pOffer->dwNumAlgos != i)
    		return -1;
    	    	
	return 0;
}

DWORD TransportFilterCheck(CHECKLIST* pcheckList, 
							     POLICYPARAMS *ppolicyParams, 
							     PIPSEC_NFA_DATA pIpsecNFAData)
//++
//Description:
//Performs Transport Mode Filter Check
//
//Arguments:
//	IN/OUT checklist
//	IN/OUT POLICYPARAMS
//	IN PIPSEC_NFA_DATA
//
//Returns:
//	Success or Failure 
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--		
{
	DWORD dwError = ERROR_SUCCESS,
			dwNumFilters = 0,
			dwResumeHandle = 0,
			i = 0,
			dwFlag = 0;
	GUID gGenericFilterID = {0};
	TRANSPORT_FILTER *pTransportFilters = NULL;
	IPSEC_FILTER_DATA *pIpsecFilterData = NULL;
	IPSEC_FILTER_SPEC *pIpsecFilterSpec = NULL;
	FILTERLIST *pTempList = NULL;

	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
		

	//get the filter from the polstore
	dwError = IPSecGetFilterData(
							ppolicyParams->hPolicyStore,
							pIpsecNFAData->FilterIdentifier,
							&pIpsecFilterData);
	reportErr();	
	_ASSERT(pIpsecFilterData);
	
	//process each filter from filter data
	for(i = 0; i < pIpsecFilterData->dwNumFilterSpecs; i ++)
	{
			pIpsecFilterSpec = pIpsecFilterData->ppFilterSpecs[i];
			_ASSERT(pIpsecFilterSpec);
			
			dwResumeHandle = 0;
			while(1)
			{

				//match transport filter from spd
				dwError = EnumTransportFilters(
									NULL,
									0,
									NULL,
									ENUM_GENERIC_FILTERS,
 									gGenericFilterID,
	 								0, //max limit set by spd server
 									&pTransportFilters, 
 									&dwNumFilters,
                     		   				&dwResumeHandle,
 									NULL
 								 	);
				if(dwError)
 				{
 					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 									Nd_Verbose, IDS_SPD_FILTER_ABSENT);		
					PrintFilterSpecList(pcheckList,
									  pIpsecFilterSpec,
									  pIpsecNFAData);
					gErrorFlag = 1;
 					goto error;
 					
	 			}//end if
				_ASSERT(pTransportFilters);
	
				Match(pIpsecFilterSpec->FilterSpecGUID, pTransportFilters, dwNumFilters);
				if(dwNumFilters != -1)
				{					
					if(dwNumofFilters){
					dwError = CheckFilterList(pIpsecFilterSpec->Filter);
					
					if(-1 != dwError)
						break;
					}
					
					//add filter to the list
					pTempList = GetNode(pcheckList,pIpsecFilterSpec->Filter);
					AddNodeToList(pTempList);
															
					if(CompareTransportFilter(pcheckList,
										     ppolicyParams,
										     pIpsecNFAData,
										     pIpsecFilterSpec, 
										     &(pTransportFilters[dwNumFilters])))
					{
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD_FILTER);
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD_STORAGE_FILTER);	
	
						PrintFilterSpecList(pcheckList,
										  pIpsecFilterSpec,
										  pIpsecNFAData);
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD);	
						PrintTxFilter( pcheckList,
									  pTransportFilters[dwNumFilters]);	
						gErrorFlag = 1;
					}

					dwFlag = ppolicyParams->dwFlags & PROCESS_BOTH;
 					if(PROCESS_BOTH == dwFlag)
 						MMFilterCheck(pcheckList, 
 								    	ppolicyParams, 
 								    	pIpsecNFAData,
 								    	pIpsecFilterSpec);
								
					break;
				}
				if(pTransportFilters){
					SPDApiBufferFree((LPVOID)pTransportFilters);	
					pTransportFilters = NULL;
				}
				dwNumFilters = 0;
			}//end while
			if(pTransportFilters){
					SPDApiBufferFree((LPVOID)pTransportFilters);	
					pTransportFilters = NULL;
			}
			dwNumFilters = 0;
	}//end for


	

	error:
	if(pIpsecFilterData){
		IPSecFreeFilterData(pIpsecFilterData);	
		pIpsecFilterData = NULL;
	}
	if(pTransportFilters){
		SPDApiBufferFree((LPVOID)pTransportFilters);
		pTransportFilters = NULL;
	}
	
	return dwError;
}

DWORD CompareTransportFilter(CHECKLIST* pcheckList, 
							POLICYPARAMS *ppolicyParams,
							PIPSEC_NFA_DATA pIpsecNFAData,
							IPSEC_FILTER_SPEC *pFilterSpec, 
					 	 	TRANSPORT_FILTER *pTxFilter)
//++
//Description:
//Performs Transport Mode Filter Check
//
//Arguments:
//	IN/OUT checklist
//	IN/OUT POLICYPARAMS
//	IN PIPSEC_NFA_DATA
//	IN IPSEC_FILTER_SPEC
//	IN TRANSPORT_FILTER
//
//Return:
//	failure or success
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--		
{
	DWORD dwFlag = 0,			
		dwError = ERROR_SUCCESS;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
		
	

	if(IPSEC_PROTOCOL_V4 != pTxFilter->IpVersion)
		return -1;
	
	//interface type
	if(ComparePAInterfaceType(pcheckList, pIpsecNFAData->dwInterfaceType, pTxFilter->InterfaceType))
		return -1;
	if(pTxFilter->bCreateMirror != (BOOL) pFilterSpec->dwMirrorFlag)
		return -1;
    	
    dwFlag = ComparePAAddress(pcheckList, pFilterSpec->Filter.SrcMask, pFilterSpec->Filter.SrcAddr, pTxFilter->SrcAddr);    	

    //taking care of filters to special servers
    if(1 == dwFlag)
   {
   	if (pFilterSpec->Filter.ExType) {
       	if (pFilterSpec->Filter.ExType & EXT_DEST) {
          		if(pTxFilter->DesAddr.AddrType != 
          		   ExTypeToAddrType(pFilterSpec->Filter.ExType))
          			return -1;
        	} else {
          		if(pTxFilter->SrcAddr.AddrType != 
          		    ExTypeToAddrType(pFilterSpec->Filter.ExType))
              		return -1;
        	}
    	}//end if
   }else if(-1 == dwFlag){
   	return -1;
   }


   
    dwFlag = ComparePAAddress(pcheckList, pFilterSpec->Filter.DestMask,pFilterSpec->Filter.DestAddr, pTxFilter->DesAddr);

    if(1 == dwFlag)
   {
   	if (pFilterSpec->Filter.ExType) {
       	if (pFilterSpec->Filter.ExType & EXT_DEST) {
          		if(pTxFilter->DesAddr.AddrType != 
          		   ExTypeToAddrType(pFilterSpec->Filter.ExType))
          			return -1;
        	} else {
          		if(pTxFilter->SrcAddr.AddrType != 
          		    ExTypeToAddrType(pFilterSpec->Filter.ExType))
              		return -1;
        	}
    	}//end if
   }else if(-1 == dwFlag){
   	return -1;
   }


    if(pTxFilter->Protocol.ProtocolType != PROTOCOL_UNIQUE)
    	return -1;
    if(pTxFilter->Protocol.dwProtocol != pFilterSpec->Filter.Protocol)
    	return -1;

    if(pTxFilter->SrcPort.PortType != PORT_UNIQUE)
    	return -1;
    if(pTxFilter->SrcPort.wPort != pFilterSpec->Filter.SrcPort)
    	return -1;

    if(pTxFilter->DesPort.PortType != PORT_UNIQUE)
    	return -1;
    if(pTxFilter->DesPort.wPort != pFilterSpec->Filter.DestPort)
    	return -1;
    if(pTxFilter->bCreateMirror != (BOOL) pFilterSpec->dwMirrorFlag)
			return -1;

    if(CompareFilterActions(pcheckList,
    				ppolicyParams,
    			      pTxFilter->InboundFilterAction, 
    			      pTxFilter->OutboundFilterAction))
    	return -1;
	
	//for block/permit the QM Policy is absent
	dwFlag = ppolicyParams->dwFlags & PROCESS_QM_FILTER;
 	if(PROCESS_QM_FILTER != dwFlag)	
		QMPolicyCheck(pcheckList, 
						      pIpsecNFAData, 
						      pTxFilter->gPolicyID, 
						      ppolicyParams);
	
	return 0;
}
DWORD CheckFilterList(IPSEC_FILTER Filter)
//++
//Description:
//Checks the filter against the filterList
//
//Arguments:
//	IN IPSEC_FILTER
//
//Return Argument:
//	success or failure
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--		
{
	DWORD iter = 0,
		iReturn = 0;
	FILTERLIST *pTempFilter = NULL;
	
	iter = dwNumofFilters;
	pTempFilter = gpFilterList;

	
	while(iter--){
		iReturn = CompareAddress(pTempFilter->ipsecFilter, Filter);
		if(-1 != iReturn);
			return iReturn; //return the location of filter in the list
		pTempFilter = pTempFilter->next;		
	}//end for loop

	return iter;	//-1 if filter not present in the list
}

DWORD CompareAddress(IPSEC_FILTER ListFilter, IPSEC_FILTER Filter)
{
	if(memcmp(&(ListFilter.SrcAddr), &(Filter.SrcAddr), sizeof(IPAddr)))
		return -1;
	if(memcmp(&(ListFilter.SrcMask), &(Filter.SrcMask), sizeof(IPMask)))
		return -1;
	if(memcmp(&(ListFilter.DestAddr),&( Filter.DestAddr), sizeof(IPAddr)))
		return -1;
	if(memcmp(&(ListFilter.DestMask), &(Filter.DestMask), sizeof(IPMask)))
		return -1;
	if(memcmp(&(ListFilter.TunnelAddr), &(Filter.TunnelAddr), sizeof(IPAddr)))
		return -1;
	if(ListFilter.Protocol != Filter.Protocol)
		return -1;
	if(ListFilter.SrcPort != Filter.SrcPort)
		return -1;
	if(ListFilter.DestPort != Filter.DestPort)
		return -1;
	if(ListFilter.TunnelFilter != Filter.TunnelFilter)
		return -1;
            
      return 0;    
}

FILTERLIST * GetNode(CHECKLIST* pcheckList, IPSEC_FILTER Filter)
//++
//Description:
//Gets node after initializing all its fields
//
//Arguments:
//	IN IPSEC_FILTER
//
//Return:
//	FILTERLIST
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{	
	FILTERLIST *pTempList = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	

	pTempList = (PFILTERLIST)malloc(sizeof(FILTERLIST));
	if(!pTempList){
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_SPD_MEM_ERROR );
		goto error;
	}
		
	
	memcpy(&(pTempList->ipsecFilter.SrcAddr), &(Filter.SrcAddr), sizeof(IPAddr));
	memcpy(&(pTempList->ipsecFilter.SrcMask), &(Filter.SrcMask), sizeof(IPMask));
	memcpy(&(pTempList->ipsecFilter.DestAddr), &(Filter.DestAddr), sizeof(IPAddr));
	memcpy(&(pTempList->ipsecFilter.DestMask), &(Filter.DestMask), sizeof(IPMask));
	memcpy(&(pTempList->ipsecFilter.TunnelAddr), &(Filter.TunnelAddr), sizeof(IPAddr));
	pTempList->ipsecFilter.Protocol = Filter.Protocol;
	pTempList->ipsecFilter.SrcPort = Filter.SrcPort;
	pTempList->ipsecFilter.DestPort = Filter.DestPort;
	pTempList->ipsecFilter.TunnelFilter = Filter.TunnelFilter;

	pTempList->next = NULL;

	error:
	return pTempList;
}

void AddNodeToList(FILTERLIST *pList)
//++
//Description:
//	Adds node to a list
//
//Arguments:
//	IN IPSEC_FILTER
//
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	FILTERLIST *pTempList = NULL;

	pTempList = gpFilterList;

	if(!gpFilterList){
		gpFilterList = pList;
		dwNumofFilters ++;
		return;
	}

	while(pTempList->next){
		pTempList = pTempList->next;
	}
	pTempList->next = pList;
	dwNumofFilters ++;

	return;
}
DWORD TunnelFilterCheck(CHECKLIST* pcheckList, 
							POLICYPARAMS *ppolicyParams, 
							PIPSEC_NFA_DATA pIpsecNFAData)
//++
//Description:
//Performs Tunnel Mode Filter Check
//
//Arguments:
//	IN/OUT checklist
//	IN POLICYPARAMS
//	IN PIPSEC_NFA_DATA
//
//Returns:
//	Success or Failure 
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwError = ERROR_SUCCESS,
			dwNumFilters = 0,
			dwResumeHandle = 0,
			i = 0,
			dwFlag = 0;
	GUID gGenericFilterID = {0};
	TUNNEL_FILTER *pTunnelFilters = NULL;
	IPSEC_FILTER_DATA *pIpsecFilterData = NULL;
	IPSEC_FILTER_SPEC *pIpsecFilterSpec = NULL;
	FILTERLIST *pTempList = NULL;

	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
		

	//get the filter from the polstore
	dwError = IPSecGetFilterData(
							ppolicyParams->hPolicyStore,
							pIpsecNFAData->FilterIdentifier,
							&pIpsecFilterData);	
	reportErr();
	_ASSERT(pIpsecFilterData);
	
	//process each filter from filter data
	for(i = 0; i < pIpsecFilterData->dwNumFilterSpecs; i ++)
	{
			pIpsecFilterSpec = pIpsecFilterData->ppFilterSpecs[i];
			_ASSERT(pIpsecFilterSpec);
			dwResumeHandle = 0;
			while(1)
			{

				//match transport filter from spd
				dwError = EnumTunnelFilters(
									NULL,
									0,
									NULL,
									ENUM_GENERIC_FILTERS,
 									gGenericFilterID,
	 								0, //max limit set by spd server
 									&pTunnelFilters, 
 									&dwNumFilters,
                     		   				&dwResumeHandle,
 									NULL
 								 	);
				if(dwError)
 				{
 					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 									Nd_Verbose, IDS_SPD_FILTER_ABSENT);		
					PrintFilterSpecList(pcheckList,
									  pIpsecFilterSpec,
									  pIpsecNFAData);
					gErrorFlag = 1;
 					goto error; 					
	 			}//end if
				_ASSERT(pTunnelFilters);
	
				Match(pIpsecFilterSpec->FilterSpecGUID, pTunnelFilters, dwNumFilters);
				if(dwNumFilters != -1)
				{					
					if(dwNumofFilters){
					dwError = CheckFilterList(pIpsecFilterSpec->Filter);
					
					if(-1 != dwError)
						break;
					}
					
					//add filter to the list
					pTempList = GetNode(pcheckList, pIpsecFilterSpec->Filter);
					AddNodeToList(pTempList);
															
					if(CompareTunnelFilter(pcheckList,
										     ppolicyParams,
										     pIpsecNFAData,
										     pIpsecFilterSpec, 
										     &(pTunnelFilters[dwNumFilters])))
					{
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD_FILTER);
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD_STORAGE_FILTER);	
	
						PrintFilterSpecList(pcheckList,
										  pIpsecFilterSpec,
										  pIpsecNFAData);
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD);	
						PrintTnFilter(pcheckList, pTunnelFilters[dwNumFilters]);
						//call function to print storage transport filter
						 
						gErrorFlag = 1;
					}

					dwFlag = ppolicyParams->dwFlags & PROCESS_BOTH;
 					if(PROCESS_BOTH == dwFlag)
 						MMFilterCheck(pcheckList, 
 								    	ppolicyParams, 
 								    	pIpsecNFAData,
 								    	pIpsecFilterSpec);
								
					break;
				}//end if dwNumFilters
				if(pTunnelFilters){
					SPDApiBufferFree((LPVOID)pTunnelFilters);	
					pTunnelFilters = NULL;
				}
				dwNumFilters = 0;
			}//end while
			if(pTunnelFilters){
				SPDApiBufferFree((LPVOID)pTunnelFilters);	
				pTunnelFilters = NULL;
			}
			dwNumFilters = 0;
	}//end for



	error:
		
	if(pTunnelFilters){
		SPDApiBufferFree((LPVOID)pTunnelFilters);
		pTunnelFilters = NULL;
	}	
	if(pIpsecFilterData){
		IPSecFreeFilterData(pIpsecFilterData);		
		pIpsecFilterData = NULL;
	}
	return dwError;

}

DWORD CompareTunnelFilter(CHECKLIST* pcheckList, 
							POLICYPARAMS *ppolicyParams,
							PIPSEC_NFA_DATA pIpsecNFAData,
							IPSEC_FILTER_SPEC *pFilterSpec, 
					 	 	TUNNEL_FILTER *pTnFilter)
//++
//Description:
//	Performs Tunnel Mode Filter Check
//
//Arguments:
//	IN/OUT checklist
//	IN POLICYPARAMS
//	IN PIPSEC_NFA_DATA
//	IN IPSEC_FILTER_SPEC
//	IN TUNNEL_FILTER
//
//Return:
// 	success or failure code.
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--						 	 	
{
	DWORD dwFlag = 0;
	
	if(IPSEC_PROTOCOL_V4 != pTnFilter->IpVersion)
		return -1;
	
	//interface type
	if(ComparePAInterfaceType(pcheckList,
							pIpsecNFAData->dwInterfaceType, 
							pTnFilter->InterfaceType))
			return -1;
    	dwFlag = ComparePAAddress(pcheckList,
    					pFilterSpec->Filter.SrcMask, 
    					pFilterSpec->Filter.SrcAddr, 
    					pTnFilter->SrcAddr);
  	if(1 == dwFlag ) {
    		if (pFilterSpec->Filter.ExType & EXT_DEST) {
       		if(pTnFilter->DesAddr.AddrType != ExTypeToAddrType(pFilterSpec->Filter.ExType))
               	return -1;
        	} else {
        		if(pTnFilter->SrcAddr.AddrType != ExTypeToAddrType(pFilterSpec->Filter.ExType))
                           	return -1;
        	}//end else
    	}else if(-1 == dwFlag)
    		return -1;
    		
    	dwFlag = ComparePAAddress(pcheckList, 
    					pFilterSpec->Filter.DestMask,
    					pFilterSpec->Filter.DestAddr, 
    					pTnFilter->DesAddr);
    	if(1 == dwFlag){    	
    		if (pFilterSpec->Filter.ExType) {
    			if (pFilterSpec->Filter.ExType & EXT_DEST) {
       			if(pTnFilter->DesAddr.AddrType != ExTypeToAddrType(
                                              pFilterSpec->Filter.ExType
                                              ))
                            return -1;
        		} else {
        			if(pTnFilter->SrcAddr.AddrType != ExTypeToAddrType(
                                              pFilterSpec->Filter.ExType
                                              ))
                           	return -1;
        		}//end else
    		}//end if
    	}else if(-1 == dwFlag)
    		return -1;

  	if( ComparePAAddress(pcheckList,
    					SUBNET_MASK_ANY, 
    					SUBNET_ADDRESS_ANY, 
    					pTnFilter->SrcTunnelAddr))
    		return -1;

    	if(ComparePATunnelAddress(pcheckList, 
    							(ULONG) pIpsecNFAData->dwTunnelIpAddr, 
    							pTnFilter->DesTunnelAddr))
    		return -1;

    	if(pTnFilter->Protocol.ProtocolType != PROTOCOL_UNIQUE)
    		return -1;
    	if(pTnFilter->Protocol.dwProtocol != pFilterSpec->Filter.Protocol)
    		return -1;

    	if(pTnFilter->SrcPort.PortType != PORT_UNIQUE)
    		return -1;
    	if(pTnFilter->SrcPort.wPort != pFilterSpec->Filter.SrcPort)
    		return -1;

    	if(pTnFilter->DesPort.PortType != PORT_UNIQUE)
    		return -1;
    	if(pTnFilter->DesPort.wPort != pFilterSpec->Filter.DestPort)
    		return -1;
    	if(pTnFilter->bCreateMirror != (BOOL) pFilterSpec->dwMirrorFlag)
			return -1;

    	if(CompareFilterActions(pcheckList,
    					ppolicyParams,
    			      		pTnFilter->InboundFilterAction, 
    			      		pTnFilter->OutboundFilterAction))
    		return -1;
    	    
	dwFlag = ppolicyParams->dwFlags & PROCESS_QM_FILTER;
 	if(PROCESS_QM_FILTER != dwFlag)	
			QMPolicyCheck(pcheckList, 
						      pIpsecNFAData, 
						      pTnFilter->gPolicyID, 
						      ppolicyParams);
	
	
    
	return 0;
}

DWORD ComparePAInterfaceType(CHECKLIST* pcheckList, DWORD dwInterfaceType, IF_TYPE InterfaceType)
//++
//Description:
//	Performs Interface Type comparisons
//
//Arguments:
//	IN/OUT checklist
//	IN dwInterfaceType
//	IN IF_TYPE
//
//Return Arguments:
//	Success or Failure
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwFlag = 0;
   	dwFlag = dwInterfaceType & PAS_INTERFACE_TYPE_DIALUP;
    	if (PAS_INTERFACE_TYPE_DIALUP == dwFlag) {
       	if(InterfaceType != INTERFACE_TYPE_DIALUP)
        		return -1;
       	return 0;        	
    	}
    	
    	dwFlag = dwInterfaceType & PAS_INTERFACE_TYPE_LAN;
    	if (PAS_INTERFACE_TYPE_LAN == dwFlag) {
       	if(INTERFACE_TYPE_LAN != InterfaceType)
        		return -1;
       	return 0;
       }
    	dwFlag = dwInterfaceType & PAS_INTERFACE_TYPE_ALL;
       if(PAS_INTERFACE_TYPE_ALL != dwFlag)
        	return -1;
       return 0;    
}

DWORD ComparePAAddress(CHECKLIST* pcheckList, ULONG uMask, ULONG uAddr, ADDR addr )
//++
//Description:
//	Performs address comparisons
//
//Arguments:
//	IN/OUT checklist
//	IN uMask
//	IN uAddr
//	IN addr
//
//Return Arguments:
//	Success or Failure
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwError = 0;
    if (IP_ADDRESS_MASK_NONE == uMask) {
        if(addr.AddrType != IP_ADDR_UNIQUE)
        	dwError = 1;
        if(addr.uIpAddr != uAddr)
        	dwError = -1;
        if(addr.uSubNetMask != uMask)
        	dwError = -1;
    }
    else {
        if(IP_ADDR_SUBNET != addr.AddrType)
        	dwError = 1;
        if(addr.uIpAddr != uAddr)
        	dwError = -1;
        if(addr.uSubNetMask != uMask)
        	dwError = -1;
    }
    if(addr.pgInterfaceID)
    	dwError = -1;
    
    return dwError;
}

DWORD ComparePATunnelAddress(CHECKLIST* pcheckList, ULONG uAddr, ADDR addr )
//++
//Description:
//	Performs tunnel address comparisons
//
//Arguments:
//	IN/OUT checklist
//	IN uAddr
//	IN Addr
//
//Return:
//	success or failure
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
    if (SUBNET_ADDRESS_ANY == uAddr) {
        if(IP_ADDR_SUBNET != addr.AddrType)
        	return -1;
        if(addr.uIpAddr != uAddr)
        	return -1;
        if(SUBNET_MASK_ANY != addr.uSubNetMask)
        	return -1;
    }
    else {
        if(IP_ADDR_UNIQUE != addr.AddrType)
        	return -1;
        if(addr.uIpAddr != uAddr)
        	return -1;
        if(IP_ADDRESS_MASK_NONE != addr.uSubNetMask)
        	return -1;
    }

    if(addr.pgInterfaceID)
    	return -1;
    return 0;
}

DWORD CompareFilterActions(CHECKLIST* pcheckList, 
							  POLICYPARAMS *ppolicyParams,
							  FILTER_ACTION InboundFilterFlag,
							  FILTER_ACTION OutboundFilterFlag )
//++
//Description:
//	Performs tunnel address comparisons
//
//Arguments:
//	IN/OUT checklist
//	IN POLICYPARAMS
//	IN InboundFilterFlag
//	IN OutboundFilterFlag
//
//Return:
//	success or failure code
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwFlags = 0;   	

    	if (IsEqualGUID(&(ppolicyParams->gNegPolAction),
    			    &(GUID_NEGOTIATION_ACTION_BLOCK))) {
      		if(InboundFilterFlag != BLOCKING){
      			if(InboundFilterFlag == PASS_THRU)
      				ppolicyParams->dwFlags |= ALLOW_SOFT;
      			else    				
        			return -1;
      		}//end if
        	if(OutboundFilterFlag != BLOCKING)
        		return -1;
        	return 0;
    	}
    	if (IsEqualGUID(&(ppolicyParams->gNegPolAction),
    				     &(GUID_NEGOTIATION_ACTION_NO_IPSEC))) {
       	if(InboundFilterFlag != PASS_THRU){
      			if(InboundFilterFlag == PASS_THRU)
      				ppolicyParams->dwFlags |= ALLOW_SOFT;
      			else    				
        			return -1;
      		}//end if
        	if(OutboundFilterFlag != PASS_THRU)
        		return -1;
	    	return 0;
    	}
    	if (IsEqualGUID(&(ppolicyParams->gNegPolAction), 
    				    &(GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU))) {
       	if(InboundFilterFlag != PASS_THRU)
        		return -1;
       	if(OutboundFilterFlag != NEGOTIATE_SECURITY)
       		return -1;   
       	return 0;
    	}
    	if(InboundFilterFlag != NEGOTIATE_SECURITY){
      		if(InboundFilterFlag == PASS_THRU)
      			ppolicyParams->dwFlags |= ALLOW_SOFT;
      		else    				
       		return -1;
      	}
       if(OutboundFilterFlag != NEGOTIATE_SECURITY)
       	return -1;   		
       return 0;
    	    	
}

void  MMFilterCheck(CHECKLIST *pcheckList, 
 					POLICYPARAMS *ppolicyParams,
					 PIPSEC_NFA_DATA pIpsecNFAData,
					 IPSEC_FILTER_SPEC *pFilterSpec)

//++
//Description:
//Performs Main Mode Filter Check
//
//Arguments:
//	IN/OUT checklist
//	IN POLICYPARAMS
//	IN PIPSEC_NFA_DATA
//	IN IPSEC_FILTER_SPEC
//
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwError = ERROR_SUCCESS,
			dwNumMMFilters = 0,
			dwResumeHandle = 0,
			i = 0;
	GUID gGenericFilterID = {0};		
	MM_FILTER *pMMFilters = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
		
	while(1)
			{
				
				//match main mode filter from spd
				dwError = EnumMMFilters(
									NULL,
									0,
									NULL,
									ENUM_GENERIC_FILTERS,
 									gGenericFilterID,
	 								0, //max limit set by spd server
 									&pMMFilters, 
 									&dwNumMMFilters,
                     		   				&dwResumeHandle,
 									NULL
 								 	);
				
				if(dwError)
 				{
 					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
 									Nd_Verbose, IDS_SPD_FILTER_ABSENT);	
	
					PrintFilterSpecList(pcheckList,
									  pFilterSpec,
									  pIpsecNFAData);
					gErrorFlag = 1;
 					goto error;
 				}//end if
				_ASSERT(pMMFilters);

				//get corresponding MM filter
				Match(pFilterSpec->FilterSpecGUID, pMMFilters, dwNumMMFilters);

				//match corresponding MM filter
				if(dwNumMMFilters != -1){
					//perform MM filter and polstore filter match
					if(CompareMMFilter(pcheckList,
								     ppolicyParams,
								     pIpsecNFAData,
								     pFilterSpec, 
								     &(pMMFilters[dwNumMMFilters])))
					{						
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD_FILTER);
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose, IDS_SPD_STORAGE_FILTER);	
	
						PrintFilterSpecList(pcheckList,
										  pFilterSpec,
										  pIpsecNFAData);
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, IDS_SPD);	
						PrintMMFilter( pcheckList,  pMMFilters[dwNumMMFilters]);						 
						gErrorFlag = 1;
					}	
									
					break;			
	
				}//end if
				
				if(pMMFilters){
					SPDApiBufferFree((LPVOID)pMMFilters);	
					pMMFilters = NULL;
				}
				dwNumMMFilters = 0;
			}//end while
			
	error:
	if(pMMFilters){
		SPDApiBufferFree((LPVOID)pMMFilters);
		pMMFilters = NULL;
	}	
	return ;
}

DWORD CompareMMFilter(CHECKLIST* pcheckList, 
						POLICYPARAMS *ppolicyParams,
						PIPSEC_NFA_DATA pIpsecNFAData,
						IPSEC_FILTER_SPEC *pFilterSpec, 
					 	MM_FILTER *pMMFilter)
//++
//Description:
//Performs Main Mode Filter Comparison
//
//Arguments:
//	IN/OUT checklist
//	IN POLICYPARAMS
//	IN PIPSEC_NFA_DATA
//	IN IPSEC_FILTER_SPEC
//	IN MM_FILTER
//
//Return:
//	Success or failure
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	DWORD dwFlag = 0;
	
	if(ComparePAInterfaceType(pcheckList,pIpsecNFAData->dwInterfaceType, pMMFilter->InterfaceType))
		return -1;
	   	
	if (!(pIpsecNFAData->dwTunnelFlags)) {
    		dwFlag = ComparePAAddress(pcheckList,
    								     pFilterSpec->Filter.SrcMask, 
    								     pFilterSpec->Filter.SrcAddr, 
    								     pMMFilter->SrcAddr);    	
    		if(1 == dwFlag){
			if (pFilterSpec->Filter.ExType) {
            			if (pFilterSpec->Filter.ExType & EXT_DEST) {
              			if(pMMFilter->DesAddr.AddrType != ExTypeToAddrType(
                                                  pFilterSpec->Filter.ExType))
                            	return -1;
            			} else {
              			if(pMMFilter->SrcAddr.AddrType != ExTypeToAddrType(
                                                  pFilterSpec->Filter.ExType))
                                   return -1;
            			}
        		}
    		}else if (-1 ==  dwFlag)
    			return -1;
    		
    		dwFlag = ComparePAAddress(pcheckList,
    								     pFilterSpec->Filter.DestMask,
    								     pFilterSpec->Filter.DestAddr, 
    								     pMMFilter->DesAddr);
    		if(1 == dwFlag){
			if (pFilterSpec->Filter.ExType) {
            			if (pFilterSpec->Filter.ExType & EXT_DEST) {
              			if(pMMFilter->DesAddr.AddrType != ExTypeToAddrType(
                                                  pFilterSpec->Filter.ExType))
                            	return -1;
            			} else {
              			if(pMMFilter->SrcAddr.AddrType != ExTypeToAddrType(
                                                  pFilterSpec->Filter.ExType))
                                   return -1;
            			}
        		}
    		}else if(-1 == dwFlag)
    			return -1;
    		
		if(pMMFilter->bCreateMirror != (BOOL) pFilterSpec->dwMirrorFlag)
			return -1;
    	}else{
		if(ComparePAAddress(pcheckList,
								     IP_ADDRESS_MASK_NONE,
								     IP_ADDRESS_ME, 
								     pMMFilter->SrcAddr))
			return -1;    	
		if(pMMFilter->bCreateMirror != TRUE)
			return -1;
    		if(ComparePATunnelAddress(pcheckList,
    		 								   (ULONG) pIpsecNFAData->dwTunnelIpAddr, 
    		 								   pMMFilter->DesAddr))
    		 	return -1;
   	}//end else

	MMAuthCheck(pcheckList,pIpsecNFAData, pMMFilter->gMMAuthID, ppolicyParams);
	        
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\snmputil.c ===
//*****************************************************************************
//
// Name:        snmputil.c
//
// Description: Provides functions to read tables of data from snmp.
//
// Used by:     netstat.exe, arp.exe, route.exe
//
// History:
//  01/12/94  JayPh     Created.
//  18-Feb-97 MohsinA   Fixing.
//  Copied from net\tcpip\commands\common2\snmpinfo.c
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1994 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

// #define DEBUG

//
// Include Files
//

#include "precomp.h"
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>

#include "snmputil.h"

//
//

ulong verbose = 0;

//
// Definitions
//

#define MAX_ID_LENGTH           50
#define MAX_RETRY_COUNT         10

// Interface ID values

#define ID_IF_INDEX             1
#define ID_IF_DESC              2
#define ID_IF_TYPE              3
#define ID_IF_MTU               4
#define ID_IF_SPEED             5
#define ID_IF_PHYSADDR          6
#define ID_IF_ADMINSTATUS       7
#define ID_IF_OPERSTATUS        8
#define ID_IF_LASTCHANGE        9
#define ID_IF_INOCTETS          10
#define ID_IF_INUCASTPKTS       11
#define ID_IF_INNUCASTPKTS      12
#define ID_IF_INDISCARDS        13
#define ID_IF_INERRORS          14
#define ID_IF_INUKNOWNPROTOS    15
#define ID_IF_OUTOCTETS         16
#define ID_IF_OUTUCASTPKTS      17
#define ID_IF_OUTNUCASTPKTS     18
#define ID_IF_OUTDISCARDS       19
#define ID_IF_OUTERRORS         20
#define ID_IF_OUTQLEN           21

// IP ID Values

#define ID_IP_FORWARDING        1
#define ID_IP_DEFAULTTTL        2
#define ID_IP_INRECEIVES        3
#define ID_IP_INHDRERRORS       4
#define ID_IP_INADDRERRORS      5
#define ID_IP_FORWDATAGRAMS     6
#define ID_IP_INUNKNOWNPROTOS   7
#define ID_IP_INDISCARDS        8
#define ID_IP_INDELIVERS        9
#define ID_IP_OUTREQUESTS       10
#define ID_IP_OUTDISCARDS       11
#define ID_IP_OUTNOROUTES       12
#define ID_IP_REASMTIMEOUTS     13
#define ID_IP_REASMREQDS        14
#define ID_IP_REASMOKS          15
#define ID_IP_REASMFAILS        16
#define ID_IP_FRAGOKS           17
#define ID_IP_FRAGFAILS         18
#define ID_IP_FRAGCREATES       19
#define ID_IP_ADDRTABLE         20
#define ID_IP_ROUTETABLE        21
#define ID_IP_ARPTABLE          22
#define ID_IP_ROUTINGDISCARDS   23

// IPAddr ID Values

#define ID_IPADDR_ADDR          1
#define ID_IPADDR_INDEX         2
#define ID_IPADDR_MASK          3
#define ID_IPADDR_BCASTADDR     4
#define ID_IPADDR_REASMSIZE     5

// Route ID values

#define ID_ROUTE_DEST           1
#define ID_ROUTE_IFINDEX        2
#define ID_ROUTE_METRIC1        3
#define ID_ROUTE_METRIC2        4
#define ID_ROUTE_METRIC3        5
#define ID_ROUTE_METRIC4        6
#define ID_ROUTE_NEXTHOP        7
#define ID_ROUTE_TYPE           8
#define ID_ROUTE_PROTO          9
#define ID_ROUTE_AGE            10
#define ID_ROUTE_MASK           11
#define ID_ROUTE_METRIC5        12

// ARP ID Values

#define ID_ARP_IFINDEX          1
#define ID_ARP_PHYSADDR         2
#define ID_ARP_NETADDR          3
#define ID_ARP_TYPE             4

// ICMP ID Values

#define ID_ICMP_INMSGS                  1
#define ID_ICMP_INERRORS                2
#define ID_ICMP_INDESTUNREACHES         3
#define ID_ICMP_INTIMEEXCDS             4
#define ID_ICMP_INPARMPROBS             5
#define ID_ICMP_INSRCQUENCHS            6
#define ID_ICMP_INREDIRECTS             7
#define ID_ICMP_INECHOS                 8
#define ID_ICMP_INECHOREPS              9
#define ID_ICMP_INTIMESTAMPS            10
#define ID_ICMP_INTIMESTAMPREPS         11
#define ID_ICMP_INADDRMASKS             12
#define ID_ICMP_INADDRMASKREPS          13
#define ID_ICMP_OUTMSGS                 14
#define ID_ICMP_OUTERRORS               15
#define ID_ICMP_OUTDESTUNREACHES        16
#define ID_ICMP_OUTTIMEEXCDS            17
#define ID_ICMP_OUTPARMPROBS            18
#define ID_ICMP_OUTSRCQUENCHS           19
#define ID_ICMP_OUTREDIRECTS            20
#define ID_ICMP_OUTECHOS                21
#define ID_ICMP_OUTECHOREPS             22
#define ID_ICMP_OUTTIMESTAMPS           23
#define ID_ICMP_OUTTIMESTAMPREPS        24
#define ID_ICMP_OUTADDRMASKS            25
#define ID_ICMP_OUTADDRMASKREPS         26

// TCP ID Values

#define ID_TCP_RTOALGORITHM     1
#define ID_TCP_RTOMIN           2
#define ID_TCP_RTOMAX           3
#define ID_TCP_MAXCONN          4
#define ID_TCP_ACTIVEOPENS      5
#define ID_TCP_PASSIVEOPENS     6
#define ID_TCP_ATTEMPTFAILS     7
#define ID_TCP_ESTABRESETS      8
#define ID_TCP_CURRESTABS       9
#define ID_TCP_INSEGS           10
#define ID_TCP_OUTSEGS          11
#define ID_TCP_RETRANSSEGS      12
#define ID_TCP_CONNTABLE        13
#define ID_TCP_INERRS           14
#define ID_TCP_OUTRSTS          15

// TCP CONN ID Values

#define ID_TCPCONN_STATE        1
#define ID_TCPCONN_LOCALADDR    2
#define ID_TCPCONN_LOCALPORT    3
#define ID_TCPCONN_REMOTEADDR   4
#define ID_TCPCONN_REMOTEPORT   5

// UDP ID Values

#define ID_UDP_INDATAGRAMS      1
#define ID_UDP_NOPORTS          2
#define ID_UDP_INERRORS         3
#define ID_UDP_OUTDATAGRAMS     4
#define ID_UDP_CONNTABLE        5

// UDP CONN ID Values

#define ID_UDPCONN_LOCALADDR    1
#define ID_UDPCONN_LOCALPORT    2

//
// Structure Definitions
//

typedef struct _OIDdef {
    ulong  Length;
    ulong  Val[MAX_ID_LENGTH];
    ulong  EntElemOffset;
    ulong  BackOffset;
} OIDdef;


//
// Local Function Prototypes
//

ulong ReadTable( GenericTable *pList, ulong Type, ulong Size );
void SaveData_IF( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid );
void SaveData_IP( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid );
void SaveData_IPAddr( GenericTable    *pEntry,
                      RFC1157VarBind   item,
                      OIDdef          *pOid );
void SaveData_ROUTE( GenericTable    *pEntry,
                     RFC1157VarBind   item,
                     OIDdef          *pOid );
void SaveData_ARP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );
void SaveData_ICMP( GenericTable    *pEntry,
                    RFC1157VarBind   item,
                    OIDdef          *pOid );
void SaveData_TCP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );
void SaveData_TCPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid );
void SaveData_UDP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );
void SaveData_UDPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid );


//
// Global Variables
//

// These are used to create object id's

OIDdef PreambleDef   = { 6, { 1,  3,  6, 1, 2, 1 },  0, 0 };
OIDdef IfInfoDef     = { 4, { 2,  2,  1, 1       },  9, 2 };
OIDdef IPInfoDef     = { 2, { 4,  1              },  7, 1 };
OIDdef IPAddrInfoDef = { 4, { 4,  20, 1, 1       },  9, 2 };
OIDdef RouteInfoDef  = { 4, { 4,  21, 1, 1       },  9, 2 };
OIDdef ARPInfoDef    = { 4, { 4,  22, 1, 1       },  9, 2 };
OIDdef ICMPInfoDef   = { 2, { 5,  1,             },  7, 1 };
OIDdef TCPInfoDef    = { 2, { 6,  1              },  7, 1 };
OIDdef TCPConnDef    = { 4, { 6, 13,  1, 1       },  9, 2 };
OIDdef UDPInfoDef    = { 2, { 7,  1              },  7, 1 };
OIDdef UDPConnDef    = { 4, { 7,  5,  1, 1       },  9, 2 };


// These are used to hold the addresses of the functions we use in inetmib1.dll

FARPROC   gQueryAddr;
FARPROC   gInitAddr;

//
// From //ORVILLE/RAZZLE/src/net/snmp/agent/mgmtapi/mgmtapi.c
// See  //ORVILLE/RAZZLE/src/public/sdk/inc/snmp.h
//          SNMP_FUNC_TYPE is WINAPI.
//
// These pointer to functions are imported from mgmtapi.dll (available
// on nt server only with snmp service, but can be copied).
// - MohsinA, 11-Mar-97.
//

BOOL (SNMP_FUNC_TYPE * pSnmpMgrOidToStr )( IN  AsnObjectIdentifier *oid,
                                            OUT LPSTR           *string );


//
// Exported Functions
//

//*****************************************************************************
//
// Name:        InitSnmp
//
// Description: Set up to use inetmib1.dll.  Load the DLL, and get addresses
//              for the interesting procedures.
//              NOTE: This function must be called before calling GetTable().
//
// Parameters:  void.
//
// Returns:     ulong: NO_ERROR if successful, error code otherwise.
//
// History:
//  12/20/93  JayPh     Created.
//
//*****************************************************************************

ulong InitSnmp( void )
{
    HANDLE                     hExtension;
    ulong                      TimeZeroReference;
    HANDLE                     hPollForTrapEvent;
    AsnObjectIdentifier        SupportedView;

    HANDLE                     mgmtapi_dll;

    TimeZeroReference = (ulong)time( (time_t *)0 );


    // Load the management apis, only on servers, but useful for
    // figuring out snmp jargon.

    if( verbose ){
        mgmtapi_dll = LoadLibraryA( "mgmtapi.dll" );
        if( mgmtapi_dll ){
            pSnmpMgrOidToStr
            = (LPVOID) GetProcAddress( mgmtapi_dll, "SnmpMgrOidToStr" );
        }
        if( !mgmtapi_dll || !pSnmpMgrOidToStr ){
            DEBUG_PRINT((
                "InitSnmp: mgmtapi.dll:pSnmpMgrOidToStr() not found.\n"
            ));
        }
    }



    // Load inetmib1.dll and get proc address for SnmpExtensionQuery

    hExtension = LoadLibraryA( "inetmib1.dll" );
    if ( hExtension == NULL )
    {
        DEBUG_PRINT(("InitSnmp: cannot load inetmib1.dll\n"));
        return ( ERROR_FILE_NOT_FOUND );
    }

    gInitAddr = GetProcAddress( hExtension, "SnmpExtensionInit" );
    if ( gInitAddr == NULL )
    {
        DEBUG_PRINT(("InitSnmp: inetmib1.dll:SnmpExtensionInit missing.\n"));
        return ( ERROR_FILE_NOT_FOUND );
    }

    gQueryAddr = GetProcAddress( hExtension, "SnmpExtensionQuery" );
    if ( gQueryAddr == NULL )
    {
        DEBUG_PRINT(("InitSnmp: inetmib1.dll:SnmpExtensionQuery missing.\n"));
        return ( ERROR_FILE_NOT_FOUND );
    }

    // Initialize the extension DLL

    (*gInitAddr)( TimeZeroReference, &hPollForTrapEvent, &SupportedView );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        GetTable
//
// Description: Gets a consistent table from snmp.  Consistency is achieved by
//              reading the table, reading the table a second time and
//              comparing the two.  If they match, we are done.  If they don't
//              match, we read the table again and compare again.  Repeating
//              until we have a match, or our retry count exceeds a threshold.
//
// Parameters:  ulong Type: type of table to get.
//              ulong *pResult: pointer to location to receive the result code.
//
// Returns:     void *: NULL if some error, otherwise pointer to table.
//
// History:
//  01/12/94  JayPh     Created.
//  18-Feb-97 MohsinA   Removed while loop and pList1.
//*****************************************************************************

void *GetTable( ulong Type, ulong *pResult )
{
    GenericTable   *pList2;
    ulong   Result;
    ulong   RetryCount = 0;
    ulong   Size;

    if( verbose ){
        fprintf(stderr, "GetTable: type = %d\n", Type );
    }

    if ( Type > TYPE_UDPCONN )
    {
        *pResult = ERROR_INVALID_PARAMETER;
        return ( NULL );
    }

    // Allocate memory for the list heads

    switch ( Type )
    {
    case TYPE_IF:
        Size = sizeof( IfEntry ) + MAX_IFDESCR_LEN;
        break;

    case TYPE_IP:
        Size = sizeof( IpEntry );
        break;

    case TYPE_IPADDR:
        Size = sizeof( IpAddrEntry );
        break;

    case TYPE_ROUTE:
        Size = sizeof( RouteEntry );
        break;

    case TYPE_ARP:
        Size = sizeof( ArpEntry );
        break;

    case TYPE_ICMP:
        Size = sizeof( IcmpEntry );
        break;

    case TYPE_TCP:
        Size = sizeof( TcpEntry );
        break;

    case TYPE_TCPCONN:
        Size = sizeof( TcpConnEntry );
        break;

    case TYPE_UDP:
        Size = sizeof( UdpEntry );
        break;

    case TYPE_UDPCONN:
        Size = sizeof( UdpConnEntry );
        break;

    }

    // Don't need pList1 - MohsinA, 18-Feb-97.

    pList2 = (GenericTable *)SNMP_malloc( Size );
    if ( pList2 == NULL )
    {
        *pResult = ERROR_NOT_ENOUGH_MEMORY;
        return ( NULL );
    }

    InitializeListHead( &pList2->ListEntry );

    // Read the table into List2

    Result = ReadTable( pList2, Type, Size );
    if ( Result != NO_ERROR )
    {
        FreeTable( pList2 );
        *pResult = Result;
        return ( NULL );
    }


    // Useless while loop removed. - MohsinA, 18-Feb-97.

    *pResult = NO_ERROR;
    return ( pList2 );
}


//*****************************************************************************
//
// Name:        FreeTable
//
// Description: Free all entries in the list, including the list head.
//
// Parameters:  GenericTable *pList: pointer to head of list.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void FreeTable( GenericTable *pList )
{
    GenericTable  *pTmp;
    LIST_ENTRY    *pTmpList;

    while ( !IsListEmpty( &pList->ListEntry ) )
    {
        pTmpList = RemoveHeadList( &pList->ListEntry );
        pTmp = CONTAINING_RECORD( pTmpList,
                                  GenericTable,
                                  ListEntry );
        SNMP_free( pTmp );
    }

    SNMP_free( pList );
}


//
// Internal Functions
//

//*****************************************************************************
//
// Name:        ReadTable
//
// Description: Queries the MIB and builds a table representing the data we are
//              interested in.
//
// Parameters:  GenericTable *pList: address of unitialized head of the entry
//                      list.
//              ulong Type: type of table we want.
//              ulong Size: size of a table entry.
//
// Returns:     ulong: NO_ERROR if no error, and table is built.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

ulong ReadTable( GenericTable *pList, ulong Type, ulong Size )
{
    AsnInteger          GetNextReq = ASN_RFC1157_GETNEXTREQUEST;
    RFC1157VarBind      item;
    RFC1157VarBindList  VarBinds = { &item, 1 };
    AsnObjectIdentifier oidBackup;
    AsnInteger          ErrorStatus = 0;
    AsnInteger          ErrorIndex = 0;
    ulong              *pId;
    GenericTable       *pTable;
    ulong               LastField = 0;
    uchar              *pTmp;
    ulong               i;
    OIDdef             *pOid;
    ulong               BreakLoop = FALSE;

    if( verbose ){
        fprintf(stderr,"ReadTable: type = %d\n", Type);
    }

    // Walk SNMP database, building local table.

    pId = (ulong *)SNMP_malloc( (sizeof( ulong ) * MAX_ID_LENGTH) );
    if ( pId == NULL )
    {
        return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    item.name.ids = pId;

    // Build OID from preamble and table-specific suffix

    // Copy preamble

    for ( i = 0; i < PreambleDef.Length; i++ )
    {
        *pId++ = PreambleDef.Val[i];
    }

    // Get pointer to table-specific info

    switch ( Type )
    {
    case TYPE_IF:
        pOid = &IfInfoDef;
        break;

    case TYPE_IP:
        pOid = &IPInfoDef;
        break;

    case TYPE_IPADDR:
        pOid = &IPAddrInfoDef;
        break;

    case TYPE_ROUTE:
        pOid = &RouteInfoDef;
        break;

    case TYPE_ARP:
        pOid = &ARPInfoDef;
        break;

    case TYPE_ICMP:
        pOid = &ICMPInfoDef;
        break;

    case TYPE_TCP:
        pOid = &TCPInfoDef;
        break;

    case TYPE_TCPCONN:
        pOid = &TCPConnDef;
        break;

    case TYPE_UDP:
        pOid = &UDPInfoDef;
        break;

    case TYPE_UDPCONN:
        pOid = &UDPConnDef;
        break;

    }

    // Copy table-specific info

    for ( i = 0; i < pOid->Length; i++ )
    {
        *pId++ = pOid->Val[i];
    }

    item.name.idLength = PreambleDef.Length + pOid->Length;
    item.value.asnType = ASN_NULL;

    pTable = pList;

    // Walk the mib until the table-specific termination condition is met.

    while( 1 )
    {
        // Get next

        (*gQueryAddr)( GetNextReq, &VarBinds, &ErrorStatus, &ErrorIndex );

        if( verbose )
        {
            int   q;

            fprintf(stderr,"value=%8d oid= ", item.value.asnValue.number );

            //
            // Print the object name, use mgmtapi.dll.
            //

            if( pSnmpMgrOidToStr ){
                LPSTR String = NULL;
                int   err;
                err = (* pSnmpMgrOidToStr )( &item.name, &String );
                if( SNMPAPI_ERROR != err ){
                    fprintf(stderr," %s ", String );
                }
                SnmpUtilMemFree( String );
            }

            if( !pSnmpMgrOidToStr || (verbose > 1) ){

                //
                // Print the oid, in ``1.3.6.1.2.1'' style.
                //

                for ( q = 0; q < (int) item.name.idLength; q++ ){

                    // Must align the output to read huge tables.

                    if( q < 6 ){
                        fprintf( stderr,"%d.", item.name.ids[q]);
                    }else if( q < 9 ){
                        fprintf( stderr,"%2d.", item.name.ids[q]);
                    }else{
                        fprintf( stderr,"%3d.", item.name.ids[q]);
                    }
                }
            }
            fprintf(stderr,"\n");

        }


        if ( ErrorStatus != 0 )
        {
            SnmpUtilVarBindFree( &item );
            return ( ErrorStatus );
        }

        // We want to break out of this while loop if the defining part of the
        // OID changes

        if ( item.name.idLength < ( PreambleDef.Length + pOid->Length ) )
        {
            break;
        }

        for ( i = PreambleDef.Length;
              i < PreambleDef.Length + pOid->Length - pOid->BackOffset;
              i++ )
        {
            if ( item.name.ids[i] != pOid->Val[i - PreambleDef.Length] )
            {
                BreakLoop = TRUE;
                break;
            }
        }

        if ( BreakLoop )
        {
            break;
        }

        // We want to ignore certain entries.  EG: the TCP statistics will also
        // return the TCP connection table, which we don't want (there is a
        // separate Type code for that).

        switch ( Type )
        {
        case TYPE_IP:
            if ( ( item.name.ids[pOid->EntElemOffset] == ID_IP_ADDRTABLE ) ||
                 ( item.name.ids[pOid->EntElemOffset] == ID_IP_ROUTETABLE ) ||
                 ( item.name.ids[pOid->EntElemOffset] == ID_IP_ARPTABLE ) )
            {
                continue;
            }
            break;

        case TYPE_TCP:
            if ( item.name.ids[pOid->EntElemOffset] == ID_TCP_CONNTABLE )
            {
                continue;
            }
            break;

        case TYPE_UDP:
            if ( item.name.ids[pOid->EntElemOffset] == ID_UDP_CONNTABLE )
            {
                continue;
            }
            break;

        }

        // Entry handling:
        //
        // There are 3 cases to consider:
        // 1. If the list is empty, OR at the end of the list AND the
        //    CurrField == LastField.
        //   Then add a new entry to the list.
        // 2. CurrField != LastField.
        //   Then reset pointer to start of the list.
        // 3. Otherwise
        //   Then go to next entry in the list.

        if ( ( pTable == pList ) ||
             ( ( pTable->ListEntry.Flink == &pList->ListEntry ) &&
               ( item.name.ids[pOid->EntElemOffset] == LastField ) ) )
        {
            // Add new entry to table

            pTable = (GenericTable *)SNMP_malloc( Size );
            if ( pTable == NULL )
            {
                SnmpUtilVarBindFree( &item );
                return ( ERROR_NOT_ENOUGH_MEMORY );
            }

            InsertTailList( &pList->ListEntry, &pTable->ListEntry );
        }
        else if ( item.name.ids[pOid->EntElemOffset] != LastField )
        {
            // Reset pointer to start of list

            pTable = CONTAINING_RECORD( pList->ListEntry.Flink,
                                        GenericTable,
                                        ListEntry );
        }
        else
        {
            // Move pointer to next entry in list

            pTable = CONTAINING_RECORD( pTable->ListEntry.Flink,
                                        GenericTable,
                                        ListEntry );
        }

        LastField = item.name.ids[pOid->EntElemOffset];

        // Save info in our list.  pTable points to desired entry.

        switch ( Type )
        {
        case TYPE_IF:
            SaveData_IF( pTable, item, pOid );
            break;

        case TYPE_IP:
            SaveData_IP( pTable, item, pOid );
            break;

        case TYPE_IPADDR:
            SaveData_IPAddr( pTable, item, pOid );
            break;

        case TYPE_ROUTE:
            SaveData_ROUTE( pTable, item, pOid );
            break;

        case TYPE_ARP:
            SaveData_ARP( pTable, item, pOid );
            break;

        case TYPE_ICMP:
            SaveData_ICMP( pTable, item, pOid );
            break;

        case TYPE_TCP:
            SaveData_TCP( pTable, item, pOid );
            break;

        case TYPE_TCPCONN:
            SaveData_TCPCONN( pTable, item, pOid );
            break;

        case TYPE_UDP:
            SaveData_UDP( pTable, item, pOid );
            break;

        case TYPE_UDPCONN:
            SaveData_UDPCONN( pTable, item, pOid );
            break;

        }

        SnmpUtilOidCpy( &oidBackup, &(item.name));
        SnmpUtilVarBindFree( &item );
        item.name.idLength = oidBackup.idLength;
        item.name.ids = oidBackup.ids;
    }

    SnmpUtilVarBindFree( &item );

    return ( NO_ERROR );
}



//*****************************************************************************
//
// Name:        SaveData_IF
//
// Description: Saves an element of the data in the interface table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IF( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid )
{
    IfEntry  *pIf = ( IfEntry *)pEntry;
    uchar    *pTmp;
    ulong     i;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IF_INDEX:
        pIf->Info.if_index = item.value.asnValue.number;
        break;

    case ID_IF_DESC:
        pIf->Info.if_descrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pIf->Info.if_descrlen; i++ )
        {
            pIf->Info.if_descr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_IF_TYPE:
        pIf->Info.if_type = item.value.asnValue.number;
        break;

    case ID_IF_MTU:
        pIf->Info.if_mtu = item.value.asnValue.number;
        break;

    case ID_IF_SPEED:
        pIf->Info.if_speed = item.value.asnValue.number;
        break;

    case ID_IF_PHYSADDR:
        pIf->Info.if_physaddrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pIf->Info.if_physaddrlen; i++ )
        {
            pIf->Info.if_physaddr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_IF_ADMINSTATUS:
        pIf->Info.if_adminstatus = item.value.asnValue.number;
        break;

    case ID_IF_OPERSTATUS:
        pIf->Info.if_operstatus = item.value.asnValue.number;
        break;

    case ID_IF_LASTCHANGE:
        pIf->Info.if_lastchange = item.value.asnValue.number;
        break;

    case ID_IF_INOCTETS:
        pIf->Info.if_inoctets = item.value.asnValue.number;
        break;

    case ID_IF_INUCASTPKTS:
        pIf->Info.if_inucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_INNUCASTPKTS:
        pIf->Info.if_innucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_INDISCARDS:
        pIf->Info.if_indiscards = item.value.asnValue.number;
        break;

    case ID_IF_INERRORS:
        pIf->Info.if_inerrors = item.value.asnValue.number;
        break;

    case ID_IF_INUKNOWNPROTOS:
        pIf->Info.if_inunknownprotos = item.value.asnValue.number;
        break;

    case ID_IF_OUTOCTETS:
        pIf->Info.if_outoctets = item.value.asnValue.number;
        break;

    case ID_IF_OUTUCASTPKTS:
        pIf->Info.if_outucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_OUTNUCASTPKTS:
        pIf->Info.if_outnucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_OUTDISCARDS:
        pIf->Info.if_outdiscards = item.value.asnValue.number;
        break;

    case ID_IF_OUTERRORS:
        pIf->Info.if_outerrors = item.value.asnValue.number;
        break;

    case ID_IF_OUTQLEN:
        pIf->Info.if_outqlen = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_IP
//
// Description: Saves an element of the data in the IP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IP( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid )
{
    IpEntry  *pIp = (IpEntry *)pEntry;
    uchar    *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IP_FORWARDING:
        pIp->Info.ipsi_forwarding = item.value.asnValue.number;
        break;

    case ID_IP_DEFAULTTTL:
        pIp->Info.ipsi_defaultttl = item.value.asnValue.number;
        break;

    case ID_IP_INRECEIVES:
        pIp->Info.ipsi_inreceives = item.value.asnValue.number;
        break;

    case ID_IP_INHDRERRORS:
        pIp->Info.ipsi_inhdrerrors = item.value.asnValue.number;
        break;

    case ID_IP_INADDRERRORS:
        pIp->Info.ipsi_inaddrerrors = item.value.asnValue.number;
        break;

    case ID_IP_FORWDATAGRAMS:
        pIp->Info.ipsi_forwdatagrams = item.value.asnValue.number;
        break;

    case ID_IP_INUNKNOWNPROTOS:
        pIp->Info.ipsi_inunknownprotos = item.value.asnValue.number;
        break;

    case ID_IP_INDISCARDS:
        pIp->Info.ipsi_indiscards = item.value.asnValue.number;
        break;

    case ID_IP_INDELIVERS:
        pIp->Info.ipsi_indelivers = item.value.asnValue.number;
        break;

    case ID_IP_OUTREQUESTS:
        pIp->Info.ipsi_outrequests = item.value.asnValue.number;
        break;

    case ID_IP_OUTDISCARDS:
        pIp->Info.ipsi_outdiscards = item.value.asnValue.number;
        break;

    case ID_IP_OUTNOROUTES:
        pIp->Info.ipsi_outnoroutes = item.value.asnValue.number;
        break;

    case ID_IP_REASMTIMEOUTS:
        pIp->Info.ipsi_reasmtimeout = item.value.asnValue.number;
        break;

    case ID_IP_REASMREQDS:
        pIp->Info.ipsi_reasmreqds = item.value.asnValue.number;
        break;

    case ID_IP_REASMOKS:
        pIp->Info.ipsi_reasmoks = item.value.asnValue.number;
        break;

    case ID_IP_REASMFAILS:
        pIp->Info.ipsi_reasmfails = item.value.asnValue.number;
        break;

    case ID_IP_FRAGOKS:
        pIp->Info.ipsi_fragoks = item.value.asnValue.number;
        break;

    case ID_IP_FRAGFAILS:
        pIp->Info.ipsi_fragfails = item.value.asnValue.number;
        break;

    case ID_IP_FRAGCREATES:
        pIp->Info.ipsi_fragcreates = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_IPAddr
//
// Description: Saves an element of the data in the IP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IPAddr( GenericTable    *pEntry,
                      RFC1157VarBind   item,
                      OIDdef          *pOid )
{
    IpAddrEntry  *pIpAddr = (IpAddrEntry *)pEntry;
    uchar        *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IPADDR_ADDR:
        pTmp = (uchar *)&(pIpAddr->Info.iae_addr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_IPADDR_INDEX:
        pIpAddr->Info.iae_index = item.value.asnValue.number;
        break;

    case ID_IPADDR_MASK:
        pTmp = (uchar *)&(pIpAddr->Info.iae_mask);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_IPADDR_BCASTADDR:
        pIpAddr->Info.iae_bcastaddr = item.value.asnValue.number;
        break;

    case ID_IPADDR_REASMSIZE:
        pIpAddr->Info.iae_reasmsize = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ROUTE
//
// Description: Saves an element of the data in the ROUTE table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ROUTE( GenericTable    *pEntry,
                     RFC1157VarBind   item,
                     OIDdef          *pOid )
{
    RouteEntry  *pRoute = (RouteEntry *)pEntry;
    uchar       *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ROUTE_DEST:
        pTmp = (uchar *)&(pRoute->Info.ire_dest);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_IFINDEX:
        pRoute->Info.ire_index = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC1:
        pRoute->Info.ire_metric1 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC2:
        pRoute->Info.ire_metric2 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC3:
        pRoute->Info.ire_metric3 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC4:
        pRoute->Info.ire_metric4 = item.value.asnValue.number;
        break;

    case ID_ROUTE_NEXTHOP:
        pTmp = (uchar *)&(pRoute->Info.ire_nexthop);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_TYPE:
        pRoute->Info.ire_type = item.value.asnValue.number;
        break;

    case ID_ROUTE_PROTO:
        pRoute->Info.ire_proto = item.value.asnValue.number;
        break;

    case ID_ROUTE_AGE:
        pRoute->Info.ire_age = item.value.asnValue.number;
        break;

    case ID_ROUTE_MASK:
        pTmp = (uchar *)&(pRoute->Info.ire_mask);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_METRIC5:
        pRoute->Info.ire_metric5 = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ARP
//
// Description: Saves an element of the data in the ARP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ARP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    ArpEntry  *pArp = (ArpEntry *)pEntry;
    uchar     *pTmp;
    ulong      i;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ARP_IFINDEX:
        pArp->Info.inme_index = item.value.asnValue.number;
        break;

    case ID_ARP_PHYSADDR:
        pArp->Info.inme_physaddrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pArp->Info.inme_physaddrlen; i++ )
        {
            pArp->Info.inme_physaddr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_ARP_NETADDR:
        pTmp = (uchar *)&(pArp->Info.inme_addr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ARP_TYPE:
        pArp->Info.inme_type = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ICMP
//
// Description: Saves an element of the data in the ICMP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ICMP( GenericTable    *pEntry,
                    RFC1157VarBind   item,
                    OIDdef          *pOid )
{
    IcmpEntry  *pIcmp = (IcmpEntry *)pEntry;
    uchar      *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ICMP_INMSGS:
        pIcmp->InInfo.icmps_msgs = item.value.asnValue.number;
        break;

    case ID_ICMP_INERRORS:
        pIcmp->InInfo.icmps_errors = item.value.asnValue.number;
        break;

    case ID_ICMP_INDESTUNREACHES:
        pIcmp->InInfo.icmps_destunreachs = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMEEXCDS:
        pIcmp->InInfo.icmps_timeexcds = item.value.asnValue.number;
        break;

    case ID_ICMP_INPARMPROBS:
        pIcmp->InInfo.icmps_parmprobs = item.value.asnValue.number;
        break;

    case ID_ICMP_INSRCQUENCHS:
        pIcmp->InInfo.icmps_srcquenchs = item.value.asnValue.number;
        break;

    case ID_ICMP_INREDIRECTS:
        pIcmp->InInfo.icmps_redirects = item.value.asnValue.number;
        break;

    case ID_ICMP_INECHOS:
        pIcmp->InInfo.icmps_echos = item.value.asnValue.number;
        break;

    case ID_ICMP_INECHOREPS:
        pIcmp->InInfo.icmps_echoreps = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMESTAMPS:
        pIcmp->InInfo.icmps_timestamps = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMESTAMPREPS:
        pIcmp->InInfo.icmps_timestampreps = item.value.asnValue.number;
        break;

    case ID_ICMP_INADDRMASKS:
        pIcmp->InInfo.icmps_addrmasks = item.value.asnValue.number;
        break;

    case ID_ICMP_INADDRMASKREPS:
        pIcmp->InInfo.icmps_addrmaskreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTMSGS:
        pIcmp->OutInfo.icmps_msgs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTERRORS:
        pIcmp->OutInfo.icmps_errors = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTDESTUNREACHES:
        pIcmp->OutInfo.icmps_destunreachs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMEEXCDS:
        pIcmp->OutInfo.icmps_timeexcds = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTPARMPROBS:
        pIcmp->OutInfo.icmps_parmprobs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTSRCQUENCHS:
        pIcmp->OutInfo.icmps_srcquenchs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTREDIRECTS:
        pIcmp->OutInfo.icmps_redirects = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTECHOS:
        pIcmp->OutInfo.icmps_echos = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTECHOREPS:
        pIcmp->OutInfo.icmps_echoreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMESTAMPS:
        pIcmp->OutInfo.icmps_timestamps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMESTAMPREPS:
        pIcmp->OutInfo.icmps_timestampreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTADDRMASKS:
        pIcmp->OutInfo.icmps_addrmasks = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTADDRMASKREPS:
        pIcmp->OutInfo.icmps_addrmaskreps = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_TCP
//
// Description: Saves an element of the data in the TCP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_TCP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    TcpEntry  *pTcp = (TcpEntry *)pEntry;
    uchar     *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_TCP_RTOALGORITHM:
        pTcp->Info.ts_rtoalgorithm = item.value.asnValue.number;
        break;

    case ID_TCP_RTOMIN:
        pTcp->Info.ts_rtomin = item.value.asnValue.number;
        break;

    case ID_TCP_RTOMAX:
        pTcp->Info.ts_rtomax = item.value.asnValue.number;
        break;

    case ID_TCP_MAXCONN:
        pTcp->Info.ts_maxconn = item.value.asnValue.number;
        break;

    case ID_TCP_ACTIVEOPENS:
        pTcp->Info.ts_activeopens = item.value.asnValue.number;
        break;

    case ID_TCP_PASSIVEOPENS:
        pTcp->Info.ts_passiveopens = item.value.asnValue.number;
        break;

    case ID_TCP_ATTEMPTFAILS:
        pTcp->Info.ts_attemptfails = item.value.asnValue.number;
        break;

    case ID_TCP_ESTABRESETS:
        pTcp->Info.ts_estabresets = item.value.asnValue.number;
        break;

    case ID_TCP_CURRESTABS:
        pTcp->Info.ts_currestab = item.value.asnValue.number;
        break;

    case ID_TCP_INSEGS:
        pTcp->Info.ts_insegs = item.value.asnValue.number;
        break;

    case ID_TCP_OUTSEGS:
        pTcp->Info.ts_outsegs = item.value.asnValue.number;
        break;

    case ID_TCP_RETRANSSEGS:
        pTcp->Info.ts_retranssegs = item.value.asnValue.number;
        break;

    case ID_TCP_INERRS:
        pTcp->Info.ts_inerrs = item.value.asnValue.number;
        break;

    case ID_TCP_OUTRSTS:
        pTcp->Info.ts_outrsts = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_TCPCONN
//
// Description: Saves an element of the data in the TCP connection table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_TCPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid )
{
    TcpConnEntry  *pTcp = (TcpConnEntry *)pEntry;
    uchar         *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_TCPCONN_STATE:
        pTcp->Info.tct_state = item.value.asnValue.number;
        break;

    case ID_TCPCONN_LOCALADDR:
        pTmp = (uchar *)&(pTcp->Info.tct_localaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_TCPCONN_LOCALPORT:
        pTcp->Info.tct_localport = item.value.asnValue.number;
        break;

    case ID_TCPCONN_REMOTEADDR:
        pTmp = (uchar *)&(pTcp->Info.tct_remoteaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_TCPCONN_REMOTEPORT:
        pTcp->Info.tct_remoteport = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_UDP
//
// Description: Saves an element of the data in the UDP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_UDP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    UdpEntry  *pUdp = (UdpEntry *)pEntry;
    uchar     *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_UDP_INDATAGRAMS:
        pUdp->Info.us_indatagrams = item.value.asnValue.number;
        break;

    case ID_UDP_NOPORTS:
        pUdp->Info.us_noports = item.value.asnValue.number;
        break;

    case ID_UDP_INERRORS:
        pUdp->Info.us_inerrors = item.value.asnValue.number;
        break;

    case ID_UDP_OUTDATAGRAMS:
        pUdp->Info.us_outdatagrams = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_UDPCONN
//
// Description: Saves an element of the data in the UDP connection table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_UDPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid )
{
    UdpConnEntry  *pUdp = (UdpConnEntry *)pEntry;
    uchar         *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_UDPCONN_LOCALADDR:
        pTmp = (uchar *)&(pUdp->Info.ue_localaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_UDPCONN_LOCALPORT:
        pUdp->Info.ue_localport = item.value.asnValue.number;
        break;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\spdcheck.h ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 2001
//
//  Module Name:
//
//      spdcheck.h
//
//  Abstract:
//
//      SPD Check stats for netdiag
//
//  Author:
//
//      Madhurima Pawar (mpawar)  - 10/15/2001
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//--

#ifndef HEADER_SPDCHECK
#define HEADER_SPDCHECK

#include <ipsec.h>
#include<winipsec.h>
#include<ipsecshr.h>
#include <oleauto.h>
#include <oakdefs.h>
#include <polstore2.h>
//#include <polstructs.h>

//++
//define
//--
#define MAXSTRLEN	(1024) 


typedef struct{
	HANDLE hPolicyStore;
	GUID gNegPolAction;	
	DWORD dwFlags;		
}POLICYPARAMS, *PPOLICYPARAMS;

typedef struct _filter_list{
	IPSEC_FILTER ipsecFilter;
	struct _filter_list *next;
} FILTERLIST, *PFILTERLIST;

//flags for filterparams
#define PROCESS_NONE  			1
#define PROCESS_QM_FILTER 		2
#define PROCESS_BOTH 			4
#define ALLOW_SOFT				8

#define Match(_guid, _filterList, _numFilter)\
	while(_numFilter)\
	{\
		if(IsEqualGUID(&(_filterList[_numFilter].gFilterID),&_guid))\
			break;\
		_numFilter --;\
	}\
	
//Globals
PFILTERLIST gpFilterList;
DWORD dwNumofFilters;
DWORD gErrorFlag;

// policy source constants
#define PS_NO_POLICY  0
#define PS_DS_POLICY  1
#define PS_LOC_POLICY 2


//++
//macro defintion
//--

#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {\
    	goto error; \
 }

#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) {\
        goto error; \
    }

#define reportErr()\
	if(dwError != ERROR_SUCCESS)\
	{\
		reportError(dwError, pParams, pResults);\
		gErrorFlag = 1;\
		goto error;\
	}\


 //++
 //data structures
 //--

typedef struct 
{
	int     iPolicySource;            // one of the three constants mentioned above
	TCHAR   pszPolicyName[MAXSTRLEN]; // policy name
	TCHAR   pszPolicyDesc[MAXSTRLEN]; // policy description
	TCHAR   pszPolicyPath[MAXSTRLEN]; // policy path (DN or RegKey)
	time_t  timestamp;                // last updated time
	GUID policyGUID;
} POLICY_INFO, *PPOLICY_INFO;

typedef struct{
	NETDIAG_PARAMS* pParams;
	NETDIAG_RESULT*  pResults;		
}CHECKLIST, *PCHECKLIST;


//++
//global variables
//--
POLICY_INFO    piAssignedPolicy;

//++
//function definition
//--

BOOL  SPDCheckTEST(NETDIAG_PARAMS* pParams, 
					     NETDIAG_RESULT*  pResults); //defined in spdcheck.cpp
void reportError ( DWORD dwError, 
				   NETDIAG_PARAMS* pParams, 
				   NETDIAG_RESULT*  pResults );





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\snmputil.h ===
//*****************************************************************************
//
// Name:	snmputil.h
//
// Description:	
//
// History:
//  01/13/94  smanda	Created.
//  Copied from \sdnt\net\tcpip\commands\common2\common2.h
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1994 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

#ifndef __SNMPUTIL_H__
#define __SNMPUTIL_H__

//
// Include Files
//

#include "ipexport.h"
#include "ipinfo.h"
#include "llinfo.h"
#include "tcpinfo.h"


//
// Definitions
//

#define MAX_ID_LENGTH		50

// Table Types

#define TYPE_IF		0
#define TYPE_IP		1
#define TYPE_IPADDR	2
#define TYPE_ROUTE	3
#define TYPE_ARP	4
#define TYPE_ICMP	5
#define TYPE_TCP	6
#define TYPE_TCPCONN	7
#define TYPE_UDP	8
#define TYPE_UDPCONN	9


//
// Structure Definitions
//

typedef struct _GenericTable {
    LIST_ENTRY  ListEntry;
} GenericTable;

typedef struct _IfEntry {
    LIST_ENTRY  ListEntry;
    IFEntry     Info;
} IfEntry;

typedef struct _IpEntry {
    LIST_ENTRY  ListEntry;
    IPSNMPInfo  Info;
} IpEntry;

typedef struct _IpAddrEntry {
    LIST_ENTRY   ListEntry;
    IPAddrEntry  Info;
} IpAddrEntry;

typedef struct _RouteEntry {
    LIST_ENTRY    ListEntry;
    IPRouteEntry  Info;
} RouteEntry;

typedef struct _ArpEntry {
    LIST_ENTRY         ListEntry;
    IPNetToMediaEntry  Info;
} ArpEntry;

typedef struct _IcmpEntry {
    LIST_ENTRY  ListEntry;
    ICMPStats   InInfo;
    ICMPStats   OutInfo;
} IcmpEntry;

typedef struct _TcpEntry {
    LIST_ENTRY  ListEntry;
    TCPStats    Info;
} TcpEntry;

typedef struct _TcpConnEntry {
    LIST_ENTRY         ListEntry;
    TCPConnTableEntry  Info;
} TcpConnEntry;

typedef struct _UdpEntry {
    LIST_ENTRY  ListEntry;
    UDPStats    Info;
} UdpEntry;

typedef struct _UdpConnEntry {
    LIST_ENTRY  ListEntry;
    UDPEntry    Info;
} UdpConnEntry;


//
// Function Prototypes
//

ulong InitSnmp( void );
void *GetTable( ulong Type, ulong *pResult );
void FreeTable( GenericTable *pList );
ulong ReadTable( GenericTable *pList, ulong Type, ulong Size );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\spdprint.c ===
#include"precomp.h"

VOID PrintAddrStr(IN CHECKLIST *pcheckList, IN ADDR ResolveAddress)
//++
//Description:
//Print Address String
//
//Arguments:
//	IN CHECKLIST
//	IN ADDR
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
	HOSTENT* pHostEnt = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
    	NETDIAG_RESULT*  pResults = pcheckList->pResults;

	pHostEnt = gethostbyaddr((char *)&(ResolveAddress.uIpAddr), 4, ResolveAddress.AddrType);
	if(pHostEnt)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, DYNAMIC_SHOW_PADD, pHostEnt->h_name);
	}
}

BOOL PrintAddr(IN CHECKLIST *pcheckList, IN ADDR addr)
//++
//Description:
//Print Address
//
//Arguments:
//	IN CHECKLIST
//	IN ADDR
//	
//Return:
//	S_FALSE or S_OK
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
    struct in_addr inAddr;

    DWORD dwStrLen = 0;
    DWORD i=0, j=0;
    LPSTR pszAddr = NULL;
    LPSTR pszFAddr = NULL;
    LPSTR pszPAddr = NULL;
    NETDIAG_PARAMS* pParams = pcheckList->pParams;
    NETDIAG_RESULT*  pResults = pcheckList->pResults;


    pszPAddr = malloc(sizeof(char)*20);
    if(!pszPAddr){
    	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_SPD_MEM_ERROR );
	return S_FALSE;
    }

	if(addr.AddrType == IP_ADDR_WINS_SERVER)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, DYNAMIC_SHOW_PADD, "WINS SERVER	");
	}
	else if(addr.AddrType == IP_ADDR_DHCP_SERVER)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, DYNAMIC_SHOW_PADD, "DHCP SERVER     ");
	}
	else if(addr.AddrType == IP_ADDR_DNS_SERVER)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, DYNAMIC_SHOW_PADD, "DNS SERVER      ");
	}
	else if(addr.AddrType == IP_ADDR_DEFAULT_GATEWAY)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, DYNAMIC_SHOW_PADD, "DEFAULT GATEWAY ");
	}
	else if (addr.AddrType == IP_ADDR_UNIQUE && addr.uIpAddr == IP_ADDRESS_ME && addr.uSubNetMask == IP_ADDRESS_MASK_NONE)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_PMYADD);

	}
	else if (addr.AddrType == IP_ADDR_SUBNET && addr.uIpAddr == SUBNET_ADDRESS_ANY && addr.uSubNetMask == SUBNET_MASK_ANY)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_PANYADD);
	}
    else
    {
		memset(pszPAddr, 0, 20);
		inAddr.s_addr = addr.uIpAddr;
		pszAddr = inet_ntoa(inAddr);
		if(pszAddr != NULL)
		{
			pszFAddr = strtok( pszAddr, ".");
			for(i=0; i<4; i++)
			{
				dwStrLen = strlen(pszFAddr);
				if(dwStrLen <3)
				{
					for(j = 0 ; j<(3-dwStrLen); j++)
					{
						strcat(pszPAddr, "0");
					}
				}
				strcat(pszPAddr, pszFAddr);

				pszFAddr = strtok( NULL, ".");
				if(pszFAddr == NULL)
					break;
				strcat(pszPAddr, ".");
			}
			strcat(pszPAddr, "\0");
		}
		else
			strcpy(pszAddr, "               ");

		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
						DYNAMIC_SHOW_PADD, pszPAddr);

	}

	free(pszPAddr);
	return S_OK;
}

BOOL PrintMask(IN CHECKLIST *pcheckList,IN ADDR addr)
//++
//Description:
//Print MAsk
//
//Arguments:
//	IN CHECKLIST
//	IN ADDR
//	
//Return:
//	S_FALSE or S_OK
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--	
{
    struct in_addr inAddr;
    HRESULT hr = ERROR_SUCCESS;
    DWORD dwStrLen = 0;
    DWORD i=0, j=0;
    LPSTR pszAddr = NULL;
    LPSTR pszFAddr = NULL;
    LPTSTR pszWPAddr = NULL;
    NETDIAG_PARAMS* pParams = pcheckList->pParams;
    NETDIAG_RESULT*  pResults = pcheckList->pResults;

    pszWPAddr = (LPTSTR)malloc(sizeof(_TCHAR)*20);
    if(!pszWPAddr){
    	//print error message
    	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_SPD_MEM_ERROR );
	return S_FALSE;
    }
	

	inAddr.s_addr = addr.uSubNetMask;
	pszAddr = inet_ntoa(inAddr);

	if(pszAddr == NULL)
		_tcscpy(pszWPAddr, _TEXT("               "));
	else
		_stprintf(pszWPAddr, _TEXT("%-15S"), pszAddr);

	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					DYNAMIC_SHOW_PADD, pszWPAddr);
	free(pszWPAddr);
	return S_OK;
}

BOOL PrintTxFilter(IN CHECKLIST *pcheckList,
						IN TRANSPORT_FILTER TransF)
//++
//Description:
//Print SPD Transport Filter
//
//Arguments:
//	IN CHECKLIST
//	IN TRANSPORT_FILTER
//	
//Return:
//	S_FALSE or S_OK
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
						
{
	DWORD dwError = ERROR_SUCCESS;
	char * pmbbuf = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	////Print FilterName
	dwError = ConverWideToMultibyte(TransF.pszFilterName, &pmbbuf);
	if(dwError){
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
						Nd_Verbose, IDS_SPD_MEM_ERROR, dwError);
		return S_FALSE ;
	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_4, pmbbuf);
	FreeP(pmbbuf);	
	//Print Connection Type
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_22);
	switch(TransF.InterfaceType)
	{
		case INTERFACE_TYPE_ALL:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_5);
			break;
		case INTERFACE_TYPE_LAN:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_6);
			break;
		case INTERFACE_TYPE_DIALUP:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_7);
			break;
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_8);
			break;
	}
	
	//Print Source Address
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMSAS_PQMSAF_5);
	if(S_OK != PrintAddr(pcheckList, TransF.SrcAddr))
		return S_FALSE;
	PrintAddrStr( pcheckList, TransF.SrcAddr);
	
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMSAS_PQMSAF_6);
	
	if(S_OK != PrintAddr(pcheckList, TransF.DesAddr))
		return S_FALSE;
	PrintAddrStr(pcheckList, TransF.DesAddr);

	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_20);
	switch(TransF.Protocol.dwProtocol)
	{
		case PROT_ID_ICMP:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_ICMP);
			break;
		case PROT_ID_TCP://6
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_TCP);
			break;
		case PROT_ID_UDP://17
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_UDP);
			break;
		case PROT_ID_RAW://255
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_RAW);
			break;
		case PROT_ID_ANY://0
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_ANY);
			break;
		case PROT_ID_EGP://8
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_EGP);
			break;
		case PROT_ID_HMP://20
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_HMP);
			break;
		case PROT_ID_XNS_IDP://22
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_XNS_IDP);
			break;
		case PROT_ID_RDP://27
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_RDP);
			break;
		case PROT_ID_RVD://66
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_RVD);
			break;
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_13, TransF.Protocol.dwProtocol);
			break;

	}
	//Print Src, Des Port
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_16,
					TransF.SrcPort.wPort,TransF.DesPort.wPort);
	//Print Mirror
	if(TransF.bCreateMirror)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_17);
	}
	else
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_18);
	}
	// Print Qm Policy Name
	switch(TransF.InboundFilterAction)
		{
			case PASS_THRU:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_1);
				break;
			case NEGOTIATE_SECURITY:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_2);
				break;
			case BLOCKING:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_3);
				break;
			default:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_4);
				break;
		}
	switch(TransF.OutboundFilterAction)
		{
			case PASS_THRU:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_5);
				break;
			case NEGOTIATE_SECURITY:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_6);
				break;
			case BLOCKING:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_7);
				break;
			default:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_8);
				break;
		}
	return S_OK;
}

BOOL PrintTnFilter(IN CHECKLIST *pcheckList, IN TUNNEL_FILTER TunnelF)
//++
//Description:
//Print SPD Tunnel Filter
//
//Arguments:
//	IN CHECKLIST
//	IN TUNNEL_FILTER
//	
//Return:
//	S_FALSE or S_OK
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	DWORD dwError = ERROR_SUCCESS;
	char * pmbbuf = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	//Print FilterName
	dwError = ConverWideToMultibyte(TunnelF.pszFilterName, &pmbbuf);
	if(dwError){
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
						Nd_Verbose, IDS_SPD_MEM_ERROR, dwError);
		return S_FALSE ;
	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_4, pmbbuf);
	FreeP(pmbbuf);	

	//Print Connection Type
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_22);

	switch(TunnelF.InterfaceType)
	{
		case INTERFACE_TYPE_ALL:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_5);
			break;
		case INTERFACE_TYPE_LAN:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_6);
			break;
		case INTERFACE_TYPE_DIALUP:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_7);
			break;
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_8);
			break;
	}
	
	//Print Source Address
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMSAS_PQMSAF_5);
	if(S_OK != PrintAddr(pcheckList, TunnelF.SrcAddr))
		return S_FALSE;
	PrintAddrStr(pcheckList, TunnelF.SrcAddr);
	
	//Print Destination Address
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMSAS_PQMSAF_6);
	if(S_OK != PrintAddr(pcheckList, TunnelF.DesAddr))
		return S_FALSE;
	PrintAddrStr(pcheckList, TunnelF.DesAddr);
	
	//Print Tunnel Src
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_14);
	PrintAddr(pcheckList, TunnelF.SrcTunnelAddr);
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_15);
	PrintAddr(pcheckList, TunnelF.DesTunnelAddr);

	//Print Protocol
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMF_PQMF_20);
	switch(TunnelF.Protocol.dwProtocol)
	{
		case PROT_ID_ICMP:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_ICMP);
			break;
		case PROT_ID_TCP://6
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_TCP);
			break;
		case PROT_ID_UDP://17
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_UDP);
			break;
		case PROT_ID_RAW://255
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_RAW);
			break;
		case PROT_ID_ANY://0
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_ANY);
			break;
		case PROT_ID_EGP://8
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_EGP);
			break;
		case PROT_ID_HMP://20
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_HMP);
			break;
		case PROT_ID_XNS_IDP://22
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_XNS_IDP);
			break;
		case PROT_ID_RDP://27
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_RDP);
			break;
		case PROT_ID_RVD://66
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_RVD);
			break;
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_QMF_PQMF_13, TunnelF.Protocol.dwProtocol);
			break;

	}
	//Print Src, Des Port
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
					DYNAMIC_SHOW_QMF_PQMF_16,TunnelF.SrcPort.wPort,TunnelF.DesPort.wPort);
	//Print Mirror
	if(TunnelF.bCreateMirror)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
						DYNAMIC_SHOW_QMF_PQMF_17);
	}
	else
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
						DYNAMIC_SHOW_QMF_PQMF_18);
	}
	switch(TunnelF.InboundFilterAction)
		{
			case PASS_THRU:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
								DYNAMIC_SHOW_QMF_PQMF_1);
				break;
			case NEGOTIATE_SECURITY:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_QMF_PQMF_2);
				break;
			case BLOCKING:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_QMF_PQMF_3);
				break;
			default:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_QMF_PQMF_4);
				break;
		}
	switch(TunnelF.OutboundFilterAction)
		{
			case PASS_THRU:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_QMF_PQMF_5);
				break;
			case NEGOTIATE_SECURITY:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_QMF_PQMF_6);
				break;
			case BLOCKING:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_QMF_PQMF_7);
				break;
			default:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_QMF_PQMF_8);
				break;
		}	
	return S_OK;
}

BOOL isDefaultMMOffers(IN IPSEC_MM_POLICY MMPol)
//++
//Description:
//Checks for default MM Offer
//
//Arguments:
//	IN IPSEC_MM_POLICY
//	
//Return:
//	TRUE or FALSE
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	BOOL bDefaultOffer = FALSE;
	if(MMPol.dwOfferCount == 3)
	{

		if((MMPol.pOffers[0].EncryptionAlgorithm.uAlgoIdentifier == CONF_ALGO_3_DES)
		   &&
		   (MMPol.pOffers[0].HashingAlgorithm.uAlgoIdentifier == AUTH_ALGO_SHA1)
		   &&
		   (MMPol.pOffers[0].dwDHGroup == DH_GROUP_2)
		   &&
		   (MMPol.pOffers[1].EncryptionAlgorithm.uAlgoIdentifier == CONF_ALGO_3_DES)
		   &&
		   (MMPol.pOffers[1].HashingAlgorithm.uAlgoIdentifier == AUTH_ALGO_MD5)
		   &&
		   (MMPol.pOffers[1].dwDHGroup == DH_GROUP_2)
		   &&
		   (MMPol.pOffers[2].EncryptionAlgorithm.uAlgoIdentifier == CONF_ALGO_3_DES)
		   &&
		   (MMPol.pOffers[2].HashingAlgorithm.uAlgoIdentifier == AUTH_ALGO_SHA1)
		   &&
		   (MMPol.pOffers[2].dwDHGroup == DH_GROUP_2048))

				bDefaultOffer=TRUE;
	}
	return bDefaultOffer;
}

VOID PrintMMFilterOffer(
	IN CHECKLIST *pcheckList, 
	IN IPSEC_MM_OFFER MMOffer)
//++
//Description:
//Prints  MM Filter Offer
//
//Arguments:
//	IN CHECKLIST
//	IN IPSEC_MM_POLICY
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	//This is to display DH2048 as 3
	if(MMOffer.dwDHGroup == DH_GROUP_2048)
		MMOffer.dwDHGroup = 3;

	switch(MMOffer.EncryptionAlgorithm.uAlgoIdentifier)
	{
		case 1:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMF_PMMF_31);
			break;
		case 2:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMF_PMMF_32);
			break;
		case 3:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMF_PMMF_33);
			break;
		case 0:
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMF_PMMF_30);
			break;
	}
	switch(MMOffer.HashingAlgorithm.uAlgoIdentifier)
	{

		case 1:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMF_PMMF_35);
			break;
		case 2:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMF_PMMF_36);
			break;
		case 0:
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMF_PMMF_34);
			break;

	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					DYNAMIC_SHOW_MMF_PMMF_37,
					MMOffer.dwDHGroup, MMOffer.Lifetime.uKeyExpirationTime, MMOffer.dwQuickModeLimit );
}

DWORD DecodeCertificateName (
	IN LPBYTE EncodedName,
	IN DWORD EncodedNameLength,
	IN OUT LPTSTR *ppszSubjectName)
//++
//Description:
//Decodes the name of the certificate
//
//Arguments:
//	IN CHECKLIST
//	IN IPSEC_MM_POLICY
//	
//Return:
//	ERROR_SUCCESS or failure code
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
    DWORD DecodedNameLength=0;
	CERT_NAME_BLOB CertName;

	CertName.cbData = EncodedNameLength;
	CertName.pbData = EncodedName;

	DecodedNameLength = CertNameToStr(
		X509_ASN_ENCODING,
		&CertName,
		CERT_X500_NAME_STR,
		NULL,
		0);

	if (!DecodedNameLength)
	{
		return ERROR_INVALID_PARAMETER;
	}

	//(*ppszSubjectName)= new _TCHAR[DecodedNameLength];
	(*ppszSubjectName) = (LPSTR)malloc(sizeof(_TCHAR)*DecodedNameLength);
	if(!(*ppszSubjectName))
		return -1;
	assert (*ppszSubjectName);

	DecodedNameLength = CertNameToStr(
		X509_ASN_ENCODING,
		&CertName,
		CERT_X500_NAME_STR,
		*ppszSubjectName,
		DecodedNameLength);

	if (!DecodedNameLength)
	{
		free((*ppszSubjectName));
		(*ppszSubjectName) = 0;
		return ERROR_INVALID_PARAMETER;
	}

    return ERROR_SUCCESS;
}
BOOL PrintMMFilter(
	IN CHECKLIST *pcheckList, 
	IN MM_FILTER MMFltr)
//++
//Description:
//Print Main Mode Filter
//
//Arguments:
//	IN CHECKLIST
//	IN MM_FILTER
//	
//Return:
//	S_OK or S_FALSE
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	DWORD dwError = ERROR_SUCCESS,
			i = 0;
	LPTSTR pszCertStr = NULL, pTmp = NULL;
	char * pmbbuf = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	

	PINT_MM_AUTH_METHODS pIntMMAuth = NULL;
	PMM_AUTH_METHODS pMMAM = NULL;

	dwError = ConverWideToMultibyte(MMFltr.pszFilterName, &pmbbuf);
	if(dwError){
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
						Nd_Verbose, IDS_SPD_MEM_ERROR, dwError);
		return S_FALSE ;
	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
					DYNAMIC_SHOW_MMF_4, pmbbuf);
	FreeP(pmbbuf);	

	//Print Connection Type
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
					DYNAMIC_SHOW_MMF_PMMF_22);
	switch(MMFltr.InterfaceType)
	{
		case INTERFACE_TYPE_ALL:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							DYNAMIC_SHOW_MMF_PMMF_5);
			break;
		case INTERFACE_TYPE_LAN:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMF_PMMF_6);
			break;
		case INTERFACE_TYPE_DIALUP:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMF_PMMF_7);
			break;
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							DYNAMIC_SHOW_MMF_PMMF_8);
			break;
	}
	//Print Source Address
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
					DYNAMIC_SHOW_QMSAS_PQMSAF_5);
	if(S_OK != PrintAddr(pcheckList, MMFltr.SrcAddr))
		return S_FALSE;
	PrintAddrStr(pcheckList, MMFltr.SrcAddr);
	
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
					DYNAMIC_SHOW_QMSAS_PQMSAF_6);
	if(S_OK !=PrintAddr(pcheckList, MMFltr.DesAddr))
		return S_FALSE;
	PrintAddrStr(pcheckList, MMFltr.DesAddr);

	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
					DYNAMIC_SHOW_MMF_PMMF_23);
	if ((dwError = GetMMAuthMethods( NULL,
								     0,
								     MMFltr.gMMAuthID, 
								     &pMMAM, 
								     NULL)) == ERROR_SUCCESS)
	{
		dwError = ConvertExtMMAuthToInt(pMMAM, &pIntMMAuth);

		if(dwError == ERROR_SUCCESS)
		{
			for (i = 0; i < pIntMMAuth[0].dwNumAuthInfos; i++)
			{
				switch(pIntMMAuth[0].pAuthenticationInfo[i].AuthMethod)
				{
					case IKE_PRESHARED_KEY:
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_24);
						break;
					case IKE_DSS_SIGNATURE:
					case IKE_RSA_SIGNATURE:
					case IKE_RSA_ENCRYPTION:
						dwError = DecodeCertificateName(
										pIntMMAuth[0].pAuthenticationInfo[i].pAuthInfo, 
										pIntMMAuth[0].pAuthenticationInfo[i].dwAuthInfoSize, 
										&pszCertStr);
						if (dwError != ERROR_SUCCESS)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
											Nd_Verbose,  
											DYNAMIC_SHOW_MMF_PMMF_15);
						}
						else
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
											Nd_Verbose,  
											DYNAMIC_SHOW_MMF_PMMF_NRT);
							for (pTmp = pszCertStr; *pTmp; pTmp++)
							{
								AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
												Nd_Verbose,  
												DYNAMIC_SHOW_MMF_PMMF_25,
												*pTmp);
							}
							free(pszCertStr);
						}

						break;
					case IKE_SSPI:
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, 
										Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_26);
						break;
					default:
					break;
				}
			}
		}

		SPDApiBufferFree(pMMAM);
	}

	return S_OK;
}

VOID PrintQMOffer(
	IN CHECKLIST *pcheckList, 
	IN IPSEC_QM_OFFER QMOffer)
//++
//Description:
//Print Quick Mode Filter
//
//Arguments:
//	IN CHECKLIST
//	IN IPSEC_QM_OFFER
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	DWORD i;
	//BOOL bFlag = TRUE;
	DWORD dwFlag = 0;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;

	if(QMOffer.dwNumAlgos > 0)
	{
  		for (i = 0; i < QMOffer.dwNumAlgos; i++)
		{
			if(QMOffer.dwNumAlgos == 1)
				dwFlag = 2;

			if(dwFlag == 1 )
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
								DYNAMIC_SHOW_QMP_QMMOFFER_PLUS);
				//printf("+");
			if(QMOffer.Algos[i].Operation == AUTHENTICATION)
			{

				switch(QMOffer.Algos[i].uAlgoIdentifier)
				{
					case 1:
						if(QMOffer.dwNumAlgos == 1)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
											DYNAMIC_SHOW_QMP_QMMOFFER_1);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
											DYNAMIC_SHOW_QMP_QMMOFFER_19);
							dwFlag++;
						}
						break;
					case 2:
						if(QMOffer.dwNumAlgos == 1)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
											DYNAMIC_SHOW_QMP_QMMOFFER_2);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
											DYNAMIC_SHOW_QMP_QMMOFFER_20);
							dwFlag++;
						}
						break;
					case 0:
						if(QMOffer.dwNumAlgos == 1)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
											DYNAMIC_SHOW_QMP_QMMOFFER_3);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
											DYNAMIC_SHOW_QMP_QMMOFFER_21);
							dwFlag++;
						}
						break;
					default:
						if(QMOffer.dwNumAlgos == 1)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
											DYNAMIC_SHOW_QMP_QMMOFFER_16);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
											DYNAMIC_SHOW_QMP_QMMOFFER_22);
							dwFlag++;
						}
						break;
				}
			}
			else if(QMOffer.Algos[i].Operation == ENCRYPTION)
			{
				switch(QMOffer.Algos[i].uAlgoIdentifier)
				{
					case 1:
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
										DYNAMIC_SHOW_QMP_QMMOFFER_4);
						break;
					case 2:
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
										DYNAMIC_SHOW_QMP_QMMOFFER_5);
						break;
					case 3:
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
										DYNAMIC_SHOW_QMP_QMMOFFER_6);
						break;
					case 0:
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
										DYNAMIC_SHOW_QMP_QMMOFFER_7);
						break;
					default:
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
										DYNAMIC_SHOW_QMP_QMMOFFER_5);
						break;
				}
				switch(QMOffer.Algos[i].uSecAlgoIdentifier)
				{
					case 1:
						if(QMOffer.dwNumAlgos == 1)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 	
											DYNAMIC_SHOW_QMP_QMMOFFER_8);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
											DYNAMIC_SHOW_QMP_QMMOFFER_23);
							dwFlag++;
						}
						break;
					case 2:
						if(QMOffer.dwNumAlgos == 1)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
											DYNAMIC_SHOW_QMP_QMMOFFER_9);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
											DYNAMIC_SHOW_QMP_QMMOFFER_24);
							dwFlag++;
						}
						break;
					case 0:
						if(QMOffer.dwNumAlgos == 1)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
											DYNAMIC_SHOW_QMP_QMMOFFER_10);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
											DYNAMIC_SHOW_QMP_QMMOFFER_25);
							dwFlag++;
						}
						break;
					default:
						if(QMOffer.dwNumAlgos == 1)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
											DYNAMIC_SHOW_QMP_QMMOFFER_17);
						}
						else if(QMOffer.dwNumAlgos == 2)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
											DYNAMIC_SHOW_QMP_QMMOFFER_26);
							dwFlag++;
						}
						break;
				}
			}
			else
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_QMP_QMMOFFER_18);
			}
			//if(bFlag)
			if(dwFlag == 2)
			{
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_QMP_QMMOFFER_14, QMOffer.Lifetime.uKeyExpirationKBytes, QMOffer.Lifetime.uKeyExpirationTime);
				if(QMOffer.bPFSRequired)
				{
					if(QMOffer.dwPFSGroup == PFS_GROUP_MM)
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
										DYNAMIC_SHOW_QMP_QMMOFFER_15);
					else if(QMOffer.dwPFSGroup == PFS_GROUP_2048)
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
										DYNAMIC_SHOW_QMP_QMMOFFER_2048);
					else
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
										DYNAMIC_SHOW_QMP_QMMOFFER_12, 
										QMOffer.dwPFSGroup);
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
									DYNAMIC_SHOW_NEWLINE);
				}
				else
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
									DYNAMIC_SHOW_QMP_QMMOFFER_13);
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
								DYNAMIC_SHOW_NEWLINE);
		    }
		}
	}

}

BOOL PrintFilterAction(
	IN CHECKLIST *pcheckList, 
	IN IPSEC_QM_POLICY QMPolicy)
//++
//Description:
//Print Filter Action
//
//Arguments:
//	IN CHECKLIST
//	IN IPSEC_QM_POLICY
//	
//Return:
//	S_OK or S_FALSE
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	DWORD i;
	char * pmbbuf = NULL;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;

	i = ConverWideToMultibyte(QMPolicy.pszPolicyName, &pmbbuf);
	if(i){
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
						Nd_Verbose, IDS_SPD_MEM_ERROR, i);
		return S_FALSE ;
	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMP_6, pmbbuf);
	FreeP(pmbbuf);	

	if(QMPolicy.dwOfferCount>0)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMP_PFA_2);
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_QMP_PFA_3);
	}

	for (i = 0; i < QMPolicy.dwOfferCount; i++)
	{
		PrintQMOffer(pcheckList, QMPolicy.pOffers[i]);
	}
	return S_OK;
}

VOID PrintMMOffer(
	IN CHECKLIST *pcheckList, 
	IN IPSEC_MM_OFFER MMOffer)
//++
//Description:
//Print Main Mode Offer
//
//Arguments:
//	IN CHECKLIST
//	IN IPSEC_MM_OFFER
//	
//Return:
//	none
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	//This is to display DH2048 as 3
	if(MMOffer.dwDHGroup == DH_GROUP_2048)
		MMOffer.dwDHGroup = 3;

	switch(MMOffer.EncryptionAlgorithm.uAlgoIdentifier)
	{
		case 1:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMP_PMMOFFER_2);
			break;
		case 2:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMP_PMMOFFER_3);
			break;
		case 3:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							DYNAMIC_SHOW_MMP_PMMOFFER_4);
			break;
		case 0:
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMP_PMMOFFER_1);
			break;

	}
	switch(MMOffer.HashingAlgorithm.uAlgoIdentifier)
	{

		case 1:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							DYNAMIC_SHOW_MMP_PMMOFFER_6);
			break;
		case 2:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMP_PMMOFFER_7);
			break;
		case 0:
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
							DYNAMIC_SHOW_MMP_PMMOFFER_5);
			break;

	}

	if(MMOffer.dwQuickModeLimit != 1)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
						DYNAMIC_SHOW_MMP_PMMOFFER_10,MMOffer.dwDHGroup, 
						MMOffer.Lifetime.uKeyExpirationKBytes, 
						MMOffer.Lifetime.uKeyExpirationTime, MMOffer.dwQuickModeLimit );
	}
	else
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
						DYNAMIC_SHOW_MMP_PMMOFFER_11,MMOffer.dwDHGroup, 
						MMOffer.Lifetime.uKeyExpirationKBytes, 
						MMOffer.Lifetime.uKeyExpirationTime);//MMOffer.dwQuickModeLimit );
	}
}

BOOL PrintMMPolicy(
	IN CHECKLIST *pcheckList, 
	IN IPSEC_MM_POLICY MMPolicy)
//++
//Description:
//Print Main Mode Policy
//
//Arguments:
//	IN CHECKLIST
//	IN IPSEC_MM_POLICY
//	
//Return:
//	S_OK or S_FALSE
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	DWORD i;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	char * pmbbuf = NULL;

	i = ConverWideToMultibyte(MMPolicy.pszPolicyName , &pmbbuf);
	if(i){
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput,
						Nd_Verbose, IDS_SPD_MEM_ERROR, i);
		return S_FALSE ;
	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
					DYNAMIC_SHOW_POLNAME, pmbbuf);
	FreeP(pmbbuf);	

	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
					DYNAMIC_SHOW_SOFTSA,  MMPolicy.uSoftExpirationTime);

	if(MMPolicy.dwOfferCount>0)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
						DYNAMIC_SHOW_MMP_PP_2);
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
						DYNAMIC_SHOW_MMP_PP_3);
	}
	for (i = 0; i < MMPolicy.dwOfferCount; i++)
	{
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  
						DYNAMIC_SHOW_NEWLINE);
		PrintMMOffer(pcheckList, MMPolicy.pOffers[i]);

	}
	return S_OK;
}

BOOL PrintMMAuth(IN CHECKLIST *pcheckList, PINT_MM_AUTH_METHODS pIntMMAuth)
//++
//Description:
//Print Main Mode Auth
//
//Arguments:
//	IN CHECKLIST
//	IN PINT_MM_AUTH_METHODS
//	
//Return:
//	S_OK or S_FALSE
//
//Author:
//	Madhurima Pawar (mpawar) 10/15/01
//--
{
	LPTSTR pszCertStr = NULL, pTmp = NULL;
	DWORD i, dwReturn = ERROR_SUCCESS;
	NETDIAG_PARAMS* pParams = pcheckList->pParams;
	NETDIAG_RESULT*  pResults = pcheckList->pResults;
	
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_23);
	

	if(pIntMMAuth){
			for (i = 0; i < pIntMMAuth[0].dwNumAuthInfos; i++)
			{
				switch(pIntMMAuth[0].pAuthenticationInfo[i].AuthMethod)
				{
					case IKE_PRESHARED_KEY:
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_24);
						break;
					case IKE_DSS_SIGNATURE:
					case IKE_RSA_SIGNATURE:
					case IKE_RSA_ENCRYPTION:
						dwReturn = DecodeCertificateName(pIntMMAuth[0].pAuthenticationInfo[i].pAuthInfo, pIntMMAuth[0].pAuthenticationInfo[i].dwAuthInfoSize, &pszCertStr);
						if (dwReturn != ERROR_SUCCESS)
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_15);
						}
						else
						{
							AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_NRT);
							for (pTmp = pszCertStr; *pTmp; pTmp++)
							{
								AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_25,*pTmp);
							}
							free(pszCertStr);
						}

						break;
					case IKE_SSPI:
						AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose,  DYNAMIC_SHOW_MMF_PMMF_26);
						break;
					default:
					break;
				}
			}
		}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\strings.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       strings.c
//
//--------------------------------------------------------------------------

#include "precomp.h"

#include "strings.h"
#define _STRINGS_DEFINE_STRINGS
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\spdres.h ===
#ifndef HEADER_SPDRES
# define HEADER_SPDRES

 //
// Common defs..
//
#define HLP_IPSEC_BASE                   		20000

#define HLP_STATIC_BASE            		 		1000
#define HLP_DYNAMIC_BASE           		 		2000
#define SHW_STATIC_BASE							3000
#define SHW_DYANMIC_BASE						9000
#define HLP_ERROR_BASE           		 		12000 // Frame Work Error Base

#define HLP_TOPLEVEL_BASE            	 		100
#define HLP_ADD_BASE            		 		200
#define HLP_SET_BASE            		 		300
#define HLP_DELETE_BASE         		 		400
#define HLP_SHOW_BASE           		 		500
/////////////////////////////////////////////////////////////////////////////////

#define DYNAMIC_SHOW_POLANDOFFERS			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 1
#define DYNAMIC_SHOW_POLNAME					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 2
#define DYNAMIC_SHOW_OFFERS					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 3
#define DYNAMIC_SHOW_PMYADD					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 4
#define DYNAMIC_SHOW_PANYADD					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 5
#define DYNAMIC_SHOW_PADD					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 6
#define DYNAMIC_SHOW_NEWLINE					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 7
#define DYNAMIC_SHOW_ICMP						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 8
#define DYNAMIC_SHOW_TCP						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 9
#define DYNAMIC_SHOW_UDP						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 10
#define DYNAMIC_SHOW_RAW						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 11
#define DYNAMIC_SHOW_ANY						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 12
#define DYNAMIC_SHOW_EGP						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 13
#define DYNAMIC_SHOW_HMP						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 14
#define DYNAMIC_SHOW_XNS_IDP					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 15
#define DYNAMIC_SHOW_RDP						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 16
#define DYNAMIC_SHOW_RVD						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 17
#define DYNAMIC_SHOW_SOFTSA					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 18
#define DYNAMIC_SHOW_WINS					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 19
#define DYNAMIC_SHOW_DHCP						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 20
#define DYNAMIC_SHOW_DNS						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 21
#define DYNAMIC_SHOW_GATEWAY				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 22
#define DYNAMIC_SHOW_ADDR_STR				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 23
#define NSHIPSEC_DLL							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 24
#define NSHIPSEC_CHECK							HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 25

#define	DYNAMIC_SHOW_MMP_1						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 100
#define	DYNAMIC_SHOW_MMP_2						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 101
#define	DYNAMIC_SHOW_MMP_3						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 102
#define	DYNAMIC_SHOW_MMP_4						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 103
#define	DYNAMIC_SHOW_MMP_5						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 104
#define	DYNAMIC_SHOW_MMP_PP_1					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 105
#define	DYNAMIC_SHOW_MMP_PP_2					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 106
#define	DYNAMIC_SHOW_MMP_PP_3					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 107

#define	DYNAMIC_SHOW_MMP_PMMOFFER_1			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 120
#define	DYNAMIC_SHOW_MMP_PMMOFFER_2			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 121
#define	DYNAMIC_SHOW_MMP_PMMOFFER_3			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 122
#define	DYNAMIC_SHOW_MMP_PMMOFFER_4			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 123
#define	DYNAMIC_SHOW_MMP_PMMOFFER_8			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 124
#define	DYNAMIC_SHOW_MMP_PMMOFFER_5			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 125
#define	DYNAMIC_SHOW_MMP_PMMOFFER_6			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 126
#define	DYNAMIC_SHOW_MMP_PMMOFFER_7			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 127
#define	DYNAMIC_SHOW_MMP_PMMOFFER_9			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 128
#define	DYNAMIC_SHOW_MMP_PMMOFFER_10			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 129
#define	DYNAMIC_SHOW_MMP_PMMOFFER_11			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 130




#define	DYNAMIC_SHOW_QMP_1						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 151
#define	DYNAMIC_SHOW_QMP_2						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 152
#define	DYNAMIC_SHOW_QMP_3						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 153
#define	DYNAMIC_SHOW_QMP_4						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 154
#define	DYNAMIC_SHOW_QMP_5						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 155
#define	DYNAMIC_SHOW_QMP_6						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 156


#define	DYNAMIC_SHOW_QMP_PFA_1					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 157
#define	DYNAMIC_SHOW_QMP_PFA_2					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 158
#define	DYNAMIC_SHOW_QMP_PFA_3					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 159


#define	DYNAMIC_SHOW_QMP_QMMOFFER_1				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 165
#define	DYNAMIC_SHOW_QMP_QMMOFFER_2				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 166
#define	DYNAMIC_SHOW_QMP_QMMOFFER_3				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 167
#define	DYNAMIC_SHOW_QMP_QMMOFFER_4				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 168
#define	DYNAMIC_SHOW_QMP_QMMOFFER_5				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 169
#define	DYNAMIC_SHOW_QMP_QMMOFFER_6				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 170
#define	DYNAMIC_SHOW_QMP_QMMOFFER_7				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 171
#define	DYNAMIC_SHOW_QMP_QMMOFFER_8				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 172
#define	DYNAMIC_SHOW_QMP_QMMOFFER_9				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 173
#define	DYNAMIC_SHOW_QMP_QMMOFFER_10			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 174
#define	DYNAMIC_SHOW_QMP_QMMOFFER_11			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 175
#define	DYNAMIC_SHOW_QMP_QMMOFFER_12			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 176
#define	DYNAMIC_SHOW_QMP_QMMOFFER_13			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 177
#define	DYNAMIC_SHOW_QMP_QMMOFFER_14			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 178
#define	DYNAMIC_SHOW_QMP_QMMOFFER_15			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 179
#define	DYNAMIC_SHOW_QMP_QMMOFFER_2048			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 180
#define DYNAMIC_SHOW_QMP_QMMOFFER_16			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 181
#define DYNAMIC_SHOW_QMP_QMMOFFER_17			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 182
#define DYNAMIC_SHOW_QMP_QMMOFFER_18			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 183
#define DYNAMIC_SHOW_QMP_QMMOFFER_19			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 184
#define DYNAMIC_SHOW_QMP_QMMOFFER_20			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 185
#define DYNAMIC_SHOW_QMP_QMMOFFER_21			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 186
#define DYNAMIC_SHOW_QMP_QMMOFFER_22			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 187
#define DYNAMIC_SHOW_QMP_QMMOFFER_23			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 188
#define DYNAMIC_SHOW_QMP_QMMOFFER_24			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 189
#define DYNAMIC_SHOW_QMP_QMMOFFER_25			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 190
#define DYNAMIC_SHOW_QMP_QMMOFFER_26			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 191
#define DYNAMIC_SHOW_QMP_QMMOFFER_PLUS			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 192


#define	DYNAMIC_SHOW_MMF_1						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 200
#define	DYNAMIC_SHOW_MMF_2						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 201
#define	DYNAMIC_SHOW_MMF_3						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 202
#define	DYNAMIC_SHOW_MMF_4						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 203
#define	DYNAMIC_SHOW_MMF_5						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 204
#define	DYNAMIC_SHOW_MMF_6						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 205
#define DYNAMIC_SHOW_MMF_13						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 206

#define	DYNAMIC_SHOW_MMF_PMMF_1				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 215
#define	DYNAMIC_SHOW_MMF_PMMF_2				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 216
#define	DYNAMIC_SHOW_MMF_PMMF_3				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 217
#define	DYNAMIC_SHOW_MMF_PMMF_4				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 218
#define	DYNAMIC_SHOW_MMF_PMMF_5				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 219
#define	DYNAMIC_SHOW_MMF_PMMF_6				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 220
#define	DYNAMIC_SHOW_MMF_PMMF_7				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 221
#define	DYNAMIC_SHOW_MMF_PMMF_8				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 222
#define	DYNAMIC_SHOW_MMF_PMMF_9				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 223
#define	DYNAMIC_SHOW_MMF_PMMF_10				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 224
#define	DYNAMIC_SHOW_MMF_PMMF_11				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 225
#define	DYNAMIC_SHOW_MMF_PMMF_12				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 226
#define	DYNAMIC_SHOW_MMF_PMMF_13				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 227
#define	DYNAMIC_SHOW_MMF_PMMF_14				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 228
#define	DYNAMIC_SHOW_MMF_PMMF_15				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 229
#define	DYNAMIC_SHOW_MMF_PMMF_16				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 230
#define	DYNAMIC_SHOW_MMF_PMMF_17				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 231
#define	DYNAMIC_SHOW_MMF_PMMF_18				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 232
#define	DYNAMIC_SHOW_MMF_PMMF_19				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 233
#define	DYNAMIC_SHOW_MMF_PMMF_20				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 234
#define	DYNAMIC_SHOW_MMF_PMMF_21				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 235
#define	DYNAMIC_SHOW_MMF_PMMF_22				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 236
#define	DYNAMIC_SHOW_MMF_PMMF_23				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 237
#define	DYNAMIC_SHOW_MMF_PMMF_24				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 238
#define	DYNAMIC_SHOW_MMF_PMMF_25				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 239
#define	DYNAMIC_SHOW_MMF_PMMF_26				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 240
#define	DYNAMIC_SHOW_MMF_PMMF_27				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 241
#define	DYNAMIC_SHOW_MMF_PMMF_28				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 242
#define	DYNAMIC_SHOW_MMF_PMMF_29				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 243
#define	DYNAMIC_SHOW_MMF_PMMF_30				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 244
#define	DYNAMIC_SHOW_MMF_PMMF_31				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 245
#define	DYNAMIC_SHOW_MMF_PMMF_32				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 246
#define	DYNAMIC_SHOW_MMF_PMMF_33				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 247
#define	DYNAMIC_SHOW_MMF_PMMF_34				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 248
#define	DYNAMIC_SHOW_MMF_PMMF_35				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 249
#define	DYNAMIC_SHOW_MMF_PMMF_36				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 250
#define	DYNAMIC_SHOW_MMF_PMMF_37				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 251
#define	DYNAMIC_SHOW_MMF_PMMF_NRT				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 252



#define	DYNAMIC_SHOW_QMF_1						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 260
#define	DYNAMIC_SHOW_QMF_2						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 261
#define	DYNAMIC_SHOW_QMF_3						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 262
#define	DYNAMIC_SHOW_QMF_4						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 263
#define	DYNAMIC_SHOW_QMF_5						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 264
#define	DYNAMIC_SHOW_QMF_6						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 265

#define	DYNAMIC_SHOW_QMF_PQMF_1				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 280
#define	DYNAMIC_SHOW_QMF_PQMF_2				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 281
#define	DYNAMIC_SHOW_QMF_PQMF_3				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 282
#define	DYNAMIC_SHOW_QMF_PQMF_4				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 283
#define	DYNAMIC_SHOW_QMF_PQMF_5				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 284
#define	DYNAMIC_SHOW_QMF_PQMF_6				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 285
#define	DYNAMIC_SHOW_QMF_PQMF_7				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 286
#define	DYNAMIC_SHOW_QMF_PQMF_8				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 287
#define	DYNAMIC_SHOW_QMF_PQMF_9				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 288
#define	DYNAMIC_SHOW_QMF_PQMF_10				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 289
#define	DYNAMIC_SHOW_QMF_PQMF_11				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 290
#define	DYNAMIC_SHOW_QMF_PQMF_12				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 291
#define	DYNAMIC_SHOW_QMF_PQMF_13				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 292
#define	DYNAMIC_SHOW_QMF_PQMF_14				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 293
#define	DYNAMIC_SHOW_QMF_PQMF_15				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 294
#define	DYNAMIC_SHOW_QMF_PQMF_16				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 295
#define	DYNAMIC_SHOW_QMF_PQMF_17				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 296
#define	DYNAMIC_SHOW_QMF_PQMF_18				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 297
#define	DYNAMIC_SHOW_QMF_PQMF_19				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 298
#define	DYNAMIC_SHOW_QMF_PQMF_20				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 299



#define	DYNAMIC_SHOW_STATS_1					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 300
#define	DYNAMIC_SHOW_STATS_2					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 301
#define	DYNAMIC_SHOW_STATS_3					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 302
#define	DYNAMIC_SHOW_STATS_4					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 303
#define	DYNAMIC_SHOW_STATS_5					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 304
#define	DYNAMIC_SHOW_STATS_6					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 305
#define	DYNAMIC_SHOW_STATS_7					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 306
#define	DYNAMIC_SHOW_STATS_8					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 307
#define	DYNAMIC_SHOW_STATS_9					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 308
#define	DYNAMIC_SHOW_STATS_10					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 309
#define	DYNAMIC_SHOW_STATS_11					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 310
#define	DYNAMIC_SHOW_STATS_12					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 311
#define	DYNAMIC_SHOW_STATS_13					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 312
#define	DYNAMIC_SHOW_STATS_14					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 313
#define	DYNAMIC_SHOW_STATS_15					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 314
#define	DYNAMIC_SHOW_STATS_16					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 315
#define	DYNAMIC_SHOW_STATS_17					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 316
#define	DYNAMIC_SHOW_STATS_18					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 317
#define	DYNAMIC_SHOW_STATS_19					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 318
#define	DYNAMIC_SHOW_STATS_20					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 319
#define	DYNAMIC_SHOW_STATS_21					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 320
#define	DYNAMIC_SHOW_STATS_22					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 321
#define	DYNAMIC_SHOW_STATS_23					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 322
#define	DYNAMIC_SHOW_STATS_24					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 323
#define	DYNAMIC_SHOW_STATS_25					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 324
#define	DYNAMIC_SHOW_STATS_26					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 325
#define	DYNAMIC_SHOW_STATS_27					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 326
#define	DYNAMIC_SHOW_STATS_28					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 327
#define	DYNAMIC_SHOW_STATS_29					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 328
#define	DYNAMIC_SHOW_STATS_30					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 329
#define	DYNAMIC_SHOW_STATS_31					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 330
#define	DYNAMIC_SHOW_STATS_32					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 331
#define	DYNAMIC_SHOW_STATS_33					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 332
#define	DYNAMIC_SHOW_STATS_34					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 333
#define	DYNAMIC_SHOW_STATS_35					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 334
#define	DYNAMIC_SHOW_STATS_36					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 335
#define	DYNAMIC_SHOW_STATS_37					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 336
#define	DYNAMIC_SHOW_STATS_38					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 337
#define	DYNAMIC_SHOW_STATS_39					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 338
#define	DYNAMIC_SHOW_STATS_40					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 339
#define	DYNAMIC_SHOW_STATS_41					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 340
#define	DYNAMIC_SHOW_STATS_42					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 341
#define	DYNAMIC_SHOW_STATS_43					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 342
#define	DYNAMIC_SHOW_STATS_44					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 343
#define	DYNAMIC_SHOW_STATS_45					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 344
#define	DYNAMIC_SHOW_STATS_46					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 345


#define	DYNAMIC_SHOW_MMSAS_PMMSAS_1				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 350
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_2				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 351
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_3				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 352
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_4				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 353
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_5				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 354
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_6				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 355
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_7				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 356
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_8				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 357
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_9				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 358
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_10			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 359
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_11			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 360
#define	DYNAMIC_SHOW_MMSAS_PMMSAS_12			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 361


#define	DYNAMIC_SHOW_QMSAS_PQMSAF_1				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 410
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_2				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 411
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_3				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 412
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_4				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 413
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_5				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 414
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_6				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 415
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_7				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 416
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_8				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 417
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_9				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 418
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_10			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 419
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_11			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 420
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_12			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 421
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_13			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 422
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_14			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 423
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_15			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 424
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_16			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 425
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_17			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 426
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_18			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 427
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_19			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 428
#define DYNAMIC_SHOW_QMSAS_PQMSAF_20			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 429
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_21			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 430
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_22			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 431
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_23			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 432
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_24			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 433
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_25			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 434
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_26			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 435
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_27			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 436
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_28   			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 437
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_29			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 438
#define	DYNAMIC_SHOW_QMSAS_PQMSAF_30			HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 439




#define	DYNAMIC_SHOW_QMSAS_PQMSAS_1				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 440
#define	DYNAMIC_SHOW_QMSAS_PQMSAS_2				HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 441

#define DYNAMIC_SHOW_REG_1						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 450
#define DYNAMIC_SHOW_REG_2						HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 451
#define DYNAMIC_SHOW_REG_3  					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 452
#define DYNAMIC_SHOW_REG_4  					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 453
#define DYNAMIC_SHOW_REG_5  					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 454
#define DYNAMIC_SHOW_REG_6  					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 455
#define DYNAMIC_SHOW_REG_7  					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 456
#define DYNAMIC_SHOW_REG_8  					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 457
#define DYNAMIC_SHOW_REG_9  					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 458
#define DYNAMIC_SHOW_REG_10 					HLP_IPSEC_BASE + SHW_DYANMIC_BASE + 459


/////////////////////////////////////////////////////////////////////////////////

#define SHW_STATIC_TAB_BASE						SHW_STATIC_BASE + 3000

#define SHW_STATIC_TAB_POLICY_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1
#define SHW_STATIC_TAB_POLICY_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2
#define SHW_STATIC_TAB_POLICY_6						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 6
#define SHW_STATIC_TAB_POLICY_7						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 7
#define SHW_STATIC_TAB_POLICY_8						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 8
#define SHW_STATIC_TAB_POLICY_9						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 9
#define SHW_STATIC_TAB_POLICY_10					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 10
#define SHW_STATIC_TAB_POLICY_11					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 11



#define SHW_STATIC_TAB_FILTERLIST_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 100
#define SHW_STATIC_TAB_FILTERLIST_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 101
#define SHW_STATIC_TAB_FILTERLIST_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 103

#define SHW_STATIC_TAB_FILTERACTION_1					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 200
#define SHW_STATIC_TAB_FILTERACTION_2					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 201
#define SHW_STATIC_TAB_FILTERACTION_3					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 202
#define SHW_STATIC_TAB_FILTERACTION_4					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 203

#define SHW_STATIC_TAB_RULE_4							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 303
#define SHW_STATIC_TAB_RULE_5							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 304
#define SHW_STATIC_TAB_RULE_6							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 305
#define SHW_STATIC_TAB_RULE_7							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 306


#define SHW_STATIC_TAB_DEFRULE_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 402
#define SHW_STATIC_TAB_DEFRULE_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 403
#define SHW_STATIC_TAB_DEFRULE_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 404

#define SHW_STATIC_TAB_ALL_1							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 500
#define SHW_STATIC_TAB_ALL_2							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 501

#define SHW_STATIC_TAB_PRTPOLICY_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 600
#define SHW_STATIC_TAB_PRTPOLICY_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 601
#define SHW_STATIC_TAB_PRTPOLICY_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 602
#define SHW_STATIC_TAB_PRTPOLICY_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 603
#define SHW_STATIC_TAB_PRTPOLICY_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 604
#define SHW_STATIC_TAB_PRTPOLICY_6						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 605
#define SHW_STATIC_TAB_PRTPOLICY_7						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 606
#define SHW_STATIC_TAB_PRTPOLICY_8						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 607
#define SHW_STATIC_TAB_PRTPOLICY_9						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 608
#define SHW_STATIC_TAB_PRTPOLICY_10						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 609
#define SHW_STATIC_TAB_PRTPOLICY_11						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 610
#define SHW_STATIC_TAB_PRTPOLICY_12						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 611
#define SHW_STATIC_TAB_PRTPOLICY_13						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 612
#define SHW_STATIC_TAB_PRTPOLICY_14						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 613
#define SHW_STATIC_TAB_PRTPOLICY_15						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 614
#define SHW_STATIC_TAB_PRTPOLICY_16						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 615
#define SHW_STATIC_TAB_PRTPOLICY_17						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 616
#define SHW_STATIC_TAB_PRTPOLICY_18						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 617
#define SHW_STATIC_TAB_PRTPOLICY_19						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 618
#define SHW_STATIC_TAB_PRTPOLICY_20						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 619
#define SHW_STATIC_TAB_PRTPOLICY_21						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 620
#define SHW_STATIC_TAB_PRTPOLICY_22						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 621

#define SHW_STATIC_TAB_PRTRULE_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 700
#define SHW_STATIC_TAB_PRTRULE_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 701
#define SHW_STATIC_TAB_PRTRULE_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 703
#define SHW_STATIC_TAB_PRTRULE_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 704
#define SHW_STATIC_TAB_PRTRULE_6						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 705
#define SHW_STATIC_TAB_PRTRULE_7						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 706
#define SHW_STATIC_TAB_PRTRULE_8						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 707
#define SHW_STATIC_TAB_PRTRULE_9						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 708
#define SHW_STATIC_TAB_PRTRULE_10						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 709
#define SHW_STATIC_TAB_PRTRULE_11						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 710
#define SHW_STATIC_TAB_PRTRULE_12						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 711
#define SHW_STATIC_TAB_PRTRULE_13						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 712
#define SHW_STATIC_TAB_PRTRULE_14						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 713
#define SHW_STATIC_TAB_PRTRULE_15						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 714
#define SHW_STATIC_TAB_PRTRULE_16						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 715
#define SHW_STATIC_TAB_PRTRULE_17						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 716
#define SHW_STATIC_TAB_PRTRULE_18						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 717
#define SHW_STATIC_TAB_PRTRULE_19						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 718
#define SHW_STATIC_TAB_PRTRULE_20						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 719
#define SHW_STATIC_TAB_PRTRULE_21						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 720
#define SHW_STATIC_TAB_PRTRULE_22						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 721
#define SHW_STATIC_TAB_PRTRULE_23						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 722
#define SHW_STATIC_TAB_PRTRULE_24						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 723
#define SHW_STATIC_TAB_PRTRULE_25						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 724
#define SHW_STATIC_TAB_PRTRULE_26						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 725
#define SHW_STATIC_TAB_PRTRULE_27						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 726
#define SHW_STATIC_TAB_PRTRULE_28						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 727
#define SHW_STATIC_TAB_PRTRULE_29						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 728
#define SHW_STATIC_TAB_PRTRULE_30						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 729
#define SHW_STATIC_TAB_PRTRULE_31						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 730
#define SHW_STATIC_TAB_PRTRULE_32						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 731
#define SHW_STATIC_TAB_PRTRULE_33						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 732
#define SHW_STATIC_TAB_PRTRULE_34						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 733
#define SHW_STATIC_TAB_PRTRULE_35						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 734
#define SHW_STATIC_TAB_PRTRULE_36						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 735
#define SHW_STATIC_TAB_PRTRULE_37						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 736
#define SHW_STATIC_TAB_PRTRULE_38						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 737
#define SHW_STATIC_TAB_PRTRULE_39						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 738


#define SHW_STATIC_TAB_PRTNEGPOL_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 800
#define SHW_STATIC_TAB_PRTNEGPOL_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 801
#define SHW_STATIC_TAB_PRTNEGPOL_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 802
#define SHW_STATIC_TAB_PRTNEGPOL_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 803
#define SHW_STATIC_TAB_PRTNEGPOL_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 804
#define SHW_STATIC_TAB_PRTNEGPOL_6						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 805
#define SHW_STATIC_TAB_PRTNEGPOL_7						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 806
#define SHW_STATIC_TAB_PRTNEGPOL_8						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 807
#define SHW_STATIC_TAB_PRTNEGPOL_9						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 808
#define SHW_STATIC_TAB_PRTNEGPOL_10						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 809
#define SHW_STATIC_TAB_PRTNEGPOL_11						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 810
#define SHW_STATIC_TAB_PRTNEGPOL_12						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 811
#define SHW_STATIC_TAB_PRTNEGPOL_13						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 812
#define SHW_STATIC_TAB_PRTNEGPOL_14						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 813
#define SHW_STATIC_TAB_PRTNEGPOL_15						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 814
#define SHW_STATIC_TAB_PRTNEGPOL_16						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 815
#define SHW_STATIC_TAB_PRTNEGPOL_17						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 816
#define SHW_STATIC_TAB_PRTNEGPOL_18						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 817
#define SHW_STATIC_TAB_PRTNEGPOL_19						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 818
#define SHW_STATIC_TAB_PRTNEGPOL_20						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 819
#define SHW_STATIC_TAB_PRTNEGPOL_21						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 820
#define SHW_STATIC_TAB_PRTNEGPOL_22						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 821
#define SHW_STATIC_TAB_PRTNEGPOL_23						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 822
#define SHW_STATIC_TAB_PRTNEGPOL_24						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 823
#define SHW_STATIC_TAB_PRTNEGPOL_25						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 824
#define SHW_STATIC_TAB_PRTNEGPOL_26						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 825


#define SHW_STATIC_TAB_PRTALGO_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1000
#define SHW_STATIC_TAB_PRTALGO_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1001
#define SHW_STATIC_TAB_PRTALGO_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1002
#define SHW_STATIC_TAB_PRTALGO_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1003
#define SHW_STATIC_TAB_PRTALGO_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1004
#define SHW_STATIC_TAB_PRTALGO_6						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1005
#define SHW_STATIC_TAB_PRTALGO_7						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1006
#define SHW_STATIC_TAB_PRTALGO_8						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1007
#define SHW_STATIC_TAB_PRTALGO_9						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1008
#define SHW_STATIC_TAB_PRTALGO_10						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1009
#define SHW_STATIC_TAB_PRTALGO_11						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1010
#define SHW_STATIC_TAB_PRTALGO_12						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1011
#define SHW_STATIC_TAB_PRTALGO_13						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1012
#define SHW_STATIC_TAB_PRTALGO_14						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1013

#define SHW_STATIC_TAB_PRTLIFE_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1100

#define SHW_STATIC_TAB_PRTAUTH_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1200
#define SHW_STATIC_TAB_PRTAUTH_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1201
#define SHW_STATIC_TAB_PRTAUTH_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1202
#define SHW_STATIC_TAB_PRTAUTH_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1203

#define SHW_STATIC_TAB_PRTFILTERDATA_1					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1300
#define SHW_STATIC_TAB_PRTFILTERDATA_2					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1301
#define SHW_STATIC_TAB_PRTFILTERDATA_3					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1302
#define SHW_STATIC_TAB_PRTFILTERDATA_4					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1303
#define SHW_STATIC_TAB_PRTFILTERDATA_5					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1304
#define SHW_STATIC_TAB_PRTFILTERDATA_6					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1305
#define SHW_STATIC_TAB_PRTFILTERDATA_7					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1306
#define SHW_STATIC_TAB_PRTFILTERDATA_8					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1307
#define SHW_STATIC_TAB_PRTFILTERDATA_9					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1308
#define SHW_STATIC_TAB_PRTFILTERDATA_10	 				HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1309
#define SHW_STATIC_TAB_PRTFILTERDATA_11					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1310

#define SHW_STATIC_TAB_PRTIP_1							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1400
#define SHW_STATIC_TAB_PRTIP_2							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1401
#define SHW_STATIC_TAB_PRTIP_3							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1402
#define SHW_STATIC_TAB_PRTIP_4							HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1403

#define SHW_STATIC_TAB_PRTFSPEC_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1500
#define SHW_STATIC_TAB_PRTFSPEC_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1501
#define SHW_STATIC_TAB_PRTFSPEC_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1502
#define SHW_STATIC_TAB_PRTFSPEC_6						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1505
#define SHW_STATIC_TAB_PRTFSPEC_7						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1506
#define SHW_STATIC_TAB_PRTFSPEC_8						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1507
#define SHW_STATIC_TAB_PRTFSPEC_9						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1508
#define SHW_STATIC_TAB_PRTFSPEC_10						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1509
#define SHW_STATIC_TAB_PRTFSPEC_11						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1510
#define SHW_STATIC_TAB_PRTFSPEC_12						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1511
#define SHW_STATIC_TAB_PRTFSPEC_13						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1512
#define SHW_STATIC_TAB_PRTFSPEC_14						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1513
#define SHW_STATIC_TAB_PRTFSPEC_15						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1514
#define SHW_STATIC_TAB_PRTFSPEC_16						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1515

#define SHW_STATIC_TAB_PRTFILTER_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1600
#define SHW_STATIC_TAB_PRTFILTER_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1601
#define SHW_STATIC_TAB_PRTFILTER_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1602
#define SHW_STATIC_TAB_PRTFILTER_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1603
#define SHW_STATIC_TAB_PRTFILTER_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1604
#define SHW_STATIC_TAB_PRTFILTER_6						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1605
#define SHW_STATIC_TAB_PRTFILTER_7						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1606
#define SHW_STATIC_TAB_PRTFILTER_8						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1607
#define SHW_STATIC_TAB_PRTFILTER_9						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1608
#define SHW_STATIC_TAB_PRTFILTER_10						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1609
#define SHW_STATIC_TAB_PRTFILTER_11						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1610
#define SHW_STATIC_TAB_PRTFILTER_12						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1611
#define SHW_STATIC_TAB_PRTFILTER_13						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1612
#define SHW_STATIC_TAB_PRTFILTER_14						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1613
#define SHW_STATIC_TAB_PRTFILTER_15						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1614

#define SHW_STATIC_TAB_PRTPROTOCOL_1					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1700
#define SHW_STATIC_TAB_PRTPROTOCOL_2					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1701
#define SHW_STATIC_TAB_PRTPROTOCOL_3					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1702
#define SHW_STATIC_TAB_PRTPROTOCOL_4					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1703
#define SHW_STATIC_TAB_PRTPROTOCOL_5					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1704
#define SHW_STATIC_TAB_PRTPROTOCOL_6					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1705
#define SHW_STATIC_TAB_PRTPROTOCOL_7					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1706
#define SHW_STATIC_TAB_PRTPROTOCOL_8					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1707
#define SHW_STATIC_TAB_PRTPROTOCOL_9					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1708
#define SHW_STATIC_TAB_PRTPROTOCOL_10					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1709


#define SHW_STATIC_TAB_PRTISAKMP_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1801
#define SHW_STATIC_TAB_PRTISAKMP_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1802
#define SHW_STATIC_TAB_PRTISAKMP_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1803
#define SHW_STATIC_TAB_PRTISAKMP_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1804
#define SHW_STATIC_TAB_PRTISAKMP_6						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1805

#define SHW_STATIC_TAB_PRTISAKMPSEC_1					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1900
#define SHW_STATIC_TAB_PRTISAKMPSEC_2					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1901
#define SHW_STATIC_TAB_PRTISAKMPSEC_3					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1902
#define SHW_STATIC_TAB_PRTISAKMPSEC_4					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1903
#define SHW_STATIC_TAB_PRTISAKMPSEC_5					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1904
#define SHW_STATIC_TAB_PRTISAKMPSEC_6					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1905
#define SHW_STATIC_TAB_PRTISAKMPSEC_7					HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 1906

#define SHW_STATIC_TAB_PRTSAFA_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2000
#define SHW_STATIC_TAB_PRTSAFA_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2001
#define SHW_STATIC_TAB_PRTSAFA_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2002
#define SHW_STATIC_TAB_PRTSAFA_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2003
#define SHW_STATIC_TAB_PRTSAFA_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2004

#define SHW_STATIC_TAB_PRTSAFL_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2100
#define SHW_STATIC_TAB_PRTSAFL_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2101
#define SHW_STATIC_TAB_PRTSAFL_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2102
#define SHW_STATIC_TAB_PRTSAFL_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2103
#define SHW_STATIC_TAB_PRTSAFL_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2104

#define SHW_STATIC_TAB_PRTALLFL_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2200
#define SHW_STATIC_TAB_PRTALLFL_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2204


#define SHW_STATIC_TAB_PRTALLFL_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2203

#define SHW_STATIC_TAB_PRTALLFA_1						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2300
#define SHW_STATIC_TAB_PRTALLFA_2						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2301
#define SHW_STATIC_TAB_PRTALLFA_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2302
#define SHW_STATIC_TAB_PRTALLFA_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2303
#define SHW_STATIC_TAB_PRTALLFA_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2304




#define SHW_STATIC_TAB_ASSIGNPOL_3						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2352
#define SHW_STATIC_TAB_ASSIGNPOL_4						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2353
#define SHW_STATIC_TAB_ASSIGNPOL_5						HLP_IPSEC_BASE + SHW_STATIC_TAB_BASE + 2354

 
// for list out put added today by surya (5/10/2001 - Friday)

///////////////////////////////Static Show List group/////////////////////////////////////////////////////////////
#define SHW_STATIC_POLICY_1						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1

#define SHW_STATIC_POLICY_3						HLP_IPSEC_BASE + SHW_STATIC_BASE + 3
#define SHW_STATIC_POLICY_4						HLP_IPSEC_BASE + SHW_STATIC_BASE + 4
#define SHW_STATIC_POLICY_5						HLP_IPSEC_BASE + SHW_STATIC_BASE + 5
#define SHW_STATIC_POLICY_6						HLP_IPSEC_BASE + SHW_STATIC_BASE + 6
#define SHW_STATIC_POLICY_7						HLP_IPSEC_BASE + SHW_STATIC_BASE + 7
#define SHW_STATIC_POLICY_8						HLP_IPSEC_BASE + SHW_STATIC_BASE + 8
#define SHW_STATIC_POLICY_9						HLP_IPSEC_BASE + SHW_STATIC_BASE + 9
#define SHW_STATIC_POLICY_10					HLP_IPSEC_BASE + SHW_STATIC_BASE + 10
#define SHW_STATIC_POLICY_11					HLP_IPSEC_BASE + SHW_STATIC_BASE + 11
#define SHW_STATIC_POLICY_12					HLP_IPSEC_BASE + SHW_STATIC_BASE + 12
#define SHW_STATIC_POLICY_13					HLP_IPSEC_BASE + SHW_STATIC_BASE + 13
#define SHW_STATIC_POLICY_14					HLP_IPSEC_BASE + SHW_STATIC_BASE + 14
#define SHW_STATIC_POLICY_15					HLP_IPSEC_BASE + SHW_STATIC_BASE + 15
#define SHW_STATIC_POLICY_16					HLP_IPSEC_BASE + SHW_STATIC_BASE + 16
#define SHW_STATIC_POLICY_17					HLP_IPSEC_BASE + SHW_STATIC_BASE + 17



#define SHW_STATIC_FILTERLIST_1						HLP_IPSEC_BASE + SHW_STATIC_BASE + 100
#define SHW_STATIC_FILTERLIST_2						HLP_IPSEC_BASE + SHW_STATIC_BASE + 101
#define SHW_STATIC_FILTERLIST_3						HLP_IPSEC_BASE + SHW_STATIC_BASE + 102
#define SHW_STATIC_FILTERLIST_4						HLP_IPSEC_BASE + SHW_STATIC_BASE + 103

#define SHW_STATIC_FILTERACTION_1					HLP_IPSEC_BASE + SHW_STATIC_BASE + 200
#define SHW_STATIC_FILTERACTION_2					HLP_IPSEC_BASE + SHW_STATIC_BASE + 201
#define SHW_STATIC_FILTERACTION_3					HLP_IPSEC_BASE + SHW_STATIC_BASE + 202
#define SHW_STATIC_FILTERACTION_4					HLP_IPSEC_BASE + SHW_STATIC_BASE + 203

#define SHW_STATIC_RULE_1							HLP_IPSEC_BASE + SHW_STATIC_BASE + 300
#define SHW_STATIC_RULE_2							HLP_IPSEC_BASE + SHW_STATIC_BASE + 301
#define SHW_STATIC_RULE_4							HLP_IPSEC_BASE + SHW_STATIC_BASE + 303
#define SHW_STATIC_RULE_5							HLP_IPSEC_BASE + SHW_STATIC_BASE + 304
#define SHW_STATIC_RULE_6							HLP_IPSEC_BASE + SHW_STATIC_BASE + 305
#define SHW_STATIC_RULE_7							HLP_IPSEC_BASE + SHW_STATIC_BASE + 306


#define SHW_STATIC_DEFRULE_3						HLP_IPSEC_BASE + SHW_STATIC_BASE + 402
#define SHW_STATIC_DEFRULE_4						HLP_IPSEC_BASE + SHW_STATIC_BASE + 403
#define SHW_STATIC_DEFRULE_5						HLP_IPSEC_BASE + SHW_STATIC_BASE + 404

#define SHW_STATIC_ALL_1							HLP_IPSEC_BASE + SHW_STATIC_BASE + 500
#define SHW_STATIC_ALL_2							HLP_IPSEC_BASE + SHW_STATIC_BASE + 501

#define SHW_STATIC_PRTPOLICY_1						HLP_IPSEC_BASE + SHW_STATIC_BASE + 600
#define SHW_STATIC_PRTPOLICY_2						HLP_IPSEC_BASE + SHW_STATIC_BASE + 601
#define SHW_STATIC_PRTPOLICY_3						HLP_IPSEC_BASE + SHW_STATIC_BASE + 602
#define SHW_STATIC_PRTPOLICY_4						HLP_IPSEC_BASE + SHW_STATIC_BASE + 603
#define SHW_STATIC_PRTPOLICY_5						HLP_IPSEC_BASE + SHW_STATIC_BASE + 604
#define SHW_STATIC_PRTPOLICY_6						HLP_IPSEC_BASE + SHW_STATIC_BASE + 605
#define SHW_STATIC_PRTPOLICY_7						HLP_IPSEC_BASE + SHW_STATIC_BASE + 606
#define SHW_STATIC_PRTPOLICY_8						HLP_IPSEC_BASE + SHW_STATIC_BASE + 607
#define SHW_STATIC_PRTPOLICY_9						HLP_IPSEC_BASE + SHW_STATIC_BASE + 608
#define SHW_STATIC_PRTPOLICY_10						HLP_IPSEC_BASE + SHW_STATIC_BASE + 609
#define SHW_STATIC_PRTPOLICY_11						HLP_IPSEC_BASE + SHW_STATIC_BASE + 610
#define SHW_STATIC_PRTPOLICY_12						HLP_IPSEC_BASE + SHW_STATIC_BASE + 611
#define SHW_STATIC_PRTPOLICY_13						HLP_IPSEC_BASE + SHW_STATIC_BASE + 612
#define SHW_STATIC_PRTPOLICY_14						HLP_IPSEC_BASE + SHW_STATIC_BASE + 613
#define SHW_STATIC_PRTPOLICY_15						HLP_IPSEC_BASE + SHW_STATIC_BASE + 614
#define SHW_STATIC_PRTPOLICY_16						HLP_IPSEC_BASE + SHW_STATIC_BASE + 615

#define SHW_STATIC_PRTRULE_1						HLP_IPSEC_BASE + SHW_STATIC_BASE + 700
#define SHW_STATIC_PRTRULE_2						HLP_IPSEC_BASE + SHW_STATIC_BASE + 701
#define SHW_STATIC_PRTRULE_6						HLP_IPSEC_BASE + SHW_STATIC_BASE + 705
#define SHW_STATIC_PRTRULE_7						HLP_IPSEC_BASE + SHW_STATIC_BASE + 706
#define SHW_STATIC_PRTRULE_8						HLP_IPSEC_BASE + SHW_STATIC_BASE + 707
#define SHW_STATIC_PRTRULE_9						HLP_IPSEC_BASE + SHW_STATIC_BASE + 708
#define SHW_STATIC_PRTRULE_10						HLP_IPSEC_BASE + SHW_STATIC_BASE + 709
#define SHW_STATIC_PRTRULE_11						HLP_IPSEC_BASE + SHW_STATIC_BASE + 710
#define SHW_STATIC_PRTRULE_12						HLP_IPSEC_BASE + SHW_STATIC_BASE + 711
#define SHW_STATIC_PRTRULE_13						HLP_IPSEC_BASE + SHW_STATIC_BASE + 712
#define SHW_STATIC_PRTRULE_14						HLP_IPSEC_BASE + SHW_STATIC_BASE + 713
#define SHW_STATIC_PRTRULE_15						HLP_IPSEC_BASE + SHW_STATIC_BASE + 714
#define SHW_STATIC_PRTRULE_16						HLP_IPSEC_BASE + SHW_STATIC_BASE + 715
#define SHW_STATIC_PRTRULE_17						HLP_IPSEC_BASE + SHW_STATIC_BASE + 716
#define SHW_STATIC_PRTRULE_18						HLP_IPSEC_BASE + SHW_STATIC_BASE + 717
#define SHW_STATIC_PRTRULE_19						HLP_IPSEC_BASE + SHW_STATIC_BASE + 718
#define SHW_STATIC_PRTRULE_20						HLP_IPSEC_BASE + SHW_STATIC_BASE + 719
#define SHW_STATIC_PRTRULE_35						HLP_IPSEC_BASE + SHW_STATIC_BASE + 734
#define SHW_STATIC_PRTRULE_36						HLP_IPSEC_BASE + SHW_STATIC_BASE + 735
#define SHW_STATIC_PRTRULE_37						HLP_IPSEC_BASE + SHW_STATIC_BASE + 736
#define SHW_STATIC_PRTRULE_38						HLP_IPSEC_BASE + SHW_STATIC_BASE + 737



#define SHW_STATIC_PRTNEGPOL_1						HLP_IPSEC_BASE + SHW_STATIC_BASE + 800
#define SHW_STATIC_PRTNEGPOL_2						HLP_IPSEC_BASE + SHW_STATIC_BASE + 801
#define SHW_STATIC_PRTNEGPOL_3						HLP_IPSEC_BASE + SHW_STATIC_BASE + 802
#define SHW_STATIC_PRTNEGPOL_4						HLP_IPSEC_BASE + SHW_STATIC_BASE + 803
#define SHW_STATIC_PRTNEGPOL_5						HLP_IPSEC_BASE + SHW_STATIC_BASE + 804
#define SHW_STATIC_PRTNEGPOL_6						HLP_IPSEC_BASE + SHW_STATIC_BASE + 805
#define SHW_STATIC_PRTNEGPOL_7						HLP_IPSEC_BASE + SHW_STATIC_BASE + 806
#define SHW_STATIC_PRTNEGPOL_8						HLP_IPSEC_BASE + SHW_STATIC_BASE + 807
#define SHW_STATIC_PRTNEGPOL_9						HLP_IPSEC_BASE + SHW_STATIC_BASE + 808
#define SHW_STATIC_PRTNEGPOL_10						HLP_IPSEC_BASE + SHW_STATIC_BASE + 809
#define SHW_STATIC_PRTNEGPOL_11						HLP_IPSEC_BASE + SHW_STATIC_BASE + 810
#define SHW_STATIC_PRTNEGPOL_12						HLP_IPSEC_BASE + SHW_STATIC_BASE + 811
#define SHW_STATIC_PRTNEGPOL_13						HLP_IPSEC_BASE + SHW_STATIC_BASE + 812
#define SHW_STATIC_PRTNEGPOL_14						HLP_IPSEC_BASE + SHW_STATIC_BASE + 813
#define SHW_STATIC_PRTNEGPOL_15						HLP_IPSEC_BASE + SHW_STATIC_BASE + 814
#define SHW_STATIC_PRTNEGPOL_16						HLP_IPSEC_BASE + SHW_STATIC_BASE + 815
#define SHW_STATIC_PRTNEGPOL_17						HLP_IPSEC_BASE + SHW_STATIC_BASE + 816

#define SHW_STATIC_PRTAUTH_1						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1200
#define SHW_STATIC_PRTAUTH_2						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1201
#define SHW_STATIC_PRTAUTH_3						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1202
#define SHW_STATIC_PRTAUTH_4						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1203

#define SHW_STATIC_PRTFILTERDATA_1					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1300
#define SHW_STATIC_PRTFILTERDATA_2					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1301
#define SHW_STATIC_PRTFILTERDATA_3					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1302
#define SHW_STATIC_PRTFILTERDATA_4					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1303
#define SHW_STATIC_PRTFILTERDATA_5					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1304
#define SHW_STATIC_PRTFILTERDATA_6					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1305
#define SHW_STATIC_PRTFILTERDATA_7					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1306
#define SHW_STATIC_PRTFILTERDATA_8					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1307
#define SHW_STATIC_PRTFILTERDATA_9					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1308
#define SHW_STATIC_PRTFILTERDATA_10	 				HLP_IPSEC_BASE + SHW_STATIC_BASE + 1309
#define SHW_STATIC_PRTFILTERDATA_11					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1310

#define SHW_STATIC_PRTIP_1							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1400
#define SHW_STATIC_PRTIP_2							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1401
#define SHW_STATIC_PRTIP_3							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1402
#define SHW_STATIC_PRTIP_4							HLP_IPSEC_BASE + SHW_STATIC_BASE + 1403

#define SHW_STATIC_PRTFSPEC_1						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1500
#define SHW_STATIC_PRTFSPEC_2						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1501
#define SHW_STATIC_PRTFSPEC_3						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1502
#define SHW_STATIC_PRTFSPEC_4						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1503
#define SHW_STATIC_PRTFSPEC_5						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1504
#define SHW_STATIC_PRTFSPEC_6						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1505
#define SHW_STATIC_PRTFSPEC_7						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1506
#define SHW_STATIC_PRTFSPEC_8						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1507
#define SHW_STATIC_PRTFSPEC_9						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1508
#define SHW_STATIC_PRTFSPEC_10						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1509
#define SHW_STATIC_PRTFSPEC_11						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1510
#define SHW_STATIC_PRTFSPEC_12						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1511
#define SHW_STATIC_PRTFSPEC_13						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1512
#define SHW_STATIC_PRTFSPEC_14						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1513
#define SHW_STATIC_PRTFSPEC_15						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1514
#define SHW_STATIC_PRTFSPEC_16						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1515

#define SHW_STATIC_PRTFILTER_1						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1600
#define SHW_STATIC_PRTFILTER_2						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1601
#define SHW_STATIC_PRTFILTER_3						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1602
#define SHW_STATIC_PRTFILTER_4						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1603
#define SHW_STATIC_PRTFILTER_5						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1604
#define SHW_STATIC_PRTFILTER_6						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1605
#define SHW_STATIC_PRTFILTER_7						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1606
#define SHW_STATIC_PRTFILTER_8						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1607
#define SHW_STATIC_PRTFILTER_9						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1608
#define SHW_STATIC_PRTFILTER_10						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1609
#define SHW_STATIC_PRTFILTER_11						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1610
#define SHW_STATIC_PRTFILTER_12						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1611
#define SHW_STATIC_PRTFILTER_13						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1612
#define SHW_STATIC_PRTFILTER_16						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1615
#define SHW_STATIC_PRTFILTER_17						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1616


#define SHW_STATIC_PRTPROTOCOL_1					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1700
#define SHW_STATIC_PRTPROTOCOL_2					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1701
#define SHW_STATIC_PRTPROTOCOL_3					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1702
#define SHW_STATIC_PRTPROTOCOL_4					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1703
#define SHW_STATIC_PRTPROTOCOL_5					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1704
#define SHW_STATIC_PRTPROTOCOL_6					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1705
#define SHW_STATIC_PRTPROTOCOL_7					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1706
#define SHW_STATIC_PRTPROTOCOL_8					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1707
#define SHW_STATIC_PRTPROTOCOL_9					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1708
#define SHW_STATIC_PRTPROTOCOL_10					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1709


#define SHW_STATIC_PRTISAKMP_2						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1801
#define SHW_STATIC_PRTISAKMP_3						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1802
#define SHW_STATIC_PRTISAKMP_4						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1803
#define SHW_STATIC_PRTISAKMP_5						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1804
#define SHW_STATIC_PRTISAKMP_6						HLP_IPSEC_BASE + SHW_STATIC_BASE + 1805

#define SHW_STATIC_PRTISAKMPSEC_1					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1900
#define SHW_STATIC_PRTISAKMPSEC_2					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1901
#define SHW_STATIC_PRTISAKMPSEC_3					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1902
#define SHW_STATIC_PRTISAKMPSEC_4					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1903
#define SHW_STATIC_PRTISAKMPSEC_5					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1904
#define SHW_STATIC_PRTISAKMPSEC_6					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1905
#define SHW_STATIC_PRTISAKMPSEC_7					HLP_IPSEC_BASE + SHW_STATIC_BASE + 1906

#define SHW_STATIC_ASSIGNEDGPO_1					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2001
#define SHW_STATIC_ASSIGNEDGPO_2					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2002
#define SHW_STATIC_ASSIGNEDGPO_3					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2003
#define SHW_STATIC_ASSIGNEDGPO_4					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2004
#define SHW_STATIC_ASSIGNEDGPO_5					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2005
#define SHW_STATIC_ASSIGNEDGPO_6					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2006
#define SHW_STATIC_ASSIGNEDGPO_7					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2007
#define SHW_STATIC_ASSIGNEDGPO_8					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2008
#define SHW_STATIC_ASSIGNEDGPO_9					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2009
#define SHW_STATIC_ASSIGNEDGPO_10					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2010
#define SHW_STATIC_ASSIGNEDGPO_11					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2011
#define SHW_STATIC_ASSIGNEDGPO_12					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2012
#define SHW_STATIC_ASSIGNEDGPO_13					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2013
#define SHW_STATIC_ASSIGNEDGPO_14					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2014
#define SHW_STATIC_ASSIGNEDGPO_15					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2015
#define SHW_STATIC_ASSIGNEDGPO_16					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2016
#define SHW_STATIC_ASSIGNEDGPO_17					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2017
#define SHW_STATIC_ASSIGNEDGPO_18					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2018
#define SHW_STATIC_ASSIGNEDGPO_19					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2019
#define SHW_STATIC_ASSIGNEDGPO_20					HLP_IPSEC_BASE + SHW_STATIC_BASE + 2020

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\spdprint.h ===
#ifndef HEADER_SPDPRINT
#define HEADER_SPDPRINT

#include "spdcheck.h"

VOID PrintAddrStr(IN CHECKLIST *pcheckList, IN ADDR ResolveAddress);
BOOL PrintAddr(IN CHECKLIST *pcheckList, IN ADDR addr);
BOOL PrintMask(IN CHECKLIST *pcheckList,IN ADDR addr);
BOOL PrintTxFilter( IN CHECKLIST *pcheckList,
					IN TRANSPORT_FILTER TransF);
BOOL PrintTnFilter( IN CHECKLIST *pcheckList,
				      IN TUNNEL_FILTER TunnelF);
BOOL isDefaultMMOffers(IN IPSEC_MM_POLICY MMPol);
BOOL PrintMMFilter(
	IN CHECKLIST *pcheckList, 
	IN MM_FILTER MMFltr);
VOID PrintMMFilterOffer(
	IN CHECKLIST *pcheckList, 
	IN IPSEC_MM_OFFER MMOffer);
DWORD DecodeCertificateName (
	IN LPBYTE EncodedName,
	IN DWORD EncodedNameLength,
	IN OUT LPTSTR *ppszSubjectName);
VOID PrintQMOffer( IN CHECKLIST *pcheckList, 
					IN IPSEC_QM_OFFER QMOffer);
BOOL PrintFilterAction(	IN CHECKLIST *pcheckList, 
						IN IPSEC_QM_POLICY QMPolicy);
VOID PrintMMOffer(
	IN CHECKLIST *pcheckList, 
	IN IPSEC_MM_OFFER MMOffer);
BOOL PrintMMPolicy(
	IN CHECKLIST *pcheckList, 
	IN IPSEC_MM_POLICY MMPolicy);
BOOL PrintMMAuth(IN CHECKLIST *pcheckList, PINT_MM_AUTH_METHODS pIntMMAuth);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\tfschar.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997- 1999 
//
// File:	tfschar.h
//
//	String functions that are used in general for TFS code.
//
// History:
//
//	05/28/97	Kenn Takara				Created.
//
//	Declarations for some common code/macros.
//============================================================================


#ifndef _TFSCHAR_H
#define _TFSCHAR_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#define TFSCORE_API(x)	x


//$ Win95: kennt, the list of Unicode-enabled functions on Win95 will
// have to be checked.  Does lstrlenW work, but lstrcpyW doesn't? (that's
// what the ATL versions of the functions imply).


/*---------------------------------------------------------------------------
	String copy functions
 ---------------------------------------------------------------------------*/

// Baisc conversion functions
TFSCORE_API(LPSTR)	StrCpyAFromW(LPSTR psz, LPCWSTR pswz);
TFSCORE_API(LPWSTR)	StrCpyWFromA(LPWSTR pswz, LPCSTR psz);

TFSCORE_API(LPSTR)	StrnCpyAFromW(LPSTR psz, LPCWSTR pswz, int iMax);
TFSCORE_API(LPWSTR)	StrnCpyWFromA(LPWSTR pswz, LPCSTR psz, int iMax);

#define	StrCpy		lstrcpy
#define StrnCpy		lstrcpyn

#define StrCpyW		lstrcpyW
#define StrCpyA		lstrcpyA
#define StrnCpyW	lstrcpynW
#define StrnCpyA	lstrcpynA

#define StrCpyOle	StrCpyW
#define StrnCpyOle	StrnCpyW

#ifdef _UNICODE

	#define StrCpyAFromT	StrCpyAFromW
	#define StrCpyTFromA	StrCpyWFromA
	#define StrCpyTFromW	lstrcpy
	#define StrCpyWFromT	lstrcpy

	#define StrnCpyAFromT	StrnCpyAFromW
	#define StrnCpyTFromA	StrnCpyWFromA
	#define StrnCpyTFromW	lstrcpyn
	#define StrnCpyWFromT	lstrcpyn

#else
	
	#define StrCpyAFromT	lstrcpy
	#define StrCpyTFromA	lstrcpy
	#define	StrCpyTFromW	StrCpyAFromW
	#define StrCpyWFromT	StrCpyWFromA

	#define StrnCpyAFromT	lstrcpyn
	#define StrnCpyTFromA	lstrcpyn
	#define	StrnCpyTFromW	StrnCpyAFromW
	#define StrnCpyWFromT	StrnCpyWFromA

#endif


#define StrCpyOleFromT		StrCpyWFromT
#define StrCpyTFromOle		StrCpyTFromW

#define StrCpyOleFromA		StrCpyWFromA
#define StrCpyAFromOle		StrCpyAFromW
#define StrCpyWFromOle		StrCpyW
#define StrCpyOleFromW		StrCpyW

#define StrnCpyOleFromT		StrnCpyWFromT
#define StrnCpyTFromOle		StrnCpyTFromW
#define StrnCpyOleFromA		StrnCpyWFromA
#define StrnCpyAFromOle		StrnCpyAFromW
#define StrnCpyOleFromW		StrnCpyW
#define StrnCpyWFromOle		StrnCpyW


/*---------------------------------------------------------------------------
	String length functions
 ---------------------------------------------------------------------------*/

#define StrLen			lstrlen
#define StrLenA			lstrlenA
#define StrLenW			lstrlenW
#define StrLenOle		StrLenW

//
//	CbStrLenA() is inaccurate for DBCS strings!  It will return the
//	incorrect number of bytes needed.
//

#define CbStrLenA(psz)	((StrLenA(psz)+1)*sizeof(char))
#define CbStrLenW(psz)	((StrLenW(psz)+1)*sizeof(WCHAR))

#ifdef _UNICODE
	#define CbStrLen(psz)	CbStrLenW(psz)
#else
	#define CbStrLen(psz)	CbStrLenA(psz)
#endif


// Given a number of characters, this it the minimal number of TCHARs
// that needs to be allocated to hold the string
#define MinTCharNeededForCch(ch)	((ch) * (2/sizeof(TCHAR)))
#define MinCbNeededForCch(ch)		(sizeof(TCHAR)*MinTCharNeededForCch(ch))

// Given a cb (count of bytes) this is the maximal number of characters
// that can be in this string
#define MaxCchFromCb(cb)		((cb) / sizeof(TCHAR))


#ifdef _UNICODE
	// Given a cb, this is the minimum number of chars found in this string
	// MinCchFromCb
	#define MinCchFromCb(cb)	((cb) / sizeof(WCHAR))
#else
	// Number of characters is only half due to DBCS
	#define MinCchFromCb(cb)	((cb) / (2*sizeof(char)))
#endif

/*---------------------------------------------------------------------------
	String dup functions

	The returned string from these functions must be freed using delete!
 ---------------------------------------------------------------------------*/
	
TFSCORE_API(LPSTR)	StrDupA( LPCSTR psz );
TFSCORE_API(LPWSTR)	StrDupW( LPCWSTR pws );

TFSCORE_API(LPSTR)	StrDupAFromW( LPCWSTR pwsz );
TFSCORE_API(LPWSTR)	StrDupWFromA( LPCSTR psz );

#ifdef _UNICODE
	#define	StrDup			StrDupW
	#define StrDupTFromW	StrDupW
	#define StrDupWFromT	StrDupW
	#define	StrDupTFromA	StrDupWFromA
	#define StrDupAFromT	StrDupAFromW

	#define StrDupOleFromA	StrDupWFromA
	#define StrDupAFromOle	StrDupAFromW
	#define StrDupOleFromW	StrDupW
	#define StrDupWFromOle	StrDupW
	#define StrDupOleFromT	StrDupOleFromW
	#define StrDupTFromOle	StrDupWFromOle
#else
	#define StrDup			StrDupA
	#define StrDupTFromA	StrDupA
	#define StrDupAFromT	StrDupA
	#define StrDupTFromW	StrDupAFromW
	#define StrDupWFromT	StrDupWFromA

	#define StrDupOleFromA	StrDupWFromA
	#define StrDupAFromOle	StrDupAFromW
	#define StrDupOleFromW	StrDupW
	#define StrDupWFromOle	StrDupW
	#define StrDupOleFromT	StrDupOleFromA
	#define StrDupTFromOle	StrDupAFromOle
#endif


//	AllocaStrDup
//	AllocaStrDupA
//	AllocaStrDupW
//
//	These functions will dup a string on the STACK.
//
#define AllocaStrDupA(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		StrCpyA((LPSTR) alloca(CbStrLenA(lpa)*2), lpa)))

#define AllocaStrDupW(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		StrCpyW((LPWSTR) alloca(CbStrLenW(lpw)), lpw)))

#ifdef _UNICODE
	#define AllocaStrDup	AllocaStrDupW
#else
	#define AllocaStrDup	AllocaStrDupA
#endif





/*---------------------------------------------------------------------------
	String comparison functions
 ---------------------------------------------------------------------------*/
#define StrCmpA		lstrcmpA
#define StrCmpW		lstrcmpW
#define StrCmpOle	StrCmpW

TFSCORE_API(int) StrnCmpA(LPCSTR psz1, LPCSTR psz2, int nLen);
TFSCORE_API(int) StrnCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen);

#define StriCmpA	lstrcmpiA
#define StriCmpW	lstrcmpiW
#define StriCmpOle	StriCmpW

TFSCORE_API(int) StrniCmpA(LPCSTR psz1, LPCSTR psz2, int nLen);
TFSCORE_API(int) StrniCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen);


#ifdef _UNICODE
	#define StrCmp		StrCmpW
	#define StrnCmp		StrnCmpW
	#define StriCmp		StriCmpW
	#define StrniCmp	StrniCmpW
#else
	#define StrCmp		StrCmpA
	#define StrnCmp		StrnCmpA
	#define StriCmp		StriCmpA
	#define StrniCmp	StrniCmpA
#endif


/*---------------------------------------------------------------------------
	String concatenation routines
 ---------------------------------------------------------------------------*/
#define	StrCatW			lstrcatW
#define StrCatA			lstrcatA

#ifdef _UNICODE
	#define StrCat		StrCatW
#else
	#define StrCat		StrCatA
#endif


/*---------------------------------------------------------------------------
	LoadString helpers
 ---------------------------------------------------------------------------*/
LPTSTR	LoadAndAllocString(UINT ids);

/*---------------------------------------------------------------------------
	Get safe strings
 ---------------------------------------------------------------------------*/
LPTSTR GetSafeString(LPTSTR psz);
LPWSTR GetSafeStringW(LPWSTR pwsz);
LPSTR GetSafeStringA(LPSTR pasz);

/*---------------------------------------------------------------------------
	Local conversion routines (conversions performed on stack!)
 ---------------------------------------------------------------------------*/

// Make sure MFC's afxconv.h hasn't already been loaded to do this
#ifndef USES_CONVERSION
	#ifndef _DEBUG
		#define USES_CONVERSION int _convert; _convert
	#else
		#define USES_CONVERSION int _convert = 0
	#endif

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars);

#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		_convert = (lstrlenA(lpa)+1),\
		AtlA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (lstrlenW(lpw)+1)*2,\
		AtlW2AHelper((LPSTR) alloca(_convert), lpw, _convert)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))


#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	#define T2W(_lp)	(_lp)
	#define W2T(_lp)	(_lp)
	#define T2CA W2CA
	#define A2CT A2CW
	#define T2CW(_lp)	(_lp)
	#define W2CT(_lp)	(_lp)
#else
	#define T2W A2W
	#define W2T W2A
	#define T2A(_lp)	(_lp)
	#define A2T(_lp)	(_lp)
	#define T2CW A2CW
	#define W2CT W2CA
	#define T2CA(_lp)	(_lp)
	#define A2CT(_lp)	(_lp)
#endif

#endif	// !USES_CONVERSION

#endif	// _TFSCHAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\wantest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      wantest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#undef IsEqualGUID
#include <ras.h>
#include <tapi.h>
#include <unimodem.h>


//$REVIEW (nsun) is this reasonable
#define MAX_RASCONN  100


BOOL
WANTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
// Description:
// This routine tests the WAN/TAPI configurations
//
//
// Author:
//  NSun
//
{
 HRESULT    hr = S_OK;
 DWORD dwReturn;
 DWORD dwByteCount;
 RASCONN pRasConn[MAX_RASCONN];
 RASENTRY RasEntry;
 DWORD    dwEntryInfoSize;
 RAS_STATS RasStats;

 DWORD   dwNumConnections;
 DWORD   i;


 PrintStatusMessage( pParams, 4, IDS_WAN_STATUS_MSG );

 InitializeListHead( &pResults->Wan.lmsgOutput );

 dwByteCount  = sizeof(RASCONN) * MAX_RASCONN;

 //
 // dwSize identifies the version of the structure being passed
 //

 pRasConn[0].dwSize = sizeof(RASCONN);

 dwReturn = RasEnumConnections(pRasConn,
                          &dwByteCount,
                          &dwNumConnections);


 if (dwReturn != 0) {
//IDS_WAN_15001                  "RasEnumConnections failed\n" 
  AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Quiet, IDS_WAN_15001);
  hr = S_FALSE;
  goto LERROR;
 }
     

 if (dwNumConnections == 0) {
//IDS_WAN_15002                  "No active remote access connections.\n" 
    AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15002);
	goto LERROR;
 }

 pResults->Wan.fPerformed = TRUE;

 for ( i = 0; i < dwNumConnections; i++) 
 {
  
     //IDS_WAN_15003                  "Entry Name: " 
     AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15003);

     if  (pRasConn[i].szEntryName[0] == '.') 
     {
         //IDS_WAN_15004                  "N/A, phone number %s\n" 
         AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15004, pRasConn[i].szEntryName+1); // skip the dot
        
         //IDS_WAN_15005                  "The following is default entry properties.\n" 
         AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15005);
		 pRasConn[i].szEntryName[0] = 0;
      }
     else
        //IDS_WAN_15006                  "%s\n" 
        AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15006, pRasConn[i].szEntryName);


   RasEntry.dwSize = sizeof(RasEntry);

   dwEntryInfoSize = sizeof(RasEntry);

   dwReturn =  RasGetEntryProperties(NULL,
                                     pRasConn[i].szEntryName,
                                     &RasEntry,
                                     &dwEntryInfoSize,
                                     NULL,
                                     NULL);

   if (dwReturn != 0) {
	 //IDS_WAN_15056		"RasGetEntryProperties for %s failed. [%s]\n"
     AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Quiet, IDS_WAN_15056, 
						 pRasConn[i].szEntryName, NetStatusToString(dwReturn));
     hr = S_FALSE;
     continue;
   }                                                                           

   //
   // dump the connection properties
   //

   // print the device type

   //IDS_WAN_15008                  "Device Type: " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15008);

   //$ REVIEW
   // Why are there '\n''s at the end of the names?

   if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_Modem\n")))
   {
	   // IDS_WAN_15009 "Modem\n" 
	   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						   IDS_WAN_15009);
   }
   else if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_Isdn\n")))
   {
	   // IDS_WAN_15010 "ISDN card\n" 
      AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						  IDS_WAN_15010);
   }
   else if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_X25\n")))
   {
        //IDS_WAN_15011 "X25 card\n" 
      AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						  IDS_WAN_15011);
   }
   else if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_Vpn\n")))
   {
        //IDS_WAN_15012                  "Virtual Private Network\n" 
      AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						  IDS_WAN_15012);
   }
   else if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_PAD")))
   {
        //IDS_WAN_15013                  "Packet Assembler / Dissasembler\n" 
      AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						  IDS_WAN_15013);
   }


   //
   // Framing protocol in use
   //

//IDS_WAN_15014                  "Framing protocol : " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15014);
   if (RasEntry.dwFramingProtocol & RASFP_Ppp) 
//IDS_WAN_15015                  " PPP\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15015);
   else
   if (RasEntry.dwFramingProtocol & RASFP_Slip)
//IDS_WAN_15016                  " Slip\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15016);
   else
   if (RasEntry.dwFramingProtocol & RASFP_Ras)
//IDS_WAN_15017                  " MS Proprietary protocol\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15017);
  


   //
   // PPP and LCP Settings
   //
 
   if (RasEntry.dwFramingProtocol & RASFP_Ppp) {

        //IDS_WAN_15018                  "LCP Extensions : " 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15018);
       if (RasEntry.dwfOptions & RASEO_DisableLcpExtensions)
            //IDS_WAN_DISABLED                  " Disabled\n" 
           AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_DISABLED);
       else
            //IDS_WAN_ENABLED                  " Enabled\n" 
           AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_ENABLED);

        //IDS_WAN_15021                  "Software Compression : " 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15021);
       if (RasEntry.dwfOptions & RASEO_SwCompression) 
            //IDS_WAN_ENABLED                  " Enabled\n" 
          AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_ENABLED);
       else
            //IDS_WAN_DISABLED                  " Disabled\n" 
          AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_DISABLED);

   }

   //
   // Network protocols in use and options
   // 

    //IDS_WAN_15024                  "Network protocols :\n " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15024);
   if (RasEntry.dwfNetProtocols & RASNP_NetBEUI) 
        //IDS_WAN_15025                  "     NetBEUI\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15025); 
   if (RasEntry.dwfNetProtocols & RASNP_Ipx) 
        //IDS_WAN_15026                  "     IPX\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15026);
   if (RasEntry.dwfNetProtocols & RASNP_Ip)
//IDS_WAN_15027                  "     TCP/IP\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15027); 

   //
   // TCP/IP options
   //


   if (RasEntry.dwfNetProtocols & RASNP_Ip) {

    //IDS_WAN_15028                  "IP Address :  " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15028);
   if (RasEntry.dwfOptions & RASEO_SpecificIpAddr)
        //IDS_WAN_15029                  "Specified\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15029);
   else
        //IDS_WAN_15030                  "Server Assigned\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15030);

    //IDS_WAN_15031                  "Name Server: " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15031);
   if (RasEntry.dwfOptions & RASEO_SpecificNameServers)
        //IDS_WAN_15032                  "Specified\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15032);
   else
        //IDS_WAN_15033                  "Server Assigned\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15033);

   // IP hdr compression makes sense only if we use PPP

   if (RasEntry.dwFramingProtocol & RASFP_Ppp) {

        //IDS_WAN_15034                  "IP Header compression : " 
     AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15034);
     if (RasEntry.dwfOptions & RASEO_IpHeaderCompression)
            //IDS_WAN_15035                  " Enabled\n" 
         AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15035);
     else
        //IDS_WAN_15036                  " Disabled\n" 
         AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15036); 
     }

    //IDS_WAN_15037                  "Use default gateway on remote network : " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15037);
   if (RasEntry.dwfOptions & RASEO_RemoteDefaultGateway) 
        //IDS_WAN_15038                  "Enabled\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15038);
   else
//IDS_WAN_15039                  "Disabled\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15039); 

   }

   //
   // Collect statistics regarding this connection
   //

   RasStats.dwSize = sizeof(RAS_STATS); // pass version information

   dwReturn = RasGetConnectionStatistics(
                                 pRasConn[i].hrasconn,
                                 &RasStats);

   if (dwReturn != 0) {
        //IDS_WAN_15040                  "    RasGetConnectionStatistics for %s failed. [%s]\n" 
       AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Quiet, IDS_WAN_15040,
						   pRasConn[i].szEntryName, NetStatusToString(dwReturn) ); 
       hr = S_FALSE;
       continue;
   }
  
    //IDS_WAN_15041                  "\n\tConnection Statistics:\n" 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15041); 

    //IDS_WAN_15042                  "\tBytes Transmitted     : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15042, RasStats.dwBytesXmited);
    //IDS_WAN_15043                  "\tBytes Received        : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15043,RasStats.dwBytesRcved);
    //IDS_WAN_15044                  "\tFrames Transmitted    : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15044,RasStats.dwFramesXmited);
    //IDS_WAN_15045                  "\tFrames Received       : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15045,RasStats.dwFramesRcved);
    //IDS_WAN_15046                  "\tCRC    Errors         : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15046,RasStats.dwFramesRcved);
    //IDS_WAN_15047                  "\tTimeout Errors        : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15047,RasStats.dwTimeoutErr);
    //IDS_WAN_15048                  "\tAlignment Errors      : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15048,RasStats.dwAlignmentErr);
    //IDS_WAN_15049                  "\tH/W Overrun Errors    : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15049,RasStats.dwHardwareOverrunErr);
    //IDS_WAN_15050                  "\tFraming Errors        : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15050,RasStats.dwFramingErr);
    //IDS_WAN_15051                  "\tBuffer Overrun Errors : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15051,RasStats.dwBufferOverrunErr);
    //IDS_WAN_15052                  "\tCompression Ratio In  : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15052,RasStats.dwCompressionRatioIn);
    //IDS_WAN_15053                  "\tCompression Ratio Out : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15053,RasStats.dwCompressionRatioOut);
    //IDS_WAN_15054                  "\tBaud Rate ( Bps )     : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15054,RasStats.dwBps);
    //IDS_WAN_15055                  "\tConnection Duration   : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15055,RasStats.dwConnectDuration);
  

 } // end of for loop

LERROR:
 pResults->Wan.hr = hr;
 return hr;
}



void WANGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	if (pParams->fVerbose)
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams,
							 IDS_WAN_LONG,
							 IDS_WAN_SHORT,
							 pResults->Wan.fPerformed,
							 pResults->Wan.hr,
							 0);
	}
	
    PrintMessageList(pParams, &pResults->Wan.lmsgOutput);
}

void WANPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    //Not a PerInterface test
}

void WANCleanup(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Wan.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\trust.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      trust.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"





BOOL DomainSidRight(    IN PTESTED_DOMAIN TestedDomain,
     NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults
 );


HRESULT TrustTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT hr = S_OK;

    PTESTED_DOMAIN Context = pParams->pDomain;

    NET_API_STATUS NetStatus;
    
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;

    NET_API_STATUS  TrustedNetStatus = 0;
    LPWSTR TrustedDomainList = NULL;
    PTESTED_DOMAIN TestedDomain = pResults->Global.pMemberDomain;
    PLIST_ENTRY ListEntry;
    LPBYTE InputDataPtr;
    int             i;

    // validDC is the count of valid Domain Controllers with which secure channel can be set.
    int validDC = 0;
        

    InitializeListHead(&pResults->Trust.lmsgOutput);

    PrintStatusMessage(pParams, 4, IDS_TRUST_STATUS_MSG);
    
    //
    // Only Members and BDCs have trust relationships to their primary domain
    //

    if (!
        (pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberWorkstation ||
        pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberServer ||
        pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController )
        )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_SKIP_NL);     
        return hr;  // not to test standalone
    }

    pResults->Trust.fPerformed = TRUE;
    //
    // Check to see that the domain Sid of the primary domain is right.
    //

    if ( !DomainSidRight( pResults->Global.pMemberDomain, pParams, pResults ) ) {
        hr = S_FALSE;
        goto L_ERR;
    }

    //
    // Use the secure channel
    //
    // If some other caller did this in the recent past,
    //  this doesn't even use the secure channel.
    //
    // On a BDC, this doesn't use the secure channel.
    //

    TrustedNetStatus = NetEnumerateTrustedDomains( NULL, &TrustedDomainList );
    if ( TrustedNetStatus != NO_ERROR ) {
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                          IDS_TRUST_FAILED_LISTDOMAINS, 
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                          NetStatusToString(TrustedNetStatus));
    }

    // Don't complain yet since the real secure channel status is more
    // important to the user.

    //
    // Check the current status of the secure channel.
    //  (This may still be cached and out of date.)
    //

    InputDataPtr = (LPBYTE)(pResults->Global.pPrimaryDomainInfo->DomainNameDns ? 
                                    pResults->Global.pPrimaryDomainInfo->DomainNameDns :
                                    pResults->Global.pPrimaryDomainInfo->DomainNameFlat);

    NetStatus = I_NetLogonControl2(
                    NULL,
                    NETLOGON_CONTROL_TC_QUERY,
                    2,  // Query level
                    (LPBYTE)&(InputDataPtr),
                    (LPBYTE *)&NetlogonInfo2 );


    // put message to message list
    if ( NetStatus != NO_ERROR ) 
    {
        //IDS_TRUST_FAILED_SECURECHANNEL      "	 Cannot get secure channel status for domain '%ws' from Netlogon. [%s]"
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                          IDS_TRUST_FAILED_SECURECHANNEL, 
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                          NetStatusToString(NetStatus));
        hr = S_FALSE;
        goto L_ERR;
    }

    if ( NetlogonInfo2->netlog2_tc_connection_status != NO_ERROR ) 
    {
        //IDS_TRUST_CHANNEL_BROKEN            "    [FATAL] Secure channel to domain '%ws' is broken. [%s]\n"
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                          IDS_TRUST_CHANNEL_BROKEN,
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                          NetStatusToString(NetlogonInfo2->netlog2_tc_connection_status));
        hr = S_FALSE;
        goto L_ERR;
    }

    AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Verbose, 0,
                          IDS_TRUST_SECURECHANNEL_TO, 
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat, 
                          NetlogonInfo2->netlog2_trusted_dc_name);
    

    // free the data buffer returned earlies
    if ( NetlogonInfo2 != NULL ) {
        NetApiBufferFree( NetlogonInfo2 );
        NetlogonInfo2 = NULL;
    }
    
    // test further
    switch(pResults->Global.pPrimaryDomainInfo->MachineRole){
    //
    // On a backup domain controller,
    //  only setup a secure channel to the PDC.
    //
    case    DsRole_RoleBackupDomainController:
        //
        // Check the current status of the secure channel.
        //  (This may be still cached and out of date.)
        //

        NetlogonInfo2 = NULL;
        InputDataPtr = (LPBYTE)(pResults->Global.pPrimaryDomainInfo->DomainNameDns ? 
                                    pResults->Global.pPrimaryDomainInfo->DomainNameDns :
                                    pResults->Global.pPrimaryDomainInfo->DomainNameFlat);

        // connect to PDC
        NetStatus = I_NetLogonControl2(
                        NULL,
                        NETLOGON_CONTROL_REDISCOVER,
                        2,  // Query level
                            (LPBYTE)&InputDataPtr,
                        (LPBYTE *)&NetlogonInfo2 );

        if (NetStatus == ERROR_ACCESS_DENIED)
        {
            //IDS_TRUST_NOT_ADMIN       "    Cannot test secure channel to PDC since you are not an administrator.\n"
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                              IDS_TRUST_NOT_ADMIN);
            goto L_ERR;
        }
            

        if(NetStatus != NO_ERROR)
        {
            //IDS_TRUST_FAILED_CHANNEL_PDC      "    [FATAL] Cannot set secure channel for domain '%ws' to PDC. [%s]\n"
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, 
                             IDS_TRUST_FAILED_CHANNEL_PDC,
                             pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                             NetStatusToString(NetStatus));
            hr = S_FALSE;
            goto L_ERR;
        }

        if ( NetlogonInfo2->netlog2_tc_connection_status != NO_ERROR ) 
        {
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, 
                             IDS_TRUST_FAILED_CHANNEL_PDC,
                             pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                             NetStatusToString(NetStatus));
            hr = S_FALSE;
            goto L_ERR;
        }

        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_ReallyVerbose, 0,
                          IDS_TRUST_SECURECHANNEL_TOPDC, 
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat, 
                          NetlogonInfo2->netlog2_trusted_dc_name);
        
    
        if ( NetlogonInfo2 != NULL ) 
        {
            NetApiBufferFree( NetlogonInfo2 );
            NetlogonInfo2 = NULL;
        }


        break;
        
        // On a workstation or member server,
    //  try the secure channel to ever DC in the domain.
    //

    case    DsRole_RoleMemberServer:
    case    DsRole_RoleMemberWorkstation:

        if ( TestedDomain->NetbiosDomainName == NULL ) {
                //IDS_TRUST_NO_NBT_DOMAIN   "    [FATAL] Cannot test secure channel since no netbios domain name '%ws' to DC '%ws'."
                AddMessageToList( &pResults->Trust.lmsgOutput, Nd_Quiet, IDS_TRUST_NO_NBT_DOMAIN, TestedDomain->PrintableDomainName );
                PrintGuruMessage2("    [FATAL] Cannot test secure channel since no netbios domain name '%ws' to DC '%ws'.", TestedDomain->PrintableDomainName );
                PrintGuru( 0, NETLOGON_GURU );
                hr = S_FALSE;
                goto L_ERR;
            }

        //
        // Ensure secure channel can be set with atleast one DC.
        //

        for ( ListEntry = TestedDomain->TestedDcs.Flink ;
                  ListEntry != &TestedDomain->TestedDcs ;
                  ListEntry = ListEntry->Flink )
        {
            WCHAR RediscoverName[MAX_PATH+1+MAX_PATH+1];
            PTESTED_DC TestedDc;


            //
            // Loop through the list of DCs in this domain
            //

            TestedDc = CONTAINING_RECORD( ListEntry, TESTED_DC, Next );

            if ( TestedDc->Flags & DC_IS_DOWN ) {
                AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_ReallyVerbose, 0,
                          IDS_TRUST_NOTESTASITSDOWN, 
                          TestedDc->ComputerName );
                continue;
            }

            //
            // Build the name to rediscover
            //

            wcscpy( RediscoverName, GetSafeStringW(TestedDomain->DnsDomainName ? 
                                                    TestedDomain->DnsDomainName :
                                                    TestedDomain->NetbiosDomainName));
            wcscat( RediscoverName, L"\\" );
            wcscat( RediscoverName, GetSafeStringW(TestedDc->ComputerName) );


            //
            // Check the current status of the secure channel.
            //  (This may be still cached and out of date.)
            //

            InputDataPtr = (LPBYTE)RediscoverName;
            NetStatus = I_NetLogonControl2(
                            NULL,
                            NETLOGON_CONTROL_REDISCOVER,
                            2,  // Query level
                            (LPBYTE)&InputDataPtr,
                            (LPBYTE *)&NetlogonInfo2 );

            if ( NetStatus != NO_ERROR ) 
            {
                if ( ERROR_ACCESS_DENIED == NetStatus )
                {
                    AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, 
                                 IDS_TRUST_TODCS_NOT_ADMIN);
                }
                else
                {
                    //IDS_TRUST_FAILED_TODCS              "    Cannot test secure channel for domain '%ws' to DC '%ws'. [%s]\n"
                    AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, 
                                 IDS_TRUST_FAILED_TODCS,
                                 TestedDomain->PrintableDomainName,
                                 TestedDc->NetbiosDcName,
                                 NetStatusToString(NetStatus));

                }

                continue;
            }

            if ( NetlogonInfo2->netlog2_tc_connection_status != NO_ERROR ) 
            {
                AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                          IDS_TRUST_FAILED_CHANNEL_DCS, 
                          TestedDomain->PrintableDomainName,
                          TestedDc->NetbiosDcName  );
                continue;
            }

            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_ReallyVerbose, 0,
                          IDS_TRUST_CHANNEL_DC, 
                          TestedDomain->PrintableDomainName,
                          NetlogonInfo2->netlog2_trusted_dc_name  );
            validDC++;
        }
        if (validDC == 0)
            hr = S_FALSE;
        
        break;
    }



L_ERR:

    if ( NetlogonInfo2 != NULL ) {
        NetApiBufferFree( NetlogonInfo2 );
        NetlogonInfo2 = NULL;
    }

    if ( TrustedDomainList != NULL ) {
        NetApiBufferFree( TrustedDomainList );
        TrustedDomainList = NULL;
    }
    
    PrintStatusMessage(pParams, 0, FHrOK(hr) ? IDS_GLOBAL_PASS_NL : IDS_GLOBAL_FAIL_NL);

    pResults->Trust.hr = hr;

    return hr;
} 

void TrustGlobalPrint(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
    // print out the test result
    if (pParams->fVerbose || !FHrOK(pResults->Trust.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_TRUST_LONG, IDS_TRUST_SHORT, pResults->Trust.fPerformed, 
                             pResults->Trust.hr, 0);

        PrintMessageList(pParams, &pResults->Trust.lmsgOutput);
    }

}

void TrustPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN OUT NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResult)
{
    // no perinterface information
}

void TrustCleanup(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Trust.lmsgOutput);

}



BOOL
DomainSidRight(
    IN PTESTED_DOMAIN TestedDomain,
     NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults
    )
/*++

Routine Description:

    Determine if the DomainSid field of the TestDomain matches the DomainSid
    of the domain.

Arguments:

    TestedDomain - Domain to test

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    BOOL RetVal = TRUE;

    SAM_HANDLE LocalSamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;

    PTESTED_DC  pTestedDc;


    //
    // Initialization
    //

    AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_ReallyVerbose, 0,
                          IDS_TRUST_ENSURESID, 
                          TestedDomain->PrintableDomainName);

    if ( TestedDomain->DomainSid == NULL ) {
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                              IDS_TRUST_MISSINGSID, 
                              TestedDomain->PrintableDomainName);
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // If we don't yet know a DC in the domain,
    //  find one.
    //

    if ( TestedDomain->DcInfo == NULL ) 
    {
        LPTSTR pszDcType;

        if ( TestedDomain->fTriedToFindDcInfo ) {
            //IDS_DCLIST_NO_DC "    '%ws': Cannot find DC to get DC list from [test skiped].\n"
            AddMessageToList( &pResults->Trust.lmsgOutput, Nd_Verbose, IDS_TRUST_NODC, TestedDomain->PrintableDomainName);
            goto Cleanup;
        }

        pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);
        NetStatus = DoDsGetDcName( pParams,
                                   pResults,
                                   &pResults->Trust.lmsgOutput,
                                   TestedDomain,
                                   DS_DIRECTORY_SERVICE_PREFERRED,
                                   pszDcType, //"DC",
                                   FALSE,
                                   &TestedDomain->DcInfo );
        Free(pszDcType);

        TestedDomain->fTriedToFindDcInfo = TRUE;

        if ( NetStatus != NO_ERROR ) {
            //IDS_TRUST_NODC    "    '%ws': Cannot find DC to get DC list from [test skiped].\n"
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Verbose, 0, 
                            IDS_TRUST_NODC, TestedDomain->PrintableDomainName);
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Verbose, 4, 
                              IDS_GLOBAL_STATUS, NetStatusToString(NetStatus));
            
            // This isn't fatal.
            RetVal = TRUE;
            goto Cleanup;
        }
    }

    //
    // Get a DC that's UP.
    //

    pTestedDc = GetUpTestedDc( TestedDomain );

    if ( pTestedDc == NULL ) {
        AddMessageToList( &pResults->Trust.lmsgOutput, Nd_Verbose, 
                          IDS_TRUST_NODC_UP, TestedDomain->PrintableDomainName);
        PrintGuruMessage2("    '%ws': No DCs are up (Cannot run test).\n",
                TestedDomain->PrintableDomainName );
        PrintGuru( NetStatus, DSGETDC_GURU );
        // This isn't fatal.
        RetVal = TRUE;
        goto Cleanup;
    }


    //
    // Connect to the SAM server
    //

    Status = NettestSamConnect(
                               pParams,
                               pTestedDc->ComputerName,
                               &LocalSamHandle );

    if ( !NT_SUCCESS(Status)) {
        if ( Status == STATUS_ACCESS_DENIED ) {
            //IDS_TRUST_NO_ACCESS   "    [WARNING] Don't have access to test your domain sid for domain '%ws'. [Test skipped]\n"
            AddMessageToList( &pResults->Trust.lmsgOutput, Nd_Verbose, 
                              IDS_TRUST_NO_ACCESS, TestedDomain->PrintableDomainName );
        }
        // This isn't fatal.
        RetVal = TRUE;
        goto Cleanup;
    }


    //
    // Open the domain.
    //  Ask for no access to avoid access denied.
    //

    Status = SamOpenDomain( LocalSamHandle,
                            0,
                            pResults->Global.pMemberDomain->DomainSid,
                            &DomainHandle );

    if ( Status == STATUS_NO_SUCH_DOMAIN ) {
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, IDS_TRUST_WRONGSID, TestedDomain->PrintableDomainName );
        RetVal = FALSE;
        goto Cleanup;

    }

    if ( !NT_SUCCESS( Status ) ) {
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, IDS_TRUST_FAILED_SAMOPEN, pTestedDc->ComputerName );
        RetVal = FALSE;
        goto Cleanup;
    }


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( DomainHandle != NULL ) {
        (VOID) SamCloseHandle( DomainHandle );
    }

    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\winstest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      winstest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "dhcptest.h"

static const TCHAR  s_szSpace12[] = _T("            ");
const int c_iWaitTime = 2000;

BOOL IsNameResponse( NETDIAG_PARAMS * pParams, char* ipAddrStr );
int Probe( NETDIAG_PARAMS *pParams, TCHAR *szSrvIpAddr, SOCKET listenNameSvcSock );

//-------------------------------------------------------------------------//
//######  W I N S T e s t ()  #############################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Queries the all the configured WINS servers to make sure that      //
//      they are reachable and that they have the proper name-IP mapping   //
//      for this workstation.                                              //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
HRESULT WinsTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    IPCONFIG_TST *  pIpConfig;
    WINS_TST *      pWinsResult;
    PIP_ADAPTER_INFO  pIpAdapter;
    IP_ADDR_STRING winsSrv;
    int            nWinsSrvOk = 0;
    HRESULT         hr = hrOK;
    int             i;
    TCHAR           szBuffer[256];

    
    // IDS_WINS_STATUS_MSG  "    Testing the WINS server... \n" 
    PrintStatusMessage(pParams, 4, IDS_WINS_STATUS_MSG);

    //
    //  try to send name queries to the WINS servers on all adapters
    //
    for ( i = 0; i < pResults->cNumInterfaces; i++ )
    {
        UINT nIfWinsOk = 0;

        pIpConfig = &pResults->pArrayInterface[i].IpConfig;
        pIpAdapter = pResults->pArrayInterface[i].IpConfig.pAdapterInfo;
        InitializeListHead( &pResults->pArrayInterface[i].Wins.lmsgPrimary );
        InitializeListHead( &pResults->pArrayInterface[i].Wins.lmsgSecondary );

        if (!pIpConfig->fActive || 
            NETCARD_DISCONNECTED == pResults->pArrayInterface[i].dwNetCardStatus)
            continue;

		if (!pResults->pArrayInterface[i].fNbtEnabled)
			continue;

        PrintStatusMessage(pParams, 8, IDSSZ_GLOBAL_StringLine, pResults->pArrayInterface[i].pszFriendlyName);

        pWinsResult = &pResults->pArrayInterface[i].Wins;

        //
        //  looping through the primary WINS server list
        //

        winsSrv = pIpAdapter->PrimaryWinsServer;
        if ( ZERO_IP_ADDRESS(winsSrv.IpAddress.String) )
        {
            if(pParams->fReallyVerbose)
                PrintMessage(pParams, IDS_WINS_QUERY_NO_PRIMARY,
                             s_szSpace12);
            AddMessageToList(&pWinsResult->lmsgPrimary,
                             Nd_ReallyVerbose, IDS_WINS_QUERY_NO_PRIMARY,
                             s_szSpace12);
        }
        else
        {
            pWinsResult->fPerformed = TRUE;

            while ( TRUE )
            {
                if (pParams->fReallyVerbose)
                    PrintMessage(pParams, IDS_WINS_QUERY_PRIMARY,
                                 s_szSpace12,
                                 winsSrv.IpAddress.String);
            
                AddMessageToList(&pWinsResult->lmsgPrimary,
                                 Nd_ReallyVerbose,
                                 IDS_WINS_QUERY_PRIMARY,
                                 s_szSpace12,
                                 winsSrv.IpAddress.String);
            
                if ( IsNameResponse(pParams, winsSrv.IpAddress.String) )
                {
                    if (pParams->fReallyVerbose)
                        PrintMessage(pParams, IDS_GLOBAL_PASS_NL);
                    AddMessageToList(&pWinsResult->lmsgPrimary,
                                     Nd_ReallyVerbose,
                                     IDS_GLOBAL_PASS_NL);
                    nWinsSrvOk++;
                    nIfWinsOk++;
                }
                else
                {
                    if (pParams->fReallyVerbose)
                        PrintMessage(pParams, IDS_GLOBAL_FAIL_NL);
                    AddMessageToList(&pWinsResult->lmsgPrimary,
                                       Nd_ReallyVerbose,
                                       IDS_GLOBAL_FAIL_NL);
                }
            
                if ( winsSrv.Next == NULL )
                {
                    break;
                }

                winsSrv = *(winsSrv.Next);
            }
        }

        //
        //  looping through the secondary WINS server list
        //

        winsSrv = pIpAdapter->SecondaryWinsServer;
        if ( ZERO_IP_ADDRESS(winsSrv.IpAddress.String) )
        {
            if(pParams->fReallyVerbose)
                PrintMessage(pParams, IDS_WINS_QUERY_NO_SECONDARY,
                             s_szSpace12);
            AddMessageToList(&pWinsResult->lmsgSecondary,
                             Nd_ReallyVerbose, IDS_WINS_QUERY_NO_SECONDARY,
                             s_szSpace12);
        }
        else
        {
            pWinsResult->fPerformed = TRUE;

            while ( TRUE )
            {
                if (pParams->fReallyVerbose)
                    PrintMessage(pParams, IDS_WINS_QUERY_SECONDARY,
                                 s_szSpace12,
                                 winsSrv.IpAddress.String);
            
                AddMessageToList(&pWinsResult->lmsgSecondary,
                                 Nd_ReallyVerbose,
                                 IDS_WINS_QUERY_SECONDARY,
                                 s_szSpace12,
                                 winsSrv.IpAddress.String);
            
                if ( IsNameResponse(pParams, winsSrv.IpAddress.String) )
                {
                    if (pParams->fReallyVerbose)
                        PrintMessage(pParams, IDS_GLOBAL_PASS_NL);
                    AddMessageToList(&pWinsResult->lmsgSecondary,
                                     Nd_ReallyVerbose,
                                     IDS_GLOBAL_PASS_NL);
                    nWinsSrvOk++;
                    nIfWinsOk++;
                }
                else
                {
                    if (pParams->fReallyVerbose)
                        PrintMessage(pParams, IDS_GLOBAL_FAIL_NL);
                    AddMessageToList(&pWinsResult->lmsgSecondary,
                                       Nd_ReallyVerbose,
                                       IDS_GLOBAL_FAIL_NL);
                }

                if ( winsSrv.Next == NULL ) { break; }

                winsSrv = *(winsSrv.Next);
            }
        }
        
        if( 0 == nIfWinsOk )
            pWinsResult->hr = S_FALSE;
        else
            pWinsResult->hr = S_OK;

    } /* end of for loop scanning all the adapters */

//$REVIEW   No global test result for WINS test
    if ( nWinsSrvOk != 0)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
        

    return hr;
} /* END OF WINSTest() */



//-------------------------------------------------------------------------//
//######  P r o b e  ()  ##################################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Assembles and sends a name query to the DHCP server.               //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE if a response has been received from the server               //
//      FALSE otherwise                                                    //
//  Global variables used:                                                 //
//      g_isDebug (reading only)                                   //
//                                                                         //
//  Comments:                                                              //
//  This will not work for b-type nodes for which you need to set the B bit//
//  and broadcast the packet instead of unicast xmission  - Rajkumar       //
//-------------------------------------------------------------------------//
int Probe( NETDIAG_PARAMS *pParams, TCHAR *szSrvIpAddr, SOCKET listenNameSvcSock ) {

    char                nbtFrameBuf[MAX_NBT_PACKET_SIZE];
    NM_FRAME_HDR       *pNbtHeader = (NM_FRAME_HDR *)nbtFrameBuf;
    NM_QUESTION_SECT   *pNbtQuestion = (NM_QUESTION_SECT *)( nbtFrameBuf + sizeof(NM_FRAME_HDR) );
    struct sockaddr_in  destSockAddr;                       
    char               *pDest, *pName;
    int                 nBytesSent = 0, i;


    /* RFC 1002 section 4.2.12

                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         NAME_TRN_ID           |0|  0x0  |0|0|1|0|0 0|B|  0x0  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          0x0001               |           0x0000              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          0x0000               |           0x0000              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                         QUESTION_NAME                         /
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           NB (0x0020)         |        IN (0x0001)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   */
    
    pNbtHeader->xid            = NM_QRY_XID;
    pNbtHeader->flags          = NBT_NM_OPC_QUERY | 
                                 NBT_NM_OPC_REQUEST | 
                                 NBT_NM_FLG_RECURS_DESRD;
    pNbtHeader->question_cnt   = 0x0100;
    pNbtHeader->answer_cnt     = 0;
    pNbtHeader->name_serv_cnt  = 0;
    pNbtHeader->additional_cnt = 0;

    // pDest is filling nbtQuestion->q_name 
    pNbtQuestion->q_type       = NBT_NM_QTYP_NB;
    pNbtQuestion->q_class      = NBT_NM_QCLASS_IN;

    //
    //  translate the name
    //

    pDest = (char *)&(pNbtQuestion->q_name);
    pName = nameToQry;

    // the first byte of the name is the length field = 2*16
    *pDest++ = NBT_NAME_SIZE;

    // step through name converting ascii to half ascii, for 32 times
    for ( i = 0; i < (NBT_NAME_SIZE / 2) ; i++ ) {
        *pDest++ = (*pName >> 4) + 'A';
        *pDest++ = (*pName++ & 0x0F) + 'A';
    }
    *pDest++ = '\0';
    *pDest = '\0';

    //
    // send the name query frame
    // 
    destSockAddr.sin_family = PF_INET;
    destSockAddr.sin_port = htons(137);     // NBT_NAME_SERVICE_PORT;
    destSockAddr.sin_addr.s_addr = inet_addr( szSrvIpAddr );
    for ( i = 0; i < 8 ; i++ ) { destSockAddr.sin_zero[i] = 0; }

    nBytesSent = sendto( listenNameSvcSock,
                         (PCHAR )nbtFrameBuf, 
                         sizeof(NM_FRAME_HDR) + sizeof(NM_QUESTION_SECT),
                         0,
                         (struct sockaddr *)&destSockAddr,
                         sizeof( struct sockaddr )
                       );


    PrintDebugSz(pParams, 0, _T("\n      querying name %s on server %s\n"), nameToQry, szSrvIpAddr );
    PrintDebugSz(pParams, 0, _T( "          bytes sent %d\n"), nBytesSent );

    if ( nBytesSent == SOCKET_ERROR )
    {
        PrintDebugSz(pParams, 0, _T("    Error %d in sendto()!\n"), WSAGetLastError() );
        return FALSE;
    }

    //
    //  the other thread should see the incoming frame and increment m_nMsgCnt
    //
    return TRUE;

} /* END OF Probe() */




//-------------------------------------------------------------------------//
//######  I s N a m e R e s p o n s e ()  #################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Sends a NetBT name Query to the IP address provided as input param //
//  Arguments:                                                             //
//      ipAddrStr - IP address where the Name Query is to be sent          //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
BOOL IsNameResponse( NETDIAG_PARAMS *pParams, char* ipAddrStr ) {

    DWORD   optionValue;    // helper var for setsockopt()
    SOCKADDR_IN sockAddr;       // struct holding source socket info
    SOCKET      listenNameSvcSock;

    DWORD  listeningThreadId;
    int iTimeout;
    
    int nBytesRcvd = 0;
    char        MsgBuf[1500];
    SOCKADDR_IN senderSockAddr;
    int         nSockAddrSize = sizeof( senderSockAddr );

    BOOL fRet = TRUE;

    //
    //  create socket to listen to name svc responses from the WINS server
    //

    listenNameSvcSock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( listenNameSvcSock  == INVALID_SOCKET ) {
        if (pParams->fReallyVerbose)
//IDS_WINS_12406                  "    Failed to create a socket to listen to WINS traffic. Error = %d \n" 
            PrintMessage(pParams, IDS_WINS_12406, WSAGetLastError() );
        return FALSE;
    }

    optionValue = TRUE;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_REUSEADDR, (const char *)&optionValue, sizeof(optionValue)) ) {
        if (pParams->fReallyVerbose)
//IDS_WINS_12407                  "    Failed to set the SO_REUSEADDR option for the socket. Error = %d\n" 
            PrintMessage(pParams, IDS_WINS_12407, WSAGetLastError() );
        return FALSE;
    }

    optionValue = FALSE;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_BROADCAST, (const char *)&optionValue, sizeof(optionValue)) ) {
        if (pParams->fReallyVerbose)
//IDS_WINS_12408                  "    Failed to set the SO_BROADCAST option for the socket. Error = %d\n" 
            PrintMessage(pParams, IDS_WINS_12408, WSAGetLastError() );
        return FALSE;
    }

    iTimeout = c_iWaitTime;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_RCVTIMEO, (char*)&iTimeout, sizeof(iTimeout)))
    {
        if (pParams->fReallyVerbose)
//IDS_WINS_12416                    "    Failed to set the SO_RCVTIMEO option for the socket. Error = %d\n"
            PrintMessage(pParams, IDS_WINS_12416, WSAGetLastError());

        return FALSE;
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = INADDR_ANY;
    sockAddr.sin_port = 0;
    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(listenNameSvcSock, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) {
        if (pParams->fReallyVerbose)
//IDS_WINS_12409                  "\n    Failed to bind the listening socket for the socket. Error = %d\n" 
            PrintMessage(pParams, IDS_WINS_12409, WSAGetLastError() );
        return FALSE;
    }

    //
    //  let's ask the WINS server for our own name
    //

    Probe( pParams, ipAddrStr, listenNameSvcSock );

    nBytesRcvd = recvfrom( listenNameSvcSock, MsgBuf, sizeof(MsgBuf), 0, (LPSOCKADDR )&senderSockAddr, &nSockAddrSize );
    if ( nBytesRcvd == SOCKET_ERROR )
    {
        //since we are sending UDP packets, it's not reliable. Do the query again
        Probe (pParams, ipAddrStr, listenNameSvcSock);
        if (SOCKET_ERROR == recvfrom( listenNameSvcSock, MsgBuf, 
                                sizeof(MsgBuf), 
                                0, 
                                (LPSOCKADDR )&senderSockAddr, 
                                &nSockAddrSize ))
        {
            fRet = FALSE;
        }
    }

    //
    //  final clean up
    //
    closesocket(listenNameSvcSock);
    
    return fRet;
} /* END OF IsNameResponse() */


void WinsGlobalPrint(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
}

void WinsPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN OUT NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResult)
{
//    PIP_ADAPTER_INFO  pIpAdapter = pIfResult->IpConfig.pAdapterInfo;
//    IP_ADDR_STRING winsSrv;

    if (!pIfResult->IpConfig.fActive ||
        NETCARD_DISCONNECTED == pIfResult->dwNetCardStatus)
        return;

    if (pParams->fVerbose || !FHrOK(pIfResult->Wins.hr))
    {
        PrintNewLine(pParams, 1);
        PrintTestTitleResult(pParams, IDS_WINS_LONG, IDS_WINS_SHORT, pIfResult->Wins.fPerformed, 
                             pIfResult->Wins.hr, 8);
    }

    
    PrintMessageList(pParams, &pIfResult->Wins.lmsgPrimary);

    PrintMessageList(pParams, &pIfResult->Wins.lmsgSecondary);

    if (pIfResult->Wins.fPerformed)
    {
        if (pIfResult->Wins.hr == hrOK)
        {
            if (pParams->fReallyVerbose)
                // IDS_WINS_12413  "            The test was successful, at least one WINS server was found.\n" 
                PrintMessage(pParams, IDS_WINS_12413);
        }
        else
        {
            // IDS_WINS_12414  "            The test failed.  We were unable to query the WINS servers.\n" 
            PrintMessage(pParams, IDS_WINS_12414);
        }
    }
    else if (pParams->fVerbose)
	{
		if (!pIfResult->fNbtEnabled)
		{
			//IDS_WINS_NBT_DISABLED			"            NetBT is disable on this interface. [Test skipped].\n"
			PrintMessage(pParams, IDS_WINS_NBT_DISABLED);
		}
		else
		{
			//IDS_WINS_12415   "            There are no WINS servers configured for this interface.\n"
			PrintMessage(pParams, IDS_WINS_12415);
		}
	}
        
}

void WinsCleanup(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    int i;
    for(i = 0; i < pResults->cNumInterfaces; i++)
    {
        MessageListCleanUp(&pResults->pArrayInterface[i].Wins.lmsgPrimary);
        MessageListCleanUp(&pResults->pArrayInterface[i].Wins.lmsgSecondary);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\winsock.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      winsock.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"


HRESULT WinsockTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	int    err,i;
	LPWSAPROTOCOL_INFO  lpProtocolBuffer = NULL;
	DWORD  reqd_length;
	SOCKET sock;
	UINT   optval;
	int    optlen;
	WSADATA WSAData;
	HRESULT	hr = S_OK;

	PrintStatusMessage(pParams,0, IDS_WINSOCK_STATUS_MSG);


	err = WSAStartup(MAKEWORD( 2, 0 ), &WSAData); 
	if(err != 0)	// error
	{
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_START);
	};
	
	// determine the length of the buffer needed
	reqd_length = 0;

	err = WSAEnumProtocols(NULL, NULL, &reqd_length);
	if(reqd_length == 0 || reqd_length == -1)
	{
		err = WSAGetLastError();
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_ENUM);
	};

	lpProtocolBuffer = (LPWSAPROTOCOL_INFO)Malloc(reqd_length);

	if (lpProtocolBuffer == NULL) {
		CHK_HR_CONTEXT(pResults->Winsock, hr = E_OUTOFMEMORY, IDS_WINSOCK_FAILED_ENUM);
	}

    ZeroMemory( lpProtocolBuffer, reqd_length );

  	// get the information of the protocols
	err = WSAEnumProtocols(
                   NULL,
                   (LPWSAPROTOCOL_INFO)lpProtocolBuffer,
                   (LPDWORD)&reqd_length
                  );

	if(err == SOCKET_ERROR)
	{
		err = WSAGetLastError();
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_ENUM);
	}

	pResults->Winsock.dwProts = err;	// number of protocols
	pResults->Winsock.pProtInfo = lpProtocolBuffer;	// protocol information array

	//
	// Other TCP/IP information
	//
	sock = socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);

	if ( sock == INVALID_SOCKET)
	{
		err = WSAGetLastError();
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_UDPSOCKET);
	}

	optlen = sizeof(optval);

	err = getsockopt(sock, SOL_SOCKET, SO_MAX_MSG_SIZE, (char FAR*)&optval, (int FAR*)&optlen);

	if (err == SOCKET_ERROR) 
	{
		err = WSAGetLastError();
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_UDPSOCKET);
	}

	pResults->Winsock.dwMaxUDP = optval;

L_ERR:
	WSACleanup();

    //$REVIEW (nsun) we should return S_FALSE so that we can go on with 
    //other tests
    if (!FHrOK(hr))
        hr = S_FALSE;

	return hr;

} /* END OF WINSTest() */

void WinsockGlobalPrint(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
	DWORD i = 0;
	LPWSAPROTOCOL_INFO	pProtInfo = pResults->Winsock.pProtInfo;
	
	// print out the test result
	if (pParams->fVerbose || !FHrOK(pResults->Winsock.hr))
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams,
							 IDS_WINSOCK_LONG,
							 IDS_WINSOCK_SHORT,
							 TRUE,
							 pResults->Winsock.hr, 0);
	}
	if (pParams->fReallyVerbose || !FHrOK(pResults->Winsock.hr))
	{
		if (!FHrOK(pResults->Winsock.hr))
		{
			PrintError(pParams, pResults->Winsock.idsContext, pResults->Winsock.hr);
		}
	}

	if (pParams->fReallyVerbose)
	{
		if(pProtInfo)
		{
			// if there is any information about the providers
			// "    The number of protocols which have been reported : %d\n" 
			PrintMessage(pParams, IDS_WINSOCK_12605, pResults->Winsock.dwProts); 

			for (i = 0; i < pResults->Winsock.dwProts ; i++)
			{
				// "        Description: %s\n" 
    			PrintMessage(pParams, IDS_WINSOCK_12606,pProtInfo->szProtocol);
				// "            Provider Version   :%d\n" 
			    PrintMessage(pParams, IDS_WINSOCK_12607,pProtInfo->iVersion);
				switch(pProtInfo++->dwMessageSize){
				case	0:
					// "            Max message size  : Stream Oriented\n" 
					PrintMessage(pParams, IDS_WINSOCK_12608);
					break;
			    case	1:
					// "            Max message size  : Message Oriented\n" 
					PrintMessage(pParams, IDS_WINSOCK_12609);
					break;
			    case	0xffffffff:
					// "            Max message size  : depends on MTU\n" 
					PrintMessage(pParams, IDS_WINSOCK_12610);
					break;
				}
			}
		}
 
		// if there is any information about the UDP size
		if(pResults->Winsock.dwMaxUDP)
			// "\n    Max UDP size : %d bytes\n" 
			PrintMessage(pParams, IDS_WINSOCK_12611,pResults->Winsock.dwMaxUDP);   
	}

}

void WinsockPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
							 IN OUT NETDIAG_RESULT *pResults,
							 IN INTERFACE_RESULT *pIfResult)
{
	// no perinterface information
}

void WinsockCleanup(IN NETDIAG_PARAMS *pParams,
						 IN OUT NETDIAG_RESULT *pResults)
{
	if(pResults->Winsock.pProtInfo)
	{
		free(pResults->Winsock.pProtInfo);
	}
	ZeroMemory(&(pResults->Winsock), sizeof(GLOBAL_WINSOCK));		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\tfschar.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tfschar.c
//
//--------------------------------------------------------------------------


#include "precomp.h"

#include <malloc.h>

/*!--------------------------------------------------------------------------
	StrCpyAFromW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrCpyAFromW(LPSTR psz, LPCWSTR pswz)
{
	USES_CONVERSION;
	return StrCpyA(psz, W2CA(pswz));
}

/*!--------------------------------------------------------------------------
	StrCpyWFromA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrCpyWFromA(LPWSTR pswz, LPCSTR psz)
{
	USES_CONVERSION;
	return StrCpyW(pswz, A2CW(psz));
}

/*!--------------------------------------------------------------------------
	StrnCpyAFromW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrnCpyAFromW(LPSTR psz, LPCWSTR pswz, int iMax)
{
	USES_CONVERSION;
	return StrnCpyA(psz, W2CA(pswz), iMax);
}

/*!--------------------------------------------------------------------------
	StrnCpyWFromA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrnCpyWFromA(LPWSTR pswz, LPCSTR psz, int iMax)
{
	USES_CONVERSION;
	return StrnCpyW(pswz, A2CW(psz), iMax);
}

/*!--------------------------------------------------------------------------
	StrDupA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrDupA( LPCSTR psz )
{
    if (psz)
    {
	   // Multiply by 2 to account for DBCS strings
   	   LPSTR	pszcpy = Malloc(sizeof(char)*CbStrLenA(psz)*2);
       if (pszcpy)
	      return StrCpyA(pszcpy, psz);
    }
    return NULL;
}

/*!--------------------------------------------------------------------------
	StrDupW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrDupW( LPCWSTR pswz )
{
    if (pswz)
    {
	   LPWSTR	pswzcpy = Malloc(sizeof(WCHAR)*CbStrLenW(pswz));
       if (pswzcpy)
	      return StrCpyW(pswzcpy, pswz);
    }
    return NULL;
}


/*!--------------------------------------------------------------------------
	StrDupAFromW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrDupAFromW( LPCWSTR pwsz )
{
	USES_CONVERSION;
	return StrDupA( W2CA(pwsz) );
}

/*!--------------------------------------------------------------------------
	StrDupWFromA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrDupWFromA( LPCSTR psz )
{
	USES_CONVERSION;
	return StrDupW( A2CW(psz) );
}



/*!--------------------------------------------------------------------------
	StrnCmpA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrnCmpA(LPCSTR psz1, LPCSTR psz2, int nLen)
{
	USES_CONVERSION;
	// It's easier to convert it to a wide string than do the
	// conversion.  (it's a pain having to deal with DBCS characters).
	return StrnCmpW(A2CW(psz1), A2CW(psz2), nLen);
}


/*!--------------------------------------------------------------------------
	StrnCmpW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrnCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen)
{   
	WCHAR *pswz1Temp = AllocaStrDupW(pswz1);        // These memory allocs get memory on the stack, so we do not need to free them
	WCHAR *pswz2Temp = AllocaStrDupW(pswz2);


    // The next three if statements could be replaced with: if( !pswz1Temp || !pswz2Temp) return StrCmpW(pswz1Temp, pswz2Temp);
    // since lstrcmp can handle NULL parameters. But if we do this prefix gets mad.
    //
    if( pswz1Temp == NULL && pswz2Temp == NULL )
    {
        // They are equal both NULL
        //
        return 0;
    }

    if( pswz1Temp == NULL)
    {
        // The first one is NULL thus the second string is greater
        //
        return -1;
    }

    if( pswz2Temp == NULL )
    {
        // The second one is NULL thus the first one is bigger
        //
        return 1;
    }
        
    if (pswz1Temp != NULL && StrLenW(pswz1Temp) > nLen)
       pswz1Temp[nLen] = 0;
	if (pswz2Temp != NULL && StrLenW(pswz2Temp) > nLen)
	   pswz2Temp[nLen] = 0;
	
    
    return StrCmpW(pswz1Temp, pswz2Temp);
}


/*!--------------------------------------------------------------------------
	StrniCmpA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrniCmpA(LPCSTR psz1, LPCSTR psz2, int nLen)
{
	CHAR *psz1Temp = AllocaStrDupA(psz1);
	CHAR *psz2Temp = AllocaStrDupA(psz2);

	CharUpperBuffA(psz1Temp, StrLenA(psz1Temp));
	CharUpperBuffA(psz2Temp, StrLenA(psz2Temp));

	return StrnCmpA(psz1Temp, psz2Temp, nLen);
}


/*!--------------------------------------------------------------------------
	StrniCmpW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrniCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen)
{
	WCHAR *pswz1Temp = AllocaStrDupW(pswz1);
	WCHAR *pswz2Temp = AllocaStrDupW(pswz2);

	CharUpperBuffW(pswz1Temp, StrLenW(pswz1Temp));
	CharUpperBuffW(pswz2Temp, StrLenW(pswz2Temp));

	return StrnCmpW(pswz1Temp, pswz2Temp, nLen);
}

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	assert(lpa != NULL);
	assert(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
}

LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	assert(lpw != NULL);
	assert(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

LPTSTR LoadAndAllocString(UINT ids)
{
	TCHAR	* psz = NULL;
	TCHAR	* pszT = NULL;
	INT	cch = 0;
	int		iRet;

	cch = 64;
	psz = Malloc(64*sizeof(TCHAR));
	if (psz == NULL)
		return NULL;
					
	iRet = LoadString(NULL, ids, psz, cch);

	if (iRet == 0)
    {
		// couldn't find the string
        Free(psz);
		return NULL;
    }

	while (iRet >= (cch - 1))
	{
		cch += 64;
		pszT = Realloc(psz, (cch*sizeof(TCHAR)));
		if (pszT == NULL)
		{
			Free(psz);
			return NULL;
		}
		psz = pszT;

		iRet = LoadString(NULL, ids, psz, cch);
	}
	
	return psz;
}

LPTSTR GetSafeString(LPTSTR psz)
{
	static LPTSTR s_szEmpty = _T("");
	return psz ? psz : s_szEmpty;
}

LPWSTR GetSafeStringW(LPWSTR pwsz)
{
	static LPWSTR s_wszEmpty = L"";
	return pwsz ? pwsz : s_wszEmpty;
}

LPSTR GetSafeStringA(LPSTR pasz)
{
	static LPSTR s_aszEmpty = "";
	return pasz ? pasz : s_aszEmpty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------


#undef CONST_STRING
#undef CONST_STRINGA
#undef CONST_STRINGW

#ifdef _STRINGS_DEFINE_STRINGS

    #define CONST_STRING(rg,s)   const TCHAR rg[] = TEXT(s);
    #define CONST_STRINGA(rg,s) const char rg[] = s;
    #define CONST_STRINGW(rg,s)  const WCHAR rg[] = s;

#else

    #define CONST_STRING(rg,s)   extern const TCHAR rg[];
    #define CONST_STRINGA(rg,s) extern const char rg[];
    #define CONST_STRINGW(rg,s)  extern const WCHAR rg[];

#endif

CONST_STRING(c_szRegKeyControlProductOptions, "System\\CurrentControlSet\\Control\\ProductOptions")
CONST_STRING(c_szRegKeyHotFix, "Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix")
CONST_STRING(c_szRegKeyTcpIpParamsInterfaces, "Tcpip\\Parameters\\Interfaces\\")
CONST_STRING(c_szRegKeyWindowsNTCurrentVersion, "Software\\Microsoft\\Windows NT\\CurrentVersion")


CONST_STRING(c_szRegAddressType,		"AddressType")
CONST_STRING(c_szRegCurrentBuild,		"CurrentBuild")
CONST_STRING(c_szRegCurrentBuildNumber,	"CurrentBuildNumber")
CONST_STRING(c_szRegCurrentType,		"CurrentType")
CONST_STRING(c_szRegCurrentVersion,		"CurrentVersion")
CONST_STRING(c_szRegDhcpClassID,		"DhcpClassID")
CONST_STRING(c_szRegDhcpNameServer,		"DhcpNameServer")
CONST_STRING(c_szRegInstalled,			"Installed")
CONST_STRING(c_szRegIPAutoconfigurationEnabled,	"IPAutoconfigurationEnabled")
CONST_STRING(c_szRegNameServer,			"NameServer")

CONST_STRING(c_szRegNetLogonParams, "System\\CurrentControlSet\\Services\\Netlogon\\Parameters")
CONST_STRING(c_szRegSysVolReady, "SysVolReady")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\xportst.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      xportst.c
//
//  Abstract:
//
//      Tests for the transports on the local workstation
//
//  Author:
//
//      1-Feb-1998 (karolys)
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--


/*==========================< Include files >==============================*/
#include "precomp.h"

#define BUFF_SIZE 650



/*===========================< NetBT vars >===============================*/

#define NETBIOS_NAME_SIZE 16

/*==========================< DHCP Include>==============================*/

#include "dhcptest.h"


/*=======================< Function prototypes >=================================*/

DWORD
OpenDriver(
    OUT HANDLE *Handle,
    IN LPWSTR DriverName
    )
//++
//
// Routine Description:
//
//    This function opens a specified IO drivers.
//
// Arguments:
//
//    Handle - pointer to location where the opened drivers handle is
//        returned.
//
//    DriverName - name of the driver to be opened.
//
// Return Value:
//
//    Windows Error Code.
//--
{

 OBJECT_ATTRIBUTES   objectAttributes;
 IO_STATUS_BLOCK     ioStatusBlock;
 UNICODE_STRING      nameString;
 NTSTATUS            status;

 *Handle = NULL;

 //
 // Open a Handle to the IP driver.
 //

 RtlInitUnicodeString(&nameString, DriverName);

 InitializeObjectAttributes(
     &objectAttributes,
     &nameString,
     OBJ_CASE_INSENSITIVE,
     (HANDLE) NULL,
     (PSECURITY_DESCRIPTOR) NULL
     );

 status = NtCreateFile(
     Handle,
     SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
     &objectAttributes,
     &ioStatusBlock,
     NULL,
     FILE_ATTRIBUTE_NORMAL,
     FILE_SHARE_READ | FILE_SHARE_WRITE,
     FILE_OPEN_IF,
     0,
     NULL,
     0
     );

 return( RtlNtStatusToDosError( status ) );

}



//-------------------------------------------------------------------------//
//######  I s I c m p R e s p o n s e ()  #################################//
//-------------------------------------------------------------------------//
BOOL 
IsIcmpResponseA( 
    LPCSTR  pszIpAddrStr
    ) 
//++
//
//  Routine Description:
//
//      Sends ICMP echo request frames to the IP address specified.
//    
//  Arguments:
//
//      pszIAddrStr - address to ping
//
//  Return Value:
//
//      TRUE:  Test suceeded.
//      FALSE: Test failed
//
//--
{

    char   *SendBuffer, *RcvBuffer;
    int     i, nReplyCnt;
    int     nReplySum = 0;
    HANDLE  hIcmp;
    PICMP_ECHO_REPLY reply;

    //
    //  contact ICMP driver
    //
    hIcmp = IcmpCreateFile();
    if ( hIcmp == INVALID_HANDLE_VALUE ) 
    {
        DebugMessage( "    [FATAL] Cannot get ICMP handle." );
        return FALSE;
    }

    //
    //  prepare buffers
    //
    SendBuffer = Malloc( DEFAULT_SEND_SIZE );
    if ( SendBuffer == NULL ) 
    {
        DebugMessage("    [FATAL] Cannot allocate buffer for the ICMP echo frame." );
        return FALSE;
    }
    ZeroMemory( SendBuffer, DEFAULT_SEND_SIZE );

    RcvBuffer = Malloc( MAX_ICMP_BUF_SIZE );
    if ( RcvBuffer == NULL ) 
    {
        Free( SendBuffer );
        DebugMessage("    [FATAL] Cannot allocate buffer for the ICMP echo frame." );
        return FALSE;
    }
    ZeroMemory( RcvBuffer, MAX_ICMP_BUF_SIZE );

    //
    //  send ICMP echo request
    //
    for ( i = 0; i < PING_RETRY_CNT; i++ ) 
    {
        nReplyCnt = IcmpSendEcho( hIcmp,
                                  inet_addr(pszIpAddrStr),
                                  SendBuffer,
                                  (unsigned short )DEFAULT_SEND_SIZE,
                                  NULL,
                                  RcvBuffer,
                                  MAX_ICMP_BUF_SIZE,
                                  DEFAULT_TIMEOUT
                                );
        //
        //  test for destination unreachables
        //
        if ( nReplyCnt != 0 ) 
        {
            reply = (PICMP_ECHO_REPLY )RcvBuffer;
            if ( reply->Status == IP_SUCCESS ) 
            {
                nReplySum += nReplyCnt;
            }
        }

    } /* for loop */

    //
    //  cleanup
    //
    Free( SendBuffer );
    Free( RcvBuffer );
    IcmpCloseHandle( hIcmp );
    if ( nReplySum == 0 ) 
    { 
        return FALSE; 
    }
    else 
    { 
        return TRUE; 
    }

} /* END OF IsIcmpResponse() */



BOOL 
IsIcmpResponseW( 
    LPCWSTR  pszIpAddrStr
    )
{
    LPSTR   pszAddr = NULL;
    BOOL    fRetval;

    pszAddr = StrDupAFromW(pszIpAddrStr);
    if (pszAddr == NULL)
        return FALSE;

    fRetval = IsIcmpResponseA(pszAddr);

    Free(pszAddr);
    
    return fRetval; 
}






//-------------------------------------------------------------------------//
//######  W S L o o p B k T e s t ()  #####################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Opens a datagram socket and sends a UDP frame through the loopback.//
//      If the frame comes back then Winsock and AFD are most probably OK. //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
BOOL WSLoopBkTest( PVOID Context ) {

    BOOL   RetVal = TRUE;
    SOCKET tstSock; 
    DWORD  optionValue;     // helper var for setsockopt()
    SOCKADDR_IN sockAddr;   // struct holding source socket info

    //
    //  create a socket
    //
    /*
    tstSock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( tstSock  == INVALID_SOCKET ) {
        printf( "    [FATAL] socket creation failed!\n" );
        printf( "    You have a potential Winsock problem!\n" );
        return FALSE;
    }    

    tstSock = WSASocket( PF_INET, 
                         SOCK_DGRAM, 
                         IPPROTO_UDP, 
                         NULL,
                         0,
                         WSA_FLAG_OVERLAPPED 
                       ); 
    if ( tstSock  == INVALID_SOCKET ) {
        printf( "    [FATAL] socket creation failed!\n" );
        printf( "    You have a potential Winsock problem!\n" );
        return FALSE;
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = 0;           // use any local address
    sockAddr.sin_port = htons( PORT_4_LOOPBK_TST );
//    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(tstSock, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) {
        printf( "    [FATAL] bind() failed with error %d!\n", WSAGetLastError() );
        printf( "    You have a potential Winsock problem!\n" );
        return FALSE;
    }
    */





    return RetVal;

    UNREFERENCED_PARAMETER( Context );

} /* END OF WSLoopBkTest() */


    
 



//######################  END OF FILE xportst.c  ##########################//
//-------------------------------------------------------------------------//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\dglogs.cpp ===
// Dglogs.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Dglogsps.mk in the project directory.

#include "stdafx.h"
#include "dglogsres.h"
#include <initguid.h>
#include "Dglogs.h"

#include "Dglogs_i.c"
#include "DglogsCom.h"
#include "Diagnostics.h"
#include <netsh.h>


DWORD WINAPI
InitHelperDllEx(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    );

DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
	return InitHelperDllEx(dwNetshVersion,pReserved);
}

//extern GUID CLSID_Dgnet;

CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DglogsCom, CDglogsCom)
    //OBJECT_ENTRY(CLSID_Dgnet, CGotNet)
END_OBJECT_MAP()

HMODULE g_hModule;
CDiagnostics g_Diagnostics;
//STDAPI RegisterhNetshHelper();
//STDAPI UnRegisterNetShHelper();

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DGLOGSLib);
        DisableThreadLibraryCalls(hInstance);
        g_hModule = (HMODULE) hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // Register with Netsh
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\dglogscp.h ===
#ifndef _DGLOGSCP_H_
#define _DGLOGSCP_H_







template <class T>
class CProxy_IDglogsComEvents : public IConnectionPointImpl<T, &DIID__IDglogsComEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_ProgressReport(BSTR * pbstrMsg, LONG nPercentDone)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = (BSTR )*pbstrMsg;
				pvars[0] = nPercentDone;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\dglogscom.h ===
// DglogsCom.h : Declaration of the CDglogsCom

#ifndef __DGLOGSCOM_H_
#define __DGLOGSCOM_H_

#include "dglogsres.h"       // main symbols
#include "DglogsCP.h"
#include "Diagnostics.h"

/////////////////////////////////////////////////////////////////////////////
// CDglogsCom
class ATL_NO_VTABLE CDglogsCom : 
	//public CComObjectRootEx<CComSingleThreadModel>,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CDglogsCom, &CLSID_DglogsCom>,
	public IConnectionPointContainerImpl<CDglogsCom>,
	public IDispatchImpl<IDglogsCom, &IID_IDglogsCom, &LIBID_DGLOGSLib>,
	public CProxy_IDglogsComEvents< CDglogsCom >,
    public IProvideClassInfo2Impl<&CLSID_DglogsCom, NULL,&LIBID_DGLOGSLib> 
{
public:
	CDglogsCom();

DECLARE_REGISTRY_RESOURCEID(IDR_DGLOGSCOM)
//DECLARE_REGISTRY_RESOURCEID(IDR_DGNET)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDglogsCom)
	COM_INTERFACE_ENTRY(IDglogsCom)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2) 
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CDglogsCom)
	CONNECTION_POINT_ENTRY(DIID__IDglogsComEvents)
END_CONNECTION_POINT_MAP()


// IDglogsCom
public:
	STDMETHOD(ExecQuery)(/*[in]*/ BSTR bstrCatagory, /*[in]*/ LONG bFlag, /*[out, retval]*/ BSTR *pbstrResult);
    STDMETHOD(Initialize)(BSTR *pbstrResult);
    STDMETHOD(StopQuery)();
public:
    DWORD        m_dwThreadId;
    CDiagnostics m_Diagnostics;

public:
    HANDLE m_hThreadTerminated;
    HANDLE m_hTerminateThread;
    LONG   m_lThreadCount;
};

#endif //__DGLOGSCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\dglogscom.cpp ===
// DglogsCom.cpp : Implementation of CDglogsCom
#include "stdafx.h"
#include "Dglogs.h"
#include "DglogsCom.h"
#include "Commdlg.h"


// Counts the total number of worker threads running.
//
LONG g_lThreadCount;

/*++

Routine Description
    Collects the diagnostics information that the client requested. A worker thread is spawened so 
    the UI (webpage) does not have to wait for the diagnostics to complete. If the UI waits 
    the web page freezes.

Arguments
    lpParameter -- Pointer to the DglogsCom Object

Return Value
    error code

--*/
DWORD WINAPI DiagnosticsThreadProc(LPVOID lpParameter)
{
    BSTR bstrResult;
    CDglogsCom *pDglogsCom = (CDglogsCom *)lpParameter;
    HRESULT hr;


    // Every thread in COM needs to initialize COM in order to use COM
    //
    hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
    if( SUCCEEDED(hr) )
    {
        // Each thread needs to reference the class
        //
        pDglogsCom->AddRef();

        // Tell the Diagnostics object that we are accessing it though COM not netsh
        //
        pDglogsCom->m_Diagnostics.SetInterface(COM_INTERFACE);

        // Tell the Diagnostics object to send status reports to the client
        //
        pDglogsCom->m_Diagnostics.RequestStatusReport(TRUE,pDglogsCom);

        // Execute the clients query
        //
        pDglogsCom->m_Diagnostics.ExecQuery();
        
        // We are done referencing the Class, dec the ref count
        //
        pDglogsCom->Release();

        // Uniniatlize COM
        //
        CoUninitialize();
    }    
    else
    {
        // We no longer need the class
        pDglogsCom->Release();
    }

    // Tell the main thread that the worker thread has completed
    //
    SetEvent(pDglogsCom->m_hThreadTerminated);

    // There are 0 local threads. (Only one thread can be in here at any given time)
    //
    pDglogsCom->m_lThreadCount = 0;

    // The thread has completed its work. Thus the thread count is 0 again. (Only one thread at a time)
    //
    InterlockedExchange(&g_lThreadCount,0);    

    ExitThread(0);

    return 0;
}

/*++

Routine Description
    Initialize the COM object and the Diagnostics object

Arguments
    pbstrResult -- Not used

Return Value
    HRESULT

--*/
STDMETHODIMP CDglogsCom::Initialize(BSTR *pbstrResult)
{
    if( _Module.GetLockCount() > 1)
    {
    }

    return S_OK;
}

/*++

Routine Description
    Process the clients request by creating a thread to collect the data,

Arguments
    bstrCatagory -- List of the catagories to collect divided by semicollens i.e. "ieproxy;mail;news;adapter"
    bFlag        -- The actions to perform i.e. PING, SHOW, CONNECT
    pbstrResult  -- Stores the result as an XML string

Return Value
    HRESULT

--*/

STDMETHODIMP CDglogsCom::ExecQuery(BSTR bstrCatagory, LONG bFlag, BSTR *pbstrResult)
{
	
    HANDLE hThread;
    WCHAR szFilename[MAX_PATH+1];
    
    *pbstrResult = NULL;

    // For security reason we can not run inside of internet explorer. Otherwise 
    // someone could create a web page using this active X component and collect
    // the clients info. If IE is renamed to something else other than explorer,exe
    // IE will not run Active X controls or scripts
    if( GetModuleFileName(NULL,szFilename,MAX_PATH) )
    {
        LPWSTR ExeName;
        LONG len = wcslen(szFilename) - wcslen(L"helpctr.exe");
        if( len <= 0 || _wcsicmp(&szFilename[len], L"helpctr.exe") != 0 )
        {            
            // The name of process is not helpctr, refuse to run but do not tell the 
            // user why. 
            *pbstrResult = SysAllocString(ids(IDS_FAILED));                        
            //return E_FAIL;
            return S_FALSE;
        }                
    }
    else
    {        
        // Unable to get process name, fail and abort. Do not provide rason for
        // failure.
        *pbstrResult = SysAllocString(ids(IDS_FAILED));                        
        return S_FALSE;
    }   

    // Check if an other thread is already in this function
    //
    if( InterlockedCompareExchange(&g_lThreadCount,1,0) == 0 )
    {

        // Need to make sure that CDiagnostics Initialized correctly in the CDglogsCom constructor
        if( !m_Diagnostics.m_bDiagInit )
        {
            *pbstrResult = SysAllocString(ids(IDS_FAILED));                        
            InterlockedExchange(&g_lThreadCount,0);        
            return S_FALSE;            
        }


        m_lThreadCount = 1;

        // The information is passed to the thread via gloabl parameters. In the near future it will be passed
        // as parameters.
        //
        m_Diagnostics.SetQuery((WCHAR *)bstrCatagory,bFlag);        

        // In order to cancel the thread we set events. The worker thread checks to see if the main thread
        // has set the cancel event
        //
        m_hThreadTerminated = CreateEvent(NULL, TRUE, FALSE, NULL);
        m_hTerminateThread  = CreateEvent(NULL, TRUE, FALSE, NULL);

        // Set the cancel option so the worker thread can be canceled at any time.
        //
        m_Diagnostics.SetCancelOption(m_hTerminateThread);

        // Add the ref count to the thread so the class does not dissappear underneath it
        AddRef();

        // Create a worker thread to collect the information from WMI.
        //                
        hThread = CreateThread(NULL,                    // Security Attributes
                               0,                       // Stack Size
                               DiagnosticsThreadProc,   // Start Proc
                               this,                    // Thread Paramter
                               0,                       // Creation flags
                               &m_dwThreadId            // ID of thethread being created
                               );

        if( hThread )
        {
            // We are done with the thread. Close it.
            //
            CloseHandle(hThread);
            *pbstrResult = SysAllocString(ids(IDS_PASSED));
            // Do not do a release cause the thread succeeded and is referencing the class now
            return S_OK;
        }
        else
        {
            // Could not create the thread. So the thread count is 0 again;
            //
            InterlockedExchange(&g_lThreadCount,0);
            *pbstrResult = SysAllocString(ids(IDS_FAILED));                        
            // The thread failed to be created not referencing the class.
            Release();
            return E_FAIL;
        }

    }

    // Another instance is already running. We only allow one instance at a time.
    *pbstrResult = SysAllocString(ids(IDS_FAILED));   

    return S_FALSE;
}

/*++

Routine Description
    Cancels the worker thread

Arguments

Return Value
    HRESULT

--*/
STDMETHODIMP CDglogsCom::StopQuery()
{   
    // Check if there is a worker thread.
    //
    if( m_lThreadCount )
    {
        // There is a worker thread for this instance. Set an event to tell it to stop processing
        //
        SetEvent(m_hTerminateThread);  

        // If the worker thread is doing an RPC call send the quit message.
        // In theory this should cancel the RPC call
        //
        PostThreadMessage(m_dwThreadId, WM_QUIT, NULL, NULL);

        // Wait until it's terminated
        //
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hThreadTerminated, 10000))
        {
            ResetEvent(m_hThreadTerminated);
        }
        
        return S_OK;
    }
    
    return S_FALSE;
}


/*++

Routine Description
    Inialize the COM object

Arguments
    
Return Value
    HRESULT

--*/
CDglogsCom::CDglogsCom()
{       
    if( m_Diagnostics.Initialize(COM_INTERFACE) == FALSE )
    {
        // If m_Diagnostics.Initialize fails it sets m_bDiagInit to false. Need to check if this
        // value is TRUE inorder to execute anyfunctions in CDiagnostics
        return;
    }

    if( _Module.GetLockCount() == 0)
    {
        // Reset globals only for the first instance of the object
        //
        g_lThreadCount = 0;
    }   
}


/*++

Routine Description
    Uninialize the COM object

Arguments
    
Return Value
    HRESULT

--*/
CDglogsCom::~CDglogsCom()
{

    if( m_hThreadTerminated ) 
    {
        CloseHandle(m_hThreadTerminated);
        m_hThreadTerminated = NULL;
    }
    if( m_hTerminateThread )
    {
        CloseHandle(m_hTerminateThread);
        m_hTerminateThread = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\dglogsnetsh.cpp ===
#include "dglogsnetsh.h"
//#include <netsh.h>

// Imported netsh.exe function
//
RegisterHelper22  RegisterHelper2  = NULL;
RegisterContext22 RegisterContext2 = NULL;
PrintMessage22    PrintMessage2    = NULL;


const WCHAR c_szTroublshootCmdLine[] = L"explorer.exe hcp://system/netdiag/dglogs.htm";

//extern CDiagnostics g_Diagnostics;

CDiagnostics * g_pDiagnostics;

static const GUID g_MyGuid = 
{ 0xcc41b21b, 0x8040, 0x4bb0, { 0xac, 0x2a, 0x82, 0x6, 0x23, 0x16, 0x9, 0x40 } };


//
// declare the command structs.  you need to declare the
// structs based on how you will be grouping them.  so,
// for example, the three 'show' commands should be in
// the same struct so you can put them in a single group
//
CMD_ENTRY g_TopLevelCommands[] =
{
    CREATE_CMD_ENTRY(SHOW_GUI, HandleShowGui),
};

// table of SHOW commands
//
static CMD_ENTRY isShowCmdTable[] =
{
    CREATE_CMD_ENTRY(SHOW_MAIL,     HandleShow),
    CREATE_CMD_ENTRY(SHOW_NEWS,     HandleShow),
    CREATE_CMD_ENTRY(SHOW_PROXY,    HandleShow),
    CREATE_CMD_ENTRY(SHOW_VERSION,  HandleShow),
    CREATE_CMD_ENTRY(SHOW_OS,       HandleShow),
    CREATE_CMD_ENTRY(SHOW_COMPUTER, HandleShow),
    CREATE_CMD_ENTRY(SHOW_WINS,     HandleShow),
    CREATE_CMD_ENTRY(SHOW_DNS,      HandleShow),
    CREATE_CMD_ENTRY(SHOW_GATEWAY,  HandleShow),
    CREATE_CMD_ENTRY(SHOW_DHCP,     HandleShow),
    CREATE_CMD_ENTRY(SHOW_IP,       HandleShow),
    CREATE_CMD_ENTRY(SHOW_ADAPTER,  HandleShow),
    CREATE_CMD_ENTRY(SHOW_CLIENT,   HandleShow),
    CREATE_CMD_ENTRY(SHOW_MODEM,    HandleShow),
    CREATE_CMD_ENTRY(SHOW_ALL,      HandleShow),
    CREATE_CMD_ENTRY(SHOW_TEST,     HandleShow),
};

// table of PING commands
//
static CMD_ENTRY isPingCmdTable[] =
{
    CREATE_CMD_ENTRY(PING_MAIL,     HandlePing),
    CREATE_CMD_ENTRY(PING_NEWS,     HandlePing),
    CREATE_CMD_ENTRY(PING_PROXY,    HandlePing),
    CREATE_CMD_ENTRY(PING_WINS,     HandlePing),
    CREATE_CMD_ENTRY(PING_DNS,      HandlePing),
    CREATE_CMD_ENTRY(PING_GATEWAY,  HandlePing),
    CREATE_CMD_ENTRY(PING_DHCP,     HandlePing),
    CREATE_CMD_ENTRY(PING_IP,       HandlePing),
    CREATE_CMD_ENTRY(PING_ADAPTER,  HandlePing),
    CREATE_CMD_ENTRY(PING_LOOPBACK, HandlePing),
    CREATE_CMD_ENTRY(PING_IPHOST,   HandlePing),
};

// table of connect commands
//
static CMD_ENTRY isConnectCmdTable[] =
{
    CREATE_CMD_ENTRY(CONNECT_MAIL,     HandleConnect),
    CREATE_CMD_ENTRY(CONNECT_NEWS,     HandleConnect),
    CREATE_CMD_ENTRY(CONNECT_PROXY,    HandleConnect),
    CREATE_CMD_ENTRY(CONNECT_IPHOST,   HandleConnect),
};


// table of above group commands
//
static CMD_GROUP_ENTRY isGroupCmds[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,    isShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_PING,    isPingCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_CONNECT, isConnectCmdTable),
};


DWORD WINAPI
InitHelperDllEx(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    DWORD  dwSize = 0;
    NS_HELPER_ATTRIBUTES attMyAttributes;
    GUID                 guidNetShGuid = NETSH_ROOT_GUID;
    HMODULE hModule;
    HMODULE hModuleNow;
    HRESULT hr;

    // Need to dynamicaly load netsh.exe cause it conflicts with the loading of WMI
    //
    hModule = LoadLibrary(L"netsh.exe");

    if( !hModule || hModule != GetModuleHandle(NULL) )
    {
        return FALSE;
    }

    // Load the netsh.exe functions we require.
    //
    RegisterHelper2  = (RegisterHelper22)  GetProcAddress(hModule,"RegisterHelper");
    if( RegisterHelper2 )
    {
        RegisterContext2 = (RegisterContext22) GetProcAddress(hModule,"RegisterContext");
        if( RegisterContext2 )
        {
            PrintMessage2    = (PrintMessage22)    GetProcAddress(hModule,"PrintMessage");                
        }
    }

    if( !PrintMessage2 )
    {
        // If PrintMessage2 failed to load they all failed and we bail.
        //
        return FALSE;
    }

    hr = CoInitializeEx(NULL,COINIT_APARTMENTTHREADED);
    if( FAILED(hr) )
    {
        return FALSE;
    }

    // Netsh only calls this function once
    g_pDiagnostics = new CDiagnostics;

    if( !g_pDiagnostics )
    {
        return FALSE;
    }


    if( g_pDiagnostics->Initialize(NETSH_INTERFACE) == FALSE )
    {
        delete g_pDiagnostics;
        g_pDiagnostics = NULL;
        return FALSE;
    }

    // Tell the Diagnostics that we are going through the netsh interface and not COM interface
    //
    g_pDiagnostics->SetInterface(NETSH_INTERFACE);

    // Register this module as a helper to the netsh root
    // context.
    //
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.dwVersion          = DGLOGS_HELPER_VERSION;
    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.pfnStart           = DglogsStartHelper;
    attMyAttributes.pfnStop            = DglogsStopHelper;

    DWORD dwErr = RegisterHelper2( &guidNetShGuid, &attMyAttributes );

    return dwErr;
}


DWORD 
WINAPI
DglogsStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = TOKEN_DGLOGS;
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = DGLOGS_CONTEXT_VERSION;
    attMyAttributes.dwFlags     = CMD_FLAG_LOCAL;
    attMyAttributes.ulNumTopCmds= sizeof(g_TopLevelCommands)/sizeof(CMD_ENTRY);
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])g_TopLevelCommands;
    attMyAttributes.ulNumGroups = sizeof(isGroupCmds)/sizeof(CMD_GROUP_ENTRY);
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])isGroupCmds;
    attMyAttributes.pfnDumpFn   = NULL;

    dwErr = RegisterContext2( &attMyAttributes );
                
    return dwErr;
}

DWORD 
WINAPI
DglogsStopHelper (
  DWORD dwReserved
)
{
    if( g_pDiagnostics )
    {
        delete g_pDiagnostics;
        g_pDiagnostics = NULL;
    }
    CoUninitialize();
    return NO_ERROR ;
}


extern PrintMessage22 PrintMessage2;

#undef PrintMessage
#define PrintMessage PrintMessage2

DWORD
HandleShowGui(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    BOOL                fResult     = TRUE;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    // + 2 because of '\0' and '\\'
    WCHAR               szCmdLine[MAX_PATH*2+2];
    WCHAR               szDesktop[MAX_PATH+1] = L"";
    STARTUPINFO StartupInfo;

    // Determine the type of desktop. If it is a telnet desktop we will be
    // unable to run the diagnostics web page
    ZeroMemory((LPVOID) &si, sizeof(si));
    si.cb = sizeof(STARTUPINFO);        

    GetStartupInfo(&StartupInfo);
    wcsncpy(szDesktop,StartupInfo.lpDesktop,MAX_PATH);
    szDesktop[MAX_PATH] = 0;


    #define TELNET_STRING_LEN 15
    if( _memicmp(szDesktop,L"telnetsrvwinsta",TELNET_STRING_LEN * sizeof(WCHAR)) == 0)    ////TelnetSrvWinSta\\IlntSrvDesktop_0
    {
        DisplayMessageT(ids(IDS_NOTELNETGUI));
    }

    else
    {
        WCHAR wszWinDir[MAX_PATH+1];
        UINT Length;
        wszWinDir[MAX_PATH] = L'\0';

        Length = GetWindowsDirectory(wszWinDir,MAX_PATH);
        if( Length > 0 && Length < MAX_PATH )
        {
            _snwprintf(szCmdLine,MAX_PATH*2 + 1,L"%s\\%s",wszWinDir,c_szTroublshootCmdLine);            

            fResult = CreateProcess(
                NULL,
                szCmdLine,
                NULL,
                NULL,
                FALSE,
                0,
                NULL,
                NULL,
                &si,
                &pi);
            if (fResult)
            {
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                DisplayMessageT(ids(IDS_GUISTARTED));
            }
            else
            {
            
                DisplayMessageT(ids(IDS_GUINOTSTARTED));            
            }
        }
        else
        {
            DisplayMessageT(ids(IDS_GUINOTSTARTED));            
        }
    }
    return 0;
}

LPWSTR ShowCommands[] =
{
    CMD_MAIL,       //L"show mail"
    CMD_NEWS,       //L"show news"
    CMD_PROXY,      //L"show ieproxy"
    CMD_OS,         //L"show os"
    CMD_COMPUTER,   //L"show computer"
    CMD_VERSION,    //L"show version"
    CMD_DNS,        //L"show dns"
    CMD_GATEWAY,    //L"show gateway"
    CMD_DHCP,       //L"show dhcp"
    CMD_IP,         //L"show ip"
    CMD_WINS,       //L"show wins"
    CMD_ADAPTER,    //L"show adapter"
    CMD_MODEM,      //L"show modem"
    CMD_CLIENT,     //L"show client"
    CMD_ALL,        //L"show all"
    CMD_TEST,       //L"show test"
    CMD_GUI,        //L"show gui"
    NULL
};

LPWSTR PingCommands[] =
{
    CMD_MAIL,       //L"ping mail"
    CMD_NEWS,       //L"ping news"
    CMD_PROXY,      //L"ping ieproxy"
    CMD_DNS,        //L"ping dns"
    CMD_GATEWAY,    //L"ping gateway"
    CMD_DHCP,       //L"ping dhcp"
    CMD_IP,         //L"ping ip"
    CMD_WINS,       //L"ping wins"
    CMD_ADAPTER,    //L"ping adapter"
    CMD_LOOPBACK,   //L"ping loopback"
    CMD_IPHOST,     //L"ping iphost"
    NULL
};

LPWSTR ConnectCommands[] =
{
    CMD_MAIL,    //L"connect mail"
    CMD_NEWS,    //L"connect news"
    CMD_PROXY,   //L"connect ieproxy"
    CMD_IPHOST,  //L"connect iphost"
    NULL
};


LPWSTR FlagCommands[] =
{
    SWITCH_VERBOSE,
    SWITCH_PROPERTIES,
    NULL
};

// Checks if a name matches part of a command. i.e. show mai means show mail
LPWSTR
GetCommandName(
    LPWSTR Commands[],
    LPWSTR Text,
    BOOL bFull
    )
{
    int i;
    int len = 0;

    if( Text == NULL )
    {
        return NULL;
    }
    for(i=0; Text[i]!=L'\0'; i++)
    {
        Text[i] = towlower(Text[i]);
    }
    len = i;
    for(i=0; Commands[i]!=NULL; i++)
    {
        if( (bFull && wcscmp(Text,Commands[i])==0) ||
            (!bFull && wcsncmp(Text,Commands[i],len) == 0) )
        {
            return Commands[i];
        }
    }

    return NULL;
}

DWORD
HandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description
    Handles the Show command

Arguments
    none

Return Value
    none

--*/
{
    WCHAR *pszwVerbose = NULL;
    WCHAR *pszwInstance = NULL;
    BOOLEAN bFlags = FLAG_VERBOSE_LOW;
    LPWSTR pwszCommand;

    pwszCommand = GetCommandName(ShowCommands,ppwcArguments[2],FALSE);
    if( !pwszCommand )
    {
        return ERROR_INVALID_SYNTAX;
    }
    // Need three arguments (show,netdiag catagory)
    //
    if( lstrcmpi(pwszCommand, CMD_ADAPTER) == 0 ||
        lstrcmpi(pwszCommand, CMD_MODEM)   == 0 ||
        lstrcmpi(pwszCommand, CMD_CLIENT)  == 0 ||
        lstrcmpi(pwszCommand, CMD_WINS)    == 0 ||
        lstrcmpi(pwszCommand, CMD_DHCP)    == 0 ||
        lstrcmpi(pwszCommand, CMD_DNS)     == 0 ||
        lstrcmpi(pwszCommand, CMD_IP)      == 0 ||
        lstrcmpi(pwszCommand, CMD_GATEWAY) == 0 )
    {
        switch(dwArgCount)
        {
        case 5:
            if( (lstrcmpi(ppwcArguments[3],SWITCH_VERBOSE) == 0 ||
                lstrcmpi(ppwcArguments[3],SWITCH_PROPERTIES) == 0) && 
                (lstrcmpi(ppwcArguments[4],SWITCH_VERBOSE) == 0 ||
                lstrcmpi(ppwcArguments[4],SWITCH_PROPERTIES) == 0))
            {
                return ERROR_INVALID_SYNTAX;
            }

            if( lstrcmpi(ppwcArguments[3],SWITCH_VERBOSE) == 0 ||
                lstrcmpi(ppwcArguments[3],SWITCH_PROPERTIES) == 0 )
            {
                // Has first the switch then the instance
                //
                pszwVerbose = ppwcArguments[3];
                pszwInstance = ppwcArguments[4];
            }
            else if( lstrcmpi(ppwcArguments[4],SWITCH_VERBOSE) == 0 ||
                     lstrcmpi(ppwcArguments[4],SWITCH_PROPERTIES) == 0 )
            {
                // Has first the instance and then the switch
                //
                pszwVerbose = ppwcArguments[4];
                pszwInstance = ppwcArguments[3];                
            }
            else
            {
                // Invalid number of arguments
                //
                return ERROR_INVALID_SYNTAX;
            }
            break;

        case 4:
            if( lstrcmpi(ppwcArguments[3],SWITCH_VERBOSE) == 0 ||
                lstrcmpi(ppwcArguments[3],SWITCH_PROPERTIES) == 0)
            {
                pszwVerbose = ppwcArguments[3];
            }
            else 
            {
                // Has na instance but no swicth
                //
                pszwInstance = ppwcArguments[3];       
                
            }
            break;

        case 3:
            // No instance and no switch
            //
            break;

        default:
                // Invalid number of arguments
                //
                return ERROR_INVALID_SYNTAX;

        }
    }
    else if( dwArgCount == 4 && 
             (lstrcmpi(ppwcArguments[3],SWITCH_VERBOSE) == 0 ||
              lstrcmpi(ppwcArguments[3],SWITCH_PROPERTIES) == 0))
    {
                // Has a switch
                //
                pszwVerbose = ppwcArguments[3];
    }
    else if( dwArgCount == 4 && lstrcmpi(ppwcArguments[3],SWITCH_PROPERTIES) == 0)
    {
                // Has a switch
                //
                pszwVerbose = ppwcArguments[3];
    }
    else if( dwArgCount != 3 )
    {
        // Invalid number of arguments
        //
        return ERROR_INVALID_SYNTAX;
    }

    if( pszwVerbose )
    {
        if( lstrcmpi(pszwVerbose,SWITCH_VERBOSE) == 0 )
        {
            bFlags = FLAG_VERBOSE_HIGH;
        }

        if( lstrcmpi(pszwVerbose,SWITCH_PROPERTIES) == 0 )
        {
            bFlags = FLAG_VERBOSE_MEDIUM;
        }
    }

                        
    g_pDiagnostics->ExecQuery(pwszCommand, (bFlags | FLAG_CMD_SHOW) ,pszwInstance);

    return 0;
}

DWORD
HandlePing(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description
    Handles the Ping command

Arguments
    none

Return Value
    none

--*/

{

    WCHAR *pszwInstance = NULL;

    LPWSTR pwszCommand;

    pwszCommand = GetCommandName(PingCommands,ppwcArguments[2],FALSE);
    if( !pwszCommand )
    {
        return ERROR_INVALID_SYNTAX;
    }


    // ERROR_INVALID_SYNTAX;

    if( lstrcmpi(pwszCommand,CMD_ADAPTER) == 0 ||
        lstrcmpi(pwszCommand,CMD_WINS)    == 0 ||
        lstrcmpi(pwszCommand,CMD_DHCP)    == 0 ||
        lstrcmpi(pwszCommand,CMD_DNS)     == 0 ||
        lstrcmpi(pwszCommand,CMD_IP)      == 0 ||
        lstrcmpi(pwszCommand,CMD_GATEWAY) == 0 )
    {
        switch(dwArgCount)
        {
        case 4:
            pszwInstance = ppwcArguments[3];
            break;
        case 3:
            break;
        default:
            // Invalid number of arguments
            //
            return ERROR_INVALID_SYNTAX;
        }
    }
    else if( lstrcmpi(pwszCommand, CMD_IPHOST) == 0 )        
    {
        if( dwArgCount == 4 )
        {
            // The IP host name/Address
            //
            pszwInstance = ppwcArguments[3];
        }
        else
        {
            // Invalid number of arguments
            //
            return ERROR_INVALID_SYNTAX;
        }
    }
    else if( dwArgCount != 3 )
    {
        // Invalid number of arguments
        //
        return ERROR_INVALID_SYNTAX;
    }

    // Ping the catagory
    //
    g_pDiagnostics->ExecQuery(pwszCommand, (FLAG_VERBOSE_MEDIUM | FLAG_CMD_PING) ,pszwInstance);

    return 0;
}

DWORD
HandleConnect(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description
    Handles the connect command

Arguments
    none

Return Value
    none

--*/

{

    WCHAR *pszwIPHost = NULL;
    WCHAR *pszwPort = NULL;    
    LPWSTR pwszCommand;

    pwszCommand = GetCommandName(ConnectCommands,ppwcArguments[2],FALSE);
    if( !pwszCommand )
    {
        return ERROR_INVALID_SYNTAX;
    }

    
    if( lstrcmpi(pwszCommand,CMD_IPHOST) == 0 )    
    {
        // IPhost
        //
        if( dwArgCount == 5 )
        {
            // IP host name/Address
            //
            pszwIPHost = ppwcArguments[3];
            pszwPort = ppwcArguments[4];
        }
        else
        {
            // Invalid number of arguments
            //
            return ERROR_INVALID_SYNTAX;
        }
    }
    else if( dwArgCount != 3 )
    {
        // Invalid number of arguments
        //
        return ERROR_INVALID_SYNTAX;
    }

    // Establish the TCP connection
    //
    g_pDiagnostics->ExecQuery(pwszCommand, (FLAG_VERBOSE_MEDIUM | FLAG_CMD_CONNECT) ,pszwIPHost, pszwPort);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\netdiag\xportst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       xportst.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_XPORTST
#define HEADER_XPORTST

/*=======================< Function prototypes >===========================*/
BOOL WSLoopBkTest( PVOID Context );
BOOL NqTest(PVOID Context);

HRESULT
InitIpconfig(IN NETDIAG_PARAMS *pParams,
			 IN OUT NETDIAG_RESULT *pResults);



/*============================< Constants >================================*/
#define DEFAULT_SEND_SIZE 32
#define MAX_ICMP_BUF_SIZE ( sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE )
#define DEFAULT_TIMEOUT   1000L
#define PING_RETRY_CNT    4
#define PORT_4_LOOPBK_TST 3038      

//
//  WINS related constants
//
#define NM_QRY_XID 0x6DFC

#define NBT_NAME_SIZE 32
#define MAX_NBT_PACKET_SIZE 1500

#define NBT_NM_OPC_REQUEST      0x0000
#define NBT_NM_OPC_RESPONSE     0x0080

#define NBT_NM_OPC_QUERY        0x0000
#define NBT_NM_OPC_REGISTRATION 0x0028
#define NBT_NM_OPC_RELEASE      0x0030
#define NBT_NM_OPC_WACK         0x0038
#define NBT_NM_OPC_REFRESH      0x0040

//
//  Name Service Flags
//
#define NBT_NM_FLG_BCAST        0x1000
#define NBT_NM_FLG_RECURS_AVAIL 0x8000   
#define NBT_NM_FLG_RECURS_DESRD 0x0001
#define NBT_NM_FLG_TRUNCATED 0x0002
#define NBT_NM_FLG_AUTHORITATIV 0x0004

//
//  Name Service question types
//
#define NBT_NM_QTYP_NB 0x2000
#define NBT_NM_QTYP_NBSTAT 0x2100

#define NBT_NM_QCLASS_IN 0x0100



/*=====================< type/struct declarations >========================*/
#include "pshpack1.h"

typedef struct {
	WORD  xid;
	WORD  flags;
	WORD  question_cnt;
	WORD  answer_cnt;
	WORD  name_serv_cnt;
	WORD  additional_cnt;
} NM_FRAME_HDR;


typedef struct {
	BYTE q_name[NBT_NAME_SIZE+2];
	WORD q_type;
	WORD q_class;
} NM_QUESTION_SECT;

#include "poppack.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\dglogsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Dglogs.rc
//
#define IDS_PROJNAME                    100
#define IDR_DGLOGSCOM                   101
//#define IDR_DGNET                       103
#define IDS_PING_PACKET                 200
#define IDS_INVALID_IP                  201
#define IDS_SOCKET_CREATE_FAIL          202
#define IDS_RESOLVE_NAME_FAIL           203
#define IDS_SEND_FAIL                   204
#define IDS_TIMED_OUT                   205
#define IDS_PASSED                      206
#define IDS_FAILED                      207
#define IDS_SAMESUBNET                  208
#define IDS_DIFFERENTSUBNET             209
#define IDS_NOTCONFIGURED               210
#define IDS_SERVERCONNECTSTART          211
#define IDS_SERVERCONNECTEND            212
#define IDS_NONE                        213
#define IDS_POP3                        214
#define IDS_POP2                        215
#define IDS_SMTP                        216
#define IDS_IMAP                        217
#define IDS_MAILPORTSCHECKED            218
#define IDS_IEPROXYNOTUSED              219
#define IDS_INVALIDIP                   220
#define IDS_MAIL                        221
#define IDS_UNREACHABLE                 222
#define IDS_CATEGORY_NETWORKADAPTERS    223
#define IDS_CATEGORY_MODEM              224
#define IDS_CATEGORY_SYSTEMINFO         225
#define IDS_CATEGORY_INTERNET           226
#define IDS_ADAPTER_HEADER              227
#define IDS_DNS_HEADER                  228
#define IDS_DHCP_HEADER                 229
#define IDS_WINS_HEADER                 230
#define IDS_IP_HEADER                   231
#define IDS_GATEWAY_HEADER              232
#define IDS_CLIENT_HEADER               233
#define IDS_MAIL_HEADER                 234
#define IDS_NEWS_HEADER                 235
#define IDS_PROXY_HEADER                236
#define IDS_COMPUTER_HEADER             237
#define IDS_OS_HEADER                   238
#define IDS_VERSION_HEADER              239
#define IDS_MODEM_HEADER                240
#define IDS_LOOPBACK_HEADER             241
#define IDS_COLLECTINGINFO_STATUS       242
#define IDS_FINISHED_STATUS             243
#define IDS_CONNECTINGTOSERVER_STATUS   244
#define IDS_PINGING_STATUS              245
#define IDS_CONNECTEDTOSERVERSUCCESS    246
#define IDS_CONNECTEDTOSERVERFAILED     247
#define IDS_OENEWSACCOUNTINFOERROR      248
#define IDS_OEMAILACCOUNTINFOERROR      249
#define IDS_WMIERROR                    250
#define IDS_EMPTY                       251
#define IDS_HTTP                        252
#define IDS_UNKNOWN                     253
#define IDS_TRUE                        254
#define IDS_FALSE                       255
#define IDS_NOTELNETGUI                 256
#define IDS_GUISTARTED                  257
#define IDS_GUINOTSTARTED               258
#define IDS_FAILEDOPENWMIREP            259
#define IDS_FAILEDOPENWMINAMESPACE      260

#define IDS_PINGMSG_1                   300
#define IDS_PINGMSG_2                   301
#define IDS_PINGMSG_3                   302
#define IDS_PINGMSG_4                   303
#define IDS_PINGMSG_5                   304
#define IDS_PINGMSG_6                   305
#define IDS_PINGMSG_7                   306
#define IDS_PINGMSG_8                   307
#define IDS_PINGMSG_9                   308
#define IDS_PINGMSG_10                  309
#define IDS_PINGMSG_11                  310
#define IDS_PINGMSG_12                  311
#define IDS_PINGMSG_13                  312
#define IDS_PINGMSG_14                  313
#define IDS_PINGMSG_15                  314
#define IDS_PINGMSG_16                  315
#define IDS_PINGMSG_17                  316
#define IDS_PINGMSG_18                  317


#define PING_BUF_TOO_SMALL              413
#define PING_DEST_NET_UNREACHABLE       414
#define PING_DEST_HOST_UNREACHABLE      415
#define PING_DEST_PROT_UNREACHABLE      416
#define PING_DEST_PORT_UNREACHABLE      417
#define PING_NO_RESOURCES               418
#define PING_BAD_OPTION                 419
#define PING_HW_ERROR                   420
#define PING_PACKET_TOO_BIG             421
#define PING_REQ_TIMED_OUT              422
#define PING_BAD_REQ                    423
#define PING_BAD_ROUTE                  424
#define PING_TTL_EXPIRED_TRANSIT        425
#define PING_TTL_EXPIRED_REASSEM        426
#define PING_PARAM_PROBLEM              427
#define PING_SOURCE_QUENCH              428
#define PING_OPTION_TOO_BIG             429
#define PING_BAD_DESTINATION            430
#define PING_NEGOTIATING_IPSEC          431
#define PING_GENERAL_FAILURE            432
#define PING_NO_MEMORY                  433


#define IPSAMPLELOG_BASE                44000

#define HLP_DUMP                        (IPSAMPLELOG_BASE + 1)
#define HLP_DUMP_EX                     (IPSAMPLELOG_BASE + 2)

#define HLP_GROUP_SHOW                  (IPSAMPLELOG_BASE + 3)
#define HLP_GROUP_PING                  (IPSAMPLELOG_BASE + 4)
#define HLP_GROUP_CONNECT               (IPSAMPLELOG_BASE + 5)

#define HLP_SHOW_MAIL                   (IPSAMPLELOG_BASE + 6)
#define HLP_SHOW_MAIL_EX                (IPSAMPLELOG_BASE + 7)
#define HLP_SHOW_NEWS                   (IPSAMPLELOG_BASE + 8)
#define HLP_SHOW_NEWS_EX                (IPSAMPLELOG_BASE + 9)
#define HLP_SHOW_PROXY                  (IPSAMPLELOG_BASE + 10)
#define HLP_SHOW_PROXY_EX               (IPSAMPLELOG_BASE + 11)
#define HLP_SHOW_OS                     (IPSAMPLELOG_BASE + 12)
#define HLP_SHOW_OS_EX                  (IPSAMPLELOG_BASE + 13)
#define HLP_SHOW_COMPUTER               (IPSAMPLELOG_BASE + 14)
#define HLP_SHOW_COMPUTER_EX            (IPSAMPLELOG_BASE + 15)
#define HLP_SHOW_VERSION                (IPSAMPLELOG_BASE + 16)
#define HLP_SHOW_VERSION_EX             (IPSAMPLELOG_BASE + 17)
#define HLP_SHOW_WINS                   (IPSAMPLELOG_BASE + 18)
#define HLP_SHOW_WINS_EX                (IPSAMPLELOG_BASE + 19)
#define HLP_SHOW_DHCP                   (IPSAMPLELOG_BASE + 20)
#define HLP_SHOW_DHCP_EX                (IPSAMPLELOG_BASE + 21)
#define HLP_SHOW_IP                     (IPSAMPLELOG_BASE + 22)
#define HLP_SHOW_IP_EX                  (IPSAMPLELOG_BASE + 23)
#define HLP_SHOW_DNS                    (IPSAMPLELOG_BASE + 24)
#define HLP_SHOW_DNS_EX                 (IPSAMPLELOG_BASE + 25)
#define HLP_SHOW_GATEWAY                (IPSAMPLELOG_BASE + 26)
#define HLP_SHOW_GATEWAY_EX             (IPSAMPLELOG_BASE + 27)
#define HLP_SHOW_ADAPTER                (IPSAMPLELOG_BASE + 28)
#define HLP_SHOW_ADAPTER_EX             (IPSAMPLELOG_BASE + 29)
#define HLP_SHOW_MODEM                  (IPSAMPLELOG_BASE + 30)
#define HLP_SHOW_MODEM_EX               (IPSAMPLELOG_BASE + 31)
#define HLP_SHOW_CLIENT                 (IPSAMPLELOG_BASE + 32)
#define HLP_SHOW_CLIENT_EX              (IPSAMPLELOG_BASE + 33)
#define HLP_SHOW_ALL                    (IPSAMPLELOG_BASE + 34)
#define HLP_SHOW_ALL_EX                 (IPSAMPLELOG_BASE + 35)


#define HLP_PING_MAIL                   (IPSAMPLELOG_BASE + 36)
#define HLP_PING_MAIL_EX                (IPSAMPLELOG_BASE + 37)
#define HLP_PING_NEWS                   (IPSAMPLELOG_BASE + 38)
#define HLP_PING_NEWS_EX                (IPSAMPLELOG_BASE + 39)
#define HLP_PING_PROXY                  (IPSAMPLELOG_BASE + 40)
#define HLP_PING_PROXY_EX               (IPSAMPLELOG_BASE + 41)
#define HLP_PING_WINS                   (IPSAMPLELOG_BASE + 42)
#define HLP_PING_WINS_EX                (IPSAMPLELOG_BASE + 43)
#define HLP_PING_DHCP                   (IPSAMPLELOG_BASE + 44)
#define HLP_PING_DHCP_EX                (IPSAMPLELOG_BASE + 45)
#define HLP_PING_IP                     (IPSAMPLELOG_BASE + 46)
#define HLP_PING_IP_EX                  (IPSAMPLELOG_BASE + 47)
#define HLP_PING_DNS                    (IPSAMPLELOG_BASE + 48)
#define HLP_PING_DNS_EX                 (IPSAMPLELOG_BASE + 49)
#define HLP_PING_GATEWAY                (IPSAMPLELOG_BASE + 50)
#define HLP_PING_GATEWAY_EX             (IPSAMPLELOG_BASE + 51)
#define HLP_PING_ADAPTER                (IPSAMPLELOG_BASE + 52)
#define HLP_PING_ADAPTER_EX             (IPSAMPLELOG_BASE + 53)
#define HLP_PING_LOOPBACK               (IPSAMPLELOG_BASE + 54)
#define HLP_PING_LOOPBACK_EX            (IPSAMPLELOG_BASE + 55)
#define HLP_PING_IPHOST                 (IPSAMPLELOG_BASE + 56)
#define HLP_PING_IPHOST_EX              (IPSAMPLELOG_BASE + 57)


#define HLP_CONNECT_MAIL                (IPSAMPLELOG_BASE + 58)
#define HLP_CONNECT_MAIL_EX             (IPSAMPLELOG_BASE + 59)
#define HLP_CONNECT_NEWS                (IPSAMPLELOG_BASE + 60)
#define HLP_CONNECT_NEWS_EX             (IPSAMPLELOG_BASE + 61)
#define HLP_CONNECT_PROXY               (IPSAMPLELOG_BASE + 62)
#define HLP_CONNECT_PROXY_EX            (IPSAMPLELOG_BASE + 63)
#define HLP_CONNECT_IPHOST              (IPSAMPLELOG_BASE + 64)
#define HLP_CONNECT_IPHOST_EX           (IPSAMPLELOG_BASE + 65)

#define HLP_SHOW_TEST                   (IPSAMPLELOG_BASE + 66)
#define HLP_SHOW_TEST_EX                (IPSAMPLELOG_BASE + 67)

#define HLP_SHOW_GUI                   (IPSAMPLELOG_BASE + 68)
#define HLP_SHOW_GUI_EX                (IPSAMPLELOG_BASE + 69)




#define WM_PROGRESSREPORT               WM_USER + 1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif

/*
#include <windows.h>
#include <ntverp.h>
*/
/*-----------------------------------------------*/
/* the following lines are specific to this file */
/*-----------------------------------------------*/

/* VER_FILETYPE, VER_FILESUBTYPE, VER_FILEDESCRIPTION_STR
 * and VER_INTERNALNAME_STR must be defined before including COMMON.VER
 * The strings don't need a '\0', since common.ver has them.
 */
//#define VER_FILETYPE    VFT_DLL
/* possible values:     VFT_UNKNOWN
                        VFT_APP
                        VFT_DLL
                        VFT_DRV
                        VFT_FONT
                        VFT_VXD
                        VFT_STATIC_LIB
*/
//#define VER_FILESUBTYPE VFT2_UNKNOWN
/* possible values      VFT2_UNKNOWN
                        VFT2_DRV_PRINTER
                        VFT2_DRV_KEYBOARD
                        VFT2_DRV_LANGUAGE
                        VFT2_DRV_DISPLAY
                        VFT2_DRV_MOUSE
                        VFT2_DRV_NETWORK
                        VFT2_DRV_SYSTEM
                        VFT2_DRV_INSTALLABLE
                        VFT2_DRV_SOUND
                        VFT2_DRV_COMM
*/
/*
#define VER_FILEDESCRIPTION_STR   "Network Diagnostics -- Netsh Helper"
#define VER_INTERNALNAME_STR      "DGLOGS.DLL"
#define VER_ORIGINALFILENAME_STR  "DGLOGS.DLL"

#include "common.ver"   // NT5.0 version file.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\dglogsnetsh.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\prstring.h

Abstract:

    The file contains definitions of command line option tag strings.

--*/

#include "stdafx.h"
//#include <netsh.h>
#include <netshp.h>
#include "diagnostics.h"

// context's version
#define DGLOGS_CONTEXT_VERSION          1

// Version number
#define DGLOGS_HELPER_VERSION           1

DWORD WINAPI
InitHelperDllEx(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    );

DWORD 
WINAPI
DglogsStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    );

DWORD 
WINAPI
DglogsStopHelper (
  DWORD dwReserved
);

DWORD
HandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );

DWORD
HandleShowGui(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );

DWORD
HandlePing(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );

DWORD
HandleConnect(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );



DWORD
WINAPI
SampleDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    );

////////////////////////////////////////
// TOKENS
////////////////////////////////////////
#define TOKEN_DGLOGS                        L"diag"


////////////////////////////////////////
// Configuration commands
////////////////////////////////////////

// Commands supported by most protocols
//
#define CMD_DUMP                            L"dump"
#define CMD_HELP1                           L"help"
#define CMD_HELP2                           L"?"

// Group Commands
//
#define CMD_GROUP_SHOW                      L"show"
#define CMD_GROUP_PING                      L"ping"
#define CMD_GROUP_CONNECT                   L"connect"

// commands
//
#define CMD_MAIL                            L"mail"
#define CMD_NEWS                            L"news"
#define CMD_PROXY                           L"ieproxy"
#define CMD_OS                              L"os"
#define CMD_COMPUTER                        L"computer"
#define CMD_VERSION                         L"version"
#define CMD_DNS                             L"dns"
#define CMD_GATEWAY                         L"gateway"
#define CMD_DHCP                            L"dhcp"
#define CMD_IP                              L"ip"
#define CMD_WINS                            L"wins"
#define CMD_ADAPTER                         L"adapter"
#define CMD_MODEM                           L"modem"
#define CMD_CLIENT                          L"client"
#define CMD_ALL                             L"all"
#define CMD_TEST                            L"test"
#define CMD_GUI                             L"gui"
#define CMD_LOOPBACK                        L"loopback"
#define CMD_IPHOST                          L"iphost"
#define SWITCH_VERBOSE                      L"/v"
#define SWITCH_PROPERTIES                   L"/p"

// show commands
//
#define CMD_SHOW_MAIL                       CMD_MAIL       //L"show mail"
#define CMD_SHOW_NEWS                       CMD_NEWS       //L"show news"
#define CMD_SHOW_PROXY                      CMD_PROXY      //L"show ieproxy"
#define CMD_SHOW_OS                         CMD_OS         //L"show os"
#define CMD_SHOW_COMPUTER                   CMD_COMPUTER   //L"show computer"
#define CMD_SHOW_VERSION                    CMD_VERSION    //L"show version"
#define CMD_SHOW_DNS                        CMD_DNS        //L"show dns"
#define CMD_SHOW_GATEWAY                    CMD_GATEWAY    //L"show gateway"
#define CMD_SHOW_DHCP                       CMD_DHCP       //L"show dhcp"
#define CMD_SHOW_IP                         CMD_IP         //L"show ip"
#define CMD_SHOW_WINS                       CMD_WINS       //L"show wins"
#define CMD_SHOW_ADAPTER                    CMD_ADAPTER    //L"show adapter"
#define CMD_SHOW_MODEM                      CMD_MODEM      //L"show modem"
#define CMD_SHOW_CLIENT                     CMD_CLIENT     //L"show client"
#define CMD_SHOW_ALL                        CMD_ALL        //L"show all"
#define CMD_SHOW_TEST                       CMD_TEST       //L"show test"
#define CMD_SHOW_GUI                        CMD_GUI        //L"show gui"

// ping commands
//
#define CMD_PING_MAIL                       CMD_MAIL       //L"ping mail"
#define CMD_PING_NEWS                       CMD_NEWS       //L"ping news"
#define CMD_PING_PROXY                      CMD_PROXY      //L"ping ieproxy"
#define CMD_PING_DNS                        CMD_DNS        //L"ping dns"
#define CMD_PING_GATEWAY                    CMD_GATEWAY    //L"ping gateway"
#define CMD_PING_DHCP                       CMD_DHCP       //L"ping dhcp"
#define CMD_PING_IP                         CMD_IP         //L"ping ip"
#define CMD_PING_WINS                       CMD_WINS       //L"ping wins"
#define CMD_PING_ADAPTER                    CMD_ADAPTER    //L"ping adapter"
#define CMD_PING_LOOPBACK                   CMD_LOOPBACK   //L"ping loopback"
#define CMD_PING_IPHOST                     CMD_IPHOST     //L"ping iphost"

// connect commands
//
#define CMD_CONNECT_MAIL                    CMD_MAIL    //L"connect mail"
#define CMD_CONNECT_NEWS                    CMD_NEWS    //L"connect news"
#define CMD_CONNECT_PROXY                   CMD_PROXY   //L"connect ieproxy"
#define CMD_CONNECT_IPHOST                  CMD_IPHOST  //L"connect iphost"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\network.h ===
#include "stdafx.h"

int 
Ping(
    IN LPCTSTR pszwHostName, 
    IN int     nIndent
    );

BOOL
Connect(
    IN LPCTSTR pszwHostName,
    IN DWORD   dwPort
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\network.cpp ===
#include "network.h"
#include "diagnostics.h"
#include "util.h"

BOOL
CDiagnostics::IsInvalidIPAddress(
    IN LPCSTR pszHostName
    )
/*++

Routine Description
    Checks to see if an IP Host is a in valid IP address
        0.0.0.0 is not valid
        255.255.255.255 is not valid
        "" is not valid

Arguments
    pszHostName  Host Address

Return Value
    TRUE   Is invalid IP address
    FALSE  Valid IP address

--*/
{
    BYTE bIP[4];
    int iRetVal;
    LONG lAddr;

    if( NULL == pszHostName || strcmp(pszHostName,"") == 0 || strcmp(pszHostName,"255.255.255.255") ==0)
    {
        // Invalid IP Host
        //
        return TRUE;
    }


    lAddr = inet_addr(pszHostName);

    if( INADDR_NONE != lAddr )
    {
        // Formatted like an IP address X.X.X.X
        //
        if( lAddr == 0 )
        {
            // Invalid IP address 0.0.0.0
            //
            return TRUE;
        }
    }
    
    return FALSE;
}

BOOL
CDiagnostics::IsInvalidIPAddress(
    IN LPCWSTR pszHostName
    )
{
    CHAR szIPAddress[MAX_PATH+1];
    szIPAddress[MAX_PATH] = L'\0';

    if( lstrlen(pszHostName) > 255 )
    {
        // A host name can only be 255 chars long
        return TRUE;
    }

    wcstombs(szIPAddress,pszHostName,MAX_PATH);

    return IsInvalidIPAddress(szIPAddress);
}


BOOL
CDiagnostics::Connect(
    IN LPCTSTR pszwHostName,
    IN DWORD dwPort
    )
/*++

Routine Description
    Establish a TCP connect

Arguments
    pszwHostName Host to ping
    dwPort       Port to connect to

Return Value
    TRUE   Successfully connected
    FALSE  Failed to establish connection

--*/

{
    SOCKET s;
    SOCKADDR_IN sAddr;
    CHAR szAscii[MAX_PATH + 1];
    hostent * pHostent;


    // Create the socket
    //
    s = socket(AF_INET, SOCK_STREAM, PF_UNSPEC);
    if (INVALID_SOCKET == s)
    {
        return FALSE;
    }

    // Bind this socket to the server's socket address
    //
    memset(&sAddr, 0, sizeof (sAddr));
    sAddr.sin_family = AF_INET;
    sAddr.sin_port = htons((u_short)dwPort);
    
    wcstombs(szAscii,(WCHAR *)pszwHostName,MAX_PATH);
    pHostent = gethostbyname(szAscii); 
    
    if( !pHostent )
    {
        return FALSE;
    }

    // Set the destination info
    //
    ULONG ulAddr;

    memcpy(&ulAddr,pHostent->h_addr,pHostent->h_length);
    sAddr.sin_addr.s_addr = ulAddr;

    // Attempt to connect
    //
    if (connect(s, (SOCKADDR*)&sAddr, sizeof(SOCKADDR_IN)) == 0)
    {
        // Connection succeded
        //
        closesocket(s);
        return TRUE;
    }
    else
    {
        // Connection failed
        //
        closesocket(s);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\oe.h ===
#include <initguid.h>
#include <oaidl.h>
#include <imnact.h>     // account manager stuff
#include <imnxport.h>
#include <msident.h>

HRESULT GetOEDefaultMailServer2(OUT INETSERVER & rInBoundServer,
                                OUT DWORD      & dwInBoundMailType,
                                OUT INETSERVER & rOutBoundServer,
                                OUT DWORD      & dwOutBoundMailType);


HRESULT GetOEDefaultNewsServer2(OUT INETSERVER & rNewsServer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\diagnostics.h ===
#include "stdafx.h"
#include "WmiGateway.h"
#include "util.h"

#ifndef DIAGNOSTICS_H
#define DIAGNOSTICS_H


class CDglogsCom;

// Field types. Describes the field
//
#define TYPE_PING             0x01
#define TYPE_CONNECT          0x02
#define TYPE_SUBNET           0x04
#define TYPE_TEXT             0x08
#define TYPE_HIDE             0x10
#define TYPE_IP               0x20



// Flags indicating what type of data should be displayed
//
#define FLAG_VERBOSE_LOW      0x01
#define FLAG_VERBOSE_MEDIUM   0x02
#define FLAG_VERBOSE_HIGH     0x04
#define FLAG_CMD_PING         0x08
#define FLAG_CMD_SHOW         0x10
#define FLAG_CMD_CONNECT      0x20



#define CMD_SHOW        0x01
#define CMD_PING        0x02
#define CMD_CONNECT     0x04

class CDiagnostics
{

public:
    BOOL m_bDiagInit;

public:

BOOL
IsInvalidIPAddress(
    IN LPCSTR pszHostName
    );

BOOL
IsInvalidIPAddress(
    IN LPCWSTR pszHostName
    );


inline BOOL ShouldTerminate();

void SetCancelOption(HANDLE hTerminateThread)
{
    m_hTerminateThread = hTerminateThread;
    m_bTerminate;
}
void CDiagnostics::ClearQuery();
private:
    HANDLE m_hTerminateThread;
    BOOL m_bTerminate;
    BOOL m_bWinsockInit;


private:
void 
CDiagnostics::FillIcmpData(
    IN OUT CHAR  *pIcmp, 
    IN     DWORD dwDataSize
    );
DWORD 
CDiagnostics::DecodeResponse(
    IN  PCHAR  pBuf, 
    IN  int    nBytes,
    IN  struct sockaddr_in *pFrom,
    IN  int nIndent
    );
USHORT 
CDiagnostics::CheckSum(
    IN USHORT *pBuffer, 
    IN DWORD dwSize
    );

int 
CDiagnostics::Ping(
    IN  LPCTSTR pszwHostName, 
    IN int nIndent
    );

int 
CDiagnostics::Ping2(WCHAR *warg);

void
CDiagnostics::print_statistics(  );

BOOL
CDiagnostics::Connect(
    IN LPCTSTR pszwHostName,
    IN DWORD dwPort
    );

public:
    CDiagnostics();

    BOOLEAN m_bAdaterHasIPAddress;

    void SetMachine(WCHAR *pszMachine)
    {
        m_WmiGateway.SetMachine(pszMachine);
    }
    wstring &CDiagnostics::Escape(LPCTSTR pszw);

    void    SetInterface(INTERFACE_TYPE bInterface);
    BOOLEAN Initialize(INTERFACE_TYPE bInterface);
    void    SetQuery(WCHAR *pszwCatagory = NULL, BOOL bFlag = NULL, WCHAR *pszwParam1 = NULL, WCHAR *pszwParam2 = NULL);
    BOOLEAN ExecQuery(WCHAR *pszwCatagory = NULL, BOOL bFlag = NULL, WCHAR *pszwParam1 = NULL, WCHAR *pszwParam2 = NULL);
    BOOLEAN ExecClientQuery(WCHAR *pszwInstance);
    BOOLEAN ExecModemQuery(WCHAR *pszwInstance);
    BOOLEAN RemoveInvalidAdapters(EnumWbemProperty & PropList);
    BOOLEAN ExecAdapterQuery(WCHAR *pszwInstance);
    BOOLEAN ExecDNSQuery(WCHAR *pszwInstance);
    BOOLEAN ExecIPQuery(WCHAR *pszwInstance);
    BOOLEAN ExecWinsQuery(WCHAR *pszwInstance);
    BOOLEAN ExecGatewayQuery(WCHAR *pszwInstance);
    BOOLEAN ExecDhcpQuery(WCHAR *pszwInstance);
    BOOLEAN ExecComputerQuery();
    BOOLEAN ExecOSQuery();
    BOOLEAN ExecVersionQuery();
    BOOLEAN ExecProxyQuery();
    BOOLEAN ExecNewsQuery();
    BOOLEAN ExecMailQuery();    
    BOOLEAN ExecLoopbackQuery();
    BOOLEAN CDiagnostics::ExecIPHost(WCHAR *pszwHostName,WCHAR *pszwHostPort);

    BOOLEAN IsLocked()
    {
        
    }

    WCHAR m_wszCaption[MAX_PATH+1];
    _bstr_t m_bstrCaption;

    template<class t>
    WCHAR * GetCaption(list<t> &l, DWORD nInstance)
    {
        list<t>::iterator iter;

        if( lstrcmp((WCHAR *)m_bstrCaption, L"") != 0 )
        {
            return (WCHAR *)m_bstrCaption;
        }

        for( iter = l.begin(); iter != l.end(); iter++)
        {
            if( lstrcmp(iter->pszwName,m_pszwCaption) == 0 )            
            {
                if( iter->bFlags & TYPE_TEXT )
                {
                    return m_pszwCaption;
                }

                if( nInstance < iter->Value.size() )
                {
                    
                    return iter->Value[nInstance].bstrVal;                    
                }
                return NULL;
            }        
        }
        return NULL;
    }


    template<class t>
    DWORD GetNumberOfInstances(list<t> &l)
    {
        list<t>::iterator iter;
        if( l.empty() )
        {
            return 0;
        }

        iter = l.begin();
        return iter->Value.size();
    }

    template<class t>
    BOOLEAN FormatEnum(list<t> &l, WCHAR *pszwInstance = NULL, BOOLEAN bPass = 2)
    {
        WCHAR *pszwCaption = NULL; 
        list<t>::iterator iter;
        WCHAR szwStatus[MAX_PATH+1];
        LONG nPercent;
        m_nIndex = 0;
        m_nInstance = GetNumberOfInstances(l);
        m_bCaptionDisplayed = FALSE;
    
        m_bHeaderStatus = 2;
        m_bValueStatus = 2;
        m_bCaptionStatus = bPass;

        if( ShouldTerminate() ) return FALSE;

        lstrcmp(szwStatus,L"");

        if( !m_WmiGateway.m_wstrWbemError.empty() )
        {
            XMLHeader(TRUE,m_szwHeader,ids(IDS_WMIERROR),m_szwCategory);
            NetShHeader(TRUE,m_szwHeader,ids(IDS_WMIERROR));

            XMLCaption(TRUE,NULL);
            NetShCaption(TRUE,NULL);

            XMLField(TRUE,NULL);   
            NetShField(TRUE,NULL);   
    
            if( (m_bFlags & FLAG_VERBOSE_LOW)==0 )
            {
                XMLProperty(TRUE,(WCHAR *)m_WmiGateway.m_wstrWbemError.c_str());
                NetShProperty(TRUE,(WCHAR *)m_WmiGateway.m_wstrWbemError.c_str());
            }

            XMLProperty(FALSE,NULL);    
            NetShProperty(FALSE,NULL);    

            XMLField(FALSE,NULL);        
            NetShField(FALSE,NULL);

            XMLCaption(FALSE);
            NetShCaption(FALSE);

            XMLHeader(FALSE,ids(IDS_FAILED));
            NetShHeader(FALSE,ids(IDS_FAILED));

            return FALSE;
        }
        if( m_nInstance <= 1 )
        {
             pszwCaption = GetCaption(l,0);
        }

        XMLHeader(TRUE,m_szwHeader,pszwCaption,m_szwCategory);
        NetShHeader(TRUE,m_szwHeader,pszwCaption);
    
        if( m_nCatagoriesRequested && m_nInstance)
        {
            nPercent = 97/(m_nCatagoriesRequested * m_nInstance);
        }
        else
        {
            nPercent = 3;
        }
        m_bHeaderStatus = bPass; //2;

        for( DWORD i = 0; i < m_nInstance; i++)
        {   
            m_bCaptionStatus = 2;
            if( ShouldTerminate() ) return FALSE;
            ReportStatus(m_szwHeader,nPercent);
            m_nIndex++;

            FormatInstance(l, i,pszwInstance);

            m_bCaptionDisplayed = FALSE;
        }

        if( m_bHeaderStatus == TRUE )
        {
            lstrcpy(szwStatus,ids(IDS_PASSED));
        }
        else
        if( m_bHeaderStatus == FALSE )
        {
            lstrcpy(szwStatus,ids(IDS_FAILED));
        }
        else
        {
            lstrcpy(szwStatus,L"");                
        }


        XMLHeader(FALSE,szwStatus);
        NetShHeader(FALSE,szwStatus);

        return TRUE;
    }

    template<class t>
    BOOLEAN FormatInstance(list<t> &l, DWORD nInstance, WCHAR *pszwInstance)
    {
        list<t>::iterator iter;
        WCHAR *pszwCaption = GetCaption(l,nInstance);
        WCHAR   szwStatus[MAX_PATH+1] = L"";                

        m_bAdaterHasIPAddress = FALSE;
        for( iter = l.begin(); iter != l.end(); iter++)
        {
            if( lstrcmp(iter->pszwName,L"IPAddress") == 0 )
            {
                int nIndex = 0;
                _bstr_t bstr;
                while( SUCCEEDED(GetVariant(iter->Value[nInstance],nIndex,bstr)) && m_bAdaterHasIPAddress == FALSE)
                {
                    if( lstrcmp((WCHAR *)bstr,L"0.0.0.0") != 0 && lstrcmp((WCHAR *)bstr,L"") != 0)
                    {                        
                        m_bAdaterHasIPAddress = TRUE;
                    }
                    nIndex++;
                }                    
            }
        }

        //m_bAdaterHasIPAddress = FALSE;

        m_bCaptionStatus = 2;

        if( pszwInstance )
        {
            if( IsNumber(pszwInstance) )
            {
                if( m_nIndex != wcstol(pszwInstance,NULL,10) )
                {
                    return 2;
                }
            }
            else
            if( !IsContained(pszwCaption,pszwInstance) )
            {
                return 2;
            }
        }

        if( m_bFlags & FLAG_VERBOSE_LOW )
        {
            XMLCaption(TRUE,pszwCaption);
            NetShCaption(TRUE,pszwCaption);
        }
        else
        {
            for( iter = l.begin(); iter != l.end(); iter++)
            {        
                m_bFieldStatus = 2;

                if( ShouldTerminate() ) return FALSE;

                if( iter->bFlags & TYPE_TEXT )
                {
                    XMLCaption(TRUE,pszwCaption);
                    XMLField(TRUE,NULL);   
                    XMLProperty(TRUE,iter->pszwName);
                    XMLProperty(FALSE,NULL);    
                    XMLField(FALSE,NULL);

                    NetShCaption(TRUE,pszwCaption);
                    NetShField(TRUE,NULL);   
                    NetShProperty(TRUE,iter->pszwName);
                    NetShProperty(FALSE,NULL);    
                    NetShField(FALSE,NULL);
                }
                else 
                if( nInstance < iter->Value.size() && Filter(iter->Value[nInstance],iter->bFlags) )
                {
                    XMLCaption(TRUE,pszwCaption);
                    NetShCaption(TRUE,pszwCaption);
                    XMLField(TRUE,iter->pszwName);                
                    NetShField(TRUE,iter->pszwName);

                    FormatProperty(l,nInstance,iter->Value[nInstance], iter->bFlags);

                    switch(m_bFieldStatus)
                    {
                    case TRUE:
                        lstrcpy(szwStatus,ids(IDS_PASSED));
                        break;

                    case FALSE:
                        lstrcpy(szwStatus,ids(IDS_FAILED));                
                        break;
                    default:
                        lstrcpy(szwStatus,L"");
                        break;
                    }

                    XMLField(FALSE,szwStatus);
                    NetShField(FALSE,szwStatus);
                }
            }
        }

        if( m_bCaptionStatus == TRUE )
        {
            lstrcpy(szwStatus,ids(IDS_PASSED));                
        }
        else if( m_bCaptionStatus == FALSE )
        {
            lstrcpy(szwStatus,ids(IDS_FAILED));                
        }
        else
        {
            lstrcpy(szwStatus,L"");                
        }

    
        XMLCaption(FALSE,szwStatus);
        NetShCaption(FALSE,szwStatus);

        return 0;
    }


    template<class t>
    BOOLEAN FormatProperty(list<t> &l, DWORD nInstance, _variant_t &vValue, BOOLEAN bFlags)
    {
        _bstr_t bstrValue;
        LPCTSTR pszwData = NULL;
        LPCTSTR pszwComment = NULL;
        WCHAR   szwStatus[MAX_PATH+1];
        WCHAR   szwComment[MAX_PATH+1];
        DWORD   nIndex = 0;
        INT nValue =0;
        //BOOLEAN bStatus = 2;    

        while( SUCCEEDED(GetVariant(vValue,nIndex++,bstrValue)) )
        {
            nValue++;
            m_bValueStatus = 2;

            if( ShouldTerminate() ) return FALSE;
            pszwData = NULL;
            lstrcpy(szwStatus,L"");
            lstrcpy(szwComment,L"");

            if( lstrcmp((WCHAR *)bstrValue,L"") == 0)
            {
                bstrValue = ids(IDS_EMPTY);
                NetShProperty(TRUE,bstrValue,szwComment);
            }
            else
            {
                if( ((bFlags & TYPE_SUBNET) || (bFlags & TYPE_PING)) && IsInvalidIPAddress((WCHAR*)bstrValue))
                {
                    // Should we report an error i.e. invalid IP address?
                    //
                    lstrcpy(szwComment,ids(IDS_INVALIDIP));
                    NetShProperty(TRUE,bstrValue,szwComment);
                }
                else
                {
                    if( (bFlags & TYPE_SUBNET) )
                    {
                        if( IsSameSubnet(Get(l,L"IPAddress",nInstance),Get(l,L"IPSubnet",nInstance),(WCHAR *)bstrValue) )
                        {
                            lstrcpy(szwComment,ids(IDS_SAMESUBNET));
                        }
                        else
                        {
                            lstrcpy(szwComment,ids(IDS_DIFFERENTSUBNET));
                        }
                    }
                    NetShProperty(TRUE,bstrValue,szwComment);
                    if( (bFlags & TYPE_PING) && (m_bFlags & FLAG_CMD_PING))
                    {
                        if( IsInvalidIPAddress((WCHAR*)bstrValue) )
                        {
                            lstrcpy(szwComment,ids(IDS_INVALIDIP));
                        }
                        else
                        {
                            WCHAR szw[MAX_PATH+1];
                            _snwprintf(szw,MAX_PATH,ids(IDS_PINGING_STATUS),(WCHAR *)bstrValue);
                            ReportStatus(szw,0);
                            if( Ping2(bstrValue) )
                            {                  
                                m_bHeaderStatus   = m_bHeaderStatus == FALSE ? FALSE : TRUE;
                                m_bCaptionStatus  = m_bCaptionStatus == FALSE ? FALSE : TRUE;
                                m_bFieldStatus    = m_bFieldStatus == FALSE ? FALSE : TRUE;
                                m_bValueStatus    = TRUE;
                            }
                            else
                            {
                                m_bHeaderStatus   = FALSE;
                                m_bCaptionStatus  = FALSE;
                                m_bFieldStatus    = FALSE;
                                m_bValueStatus    = FALSE;   
                            }
                            pszwData = m_wstrPing.c_str();
                        }
                    }
                }
            }
       
            if( m_bValueStatus == TRUE )
            {
                lstrcpy(szwStatus,ids(IDS_PASSED));                
            }
            else if( m_bValueStatus == FALSE )
            {
                lstrcpy(szwStatus,ids(IDS_FAILED));                
            }
            else
            {
                lstrcpy(szwStatus,L"");                
            }

            XMLProperty(TRUE,bstrValue,pszwData,szwComment);
            XMLProperty(FALSE,szwStatus);
            NetShProperty(FALSE,szwStatus);

        }

        if( nValue == 0 ) 
        {
            NetShProperty(TRUE,ids(IDS_EMPTY),L"");
            NetShProperty(FALSE,L"");
        }

        return 0; //bStatus;
    }

    template<class t>
    void HideAll(list<t> &l)
    {
        list<t>::iterator iter;

        for(iter = l.begin(); iter != l.end(); iter++)
        {
            iter->bFlags = TYPE_HIDE;
        }

    }

    BOOLEAN FormatPing(WCHAR * pszwText);

    BOOLEAN Filter(_variant_t &vValue, BOOLEAN bFlags);

    void RequestStatusReport(BOOLEAN bReportStatus, CDglogsCom *pDglogsCom)
    {
        m_bReportStatus = bReportStatus;
        m_pDglogsCom = pDglogsCom;
    }

    void ReportStatus(LPCTSTR pszwMsg, LONG lValue);

    ~CDiagnostics();

public:
    wstring         m_wstrXML;
    wstring         m_wstrText;
    wstring         m_wstrPing;

private:
    wstring         m_wstrEscapeXml;
    INTERFACE_TYPE  m_bInterface;
    CWmiGateway     m_WmiGateway;
    WCHAR *         m_pszwCaption;
    WCHAR           m_szwHeader[MAX_PATH + 1];
    WCHAR           m_szwCategory[MAX_PATH + 1];
    BOOLEAN         m_bCaptionDisplayed;
    DWORD           m_nInstance;
    BOOLEAN         m_bStatus;

private:
    PWCHAR      m_pszwCatagory;
    BOOL        m_bFlags;
    PWCHAR      m_pszwParam1;
    PWCHAR      m_pszwParam2;

public:
    CDglogsCom *m_pDglogsCom;

private:
    void EventCall(LPCTSTR pszwStatusReport, LONG lPercent);

private:
    BOOLEAN         m_IsNetdiagDisplayed;
    BOOLEAN         m_IsContainerDisplayed;
    BOOLEAN         m_IsPropertyListDisplayed;
    BOOLEAN         m_IsPropertyDisplayed;
    BOOLEAN         m_IsValueDisplayed;
    DWORD           m_nPropertyLegth;
    DWORD           m_nValueIndex;
    DWORD           m_nIndent;
    DWORD           m_nIndex;
    BOOLEAN         m_bReportStatus;
    WCHAR           m_szwStatusReport[MAX_PATH + 1];
    LONG            m_lTotalWork;
    LONG            m_lWorkDone;
    LONG            m_nCatagoriesRequested;

    BOOLEAN         m_bHeaderStatus;
    BOOLEAN         m_bCaptionStatus;
    BOOLEAN         m_bFieldStatus;
    BOOLEAN         m_bPropertyStatus;
    BOOLEAN         m_bValueStatus;


private:

    void XMLNetdiag(BOOLEAN bStartTag, LPCTSTR pszwValue = NULL);
    void XMLHeader(BOOLEAN bStartTag, WCHAR *pszwHeader = NULL, WCHAR *pszwCaption = NULL, WCHAR *pszwCategory = NULL);
    void XMLCaption(BOOLEAN bStartTag, WCHAR *pszwCaption = NULL);
    void XMLField(BOOLEAN bStartTag, WCHAR *pszwField = NULL);
    void XMLProperty(BOOLEAN bStartTag, WCHAR *pszwProperty = NULL, LPCTSTR pszwData = NULL, LPCTSTR pszwComment = NULL);
    
private:
    void NetShNetdiag(BOOLEAN bStartTag, LPCTSTR pszwValue = NULL);
    void NetShHeader(BOOLEAN bStartTag,LPCTSTR pszwValue = NULL,LPCTSTR pszwCaption = NULL);
    void NetShCaption(BOOLEAN bStartTag,LPCTSTR pszwValue = NULL);
    void NetShField(BOOLEAN bStartTag,LPCTSTR pszwValue = NULL);
    void NetShProperty(BOOLEAN bStartTag,LPCTSTR pszwValue = NULL,LPCTSTR pszwComment = NULL,BOOL bFlags = 0);





};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\oe.cpp ===
// oe.cpp
//
#include "oe.h"


/*
HRESULT GetServerAndPort(IN INETSERVER & rServer, OUT CHost & host, OUT DWORD & dwPort)
{
#ifdef UNICODE
    TCHAR wcsServer[128];

    mbstowcs(wcsServer, rServer.szServerName, 128);
	host.SetHost(wcsServer);
#else
	host.SetHost(rServer.szServerName);
#endif
	dwPort = (long)rServer.dwPort;   
    
    return S_OK;
}
*/

enum MAIL_TYPE
{
    MAIL_NONE,
    MAIL_SMTP,
    MAIL_SMTP2,
    MAIL_IMAP,
    MAIL_POP3,
    MAIL_HTTP,
};

HRESULT GetDefaultOutBoundMailServer2(IN  IImnAccount * pIImnAccount,
                                      OUT INETSERVER  & rServer,
                                      OUT DWORD       & dwMailType)
{    
    ISMTPTransport     *pSMTPTransport;
    ISMTPTransport2    *pSMTPTransport2;
    HRESULT hr;

    // Create the SMTP transport object
    //
    hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport, (LPVOID *)&pSMTPTransport);
    if( SUCCEEDED(hr) )
    {
        // Get the SMTP server information
        //
		hr = pSMTPTransport->InetServerFromAccount(pIImnAccount, &rServer);
        dwMailType = MAIL_SMTP;
        pSMTPTransport->Release();
    }

    if( FAILED(hr) )
    {
        // Unable to get SMTP server info, lets try and get SMTP transport 2 server information
        // 
        hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport2, (LPVOID *)&pSMTPTransport2);
        if( SUCCEEDED(hr) )
        {
            // Get SMTP2 server info
            //
            hr = pSMTPTransport2->InetServerFromAccount(pIImnAccount, &rServer);
            dwMailType = MAIL_SMTP2;
            pSMTPTransport2->Release();
        }
    }

    if( FAILED(hr) )
    {
        // Make sure to clear the struct
        //
        memset(&rServer,0,sizeof(rServer));
        dwMailType = MAIL_NONE;
    }
    
    return hr;
}


HRESULT GetDefaultInBoundMailServer2(IN  IImnAccount * pIImnAccount,
                                     OUT INETSERVER  & rServer,
                                     OUT DWORD       & dwMailType)
{    
    IPOP3Transport *pPOP3Transport;
    IIMAPTransport *pIMAPTransport;
    IHTTPMailTransport *pHTTPTransport;
    HRESULT hr;


    // Create the HTTP transport object
    //
    hr = CoCreateInstance(CLSID_IHTTPMailTransport, NULL, CLSCTX_INPROC_SERVER, IID_IHTTPMailTransport, (LPVOID *)&pHTTPTransport);
    if( SUCCEEDED(hr) )
    {
        // Get the HTTP server information
        //
		hr = pHTTPTransport->InetServerFromAccount(pIImnAccount, &rServer);
        dwMailType = MAIL_HTTP;
        pHTTPTransport->Release();
    }

    if( FAILED(hr) )
    {
        // Create the POP3 transport object
        //
        hr = CoCreateInstance(CLSID_IPOP3Transport, NULL, CLSCTX_INPROC_SERVER, IID_IPOP3Transport, (LPVOID *)&pPOP3Transport);
        if( SUCCEEDED(hr) )
        {
            // Get the POP3 server information
            //
		    hr = pPOP3Transport->InetServerFromAccount(pIImnAccount, &rServer);
            dwMailType = MAIL_POP3;
            pPOP3Transport->Release();
        }
    }

    if( FAILED(hr) )
    {
        // Create the SMTP transport object
        //
        hr = CoCreateInstance(CLSID_IIMAPTransport, NULL, CLSCTX_INPROC_SERVER, IID_IIMAPTransport, (LPVOID *)&pIMAPTransport);
        if( SUCCEEDED(hr) )
        {
            // Get the SMTP server information
            //
			hr = pIMAPTransport->InetServerFromAccount(pIImnAccount, &rServer);
            dwMailType = MAIL_IMAP;            
            pIMAPTransport->Release();
        }
   }


    if( FAILED(hr) )
    {
        memset(&rServer,0,sizeof(rServer));    
        dwMailType = MAIL_NONE;
    }
    
    return hr;
}


HRESULT GetOEDefaultMailServer2(OUT INETSERVER & rInBoundServer,
                                OUT DWORD      & dwInBoundMailType,
                                OUT INETSERVER & rOutBoundServer,
                                OUT DWORD      & dwOutBoundMailType)
{   
    IImnAccountManager2 *pIImnAccountManager2 = NULL;
    IImnAccountManager  *pIImnAccountManager = NULL;
    IImnAccount         *pIImnAccount = NULL;
    HRESULT hr;


    hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER, IID_IImnAccountManager, (void**)&pIImnAccountManager);	
    if( SUCCEEDED(hr) )
    {
	    hr = pIImnAccountManager->QueryInterface(__uuidof(IImnAccountManager2), (void**)&pIImnAccountManager2);
	    if(SUCCEEDED(hr))
	    {
		    hr = pIImnAccountManager2->InitUser(NULL, (GUID)UID_GIBC_DEFAULT_USER, 0);

	    }   
	
        if(SUCCEEDED(hr))
	    {        
		    hr = pIImnAccountManager->Init(NULL);
	    }

        if( SUCCEEDED(hr) )
        {
	        hr = pIImnAccountManager->GetDefaultAccount(ACCT_MAIL, &pIImnAccount);
	        if( SUCCEEDED(hr) )
            {      
                HRESULT hr2, hr3;

                hr = E_FAIL;

                hr2 = GetDefaultInBoundMailServer2(pIImnAccount,rInBoundServer,dwInBoundMailType);
                hr3 = GetDefaultOutBoundMailServer2(pIImnAccount,rOutBoundServer,dwOutBoundMailType);

                if( SUCCEEDED(hr2) || SUCCEEDED(hr3) )
                {
                    hr = S_OK;
                }
                pIImnAccount->Release();
            }
        }

        pIImnAccountManager->Release();
        if( pIImnAccountManager2 )
        {
            pIImnAccountManager2->Release();
        }
    }

    return hr;
}


HRESULT GetOEDefaultNewsServer2(OUT INETSERVER & rNewsServer)
{   
    IImnAccountManager2 *pIImnAccountManager2 = NULL;
    IImnAccountManager  *pIImnAccountManager = NULL;
    IImnAccount         *pIImnAccount = NULL;
    INNTPTransport    	*pNNTPTransport;	
    HRESULT hr;


    hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER, IID_IImnAccountManager, (void**)&pIImnAccountManager);	
    if( SUCCEEDED(hr) )
    {
	    hr = pIImnAccountManager->QueryInterface(__uuidof(IImnAccountManager2), (void**)&pIImnAccountManager2);
	    if(SUCCEEDED(hr))
	    {
		    hr = pIImnAccountManager2->InitUser(NULL, (GUID)UID_GIBC_DEFAULT_USER, 0);

	    }   
	
        if(SUCCEEDED(hr))
	    {        
		    hr = pIImnAccountManager->Init(NULL);
	    }

        if( SUCCEEDED(hr) )
        {
	        hr = pIImnAccountManager->GetDefaultAccount(ACCT_NEWS, &pIImnAccount);
	        if( SUCCEEDED(hr) )
            {
		        hr = CoCreateInstance(CLSID_INNTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_INNTPTransport, (LPVOID *)&pNNTPTransport);
		        if(SUCCEEDED(hr))
		        {

			        hr = pNNTPTransport->InetServerFromAccount(pIImnAccount, &rNewsServer);                
                    pNNTPTransport->Release();                    
                }
                pIImnAccount->Release();                
            }
        }

        pIImnAccountManager->Release();
        if( pIImnAccountManager2 )
        {
            pIImnAccountManager2->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\diagnostics.cpp ===
#include "diagnostics.h"
//#include <netsh.h>
#include <netshp.h>
#include "Dglogs.h"
#include "DglogsCom.h"
#include "Commdlg.h"
#include "oe.h"

extern PrintMessage22 PrintMessage2;

#undef PrintMessage
#define PrintMessage PrintMessage2


// Wbem Repositories
//
#define TXT_WBEM_REP_CIMV2     L"root\\cimv2"

// Wbem Namespaces
//
#define TXT_WBEM_NS_COMPUTER   L"win32_computersystem"
#define TXT_WBEM_NS_OS         L"win32_operatingsystem"
#define TXT_WBEM_NS_NETWORK    L"win32_networkadapterconfiguration"
#define TXT_WBEM_NS_NETWORK2   L"win32_networkadapter"
#define TXT_WBEM_NS_CLIENT     L"win32_networkclient"
#define TXT_WBEM_NS_WMI        L"win32_wmisetting"
#define TXT_WBEM_NS_NETDIAG    L"netdiagnostics"
#define TXT_WBEM_NS_MODEM      L"win32_potsmodem"

// Captions for the different catagories
//
#define TXT_ADAPTER_CAPTION    L"Caption"
#define TXT_CLIENT_CAPTION     L"Name"
#define TXT_MAIL_CAPTION       L"InBoundMailServer"
#define TXT_NEWS_CAPTION       L"NewsServer"
#define TXT_PROXY_CAPTION      L"IEProxy"
#define TXT_COMPUTER_CAPTION   L"Caption"
#define TXT_OS_CAPTION         L"Caption"
#define TXT_VERSION_CAPTION    L"Version"
#define TXT_MODEM_CAPTION      L"Caption"
#define TXT_LOOPBACK_CAPTION   L"Loopback"


enum MAIL_TYPE
{
    MAIL_NONE,
    MAIL_SMTP,
    MAIL_SMTP2,
    MAIL_IMAP,
    MAIL_POP3,
    MAIL_HTTP,
};


/*++

Routine Description
    The worker thread uses this function to check if the main thread has canceled the worker thread.
    i.e. the work thread should abort what ever it is doing, clean up and terminate.

Arguments
    none

Return Value
    TRUE the worker thread has been terminated
    FALSE the worker thread has not been terminated

--*/
inline BOOL CDiagnostics::ShouldTerminate()
{
    if( m_bTerminate )
    {
        // The worker thread already has been canceled.
        //
        return TRUE;
    }

    if (WaitForSingleObject(m_hTerminateThread, 0) == WAIT_OBJECT_0)
    {
        // Worker thread has been canceled
        //
        m_bTerminate = FALSE;
        return TRUE;
    }
    else
    {
        // Worker thread has not yet been canceled.
        //
        return FALSE;
    }
}

/*++

Routine Description
    Initialize the Diagnostics Object

Arguments
    none

Return Value

--*/
CDiagnostics::CDiagnostics()
{
    m_bFlags  = 0;
    m_bInterface = NO_INTERFACE;
    lstrcpy(m_szwStatusReport,L"");
    m_bReportStatus = FALSE;
    m_lWorkDone = 0;
    m_lTotalWork = 0;
    ClearQuery();
    // Max sure that these strings are always NULL terminated
    m_szwCategory[MAX_PATH] = L'\0';    
    m_szwHeader[MAX_PATH] = L'\0';
    m_pszwCatagory = NULL;
    m_bWinsockInit = FALSE;
    m_bDiagInit = FALSE;
}

/*++

Routine Description
    Uniniailize the Diagnostics object

Arguments
    none

Return Value

--*/
CDiagnostics::~CDiagnostics()
{
    // Close the winsock
    //
    if( m_bWinsockInit )
    {
        WSACleanup();
        m_bWinsockInit = FALSE;
    }
    if( m_pszwCatagory )
    {
        HeapFree(GetProcessHeap(),0,m_pszwCatagory);
        m_pszwCatagory = NULL;
    }
    m_bDiagInit = FALSE;

}

/*++

Routine Description
    Set the interface i.e. Netsh or COM

Arguments
    bInterface -- Interface used to access the data

Return Value

--*/
void CDiagnostics::SetInterface(INTERFACE_TYPE bInterface) 
{ 
    m_bInterface = bInterface; 
}

/*++

Routine Description
    Iniatilze the Diagnostics object

Arguments
    

Return Value
    TRUE -- Successfully 
    else FALSE
--*/
BOOLEAN CDiagnostics::Initialize(INTERFACE_TYPE bInterface)
{
    int iRetVal;
    WSADATA wsa;

    m_bInterface = bInterface;

    // Initialize the WmiGateway object
    //
    if( FALSE == m_WmiGateway.WbemInitialize(bInterface) )
    {
        m_bDiagInit = FALSE;
        return FALSE;
    }

    if( !m_bWinsockInit )
    {
        // Initialize Winsock
        //
        iRetVal = WSAStartup(MAKEWORD(2,1), &wsa);
        if( iRetVal )
        {            
            m_bDiagInit = FALSE;
            return FALSE;
        }
        m_bWinsockInit = TRUE;
    }

    m_bDiagInit = TRUE;
    
    return TRUE;
}

/*++

Routine Description
    Sends an event to client informing the client of its progress.

Arguments
    pszwStatusReport -- Message telling the client what it CDiagnostics is currently doing
    lPercent         -- A percentage indicating its progress.

Return Value
    error code

--*/
void CDiagnostics::EventCall(LPCTSTR pszwStatusReport, LONG lPercent)
{
    if( m_pDglogsCom )
    {
        // Alocate memory for the message and send it to the client
        //
        BSTR bstrResult = SysAllocString(pszwStatusReport);
        m_pDglogsCom->Fire_ProgressReport(&bstrResult,lPercent);
    }
}

/*++

Routine Description
    Sends an event to client informing the client of its progress.

Arguments
    pszwMsg -- Message telling the client what it CDiagnostics is currently doing
    lValue  -- A percentage indicating its progress.

Return Value
    void

Note: 
    If lValue is -1 then send the finished message

--*/
void CDiagnostics::ReportStatus(LPCTSTR pszwMsg, LONG lValue)
{
    // Check if the client requested the Status report option
    //
    if( m_bReportStatus )
    {
        if( lValue == -1 )
        {
            // Send the finished message. 100% complete and the final XML result
            //
            EventCall(ids(IDS_FINISHED_STATUS), 100);
            EventCall(pszwMsg, lValue);
            m_lWorkDone = 0;
            m_lTotalWork = 0;
        }
        else
        {
            // Compute the total percentage completed. Make sure we never go over 100%
            //
            m_lWorkDone += m_lWorkDone+lValue < 100?lValue:0;
            EventCall(pszwMsg, m_lWorkDone);
        }
    }
}

/*++

Routine Description
    Counts the occurance of chars in a string

Arguments
    pszw -- String to search
    c  -- Char to count the occurnce of

Return Value
    number of time c occured in pszw

Note: 
    If lValue is -1 then send the finished message

--*/
int wcscount(LPCWSTR pszw, WCHAR c)
{
    int n =0;
    for(int i=0; pszw[i]!=L'\0'; i++)
    {
        if( pszw[i] == c )
        {
            if( i > 0 && pszw[i-1]!=c) n++;
        }
    }
    return n;
}

/*++

Routine Description
    Set the query information

Arguments
    pszwCatagory -- Catagory
    bFlag --  Flags (Show, PING, Connect)
    pszwParam1 -- Instance | iphost
    pszwParam2 -- Port number

Return Value
    void

--*/
void CDiagnostics::SetQuery(WCHAR *pszwCatagory, BOOL bFlag, WCHAR *pszwParam1, WCHAR *pszwParam2)
{
    if( pszwCatagory )
    {
        // Set the catagory. Need to make a copy of the Catagory since the string might disapper i.e. threads
        //
        LONG Length = wcslen(pszwCatagory);
        if( m_pszwCatagory )
        {
            HeapFree(GetProcessHeap(),0,m_pszwCatagory);
            m_pszwCatagory = NULL;
        }

        // If this memory allocation fails m_pszwCatagory will be Null and the catagory will not be displayed
        m_pszwCatagory = (LPWSTR)HeapAlloc(GetProcessHeap(),0,(Length+1)*sizeof(WCHAR));
        if( m_pszwCatagory )
        {
            wcscpy(m_pszwCatagory,pszwCatagory);
        }
    }

    if( bFlag )
    {
        m_bFlags = bFlag;
    }

    if( pszwParam1 )
    {
        m_pszwParam1 = pszwParam1;
    }

    if( pszwParam2 )
    {
        m_pszwParam2 = pszwParam2;
    }
}


/*++

Routine Description
    Clears the Set query information

Arguments
    void 

Return Value
    void

--*/
void CDiagnostics::ClearQuery()
{

    m_pszwCatagory = NULL;
    m_bFlags = NULL;
    m_pszwParam1 = NULL;
    m_pszwParam2 = NULL;
}

/*++

Routine Description
    Execute the query

Arguments 

Return Value
    void

--*/
BOOL GetIEProxy(LPWSTR pwszProxy, LONG ProxyLen, LPDWORD pdwPort, LPDWORD pdwEnabled);
BOOLEAN CDiagnostics::ExecQuery(WCHAR *pszwCatagory, BOOL bFlags, WCHAR *pszwParam1, WCHAR *pszwParam2)
{
    WCHAR *pszw;
    BOOL bAll = FALSE;

    SetQuery(pszwCatagory,bFlags,pszwParam1,pszwParam2);
    m_WmiGateway.SetCancelOption(m_hTerminateThread);

    m_WmiGateway.m_wstrWbemError = L"";
    m_bTerminate = FALSE;
    m_lWorkDone = 0;
    m_lTotalWork = 0;

    m_bstrCaption = L"";

    if( m_pszwParam1 && !wcsstr(m_pszwParam1,L"*") )
    {
        if( m_bFlags & FLAG_VERBOSE_LOW )
        {
            m_bFlags &= ~FLAG_VERBOSE_LOW;
            m_bFlags |=  FLAG_VERBOSE_MEDIUM;
        }
    }

    if( !m_pszwCatagory )
    {
        ClearQuery();
        return FALSE;
    }

    // the 3 is the start percentage indicating that something is happening!
    ReportStatus(ids(IDS_COLLECTINGINFO_STATUS),3);
           
    if( wcsstr(m_pszwCatagory,L"test") )
    {
        if( (m_bFlags & FLAG_VERBOSE_LOW) )
        {
            m_bFlags &= ~FLAG_CMD_SHOW;
        }
        else
        {
            m_bFlags |= FLAG_CMD_SHOW;
        }
        if( m_bFlags & FLAG_VERBOSE_LOW )
        {
            m_bFlags &= ~FLAG_VERBOSE_LOW;
            m_bFlags |=  FLAG_VERBOSE_MEDIUM;
        }
        m_bFlags |= FLAG_CMD_PING | FLAG_CMD_CONNECT;
        bAll = TRUE;
    }

    if( wcsstr(m_pszwCatagory,L"all") )
    {
        bAll = TRUE;
    }

    pszw = new WCHAR[lstrlen(m_pszwCatagory) + 3];
    if( !pszw )
    {
        ClearQuery();
        return FALSE;
    }

    wsprintf(pszw,L";%s;",m_pszwCatagory);
    ToLowerStr(pszw);

    m_nCatagoriesRequested = wcscount(pszw,L';') - 1;

    XMLNetdiag(TRUE);
    NetShNetdiag(TRUE);

    if( ShouldTerminate() ) goto End;
    if( wcsstr(pszw,L";iphost;") )
    {
        ExecIPHost(m_pszwParam1,m_pszwParam2);
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";mail;") )
    {
        ExecMailQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";news;") )
    {
        ExecNewsQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";ieproxy;") )
    {
        ExecProxyQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";loopback;") )
    {
        ExecLoopbackQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";computer;") )
    {
        ExecComputerQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";os;") )
    {
        ExecOSQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";version;") )
    {
        ExecVersionQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";modem;") )
    {
        ExecModemQuery(m_pszwParam1);
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";adapter;")  )
    {
        ExecAdapterQuery(m_pszwParam1);
    }

    {
        BOOL bFlagSave = m_bFlags;
        m_bFlags &= ~FLAG_VERBOSE_LOW;
        m_bFlags &= ~FLAG_VERBOSE_HIGH;
        m_bFlags |= FLAG_VERBOSE_MEDIUM;
        
        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";dns;")  )
        {
            ExecDNSQuery(m_pszwParam1);
        }

        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";gateway;")  )
        {
            ExecGatewayQuery(m_pszwParam1);
        }

        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";dhcp;")  )
        {
            ExecDhcpQuery(m_pszwParam1);
        }

        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";ip;") )
        {
            ExecIPQuery(m_pszwParam1);
        }

        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";wins;") )
        {
            ExecWinsQuery(m_pszwParam1);
        }
        m_bFlags = bFlagSave;
    }


    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";client;")  )
    {
        ExecClientQuery(m_pszwParam1);
    }


End:
    delete [] pszw;
    
    if( ShouldTerminate() ) return FALSE;

    XMLNetdiag(FALSE);
    NetShNetdiag(FALSE);
    
    Sleep(50);
    ReportStatus(m_wstrXML.c_str(),-1);    
    
    ClearQuery();

    return TRUE;
}


// Escaoes special XML chars
wstring &CDiagnostics::Escape(LPCTSTR pszw)
{

    m_wstrEscapeXml = L"";

    if( !pszw )
    {
        return m_wstrEscapeXml;
    }
    
    for(int i=0; pszw[i]!=L'\0'; i++)
    {
        switch(pszw[i])
        {
        case L'&':
            m_wstrEscapeXml += L"&amp;";
            break;
        case L'\'':
            m_wstrEscapeXml += L"&apos;";
            break;
        case L'\"':
            m_wstrEscapeXml += L"&quot;";
            break;
        case L'<':
            m_wstrEscapeXml += L"&lt;";
            break;
        case L'>':
            m_wstrEscapeXml += L"&gt;";
            break;
        default:
            m_wstrEscapeXml += pszw[i];

        }
    }

    return m_wstrEscapeXml;
}

// Creates the XML start tag
// <Netdiag> 
//      <Status Value = _____ ></Status>
//      ______ 
// </Netdiag>
void CDiagnostics::XMLNetdiag(BOOLEAN bStartTag, LPCTSTR pszwValue)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            m_wstrXML = wstring(L"<Netdiag Name = \"Network Diagnostics\">\n");
        }
        else
        {
            m_wstrXML += wstring(L"<Status Value = \"") + Escape(pszwValue) + wstring(L"\"> </Status>\n");
            m_wstrXML += wstring(L"</Netdiag>\n");
        }           
    }
}

// Creates a the diagnostics header
// <Container Name = "_____" Category = "_____" Caption = "_____">
//      <Status Value = _____ ></Status>
// </Container>
void CDiagnostics::XMLHeader(BOOLEAN bStartTag, WCHAR *pszwHeader, WCHAR *pszwCaption, WCHAR *pszwCategory)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            m_wstrXML += wstring(L"<Container Name = \"") + Escape(pszwHeader) + wstring(L"\" ");
            m_wstrXML += wstring(L"Category = \"") + Escape(pszwCategory) + wstring(L"\" ");
            m_wstrXML += wstring(L"Caption = \"") + Escape(pszwCaption) + wstring(L"\">\n");
        }
        else
        {
            m_wstrXML += wstring(L"<Status Value = \"") + Escape(pszwHeader) + wstring(L"\"> </Status>\n");
            m_wstrXML += wstring(L"</Container>");
        }
    }
}

// Creates the Caption string
// <ClassObjectEnum Name = "_____">
//      <Status Value = _____ > </Status>
// </ClassObjectEnum>
// 
void CDiagnostics::XMLCaption(BOOLEAN bStartTag, WCHAR *pszwCaption)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            pszwCaption = (m_nInstance == 1)?NULL:pszwCaption;
            if( m_bCaptionDisplayed == FALSE )
            {
                m_wstrXML += wstring(L"<ClassObjectEnum Name = \"") + Escape(pszwCaption) + wstring(L"\">\n");
                m_bCaptionDisplayed = TRUE;
                m_IsPropertyListDisplayed = TRUE;
            }
        }
        else
        {
            if( m_IsPropertyListDisplayed )
            {
                m_wstrXML += wstring(L"<Status Value = \"") + Escape(pszwCaption) + wstring(L"\"> </Status>\n");
                m_wstrXML += wstring(L"</ClassObjectEnum>\n");
            }
            m_IsPropertyListDisplayed = FALSE;
        }
    }
}

// Creates a field tag
// <Property Name = "_____" >
//      <Status Value = _____ > </Status>
// </Property>
void CDiagnostics::XMLField(BOOLEAN bStartTag, WCHAR *pszwField)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            m_wstrXML += wstring(L"<Property Name = \"") + Escape(pszwField) + wstring(L"\">\n");
        }
        else
        {
            m_wstrXML += wstring(L"<Status Value = \"") + Escape(pszwField) + wstring(L"\"> </Status>\n");
            m_wstrXML += wstring(L"</Property>\n");
        }
    }
}

// Creates a property
// <PropertyValue Value = "_____" Data = "_____" Comment = "_____" >
void CDiagnostics::XMLProperty(BOOLEAN bStartTag, WCHAR *pszwProperty, LPCTSTR pszwData, LPCTSTR pszwComment)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            m_wstrXML += wstring(L"<PropertyValue ");
            m_wstrXML += wstring(L"Value = \"")   + Escape(pszwProperty) + wstring(L"\" ");
            m_wstrXML += wstring(L"Data = \"")    + Escape(pszwData)     + wstring(L"\" ");
            m_wstrXML += wstring(L"Comment = \"") + Escape(pszwComment)  + wstring(L"\" ");
            m_wstrXML += wstring(L">\n");

        }
        else
        {
            m_wstrXML += Escape(pszwProperty);
            m_wstrXML += wstring(L"</PropertyValue>\n");
        }
    }
}


// Ensurse that the property is valid and should be displayed
BOOLEAN CDiagnostics::Filter(_variant_t &vValue, BOOLEAN bFlags)
{
    BOOLEAN retVal;
    BOOLEAN bShow    = (m_bFlags & FLAG_CMD_SHOW);
    BOOLEAN bPing    = (m_bFlags & FLAG_CMD_PING) && (bFlags & TYPE_PING);
    BOOLEAN bConnect = (m_bFlags & FLAG_CMD_CONNECT) && (bFlags & TYPE_CONNECT);

    if( m_bFlags & FLAG_VERBOSE_LOW )
    {
        return FALSE;
    }

    if( bFlags & TYPE_HIDE ) 
    {
        return FALSE;
    }

    if( (m_bFlags & FLAG_VERBOSE_HIGH)==0 && (retVal = IsVariantEmpty(vValue)) )
    {
        return FALSE;
    }

    if( (bFlags & TYPE_IP) && !m_bAdaterHasIPAddress )
    {
        return FALSE;
    }

    if( !bShow )
    {
        if( bPing || bConnect)
        {
            return TRUE;
        }
        return FALSE;
    }

    return TRUE;
}

// Get a entry from the link list stack
template<class t>
_variant_t *Get(list<t> &l, WCHAR *pszwName, DWORD nInstance)
{
    list<t>::iterator iter;
    if( l.empty() )
    {
        return NULL;
    }
    for( iter = l.begin(); iter != l.end(); iter++)
    {
        if( lstrcmp(iter->pszwName,pszwName) == 0 )
        {
            if( nInstance < iter->Value.size() )
            {
                return &iter->Value[nInstance];
            }
            else
            {
                return NULL;
            }
        }
    }
    return NULL;
}   

// Remove a entry from the list link stack
template<class t>
BOOLEAN RemoveInstance(list<t> &l, DWORD nInstance)
{
    list<t>::iterator iter;
    for( iter = l.begin(); iter != l.end(); iter++)
    {
        iter->Value.erase(&iter->Value[nInstance]);
    }
    return FALSE;
}

// Add/modify an entry in the link list stack
template<class t>
void Set(list<t> &l, WCHAR *pszwName, BOOLEAN bFlags, _variant_t &vValue)
{    
    list<t>::iterator iter;

    for( iter = l.begin(); iter != l.end(); iter++)
    {
        if( lstrcmp(iter->pszwName,pszwName) == 0 )
        {
            iter->Value.push_back(vValue);
            return;
        }
    }
    l.push_back(Property(pszwName,bFlags));
    iter = l.end();
    iter--;
    iter->Value.push_back(vValue);

    return;
}


// Formats the ping data
// 
BOOLEAN CDiagnostics::FormatPing(WCHAR * pszwText)
{        
    if( m_bInterface == NETSH_INTERFACE )
    {
        if( pszwText )
        {
            LONG nIndent = m_IsNetdiagDisplayed + m_IsContainerDisplayed + m_IsPropertyListDisplayed +  m_IsPropertyDisplayed + m_IsValueDisplayed;
            DisplayMessageT(L"%1!s!%2!s!\n",Indent(nIndent),pszwText); 
            return TRUE;
        }
    }

    if( m_bInterface == COM_INTERFACE )
    {
        if( !pszwText )
        {
            m_wstrPing.erase(m_wstrPing.begin(),m_wstrPing.end());
        }
        else if( m_wstrPing.empty() )
        {
            m_wstrPing = pszwText;
        }
        else
        {
            m_wstrPing += wstring(L"|") + pszwText;
        }
        return TRUE;
    }

    return FALSE;
}


BOOLEAN CDiagnostics::ExecClientQuery(WCHAR *pszwInstance)
{
    if( !(m_bFlags & FLAG_CMD_SHOW) )
    {
        return FALSE;
    }

    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_CLIENT_CAPTION;
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS),MAX_PATH);    
    wcsncpy(m_szwHeader,ids(IDS_CLIENT_HEADER),MAX_PATH);

    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_CLIENT));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecModemQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
 
    m_pszwCaption = TXT_MODEM_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_MODEM_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_MODEM),MAX_PATH);

    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_MODEM));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

// Removes adapters that are not present
// It checks the Win32_Netwokadapter NetConnectionStatus field to see if the adapter is valid or not
BOOLEAN CDiagnostics::RemoveInvalidAdapters(EnumWbemProperty & PropList)
{
    INT i = 0;
    _variant_t *pvIPEnabled;
    _variant_t *pvIndex1;
    _variant_t *pvIndex2;
    _variant_t *pvAdapterStatus;



    // Get the Win32_Networkadapter class so we can determine if the adapters in the Win32_Networkadapterconfiguration are valid(Present)
    EnumWbemProperty Win32NetworkAdpterList;
    Win32NetworkAdpterList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK2));
    m_WmiGateway.GetWbemProperties(Win32NetworkAdpterList);

    // With WMI you can not Union tables so we need to get both tables (Win32_NetwokAdapterConfiguration and Win32_NetwokAdapter) and walk
    // through each entry. Entries with the same index are the same adapter. The NetConnectionStatus says if the adapter is valid.
    do
    {
        pvIPEnabled = Get(PropList,L"IPEnabled",i);
        if( pvIPEnabled )
        {
            DWORD j;
            pvIndex1 = Get(PropList,L"Index",i);
            if( pvIndex1 )
            {
                j = 0;
                do
                {
                    pvIndex2 = Get(Win32NetworkAdpterList,L"Index",j);
                    if( pvIndex2 && pvIndex2->ulVal == pvIndex1->ulVal )
                    {    
                        pvAdapterStatus = Get(Win32NetworkAdpterList,L"NetConnectionStatus",j);                        
                        if( pvAdapterStatus != NULL && (pvAdapterStatus->ulVal != 2 && pvAdapterStatus->ulVal != 9) )
                        {                  
                            RemoveInstance(PropList,(DWORD)i);
                            pvIndex2 = NULL;
                            i--;
                        }
                    }
                    j++;
                }
                while(pvIndex2);
            }
            i++;
        } 


    }
    while(pvIPEnabled);

    return TRUE;
}

// Gets all of the adapter info from Win32_NetworkAdapterConfiguration
// Sets flags for some of the properties and values it recives (i.e. Ping and IP)
// These flags indicate how to display he data process the data.
BOOLEAN CDiagnostics::ExecAdapterQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
    EnumWbemProperty::iterator iter;

    m_pszwCaption = TXT_ADAPTER_CAPTION;  
    wcsncpy(m_szwHeader,ids(IDS_ADAPTER_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS),MAX_PATH);
    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    m_WmiGateway.GetWbemProperties(PropList);

    for(iter = PropList.begin(); iter != PropList.end(); iter++)
    {
        if( 0 == lstrcmp(iter->pszwName, L"DNSServerSearchOrder") ||
            0 == lstrcmp(iter->pszwName, L"IPAddress")            ||
            0 == lstrcmp(iter->pszwName, L"WINSPrimaryServer")    ||
            0 == lstrcmp(iter->pszwName, L"WINSSecondaryServer")  ||
            0 == lstrcmp(iter->pszwName, L"DHCPServer")           )
        {
            iter->bFlags = TYPE_PING | TYPE_IP;
        }

        if( 0 == lstrcmp(iter->pszwName, L"DefaultIPGateway") )
        {
            iter->bFlags = TYPE_PING | TYPE_SUBNET | TYPE_IP;
        }
    }

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }
    
    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

// Get the DNS data from Win32_NetworkAdapter
BOOLEAN CDiagnostics::ExecDNSQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;

    m_pszwCaption = TXT_ADAPTER_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_DNS_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS),MAX_PATH);

    PropList.push_back(WbemProperty(L"DNSServerSearchOrder",TYPE_PING | TYPE_IP ,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
	PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPEnabled",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    
    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

// Get the IP data from Win32_NetworkAdapter
BOOLEAN CDiagnostics::ExecIPQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;

    m_pszwCaption = TXT_ADAPTER_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_IP_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS),MAX_PATH);

    PropList.push_back(WbemProperty(L"IPAddress",TYPE_PING | TYPE_IP,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));    
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
	PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPEnabled",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));

    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

// Get the WINS data from Win32_NetworkAdapter
BOOLEAN CDiagnostics::ExecWinsQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_ADAPTER_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_WINS_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS),MAX_PATH);

    PropList.push_back(WbemProperty(L"WINSPrimaryServer",TYPE_PING | TYPE_IP,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"WINSSecondaryServer",TYPE_PING | TYPE_IP,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
	PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPEnabled",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    
    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

// Get the Gateway data from Win32_NetworkAdapter
BOOLEAN CDiagnostics::ExecGatewayQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_ADAPTER_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_GATEWAY_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS),MAX_PATH);

    PropList.push_back(WbemProperty(L"DefaultIPGateway",TYPE_PING | TYPE_IP | TYPE_SUBNET,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPSubnet",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPEnabled",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    
    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

// Get the DHCP data from Win32_NetworkAdapter
BOOLEAN CDiagnostics::ExecDhcpQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_ADAPTER_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_DHCP_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS),MAX_PATH);

    PropList.push_back(WbemProperty(L"DHCPServer",TYPE_PING | TYPE_IP,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
	PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));

    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

// Get the Computer info data from Win32_ComputerSystem
BOOLEAN CDiagnostics::ExecComputerQuery()
{
    if( !(m_bFlags & FLAG_CMD_SHOW) )
    {
        return FALSE;
    }
    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_COMPUTER_CAPTION;
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_SYSTEMINFO),MAX_PATH);
    wcsncpy(m_szwHeader,ids(IDS_COMPUTER_HEADER),MAX_PATH);

    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_COMPUTER));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList);

    return TRUE;
}

// Gets the system info data from Win32_SystemInformation
BOOLEAN CDiagnostics::ExecOSQuery()
{
    if( !(m_bFlags & FLAG_CMD_SHOW) )
    {
        return FALSE;
    }

    EnumWbemProperty PropList;

    m_pszwCaption = TXT_OS_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_OS_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_SYSTEMINFO),MAX_PATH);

    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_OS));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList);

    return TRUE;
}

// Gets the Version info data from Win32_SystemInformation
BOOLEAN CDiagnostics::ExecVersionQuery()
{
    if( !(m_bFlags & FLAG_CMD_SHOW) )
    {
        return FALSE;
    }

    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_VERSION_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_VERSION_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_SYSTEMINFO),MAX_PATH);

    PropList.push_back(WbemProperty(L"Version",0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_OS));
    PropList.push_back(WbemProperty(L"BuildVersion",0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_WMI));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList);

    return TRUE;
}

// Converts a port number into a string
LPWSTR GetMailType(DWORD dwType)
{
    switch(dwType)
    {
    case MAIL_SMTP:
        return ids(IDS_SMTP); 
    case MAIL_SMTP2:
        return ids(IDS_SMTP);
    case MAIL_POP3:
        return ids(IDS_POP3);
    case MAIL_IMAP:
        return ids(IDS_IMAP);
    case MAIL_HTTP:
        return ids(IDS_HTTP);
    default:
        return ids(IDS_UNKNOWN);
    }
}


//Gets the news and data and formats the results. performs the pings and connects
BOOLEAN CDiagnostics::ExecNewsQuery()
{    
    HRESULT hr;
    INETSERVER rNewsServer;
    EnumProperty PropList;
    BOOLEAN bConnect = 2;

    m_pszwCaption = TXT_NEWS_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_NEWS_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET),MAX_PATH);

    hr = GetOEDefaultNewsServer2(rNewsServer); 

    if( SUCCEEDED(hr) )
    {        
        if( strcmp(rNewsServer.szServerName,"")  != 0 )
        {
            Property Prop;           

            m_bstrCaption = rNewsServer.szServerName;

            Prop.Clear();
            Prop.SetProperty(L"NewsNNTPPort",TYPE_CONNECT);
            Prop.Value.push_back(_variant_t((LONG)rNewsServer.dwPort));
            PropList.push_back(Prop);

            Prop.Clear();
            Prop.SetProperty(L"NewsServer",TYPE_PING | TYPE_CONNECT);
            Prop.Value.push_back(_variant_t(rNewsServer.szServerName));
            PropList.push_back(Prop);            

            if( (m_bFlags & FLAG_CMD_CONNECT) )
            {
                WCHAR wszConnect[MAX_PATH+1];
                _bstr_t bstrServer = rNewsServer.szServerName;
                
               
                if( Connect((LPWSTR)bstrServer,rNewsServer.dwPort) )
                {
                    //L"Successfully connected to %hs port %d"
                    _snwprintf(wszConnect,MAX_PATH,ids(IDS_CONNECTEDTOSERVERSUCCESS),rNewsServer.szServerName,rNewsServer.dwPort);               
                    bConnect = TRUE;
                }
                else
                {

                    //"Unable to connect to %hs port %d"
                    _snwprintf(wszConnect,MAX_PATH,ids(IDS_CONNECTEDTOSERVERFAILED),rNewsServer.szServerName,rNewsServer.dwPort);               
                    bConnect = FALSE;
                }
                    
                PropList.push_back(Property(wszConnect,TYPE_TEXT | TYPE_CONNECT));
                
            }
        }
    }
    else
    {            
        m_bstrCaption = ids(IDS_NOTCONFIGURED);
        PropList.push_back(Property((WCHAR*)m_bstrCaption,TYPE_TEXT));
    }

    FormatEnum(PropList, NULL, bConnect);

    m_bstrCaption = L"";


    return TRUE;
}

// Get and format the Mail server and port number. This uses the OEACCTMGR not WMI.
// OEACCTMGR does not work if it is run as a provider 
BOOLEAN CDiagnostics::ExecMailQuery()
{    
    EnumProperty PropList;
    INETSERVER rInBoundMailServer;
    INETSERVER rOutBoundMailServer;
    DWORD dwInBoundMailType;
    DWORD dwOutBoundMailType;
    HRESULT hr;
    BOOLEAN bConnect = 2;
    BOOLEAN bMailConfigured = FALSE;

    

    // Set the caption, header and category information (describes this object)
    //
    m_pszwCaption = TXT_MAIL_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_MAIL_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET),MAX_PATH);

    hr = GetOEDefaultMailServer2(rInBoundMailServer, 
                                 dwInBoundMailType,
                                 rOutBoundMailServer, 
                                 dwOutBoundMailType);

    if( SUCCEEDED(hr) )
    {
        if( strcmp(rInBoundMailServer.szServerName,"")  != 0 )
        {
            Property Prop;
            _variant_t varValue;

            m_bstrCaption = rInBoundMailServer.szServerName;

            Prop.Clear();
            Prop.SetProperty(L"InBoundMailPort",TYPE_CONNECT);
            Prop.Value.push_back(_variant_t((LONG)rInBoundMailServer.dwPort));
            PropList.push_back(Prop);

            Prop.Clear();
            Prop.SetProperty(L"InBoundMailServer",TYPE_CONNECT | (dwInBoundMailType!=MAIL_HTTP ? TYPE_PING : 0));
            Prop.Value.push_back(_variant_t(rInBoundMailServer.szServerName));
            PropList.push_back(Prop);            

            Prop.Clear();
            Prop.SetProperty(L"InBoundMailType",0);
            Prop.Value.push_back(_variant_t(GetMailType(dwInBoundMailType)));
            PropList.push_back(Prop);

            if( (m_bFlags & FLAG_CMD_CONNECT) && dwInBoundMailType != MAIL_HTTP)
            {
                _bstr_t bstrServer = rInBoundMailServer.szServerName;
                WCHAR wszConnect[MAX_PATH+1];
               
                if( Connect((LPWSTR)bstrServer,rInBoundMailServer.dwPort) )
                {
                    _snwprintf(wszConnect,MAX_PATH,ids(IDS_CONNECTEDTOSERVERSUCCESS),rInBoundMailServer.szServerName,rInBoundMailServer.dwPort);               
                    bConnect = TRUE;
                }
                else
                {
                    _snwprintf(wszConnect,MAX_PATH,ids(IDS_CONNECTEDTOSERVERFAILED),rInBoundMailServer.szServerName,rInBoundMailServer.dwPort);               
                    bConnect = FALSE;
                }
                    
                PropList.push_back(Property(wszConnect,TYPE_TEXT | TYPE_CONNECT));
                
            }

            bMailConfigured = TRUE;
        }

        if( strcmp(rOutBoundMailServer.szServerName,"")  != 0 )
        {

            Property Prop;
            _variant_t varValue;

            if( bMailConfigured )
            {
                m_bstrCaption += L" / ";
            }

            m_bstrCaption += rOutBoundMailServer.szServerName;

            Prop.Clear();
            Prop.SetProperty(L"OutBoundMailPort",TYPE_CONNECT);
            Prop.Value.push_back(_variant_t((LONG)rOutBoundMailServer.dwPort));
            PropList.push_back(Prop);

            Prop.Clear();
            Prop.SetProperty(L"OutBoundMailServer",TYPE_PING | TYPE_CONNECT);
            Prop.Value.push_back(_variant_t(rOutBoundMailServer.szServerName));
            PropList.push_back(Prop);            

            Prop.Clear();
            Prop.SetProperty(L"OutBoundMailType",0);
            Prop.Value.push_back(_variant_t(GetMailType(dwOutBoundMailType)));
            PropList.push_back(Prop);

            if( (m_bFlags & FLAG_CMD_CONNECT) && dwOutBoundMailType != MAIL_HTTP)
            {
                _bstr_t bstrServer = rOutBoundMailServer.szServerName;
                WCHAR wszConnect[MAX_PATH+1];
               
                if( Connect((LPWSTR)bstrServer,rOutBoundMailServer.dwPort) )
                {
                    _snwprintf(wszConnect,MAX_PATH,ids(IDS_CONNECTEDTOSERVERSUCCESS),rOutBoundMailServer.szServerName,rOutBoundMailServer.dwPort);               
                    bConnect = TRUE;
                }
                else
                {
                    _snwprintf(wszConnect,MAX_PATH,ids(IDS_CONNECTEDTOSERVERFAILED),rOutBoundMailServer.szServerName,rOutBoundMailServer.dwPort);               
                    bConnect = FALSE;
                }
                    
                PropList.push_back(Property(wszConnect,TYPE_TEXT | TYPE_CONNECT));
                
            }

            bMailConfigured = TRUE;
        }

        if( !bMailConfigured )
        {
            m_bstrCaption = ids(IDS_NOTCONFIGURED);
            PropList.push_back(Property((WCHAR*)m_bstrCaption,TYPE_TEXT));
        }
    }
    else
    {
        m_bstrCaption = ids(IDS_NOTCONFIGURED);
        PropList.push_back(Property((WCHAR*)m_bstrCaption,TYPE_TEXT));
    }
    FormatEnum(PropList, NULL, bConnect);

    m_bstrCaption = L"";
    return TRUE;
}



// Get IE's proxy settings and process the data
BOOLEAN CDiagnostics::ExecProxyQuery()
{

    WCHAR wszProxy[MAX_PATH];
    DWORD dwPort;
    DWORD dwEnabled;
    EnumProperty PropList;    
    BOOLEAN bConnectPass = 2;
    WCHAR szw[MAX_PATH+1];

    wcsncpy(m_szwHeader,ids(IDS_PROXY_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET),MAX_PATH);
    
    if( GetIEProxy(wszProxy,MAX_PATH,&dwPort,&dwEnabled) )
    {                    
        m_bstrCaption = wszProxy;

        if( dwEnabled )
        {
            Property Prop;
            WCHAR szwConnect[MAX_PATH+1];
            LONG nConnect = 0;

            Prop.Clear();
            Prop.SetProperty(L"IEProxy",TYPE_PING | TYPE_CONNECT);
            Prop.Value.push_back(_variant_t(wszProxy));
            PropList.push_back(Prop);

            Prop.Clear();
            Prop.SetProperty(L"IEProxyPort",TYPE_CONNECT);
            Prop.Value.push_back(_variant_t((LONG)dwPort));
            PropList.push_back(Prop);

            if( (m_bFlags & FLAG_CMD_CONNECT) )
            {
                // Connecting to %s port %d
                _snwprintf(szw,MAX_PATH,ids(IDS_CONNECTINGTOSERVER_STATUS),wszProxy,dwPort);               

                ReportStatus(szw,0);

                _snwprintf(szwConnect,MAX_PATH,ids(IDS_SERVERCONNECTSTART));
                if( Connect(wszProxy,dwPort) )
                {
                    _snwprintf(szwConnect,MAX_PATH,L"%s%s%d",szwConnect,nConnect?L",":L"",dwPort);
                    nConnect++;
                }
                if( !nConnect )
                {
                    _snwprintf(szwConnect,MAX_PATH,L"%s%s",szwConnect,ids(IDS_NONE));
                    bConnectPass = FALSE;
                }
                else
                {
                    bConnectPass = TRUE;
                }

                _snwprintf(szwConnect,MAX_PATH,L"%s%s",szwConnect,ids(IDS_SERVERCONNECTEND));
                PropList.push_back(WbemProperty(szwConnect,TYPE_TEXT | TYPE_CONNECT));

            }
        }
        else
        {
            HideAll(PropList);
            lstrcpy(szw,ids(IDS_IEPROXYNOTUSED));
            m_pszwCaption = szw;
            m_bstrCaption = ids(IDS_IEPROXYNOTUSED); //IDS_NOTCONFIGURED
        }

    }

    FormatEnum(PropList,NULL, bConnectPass);
    m_bstrCaption = L"";
    return TRUE;
}

// Get teh loopback adapter
BOOLEAN CDiagnostics::ExecLoopbackQuery()
{
    EnumWbemProperty PropList;
    EnumWbemProperty::iterator iter;

    _variant_t vLoopback = L"127.0.0.1";
    
    m_pszwCaption = TXT_LOOPBACK_CAPTION;
    wcsncpy(m_szwHeader,ids(IDS_LOOPBACK_HEADER),MAX_PATH);
    wcsncpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET),MAX_PATH);

    PropList.push_back(WbemProperty(L"Loopback",TYPE_PING));    

    iter = PropList.begin();
    iter->Value.push_back(vLoopback);

    FormatEnum(PropList);

    return TRUE;
}


// ping or connect to a specified IP host name or IP address
BOOLEAN CDiagnostics::ExecIPHost(WCHAR *pszwHostName,WCHAR *pszwHostPort)
{
    EnumProperty PropList;
    WCHAR szw[MAX_PATH+1];
    BOOL bFlag;

    m_pszwCaption = L"IPHost";
    lstrcpy(m_szwHeader,L"IPHost");
    
    Set(PropList, L"IPHost",TYPE_CONNECT | TYPE_PING,_variant_t(pszwHostName));

    if( m_bFlags & FLAG_CMD_CONNECT )
    {
        WCHAR szw[MAX_PATH+1];
        WCHAR szwConnect[MAX_PATH+1];
        
        Set(PropList, L"Port",TYPE_CONNECT,_variant_t(pszwHostPort));
        _snwprintf(szw,MAX_PATH,L"Connecting to %s port %s",pszwHostName,pszwHostPort);
        ReportStatus(szw,0);
        _snwprintf(szwConnect,MAX_PATH,ids(IDS_SERVERCONNECTSTART));
        if( IsNumber(pszwHostPort) && Connect(pszwHostName,wcstol(pszwHostPort,NULL,10)) )
        {
            _snwprintf(szwConnect,MAX_PATH,L"%s%s",szwConnect,pszwHostPort);
        }
        else
        {
            _snwprintf(szwConnect,MAX_PATH,L"%s%s",szwConnect,ids(IDS_NONE));
        }

        _snwprintf(szwConnect,MAX_PATH,L"%s%s",szwConnect,ids(IDS_SERVERCONNECTEND));
        PropList.push_back(Property(szwConnect,TYPE_TEXT | TYPE_CONNECT));
    }

    FormatEnum(PropList);

    return TRUE;
        
}




// Init the netsh interface
void CDiagnostics::NetShNetdiag(BOOLEAN bStartTag, LPCTSTR pszwValue)
{
    if( m_bInterface == NETSH_INTERFACE )
    {
        m_nIndent = 0;
        m_IsNetdiagDisplayed = FALSE;
    }
}

// Format the netsh header
void CDiagnostics::NetShHeader(BOOLEAN bStartTag,LPCTSTR pszwValue,LPCTSTR pszwCaption)
{
    if( m_bInterface == NETSH_INTERFACE )
    {
        if( bStartTag )
        {
            DisplayMessageT(L"\n");
            if( pszwValue )
            {
                LONG nIndent = m_IsNetdiagDisplayed;
                DisplayMessageT(L"%1!s!%2!s!",Indent(nIndent),pszwValue);
                if( pszwCaption )
                {
                    DisplayMessageT(L" (%1!s!)",pszwCaption);
                }
                DisplayMessageT(L"\n");
                m_IsContainerDisplayed = TRUE;
            }
            else
            {
                m_IsContainerDisplayed = FALSE;
            }
        }
        else
        {
            m_IsContainerDisplayed = FALSE;
        }
    }
}

// Format the netsh caption
void CDiagnostics::NetShCaption(BOOLEAN bStartTag,LPCTSTR pszwValue)
{
    if( m_bInterface == NETSH_INTERFACE )
    {
        if( bStartTag )
        {
            if( m_nInstance > 1 )
            {
                if( m_bCaptionDisplayed == FALSE )
                {
                    if( pszwValue )
                    {
                        LONG nIndent = m_IsNetdiagDisplayed + m_IsContainerDisplayed;
                        DisplayMessageT(L"%1!s!%2!2d!. %3!s!\n",Indent(nIndent),m_nIndex, pszwValue);
                        m_IsPropertyListDisplayed = TRUE;
                    }
                    else
                    {
                        m_IsPropertyListDisplayed = FALSE;
                    }

                    m_bCaptionDisplayed = TRUE;
                }
            }
        }
        else
        {
            m_IsPropertyListDisplayed = FALSE;
        }
    }
}

void CDiagnostics::NetShField(BOOLEAN bStartTag,LPCTSTR pszwValue)
{
    if( m_bInterface == NETSH_INTERFACE )
    {                       
        if( bStartTag )
        {
            m_nPropertyLegth = 0;

            LONG nIndent = m_IsNetdiagDisplayed + m_IsContainerDisplayed + m_IsPropertyListDisplayed;
            if( pszwValue )
            {
                m_nPropertyLegth = DisplayMessageT(L"%1!s!%2!s! = ",Indent(nIndent),pszwValue);
            }
            else
            {
                m_nPropertyLegth = DisplayMessageT(L"%1!s!",Indent(nIndent));
            }
            m_nValueIndex = 0;
            m_IsPropertyDisplayed = TRUE;
        }
        else
        {        
            m_IsPropertyDisplayed = FALSE;
        }
    }
}

void CDiagnostics::NetShProperty(BOOLEAN bStartTag,LPCTSTR pszwValue,LPCTSTR pszwComment,BOOL bFlags)
{
    if( m_bInterface == NETSH_INTERFACE )
    {
        if( bStartTag )
        {
            if( (bFlags & TYPE_PING) )
            {
                LONG nIndent = m_IsNetdiagDisplayed + m_IsContainerDisplayed + m_IsPropertyListDisplayed + m_IsPropertyDisplayed;
                if( m_nValueIndex == 0 )
                {
                    DisplayMessageT(L"\n");
                }
                DisplayMessageT(L"%1!s!%2!s! %3!s!\n",Indent(nIndent),pszwValue?pszwValue:L"",pszwComment?pszwComment:L"");
                m_nValueIndex++;
            }
            else
            {
                DisplayMessageT(L"%1!s!%2!s! %3!s!\n",m_nValueIndex++?Space(m_nPropertyLegth):L"",pszwValue?pszwValue:L"",pszwComment?pszwComment:L"");
            }
            m_IsValueDisplayed = TRUE;
        }
        else
        {
            m_IsValueDisplayed = FALSE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\proxy.cpp ===
// proxy.cpp
//
#include "stdafx.h"
#include "Wininet.h"

const TCHAR szFileVersion[]	 = TEXT("FileVersion");


BOOL GetIEProxy(LPWSTR pwszProxy, LONG ProxyLen, LPDWORD pdwPort, LPDWORD pdwEnabled)
{
    unsigned long        nSize = 4096;
    INTERNET_PROXY_INFO* pInfo;
    LONG i;
    LONG j;

    pwszProxy[0] = L'\0';
    *pdwPort = 0;
    *pdwEnabled = FALSE;

    pInfo = (INTERNET_PROXY_INFO*)HeapAlloc(GetProcessHeap(),0,nSize);
    if( !pInfo  )
    {
        return FALSE;
    }

    do
    {
        if(!InternetQueryOption(NULL, INTERNET_OPTION_PROXY, pInfo, &nSize))
        {
            if( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                LPVOID pTmp;
                pTmp = HeapReAlloc(GetProcessHeap(),0,pInfo,nSize);
                if( !pTmp )
                {
                    HeapFree(GetProcessHeap(),0,pInfo);
                    return FALSE;
                }
                pInfo = (INTERNET_PROXY_INFO*)pTmp;
                continue;
            }
        }
    }
    while(FALSE);

    if( pInfo->lpszProxy )
    {
        PCHAR psz = (PCHAR) pInfo->lpszProxy;
        PCHAR EndPtr = NULL;
        LONG Len = 0;

        //
        // Get the port Number from the string
        //
        for(i=strlen(psz)-1; i>=0 && psz[i] != ':'; i--)
            ;
        if( psz[i] == ':' )
        {
            *pdwPort = strtoul((CHAR *)&psz[i+1],&EndPtr,10);
            if( *EndPtr != L'\0' )
            {
                *pdwPort = 0;
            }
            i--;
        }

        //
        // Get the URL or IP Address. This is right after http://
        //
        for(i=i; i>=0 && psz[i] != '/'; i--, Len++)
            ;

        //
        // Copy the URL or IP address into our buffer
        //
        for(i=i+1, j=0; j<Len; i++, j++)
        {
            pwszProxy[j] = (WCHAR)psz[i];
        }

        pwszProxy[j] = L'\0';
        
        *pdwEnabled = TRUE;        
    }        

    HeapFree(GetProcessHeap(),0,pInfo);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\util.h ===
#ifndef UTIL_H
#define UTIL_H

#include "stdafx.h"

void 
ToLowerStr(
    WCHAR *pszwText
    );

WCHAR * 
Space(
    int nSpace
    );

WCHAR * 
Indent(
    int nIndent
    );

BOOLEAN 
IsNumber(
    IN LPCTSTR pszw
    );

BOOLEAN 
wcsstri(
    IN LPCTSTR pszw,
    IN LPCTSTR pszwSrch,
    IN int nLen = -1
    );

BOOLEAN 
IsContained(
    IN LPCTSTR pszwInstance, 
    IN LPCTSTR pszwSrch
    );

HRESULT 
GetVariant(
    IN  _variant_t  &vValue, 
    IN  long        nIndex, 
    OUT _bstr_t     &bstr
    );

BOOLEAN 
IsVariantEmpty(
    _variant_t &vValue
    );

WCHAR *
ids(
    LONG nIndex
    );

BOOLEAN 
IsSameSubnet(
        IN LPCTSTR pszwIP1, 
        IN LPCTSTR pszwIP2, 
        IN LPCTSTR pszwSubnetMask
        );

BOOLEAN 
IsSameSubnet(
    IN _variant_t *vIPAddress, 
    IN _variant_t *vSubnetMask, 
    IN WCHAR *pszwIPAddress2
    );

/*
BOOLEAN 
IsInvalidIPAddress(
    LPCTSTR pszwIPAddress
    );
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\ping.cpp ===
#include "diagnostics.h"

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <Ipexport.h>
#include <icmpapi.h>
#include <ctype.h>

#define DEFAULT_SEND_SIZE           32
#define DEFAULT_TTL                 128
#define DEFAULT_TOS                 0
#define DEFAULT_COUNT               4
#define DEFAULT_TIMEOUT             4000L
#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define MIN_INTERVAL                1000L

struct IPErrorTable {
    IP_STATUS  Error;                   // The IP Error    
    DWORD ErrorNlsID;                   // NLS string ID
} ErrorTable[] =
{
    { IP_BUF_TOO_SMALL,         PING_BUF_TOO_SMALL},
    { IP_DEST_NET_UNREACHABLE,  PING_DEST_NET_UNREACHABLE},
    { IP_DEST_HOST_UNREACHABLE, PING_DEST_HOST_UNREACHABLE},
    { IP_DEST_PROT_UNREACHABLE, PING_DEST_PROT_UNREACHABLE},
    { IP_DEST_PORT_UNREACHABLE, PING_DEST_PORT_UNREACHABLE},
    { IP_NO_RESOURCES,          PING_NO_RESOURCES},
    { IP_BAD_OPTION,            PING_BAD_OPTION},
    { IP_HW_ERROR,              PING_HW_ERROR},
    { IP_PACKET_TOO_BIG,        PING_PACKET_TOO_BIG},
    { IP_REQ_TIMED_OUT,         PING_REQ_TIMED_OUT},
    { IP_BAD_REQ,               PING_BAD_REQ},
    { IP_BAD_ROUTE,             PING_BAD_ROUTE},
    { IP_TTL_EXPIRED_TRANSIT,   PING_TTL_EXPIRED_TRANSIT},
    { IP_TTL_EXPIRED_REASSEM,   PING_TTL_EXPIRED_REASSEM},
    { IP_PARAM_PROBLEM,         PING_PARAM_PROBLEM},
    { IP_SOURCE_QUENCH,         PING_SOURCE_QUENCH},
    { IP_OPTION_TOO_BIG,        PING_OPTION_TOO_BIG},
    { IP_BAD_DESTINATION,       PING_BAD_DESTINATION},
    { IP_NEGOTIATING_IPSEC,     PING_NEGOTIATING_IPSEC},
    { IP_GENERAL_FAILURE,       PING_GENERAL_FAILURE}
};

UINT  num_send=0, num_recv=0, time_min=(UINT)-1, time_max=0, time_total=0;
IPAddr address=0;                      



LPWSTR NlsPutMsg(HMODULE Handle, unsigned usMsgNum, ...);


unsigned long get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq);

//void print_statistics();

int CDiagnostics::Ping2(WCHAR *warg)
{
    HANDLE IcmpHandle;
    IP_OPTION_INFORMATION SendOpts;
    UCHAR  *Opt = NULL;                // Pointer to send options
    UCHAR  Flags = 0;
    char   SendBuffer[DEFAULT_SEND_SIZE];
    char   RcvBuffer[DEFAULT_BUFFER_SIZE];
    UINT   SendSize = DEFAULT_SEND_SIZE;
    UINT   RcvSize  = DEFAULT_BUFFER_SIZE;
    UINT   i;  
    UINT   j;
    char   *hostname = NULL;
    int    was_inaddr;
    int    dnsreq = 0;
    struct in_addr addr;
    DWORD   numberOfReplies;
    UINT    Count = DEFAULT_COUNT;
    DWORD   errorCode;
    PICMP_ECHO_REPLY  reply;
    LPWSTR wszMsg, wszMsg2, wszMsg3, wszMsg4, wszMsg5;
    int SuccessCount = 0;
    char *arg;

    num_send=0;
    num_recv=0, 
    time_min=(UINT)-1;
    time_max=0;
    time_total=0;
    address=0;                      

    if( warg == NULL )
    {
        wszMsg = NlsPutMsg(g_hModule,PING_NO_MEMORY,GetLastError());
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return FALSE;
    }

    int len = lstrlen(warg);
    if( len == 0 )
    {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_2,warg);
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return FALSE;
    }

    // Add the '\0' char
    len++;
    len *= 2;

    arg = (CHAR *)HeapAlloc(GetProcessHeap(),0,len * sizeof(WCHAR));
    if( !arg )
    {
        wszMsg = NlsPutMsg(g_hModule,IDS_PINGMSG_1,GetLastError());
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return FALSE;
    }

    //if( WideCharToMultiByte(0,
    if( -1 == wcstombs(arg,warg,len) )
    {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_2,warg);
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        HeapFree(GetProcessHeap(),0,arg);
        return FALSE;
    }
    
    FormatPing(NULL);

    address = get_pingee(arg, &hostname, &was_inaddr, dnsreq);
    if ( !address || (address == INADDR_NONE) ) {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_2,warg);
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return 0;
    }    


    IcmpHandle = IcmpCreateFile();    

    if (IcmpHandle == INVALID_HANDLE_VALUE) {         
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_3,GetLastError());
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return 0;
    }

    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < SendSize; i++) {
        SendBuffer[i] = 'a' + (i % 23);
    }

    
    //
    // Initialize the send options
    //
    SendOpts.OptionsData = NULL;
    SendOpts.OptionsSize = 0;
    SendOpts.Ttl = DEFAULT_TTL;
    SendOpts.Tos = DEFAULT_TOS;
    SendOpts.Flags = Flags;

    addr.s_addr = address;


    if (hostname) {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_4,hostname,inet_ntoa(addr),SendSize);
        FormatPing(wszMsg);
        LocalFree(wszMsg);
    }
    else
    {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_5,inet_ntoa(addr),SendSize);
        FormatPing(wszMsg);
        LocalFree(wszMsg);
    }

    for (i = 0; i < Count; i++) {

        if( ShouldTerminate() ) goto end;

        numberOfReplies = IcmpSendEcho2(IcmpHandle,
                                        0,
                                        NULL,
                                        NULL,
                                        address,
                                        SendBuffer,
                                        (unsigned short) SendSize,
                                        &SendOpts,
                                        RcvBuffer,
                                        RcvSize,
                                        DEFAULT_TIMEOUT);       

        num_send++;

        if (numberOfReplies == 0) {

            errorCode = GetLastError();

            if (errorCode < IP_STATUS_BASE) {
                wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_6,errorCode);
                FormatPing(wszMsg);
                LocalFree(wszMsg);
            } else {
                for (j = 0; ErrorTable[j].Error != errorCode &&
                    ErrorTable[j].Error != IP_GENERAL_FAILURE;j++)
                    ;

                wszMsg = NlsPutMsg(g_hModule, ErrorTable[j].ErrorNlsID);
                FormatPing(wszMsg);
                LocalFree(wszMsg);
            }

            if (i < (Count - 1)) {
                Sleep(MIN_INTERVAL);
            }

        } else {
            // We can trust the buffer that it is the correct size otherwise IcmpSendEcho2 would fail
            reply = (PICMP_ECHO_REPLY) RcvBuffer;

            while (numberOfReplies--) {
                struct in_addr addr;

                addr.S_un.S_addr = reply->Address;

                wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_7, inet_ntoa(addr));
                if (reply->Status == IP_SUCCESS) {

                    wszMsg2 = NlsPutMsg(g_hModule, IDS_PINGMSG_8, wszMsg, (int) reply->DataSize);
                    if (reply->DataSize != SendSize) {
                        wszMsg3 = NlsPutMsg(g_hModule, IDS_PINGMSG_9, wszMsg2, (int) reply->DataSize);                        
                    } else {
                        char *sendptr, *recvptr;

                        sendptr = &(SendBuffer[0]);
                        recvptr = (char *) reply->Data;

                        wszMsg3 = NlsPutMsg(g_hModule, IDS_PINGMSG_14, wszMsg2);
                        for (j = 0; j < SendSize; j++)
                            if (*sendptr++ != *recvptr++) {
                                wszMsg3 = NlsPutMsg(g_hModule, IDS_PINGMSG_10, wszMsg2,j);
                                break;
                            }                        
                        
                    }

                    if (reply->RoundTripTime) {

                        wszMsg4 = NlsPutMsg(g_hModule, IDS_PINGMSG_11, wszMsg3,reply->RoundTripTime);
                        // Collect stats.

                        time_total += reply->RoundTripTime;
                        if ( reply->RoundTripTime < time_min ) {
                            time_min = reply->RoundTripTime;
                        }
                        if ( reply->RoundTripTime > time_max ) {
                            time_max = reply->RoundTripTime;
                        }
                    }

                    else {

                        wszMsg4 = NlsPutMsg(g_hModule, IDS_PINGMSG_12,wszMsg3);
                        time_min = 0;
                    }

                    wszMsg5 = NlsPutMsg(g_hModule, IDS_PINGMSG_13, wszMsg4,reply->RoundTripTime);
                    if (reply->Options.OptionsSize) {
                        // void, we have no options
                        //ProcessOptions(reply, (BOOLEAN) dnsreq);
                    }

                    FormatPing(wszMsg5);
                    if(wszMsg)  LocalFree(wszMsg);
                    if(wszMsg2) LocalFree(wszMsg2);
                    if(wszMsg3) LocalFree(wszMsg3);
                    if(wszMsg4) LocalFree(wszMsg4);
                    if(wszMsg5) LocalFree(wszMsg5);
                    SuccessCount++;
                } else {
                    for (j=0; ErrorTable[j].Error != IP_GENERAL_FAILURE; j++) {
                        if (ErrorTable[j].Error == reply->Status) {
                            break;
                        }
                    }
                    wszMsg = NlsPutMsg(g_hModule, ErrorTable[j].ErrorNlsID);                    
                    FormatPing(wszMsg);
                    LocalFree(wszMsg);
                }

                num_recv++;
                reply++;
            }

            if (i < (Count - 1)) {
                reply--;

                if (reply->RoundTripTime < MIN_INTERVAL) {
                    Sleep(MIN_INTERVAL - reply->RoundTripTime);
                }
            }
        }
    }

    print_statistics();

end:
    
    (void)IcmpCloseHandle(IcmpHandle);

    HeapFree(GetProcessHeap(),0,arg);
    return SuccessCount == Count;
}

unsigned long
get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq)
{
    struct hostent *hostp = NULL;
    long            inaddr;

    if ( strcmp( ahstr, "255.255.255.255" ) == 0 ) {
        return(0L);
    }

    if ((inaddr = inet_addr(ahstr)) == -1L) {
        hostp = gethostbyname(ahstr);
        if (hostp) {
            /*
             * If we find a host entry, set up the internet address
             */
            inaddr = *(long *)hostp->h_addr;
            *was_inaddr = 0;
        } else {
            // Neither dotted, not name.
            return(0L);
        }

    } else {
        // Is dotted.
        *was_inaddr = 1;
        if (dnsreq == 1) {
            hostp = gethostbyaddr((char *)&inaddr,sizeof(inaddr),AF_INET);
        }
    }

    *hstr = hostp ? hostp->h_name : (char *)NULL;
    return(inaddr);
}


void
CDiagnostics::print_statistics(  )
{
    struct in_addr addr;
    LPWSTR wszMsg;

    if (num_send > 0) {
        addr.s_addr = address;

        if (time_min == (UINT) -1) {  // all times were off.
            time_min = 0;
        }

        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_15,inet_ntoa(addr));                    
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_16,
                           num_send, num_recv,num_send - num_recv,(UINT) ( 100 * (num_send - num_recv) / num_send ));                    
        FormatPing(wszMsg);
        LocalFree(wszMsg);

        if (num_recv > 0) {

            wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_17);                    
            FormatPing(wszMsg);
            LocalFree(wszMsg);
            wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_18,
                               time_min, time_max, time_total / num_recv);                    
            FormatPing(wszMsg);
            LocalFree(wszMsg);
        }
    }
}

LPWSTR
NlsPutMsg(HMODULE Handle, unsigned usMsgNum, ...)
{
    unsigned msglen;
    VOID * vp = NULL;
    va_list arglist;
    DWORD StrLen;
    WCHAR wszFormat[MAX_PATH+1];    
    int ret;

    wszFormat[MAX_PATH] = 0;
    if( (ret=LoadString(Handle,usMsgNum,wszFormat,MAX_PATH))!=0 )
    {
        va_start(arglist, usMsgNum);
        if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                     FORMAT_MESSAGE_FROM_STRING,
                                     wszFormat,
                                     0,
                                     0L,    // Default country ID.
                                     (LPTSTR)&vp,
                                     0,
                                     &arglist)))

        {
            return NULL; 

        }
    }
    return (LPWSTR)vp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED_)
#define AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
extern HMODULE g_hModule;
#include <windows.h>
#include <atlcom.h>
#include <comdef.h>
#include <string>
#include <map>
#include <vector>
#include <list>
#include <wbemidl.h>
#include <wbemcli.h>
#include <winsock2.h>
#include "dglogsres.h"
#include "network.h"
#include <netsh.h>

// Functions loaded from netsh.exe. We can not link to netsh.exe since it conflicts with wmi.exe or something like that.
//
typedef DWORD (WINAPI *RegisterHelper22)(CONST GUID *, CONST NS_HELPER_ATTRIBUTES *);
typedef DWORD (WINAPI *RegisterContext22)(CONST NS_CONTEXT_ATTRIBUTES *);
typedef DWORD (WINAPI *PrintMessage22)(LPCWSTR, ...);


using namespace std;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\util.cpp ===
#include "util.h"

WCHAR g_szwIds[MAX_PATH + 1];
WCHAR g_szwSpace[MAX_PATH + 1];

WCHAR *
ids(LONG nIndex)
{
    if( LoadString((HINSTANCE)g_hModule,nIndex,g_szwIds,MAX_PATH) )
    {
        g_szwIds[MAX_PATH] = L'\0';
        return g_szwIds;
    }
    else
    {
        return L"";
    }
}

WCHAR * 
Space(
    int nSpace
    )
{
    for(int i=0; i<nSpace && i< MAX_PATH; i++)
    {
        g_szwSpace[i] = L' ';
    }

    g_szwSpace[i] = L'\0';

    return g_szwSpace;
}

WCHAR * 
Indent(
    int nIndent
    )
{
    return Space(nIndent * 4);
}
BOOLEAN 
IsNumber(
    IN LPCTSTR pszw
    )
{
    if( !pszw )
    {
        return FALSE;
    }
    for(int i=0; pszw[i]!=L'\0'; i++)
    {
        if( !isdigit(pszw[i]) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

BOOLEAN 
IsContained(
    IN LPCTSTR pszwInstance, 
    IN LPCTSTR pszwSrch
    )
/*++

Routine Description
    This method compares two strings and determines if the strings resemble each 
    other. If the strings are identical, then they resemble each other.
    If the search string (pszwSrch) starts or ends with a '*', then the  method
    checks if the search string is contained inside of the instance string (pszwInstance).
    i.e. pszwInstance = 3Com 3C918 Integrated Fast Ethernet Controller (3C905B-TX Compatible)
         pszwSrch = com* |  *com
    then pszwSrch resembles pszwInstance. The string compare is not case sensative.

Arguments
    pszwInstance    The instance string
    pszwSrch        The search string

Return Value
    TRUE if the strings resemble each other
    else FALSE

--*/
{
    LPCTSTR pszw = NULL;
    int nLen;

    if( !pszwSrch || !pszwInstance || lstrcmpi(pszwSrch,L"*")==0 )
    {
        //  The strings are empty, so they match.
        //
        return TRUE;
    }

    if( pszwSrch[0] == L'*' )
    {
        // The search string starts with a '*', check if the search 
        // string is contained in the instance string
        //
        pszw = &pszwSrch[1];
        
        if( wcsstri(pszwInstance,pszw) )
        {
            // Search string is contain within the instance string
            //
            return TRUE;
        }
    }

    nLen = lstrlen(pszwSrch);
    if( nLen > 1 && pszwSrch[nLen -1] == L'*' )
    {
        // The search string ends with a '*'. check if the search 
        // string is contained in the instance string
        //
        if( wcsstri(pszwInstance,pszwSrch,nLen-1) )
        {
            // Search string is contain within the instance string
            //
            return TRUE;
        }
    }
    
    if( lstrcmpi(pszwInstance,pszwSrch) == 0 )
    {
        // No '*'. Check if the strings are the same
        //
        return TRUE;
    }

    // Strings do not resemble each other
    //
    return FALSE;
}

void 
ToLowerStr(
    WCHAR *pszwText
    )
{
    while( pszwText && *pszwText )
    {
        *pszwText = towlower(*pszwText);
        pszwText++;
    }
}

BOOLEAN 
wcsstri(
    IN LPCTSTR pszw,
    IN LPCTSTR pszwSrch,
    IN int nLen
    )
{
    BOOLEAN bMatch = FALSE;
    int i=0,j=0;

    if( !pszw || !pszwSrch )
    {
        // Invalid pointers
        //
        return FALSE;
    }

    for(i=0; pszw[i]!=L'\0'; i++)
    {
        if( j == nLen )
        {
            return bMatch;
        }
        if( pszwSrch[j] == L'\0' )
        {
            return bMatch;
        }
        if( towlower(pszw[i]) == towlower(pszwSrch[j]) )
        {
            j++;
            bMatch = TRUE;
        }
        else
        {
            j=0;
            bMatch = FALSE;
        }
    }

    return FALSE;
}


BOOLEAN IsVariantEmpty(_variant_t &vValue)
{
    _bstr_t bstr;
    if( SUCCEEDED(GetVariant(vValue,0,bstr)) )
    {
        return lstrcmp(bstr,L"") == 0;
    }
    return TRUE;
}

BOOLEAN MakeIPByteArray(LPCTSTR pszwIPAddress, BYTE bIPByte[])
{
    LONG nByteValue = 0;
    LONG nByte = 0;

    for(int i=0; pszwIPAddress[i]!=0; i++)
    {
        if( pszwIPAddress[i] == L'.')
        {
            if( nByteValue > 255 )
            {
                return FALSE;
            }
            bIPByte[nByte] = nByteValue;
            nByteValue = 0;
            nByte++;
        }
        else
        {
            if( !iswdigit(pszwIPAddress[i]) )
            {
                return FALSE;
            }
            nByteValue = nByteValue * 10 + (pszwIPAddress[i] - L'0');
        }
    }
    bIPByte[nByte] = nByteValue;

    return (nByte != 3)?FALSE:TRUE;
}
/*
BOOLEAN IsInvalidIPAddress(LPCTSTR pszwIPAddress)
{
    BYTE bIPByte[4];

    if( MakeIPByteArray(pszwIPAddress,bIPByte) )
    {
        INT iZeroCount = 0;
        INT i255Count = 0;
        for(INT i=0; i<4; i++)
        {
            if( pszwIPAddress[i] == 0 )
            {
                iZeroCount++;
            }

            if( pszwIPAddress[i] == 255 )
            {
                i255Count++;
            }
        }

        if( i255Count == 4 || iZeroCount == 4 )
        {
            return TRUE;
        }
    }

    return FALSE;
}
*/
BOOLEAN 
IsSameSubnet(
        IN LPCTSTR pszwIP1, 
        IN LPCTSTR pszwIP2, 
        IN LPCTSTR pszwSubnetMask
        )
/*++

Routine Description
    This method determines if two IP address are in the same subnet.

Arguments
    pszwIP1         IP Address one
    pszwIP2         IP Address two
    pszwSubnetMask  Subnet mask

Return Value
    TRUE if they are in the same subnet
    FALSE if they are not in the smae subnet

--*/
{
    BYTE bIP1[4];
    BYTE bIP2[4];
    BYTE bSubnetMask[4];
    int iRetVal;

    if( !MakeIPByteArray(pszwIP1,bIP1) )
    {
        return FALSE;
    }
    if( !MakeIPByteArray(pszwIP2,bIP2) )
    {
        return FALSE;
    }
    if( !MakeIPByteArray(pszwSubnetMask,bSubnetMask) )
    {
        return FALSE;
    }


    // Check if IP1 and IP2 are in the same subnet
    //
    for( int i = 0; i< 4; i++)
    {
        // If (IP1 & with Subnetmas) == (IP2 & with subnet) then they are in the same subnet
        //
        if( (bIP1[i] & bSubnetMask[i]) != (bIP2[i] & bSubnetMask[i]) )
        {
            // No the same subnet
            //
            return FALSE;
        }
    }

    // Same subnet
    //
    return TRUE;
}

BOOLEAN 
IsSameSubnet(
    IN _variant_t *vIPAddress, 
    IN _variant_t *vSubnetMask, 
    IN WCHAR *pszwIPAddress2
    )
{
    DWORD i = 0;
    DWORD j = 0;
    _bstr_t bstrIP;
    _bstr_t bstrSubnetMask;

    if( !vIPAddress || !vSubnetMask || !pszwIPAddress2 )
    {
        return FALSE;
    }
    
    while( S_OK == GetVariant(*vIPAddress,i,bstrIP) )
    {
        j = 0;
        while( S_OK == GetVariant(*vSubnetMask,j,bstrSubnetMask) )
        {
            if( IsSameSubnet(bstrIP, pszwIPAddress2, bstrSubnetMask) )
            {
                return TRUE;
            }
            j++;
        }
        i++;
    }

    return FALSE;
}



HRESULT 
GetVariant(
        IN  _variant_t  &vValue, 
        IN  long        nIndex, 
        OUT _bstr_t     &bstr
        )
/*++

Routine Description
    This method extracts nth piece of data from a variant, converts it into a bstring
    and returns the bstring.

Arguments
    vValue      Variant to extract data from
    nIndex      The index into the variant array (for non-arrays nIndex always is 0)
    bstr        Stores the variant as a bstr

Return Value
    S_OK successfull
    else HRESULT

--*/
{
    HRESULT hr = S_FALSE;
    BYTE g[100];
    LPVOID  pData = (LPVOID)g;
    
    WCHAR szw[MAX_PATH+1];
    _variant_t vTmp;

    if( nIndex >= 25 )
    {
        // The array is to big. We are cutting it short
        return E_INVALIDARG;
    }
    if( (vValue.vt & VT_ARRAY) )
    {
        // The variant contains an array. get the nIndex element from the array
        //
        hr = SafeArrayGetElement(vValue.parray,&nIndex,pData);

        if( S_OK == hr )
        {
            
            // Convert the extracted data into a string
            //
            switch( vValue.vt & ~VT_ARRAY )
            {
            case VT_BSTR:
                bstr = (BSTR)*((BSTR *)pData);
                return S_OK;

            case VT_I2:
                bstr = (short)*((short *)pData);
                return S_OK;

            case VT_I4:
                bstr = (long)*((LONG *)pData);
                return S_OK;

            case VT_UI1:
                bstr = (BYTE)*((BYTE *)pData);
                return S_OK;

            case VT_NULL:
                return S_FALSE;

            case VT_EMPTY:
                return S_FALSE;

            case VT_BOOL:
            {
                if( (VARIANT_BOOL *)pData )
                {
                    bstr = ids(IDS_TRUE);
                }
                else
                {
                    bstr = ids(IDS_FALSE);
                }
            }

            default:
                bstr = L"";
                return S_OK;
            }
        }
    }
    else
    {
        if( nIndex == 0)
        {
            //  The variant is not an array. In this case nIndex always needs to be 0
            //
            if( vValue.vt == VT_NULL || vValue.vt == VT_EMPTY)
            {
                // The variant is empty
                //
                bstr = L"";
                return S_FALSE;
            }
            else if( (vValue.vt == VT_EMPTY) || (vValue.vt == VT_BSTR && lstrlen(vValue.bstrVal) == 0) )
            {
                // The variant is empty
                //
                bstr = L"";
                return S_FALSE;
            }
            else if( vValue.vt == VT_BOOL )
            {
                if( vValue.boolVal )
                {
                    bstr = ids(IDS_TRUE);
                }
                else
                {
                    bstr = ids(IDS_FALSE);
                }
            }
            else
            {
                // The variant contains valid data. Convert the data into a bstring.
                //
                vTmp = vValue;
                vTmp.ChangeType(VT_BSTR);
                bstr = vTmp.bstrVal;
            }
            return S_OK;
        }
    }

    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\wmigateway.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    dglogswmi.cpp

Abstract:

    The file contains the methods for class CWmi. CWmi retrives information from WMI
    
--*/
#include "StdAfx.h"
#include "WmiGateway.h"
#include <wbemtime.h>
#include "util.h"

/*++

Routine Description
    The worker thread uses this function to check if the main thread has canceled the worker thread.
    i.e. the work thread should abort what ever it is doing, clean up and terminate.

Arguments
    none

Return Value
    TRUE the worker thread has been terminated
    FALSE the worker thread has not been terminated

--*/
inline BOOL CWmiGateway::ShouldTerminate()
{
    if( m_bTerminate )
    {
        return TRUE;
    }

    if (WaitForSingleObject(m_hTerminateThread, 0) == WAIT_OBJECT_0)
    {
        m_bTerminate = FALSE;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


CWmiGateway::CWmiGateway()
/*++

Routine Description
    Constructor, initializes member variables and creates the Wbem class object

Arguments
    none

Return Value
    none

--*/
{
    HRESULT hr = S_OK;
    m_wstrMachine = L".";
    m_pWbemLocater = NULL;
}

BOOL
CWmiGateway::WbemInitialize(INTERFACE_TYPE bInterface)
{
    HRESULT hr = E_FAIL;

    // Create the WMI object
    //
    hr = CoCreateInstance(CLSID_WbemLocator,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (void **)&m_pWbemLocater); 

    if( FAILED(hr) )
    {
        m_pWbemLocater = NULL;
        return FALSE;
    }

    return TRUE;
}

// Not currently used
VOID CWmiGateway::SetMachine(WCHAR *pszwMachine)
{
    EmptyCache();
    m_wstrMachine = pszwMachine;
}

//
// SetSecurity - set the Proxy Blanket on an IUnknown* interface so that it can be used by WMI 
//               cross-machine calls.
//
//               Okay for any of pwszDomainName, pwszUserName or pwszPassword to be NULL.
//
// deonb 12/20/2001
//
HRESULT WINAPI SetSecurity(IN OUT IUnknown* pUnk, IN USHORT* pwszDomainName, IN USHORT* pwszUserName, IN USHORT* pwszPassword)
{
    HRESULT hr = S_OK;

    COAUTHIDENTITY authident;
    authident.Domain = pwszDomainName;
    authident.DomainLength = pwszDomainName ? wcslen(pwszDomainName) : 0;
    authident.Password = pwszPassword;
    authident.PasswordLength = pwszPassword ? wcslen(pwszPassword) : 0;
    authident.User = pwszUserName;
    authident.UserLength = pwszUserName ? wcslen(pwszUserName) : 0;
    authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    
    hr = CoSetProxyBlanket(pUnk,
                           RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE,
                           NULL,
                           RPC_C_AUTHN_LEVEL_PKT,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           &authident,
                           EOAC_NONE);

    return hr;
}

IWbemServices *
CWmiGateway::GetWbemService(
        IN LPCTSTR pszwService
        )
/*++

Routine Description
    Connects to a Wbem Service (Repository i.e. root\default). The connection to the Wbem service
    is cached so if the Service is requested again, the service is retrived from the cache. When 
    the class is destroyed the connection to the cached Wbem services is released.

Arguments
    pszwService     Wbem Service to connect to. (i.e. root\default)

Return Value
    A pointer to the Wbem service connection. 
    If the connection fails, the method returns NULL

--*/
{
    WbemServiceCache::iterator iter;
    IWbemServices *pWbemServices = NULL;
    _bstr_t bstrService;
    HRESULT hr;

    if( !m_pWbemLocater )
    {
        // Wbem class object was not created.
        //
        return NULL;
    }
    
    // Check if the wbem service is cached.
    //
    iter = m_WbemServiceCache.find(pszwService);

    if( iter == m_WbemServiceCache.end() )
    {
        // We did not create and cache the wbem service yet, do it now
        //
        hr = m_pWbemLocater->ConnectServer(_bstr_t(pszwService),
                                           NULL,                    // User name 
                                           NULL,                    // user password
                                           NULL,NULL,NULL,NULL,
                                           &pWbemServices);
        if( SUCCEEDED(hr) )
        {
            //
            // Set the authentication information for the WbemService
            //
            hr = SetSecurity(pWbemServices, NULL, NULL,NULL);
            if( SUCCEEDED(hr) )
            {
                // Cache the newly created WbemService
                //
                m_WbemServiceCache[pszwService] = pWbemServices;                
                pWbemServices->Release();
                return m_WbemServiceCache[pszwService]; 
            }
            else
            {
                // Failed to set the proxy blankey on the service, release the wbem service
                //
                pWbemServices->Release();
                pWbemServices = NULL;
            }
        }
        
        return pWbemServices;

    }

    // We found the requested WbemService in our cache, return it
    //
    return iter->second;
}

IEnumWbemClassObject * 
CWmiGateway::GetEnumWbemClassObject(
        IN LPCTSTR pszwService,
        IN LPCTSTR pszwNameSpace
        )
/*++

Routine Description
    Creates an IEnumWbemClassObject. The IEnumWbemClassObject contains all of the instance
    of a class object. This pointer is not chached, since the instances are a snap shot
    of WMI at the time the object is created. So if we reuse the class object the data
    will be out-of-date. The caller must release the created IEnumWbemClassObject 
    (i.e. pEnumWbemClassObject->Release() );

Arguments
    pszwService     Wbem Service to connect to. (i.e. root\default)
    pszwNameSpace   Wbem Name space to connect to. (i.e. NetDiagnostics, Win32_NetworkAdapterConfiguration)

Return Value
    A pointer to the IEnumWbemClassObject. 
    If the the class object can not be created, the method reurns NULL

--*/
{
    IWbemServices *pWbemServices = NULL;
    IEnumWbemClassObject *pEnumWbemClassObject = NULL;

    // Get the requested WbemService
    //
    pWbemServices = GetWbemService(pszwService);

    if( pWbemServices )
    {
        // Create the EnumWbemClassObject. No need to check the 
        // return value. If this function fails pEnumWbemClassObject 
        // will be NULL
        //
        (void)pWbemServices->CreateInstanceEnum(_bstr_t(pszwNameSpace),
                                                0L,
                                                NULL,
                                                &pEnumWbemClassObject);
    }

    return pEnumWbemClassObject;
}

IWbemClassObject * 
CWmiGateway::GetWbemClassObject(
        LPCTSTR pszwService,
        LPCTSTR pszwNameSpace,
        const int nInstance)
/*++

Routine Description
    Creates an IWbemClassObject. The IWbemClassObject is an instance of the IEnumWbemClassObject
    This pointer is not chached, since the instance is a snap shot of WMI at the time the object 
    is created. So if we reuse the class object the data will be out-of-date. The caller must release 
    the IWbemClassObject (i.e. pWbemClassObject->Release() )

Arguments
    pszwService     Wbem Service to connect to. (i.e. root\default)
    pszwNameSpace   Wbem Name space to connect to. (i.e. NetDiagnostics, Win32_NetworkAdapterConfiguration)
    nInstance       The instance of IEnumWbemClassObject to retrive. Default is to grab the first instance (nInstance  0)

Return Value
    A pointer to the IWbemClassObject
    If the class object can not be created, the method returns NULL.

--*/
{
    IEnumWbemClassObject *pEnumWbemClassObject = NULL;
    IWbemClassObject *pWbemClassObject = NULL;
    ULONG uReturned;
    HRESULT hr;

    // Get the EnumWbemClass object (Contains all of the instances)
    //
    pEnumWbemClassObject = GetEnumWbemClassObject(pszwService,pszwNameSpace);

    if( pEnumWbemClassObject )
    {
        // Jump to the nth instance
        //
        hr = pEnumWbemClassObject->Skip(WBEM_INFINITE, nInstance);
        
        if( WBEM_S_NO_ERROR == hr )
        {
            // Get the nth classobject (i.e. instance). If this call fails pWbemClassObject is NULL
            // Next grabs the instances you skipped to.
            //
            hr = pEnumWbemClassObject->Next(WBEM_INFINITE,
                                            1,
                                            &pWbemClassObject,
                                            &uReturned);
        }

        // Release the IEnumWbemClassObject
        //
        pEnumWbemClassObject->Release();
    }

    return pWbemClassObject;
}

    
void CWmiGateway::ReleaseAll(IEnumWbemClassObject *pEnumWbemClassObject, IWbemClassObject *pWbemClassObject[], int nInstances)
{
    if( pWbemClassObject )
    {
        for(ULONG i = 0; i < nInstances; i++)
        {
            if( pWbemClassObject[i] )
            {
                pWbemClassObject[i]->Release();
                pWbemClassObject[i] = NULL;
            }
        }                                           
    }
    if( pEnumWbemClassObject )
    {
        pEnumWbemClassObject->Release();
    }
}

HRESULT 
CWmiGateway::GetWbemProperties(     
        IN OUT  EnumWbemProperty &EnumProp
        )
{
    
    HRESULT hr = S_OK;
    EnumWbemProperty::iterator iter, iter2;
    IWbemServices *pWbemServices = NULL;
    IEnumWbemClassObject *pEnumWbemClassObject = NULL;        
    IWbemClassObject *pWbemClassObject[30]; // = NULL;
    WCHAR pszwRepository[MAX_PATH + 1] = L""; 
    WCHAR pszwNamespace[MAX_PATH + 1 ] = L"";  
    ULONG   nInstances = 0;

    m_wstrWbemError = L"";

    for( iter = EnumProp.begin(); iter != EnumProp.end(); iter++)
    {
        if( iter->pszwRepository && lstrcmpi(iter->pszwRepository,pszwRepository) != 0 )
        {            
            if( pWbemServices )
            {
                pWbemServices->Release();
                pWbemServices = NULL;
            }

            lstrcpy(pszwRepository,iter->pszwRepository);
            lstrcpy(pszwNamespace, L"");
            pWbemServices = GetWbemService(pszwRepository);
            if( ShouldTerminate() ) goto End;
            if( !pWbemServices )
            {                
                if( !m_wstrWbemError.empty() )
                {
                    m_wstrWbemError += L";";
                }
                WCHAR wsz[MAX_PATH+1];
                _snwprintf(wsz,MAX_PATH,ids(IDS_FAILEDOPENWMIREP),pszwRepository);
                m_wstrWbemError += wsz;
            }
        }
        
        if( iter->pszwNamespace && lstrcmpi(pszwNamespace, iter->pszwNamespace)  != 0 )
        {
            lstrcpy(pszwNamespace, iter->pszwNamespace);

            if( pWbemServices )
            {

                ReleaseAll(pEnumWbemClassObject,pWbemClassObject,nInstances);
                pEnumWbemClassObject = NULL;
                hr = pWbemServices->CreateInstanceEnum(_bstr_t(pszwNamespace),
                                                       0L,
                                                       NULL,
                                                       &pEnumWbemClassObject);

                if( SUCCEEDED(hr) )
                {
                    // With WMI you can not get the number of instances in a class. So I am using a hard coded value of 30
                    // If there are more than 30 instance their will be a problem displaying all of them.
                    nInstances = 0;
                    hr = pEnumWbemClassObject->Next(WBEM_INFINITE,
                                                20,             // Get all of the instances
                                                pWbemClassObject,
                                                &nInstances);
                    if( ShouldTerminate() )  goto End;
                    if( SUCCEEDED(hr) )
                    {
                        for(ULONG i = 0; i< nInstances; i++)
                        {
                            (void)pWbemClassObject[i]->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
                        }
                    }
                }
                else
                {
                    if( !m_wstrWbemError.empty() )
                    {
                        m_wstrWbemError += L";";
                    }
                    WCHAR wsz[MAX_PATH+1];
                    _snwprintf(wsz,MAX_PATH,ids(IDS_FAILEDOPENWMINAMESPACE),pszwNamespace),
                    m_wstrWbemError += wsz;
                }

            }
        }

        if( pWbemClassObject && nInstances)
        {
            VARIANT vValue;

            VariantInit(&vValue);

            if( !iter->pszwName || lstrcmp(iter->pszwName,L"") == 0)
            {
                BSTR bstrFieldname;
                int nProperty = 0;
                CIMTYPE CimType;
                
                while( WBEM_S_NO_ERROR == pWbemClassObject[0]->Next(0,&bstrFieldname, NULL, &CimType, NULL) )
                {
                    if( ShouldTerminate() )  goto End;

                    if( lstrcmp((WCHAR *)bstrFieldname,L"OEMLogoBitmap")==0 ) continue;
                    // Do not get arrays they are to did handles i.e. bitmaps              

                    if( nProperty == 0 )
                    {
                        iter->SetProperty((WCHAR *)bstrFieldname,0);
                        iter2 = iter;
                        iter2++;
                    }
                    else
                    {
                        if( iter2 == EnumProp.end() )
                        {
                            EnumProp.push_back(WbemProperty((WCHAR *)bstrFieldname,0,NULL,NULL));
                            iter2 = EnumProp.end();
                        }
                        else
                        {                            
                            iter2 = EnumProp.insert(iter2,WbemProperty((WCHAR *)bstrFieldname,0,NULL,NULL));
                            iter2++;
                        }
                    }

                    SysFreeString(bstrFieldname);
                    nProperty++;
                }
            }

            for(ULONG i = 0; i < nInstances; i++)
            {        
                HRESULT hr;
                CIMTYPE vtType;
                hr = pWbemClassObject[i]->Get(iter->pszwName,0,&vValue,&vtType,NULL);
                if( ShouldTerminate() )  goto End;
                if( SUCCEEDED(hr) )
                {
                    if( vValue.vt != VT_NULL && vtType == CIM_DATETIME && vValue.bstrVal!=  NULL && lstrcmp((WCHAR *)vValue.bstrVal,L"")!=0 )
                    {
                        
                        WBEMTime wt(vValue.bstrVal);
                        
                        WCHAR szBuff[MAX_PATH+1];
                        WCHAR szwDateTime[MAX_PATH+1];
                        SYSTEMTIME SysTime;
                        if( wt.GetSYSTEMTIME(&SysTime) )
                        {
                            FILETIME FileTime, LocalFileTime;
                            SYSTEMTIME UTCTIme, LocalTime;
                            memcpy(&UTCTIme,&SysTime,sizeof(SYSTEMTIME));
                            SystemTimeToFileTime(&UTCTIme,&FileTime);
                            FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
                            FileTimeToSystemTime(&LocalFileTime, &LocalTime); 
                            memcpy(&SysTime,&LocalTime,sizeof(SYSTEMTIME));


                            lstrcpy(szwDateTime,L"");

                            if (0 != GetTimeFormat(LOCALE_USER_DEFAULT, //GetThreadLocale(), 
                                                   0, 
                                                   &SysTime, 
                                                   NULL,
                                                   szBuff, 
                                                   sizeof(szBuff)/sizeof(WCHAR)))
                            {                                
                                //vValue.bstrVal = szBuff;
                                lstrcpy(szwDateTime,szBuff);
                            } 

                            if (0 != GetDateFormat(LOCALE_USER_DEFAULT, //GetThreadLocale(), 
                                                   0, 
                                                   &SysTime, 
                                                   NULL,
                                                   szBuff, 
                                                   sizeof(szBuff)/sizeof(WCHAR)))
                            {
                                //vValue.bstrVal = szBuff;
                                _snwprintf(szwDateTime,MAX_PATH,L"%s %s",szwDateTime,szBuff);
                            } 
                            //SysFreeString(vValue.bstrVal);
                            VariantClear(&vValue);
                            vValue.bstrVal = SysAllocString((WCHAR *)szwDateTime);                            
                            vValue.vt = VT_BSTR;
                        }
                        
                        
                    }
                    /*
                        Security: Make sure that the variants in the stack are cleared when the stack is destroyed
                    */
                    iter->Value.push_back(vValue);
                    VariantClear(&vValue);
                }
            }
        }
    }


End:

    ReleaseAll(pEnumWbemClassObject,pWbemClassObject,nInstances);        
    pEnumWbemClassObject = NULL;
    return hr;
}



void CWmiGateway::EmptyCache()
{
    
    // Empty the WbemService cache
    //
    m_WbemServiceCache.erase(m_WbemServiceCache.begin(), 
                             m_WbemServiceCache.end());
    
}

// Netsh does not free its helpers if it is aborted or the user runs netsh with /?
// The Wbem object dissapears from under neath us. try and except do not work inside 
// of the destructor.
//
ReleaseWbemObject(IWbemLocator *p)
{
    /*
        Security: Need to check if we still need the try catch
    */
    __try
    {
        p->Release();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //DebugBreak();
    }

    return 0;
}
CWmiGateway::~CWmiGateway()
/*++

Routine Description
    Destructor, free all member variables and release the wbem connection

Arguments
    none

Return Value
    none

--*/
{    
    //DebugBreak();



    EmptyCache();

    if( m_pWbemLocater )
    {
        ReleaseWbemObject(m_pWbemLocater);
        m_pWbemLocater = NULL;       

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\api\acslan.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    acslan.c

Abstract:

    The module is the entry to the OS/2 ACSLAN emulation module.
    It uses the secure native NT DLC API to implement the full
    IBM OS/2 DLC compatible interface for Windows/NT.

    Contents:
        AcsLan
        NtAcsLan
        GetCcbStationId
        OpenDlcApiDriver
        GetAdapterNameAndParameters
        GetAdapterNameFromNumber
        GetAdapterNumberFromName
        DoSyncDeviceIoControl
        DlcGetInfo
        DlcSetInfo
        DlcCallDriver
        DllEntry
        QueueCommandCompletion

Author:

    Antti Saarenheimo (o-anttis) 06-JUN-1991

Revision History:

--*/

#include "dlcdll.h"
#include "dlcdebug.h"

#define DLC_UNSUPPORTED_COMMAND ((ULONG)0x7fffffff)
#define DLC_ASYNCHRONOUS_FLAG   ((ULONG)0x80000000)
#define IS_SYNCHRONOUS(command) (!(IoctlCodes[command] & DLC_ASYNCHRONOUS_FLAG))
#define DLC_IOCTL(command)      (IoctlCodes[command] & ~DLC_ASYNCHRONOUS_FLAG)
#define IS_TRANSMIT(command)    (((command) == LLC_TRANSMIT_DIR_FRAME) \
                                || ((command) == LLC_TRANSMIT_I_FRAME) \
                                || ((command) == LLC_TRANSMIT_UI_FRAME) \
                                || ((command) == LLC_TRANSMIT_XID_CMD) \
                                || ((command) == LLC_TRANSMIT_XID_RESP_FINAL) \
                                || ((command) == LLC_TRANSMIT_XID_RESP_NOT_FINAL) \
                                || ((command) == LLC_TRANSMIT_TEST_CMD))

#define DEFAULT_QUERY_BUFFER_LENGTH 1024    // 512 wide chars, approx. 32 bindings
#define DEFAULT_BINDING_LENGTH      64      // 32 wide chars, double typical

#ifdef GRAB_READ

typedef struct {
    PVOID List;
    PLLC_CCB pCcb;
    HANDLE OriginalEventHandle;
    HANDLE NewEventHandle;
} READ_GRABBER, *PREAD_GRABBER;

VOID ReadGrabber(VOID);
DWORD MungeReadGrabberHandles(VOID);
VOID AddReadGrabber(PREAD_GRABBER);
PREAD_GRABBER RemoveReadGrabber(HANDLE);

#endif

//
// private data
//

static USHORT aMinDirLogSize[3] = {
    sizeof(LLC_ADAPTER_LOG),
    sizeof(LLC_DIRECT_LOG),
    sizeof(LLC_ADAPTER_LOG) + sizeof(LLC_DIRECT_LOG)
};

CRITICAL_SECTION DriverHandlesCritSec;
HANDLE aDlcDriverHandles[LLC_MAX_ADAPTER_NUMBER];
IO_STATUS_BLOCK GlobalIoStatus;

//
// IoctlCodes - combines actual IOCTL code (giving device type, request vector,
// I/O buffer method and file access) and synchronous/asynchronous flag (high bit)
//

ULONG IoctlCodes[LLC_MAX_DLC_COMMAND] = {
    DLC_UNSUPPORTED_COMMAND,                            // 0x00 DIR.INTERRUPT
    DLC_UNSUPPORTED_COMMAND,                            // 0x01 DIR.MODIFY.OPEN.PARMS       CCB1 ONLY
    DLC_UNSUPPORTED_COMMAND,                            // 0x02 DIR.RESTORE.OPEN.PARMS      CCB1 ONLY
    IOCTL_DLC_OPEN_ADAPTER,                             // 0x03 DLC.OPEN.ADAPTER
    IOCTL_DLC_CLOSE_ADAPTER | DLC_ASYNCHRONOUS_FLAG,    // 0x04 DIR.CLOSE.ADAPTER
    IOCTL_DLC_SET_INFORMATION,                          // 0x05 DIR.SET.MULTICAST.ADDRESS
    IOCTL_DLC_SET_INFORMATION,                          // 0x06 DIR.SET.GROUP.ADDRESS
    IOCTL_DLC_SET_INFORMATION,                          // 0x07 DIR.SET.FUNCTIONAL.ADDRESS
    DLC_UNSUPPORTED_COMMAND,                            // 0x08 DIR.READ.LOG
    IOCTL_DLC_TRANSMIT2 | DLC_ASYNCHRONOUS_FLAG,        // 0x09 TRANSMIT.FRAMES
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0a TRANSMIT.DIR.FRAME
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0b TRANSMIT.I.FRAME
    DLC_UNSUPPORTED_COMMAND,                            // 0x0c no command
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0d TRANSMIT.UI.FRAME
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0e TRANSMIT.XID.CMD
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x0f TRANSMIT.XID.RESP.FINAL
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x10 TRANSMIT.XID.RESP.NOT.FINAL
    IOCTL_DLC_TRANSMIT | DLC_ASYNCHRONOUS_FLAG,         // 0x11 TRANSMIT.TEST.CMD
    IOCTL_DLC_QUERY_INFORMATION,                        // 0x12 no command
    IOCTL_DLC_SET_INFORMATION,                          // 0x13 no command
    IOCTL_DLC_RESET | DLC_ASYNCHRONOUS_FLAG,            // 0x14 DLC.RESET
    IOCTL_DLC_OPEN_SAP,                                 // 0x15 DLC.OPEN.SAP
    IOCTL_DLC_CLOSE_SAP | DLC_ASYNCHRONOUS_FLAG,        // 0x16 DLC.CLOSE.SAP
    IOCTL_DLC_REALLOCTE_STATION,                        // 0x17 DLC.REALLOCATE
    DLC_UNSUPPORTED_COMMAND,                            // 0x18 no command
    IOCTL_DLC_OPEN_STATION,                             // 0x19 DLC.OPEN.STATION
    IOCTL_DLC_CLOSE_STATION | DLC_ASYNCHRONOUS_FLAG,    // 0x1a DLC.CLOSE.STATION
    IOCTL_DLC_CONNECT_STATION | DLC_ASYNCHRONOUS_FLAG,  // 0x1b DLC.CONNECT.STATION
    DLC_UNSUPPORTED_COMMAND,                            // 0x1c DLC.MODIFY
    IOCTL_DLC_FLOW_CONTROL,                             // 0x1d DLC.FLOW.CONTROL
    DLC_UNSUPPORTED_COMMAND,                            // 0x1e DLC.STATISTICS
    IOCTL_DLC_FLOW_CONTROL,                             // 0x1f no command
    IOCTL_DLC_CLOSE_ADAPTER | DLC_ASYNCHRONOUS_FLAG,    // 0x20 DIR.INITIALIZE
    IOCTL_DLC_QUERY_INFORMATION,                        // 0x21 DIR.STATUS
    IOCTL_DLC_TIMER_SET | DLC_ASYNCHRONOUS_FLAG,        // 0x22 DIR.TIMER.SET
    IOCTL_DLC_TIMER_CANCEL,                             // 0x23 DIR.TIMER.CANCEL
    DLC_UNSUPPORTED_COMMAND,                            // 0x24 PDT.TRACE.ON                CCB1 ONLY
    DLC_UNSUPPORTED_COMMAND,                            // 0x25 PDT.TRACE.OFF               CCB1 ONLY
    IOCTL_DLC_BUFFER_GET,                               // 0x26 BUFFER.GET
    IOCTL_DLC_BUFFER_FREE,                              // 0x27 BUFFER.FREE
    IOCTL_DLC_RECEIVE | DLC_ASYNCHRONOUS_FLAG,          // 0x28 RECEIVE
    IOCTL_DLC_RECEIVE_CANCEL,                           // 0x29 RECEIVE.CANCEL
    DLC_UNSUPPORTED_COMMAND,                            // 0x2a RECEIVE.MODIFY
    DLC_UNSUPPORTED_COMMAND,                            // 0x2b DIR.DEFINE.MIF.ENVIRONMENT  CCB1 ONLY
    IOCTL_DLC_TIMER_CANCEL_GROUP,                       // 0x2c DIR.TIMER.CANCEL.GROUP
    IOCTL_DLC_SET_EXCEPTION_FLAGS,                      // 0x2d DIR.SET.EXCEPTION.FLAGS
    DLC_UNSUPPORTED_COMMAND,                            // 0x2e no command
    DLC_UNSUPPORTED_COMMAND,                            // 0x2f no command
    IOCTL_DLC_BUFFER_CREATE,                            // 0x30 BUFFER.CREATE
    IOCTL_DLC_READ | DLC_ASYNCHRONOUS_FLAG,             // 0x31 READ
    IOCTL_DLC_READ_CANCEL,                              // 0x32 READ.CANCEL
    DLC_UNSUPPORTED_COMMAND,                            // 0x33 DLC.SET.THRESHOLD
    IOCTL_DLC_CLOSE_DIRECT | DLC_ASYNCHRONOUS_FLAG,     // 0x34 DIR.CLOSE.DIRECT
    IOCTL_DLC_OPEN_DIRECT,                              // 0x35 DIR.OPEN.DIRECT
    DLC_UNSUPPORTED_COMMAND                             // 0x36 PURGE.RESOURCES
};

CRITICAL_SECTION AdapterOpenSection;


//
// macros
//

//
// The next procedure has been implemented as macro, because it is on
// the critical path (used by BufferFree and all old transmit commands)
//

#ifdef DLCAPI_DBG

VOID
CopyToDescriptorBuffer(
    IN OUT PLLC_TRANSMIT_DESCRIPTOR pDescriptors,
    IN PLLC_XMIT_BUFFER pDlcBufferQueue,
    IN BOOLEAN DeallocateBufferAfterUse,
    IN OUT PUINT pIndex,
    IN OUT PLLC_XMIT_BUFFER *ppBuffer,
    IN OUT PUINT pDlcStatus
    )

/*++

Routine Description:

    Function translates the link list of DLC buffers to a NT DLC descriptor
    array to be used as the input parameter for dlc device driver.
    (NT driver may have only one input buffer => we cannot use any link
     list structures to give parameters to a NT dlc driver).

Arguments:

    pDescriptors - NT DLC descriptor array

    pDlcBufferQueue - pointer to a link list of DLC buffers

    DeallocateBufferAfterUse - the flag is set, if the dlc buffers
        are released back to buffer pool when the frame is sent or
        if this routine is called by buffer free.

    pIndex - current index of the descriptor array

    ppLastBuffer - pointer to the next buffer, if the maximum size of
        the current descriptor table in stack is exceeded.  This feature
        is used, if the number buffers in free list given to BufferFree
        is bigger that the maximum number of slots in the descriptor
        array (allocated from stack).
        It's an error, if this parameter has non null value, when we
        returne back to the transmit command.


Return Value:

    LLC_STATUS_TRANSMIT_ERROR - there are too many transmit buffers
        (over 128) for the static descriptor buffer, that is allocated
        from the stack.

--*/

{
    *ppBuffer = pDlcBufferQueue;
    *pDlcStatus = LLC_STATUS_SUCCESS;

    while (*ppBuffer != NULL) {

        //
        // Check the overflow of the internal xmit buffer in stack and
        // the loop counter, that prevents the forever loop of zero length
        // transmit buffer (the buffer chain might be circular)
        //

        if (*pIndex >= MAX_TRANSMIT_SEGMENTS) {
            *pDlcStatus = LLC_STATUS_TRANSMIT_ERROR;
            break;
        }

        //
        // Buffer free may free buffers having 0 data bytes (just the
        // lan and LLC headers).
        //

        pDescriptors[*pIndex].pBuffer = &(*ppBuffer)->auchData[(*ppBuffer)->cbUserData];
        pDescriptors[*pIndex].cbBuffer = (*ppBuffer)->cbBuffer;
        pDescriptors[*pIndex].eSegmentType = LLC_NEXT_DATA_SEGMENT;
        pDescriptors[*pIndex].boolFreeBuffer = DeallocateBufferAfterUse;

        //
        // We will reset all next pointers of the released buffers
        // to break loops in the buffer chain of BufferFree
        // request.  BufferFree would loop for ever with a circular
        // buffer link list.
        //

        if (DeallocateBufferAfterUse) {

            PLLC_XMIT_BUFFER    pTempNext;

            pTempNext = (*ppBuffer)->pNext;
            (*ppBuffer)->pNext = NULL;
            *ppBuffer = pTempNext;
        } else {
            *ppBuffer = (*ppBuffer)->pNext;
        }
        *pIndex++;
    }
}

#else

#define CopyToDescriptorBuffer(pDescriptors,                                                \
                               pDlcBufferQueue,                                             \
                               DeallocateBufferAfterUse,                                    \
                               pIndex,                                                      \
                               ppBuffer,                                                    \
                               pDlcStatus                                                   \
                               )                                                            \
{                                                                                           \
    (*ppBuffer) = pDlcBufferQueue;                                                          \
    (*pDlcStatus) = LLC_STATUS_SUCCESS;                                                     \
                                                                                            \
    while ((*ppBuffer) != NULL) {                                                           \
                                                                                            \
        if (*pIndex >= MAX_TRANSMIT_SEGMENTS) {                                             \
            (*pDlcStatus) = LLC_STATUS_TRANSMIT_ERROR;                                      \
            break;                                                                          \
        }                                                                                   \
                                                                                            \
        pDescriptors[*pIndex].pBuffer = &((*ppBuffer)->auchData[(*ppBuffer)->cbUserData]);  \
        pDescriptors[*pIndex].cbBuffer = (*ppBuffer)->cbBuffer;                             \
        pDescriptors[*pIndex].eSegmentType = LLC_NEXT_DATA_SEGMENT;                         \
        pDescriptors[*pIndex].boolFreeBuffer = DeallocateBufferAfterUse;                    \
                                                                                            \
        if (DeallocateBufferAfterUse) {                                                     \
                                                                                            \
            PLLC_XMIT_BUFFER pTempNext;                                                     \
                                                                                            \
            pTempNext = (*ppBuffer)->pNext;                                                 \
            (*ppBuffer)->pNext = NULL;                                                      \
            (*ppBuffer) = pTempNext;                                                        \
        } else {                                                                            \
            (*ppBuffer) = (*ppBuffer)->pNext;                                               \
        }                                                                                   \
        (*pIndex)++;                                                                        \
    }                                                                                       \
}

#endif

//
// functions
//


ACSLAN_STATUS
AcsLan(
    IN OUT PLLC_CCB pCCB,
    OUT PLLC_CCB* ppBadCcb
    )

/*++

Routine Description:

    Native NT DLC API (ACSLAN) entry point.  Called from Win32 applications

Arguments:

    pCCB        - pointer to CCB (CCB2 = OS/2 DLC Command Control Block)
    ppBadCcb    - returned pointer to failing CCB

Return Value:

    ACSLAN_STATUS
        Success - ACSLAN_STATUS_COMMAND_ACCEPTED
                    Successfully accepted or completed CCB

        Failure - ACSLAN_STATUS_INVALID_CCB_POINTER
                    Next CCB pointer field is invalid

                  ACSLAN_STATUS_CCB_IN_ERROR
                    Error code returned in only/first CCB

                  ACSLAN_STATUS_CHAINED_CCB_IN_ERROR
                    Error code returned in a chained CCB

                  ACSLAN_STATUS_SYSTEM_STATUS
                    Unexpected system error, check the system status field

                  ACSLAN_STATUS_INVALID_COMMAND
                    The first CCB pointer or bad CCB pointer was invalid

--*/

{

    UINT AcslanStatus;
    UINT Status;
    PLLC_CCB pFirstCcb = pCCB;

    IF_DEBUG(DUMP_ACSLAN) {
        IF_DEBUG(DUMP_INPUT_CCB) {
            DUMPCCB(pCCB, TRUE, TRUE);
        }
    }

    try {

        if (pCCB->uchDlcCommand >= LLC_MAX_DLC_COMMAND) {

            pCCB->uchDlcStatus = LLC_STATUS_INVALID_COMMAND;
            AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;

        } else if (pCCB->pNext == NULL) {

            //
            // 99.9% of all DLC commands are not chained. We execute
            // them as a special case to avoid the wasting of the CPU
            // cycles with that CCB chaining stuff
            //

            //
            // DOS DLC needs three different CCB pointers.
            // In Windows/Nt there is only one.
            // We cannot complete the synchronous commands
            // by the io-system, because another thread waiting
            // for the event to complete might be signalled before
            // the status and the output parameters have been set
            // in the CCB and its parameter table
            //

            AcslanStatus = ACSLAN_STATUS_COMMAND_ACCEPTED;

            if (IS_SYNCHRONOUS(pCCB->uchDlcCommand)) {

                //
                // synchronous command: let the driver do the work then set
                // the status field in the output CCB to the value returned
                // by the driver
                //

                Status = NtAcsLan(pCCB, pCCB, pCCB, NULL);
                pCCB->uchDlcStatus = (UCHAR)Status;
                if (Status != LLC_STATUS_SUCCESS) {
                    AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;

                    //
                    // RLF 05/18/93
                    //
                    // If NtAcsLan returns the CCB.NEXT field pointing at the CCB,
                    // set it to NULL
                    //

                    if (pCCB->pNext == pCCB) {
                        pCCB->pNext = NULL;
                    }

                }

                //
                // here we handle asyncronous completion of the synchronous
                // commands by using the READ command
                //
                // RLF 04/23/93 Bogus: This should be handled in the driver
                //

                if (pCCB->ulCompletionFlag != 0) {
                    QueueCommandCompletion(pCCB);
                }

                //
                // Signal the event when everything has been done
                //

                if (pCCB->hCompletionEvent != NULL) {
                    SetEvent(pCCB->hCompletionEvent);
                }
            } else {

                //
                // The command completion field is used as special
                // input parameter for the chained READ commands
                //

                if (pCCB->uchDlcCommand == LLC_READ) {
                    ((PNT_DLC_READ_INPUT)pCCB->u.pParameterTable)->CommandCompletionCcbLink = NULL;
                }

                //
                // The asynchronous commands always returns a pending status
                // (we cannot touch the CCB status field because it may be
                // simultaneously accessed by another processor in MP systems)
                //

                Status = NtAcsLan(pCCB, pCCB, pCCB, pCCB->hCompletionEvent);
                if ((Status != LLC_STATUS_PENDING) && (Status != LLC_STATUS_SUCCESS)) {

//printf("ACSLAN: Async Command %#x Retcode %#x\n", pCCB->uchDlcCommand, pCCB->uchDlcStatus);

                    //
                    // Only return immediate error status on asynchronous
                    // commands if this is a transmit
                    //

                    if (IS_TRANSMIT(pCCB->uchDlcCommand)) {
                        AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
                    } else if (pCCB->hCompletionEvent) {
                        SetEvent(pCCB->hCompletionEvent);
                    }
                }
            }
        } else {

            //
            // here if there is a chain of CCBs
            //

            PLLC_CCB pNextCCB;
            INT CcbCount;

            //
            // An evil app may have linked the CCBs in a circular list (it
            // happens very easily when the same transmit commands are reused
            // before they have been read from the command completion list.
            // We prevent looping forever by checking the number of linked CCBs
            // beforehand. (We will save the current command count, because the
            // CCB chain may also be corrupted during its execution)
            //

            pNextCCB = pCCB->pNext;

            //
            // note: 10240 is an arbitrary number. Any reasonably large number
            // will do, this is too large, but we'll stick with it for now
            //

            for (CcbCount = 1; pNextCCB != NULL && CcbCount < 10240; CcbCount++) {
                pNextCCB = pNextCCB->pNext;
            }
            if (CcbCount == 10240) {

                //
                // Too many commands, the CCB list must be circular
                //

                AcslanStatus = ACSLAN_STATUS_INVALID_CCB_POINTER;
            } else {

                //
                // Several CCBs may be chained together. Loop until end of
                // the list or the next CCB is a special READ CCB bound to
                // the current command
                //

                do {

                    //
                    // Set the default ACSLAN error status returned in case the
                    // given CCB pointer is invalid
                    //

                    AcslanStatus = ACSLAN_STATUS_INVALID_COMMAND;

                    //
                    // Reset the command completion link by default. We will set
                    // it if we find a READ command linked to the previous command
                    //

                    if (pCCB->uchDlcCommand == LLC_READ) {
                        ((PNT_DLC_READ_INPUT)pCCB->u.pParameterTable)->CommandCompletionCcbLink = NULL;
                    } else if (pCCB->uchDlcCommand >= LLC_MAX_DLC_COMMAND) {
                        AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
                        pCCB->uchDlcStatus = LLC_STATUS_INVALID_COMMAND;
                        break;
                    }

                    //
                    // Check if there is a READ command linked to the CCB
                    // pointer of this command to be used for the command
                    // completion
                    //

                    pNextCCB = pCCB->pNext;
                    if (pNextCCB != NULL) {
                        AcslanStatus = ACSLAN_STATUS_INVALID_CCB_POINTER;
                        if (pNextCCB->uchAdapterNumber != pCCB->uchAdapterNumber) {
                            pCCB->uchDlcStatus = LLC_STATUS_CHAINED_DIFFERENT_ADAPTERS;
                            break;
                        } else {
                            if (pCCB->uchReadFlag && pCCB->ulCompletionFlag
                            && pNextCCB->uchDlcCommand == LLC_READ) {

                                //
                                // Swap the actual CCB and its read command in
                                // the linked list of sequential CCBs.
                                // Note: the chain may continue after READ
                                //

                                pNextCCB = pCCB;
                                pCCB = pCCB->pNext;
                                pNextCCB->pNext = pCCB->pNext;
                                pCCB->pNext = pNextCCB;
                                ((PNT_DLC_READ_INPUT)pCCB->u.pParameterTable)->CommandCompletionCcbLink = pNextCCB;
                            }
                        }
                    }

                    //
                    // CCB is now safe, any exceptions returned by NtAcsLan
                    // indicate an invalid (parameter) pointer within CCB
                    //

                    AcslanStatus = ACSLAN_STATUS_COMMAND_ACCEPTED;

                    //
                    // DOS DLC needs three different CCB pointers.
                    // In Windows/Nt there is only one.
                    // We cannot complete the synchronous commands
                    // by the io-system, because another thread waiting for
                    // the event to complete might be signalled before
                    // the status and the output parameters have been set
                    // in the CCB and its parameter table
                    //

                    Status = NtAcsLan(pCCB,
                                      pCCB,
                                      pCCB,
                                      IS_SYNCHRONOUS(pCCB->uchDlcCommand)
                                        ? NULL
                                        : pCCB->hCompletionEvent
                                      );
                    if (Status != LLC_STATUS_PENDING) {
                        pCCB->uchDlcStatus = (UCHAR)Status;
                    }

                    //
                    // We must stop the command execution of all commands, when we
                    // hit the first error (the next commands would assume that
                    // this command succeeded)
                    //

                    if (pCCB->uchDlcStatus != LLC_STATUS_PENDING) {

                        //
                        // here, we handle the asyncronous command completion
                        // of the synchronous commands by using the READ
                        //

                        if (IS_SYNCHRONOUS(pCCB->uchDlcCommand)) {

                            //
                            // RLF 04/23/93 Bogus: This should be handled in the driver
                            //

                            if (pCCB->ulCompletionFlag != 0) {
                                QueueCommandCompletion(pCCB);
                            }

                            //
                            // Signal the event when everything has been done
                            //

                            if (pCCB->hCompletionEvent != NULL) {
                                SetEvent(pCCB->hCompletionEvent);
                            }
                        }
                        if (pCCB->uchDlcStatus != LLC_STATUS_SUCCESS) {
                            AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
                            break;
                        }
                    }
                    pCCB = pNextCCB;
                    CcbCount--;
                } while (pCCB != NULL && CcbCount > 0);

                //
                // Check if the CCB list was corrupted during its use. There
                // must be the same number of linked CCBs as in the beginning
                //

                if (pCCB != NULL && CcbCount == 0) {
                    AcslanStatus = ACSLAN_STATUS_INVALID_CCB_POINTER;
                } else if (AcslanStatus != ACSLAN_STATUS_COMMAND_ACCEPTED) {
                    if (pCCB != pFirstCcb) {
                        *ppBadCcb = pCCB;
                        AcslanStatus = ACSLAN_STATUS_CHAINED_CCB_IN_ERROR;
                    } else {
                        AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
                    }
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // There was a bad pointer in the parameter table if the exception
        // occurred in NtAcsLan! If we have a chain of CCBs then we have to
        // return which was is bad, else just notify the caller that their
        // data is unacceptable
        //

        if (AcslanStatus == ACSLAN_STATUS_COMMAND_ACCEPTED) {
            pCCB->uchDlcStatus = LLC_STATUS_INVALID_PARAMETER_TABLE;
            if (pCCB != pFirstCcb) {
                *ppBadCcb = pCCB;
                AcslanStatus = ACSLAN_STATUS_CHAINED_CCB_IN_ERROR;
            } else {
                AcslanStatus = ACSLAN_STATUS_CCB_IN_ERROR;
            }
        }
    }

    IF_DEBUG(DUMP_ACSLAN) {
        IF_DEBUG(DUMP_OUTPUT_CCB) {
            DUMPCCB(pCCB, TRUE, FALSE);
        }
        IF_DEBUG(RETURN_CODE) {
            PUT(("AcsLan: returning %d [0x%x]\n", AcslanStatus, AcslanStatus));
        }
    }

    return AcslanStatus;
}


LLC_STATUS
NtAcsLan(
    IN PLLC_CCB pCCB,
    IN PVOID pOriginalCcbAddress,
    OUT PLLC_CCB pOutputCcb,
    IN HANDLE EventHandle OPTIONAL
    )

/*++

Routine Description:

    Extended ACSLAN entrypoint used by the native NT DLC API and DOS (and
    OS/2) DLC subsystem emulators.

    This procedure can use the smaller original DOS CCBs. All unknown
    DOS CCB parameter fields are optional parameters on the stack

Arguments:

    pCCB                - OS/2 DLC Command control block.
                          This must be double word aligned

    pOriginalCcbAddress - the original (possibly virtual DOS) CCB address.
                          This pointer cannot be used in Windows/Nt address
                          space.

    pOutputCcb          - the original CCB (32bit) pointer where the status and
                          next CCB fields are updated.
                          Might not be double word aligned.

    EventHandle         - NT event object handle

Return Value:

    LLC_STATUS - See the DLC API return values.

--*/

{
    NT_DLC_PARMS NtDlcParms;
    PNT_DLC_PARMS pNtParms;
    PLLC_PARMS pDlcParms;
    PVOID pOutputBuffer;
    UINT OutputBufferLength;
    PVOID pInputBuffer;
    UINT InputBufferSize;
    ULONG IoctlCommand;
    UINT DlcStatus;
    HANDLE DriverHandle;
    NTSTATUS NtStatus;
    UINT InfoClass;
    UINT cElement;
    UCHAR FrameType;
    UCHAR AdapterNumber;
    PUCHAR pBuffer;
    UINT CopyLength;
    UINT cbLogBuffer;
    PLLC_XMIT_BUFFER pFirstBuffer;

    IF_DEBUG(DUMP_NTACSLAN) {
        IF_DEBUG(DUMP_INPUT_CCB) {
            DUMPCCB(pCCB, TRUE, TRUE);
        }
    }

    //
    // Setup first the default values for this CCB
    //

    pCCB->uchDlcStatus = (UCHAR)LLC_STATUS_PENDING;
    pCCB->pNext = pOriginalCcbAddress;
    pDlcParms = pCCB->u.pParameterTable;

    //
    // Discard immediately any commands for closed adapters,
    // except adapter open and initialize
    //

    AdapterNumber = pCCB->uchAdapterNumber;
    EnterCriticalSection(&DriverHandlesCritSec);
    DriverHandle = aDlcDriverHandles[AdapterNumber];
    LeaveCriticalSection(&DriverHandlesCritSec);
    if (DriverHandle == NULL) {

        //
        // OS/2 DLC applications may issue DIR_INITIALIZE_ADAPTER before
        // DIR_OPEN_ADAPTER. In that case it is simply a NOP
        //

        if (pCCB->uchDlcCommand != LLC_DIR_OPEN_ADAPTER
        && pCCB->uchDlcCommand != LLC_DIR_INITIALIZE) {

            pCCB->uchDlcStatus = LLC_STATUS_ADAPTER_CLOSED;

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n",
                        pCCB->uchDlcStatus,
                        pCCB->uchDlcStatus
                        ));
                }
            }

            return pCCB->uchDlcStatus;
        }
    }

    //
    // Set the default input and output buffers and their sizes
    //

    IoctlCommand = DLC_IOCTL(pCCB->uchDlcCommand);
    if (IoctlCommand != DLC_UNSUPPORTED_COMMAND) {

        InputBufferSize = aDlcIoBuffers[((USHORT)IoctlCommand) >> 2].InputBufferSize;
        OutputBufferLength = aDlcIoBuffers[((USHORT)IoctlCommand) >> 2].OutputBufferSize;

        //
        // Set the default input and output buffers.
        //

        if (OutputBufferLength != 0) {
            pOutputBuffer = pOutputCcb;
        } else {
            pOutputBuffer = NULL;
        }
    } else {
        OutputBufferLength = 0;
        pOutputBuffer = NULL;
    }
    pInputBuffer = (PVOID)&NtDlcParms;

    switch (pCCB->uchDlcCommand) {
    case LLC_BUFFER_FREE:

        //
        // Copy the link list headers to the descriptor array
        // and build NT CCB.  Application may want to
        // free more buffers at the time then allowed by
        // by the maximum descriptor buffer size =>
        // we must loop until the whole buffer list has been released
        //

        pFirstBuffer = pDlcParms->BufferFree.pFirstBuffer;

        for ( pFirstBuffer = pDlcParms->BufferFree.pFirstBuffer,
                DlcStatus = LLC_STATUS_SUCCESS ;
              pFirstBuffer != NULL ; ) {

            cElement = 0;

            //
            // We don't need to care about errors in the buffer chain,
            // because the procedure automatically breaks all loops
            // in the buffer chain
            //

            CopyToDescriptorBuffer(NtDlcParms.BufferFree.DlcBuffer,
                                   pFirstBuffer,
                                   TRUE,    // DEALLOCATE_AFTER_USE
                                   &cElement,
                                   &pFirstBuffer,
                                   &DlcStatus
                                   );
            NtDlcParms.BufferFree.BufferCount = (USHORT)cElement;
            InputBufferSize = sizeof(LLC_TRANSMIT_DESCRIPTOR) * cElement
                            + sizeof(NT_DLC_BUFFER_FREE_PARMS)
                            - sizeof(LLC_TRANSMIT_DESCRIPTOR);

            DlcStatus = DoSyncDeviceIoControl(DriverHandle,
                                              IoctlCommand,
                                              &NtDlcParms,
                                              InputBufferSize,
                                              pDlcParms,
                                              OutputBufferLength
                                              );
        }

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DIR_INITIALIZE:

        //
        // DIR.INITIALIZE is actually adapter close + hardware reset, but we
        // must return OK status if the adapter is not opened. Apps should
        // not reset the adapter without a good reason because it terminates
        // all other network communication for a while, and may disconnect
        // the sessions
        //

        RtlZeroMemory(pDlcParms, sizeof(LLC_DIR_INITIALIZE_PARMS));
        if (DriverHandle == NULL) {
            pCCB->uchDlcStatus = LLC_STATUS_SUCCESS;

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n",
                        pCCB->uchDlcStatus,
                        pCCB->uchDlcStatus
                        ));
                }
            }

            return pCCB->uchDlcStatus;
        }

    case LLC_DIR_CLOSE_ADAPTER:

        //
        // protect the close with the open critical section. We do this because
        // we need to protect the driver against simultaneous closes on the same
        // handle from multiple threads within the same process. The driver needs
        // to be fixed ultimately
        //

        EnterCriticalSection(&AdapterOpenSection);

        NtStatus = NtDeviceIoControlFile(DriverHandle,
                                         EventHandle,   // Event signaled when cmd compleletes
                                         NULL,
                                         NULL,
                                         &GlobalIoStatus,
                                         IOCTL_DLC_CLOSE_ADAPTER,
                                         pCCB,
                                         InputBufferSize,
                                         pOutputCcb,
                                         OutputBufferLength
                                         );
        if (NT_SUCCESS(NtStatus)) {

            if ((NtStatus != STATUS_PENDING) && (pOutputCcb->uchDlcStatus == LLC_STATUS_PENDING)) {

//printf("ACSLAN: Success: DirCloseAdapter: DD returns %#x. Retcode=%#x\n",
//        NtStatus, pOutputCcb->uchDlcStatus);

                pOutputCcb->uchDlcStatus = (UCHAR)NtStatus;

//printf("ACSLAN: Success: DirCloseAdapter: DD returns %#x. Retcode=%#x\n",
//        NtStatus, pOutputCcb->uchDlcStatus);

            }

            //
            // it is safe to enter the handle array critical section whilst we
            // are still holding the open critical section - this is the only
            // code path that grabs both
            //

            EnterCriticalSection(&DriverHandlesCritSec);
            aDlcDriverHandles[AdapterNumber] = NULL;
            LeaveCriticalSection(&DriverHandlesCritSec);

            //
            // if the DirCloseAdapter IOCTL returns STATUS_PENDING, NtClose
            // will block in the io-system until the close adapter IOCTL completes
            //

            NtClose(DriverHandle);
        } else {

//            printf("ACSLAN: Failure: DirCloseAdapter: DD returns %#x. Retcode=%#x\n",
//                    NtStatus, pOutputCcb->uchDlcStatus);

            //
            // RLF 04/21/94
            //
            // If we picked up a handle that has been subsequently closed by
            // another thread, Io will return STATUS_INVALID_HANDLE. In this
            // case, change the status code to LLC_STATUS_ADAPTER_CLOSED
            //

            if (NtStatus == STATUS_INVALID_HANDLE) {
                pOutputCcb->uchDlcStatus = LLC_STATUS_ADAPTER_CLOSED;
            }
        }

        LeaveCriticalSection(&AdapterOpenSection);

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n",
                    pCCB->uchDlcStatus,
                    pCCB->uchDlcStatus
                    ));
            }
        }

        return pCCB->uchDlcStatus;

    case LLC_DIR_CLOSE_DIRECT:
        pCCB->u.dlc.usStationId = 0;

        //
        // fall through
        //

    case LLC_DLC_CLOSE_STATION:
    case LLC_DLC_CLOSE_SAP:
    case LLC_DLC_RESET:
        pInputBuffer = pCCB;
        break;

    case LLC_DIR_INTERRUPT:

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n",
                    LLC_STATUS_SUCCESS,
                    LLC_STATUS_SUCCESS
                    ));
            }
        }

        return LLC_STATUS_SUCCESS;


//
// define a few macros to make DIR.OPEN.ADAPTER code easier to read
//

//
// IO_PARMS - specifies DirOpenAdapter structure in NT_DLC_PARMS union for input
// to DLC device driver
//
#define IO_PARMS NtDlcParms.DirOpenAdapter

//
// OA_PARMS - specifies pointer to DIR.OPEN.ADAPTER parameter table which contains
// pointers to 4 other parameter tables
//
#define OA_PARMS pDlcParms->DirOpenAdapter

//
// EX_PARMS - specifies pointer to LLC_EXTENDED_ADAPTER_PARMS parameter table
//
#define EX_PARMS pDlcParms->DirOpenAdapter.pExtendedParms

//
// DLC_PARMS - specifies pointer to LLC_DLC_PARMS parameter table
//
#define DLC_PARMS pDlcParms->DirOpenAdapter.pDlcParms

    case LLC_DIR_OPEN_ADAPTER:

        //
        // We can only open one adapter at a time. It is very hard to completely
        // synchronize this in the driver
        //

        EnterCriticalSection(&AdapterOpenSection);

        if (DriverHandle != NULL) {
            DlcStatus = LLC_STATUS_ADAPTER_OPEN;
        } else {
            DlcStatus = OpenDlcApiDriver(EX_PARMS->pSecurityDescriptor, &DriverHandle);
        }
        if (DlcStatus == LLC_STATUS_SUCCESS) {

            //
            // We read the output to the original OS/2 CCB buffer,
            // but it is too small for the complete NDIS adapter
            // name => we will copy all input parameters to the NT CCB
            //

            pOutputBuffer = OA_PARMS.pAdapterParms;

            //
            // copy any input adapter parameters from the caller's
            // LLC_ADAPTER_OPEN_PARMS to the device driver input buffer
            //

            RtlMoveMemory(&IO_PARMS.Adapter,
                          OA_PARMS.pAdapterParms,
                          sizeof(IO_PARMS.Adapter)
                          );
            IO_PARMS.AdapterNumber = AdapterNumber;

            //
            // WE MUST CREATE NEW FIELD TO DEFINE, IF APPLICATION WANT
            // TO USE DIX or 802.3 ethernet frames under 802.2
            // (unnecessary feature, config parameter would be enough)
            //

            IO_PARMS.NtDlcIoctlVersion = NT_DLC_IOCTL_VERSION;
            IO_PARMS.pSecurityDescriptor = EX_PARMS->pSecurityDescriptor;
            IO_PARMS.hBufferPoolHandle = EX_PARMS->hBufferPool;
            IO_PARMS.LlcEthernetType = EX_PARMS->LlcEthernetType;
            IO_PARMS.NdisDeviceName.Buffer = (WCHAR *)IO_PARMS.Buffer;
            IO_PARMS.NdisDeviceName.MaximumLength = sizeof(IO_PARMS.Buffer);

            //
            // get the configuration info from the registry
            //

            DlcStatus = GetAdapterNameAndParameters(
                            AdapterNumber % LLC_MAX_ADAPTERS,
                            &IO_PARMS.NdisDeviceName,
                            (PUCHAR)&IO_PARMS.LlcTicks,
                            &IO_PARMS.LlcEthernetType
                            );
            if (DlcStatus == LLC_STATUS_SUCCESS) {

                //
                // copy the name buffer into the IO buffer and free the former
                //

                RtlMoveMemory(&IO_PARMS.Buffer,
                              IO_PARMS.NdisDeviceName.Buffer,
                              IO_PARMS.NdisDeviceName.Length
                              );

                //
                // ensure the name is actually zero-terminated for the call to
                // RtlInitUnicodeString
                //

                IO_PARMS.Buffer[IO_PARMS.NdisDeviceName.Length/sizeof(WCHAR)] = 0;

                //
                // finished with UNICODE_STRING allocated in GetAdapterName...
                //

                RtlFreeUnicodeString(&IO_PARMS.NdisDeviceName);

                //
                // fill the UNICODE_STRING back in to point at our buffer
                //

                RtlInitUnicodeString(&IO_PARMS.NdisDeviceName, IO_PARMS.Buffer);

                //
                // now perform the actual open of the adapter for this process
                //

                DlcStatus = DoSyncDeviceIoControl(
                                DriverHandle,
                                IOCTL_DLC_OPEN_ADAPTER,
                                &NtDlcParms,
                                sizeof(NT_DIR_OPEN_ADAPTER_PARMS),
                                pOutputBuffer,
                                sizeof(LLC_ADAPTER_OPEN_PARMS)
                                );
            }
            if (DlcStatus == LLC_STATUS_SUCCESS) {

                //
                // get the timer tick values from the driver for this adapter
                //

                DlcStatus = DlcGetInfo(DriverHandle,
                                       DLC_INFO_CLASS_DLC_TIMERS,
                                       0,
                                       &DLC_PARMS->uchT1_TickOne,
                                       sizeof(LLC_TICKS)
                                       );

                //
                // set the returned maxima to the default maxima as per the
                // IBM LAN Tech. Ref.
                //

                DLC_PARMS->uchDlcMaxSaps = 127;
                DLC_PARMS->uchDlcMaxStations = 255;
                DLC_PARMS->uchDlcMaxGroupSaps = 126;
                DLC_PARMS->uchDlcMaxGroupMembers = 127;

                //
                // this adapter is now successfully opened for this process
                //

                EnterCriticalSection(&DriverHandlesCritSec);
                aDlcDriverHandles[AdapterNumber] = DriverHandle;
                LeaveCriticalSection(&DriverHandlesCritSec);
            }
        }
        LeaveCriticalSection(&AdapterOpenSection);

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_OUTPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

#undef IO_PARMS
#undef PO_PARMS
#undef EX_PARMS
#undef DLC_PARMS


    case LLC_BUFFER_CREATE:
    case LLC_BUFFER_GET:
    case LLC_DIR_OPEN_DIRECT:
    case LLC_DIR_SET_EXCEPTION_FLAGS:
    case LLC_DLC_REALLOCATE_STATIONS:

        //
        //  We can use the standard OS/2 CCB for input and output!
        //

        pOutputBuffer = pDlcParms;
        pInputBuffer = pDlcParms;
        break;

    case LLC_DLC_STATISTICS:

        //
        //  User may read either SAP or link statistics log
        //

        if ((NtDlcParms.DlcStatistics.usStationId & 0xff) == 0) {
            InputBufferSize = sizeof(DLC_SAP_LOG);
        } else {
            InputBufferSize = sizeof(DLC_LINK_LOG);
        }

        if (pDlcParms->DlcStatistics.uchOptions & 0x80) {
            InfoClass = DLC_INFO_CLASS_STATISTICS_RESET;
        } else {
            InfoClass = DLC_INFO_CLASS_STATISTICS;
        }
        DlcStatus = DlcGetInfo(DriverHandle,
                               InfoClass,
                               pDlcParms->DlcStatistics.usStationId,
                               NtDlcParms.DlcGetInformation.Info.Buffer,
                               InputBufferSize
                               );
        if ((ULONG)pDlcParms->DlcStatistics.cbLogBufSize < InputBufferSize) {
            InputBufferSize = (ULONG)pDlcParms->DlcStatistics.cbLogBufSize;
        }

        RtlMoveMemory(pDlcParms->DlcStatistics.pLogBuf,
                      NtDlcParms.DlcGetInformation.Info.Buffer,
                      InputBufferSize
                      );

        if (DlcStatus == LLC_STATUS_SUCCESS
        && (ULONG)pDlcParms->DlcStatistics.cbLogBufSize < InputBufferSize) {
            DlcStatus = LLC_STATUS_LOST_LOG_DATA;
        }

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DIR_READ_LOG:

        //
        //  We use two get info functions to read necessary stuff.
        //  Must must read even partial log buffer if user buffer
        //  is too small for the whole data (the user buffer could
        //  be even zero).
        //

        if (pDlcParms->DirReadLog.usTypeId > LLC_DIR_READ_LOG_BOTH) {

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n",
                        LLC_STATUS_INVALID_LOG_ID,
                        LLC_STATUS_INVALID_LOG_ID
                        ));
                }
            }

            return LLC_STATUS_INVALID_LOG_ID;
        }
        DlcStatus = STATUS_SUCCESS;
        CopyLength = cbLogBuffer = pDlcParms->DirReadLog.cbLogBuffer;
        pBuffer = (PUCHAR)pDlcParms->DirReadLog.pLogBuffer;

        switch (pDlcParms->DirReadLog.usTypeId) {
        case LLC_DIR_READ_LOG_BOTH:
        case LLC_DIR_READ_LOG_ADAPTER:
            if (DlcStatus == STATUS_SUCCESS) {
                DlcStatus = DlcGetInfo(DriverHandle,
                                        DLC_INFO_CLASS_ADAPTER_LOG,
                                        0,
                                        NtDlcParms.DlcGetInformation.Info.Buffer,
                                        sizeof(LLC_ADAPTER_LOG)
                                        );
            }
            if (cbLogBuffer > sizeof(LLC_ADAPTER_LOG)) {
                CopyLength = sizeof(LLC_ADAPTER_LOG);
            }
            if (pDlcParms->DirReadLog.usTypeId == LLC_DIR_READ_LOG_BOTH) {
                RtlMoveMemory(pBuffer,
                              NtDlcParms.DlcGetInformation.Info.Buffer,
                              CopyLength
                              );
                cbLogBuffer -= CopyLength;
                pBuffer += CopyLength;
                CopyLength = cbLogBuffer;

                DlcStatus = DlcGetInfo(DriverHandle,
                                        DLC_INFO_CLASS_STATISTICS_RESET,
                                        0,
                                        NtDlcParms.DlcGetInformation.Info.Buffer,
                                        sizeof(LLC_DIRECT_LOG)
                                        );
                if (cbLogBuffer > sizeof(LLC_DIRECT_LOG)) {
                    CopyLength = sizeof(LLC_DIRECT_LOG);
                }
            }

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
                }
            }

            return DlcStatus;

        case LLC_DIR_READ_LOG_DIRECT:
            DlcStatus = DlcGetInfo(DriverHandle,
                                    DLC_INFO_CLASS_STATISTICS_RESET,
                                    0,
                                    NtDlcParms.DlcGetInformation.Info.Buffer,
                                    sizeof(LLC_DIRECT_LOG)
                                    );
            if (cbLogBuffer > sizeof(LLC_DIRECT_LOG)) {
                CopyLength = sizeof(LLC_DIRECT_LOG);
            }
            break;
        }
        RtlMoveMemory(pBuffer,
                      NtDlcParms.DlcGetInformation.Info.Buffer,
                      CopyLength
                      );

        if (aMinDirLogSize[pDlcParms->DirReadLog.usTypeId] > pDlcParms->DirReadLog.cbLogBuffer) {
            pDlcParms->DirReadLog.cbActualLength = aMinDirLogSize[pDlcParms->DirReadLog.usTypeId];
            DlcStatus = LLC_STATUS_LOST_LOG_DATA;
        }

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DIR_SET_FUNCTIONAL_ADDRESS:
        if (pCCB->u.auchBuffer[0] & (UCHAR)0x80) {
            InfoClass = DLC_INFO_CLASS_RESET_FUNCTIONAL;
        } else {
            InfoClass = DLC_INFO_CLASS_SET_FUNCTIONAL;
        }
        DlcStatus = DlcSetInfo(DriverHandle,
                               InfoClass,
                               0,
                               &NtDlcParms.DlcSetInformation,
                               pCCB->u.auchBuffer,
                               sizeof(TR_BROADCAST_ADDRESS)
                               );

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DIR_SET_GROUP_ADDRESS:
        return DlcSetInfo(DriverHandle,
                          DLC_INFO_CLASS_SET_GROUP,
                          0,
                          &NtDlcParms.DlcSetInformation,
                          pCCB->u.auchBuffer,
                          sizeof(TR_BROADCAST_ADDRESS)
                          );

    case LLC_DIR_SET_MULTICAST_ADDRESS:
        return DlcSetInfo(DriverHandle,
                          DLC_INFO_CLASS_SET_MULTICAST,
                          0,
                          &NtDlcParms.DlcSetInformation,
                          pCCB->u.pParameterTable,
                          sizeof(LLC_DIR_MULTICAST_ADDRESS)
                          );

    case LLC_DIR_STATUS:

        //
        // We will generic DlcGetInfo to read the status info.
        // some parameters must be moved ot correct places.
        //

        RtlZeroMemory(pDlcParms, sizeof(LLC_DIR_STATUS_PARMS));
        DlcStatus = DlcGetInfo(DriverHandle,
                               DLC_INFO_CLASS_DIR_ADAPTER,
                               0,
                               &NtDlcParms.DlcGetInformation.Info.DirAdapter,
                               sizeof(LLC_ADAPTER_INFO)
                               );
        if (DlcStatus != LLC_STATUS_SUCCESS) {

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
                }
            }

            return DlcStatus;
        }
        RtlMoveMemory(pDlcParms->DirStatus.auchNodeAddress,
                      &NtDlcParms.DlcGetInformation.Info.DirAdapter,
                      sizeof(LLC_ADAPTER_INFO)
                      );
        pDlcParms->DirStatus.usAdapterType =
            NtDlcParms.DlcGetInformation.Info.DirAdapter.usAdapterType;

        //
        // Set the adapter config flags, the only thing we actually
        // can know, if the current link speed on the adapter.
        // In the other fields we just use the default values.
        // Keep the bit defining extended DOS parameters unchanged,
        // but all other bits may be changed.
        //

        pDlcParms->DirStatus.uchAdapterConfig &= ~0x20; // DOS extended parms
        if (NtDlcParms.DlcGetInformation.Info.DirAdapter.ulLinkSpeed ==
            TR_16Mbps_LINK_SPEED) {
            pDlcParms->DirStatus.uchAdapterConfig |=
                0x10 |      // early release token
                0x0c |      // 64 kB RAM on a 4/16 IBM token-ring adapter
                0x01;       // adapter rate is 16 Mbps
        } else {
            pDlcParms->DirStatus.uchAdapterConfig |=
                0x0c;       // 64 kB RAM on adapter
        }
        DlcStatus = DlcGetInfo(DriverHandle,
                               DLC_INFO_CLASS_PERMANENT_ADDRESS,
                               0,
                               pDlcParms->DirStatus.auchPermanentAddress,
                               6
                               );
        if (DlcStatus != LLC_STATUS_SUCCESS) {

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
                }
            }

            return DlcStatus;
        }
        DlcStatus = DlcGetInfo(DriverHandle,
                               DLC_INFO_CLASS_DLC_ADAPTER,
                               0,
                               &pDlcParms->DirStatus.uchMaxSap,
                               sizeof(struct _DlcAdapterInfoGet)
                               );

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_READ_CANCEL:
    case LLC_DIR_TIMER_CANCEL:
    case LLC_RECEIVE_CANCEL:

        //
        //  Copy pointer of the cancelled command to the
        //  byte aligned output buffer.
        //

        NtDlcParms.DlcCancelCommand.CcbAddress = (PVOID)pDlcParms;
        //SmbPutUlong(&pOutputCcb->pNext, (ULONG_PTR) pDlcParms);
        pOutputCcb->pNext = (PVOID) pDlcParms;
        break;

    case LLC_DIR_TIMER_CANCEL_GROUP:
    case LLC_DIR_TIMER_SET:
        pInputBuffer = pCCB;
        break;

    case LLC_DLC_CONNECT_STATION:

        NtDlcParms.Async.Ccb = *(PNT_DLC_CCB)pCCB;
        NtDlcParms.Async.Parms.DlcConnectStation.StationId = pDlcParms->DlcConnectStation.usStationId;

        if (pDlcParms->DlcConnectStation.pRoutingInfo != NULL) {

            NtDlcParms.Async.Parms.DlcConnectStation.RoutingInformationLength = *pDlcParms->DlcConnectStation.pRoutingInfo & (UCHAR)0x1f;

            RtlMoveMemory(NtDlcParms.Async.Parms.DlcConnectStation.aRoutingInformation,
                          pDlcParms->DlcConnectStation.pRoutingInfo,
                          NtDlcParms.Async.Parms.DlcConnectStation.RoutingInformationLength
                          );
        } else {

            NtDlcParms.Async.Parms.DlcConnectStation.RoutingInformationLength=0;

        }
        break;

    case LLC_DOS_DLC_FLOW_CONTROL:

        //
        // This is an official entry to DlcFlowControl used by
        // VDM DLC support DLL to set a link buffer busy state.
        //

        NtDlcParms.DlcFlowControl.FlowControlOption = (UCHAR)pCCB->u.dlc.usParameter;
        NtDlcParms.DlcFlowControl.StationId = pCCB->u.dlc.usStationId;
        break;

    case LLC_DLC_FLOW_CONTROL:

        //
        // This is the official entry to DlcFlowControl
        //

        NtDlcParms.DlcFlowControl.FlowControlOption = (UCHAR)(pCCB->u.dlc.usParameter & LLC_VALID_FLOW_CONTROL_BITS);
        NtDlcParms.DlcFlowControl.StationId = pCCB->u.dlc.usStationId;
        break;

    case LLC_DLC_MODIFY:
        RtlMoveMemory(&NtDlcParms.DlcSetInformation.Info.LinkStation,
                      &pDlcParms->DlcModify.uchT1,
                      sizeof(DLC_LINK_PARAMETERS)
                      );
        NtDlcParms.DlcSetInformation.Info.LinkStation.TokenRingAccessPriority = pDlcParms->DlcModify.uchAccessPriority;

        //
        // This is a non-standard extension: DlcModify returns
        // the maximum allowed information field lentgh for a link station.
        // (it depends on length of source routing and bridges
        // between two stations).
        //

        if ((pDlcParms->DlcModify.usStationId & 0x00ff) != 0) {
            DlcStatus = DlcGetInfo(DriverHandle,
                                   DLC_INFO_CLASS_LINK_STATION,
                                   pDlcParms->DlcModify.usStationId,
                                   &pDlcParms->DlcModify.usMaxInfoFieldLength,
                                   sizeof(USHORT)
                                   );
        }
        DlcStatus = DlcSetInfo(DriverHandle,
                               DLC_INFO_CLASS_LINK_STATION,
                               pDlcParms->DlcModify.usStationId,
                               &NtDlcParms.DlcSetInformation,
                               NULL,
                               sizeof(DLC_LINK_PARAMETERS)
                               );

        //
        // Set the group information, if there is any
        //

        if (DlcStatus == LLC_STATUS_SUCCESS && pDlcParms->DlcModify.cGroupCount != 0) {
            NtDlcParms.DlcSetInformation.Info.Sap.GroupCount = pDlcParms->DlcModify.cGroupCount;
            RtlMoveMemory(NtDlcParms.DlcSetInformation.Info.Sap.GroupList,
                          pDlcParms->DlcModify.pGroupList,
                          pDlcParms->DlcModify.cGroupCount
                          );
            DlcStatus = DlcSetInfo(DriverHandle,
                                   DLC_INFO_CLASS_GROUP,
                                   pDlcParms->DlcModify.usStationId,
                                   &NtDlcParms.DlcSetInformation,
                                   NULL,
                                   sizeof(struct _DlcSapInfoSet)
                                   );
        }

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DLC_OPEN_SAP:

        //
        // DlcOpenSap uses the original OS/2 CCB, but it has to modify a couple
        // fields. There is a separate call to setup the group SAPS because
        // they cannot use the original CCB parameter table (it's a pointer)
        //

        pNtParms = (PNT_DLC_PARMS)pDlcParms;

        pNtParms->DlcOpenSap.LinkParameters.TokenRingAccessPriority = pDlcParms->DlcOpenSap.uchOptionsPriority & (UCHAR)0x1F;

        DlcStatus = DoSyncDeviceIoControl(DriverHandle,
                                          IOCTL_DLC_OPEN_SAP,
                                          pNtParms,
                                          sizeof(NT_DLC_OPEN_SAP_PARMS),
                                          pNtParms,
                                          sizeof(NT_DLC_OPEN_SAP_PARMS)
                                          );
        if (DlcStatus != LLC_STATUS_SUCCESS) {
            pOutputCcb->uchDlcStatus = (UCHAR)DlcStatus;

            IF_DEBUG(DUMP_NTACSLAN) {
                IF_DEBUG(DUMP_INPUT_CCB) {
                    DUMPCCB(pCCB, TRUE, FALSE);
                }
                IF_DEBUG(RETURN_CODE) {
                    PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
                }
            }

            return DlcStatus;
        }

        //
        // Check if there is defined any group saps
        //

        if (pDlcParms->DlcOpenSap.cGroupCount != 0) {
            NtDlcParms.DlcSetInformation.Info.Sap.GroupCount = pDlcParms->DlcOpenSap.cGroupCount;
            RtlMoveMemory(&NtDlcParms.DlcSetInformation.Info.Sap.GroupList,
                          pDlcParms->DlcOpenSap.pGroupList,
                          pDlcParms->DlcOpenSap.cGroupCount
                          );
            DlcStatus = DlcSetInfo(DriverHandle,
                                   DLC_INFO_CLASS_GROUP,
                                   pDlcParms->DlcOpenSap.usStationId,
                                   &NtDlcParms.DlcSetInformation,
                                   NULL,
                                   sizeof(struct _DlcSapInfoSet)
                                   );
        }
        pOutputCcb->uchDlcStatus = (UCHAR)DlcStatus;

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_INPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", DlcStatus, DlcStatus));
            }
        }

        return DlcStatus;

    case LLC_DLC_OPEN_STATION:
        NtDlcParms.DlcOpenStation.RemoteSap = pDlcParms->DlcOpenStation.uchRemoteSap;
        NtDlcParms.DlcOpenStation.LinkStationId = pDlcParms->DlcOpenStation.usSapStationId;
        RtlMoveMemory(NtDlcParms.DlcOpenStation.aRemoteNodeAddress,
                      pDlcParms->DlcOpenStation.pRemoteNodeAddress,
                      6
                      );
        RtlMoveMemory(&NtDlcParms.DlcOpenStation.LinkParameters,
                      &pDlcParms->DlcOpenStation.uchT1,
                      sizeof(DLC_LINK_PARAMETERS)
                      );
        NtDlcParms.DlcOpenStation.LinkParameters.TokenRingAccessPriority = pDlcParms->DlcOpenStation.uchAccessPriority;
        pOutputBuffer = &pDlcParms->DlcOpenStation.usLinkStationId;
        break;

    case LLC_READ:

#ifdef GRAB_READ

        if (pCCB->hCompletionEvent) {

            PREAD_GRABBER pGrabberStruct;

            pGrabberStruct = (PREAD_GRABBER)LocalAlloc(LMEM_FIXED, sizeof(READ_GRABBER));
            pGrabberStruct->pCcb = pCCB;
            pGrabberStruct->OriginalEventHandle = pCCB->hCompletionEvent;
            pGrabberStruct->NewEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL);
            EventHandle = pGrabberStruct->NewEventHandle;
            AddReadGrabber(pGrabberStruct);
        } else {
            OutputDebugString(L"NtAcsLan: LLC_READ with no event!\n");
        }

#endif

        //
        // IOCTL_DLC_READ have two output buffer, one for CCB and another
        // for the actual data.  IOCTL_DLC_READ2 is a read request, that
        // have the second outbut buffer immediately after the firt one =>
        // we don't need to lock, map, copy, unmap and unlock the second
        // output buffer.  The same thing has been implemented for receive.
        //

        if (pDlcParms != NULL && pDlcParms != (PVOID)&pCCB[1]) {
            OutputBufferLength = sizeof(NT_DLC_CCB_OUTPUT);
            NtDlcParms.Async.Ccb = *(PNT_DLC_CCB)pCCB;
            NtDlcParms.Async.Parms.ReadInput = *(PNT_DLC_READ_INPUT)pDlcParms;
        } else {
            IoctlCommand = IOCTL_DLC_READ2;
            OutputBufferLength = sizeof(NT_DLC_READ_PARMS) + sizeof(LLC_CCB);
            pInputBuffer = pCCB;
        }
        break;

    case LLC_RECEIVE:
        OutputBufferLength = sizeof(NT_DLC_CCB_OUTPUT);
        if (pDlcParms != NULL && pDlcParms != (PVOID)&pCCB[1]) {
            NtDlcParms.Async.Ccb = *(PNT_DLC_CCB)pCCB;
            NtDlcParms.Async.Parms.Receive = pDlcParms->Receive;

            //
            // We don't actually receive any data with receive command,
            // if the receive flag is set.
            //

            if (NtDlcParms.Async.Parms.Receive.ulReceiveFlag != 0) {
                IoctlCommand = IOCTL_DLC_RECEIVE2;
            }
        } else {
            IoctlCommand = IOCTL_DLC_RECEIVE2;
            pInputBuffer = pCCB;
        }
        break;

    case LLC_TRANSMIT_DIR_FRAME:
        FrameType = LLC_DIRECT_TRANSMIT;
        goto TransmitHandling;

    case LLC_TRANSMIT_UI_FRAME:
        FrameType = LLC_UI_FRAME;
        goto TransmitHandling;

    case LLC_TRANSMIT_XID_CMD:
        FrameType = LLC_XID_COMMAND_POLL;
        goto TransmitHandling;

    case LLC_TRANSMIT_XID_RESP_FINAL:
        FrameType = LLC_XID_RESPONSE_FINAL;
        goto TransmitHandling;

    case LLC_TRANSMIT_XID_RESP_NOT_FINAL:
        FrameType = LLC_XID_RESPONSE_NOT_FINAL;
        goto TransmitHandling;

    case LLC_TRANSMIT_TEST_CMD:
        FrameType = LLC_TEST_COMMAND_POLL;
        goto TransmitHandling;

    case LLC_TRANSMIT_I_FRAME:
        FrameType = LLC_I_FRAME;

TransmitHandling:

        //
        // Copy the link list headers to the descriptor array and build NT CCB.
        // (BUG-BUG-BUG: We should implement the send of multiple frames.
        // loop CCB chain as far as the same CCB command and transmit commands
        // completed with READ)
        //

        OutputBufferLength = sizeof(NT_DLC_CCB_OUTPUT);

        //
        // This stuff is for DOS DLC, the transmit parameter table may have been
        // copied if it was unaligned
        //

        //SmbPutUlong((PULONG)&pOutputCcb->pNext, (ULONG)pOriginalCcbAddress);
        pOutputCcb->pNext = (PVOID) pOriginalCcbAddress;
        RtlMoveMemory((PUCHAR)&NtDlcParms.Async.Ccb, (PUCHAR)pOutputCcb, sizeof(NT_DLC_CCB));

        pOutputCcb->uchDlcStatus = (UCHAR)LLC_STATUS_PENDING;
        NtDlcParms.Async.Parms.Transmit.FrameType = FrameType;
        NtDlcParms.Async.Parms.Transmit.StationId = pDlcParms->Transmit.usStationId;
        NtDlcParms.Async.Parms.Transmit.RemoteSap = pDlcParms->Transmit.uchRemoteSap;
        NtDlcParms.Async.Parms.Transmit.XmitReadOption = pDlcParms->Transmit.uchXmitReadOption;

        cElement = 0;
        if (pDlcParms->Transmit.pXmitQueue1 != NULL) {
            CopyToDescriptorBuffer(NtDlcParms.Async.Parms.Transmit.XmitBuffer,
                                   pDlcParms->Transmit.pXmitQueue1,
                                   FALSE,   // DO_NOT_DEALLOCATE
                                   &cElement,
                                   &pFirstBuffer,
                                   &DlcStatus
                                   );
            if (DlcStatus != STATUS_SUCCESS) {
                pCCB->uchDlcStatus = (UCHAR)DlcStatus;

                IF_DEBUG(DUMP_NTACSLAN) {
                    IF_DEBUG(DUMP_INPUT_CCB) {
                        DUMPCCB(pCCB, TRUE, FALSE);
                    }
                    IF_DEBUG(RETURN_CODE) {
                        PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
                    }
                }

                return LLC_STATUS_PENDING;
            }
        }
        if (pDlcParms->Transmit.pXmitQueue2 != NULL) {
            CopyToDescriptorBuffer(NtDlcParms.Async.Parms.Transmit.XmitBuffer,
                                   pDlcParms->Transmit.pXmitQueue2,
                                   TRUE,    // DEALLOCATE_AFTER_USE
                                   &cElement,
                                   &pFirstBuffer,
                                   &DlcStatus
                                   );

            //
            // The Queue2 pointer must be reset always.
            // This doesn't work for DOS DLC buffers, but it does not
            // matter, because this feature is not needed by VDM DLC
            // (we cannot access pOutputCcb or its parameter block,
            // because they may be unaligned)
            //

            pDlcParms->Transmit.pXmitQueue2 = NULL;

            if (DlcStatus != STATUS_SUCCESS) {
                pCCB->uchDlcStatus = (UCHAR)DlcStatus;

                IF_DEBUG(DUMP_NTACSLAN) {
                    IF_DEBUG(DUMP_INPUT_CCB) {
                        DUMPCCB(pCCB, TRUE, FALSE);
                    }
                    IF_DEBUG(RETURN_CODE) {
                        PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
                    }
                }

                return LLC_STATUS_PENDING;
            }
        }
        if (pDlcParms->Transmit.cbBuffer1 != 0) {
            if (cElement == MAX_TRANSMIT_SEGMENTS) {
                pCCB->uchDlcStatus = LLC_STATUS_TRANSMIT_ERROR;

                IF_DEBUG(DUMP_NTACSLAN) {
                    IF_DEBUG(DUMP_INPUT_CCB) {
                        DUMPCCB(pCCB, TRUE, FALSE);
                    }
                    IF_DEBUG(RETURN_CODE) {
                        PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
                    }
                }

                return LLC_STATUS_PENDING;
            }
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].pBuffer = pDlcParms->Transmit.pBuffer1;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].cbBuffer = pDlcParms->Transmit.cbBuffer1;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].boolFreeBuffer = FALSE;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].eSegmentType = LLC_NEXT_DATA_SEGMENT;
            cElement++;
        }
        if (pDlcParms->Transmit.cbBuffer2 != 0) {
            if (cElement == MAX_TRANSMIT_SEGMENTS) {
                pCCB->uchDlcStatus = LLC_STATUS_TRANSMIT_ERROR;

                IF_DEBUG(DUMP_NTACSLAN) {
                    IF_DEBUG(DUMP_INPUT_CCB) {
                        DUMPCCB(pCCB, TRUE, FALSE);
                    }
                    IF_DEBUG(RETURN_CODE) {
                        PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
                    }
                }

                return LLC_STATUS_PENDING;
            }
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].pBuffer = pDlcParms->Transmit.pBuffer2;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].cbBuffer = pDlcParms->Transmit.cbBuffer2;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].boolFreeBuffer = FALSE;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].eSegmentType = LLC_NEXT_DATA_SEGMENT;
            cElement++;
        }
        NtDlcParms.Async.Parms.Transmit.XmitBuffer[0].eSegmentType = LLC_FIRST_DATA_SEGMENT;
        NtDlcParms.Async.Parms.Transmit.XmitBufferCount = cElement;
        InputBufferSize = sizeof(LLC_TRANSMIT_DESCRIPTOR) * cElement
                        + sizeof(NT_DLC_TRANSMIT_PARMS)
                        + sizeof(NT_DLC_CCB)
                        - sizeof(LLC_TRANSMIT_DESCRIPTOR);
        break;

        //
        // Multiple frame transmit:
        //     - atomic operation: single error => all are discarded
        //       by error, but some successful packets may have been sent
        //       after the unsuccessful one.
        //     - No DLC frame headers are included
        //     - LAN header must always be in the first buffer,
        //     - 3 dwords reserved for DLC in the beginning.
        // good: provides the minimal system overhead
        // bad: error handling may be difficult in some cases
        // new data link operation:
        //     cancel packets by request handle, called when an
        //     error has occurred (this would require a new
        //     one level request handle)
        //

    case LLC_TRANSMIT_FRAMES:

        //
        // We must copy the actual CCB to the parameter table only if
        // the CCB is not allocated within the transmit command structure
        //

        if (&pDlcParms->Transmit2.Ccb != pCCB) {
            pDlcParms->Transmit2.Ccb = *pCCB;
        }
        pInputBuffer = pDlcParms;
        InputBufferSize = (sizeof(LLC_TRANSMIT_DESCRIPTOR)
                        * (UINT)pDlcParms->Transmit2.cXmitBufferCount)
                        + sizeof(LLC_TRANSMIT2_COMMAND)
                        - sizeof(LLC_TRANSMIT_DESCRIPTOR);
        break;

    default:
        return LLC_STATUS_INVALID_COMMAND;
    }

    NtStatus = NtDeviceIoControlFile(DriverHandle,
                                     EventHandle,       // Event signaled when cmd completes
                                     NULL,              // no APC routine
                                     NULL,              // no context for APC
                                     &GlobalIoStatus,   // global I/O status block
                                     IoctlCommand,      // map DLC cmd codes to Nt IoCtl codes
                                     pInputBuffer,
                                     InputBufferSize,
                                     pOutputBuffer,
                                     OutputBufferLength
                                     );

    //
    // The io-completion directly updates Status and next CCB pointer
    // of this CCB when the main function return status pending.
    // If the status code is non-pending (error or ok), then we
    // must save the status code to CCB and reset next CCB pointer.
    //

    if (NtStatus != STATUS_PENDING) {

        //
        // Reset the next pointer if the command is still linked to itself.
        // For example the cancel command returns a pointer to the cancelled
        // CCB in the next CCB pointer (pNext)
        //

        if (pCCB->pNext == pOutputCcb) {
            pCCB->pNext = NULL;
        }

        pCCB->uchDlcStatus = (UCHAR)NtStatus;

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_OUTPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", pCCB->uchDlcStatus, pCCB->uchDlcStatus));
            }
        }

#if DBG
        if (pOutputCcb->uchDlcStatus == 0xA1) {
            OutputDebugString(TEXT("NtAcsLan returning 0xA1\n"));
            //DebugBreak();
        }

        if (pOutputCcb->uchDlcCommand == LLC_TRANSMIT_I_FRAME && pOutputCcb->uchDlcStatus != LLC_STATUS_SUCCESS) {

            WCHAR buf[80];

            wsprintf(buf, TEXT("NtAcsLan: I-Frame returning %#02x\n"), pOutputCcb->uchDlcStatus);
            OutputDebugString(buf);
        }

        if (pCCB->uchDlcStatus != pOutputCcb->uchDlcStatus) {

            WCHAR buf[80];

            wsprintf(buf, TEXT("NtAcsLan: pCCB->uchDlcStatus = %#02x; pOutputCcb->uchDlcStatus = %#02x\n"),
                    pCCB->uchDlcStatus,
                    pOutputCcb->uchDlcStatus
                    );
            OutputDebugString(buf);
        }
#endif

        return pCCB->uchDlcStatus;

    } else {

        IF_DEBUG(DUMP_NTACSLAN) {
            IF_DEBUG(DUMP_OUTPUT_CCB) {
                DUMPCCB(pCCB, TRUE, FALSE);
            }
            IF_DEBUG(RETURN_CODE) {
                PUT(("NtAcsLan: returning %d [0x%x]\n", LLC_STATUS_PENDING, LLC_STATUS_PENDING));
            }
        }

        return LLC_STATUS_PENDING;

    }
}


USHORT
GetCcbStationId(
    IN PLLC_CCB pCCB
    )

/*++

Routine Description:

    The function returns the station id used by the given ccb.
    -1 is returned, if the command didn't have any station id.

Arguments:

    pCCB - OS/2 DLC Command control block


Return Value:

    Station Id
    -1          No station id

--*/

{
    switch (pCCB->uchDlcCommand) {
    case LLC_BUFFER_FREE:
    case LLC_BUFFER_CREATE:
    case LLC_BUFFER_GET:
    case LLC_DLC_REALLOCATE_STATIONS:
    case LLC_DLC_STATISTICS:
    case LLC_READ:
    case LLC_RECEIVE:
    case LLC_TRANSMIT_DIR_FRAME:
    case LLC_TRANSMIT_UI_FRAME:
    case LLC_TRANSMIT_XID_CMD:
    case LLC_TRANSMIT_XID_RESP_FINAL:
    case LLC_TRANSMIT_XID_RESP_NOT_FINAL:
    case LLC_TRANSMIT_TEST_CMD:
    case LLC_TRANSMIT_I_FRAME:
    case LLC_TRANSMIT_FRAMES:
    case LLC_DLC_CONNECT_STATION:
    case LLC_DLC_MODIFY:
        return pCCB->u.pParameterTable->DlcModify.usStationId;

    case LLC_DLC_FLOW_CONTROL:
    case LLC_DLC_CLOSE_STATION:
    case LLC_DLC_CLOSE_SAP:
    case LLC_DIR_CLOSE_DIRECT:
    case LLC_DLC_RESET:
        return pCCB->u.dlc.usStationId;

    default:
        return (USHORT)-1;
    }
}


LLC_STATUS
OpenDlcApiDriver(
    IN PVOID pSecurityDescriptor,
    OUT HANDLE* pHandle
    )

/*++

Routine Description:

    Opens a handle to the DLC driver

Arguments:

    pSecurityDescriptor - pointer to security descriptor
    pHandle             - pointer to returned handle if success

Return Value:

    LLC_STATUS
        Success - LLC_STATUS_SUCCESS
        Failure - LLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED

--*/

{
    IO_STATUS_BLOCK iosb;
    OBJECT_ATTRIBUTES objattr;
    UNICODE_STRING DriverName;
    NTSTATUS Status;

    RtlInitUnicodeString(&DriverName, DD_DLC_DEVICE_NAME);

    InitializeObjectAttributes(
            &objattr,                       // obj attr to initialize
            &DriverName,                    // string to use
            OBJ_CASE_INSENSITIVE,           // Attributes
            NULL,                           // Root directory
            pSecurityDescriptor             // Security Descriptor
            );

    Status = NtCreateFile(
                pHandle,                    // ptr to handle
                GENERIC_READ                // desired...
                | GENERIC_WRITE,            // ...access
                &objattr,                   // name & attributes
                &iosb,                      // I/O status block.
                NULL,                       // alloc size.
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_DELETE           // share...
                | FILE_SHARE_READ
                | FILE_SHARE_WRITE,         // ...access
                FILE_OPEN_IF,               // create disposition
                0,                          // ...options
                NULL,                       // EA buffer
                0L                          // Ea buffer len
                );

    if (Status != STATUS_SUCCESS) {
        return LLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED;
    }
    return LLC_STATUS_SUCCESS;
}


LLC_STATUS
GetAdapterNameAndParameters(
    IN UINT AdapterNumber,
    OUT PUNICODE_STRING pNdisName,
    OUT PUCHAR pTicks,
    OUT PLLC_ETHERNET_TYPE pLlcEthernetType
    )

/*++

Routine Description:

    Get the adapter mapping for AdapterNumber from the registry. Also, get the
    Ethernet type and

Arguments:

    AdapterNumber - DLC adapter number (0, 1, 2 ... 15)

    pNdisName - the returned unicode name string

    pTicks -

    pLlcEthernetType -

Return Value:

    LLC_STATUS

--*/

{
    LLC_STATUS llcStatus;
    LONG regStatus;
    HKEY hkey;

    static LPTSTR subkey = TEXT("System\\CurrentControlSet\\Services\\Dlc\\Linkage");

    regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             subkey,
                             0,
                             KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                             &hkey
                             );
    if (regStatus == ERROR_SUCCESS) {

        DWORD type;
        DWORD dataSize;
        LPTSTR buffer;
        LPTSTR tempbuffer;

        //
        // here we try to get all the info in one go from the registry. If
        // the "Bind" value has grown to more than 1024 bytes, then we must
        // try to reallocate the buffer and try again. If it fails a second
        // time, then give up
        //

        buffer = (LPTSTR)LocalAlloc(LMEM_FIXED, DEFAULT_QUERY_BUFFER_LENGTH);
        if (buffer) {
            dataSize = DEFAULT_QUERY_BUFFER_LENGTH;
            regStatus = RegQueryValueEx(hkey,
                                        TEXT("Bind"),
                                        NULL,   // lpdwReserved
                                        &type,
                                        (LPBYTE)buffer,
                                        &dataSize
                                        );
            if (regStatus == ERROR_SUCCESS || regStatus == ERROR_MORE_DATA) {
                llcStatus = LLC_STATUS_SUCCESS;

                //
                // This code not tested - Realloc don't work
                //
                if (dataSize > DEFAULT_QUERY_BUFFER_LENGTH) {

                    DWORD oldSize;

                    //
                    // more available than I anticipated. Try growing the buffer.
                    // Add an extra DEFAULT_BINDING_LENGTH in case somebody's
                    // adding to this entry whilst we're reading it (unlikely)
                    //

                    oldSize = dataSize;
                    dataSize += DEFAULT_BINDING_LENGTH;
                    tempbuffer = buffer;
                    buffer = (LPTSTR)LocalReAlloc((HLOCAL)buffer, dataSize, 0);
                    if (buffer) {
                        regStatus = RegQueryValueEx(hkey,
                                                    subkey,
                                                    NULL,   // lpdwReserved
                                                    &type,
                                                    (LPBYTE)buffer,
                                                    &dataSize
                                                    );
                        if (regStatus != ERROR_SUCCESS) {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        } else if (dataSize > oldSize) {

                            //
                            // data has grown since last call? Bogus?
                            //

                            llcStatus = LLC_STATUS_NO_MEMORY;
                        }
                    } else {
                        LocalFree(tempbuffer);

                        //
                        // Is this error code acceptable in this circumstance?
                        //

                        llcStatus = LLC_STATUS_NO_MEMORY;
                    }
                }
                if (llcStatus == LLC_STATUS_SUCCESS) {

                    //
                    // we managed to read something from the registry. Try to
                    // locate our adapter. The returned data is wide-character
                    // strings (better be, lets check the type first)
                    //

                    if (type == REG_MULTI_SZ) {

                        DWORD i;
                        LPTSTR pBinding = buffer;

                        for (i = 0; i != AdapterNumber; ++i) {
                            pBinding = wcschr(pBinding, L'\0') + 1;
                            if (!*pBinding) {
                                break;
                            }
                        }

                        //
                        // if there is a binding corresponding to this adapter
                        // number (e.g. \Device\IbmTok01) then make a copy of
                        // the string and make it into a UNICODE_STRING. The
                        // caller uses RtlFreeUnicodeString
                        //
                        // Does RtlFreeUnicodeString know that I used
                        // LocalAlloc to allocate the string?
                        //

                        if (*pBinding) {

                            LPTSTR bindingName;

                            bindingName = (LPTSTR)LocalAlloc(
                                                LMEM_FIXED,
                                                (wcslen(pBinding) + 1)
                                                    * sizeof(WCHAR)
                                                );
                            if (bindingName) {
                                wcscpy(bindingName, pBinding);
                                RtlInitUnicodeString(pNdisName, bindingName);

//#if DBG
//                                DbgPrint("DLCAPI.DLL: Adapter %d maps to %ws\n",
//                                         AdapterNumber,
//                                         pBinding
//                                         );
//#endif
                            } else {
                                llcStatus = LLC_STATUS_NO_MEMORY;
                            }
                        } else {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        }
                    } else {

                        //
                        // unexpected type in registry
                        //

                        llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                    }
                }
            } else {
                llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
            }
            if (buffer) {
                LocalFree(buffer);
            }

            //
            // for now, default the ticks and ethernet type
            //

            RtlZeroMemory(pTicks, sizeof(LLC_TICKS));

            //
            // if the app passed in anything other than those values we
            // recognize, convert to AUTO.
            //
            // Note: we should really return an error (invalid parameter) in
            // this case, since it means the app is passing in a bad value,
            // but at this late stage, it is better to accept invalid input
            // and default it than to risk an app/printer monitor stopping
            // working (RLF 05/10/93)
            //

            if (*pLlcEthernetType != LLC_ETHERNET_TYPE_AUTO
            && *pLlcEthernetType != LLC_ETHERNET_TYPE_DEFAULT
            && *pLlcEthernetType != LLC_ETHERNET_TYPE_DIX
            && *pLlcEthernetType != LLC_ETHERNET_TYPE_802_3) {
                *pLlcEthernetType = LLC_ETHERNET_TYPE_AUTO;
            }
        } else {

            //
            // Is this error code acceptable in this circumstance?
            //

            llcStatus = LLC_STATUS_NO_MEMORY;
        }
        RegCloseKey(hkey);
    } else {
        llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
    }

    return llcStatus;
}



LLC_STATUS
GetAdapterNameFromNumber(
    IN UINT AdapterNumber,
    OUT LPTSTR pNdisName
    )

/*++

Routine Description:

    Get the adapter name mapping for AdapterNumber from the registry.

Arguments:

    AdapterNumber - DLC adapter number (0, 1, 2 ... 15)

    pNdisName - the returned zero-terminated wide character string

Return Value:

    LLC_STATUS

--*/

{
    LLC_STATUS llcStatus;
    LONG regStatus;
    HKEY hkey;

    static LPTSTR subkey = TEXT("System\\CurrentControlSet\\Services\\Dlc\\Linkage");

    regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             subkey,
                             0,
                             KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                             &hkey
                             );
    if (regStatus == ERROR_SUCCESS) {

        DWORD type;
        DWORD dataSize;
        LPTSTR buffer;

        //
        // here we try to get all the info in one go from the registry. If
        // the "Bind" value has grown to more than 1024 bytes, then we must
        // try to reallocate the buffer and try again. If it fails a second
        // time, then give up
        //

        buffer = (LPTSTR)LocalAlloc(LMEM_FIXED, DEFAULT_QUERY_BUFFER_LENGTH);
        if (buffer) {
            dataSize = DEFAULT_QUERY_BUFFER_LENGTH;
            regStatus = RegQueryValueEx(hkey,
                                        TEXT("Bind"),
                                        NULL,   // lpdwReserved
                                        &type,
                                        (LPBYTE)buffer,
                                        &dataSize
                                        );
            if (regStatus == ERROR_SUCCESS || regStatus == ERROR_MORE_DATA) {
                llcStatus = LLC_STATUS_SUCCESS;

                //
                // this code not tested - Realloc don't work
                //

                if (dataSize > DEFAULT_QUERY_BUFFER_LENGTH) {

                    DWORD oldSize;

                    //
                    // more available than I anticipated. Try growing the buffer.
                    // Add an extra DEFAULT_BINDING_LENGTH in case somebody's
                    // adding to this entry whilst we're reading it (unlikely)
                    //

                    oldSize = dataSize;
                    dataSize += DEFAULT_BINDING_LENGTH;
                    buffer = (LPTSTR)LocalReAlloc((HLOCAL)buffer, dataSize, 0);
                    if (buffer) {
                        regStatus = RegQueryValueEx(hkey,
                                                    subkey,
                                                    NULL,   // lpdwReserved
                                                    &type,
                                                    (LPBYTE)buffer,
                                                    &dataSize
                                                    );
                        if (regStatus != ERROR_SUCCESS) {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        } else if (dataSize > oldSize) {

                            //
                            // data has grown since last call? Bogus?
                            //

                            llcStatus = LLC_STATUS_NO_MEMORY;
                        }
                    } else {

                        //
                        // Is this error code acceptable in this circumstance?
                        //

                        llcStatus = LLC_STATUS_NO_MEMORY;
                    }
                }
                if (llcStatus == LLC_STATUS_SUCCESS) {

                    //
                    // we managed to read something from the registry. Try to
                    // locate our adapter. The returned data is wide-character
                    // strings (better be, lets check the type first)
                    //

                    if (type == REG_MULTI_SZ) {

                        DWORD i;
                        LPTSTR pBinding = buffer;

                        for (i = 0; i != AdapterNumber; ++i) {
                            pBinding = wcschr(pBinding, L'\0') + 1;
                            if (!*pBinding) {
                                break;
                            }
                        }

                        //
                        // if there is a binding corresponding to this adapter
                        // number (e.g. \Device\IbmTok01)

                        if (*pBinding) {
			    wcscpy(pNdisName, pBinding);
                        } else {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        }
                    } else {

                        //
                        // unexpected type in registry
                        //

                        llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                    }
                }
            } else {
                llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
            }

	    LocalFree(buffer);

        }

	else {
	  llcStatus = LLC_STATUS_NO_MEMORY;
	}
	
        RegCloseKey(hkey);
    } else {
      llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
    }

    return llcStatus;
}



LLC_STATUS
GetAdapterNumberFromName(
    IN LPTSTR pNdisName,
    OUT UINT *AdapterNumber
    )

/*++

Routine Description:

    Get the adapter number mapping for AdapterName from the registry.

Arguments:

    pNdisName - zero-terminated wide character string

    AdapterNumber - returned DLC adapter number (0, 1, 2 ... 15)

Return Value:

    LLC_STATUS

--*/

{
    LLC_STATUS llcStatus;
    LONG regStatus;
    HKEY hkey;

    static LPTSTR subkey = TEXT("System\\CurrentControlSet\\Services\\Dlc\\Linkage");

    regStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             subkey,
                             0,
                             KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                             &hkey
                             );
    if (regStatus == ERROR_SUCCESS) {

        DWORD type;
        DWORD dataSize;
        LPTSTR buffer;

        //
        // here we try to get all the info in one go from the registry. If
        // the "Bind" value has grown to more than 1024 bytes, then we must
        // try to reallocate the buffer and try again. If it fails a second
        // time, then give up
        //

        buffer = (LPTSTR)LocalAlloc(LMEM_FIXED, DEFAULT_QUERY_BUFFER_LENGTH);
        if (buffer) {
            dataSize = DEFAULT_QUERY_BUFFER_LENGTH;
            regStatus = RegQueryValueEx(hkey,
                                        TEXT("Bind"),
                                        NULL,   // lpdwReserved
                                        &type,
                                        (LPBYTE)buffer,
                                        &dataSize
                                        );
            if (regStatus == ERROR_SUCCESS || regStatus == ERROR_MORE_DATA) {
                llcStatus = LLC_STATUS_SUCCESS;

                //
                // this code not tested - Realloc don't work
                //

                if (dataSize > DEFAULT_QUERY_BUFFER_LENGTH) {

                    DWORD oldSize;

                    //
                    // more available than I anticipated. Try growing the buffer.
                    // Add an extra DEFAULT_BINDING_LENGTH in case somebody's
                    // adding to this entry whilst we're reading it (unlikely)
                    //

                    oldSize = dataSize;
                    dataSize += DEFAULT_BINDING_LENGTH;
                    buffer = (LPTSTR)LocalReAlloc((HLOCAL)buffer, dataSize, 0);
                    if (buffer) {
                        regStatus = RegQueryValueEx(hkey,
                                                    subkey,
                                                    NULL,   // lpdwReserved
                                                    &type,
                                                    (LPBYTE)buffer,
                                                    &dataSize
                                                    );
                        if (regStatus != ERROR_SUCCESS) {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        } else if (dataSize > oldSize) {

                            //
                            // data has grown since last call? Bogus?
                            //

                            llcStatus = LLC_STATUS_NO_MEMORY;
                        }
                    } else {

                        //
                        // is this error code acceptable in this circumstance?
                        //

                        llcStatus = LLC_STATUS_NO_MEMORY;
                    }
                }
                if (llcStatus == LLC_STATUS_SUCCESS) {

                    //
                    // we managed to read something from the registry. Try to
                    // locate our adapter. The returned data is wide-character
                    // strings (better be, lets check the type first)
                    //

                    if (type == REG_MULTI_SZ) {

                        DWORD i;
                        LPTSTR pBinding = buffer;

			// here we map the name to number
			
			i = 0;
			while (*pBinding) {
			  if (!_wcsnicmp(pBinding, pNdisName, DEFAULT_BINDING_LENGTH)) {
			    break;
			  }
			  pBinding = wcschr(pBinding, L'\0') + 1;
			  if (!*pBinding) {
			    break;
			  }
			  i++;
			}
			
                        //
                        // if there is a binding corresponding to this adapter
                        // name (e.g. \Device\IbmTok01)
                        //

                        if (*pBinding) {
			    *AdapterNumber = i;
                        } else {
                            llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                        }
                    } else {

                        //
                        // unexpected type in registry
                        //

                        llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
                    }
                }
            } else {
                llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
            }

	    LocalFree(buffer);
	}
	
	else {
	  llcStatus = LLC_STATUS_NO_MEMORY;
	}
	
        RegCloseKey(hkey);
    }

    else {
      llcStatus = LLC_STATUS_ADAPTER_NOT_INSTALLED;
    }

    return llcStatus;
}


LLC_STATUS
DoSyncDeviceIoControl(
    IN HANDLE DeviceHandle,
    IN ULONG IoctlCommand,
    IN PVOID pInputBuffer,
    IN UINT InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    )

/*++

Routine Description:

    Function makes only the IO control call little bit simpler

Arguments:

    DeviceHandle        - device handle of the current address object
    IoctlCommand        - DLC command code
    pInputBuffer        - input parameters
    InputBufferLength   - lenght of input parameters
    pOutputBuffer       - the returned data
    OutputBufferLength  - the length of the returned data

Return Value:

    LLC_STATUS

--*/

{
    NTSTATUS NtStatus;

    NtStatus = NtDeviceIoControlFile(DeviceHandle,
                                     NULL,  // Event
                                     NULL,  // ApcRoutine
                                     NULL,  // ApcContext
                                     &GlobalIoStatus,
                                     IoctlCommand,
                                     pInputBuffer,
                                     InputBufferLength,
                                     pOutputBuffer,
                                     OutputBufferLength
                                     );

    //
    // NT DLC driver never returns any errors as NT error status.
    // => the CCB pointer had to be invalid, if NtDeviceIoctl returns
    // error
    //

    if (NtStatus != STATUS_SUCCESS && NtStatus != STATUS_PENDING) {
        if (NtStatus > LLC_STATUS_MAX_ERROR) {

            //
            // NT DLC driver should never any errors as NT error status.
            // => the CCB pointer must be invalid, if NtDeviceIoctl
            // returns an nt error status.
            //

            NtStatus = LLC_STATUS_INVALID_POINTER_IN_CCB;
        }
    }
    return (LLC_STATUS)NtStatus;
}


LLC_STATUS
DlcGetInfo(
    IN HANDLE DriverHandle,
    IN UINT InfoClass,
    IN USHORT StationId,
    IN PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    )

/*++

Routine Description:

    Function makes only the IO control call little bit simpler.

Arguments:

    DriverHandle        - the device handle of the address object
    InfoClass           - the type of the requested information
    StationId           - direct, link or sap station id
    pOutputBuffer       - the returned info structure
    OutputBufferLength  - output buffer length

Return Value:

    LLC_STATUS

--*/

{
    NT_DLC_QUERY_INFORMATION_PARMS GetInformation;

    GetInformation.Header.StationId = StationId;
    GetInformation.Header.InfoClass = (USHORT)InfoClass;

    return DoSyncDeviceIoControl(DriverHandle,
                                 IOCTL_DLC_QUERY_INFORMATION,
                                 &GetInformation,
                                 sizeof(NT_DLC_QUERY_INFORMATION_INPUT),
                                 pOutputBuffer,
                                 OutputBufferLength
                                 );
}


LLC_STATUS
DlcSetInfo(
    IN HANDLE DriverHandle,
    IN UINT InfoClass,
    IN USHORT StationId,
    IN PNT_DLC_SET_INFORMATION_PARMS pSetInfoParms,
    IN PVOID DataBuffer,
    IN UINT DataBufferLength
    )

/*++

Routine Description:

    Function makes only the IO control call little bit simpler.

Arguments:

    DriverHandle        - the device handle of the address object
    InfoClass           - the type of the requested information
    StationId           - direct, link or sap station id
    pSetInfoParms       - NT DLC parameter buffer
    DataBuffer          - actual set data buffer copied to the parameter buffer
    DataBufferLength    - length of the data buffer.

Return Value:

    LLC_STATUS

--*/

{
    pSetInfoParms->Header.StationId = StationId;
    pSetInfoParms->Header.InfoClass = (USHORT)InfoClass;

    if (DataBuffer != NULL) {
        RtlMoveMemory(pSetInfoParms->Info.Buffer, DataBuffer, DataBufferLength);
    }

    return DoSyncDeviceIoControl(DriverHandle,
                                 IOCTL_DLC_SET_INFORMATION,
                                 pSetInfoParms,
                                 DataBufferLength + sizeof(struct _DlcSetInfoHeader),
                                 NULL,
                                 0
                                 );
}


LLC_STATUS
DlcCallDriver(
    IN UINT AdapterNumber,
    IN UINT IoctlCommand,
    IN PVOID pInputBuffer,
    IN UINT InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    )

/*++

Routine Description:

    Function makes only the IO control call little bit simpler.

Arguments:

    AdapterNumber       - the requested adapter number (0 or 1)
    IoctlCommand        - DLC driver Ioctl code
    pInputBuffer        - input parameters
    InputBufferLength   - length of input parameters
    pOutputBuffer       - the returned data
    OutputBufferLength  - the length of the returned data

Return Value:

    LLC_STATUS

--*/

{
    NTSTATUS NtStatus;
    HANDLE driverHandle;

    EnterCriticalSection(&DriverHandlesCritSec);
    driverHandle = aDlcDriverHandles[AdapterNumber];
    LeaveCriticalSection(&DriverHandlesCritSec);

    if (driverHandle) {
        NtStatus = NtDeviceIoControlFile(driverHandle,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &GlobalIoStatus,
                                         IoctlCommand,
                                         pInputBuffer,
                                         InputBufferLength,
                                         pOutputBuffer,
                                         OutputBufferLength
                                         );
    } else {
        NtStatus = STATUS_INVALID_HANDLE;
    }

    //
    // if we get a real NT error (e.g. because the handle was invalid) then
    // convert it into an adapter closed error
    //

    if (!NT_SUCCESS(NtStatus)) {
        if ((NtStatus == STATUS_INVALID_HANDLE) || (NtStatus == STATUS_OBJECT_TYPE_MISMATCH)) {

            //
            // bad handle
            //

            return LLC_STATUS_ADAPTER_CLOSED;
        } else if (NtStatus > LLC_STATUS_MAX_ERROR) {

            //
            // the NT DLC driver does not return any NT-level errors. If we get
            // an NT-level error, then it must be because the IO subsystem
            // detected an invalid pointer in the data we passed. Return an
            // invalid pointer error
            //

            NtStatus = LLC_STATUS_INVALID_POINTER_IN_CCB;
        }
    } else if (NtStatus == STATUS_PENDING) {

        //
        // STATUS_PENDING is a success status
        //

        NtStatus = LLC_STATUS_PENDING;
    }

    return (LLC_STATUS)NtStatus;
}

#ifdef GRAB_READ

DWORD ReadGrabberCount = 2;
HANDLE ReadGrabberHandles[64];
PREAD_GRABBER ReadGrabberListHead = NULL;
PREAD_GRABBER ReadGrabberListTail = NULL;
CRITICAL_SECTION ReadGrabberListSect;

#endif


BOOLEAN
DllEntry(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    Function initializes dlc for a new thread and terminates it in the
    process exit.

Arguments:

    DllHandle   - don't need this
    Reason      - why this function is being called
    Context     - don't need this either

Return Value:

    TRUE    - nothing cannot go wrong in the initialization and
              we cannot return error in close (or should we?).

--*/

{
    static LLC_CCB OutputCcb;           // MUST BE STATIC!!!

    UNREFERENCED_PARAMETER(DllHandle);  // avoid compiler warnings
    UNREFERENCED_PARAMETER(Context);    // avoid compiler warnings

    if (Reason == DLL_PROCESS_ATTACH) {

#ifdef GRAB_READ

        DWORD threadId;

        OutputDebugString(L"DllEntry: Initializing ReadGrabber\n");
        InitializeCriticalSection(&ReadGrabberListSect);
        ReadGrabberHandles[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
        ReadGrabberHandles[1] = CreateEvent(NULL, TRUE, FALSE, NULL);
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ReadGrabber, NULL, 0, &threadId);

#endif

        //
        // The global event handle is used to prevent the io-system
        // to block calls, that are completed by READ.
        //

        InitializeCriticalSection(&AdapterOpenSection);
        InitializeCriticalSection(&DriverHandlesCritSec);
        RtlZeroMemory((PVOID)aDlcDriverHandles, sizeof(aDlcDriverHandles));

#if DBG
        GetAcslanDebugFlags();
#endif

    } else if (Reason == DLL_PROCESS_DETACH) {

        UINT i;
        LLC_CCB CloseCcb;

#ifdef GRAB_READ

        ResetEvent(ReadGrabberHandles[0]);

#endif

        //
        // We must issue DIR_CLOSE_ADAPTER command for all
        // opened adapters.  Process exit does not close these
        // handles before all pending IRPs have been completed.
        // Thus this code actually flush all IRPs on dlc and lets
        // IO- system to complete the cleanup.
        //

        RtlZeroMemory(&CloseCcb, sizeof(CloseCcb));
        CloseCcb.uchDlcCommand = LLC_DIR_CLOSE_ADAPTER;

        for (i = 0; i < LLC_MAX_ADAPTER_NUMBER; i++) {
            if (aDlcDriverHandles[i] != NULL) {
                CloseCcb.uchAdapterNumber = (UCHAR)i;
                NtDeviceIoControlFile(aDlcDriverHandles[i],
                                      NULL,
                                      NULL,
                                      NULL,
                                      &GlobalIoStatus,
                                      IOCTL_DLC_CLOSE_ADAPTER,
                                      &CloseCcb,
                                      sizeof(NT_DLC_CCB_INPUT),
                                      &OutputCcb,
                                      sizeof(NT_DLC_CCB_OUTPUT)
                                      );
            }
        }

#if DBG
        if (hDumpFile) {
            fflush(hDumpFile);
            fclose(hDumpFile);
        }
#endif

        //DeleteCriticalSection(&AdapterOpenSection);
        //DeleteCriticalSection(&DriverHandlesCritSec);
    }

    return TRUE;
}


VOID
QueueCommandCompletion(
    IN PLLC_CCB pCCB
    )

/*++

Routine Description:

    The routine queues a command completion event of a synchronous DLC command
    to the command completion queue on the DLC driver.

    RLF 04/23/93 Bogus: This should be handled in the driver

Arguments:

    pCCB - OS/2 DLC Command control block, this must be double word aligned

Return Value:

    LLC_STATUS - See the DLC API return values.

--*/

{
    NT_DLC_COMPLETE_COMMAND_PARMS CompleteCommand;
    UINT Status;

    CompleteCommand.pCcbPointer = pCCB;
    CompleteCommand.CommandCompletionFlag = pCCB->ulCompletionFlag;
    CompleteCommand.StationId = GetCcbStationId(pCCB);

    Status = DoSyncDeviceIoControl(aDlcDriverHandles[pCCB->uchAdapterNumber],
                                   IOCTL_DLC_COMPLETE_COMMAND,
                                   &CompleteCommand,
                                   sizeof(CompleteCommand),
                                   NULL,
                                   0
                                   );
    if (Status != STATUS_SUCCESS) {
        pCCB->uchDlcStatus = (UCHAR)Status;
    }
}

#ifdef GRAB_READ

PLLC_CCB Last8ReadCcbs[8];
DWORD LastReadCcbIndex = 0;

PLLC_PARMS Last8ReadParameterTables[8];
DWORD LastReadParameterTableIndex = 0;

DWORD Last8IFramesReceived[8];
DWORD LastReceivedIndex = 0;

DWORD NextIFrame = 0;

VOID ReadGrabber() {

    DWORD status;
    PLLC_CCB readCcb;
    WCHAR buf[100];
//    static DWORD NextIFrame = 0;
    PREAD_GRABBER grabbedRead;

    while (1) {
        if (ReadGrabberCount > 3) {
            wsprintf(buf, L"ReadGrabber: waiting for %d handles\n", ReadGrabberCount);
            OutputDebugString(buf);
        }
        status = WaitForMultipleObjects(ReadGrabberCount,
                                        ReadGrabberHandles,
                                        FALSE,
                                        INFINITE
                                        );
        if (status >= WAIT_OBJECT_0 && status < WAIT_OBJECT_0 + ReadGrabberCount) {
            if (status == WAIT_OBJECT_0) {
                OutputDebugString(L"ReadGrabber terminating\n");
                ExitThread(0);
            } else if (status != WAIT_OBJECT_0+1) {
//                wsprintf(buf, L"ReadGrabber: READ completed. Index %d\n", status);
//                OutputDebugString(buf);
                if (grabbedRead = RemoveReadGrabber(ReadGrabberHandles[status])) {
                    readCcb = grabbedRead->pCcb;
                    Last8ReadCcbs[LastReadCcbIndex] = readCcb;
                    LastReadCcbIndex = (LastReadCcbIndex + 1) & 7;
                    Last8ReadParameterTables[LastReadParameterTableIndex] = readCcb->u.pParameterTable;
                    LastReadParameterTableIndex = (LastReadParameterTableIndex + 1) & 7;
                    if (readCcb->u.pParameterTable->Read.uchEvent & LLC_EVENT_RECEIVE_DATA) {

                        PLLC_BUFFER pBuffer;
                        INT i;

                        if (readCcb->u.pParameterTable->Read.uchEvent != LLC_EVENT_RECEIVE_DATA) {
                            OutputDebugString(L"ReadGrabber: RECEIVED DATA + other events\n");
                        }
                        pBuffer = readCcb->u.pParameterTable->Read.Type.Event.pReceivedFrame;
                        for (i = readCcb->u.pParameterTable->Read.Type.Event.usReceivedFrameCount; i; --i) {
                            if (pBuffer->NotContiguous.uchMsgType == LLC_I_FRAME) {

                                DWORD thisDlcHeader;

                                thisDlcHeader = *(ULONG UNALIGNED*)(pBuffer->NotContiguous.auchDlcHeader);
                                if (thisDlcHeader & 0x00FF0000 != NextIFrame) {
                                    wsprintf(buf,
                                             L"Error: ReadGrabber: This=%08X. Next=%08X\n",
                                             thisDlcHeader,
                                             NextIFrame
                                             );
                                    OutputDebugString(buf);
                                }
                                NextIFrame = (thisDlcHeader + 0x00020000) & 0x00FF0000;
                                Last8IFramesReceived[LastReceivedIndex] = thisDlcHeader & 0x00FF0000;
                                LastReceivedIndex = (LastReceivedIndex + 1) & 7;
                                wsprintf(buf, L"%08X ", thisDlcHeader);
                                OutputDebugString(buf);
                            }
                            pBuffer = pBuffer->NotContiguous.pNextFrame;
                            if (!pBuffer && i > 1) {
                                OutputDebugString(L"ReadGrabber: Next frame is NULL, Count > 1!\n");
                                break;
                            }
                        }
                        if (pBuffer) {
                            OutputDebugString(L"ReadGrabber: Error: More frames linked!\n");
                        }
                    } else {
                        if (!(readCcb->u.pParameterTable->Read.uchEvent & LLC_EVENT_TRANSMIT_COMPLETION)) {
                            wsprintf(buf,
                                    L"\nReadGrabber: Event = %02X\n",
                                    readCcb->u.pParameterTable->Read.uchEvent
                                    );
                            OutputDebugString(buf);
                        }
                    }
//                    DUMPCCB(readCcb, TRUE, FALSE);
//                    wsprintf(buf, L"ReadGrabber: Closing Handle %08X\n", grabbedRead->NewEventHandle);
//                    OutputDebugString(buf);
                    CloseHandle(grabbedRead->NewEventHandle);
                    readCcb->hCompletionEvent = grabbedRead->OriginalEventHandle;
//                    wsprintf(buf, L"ReadGrabber: Signalling Event %08X\n", grabbedRead->OriginalEventHandle);
//                    OutputDebugString(buf);
                    SetEvent(grabbedRead->OriginalEventHandle);
                    LocalFree((HLOCAL)grabbedRead);
                }
//            } else {
//                OutputDebugString(L"ReadGrabber: something added to list!\n");
            }
            ReadGrabberCount = MungeReadGrabberHandles();
            if (status == WAIT_OBJECT_0+1) {
                ResetEvent(ReadGrabberHandles[1]);
            }
        } else {

            INT i;

            if (status == 0xFFFFFFFF) {
                status = GetLastError();
            }
            wsprintf(buf, L"Yoiks: didn't expect this? status = %d\nHandle array:\n", status);
            OutputDebugString(buf);

            for (i = 0; i < ReadGrabberCount; ++i) {
                wsprintf(buf, L"Handle %d: %08X\n", i, ReadGrabberHandles[i]);
                OutputDebugString(buf);
            }
        }
    }
}

DWORD MungeReadGrabberHandles() {

    INT i;
    PREAD_GRABBER p;
    WCHAR buf[100];

    EnterCriticalSection(&ReadGrabberListSect);
    p = ReadGrabberListHead;
    for (i = 2; p; ++i) {
        ReadGrabberHandles[i] = p->NewEventHandle;
//        wsprintf(buf, L"MungeReadGrabber: adding Struct %08X Ccb %08X Handle %08X, index %d\n",
//                p,
//                p->pCcb,
//                ReadGrabberHandles[i],
//                i
//                );
//        OutputDebugString(buf);
        p = p->List;
    }
    LeaveCriticalSection(&ReadGrabberListSect);
    return i;
}

VOID AddReadGrabber(PREAD_GRABBER pStruct) {

    WCHAR buf[100];
    PREAD_GRABBER pRead;
    BOOL found = FALSE;

    EnterCriticalSection(&ReadGrabberListSect);
//    for (pRead = ReadGrabberListHead; pRead; pRead = pRead->List) {
//        if (pRead->pCcb == pStruct->pCcb) {
//            wsprintf(buf, L"AddReadGrabber: CCB %08X already on list. Ignoring\n",
//                    pStruct->pCcb
//                    );
//            OutputDebugString(buf);
//            LocalFree((HLOCAL)pStruct);
//            found = TRUE;
//            break;
//        }
//    }
//    if (!found) {
        if (!ReadGrabberListHead) {
            ReadGrabberListHead = pStruct;
        } else {
            ReadGrabberListTail->List = pStruct;
        }
        ReadGrabberListTail = pStruct;
        pStruct->List = NULL;
//        wsprintf(buf, L"AddReadGrabber: adding %08X, CCB %08X New Handle %08X Old Handle %08X\n",
//                pStruct,
//                pStruct->pCcb,
//                pStruct->NewEventHandle,
//                pStruct->OriginalEventHandle
//                );
//        OutputDebugString(buf);
        SetEvent(ReadGrabberHandles[1]);
//    }
    LeaveCriticalSection(&ReadGrabberListSect);
}

PREAD_GRABBER RemoveReadGrabber(HANDLE hEvent) {

    PREAD_GRABBER this, prev;
    WCHAR buf[100];

    EnterCriticalSection(&ReadGrabberListSect);
    prev = NULL;
    for (this = ReadGrabberListHead; this; this = this->List) {
        if (this->NewEventHandle == hEvent) {
            break;
        } else {
            prev = this;
        }
    }
    if (!this) {
        wsprintf(buf, L"RemoveReadGrabber: Can't find handle %08X in ReadGrabberList\n",
                hEvent
                );
        OutputDebugString(buf);
    } else {
        if (prev) {
            prev->List = this->List;
        } else {
            ReadGrabberListHead = this->List;
        }
        if (ReadGrabberListTail == this) {
            ReadGrabberListTail = prev;
        }
    }
    LeaveCriticalSection(&ReadGrabberListSect);

//    wsprintf(buf, L"RemoveReadGrabber: removed %08X, CCB %08X Handle %08X\n",
//            this,
//            this ? this->pCcb : 0,
//            this ? this->NewEventHandle : 0
//            );
//    OutputDebugString(buf);

    return this;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\diagnostics\wmi\wmigateway.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    WmiGateway.h

Abstract:

    The file contains the the class definition for CWmiGateway. CWmiGateway is a class
    that extracts information from WMI,
    
--*/

#pragma once

#include "stdafx.h"
#ifndef WMIGATEWAY_H
#define WMIGATEWAY_H

// Defines which interface the client is using to communicate with us
//
typedef enum
{
    NO_INTERFACE    = 0,
    COM_INTERFACE   = 1,
    NETSH_INTERFACE = 2,
}INTERFACE_TYPE;

// A cache for all the repositories opened. We cache this information since it can take a long time
// to connect to a repository through WMI.
//
typedef map<wstring, CComPtr<IWbemServices> > WbemServiceCache; 

struct Property
{
public:
    void SetProperty(LPCTSTR pszwPropertyName, BOOLEAN bPropertyFlags)
    {
        if( pszwPropertyName )
        {
            pszwName = new WCHAR[lstrlen(pszwPropertyName) + 1];
            if( pszwName )
            {
                lstrcpy(pszwName,pszwPropertyName);
            }
        }
        else
        {
            pszwName = NULL;
        }
        bFlags   = bPropertyFlags;
    }



public:
    Property()
    {
        pszwName = NULL;
    }

    Property(const Property *ref):Value(ref->Value)
    {
        if( ref != this )
        {
            SetProperty(ref->pszwName,ref->bFlags);
        }
    }

    Property(const Property &ref):Value(ref.Value)
    {
        if( &ref != this )
        {
            SetProperty(ref.pszwName,ref.bFlags);
        }
    }

    Property(LPCTSTR pszwPropertyName, BOOLEAN bPropertyFlags = 0)
    {
        SetProperty(pszwPropertyName,bPropertyFlags);
    }

    void Clear()
    {
        if ( pszwName )
        {
            delete pszwName;
            pszwName = NULL;
        }

        Value.clear();
    }

    ~Property()
    {
        Clear();
    }

public:
    LPTSTR  pszwName;
    BOOLEAN bFlags;
       
    typedef vector< _variant_t > Values;

    Values Value;
};

typedef list< Property > EnumProperty;


struct WbemProperty: public Property
{
    
public:
    void SetWbemProperty(LPCTSTR pszwWbemRepository = NULL, LPCTSTR pszwWbemNamespace = NULL)
    {
        if( pszwWbemRepository != NULL )
        {
            pszwRepository = new WCHAR[lstrlen(pszwWbemRepository) + 1];
            if( pszwRepository )
            {
                lstrcpy(pszwRepository,pszwWbemRepository);
            }
        }
        else
        {
            pszwRepository = NULL;
        }

        if( pszwWbemNamespace != NULL )
        {
            pszwNamespace = new WCHAR[lstrlen(pszwWbemNamespace) + 1];
            if( pszwNamespace )
            {
                lstrcpy(pszwNamespace,pszwWbemNamespace);
            }
        }
        else
        {
            pszwNamespace = NULL;
        }
    }

public:
    WbemProperty()
    {
        pszwRepository = NULL;
        pszwNamespace = NULL;
    }

    WbemProperty(const WbemProperty * ref):Property(ref->pszwName,ref->bFlags)
    {
        if( ref != this )
        {
            SetWbemProperty(ref->pszwRepository,ref->pszwNamespace);
        }
    }
    
    WbemProperty(const WbemProperty & ref): Property(ref.pszwName,ref.bFlags)
    {
        if( &ref != this )
        {
            SetWbemProperty(ref.pszwRepository,ref.pszwNamespace);
        }
    }

    WbemProperty(LPCTSTR pszwPropertyName, BOOLEAN bPropertyFlags = 0, LPCTSTR pszwWbemRepository = NULL, LPCTSTR pszwWbemNamespace = NULL):
        Property(pszwPropertyName,bPropertyFlags)
    {
        SetWbemProperty(pszwWbemRepository,pszwWbemNamespace);
    }

    ~WbemProperty()
    {
        if ( pszwRepository )
        {
            delete pszwRepository;
        }
        if ( pszwNamespace )
        {
            delete pszwNamespace;
        }

        pszwRepository = NULL;
        pszwNamespace = NULL;

    }
    LPTSTR pszwRepository;
    LPTSTR pszwNamespace;
};


typedef list< WbemProperty > EnumWbemProperty;


class CWmiGateway
/*++

Class Description
    TBD
--*/
{
public:
    CWmiGateway();

    void SetCancelOption(HANDLE hTerminateThread)
    {
        m_hTerminateThread = hTerminateThread;
        m_bTerminate = FALSE;
    }

inline BOOL CWmiGateway::ShouldTerminate();

private:
    HANDLE m_hTerminateThread;
    BOOL m_bTerminate;
    wstring m_wstrMachine;

public:
    BOOL WbemInitialize(INTERFACE_TYPE bInterface);

    VOID SetMachine(WCHAR *pszwMachine);
    void EmptyCache();

    IWbemServices * 
    GetWbemService(
            IN LPCTSTR pszService
            );

    IEnumWbemClassObject * 
    GetEnumWbemClassObject(
            IN LPCTSTR pszwService,
            IN LPCTSTR pszwNameSpace
            );

    IWbemClassObject * 
    GetWbemClassObject(
            IN LPCTSTR   pszwService,
            IN LPCTSTR   pszwNameSpace,
            IN const int nInstance = 0
            );

HRESULT 
CWmiGateway::GetWbemProperties(     
        IN OUT  EnumWbemProperty &EnumProp
        );

void 
ReleaseAll(
        IN IEnumWbemClassObject *pEnumWbemClassObject, 
        IN IWbemClassObject *pWbemClassObject[], 
        IN int nInstance
        );

    ~CWmiGateway();

    wstring m_wstrWbemError;
private:
    IWbemLocator     *m_pWbemLocater;
    WbemServiceCache m_WbemServiceCache; 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\api\dlcdll.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    dlcdll.h

Abstract:

    This module incldes all files needed to compile
    the NT DLC DLL API module.

Author:

    Antti Saarenheimo (o-anttis) 20-09-1991

Revision History:

--*/

//
// System APIs:
//

#include <nt.h>

#ifndef OS2_EMU_DLC

#include <ntrtl.h>
#include <nturtl.h>

#if !defined(UNICODE)
#define UNICODE                         // want wide character registry functions
#endif

#include <windows.h>
#include <winreg.h>
#define INCLUDE_IO_BUFFER_SIZE_TABLE    // includes the io buffer sizes

#endif  // OS2_EMU_DLC

#include <memory.h>
#include <stdlib.h>
#include <stdio.h>

//
// Inlcude the smb macros to handle the unaligned dos ccb and parameter tables
//

#include <smbgtpt.h>

//
// NT DLC API interface files:
//

#include <dlcapi.h>                     // Official DLC API definition
#include <ntdddlc.h>                    // IOCTL commands
#include <dlcio.h>                      // Internal IOCTL API interface structures

//
// Local types and function prototypes:
//

typedef
VOID
(*PFDLC_POST_ROUTINE)(
    IN PVOID hApcContext,
    IN PLLC_CCB pCcb
    );

#define SUPPORT_DEBUG_NAMES     0

//
// In DOS the adapter number and NetBIOS command use the same
// byte in CCB/NCB data structure.
// The smallest NetBIOS command is NCB.CALL (10H), which limits
// the maximum adapter numbers 0 - 15 in DOS (and Windows NT)
// The extra adapter numbers above 15 may be used as extra
// alternate adapter handles to extend the number of available
// link stations.  Only the first instance of a SAP can receive
// remote connect requests.
//

#define LLC_MAX_ADAPTER_NUMBER  255
#define LLC_MAX_ADAPTERS        16

#define TR_16Mbps_LINK_SPEED    0x1000000

VOID
QueueCommandCompletion(
    PLLC_CCB pCCB
    );
VOID
InitializeAcsLan(
    VOID
    );
LLC_STATUS
OpenDlcApiDriver(
    IN PVOID SecurityDescriptor,
    OUT HANDLE *pHandle
    );
LLC_STATUS
GetAdapterNameAndParameters(
    IN UINT AdapterNumber,
    OUT PUNICODE_STRING pNdisName,
    OUT PUCHAR pTicks,
    OUT PLLC_ETHERNET_TYPE pLlcEthernetType
    );
VOID
CopyAsciiStringToUnicode(
    IN PUNICODE_STRING  pUnicodeDest,
    IN PSZ              pAsciiSrc
    );
VOID
BuildDescriptorList(
    IN PLLC_TRANSMIT_DESCRIPTOR pDescriptor,
    IN PLLC_CCB pCCB,
    IN OUT PUINT pCurrentDescriptor
    );
LLC_STATUS
DoSyncDeviceIoControl(
    IN HANDLE DeviceHandle,
    IN ULONG IoctlCommand,
    IN PVOID pInputBuffer,
    IN UINT InputBufferLength,
    OUT PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    );
LLC_STATUS
DlcGetInfo(
    IN HANDLE DriverHandle,
    IN UINT InfoClass,
    IN USHORT StationId,
    IN PVOID pOutputBuffer,
    IN UINT OutputBufferLength
    );
VOID
CopyToDescriptorBuffer(
    IN OUT PLLC_TRANSMIT_DESCRIPTOR pDescriptors,
    IN PLLC_BUFFER pDlcBufferQueue,
    IN BOOLEAN DeallocateBufferAfterUse,
    IN OUT PUINT pIndex,
    IN OUT PLLC_BUFFER *ppLastBuffer,
    OUT LLC_STATUS *pStatus
    );
LLC_STATUS
DlcSetInfo(
    IN HANDLE DriverHandle,
    IN UINT InfoClass,
    IN USHORT StationId,
    IN PNT_DLC_SET_INFORMATION_PARMS pSetInfoParms,
    IN PVOID DataBuffer,
    IN UINT DataBufferLength
    );

USHORT
GetCcbStationId(
    IN PLLC_CCB pCCB
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    dlc.h

Abstract:

    This module incldes all files needed to compile
    the NT DLC driver.

Author:

    Antti Saarenheimo (o-anttis) 20-09-1991

Revision History:

--*/

#ifndef DLC_INCLUDED
#define DLC_INCLUDED

#include <ntddk.h>
#include <ndis.h>

#include <ntdddlc.h>

#undef APIENTRY
#define APIENTRY

#include <dlcapi.h>
#include <dlcio.h>
#include <llcapi.h>

#include <dlcdef.h>
#include <dlctyp.h>
#include <dlcext.h>

#include "dlcreg.h"

#include <memory.h>         // prototype for inline memcpy

#include "llc.h"

#endif  // DLC_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dbgmsg.h ===
/*++

 Copyright (c) 1998 Microsoft Corporation

 Module Name:    
       
       dbgmsg.h

 Abstract:       
       
       Debug message macros and zones.
       
 Author:
 
       Scott Holden (sholden)  2/8/1999
       
 Revision History:

--*/

#if DBG

extern  int DbgSettings;

#define DEBUGZONE(n)  (DbgSettings & (0x00000001<<n))

#define DEBUGMSG(dbgs,format) ((dbgs) ? DbgPrint format:0)

#define DBG_INIT                DEBUGZONE(0)
#define DBG_NDIS_OPEN           DEBUGZONE(1)
#define DBG_NDIS_BIND           DEBUGZONE(2)
#define DBG_NDIS_TX             DEBUGZONE(3)
#define DBG_NDIS_RX             DEBUGZONE(4)

#define DBG_REF                 DEBUGZONE(28)
#define DBG_VERBOSE             DEBUGZONE(29)
#define DBG_WARN                DEBUGZONE(30)
#define DBG_ERROR               DEBUGZONE(31)

#else

#define DEBUGMSG(d,f)   (0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\api\dlcdebug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcdebug.c

Abstract:

    CCB dump routines for NT-level CCB

    Contents:
        GetAcslanDebugFlags
        SetAcslanDebugFlags
        AcslanDebugPrint
        AcslanDebugPrintString
        DumpCcb
        MapCcbRetcode
        DumpData
        (DefaultParameterTableDump)
        (DumpParameterTableHeader)
        (DumpBufferCreateParms)
        (DumpBufferFreeParms)
        (DumpBufferGetParms)
        (DumpDirInitializeParms)
        (DumpDirOpenAdapterParms)
        (MapEthernetType)
        (DumpDirOpenDirectParms)
        (DumpDirReadLogParms)
        (MapLogType)
        (DumpDirSetExceptionFlagsParms)
        (DumpDirSetFunctionalAddressParms)
        (DumpDirSetGroupAddressParms)
        (DumpDirStatusParms)
        (MapAdapterType)
        (DumpDirTimerCancelParms)
        (DumpDirTimerCancelGroupParms)
        (DumpDirTimerSetParms)
        (DumpDlcCloseSapParms)
        (DumpDlcCloseStationParms)
        (DumpDlcConnectStationParms)
        (DumpDlcFlowControlParms)
        (MapFlowControl)
        (DumpDlcModifyParms)
        (DumpDlcOpenSapParms)
        (DumpDlcOpenStationParms)
        (DumpDlcReallocateParms)
        (DumpDlcResetParms)
        (DumpDlcSetThresholdParms)
        (DumpDlcStatisticsParms)
        (DumpReadParms)
        (MapOptionIndicator)
        (MapReadEvent)
        (MapDlcStatus)
        (DumpReadCancelParms)
        (DumpReceiveParms)
        (MapRcvReadOption)
        (MapReceiveOptions)
        (DumpReceiveCancelParms)
        (DumpReceiveModifyParms)
        (DumpTransmitDirFrameParms)
        (DumpTransmitIFrameParms)
        (DumpTransmitTestCmdParms)
        (DumpTransmitUiFrameParms)
        (DumpTransmitXidCmdParms)
        (DumpTransmitXidRespFinalParms)
        (DumpTransmitXidRespNotFinalParms)
        (DumpTransmitFramesParms)
        (DumpTransmitParms)
        (DumpTransmitQueue)
        DumpReceiveDataBuffer
        (MapMessageType)

Author:

    Richard L Firth (rfirth) 28-May-1992

Revision History:

--*/

#if DBG

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <dlcapi.h>     // Official DLC API definition
#include "dlcdebug.h"

//
// defines
//

#define DBGDBG  0

//
// macros
//

//
// HEX_TO_NUM - converts an ASCII hex character (0-9A-Fa-f) to corresponding
// number (0-15). Assumes c is hexadecimal digit on input
//

#define HEX_TO_NUM(c)   ((c) - ('0' + (((c) <= '9') ? 0 : ((islower(c) ? 'a' : 'A') - ('9' + 1)))))

//
// local prototypes
//

VOID
AcslanDebugPrintString(
    IN LPSTR String
    );

PRIVATE
VOID
DefaultParameterTableDump(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpParameterTableHeader(
    IN LPSTR CommandName,
    IN PVOID Table
    );

PRIVATE
VOID
DumpBufferCreateParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpBufferFreeParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpBufferGetParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirInitializeParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirOpenAdapterParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapEthernetType(
    IN LLC_ETHERNET_TYPE EthernetType
    );

PRIVATE
VOID
DumpDirOpenDirectParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirReadLogParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapLogType(
    IN USHORT Type
    );

PRIVATE
VOID
DumpDirSetExceptionFlagsParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirSetFunctionalAddressParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirSetGroupAddressParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirStatusParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapAdapterType(
    IN USHORT AdapterType
    );

PRIVATE
VOID
DumpDirTimerCancelParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirTimerCancelGroupParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirTimerSetParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcCloseSapParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcCloseStationParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcConnectStationParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcFlowControlParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapFlowControl(
    IN BYTE FlowControl
    );

PRIVATE
VOID
DumpDlcModifyParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcOpenSapParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcOpenStationParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcReallocateParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcResetParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcSetThresholdParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcStatisticsParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpReadParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapOptionIndicator(
    IN UCHAR OptionIndicator
    );

PRIVATE
LPSTR
MapReadEvent(
    UCHAR Event
    );

PRIVATE
LPSTR
MapDlcStatus(
    WORD Status
    );

PRIVATE
VOID
DumpReadCancelParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpReceiveParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapReceiveOptions(
    IN UCHAR Options
    );

PRIVATE
LPSTR
MapRcvReadOption(
    IN UCHAR Option
    );

PRIVATE
VOID
DumpReceiveCancelParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpReceiveModifyParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitDirFrameParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitIFrameParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitTestCmdParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitUiFrameParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitXidCmdParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitXidRespFinalParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitXidRespNotFinalParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitFramesParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitQueue(
    IN PLLC_XMIT_BUFFER Buffer
    );

PRIVATE
LPSTR
MapXmitReadOption(
    IN UCHAR Option
    );

VOID
DumpReceiveDataBuffer(
    IN PVOID Buffer
    );

PRIVATE
LPSTR
MapMessageType(
    UCHAR MessageType
    );

//
// explanations of error codes returned in CCB_RETCODE fields. Explanations
// taken more-or-less verbatim from IBM Local Area Network Technical Reference
// table B-1 ppB-2 to B-5. Includes all errors
//

static LPSTR CcbRetcodeExplanations[] = {
    "Success",
    "Invalid command code",
    "Duplicate command, one already outstanding",
    "Adapter open, should be closed",
    "Adapter closed, should be open",
    "Required parameter missing",
    "Invalid/incompatible option",
    "Command cancelled - unrecoverable failure",
    "Unauthorized access priority",
    "Adapter not initialized, should be",
    "Command cancelled by user request",
    "Command cancelled, adapter closed while command in progress",
    "Command completed Ok, adapter not open",
    "Invalid error code 0x0D",
    "Invalid error code 0x0E",
    "Invalid error code 0x0F",
    "Adapter open, NetBIOS not operational",
    "Error in DIR.TIMER.SET or DIR.TIMER.CANCEL",
    "Available work area exceeded",
    "Invalid LOG.ID",
    "Invalid shared RAM segment or size",
    "Lost log data, buffer too small, log reset",
    "Requested buffer size exceeds pool length",
    "Command invalid, NetBIOS operational",
    "Invalid buffer length",
    "Inadequate buffers available for request",
    "The CCB_PARM_TAB pointer is invalid",
    "A pointer in the CCB parameter table is invalid",
    "Invalid CCB_ADAPTER value",
    "Invalid functional address",
    "Invalid error code 0x1F",
    "Lost data on receive, no buffers available",
    "Lost data on receive, inadequate buffer space",
    "Error on frame transmission, check TRANSMIT.FS data",
    "Error on frame transmit or strip process",
    "Unauthorized MAC frame",
    "Maximum commands exceeded",
    "Unrecognized command correlator",
    "Link not transmitting I frames, state changed from link opened",
    "Invalid transmit frame length",
    "Invalid error code 0x29",
    "Invalid error code 0x2a",
    "Invalid error code 0x2b",
    "Invalid error code 0x2c",
    "Invalid error code 0x2d",
    "Invalid error code 0x2e",
    "Invalid error code 0x2f",
    "Inadequate receive buffers for adapter to open",
    "Invalid error code 0x31",
    "Invalid NODE_ADDRESS",
    "Invalid adapter receive buffer length defined",
    "Invalid adapter transmit buffer length defined",
    "Invalid error code 0x35",
    "Invalid error code 0x36",
    "Invalid error code 0x37",
    "Invalid error code 0x38",
    "Invalid error code 0x39",
    "Invalid error code 0x3a",
    "Invalid error code 0x3b",
    "Invalid error code 0x3c",
    "Invalid error code 0x3d",
    "Invalid error code 0x3e",
    "Invalid error code 0x3f",
    "Invalid STATION_ID",
    "Protocol error, link in invalid state for command",
    "Parameter exceeded maximum allowed",
    "Invalid SAP value or value already in use",
    "Invalid routing information field",
    "Requested group membership in non-existent group SAP",
    "Resources not available",
    "Sap cannot close unless all link stations are closed",
    "Group SAP cannot close, individual SAPs not closed",
    "Group SAP has reached maximum membership",
    "Sequence error, incompatible command in progress",
    "Station closed without remote acknowledgement",
    "Sequence error, cannot close, DLC commands outstanding",
    "Unsuccessful link station connection attempted",
    "Member SAP not found in group SAP list",
    "Invalid remote address, may not be a group address",
    "Invalid pointer in CCB_POINTER field",
    "Invalid error code 0x51",
    "Invalid application program ID",
    "Invalid application program key code",
    "Invalid system key code",
    "Buffer is smaller than buffer size given in DLC.OPEN.SAP",
    "Adapter's system process is not installed",
    "Inadequate stations available",
    "Invalid CCB_PARAMETER_1 parameter",
    "Inadequate queue elements to satisfy request",
    "Initialization failure, cannot open adapter",
    "Error detected in chained READ command",
    "Direct stations not assigned to application program",
    "Dd interface not installed",
    "Requested adapter is not installed",
    "Chained CCBs must all be for same adapter",
    "Adapter initializing, command not accepted",
    "Number of allowed application programs has been exceeded",
    "Command cancelled by system action",
    "Direct stations not available",
    "Invalid DDNAME parameter",
    "Inadequate GDT selectors to satisfy request",
    "Invalid error code 0x66",
    "Command cancelled, CCB resources purged",
    "Application program ID not valid for interface",
    "Segment associated with request cannot be locked",
    "Invalid error code 0x6a",
    "Invalid error code 0x6b",
    "Invalid error code 0x6c",
    "Invalid error code 0x6d",
    "Invalid error code 0x6e",
    "Invalid error code 0x6f",
    "Invalid error code 0x70",
    "Invalid error code 0x71",
    "Invalid error code 0x72",
    "Invalid error code 0x73",
    "Invalid error code 0x74",
    "Invalid error code 0x75",
    "Invalid error code 0x76",
    "Invalid error code 0x77",
    "Invalid error code 0x78",
    "Invalid error code 0x79",
    "Invalid error code 0x7a",
    "Invalid error code 0x7b",
    "Invalid error code 0x7c",
    "Invalid error code 0x7d",
    "Invalid error code 0x7e",
    "Invalid error code 0x7f",
    "Invalid buffer address",
    "Buffer already released",
    "Invalid error code 0x82",
    "Invalid error code 0x83",
    "Invalid error code 0x84",
    "Invalid error code 0x85",
    "Invalid error code 0x86",
    "Invalid error code 0x87",
    "Invalid error code 0x88",
    "Invalid error code 0x89",
    "Invalid error code 0x8a",
    "Invalid error code 0x8b",
    "Invalid error code 0x8c",
    "Invalid error code 0x8d",
    "Invalid error code 0x8e",
    "Invalid error code 0x8f",
    "Invalid error code 0x90",
    "Invalid error code 0x91",
    "Invalid error code 0x92",
    "Invalid error code 0x93",
    "Invalid error code 0x94",
    "Invalid error code 0x95",
    "Invalid error code 0x96",
    "Invalid error code 0x97",
    "Invalid error code 0x98",
    "Invalid error code 0x99",
    "Invalid error code 0x9a",
    "Invalid error code 0x9b",
    "Invalid error code 0x9c",
    "Invalid error code 0x9d",
    "Invalid error code 0x9e",
    "Invalid error code 0x9f",
    "BIND error",
    "Invalid version",
    "NT Error status"
};

#define NUMBER_OF_ERROR_MESSAGES    ARRAY_ELEMENTS(CcbRetcodeExplanations)
#define LAST_DLC_ERROR_CODE         LAST_ELEMENT(CcbRetcodeExplanations)

//
// preset the debug flags to nothing, or to whatever is defined at compile-time
//

DWORD   AcslanDebugFlags = ACSLAN_DEBUG_FLAGS;
FILE*   hDumpFile = NULL;
BYTE    AcslanDumpCcb[LLC_MAX_DLC_COMMAND];
BOOL    HaveCcbFilter = FALSE;

VOID
GetAcslanDebugFlags(
    VOID
    )

/*++

Routine Description:

    This routine is called whenever we have a DLL_PROCESS_ATTACH to the DLL

    checks if there is an environment variable called ACSLAN_DEBUG_FLAGS, and
    loads whatever it finds (as a 32-bit hex number) into AcslanDebugFlags

    checks if there is an environment variable called ACSLAN_DUMP_FILE. If
    there is, then output which otherwise would have gone to the terminal
    goes to the file. The file is opened in "w" mode by default - open for
    write. Current file is destroyed if it exists

    If there is an environment variable called ACSLAN_DUMP_FILTER then this is
    loaded into the AcslanDumpCcb array. This is a string of numbers, the
    position of which corresponds to the CCB command. For each position, 1
    means dump the CCB and 2 means dump the CCB and its parameters. This is an
    additional filter control over that contained in ACSLAN_DEBUG_FLAGS which
    allows control on a per CCB basis. Example:

        ACSLAN_DUMP_CCB=1x0221

    means:

        for CCB 0 (DIR.INTERRUPT) dump the CCB only (no parameter table anyway)
                1 (???) don't do anything (x==0)
                2 (???) don't do anything (x==0)
                3 (DIR.OPEN.ADAPTER) dump the CCB and parameter table
                4 (DIR.CLOSE.ADAPTER) dump the CCB and parameter table
                    (no parameter table, doesn't matter)
                5 (DIR.SET.MULTICAST.ADDRESS) dump the CCB

    etc. We currently recognize up to CCB command 0x36 (54, PURGE.RESOURCES)

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPSTR envVar;
    SYSTEMTIME systemTime;

    if (envVar = getenv(ACSLAN_DEBUG_ENV_VAR)) {
        if (!_strnicmp(envVar, "0x", 2)) {
            envVar += 2;
        }
        for (AcslanDebugFlags = 0; isxdigit(*envVar); ++envVar) {
            AcslanDebugFlags = AcslanDebugFlags * 16 + HEX_TO_NUM(*envVar);
//                + (*envVar
//                    - ('0' + ((*envVar <= '9') ? 0
//                        : ((islower(*envVar) ? 'a' : 'A') - ('9' + 1)))));
        }
    }

    if (envVar = getenv(ACSLAN_DUMP_FILE_VAR)) {

        char* comma;
        static char openMode[3] = "w";

        if (comma = strchr(envVar, ',')) {
            strcpy(openMode, comma+1);
            *comma = 0;
        }
        if ((hDumpFile = fopen(envVar, openMode)) == NULL) {
            DbgPrint("Error: can't create dump file %s\n", envVar);
        } else {
            AcslanDebugFlags |= DEBUG_TO_FILE;
            AcslanDebugFlags &= ~DEBUG_TO_TERMINAL;
        }
    }


#if DBGDBG
    IF_DEBUG(DLL_INFO) {
        PUT(("GetAcslanDebugFlags: AcslanDebugFlags = %#x\n", AcslanDebugFlags));
    }
#endif

    if (envVar = getenv(ACSLAN_DUMP_FILTER_VAR)) {

        int i, len;
        BYTE ch;

        if (strlen(envVar) > sizeof(AcslanDumpCcb) - 1) {

            //
            // if there's too much info then inform the debugger but set up the
            // string anyway
            //

            PUT(("GetAcslanDebugFlags: Error: ACSLAN_DUMP_CCB variable too long: \"%s\"\n", envVar));
            strncpy(AcslanDumpCcb, envVar, sizeof(AcslanDumpCcb) - 1);
            AcslanDumpCcb[sizeof(AcslanDumpCcb) - 1] = 0;
        } else {
            strcpy(AcslanDumpCcb, envVar);
        }

#if DBGDBG
        IF_DEBUG(DLL_INFO) {
            PUT(("GetAcslanDebugFlags: AcslanDumpCcb = %s\n", AcslanDumpCcb));
        }
#endif

        //
        // if there are less characters in the string than CCB commands then
        // default the rest of the commands
        //

        len = strlen(AcslanDumpCcb);
        for (i = len; i < sizeof(AcslanDumpCcb); ++i) {
            AcslanDumpCcb[i] = 0xff;
        }
        AcslanDumpCcb[i] = 0;

        //
        // convert the ASCII characters to numbers
        //

        for (i = 0; i < len; ++i) {
            ch = AcslanDumpCcb[i];
            if (isxdigit(ch)) {
                ch = HEX_TO_NUM(ch);
            } else {
                ch = (BYTE)0xff;
            }
            AcslanDumpCcb[i] = ch;

#if DBGDBG
            PUT(("Command %d: filter=%02x\n", i, ch));
#endif

        }

        HaveCcbFilter = TRUE;
    }

    IF_DEBUG(DLL_INFO) {
        GetSystemTime(&systemTime);
        PUT(("PROCESS STARTED @ %02d:%02d:%02d\n",
            systemTime.wHour, systemTime.wMinute, systemTime.wSecond
            ));
    }
}

VOID
SetAcslanDebugFlags(
    IN DWORD Flags
    )
{
    AcslanDebugFlags = Flags;
}

VOID
AcslanDebugPrint(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Print the debug information to the terminal or debug terminal, depending
    on DEBUG_TO_TERMINAL flag (0x80000000)

Arguments:

    Format  - printf/DbgPrint style format string (ANSI)
    ...     - optional parameters

Return Value:

    None.

--*/

{
    char printBuffer[1024];
    va_list list;

    va_start(list, Format);
    vsprintf(printBuffer, Format, list);

    IF_DEBUG(TO_FILE) {
        fputs(printBuffer, hDumpFile);
    } else IF_DEBUG(TO_TERMINAL) {
        printf(printBuffer);
    } else {
        DbgPrint(printBuffer);
    }
}

VOID
AcslanDebugPrintString(
    IN LPSTR String
    )

/*++

Routine Description:

    Print the debug information to the terminal or debug terminal, depending
    on DEBUG_TO_TERMINAL flag (0x80000000)

Arguments:

    String  - formatted string (ANSI)

Return Value:

    None.

--*/

{
    IF_DEBUG(TO_FILE) {
        fputs(String, hDumpFile);
    } else IF_DEBUG(TO_TERMINAL) {
        printf(String);
    } else {
        DbgPrint(String);
    }
}

VOID
DumpCcb(
    IN PLLC_CCB Ccb,
    IN BOOL DumpAll,
    IN BOOL CcbIsInput
    )

/*++

Routine Description:

    Dumps a CCB and any associated parameter table. Also displays the symbolic
    CCB command and an error code description if the CCB is being returned to
    the caller. Dumps NT format CCBs (flat 32-bit pointers)

Arguments:

    Ccb         - flat 32-bit pointer to CCB2 to dump
    DumpAll     - if TRUE, dumps parameter tables and buffers, else just CCB
    CcbIsInput  - if TRUE, CCB is from user: don't display error code explanation

Return Value:

    None.

--*/

{
    LPSTR   cmdname = "UNKNOWN CCB!";
    BOOL    haveParms = FALSE;
    VOID    (*DumpParms)(PVOID) = DefaultParameterTableDump;
    PVOID   parameterTable = NULL;
    BOOL    parmsInCcb = FALSE;
    BYTE    command;
    DWORD   numberOfTicks;
    BOOL    ccbIsBad = FALSE;
    BOOL    dumpInputParms = TRUE;
    BOOL    dumpOutputParms = TRUE;

    static DWORD LastTicks;
    static BOOL FirstTimeFunctionCalled = TRUE;

    try {
        command = Ccb->uchDlcCommand;
    } except(1) {
        ccbIsBad = TRUE;
    }

    //
    // bomb out if we get a bad CCB address
    //

    if (ccbIsBad) {
        PUT(("*** Error: Bad Address for CCB @ %08x ***\n", Ccb));
        return;
    }

#if DBGDBG
    PUT(("DumpCcb(%x, %d, %d)\n", Ccb, DumpAll, CcbIsInput));
#endif

    IF_DEBUG(DUMP_TIME) {

        DWORD ticksNow = GetTickCount();

        if (FirstTimeFunctionCalled) {
            numberOfTicks = 0;
            FirstTimeFunctionCalled = FALSE;
        } else {
            numberOfTicks = ticksNow - LastTicks;
        }
        LastTicks = ticksNow;
    }

    switch (command) {
    case LLC_BUFFER_CREATE:
        cmdname = "BUFFER.CREATE";
        haveParms = TRUE;
        DumpParms = DumpBufferCreateParms;
        break;

    case LLC_BUFFER_FREE:
        cmdname = "BUFFER.FREE";
        haveParms = TRUE;
        DumpParms = DumpBufferFreeParms;
        break;

    case LLC_BUFFER_GET:
        cmdname = "BUFFER.GET";
        haveParms = TRUE;
        DumpParms = DumpBufferGetParms;
        break;

    case LLC_DIR_CLOSE_ADAPTER:
        cmdname = "DIR.CLOSE.ADAPTER";
        haveParms = FALSE;
        break;

    case LLC_DIR_CLOSE_DIRECT:
        cmdname = "DIR.CLOSE.DIRECT";
        haveParms = FALSE;
        break;

    case LLC_DIR_INITIALIZE:
        cmdname = "DIR.INITIALIZE";
        haveParms = TRUE;
        DumpParms = DumpDirInitializeParms;
        break;

    case LLC_DIR_INTERRUPT:
        cmdname = "DIR.INTERRUPT";
        haveParms = FALSE;
        break;

    case LLC_DIR_OPEN_ADAPTER:
        cmdname = "DIR.OPEN.ADAPTER";
        haveParms = TRUE;
        DumpParms = DumpDirOpenAdapterParms;
        break;

    case LLC_DIR_OPEN_DIRECT:
        cmdname = "DIR.OPEN.DIRECT";
        haveParms = TRUE;
        DumpParms = DumpDirOpenDirectParms;
        break;

    case LLC_DIR_READ_LOG:
        cmdname = "DIR.READ.LOG";
        haveParms = TRUE;
        DumpParms = DumpDirReadLogParms;
        break;

    case LLC_DIR_SET_EXCEPTION_FLAGS:
        cmdname = "DIR.SET.EXCEPTION.FLAGS";
        haveParms = TRUE;
        DumpParms = DumpDirSetExceptionFlagsParms;
        break;

    case LLC_DIR_SET_FUNCTIONAL_ADDRESS:
        cmdname = "DIR.SET.FUNCTIONAL.ADDRESS";
        haveParms = TRUE;
        DumpParms = DumpDirSetFunctionalAddressParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_SET_GROUP_ADDRESS:
        cmdname = "DIR.SET.GROUP.ADDRESS";
        haveParms = TRUE;
        DumpParms = DumpDirSetGroupAddressParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_STATUS:
        cmdname = "DIR.STATUS";
        haveParms = TRUE;
        DumpParms = DumpDirStatusParms;
        break;

    case LLC_DIR_TIMER_CANCEL:
        cmdname = "DIR.TIMER.CANCEL";
        haveParms = TRUE;
        DumpParms = DumpDirTimerCancelParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_TIMER_CANCEL_GROUP:
        cmdname = "DIR.TIMER.CANCEL.GROUP";
        haveParms = TRUE;
        DumpParms = DumpDirTimerCancelGroupParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_TIMER_SET:
        cmdname = "DIR.TIMER.SET";
        haveParms = TRUE;
        DumpParms = DumpDirTimerSetParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_CLOSE_SAP:
        cmdname = "DLC.CLOSE.SAP";
        haveParms = TRUE;
        DumpParms = DumpDlcCloseSapParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_CLOSE_STATION:
        cmdname = "DLC.CLOSE.STATION";
        haveParms = TRUE;
        DumpParms = DumpDlcCloseStationParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_CONNECT_STATION:
        cmdname = "DLC.CONNECT.STATION";
        haveParms = TRUE;
        DumpParms = DumpDlcConnectStationParms;
        break;

    case LLC_DLC_FLOW_CONTROL:
        cmdname = "DLC.FLOW.CONTROL";
        haveParms = TRUE;
        DumpParms = DumpDlcFlowControlParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_MODIFY:
        cmdname = "DLC.MODIFY";
        haveParms = TRUE;
        DumpParms = DumpDlcModifyParms;
        break;

    case LLC_DLC_OPEN_SAP:
        cmdname = "DLC.OPEN.SAP";
        haveParms = TRUE;
        DumpParms = DumpDlcOpenSapParms;
        break;

    case LLC_DLC_OPEN_STATION:
        cmdname = "DLC.OPEN.STATION";
        haveParms = TRUE;
        DumpParms = DumpDlcOpenStationParms;
        break;

    case LLC_DLC_REALLOCATE_STATIONS:
        cmdname = "DLC.REALLOCATE";
        haveParms = TRUE;
        DumpParms = DumpDlcReallocateParms;
        break;

    case LLC_DLC_RESET:
        cmdname = "DLC.RESET";
        break;

    case LLC_DLC_SET_THRESHOLD:
        cmdname = "DLC.SET.THRESHOLD";
        haveParms = TRUE;
        break;

    case LLC_DLC_STATISTICS:
        cmdname = "DLC.STATISTICS";
        haveParms = TRUE;
        DumpParms = DumpDlcStatisticsParms;
        break;

    case 0x25:

        //
        // not supported !
        //

        cmdname = "PDT.TRACE.OFF";
        break;

    case 0x24:

        //
        // not supported !
        //

        cmdname = "PDT.TRACE.ON";
        break;

    case LLC_READ:
        cmdname = "READ";
        haveParms = !CcbIsInput;
        DumpParms = DumpReadParms;
        dumpInputParms = FALSE;
        dumpOutputParms = !CcbIsInput && Ccb->uchDlcStatus == LLC_STATUS_SUCCESS;
        break;

    case LLC_READ_CANCEL:
        cmdname = "READ.CANCEL";
        break;

    case LLC_RECEIVE:
        cmdname = "RECEIVE";
        haveParms = TRUE;
        DumpParms = DumpReceiveParms;
        break;

    case LLC_RECEIVE_CANCEL:
        cmdname = "RECEIVE.CANCEL";
        haveParms = TRUE;
        DumpParms = DumpReceiveCancelParms;
        parmsInCcb = TRUE;
        break;

    case LLC_RECEIVE_MODIFY:
        cmdname = "RECEIVE.MODIFY";
        haveParms = TRUE;
        break;

    case LLC_TRANSMIT_FRAMES:
        cmdname = "TRANSMIT.FRAMES";
        haveParms = TRUE;
        DumpParms = DumpTransmitFramesParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_DIR_FRAME:
        cmdname = "TRANSMIT.DIR.FRAME";
        haveParms = TRUE;
        DumpParms = DumpTransmitDirFrameParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_I_FRAME:
        cmdname = "TRANSMIT.I.FRAME";
        haveParms = TRUE;
        DumpParms = DumpTransmitIFrameParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_TEST_CMD:
        cmdname = "TRANSMIT.TEST.CMD";
        haveParms = TRUE;
        DumpParms = DumpTransmitTestCmdParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_UI_FRAME:
        cmdname = "TRANSMIT.UI.FRAME";
        haveParms = TRUE;
        DumpParms = DumpTransmitUiFrameParms;
        break;

    case LLC_TRANSMIT_XID_CMD:
        cmdname = "TRANSMIT.XID.CMD";
        haveParms = TRUE;
        DumpParms = DumpTransmitXidCmdParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_XID_RESP_FINAL:
        cmdname = "TRANSMIT.XID.RESP.FINAL";
        haveParms = TRUE;
        DumpParms = DumpTransmitXidRespFinalParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_XID_RESP_NOT_FINAL:
        cmdname = "TRANSMIT.XID.RESP.NOT.FINAL";
        haveParms = TRUE;
        DumpParms = DumpTransmitXidRespNotFinalParms;
        dumpOutputParms = FALSE;
        break;

    }

    if (HaveCcbFilter) {

        BYTE filter = AcslanDumpCcb[command];

#if DBGDBG
        PUT(("filter = %02x\n", filter));
#endif

        if (filter == 0xff) {

            //
            // do nothing - 0xff means use default in ACSLAN_DEBUG_FLAGS
            //

        } else {
            if (CcbIsInput) {
                if (!(filter & CF_DUMP_CCB_IN)) {

                    //
                    // not interested in this input CCB
                    //

                    return;
                }
                DumpAll = filter & CF_DUMP_PARMS_IN;
            } else {
                if (!(filter & CF_DUMP_CCB_OUT)) {

                    //
                    // not interested in this output CCB
                    //

                    return;
                }
                DumpAll = filter & CF_DUMP_PARMS_OUT;
            }
        }
    }

    PUT(("\n==============================================================================\n"));

    IF_DEBUG(DUMP_TIME) {
        PUT(("%sPUT CCB @ 0x%08x +%d mSec\n",
            CcbIsInput ? "IN" : "OUT",
            Ccb,
            numberOfTicks
            ));
    } else {
        PUT(("%sPUT CCB @ 0x%08x\n",
            CcbIsInput ? "IN" : "OUT",
            Ccb
            ));
    }

    PUT(("Adapter . . . . %02x\n"
        "Command . . . . %02x [%s]\n"
        "Status. . . . . %02x [%s]\n"
        "Reserved. . . . %02x\n"
        "Next. . . . . . %08x\n"
        "CompletionFlag. %08x\n",
        Ccb->uchAdapterNumber,
        Ccb->uchDlcCommand,
        cmdname,
        Ccb->uchDlcStatus,
        CcbIsInput ? "" : MapCcbRetcode(Ccb->uchDlcStatus),
        Ccb->uchReserved1,
        Ccb->pNext,
        Ccb->ulCompletionFlag
        ));

    if (haveParms) {
        if (parmsInCcb) {
            DumpParms(Ccb->u.pParameterTable);
        } else {
            parameterTable = Ccb->u.pParameterTable;
            PUT(("Parameters. . . %08x\n", parameterTable));
        }
    } else {
        PUT(("Parameters. . . %08x\n", Ccb->u.pParameterTable));
    }

    PUT(("CompletionEvent %08x\n"
        "Reserved. . . . %02x\n"
        "ReadFlag. . . . %02x\n"
        "Reserved. . . . %04x\n",
        Ccb->hCompletionEvent,
        Ccb->uchReserved2,
        Ccb->uchReadFlag,
        Ccb->usReserved3
        ));

    if (parameterTable && DumpAll) {
        if ((CcbIsInput && dumpInputParms) || (!CcbIsInput && dumpOutputParms)) {
            DumpParms(parameterTable);
        }
    }
}

LPSTR
MapCcbRetcode(
    IN  BYTE    Retcode
    )

/*++

Routine Description:

    Returns string describing error code

Arguments:

    Retcode - CCB_RETCODE

Return Value:

    LPSTR

--*/

{
    static char errbuf[128];

    if (Retcode == LLC_STATUS_PENDING) {
        return "Command in progress";
    } else if (Retcode > NUMBER_OF_ERROR_MESSAGES) {
        sprintf(errbuf, "*** Invalid error code 0x%2x ***", Retcode);
        return errbuf;
    }
    return CcbRetcodeExplanations[Retcode];
}

VOID
DumpData(
    IN LPSTR Title,
    IN PBYTE Address,
    IN DWORD Length,
    IN DWORD Options,
    IN DWORD Indent
    )
{
    char dumpBuf[80];
    char* bufptr;
    int i, n, iterations;
    char* hexptr;

    //
    // the usual dump style: 16 columns of hex bytes, followed by 16 columns
    // of corresponding ASCII characters, or '.' where the character is < 0x20
    // (space) or > 0x7f (del?)
    //

    if (Options & DD_LINE_BEFORE) {
        AcslanDebugPrintString("\n");
    }

    try {
        iterations = 0;
        while (Length) {
            bufptr = dumpBuf;
            if (Title && !iterations) {
                strcpy(bufptr, Title);
                bufptr = strchr(bufptr, 0);
            }

            if (Indent && ((Options & DD_INDENT_ALL) || iterations)) {

                int indentLen = (!iterations && Title)
                                    ? ((INT)(Indent - strlen(Title)) < 0)
                                        ? 1
                                        : Indent - strlen(Title)
                                    : Indent;

                memset(bufptr, ' ', indentLen);
                bufptr += indentLen;
            }

            if (!(Options & DD_NO_ADDRESS)) {
                bufptr += sprintf(bufptr, "%p: ", Address);
            }

            n = (Length < 16) ? Length : 16;
            hexptr = bufptr;
            for (i = 0; i < n; ++i) {
                bufptr += sprintf(bufptr, "%02x", Address[i]);
                *bufptr++ = (i == 7) ? '-' : ' ';
            }

            if (Options & DD_UPPER_CASE) {
                _strupr(hexptr);
            }

            if (!(Options & DD_NO_ASCII)) {
                if (n < 16) {
                    for (i = 0; i < 16-n; ++i) {
                        bufptr += sprintf(bufptr, Options & DD_DOT_DOT_SPACE ? ".. " : "   ");
                    }
                }
                bufptr += sprintf(bufptr, "  ");
                for (i = 0; i < n; ++i) {
                    *bufptr++ = (Address[i] < 0x20 || Address[i] > 0x7f) ? '.' : Address[i];
                }
            }

            *bufptr++ = '\n';
            *bufptr = 0;
            AcslanDebugPrintString(dumpBuf);
            Length -= n;
            Address += n;
            ++iterations;
        }

        if (Options & DD_LINE_AFTER) {
            AcslanDebugPrintString("\n");
        }
    } except(1) {
        PUT(("*** Error: Bad Data @ %x, length %d ***\n", Address, Length));
    }
}

PRIVATE
VOID
DefaultParameterTableDump(
    IN  PVOID   Parameters
    )

/*++

Routine Description:

    Displays default message for CCBs which have parameter tables that don't
    have a dump routine yet

Arguments:

    Parameters  - pointer to parameter table

Return Value:

    None.

--*/

{
    PUT(("Parameter table dump not implemented for this CCB\n"));
}

PRIVATE
VOID
DumpParameterTableHeader(
    IN  LPSTR   CommandName,
    IN  PVOID   Table
    )

/*++

Routine Description:

    Displays header for parameter table dump

Arguments:

    CommandName - name of command which owns parameter table
    Table       - flat 32-bit address of parameter table

Return Value:

    None.

--*/

{
    PUT(("\n%s parameter table @ 0x%08x\n", CommandName, Table));
}

PRIVATE
VOID
DumpBufferCreateParms(
    IN PVOID Parameters
    )
{
    PLLC_BUFFER_CREATE_PARMS parms = (PLLC_BUFFER_CREATE_PARMS)Parameters;

    DumpParameterTableHeader("BUFFER.CREATE", Parameters);

    PUT(("Buf Pool Handle %08x\n"
        "Buf Pool Addr . %08x\n"
        "Buffer Size . . %08x\n"
        "Minimum Size. . %08x\n",
        parms->hBufferPool,
        parms->pBuffer,
        parms->cbBufferSize,
        parms->cbMinimumSizeThreshold
        ));
}

PRIVATE
VOID
DumpBufferFreeParms(
    IN  PVOID   Parameters
    )
{
    PLLC_BUFFER_FREE_PARMS parms = (PLLC_BUFFER_FREE_PARMS)Parameters;

    DumpParameterTableHeader("BUFFER.FREE", Parameters);

    PUT(("reserved. . . . %04x\n"
        "buffers left. . %04x\n"
        "reserved. . . . %02x %02x %02x %02x\n"
        "first buffer. . %08x\n",
        parms->usReserved1,
        parms->cBuffersLeft,
        ((PBYTE)&(parms->ulReserved))[0],
        ((PBYTE)&(parms->ulReserved))[1],
        ((PBYTE)&(parms->ulReserved))[2],
        ((PBYTE)&(parms->ulReserved))[3],
        parms->pFirstBuffer
        ));
}

PRIVATE
VOID
DumpBufferGetParms(
    IN  PVOID   Parameters
    )
{
    PLLC_BUFFER_GET_PARMS parms = (PLLC_BUFFER_GET_PARMS)Parameters;

    DumpParameterTableHeader("BUFFER.GET", Parameters);

    PUT(("reserved. . . . %04x\n"
        "buffers left. . %04x\n"
        "buffers to get. %04x\n"
        "buffer size . . %04x\n"
        "first buffer. . %08x\n",
        parms->usReserved1,
        parms->cBuffersLeft,
        parms->cBuffersToGet,
        parms->cbBufferSize,
        parms->pFirstBuffer
        ));
}

PRIVATE
VOID
DumpDirInitializeParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DIR_INITIALIZE_PARMS parms = (PLLC_DIR_INITIALIZE_PARMS)Parameters;

    DumpParameterTableHeader("DIR.INITIALIZE", Parameters);

    PUT(("Bring Ups . . . %04x\n"
        "Reserved. . . . %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"
        "                %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"
        "                %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
        parms->usBringUps,
        parms->Reserved[ 0],
        parms->Reserved[ 1],
        parms->Reserved[ 2],
        parms->Reserved[ 3],
        parms->Reserved[ 4],
        parms->Reserved[ 5],
        parms->Reserved[ 6],
        parms->Reserved[ 7],
        parms->Reserved[ 8],
        parms->Reserved[ 9],
        parms->Reserved[10],
        parms->Reserved[11],
        parms->Reserved[12],
        parms->Reserved[13],
        parms->Reserved[14],
        parms->Reserved[15],
        parms->Reserved[16],
        parms->Reserved[17],
        parms->Reserved[18],
        parms->Reserved[19],
        parms->Reserved[20],
        parms->Reserved[21],
        parms->Reserved[22],
        parms->Reserved[23],
        parms->Reserved[24],
        parms->Reserved[25],
        parms->Reserved[26],
        parms->Reserved[27],
        parms->Reserved[28],
        parms->Reserved[29]
        ));
}

PRIVATE
VOID
DumpDirOpenAdapterParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DIR_OPEN_ADAPTER_PARMS parms = (PLLC_DIR_OPEN_ADAPTER_PARMS)Parameters;
    PLLC_ADAPTER_OPEN_PARMS pAdapterParms = parms->pAdapterParms;
    PLLC_EXTENDED_ADAPTER_PARMS pExtendedParms = parms->pExtendedParms;
    PLLC_DLC_PARMS pDlcParms = parms->pDlcParms;

    DumpParameterTableHeader("DIR.OPEN.ADAPTER", Parameters);

    PUT(("adapter parms . %08x\n"
        "extended parms. %08x\n"
        "DLC parms . . . %08x\n"
        "reserved. . . . %08x\n",
        pAdapterParms,
        pExtendedParms,
        pDlcParms,
        parms->pReserved1
        ));

    if (pAdapterParms) {
        PUT(("\n"
            "Adapter Parms @ %08x\n"
            "open error. . . %04x\n"
            "open options. . %04x\n"
            "node address. . %02x-%02x-%02x-%02x-%02x-%02x\n"
            "group address . %08x\n"
            "func. address . %08x\n"
            "Reserved 1. . . %04x\n"
            "Reserved 2. . . %04x\n"
            "max frame size  %04x\n"
            "Reserved 3. . . %04x %04x %04x %04x\n"
            "bring ups . . . %04x\n"
            "init warnings . %04x\n"
            "Reserved 4. . . %04x %04x %04x\n",
            pAdapterParms,
            pAdapterParms->usOpenErrorCode,
            pAdapterParms->usOpenOptions,
            pAdapterParms->auchNodeAddress[0],
            pAdapterParms->auchNodeAddress[1],
            pAdapterParms->auchNodeAddress[2],
            pAdapterParms->auchNodeAddress[3],
            pAdapterParms->auchNodeAddress[4],
            pAdapterParms->auchNodeAddress[5],
            *(DWORD UNALIGNED *)(&pAdapterParms->auchGroupAddress),
            *(DWORD UNALIGNED *)(&pAdapterParms->auchFunctionalAddress),
            pAdapterParms->usReserved1,
            pAdapterParms->usReserved2,
            pAdapterParms->usMaxFrameSize,
            pAdapterParms->usReserved3[0],
            pAdapterParms->usReserved3[1],
            pAdapterParms->usReserved3[2],
            pAdapterParms->usReserved3[3],
            pAdapterParms->usBringUps,  // blooargh
            pAdapterParms->InitWarnings,
            pAdapterParms->usReserved4[0],
            pAdapterParms->usReserved4[1],
            pAdapterParms->usReserved4[2]
            ));
    }

    if (pExtendedParms) {
        PUT(("\n"
            "Extended Parms @ %08x\n"
            "hBufferPool . . %08x\n"
            "pSecurityDesc . %08x\n"
            "EthernetType. . %08x [%s]\n",
            pExtendedParms,
            pExtendedParms->hBufferPool,
            pExtendedParms->pSecurityDescriptor,
            pExtendedParms->LlcEthernetType,
            MapEthernetType(pExtendedParms->LlcEthernetType)
            ));
    }

    if (pDlcParms) {
        PUT(("\n"
            "DLC Parms @ %08x\n"
            "max SAPs. . . . %02x\n"
            "max links . . . %02x\n"
            "max group SAPs. %02x\n"
            "max group membs %02x\n"
            "T1 Tick 1 . . . %02x\n"
            "T2 Tick 1 . . . %02x\n"
            "Ti Tick 1 . . . %02x\n"
            "T1 Tick 2 . . . %02x\n"
            "T2 Tick 2 . . . %02x\n"
            "Ti Tick 2 . . . %02x\n",
            pDlcParms,
            pDlcParms->uchDlcMaxSaps,
            pDlcParms->uchDlcMaxStations,
            pDlcParms->uchDlcMaxGroupSaps,
            pDlcParms->uchDlcMaxGroupMembers,
            pDlcParms->uchT1_TickOne,
            pDlcParms->uchT2_TickOne,
            pDlcParms->uchTi_TickOne,
            pDlcParms->uchT1_TickTwo,
            pDlcParms->uchT2_TickTwo,
            pDlcParms->uchTi_TickTwo
            ));
    }
}

PRIVATE
LPSTR
MapEthernetType(
    IN LLC_ETHERNET_TYPE EthernetType
    )
{
    switch (EthernetType) {
    case LLC_ETHERNET_TYPE_DEFAULT:
        return "DEFAULT";

    case LLC_ETHERNET_TYPE_AUTO:
        return "AUTO";

    case LLC_ETHERNET_TYPE_802_3:
        return "802.3";

    case LLC_ETHERNET_TYPE_DIX:
        return "DIX";
    }
    return "*** Unknown Ethernet Type ***";
}

PRIVATE
VOID
DumpDirOpenDirectParms(
    IN PVOID Parameters
    )
{
    PLLC_DIR_OPEN_DIRECT_PARMS parms = (PLLC_DIR_OPEN_DIRECT_PARMS)Parameters;

    DumpParameterTableHeader("DIR.OPEN.DIRECT", Parameters);

    PUT(("reserved. . . . %04x %04x %04x %04x\n"
        "open options. . %04x\n"
        "ethernet type . %04x\n"
        "protocol mask . %08x\n"
        "protocol match. %08x\n"
        "protocol offset %04x\n",
        parms->Reserved[0],
        parms->Reserved[1],
        parms->Reserved[2],
        parms->Reserved[3],
        parms->usOpenOptions,
        parms->usEthernetType,
        parms->ulProtocolTypeMask,
        parms->ulProtocolTypeMatch,
        parms->usProtocolTypeOffset
        ));
}

PRIVATE
VOID
DumpDirReadLogParms(
    IN PVOID Parameters
    )
{
    PLLC_DIR_READ_LOG_PARMS parms = (PLLC_DIR_READ_LOG_PARMS)Parameters;

    DumpParameterTableHeader("DIR.READ.LOG", Parameters);

    PUT(("type id . . . . %04x [%s]\n"
        "log buf len . . %04x\n"
        "log buf ptr . . %08x\n"
        "act. log. len.. %04x\n",
        parms->usTypeId,
        MapLogType(parms->usTypeId),
        parms->cbLogBuffer,
        parms->pLogBuffer,
        parms->cbActualLength
        ));
}

PRIVATE
LPSTR
MapLogType(
    IN USHORT Type
    )
{
    switch (Type) {
    case 0:
        return "Adapter Error Log";

    case 1:
        return "Direct Interface Error Log";

    case 2:
        return "Adapter & Direct Interface Error Logs";
    }
    return "*** Unknown Log Type ***";
}

PRIVATE
VOID
DumpDirSetExceptionFlagsParms(
    IN PVOID Parameters
    )
{
    PLLC_DIR_SET_EFLAG_PARMS parms = (PLLC_DIR_SET_EFLAG_PARMS)Parameters;

    DumpParameterTableHeader("DIR.SET.EXCEPTION.FLAGS", Parameters);

    PUT(("Adapter Check Flag. %08x\n"
        "Network Status Flag %08x\n"
        "PC Error Flag . . . %08x\n"
        "System Action Flag. %08x\n",
        parms->ulAdapterCheckFlag,
        parms->ulNetworkStatusFlag,
        parms->ulPcErrorFlag,
        parms->ulSystemActionFlag
        ));
}

PRIVATE
VOID
DumpDirSetFunctionalAddressParms(
    IN PVOID Parameters
    )
{
    PUT(("Functional addr %08x\n", Parameters));
}

PRIVATE
VOID
DumpDirSetGroupAddressParms(
    IN PVOID Parameters
    )
{
    PUT(("Group addr. . . %08x\n", Parameters));
}

PRIVATE
VOID
DumpDirStatusParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DIR_STATUS_PARMS parms = (PLLC_DIR_STATUS_PARMS)Parameters;

    DumpParameterTableHeader("DIR.STATUS", Parameters);

    PUT(("perm node addr. %02x-%02x-%02x-%02x-%02x-%02x\n"
        "local node addr %02x-%02x-%02x-%02x-%02x-%02x\n"
        "group addr. . . %08lx\n"
        "functional addr %08lx\n"
        "max SAPs. . . . %02x\n"
        "open SAPs . . . %02x\n"
        "max stations. . %02x\n"
        "open stations . %02x\n"
        "avail stations. %02x\n"
        "adapter config. %02x\n"
        "reserved 1. . . %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x\n"
        "reserved 2. . . %08x\n"
        "reserved 3. . . %08x\n"
        "max frame len . %08x\n"
        "last NW status. %04x\n"
        "adapter type. . %04x [%s]\n",
        parms->auchPermanentAddress[0],
        parms->auchPermanentAddress[1],
        parms->auchPermanentAddress[2],
        parms->auchPermanentAddress[3],
        parms->auchPermanentAddress[4],
        parms->auchPermanentAddress[5],
        parms->auchNodeAddress[0],
        parms->auchNodeAddress[1],
        parms->auchNodeAddress[2],
        parms->auchNodeAddress[3],
        parms->auchNodeAddress[4],
        parms->auchNodeAddress[5],
        *(LPDWORD)(&parms->auchGroupAddress),
        *(LPDWORD)(&parms->auchFunctAddr),
        parms->uchMaxSap,
        parms->uchOpenSaps,
        parms->uchMaxStations,
        parms->uchOpenStation,
        parms->uchAvailStations,
        parms->uchAdapterConfig,
        parms->auchReserved1[0],
        parms->auchReserved1[1],
        parms->auchReserved1[2],
        parms->auchReserved1[3],
        parms->auchReserved1[4],
        parms->auchReserved1[5],
        parms->auchReserved1[6],
        parms->auchReserved1[7],
        parms->auchReserved1[8],
        parms->auchReserved1[9],
        parms->ulReserved1,
        parms->ulReserved2,
        parms->ulMaxFrameLength,
        parms->usLastNetworkStatus,
        parms->usAdapterType,
        MapAdapterType(parms->usAdapterType)
        ));
}

PRIVATE
LPSTR
MapAdapterType(
    IN USHORT AdapterType
    )
{
    switch (AdapterType) {
    case 0x0001:
        return "Token Ring Network PC Adapter";

    case 0x0002:
        return "Token Ring Network PC Adapter II";

    case 0x0004:
        return "Token Ring Network Adapter/A";

    case 0x0008:
        return "Token Ring Network PC Adapter II";

    case 0x0020:
        return "Token Ring Network 16/4 Adapter";

    case 0x0040:
        return "Token Ring Network 16/4 Adapter/A";

    case 0x0080:
        return "Token Ring Network Adapter/A";

    case 0x0100:
        return "Ethernet Adapter";

    case 0x4000:
        return "PC Network Adapter";

    case 0x8000:
        return "PC Network Adapter/A";
    }
    return "*** Unknown Adapter Type ***";
}

PRIVATE
VOID
DumpDirTimerCancelParms(
    IN PVOID Parameters
    )
{
    PUT(("timer addr. . . %08x\n", Parameters));
}

PRIVATE
VOID
DumpDirTimerCancelGroupParms(
    IN PVOID Parameters
    )
{
    PUT(("timer cmpl flag %08x\n", Parameters));
}

PRIVATE
VOID
DumpDirTimerSetParms(
    IN PVOID Parameters
    )
{
    PUT(("time value. . . %04x\n", HIWORD(Parameters)));
}

PRIVATE
VOID
DumpDlcCloseSapParms(
    IN PVOID Parameters
    )
{
    PUT(("station id      %04x\n"
        "reserved. . . . %02x %02x\n",
        HIWORD(Parameters),
        HIBYTE(LOWORD(Parameters)),
        LOBYTE(LOWORD(Parameters))
        ));
}

PRIVATE
VOID
DumpDlcCloseStationParms(
    IN PVOID Parameters
    )
{
    PUT(("station id. . . %04x\n"
        "reserved. . . . %02x %02x\n",
        HIWORD(Parameters),
        HIBYTE(LOWORD(Parameters)),
        LOBYTE(LOWORD(Parameters))
        ));
}

PRIVATE
VOID
DumpDlcConnectStationParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DLC_CONNECT_PARMS parms = (PLLC_DLC_CONNECT_PARMS)Parameters;
    LPBYTE routing = parms->pRoutingInfo;
    int i, n;

    DumpParameterTableHeader("DLC.CONNECT.STATION", Parameters);

    PUT(("station id. . . %04x\n"
        "reserved. . . . %04x\n"
        "routing addr. . %08x [",
        parms->usStationId,
        parms->usReserved,
        routing
        ));
    if (routing) {
        n = (int)(routing[0] & 0x1f);
        for (i=0; i<n-1; ++i) {
            PUT(("%02x ", routing[i]));
        }
        PUT(("%02x", routing[i]));
    }
    PUT(("]\n"));
    if (routing) {
        char broadcastIndicators = routing[0] & 0xe0;
        char length = routing[0] & 0x1f;
        char direction = routing[1] & 0x80;
        char largestFrame = routing[1] & 0x70;
        PUT(("Routing Info Description: "));
        if ((broadcastIndicators & 0x80) == 0) {
            PUT(("Non Broadcast "));
        } else if ((broadcastIndicators & 0xc0) == 0x80) {
            PUT(("All Routes Broadcast "));
        } else if ((broadcastIndicators & 0xc0) == 0xc0) {
            PUT(("Single Route Broadcast "));
        }
        PUT(("Length = %d ", length));
        if (direction) {
            PUT(("interpret right-to-left "));
        } else {
            PUT(("interpret left-to-right "));
        }
        switch (largestFrame) {
        case 0x00:
            PUT(("<= 516 bytes in I-field "));
            break;

        case 0x10:
            PUT(("<= 1500 bytes in I-field "));
            break;

        case 0x20:
            PUT(("<= 2052 bytes in I-field "));
            break;

        case 0x30:
            PUT(("<= 4472 bytes in I-field "));
            break;

        case 0x40:
            PUT(("<= 8144 bytes in I-field "));
            break;

        case 0x50:
            PUT(("<= 11407 bytes in I-field "));
            break;

        case 0x60:
            PUT(("<= 17800 bytes in I-field "));
            break;

        case 0x70:
            PUT(("All-Routes Broadcast Frame "));
            break;

        }
        PUT(("\n"));
    }
}

PRIVATE
VOID
DumpDlcFlowControlParms(
    IN PVOID Parameters
    )
{
    PUT(("station id. . . %04x\n"
        "flow control. . %02x [%s]\n",
        HIWORD(Parameters),
        HIBYTE(LOWORD(Parameters)),
        MapFlowControl(HIBYTE(LOWORD(Parameters)))
        ));
}

PRIVATE
LPSTR
MapFlowControl(
    IN BYTE FlowControl
    )
{
    if (FlowControl & 0x80) {
        if (FlowControl & 0x40) {
            return "RESET LOCAL BUSY - BUFFER";
        } else {
            return "RESET LOCAL BUSY - USER";
        }
    } else {
        return "Enter LOCAL BUSY state";
    }
}

PRIVATE
VOID
DumpDlcModifyParms(
    IN PVOID Parameters
    )
{
    PLLC_DLC_MODIFY_PARMS parms = (PLLC_DLC_MODIFY_PARMS)Parameters;

    DumpParameterTableHeader("DLC.MODIFY", Parameters);

    PUT(("reserved. . . . %04x\n"
        "station id. . . %04x\n"
        "timer T1. . . . %02x\n"
        "timer T2. . . . %02x\n"
        "timer Ti. . . . %02x\n"
        "maxout. . . . . %02x\n"
        "maxin . . . . . %02x\n"
        "maxout incr . . %02x\n"
        "max retry count %02x\n"
        "reserved. . . . %02x\n"
        "max info field. %02x\n"
        "access priority %02x\n"
        "reserved. . . . %02x %02x %02x %02x\n"
        "group count . . %02x\n"
        "group list. . . %08x ",
        parms->usRes,
        parms->usStationId,
        parms->uchT1,
        parms->uchT2,
        parms->uchTi,
        parms->uchMaxOut,
        parms->uchMaxIn,
        parms->uchMaxOutIncr,
        parms->uchMaxRetryCnt,
        parms->uchReserved1,
        parms->usMaxInfoFieldLength,
        parms->uchAccessPriority,
        parms->auchReserved3[0],
        parms->auchReserved3[1],
        parms->auchReserved3[2],
        parms->auchReserved3[3],
        parms->cGroupCount,
        parms->pGroupList
        ));

    if (parms->pGroupList) {
        DumpData(NULL,
                 parms->pGroupList,
                 parms->cGroupCount,
                 DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE,
                 DEFAULT_FIELD_WIDTH + 8 + 1
                 );
    }

    PUT(("\n"));
}

PRIVATE
VOID
DumpDlcOpenSapParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DLC_OPEN_SAP_PARMS parms = (PLLC_DLC_OPEN_SAP_PARMS)Parameters;

    DumpParameterTableHeader("DLC.OPEN.SAP", Parameters);

    PUT(("station id. . . %04x\n"
        "user stat . . . %04x\n"
        "T1. . . . . . . %02x\n"
        "T2. . . . . . . %02x\n"
        "Ti. . . . . . . %02x\n"
        "max out . . . . %02x\n"
        "max in  . . . . %02x\n"
        "max out incr. . %02x\n"
        "max retry count %02x\n"
        "max members . . %02x\n"
        "max I field . . %04x\n"
        "SAP value . . . %02x\n"
        "options/pri . . %02x\n"
        "link count. . . %02x\n"
        "reserved. . . . %02x %02x\n"
        "group count . . %02x\n"
        "group list. . . %08x\n"
        "status flags. . %08x\n"
        "reserved. . . . %02x %02x %02x %02x %02x %02x %02x %02x\n"
        "links available %02x\n",
        parms->usStationId,
        parms->usUserStatValue,
        parms->uchT1,
        parms->uchT2,
        parms->uchTi,
        parms->uchMaxOut,
        parms->uchMaxIn,
        parms->uchMaxOutIncr,
        parms->uchMaxRetryCnt,
        parms->uchMaxMembers,
        parms->usMaxI_Field,
        parms->uchSapValue,
        parms->uchOptionsPriority,
        parms->uchcStationCount,
        parms->uchReserved2[0],
        parms->uchReserved2[1],
        parms->cGroupCount,
        parms->pGroupList,
        parms->DlcStatusFlags,
        parms->uchReserved3[0],
        parms->uchReserved3[1],
        parms->uchReserved3[2],
        parms->uchReserved3[3],
        parms->uchReserved3[4],
        parms->uchReserved3[5],
        parms->uchReserved3[6],
        parms->uchReserved3[7],
        parms->cLinkStationsAvail
        ));
}

PRIVATE
VOID
DumpDlcOpenStationParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DLC_OPEN_STATION_PARMS parms = (PLLC_DLC_OPEN_STATION_PARMS)Parameters;
    LPBYTE dest = parms->pRemoteNodeAddress;
    char destAddr[19];

    DumpParameterTableHeader("DLC.OPEN.STATION", Parameters);

    destAddr[0] = 0;
    if (dest) {
        sprintf(destAddr, "%02x-%02x-%02x-%02x-%02x-%02x",
                dest[0],
                dest[1],
                dest[2],
                dest[3],
                dest[4],
                dest[5]
                );
    }
    PUT(("SAP station . . %04x\n"
        "link station. . %04x\n"
        "T1. . . . . . . %02x\n"
        "T2. . . . . . . %02x\n"
        "Ti. . . . . . . %02x\n"
        "max out . . . . %02x\n"
        "max in. . . . . %02x\n"
        "max out incr. . %02x\n"
        "max retry count %02x\n"
        "remote SAP. . . %02x\n"
        "max I field . . %04x\n"
        "access priority %02x\n"
        "remote node . . %08x [%s]\n",
        parms->usSapStationId,
        parms->usLinkStationId,
        parms->uchT1,
        parms->uchT2,
        parms->uchTi,
        parms->uchMaxOut,
        parms->uchMaxIn,
        parms->uchMaxOutIncr,
        parms->uchMaxRetryCnt,
        parms->uchRemoteSap,
        parms->usMaxI_Field,
        parms->uchAccessPriority,
        dest,
        destAddr
        ));
}

PRIVATE
VOID
DumpDlcReallocateParms(
    IN PVOID Parameters
    )
{
    PLLC_DLC_REALLOCATE_PARMS parms = (PLLC_DLC_REALLOCATE_PARMS)Parameters;

    DumpParameterTableHeader("DLC.REALLOCATE", Parameters);

    PUT(("station id. . . %04x\n"
        "option. . . . . %02x [%screase link stations]\n"
        "station count . %02x\n"
        "adapter stns. . %02x\n"
        "SAP stations. . %02x\n"
        "adapter total . %02x\n"
        "SAP total . . . %02x\n",
        parms->usStationId,
        parms->uchOption,
        parms->uchOption & 0x80 ? "De" : "In",
        parms->uchStationCount,
        parms->uchStationsAvailOnAdapter,
        parms->uchStationsAvailOnSap,
        parms->uchTotalStationsOnAdapter,
        parms->uchTotalStationsOnSap
        ));
}

PRIVATE
VOID
DumpDlcResetParms(
    IN PVOID Parameters
    )
{
    PUT(("station id. . . %04x\n", HIWORD(Parameters)));
}

PRIVATE
VOID
DumpDlcSetThresholdParms(
    IN PVOID Parameters
    )
{
    PLLC_DLC_SET_THRESHOLD_PARMS parms = (PLLC_DLC_SET_THRESHOLD_PARMS)Parameters;

    DumpParameterTableHeader("DLC.SET.THRESHOLD", Parameters);

    PUT(("station id. . . %04x\n"
        "buf threshold . %04x\n"
        "event . . . . . %08x\n",
        parms->usStationId,
        parms->cBufferThreshold,
        parms->AlertEvent
        ));
}

PRIVATE
VOID
DumpDlcStatisticsParms(
    IN PVOID Parameters
    )
{
    PLLC_DLC_STATISTICS_PARMS parms = (PLLC_DLC_STATISTICS_PARMS)Parameters;

    DumpParameterTableHeader("DLC.STATISTICS", Parameters);

    PUT(("station id. . . %04x\n"
        "log buf size. . %04x\n"
        "log buffer. . . %08x\n"
        "actual log len. %04x\n"
        "options . . . . %02x [%s]\n",
        parms->usStationId,
        parms->cbLogBufSize,
        parms->pLogBuf,
        parms->usActLogLength,
        parms->uchOptions,
        parms->uchOptions & 0x80 ? "Reset counters" : ""
        ));
}

PRIVATE
VOID
DumpReadParms(
    IN PVOID Parameters
    )
{
    PLLC_READ_PARMS parms = (PLLC_READ_PARMS)Parameters;

    DumpParameterTableHeader("READ", Parameters);

    try {
        PUT(("station id. . . %04x\n"
            "option ind. . . %02x [%s]\n"
            "event set . . . %02x\n"
            "event . . . . . %02x [%s]\n"
            "crit. subset. . %02x\n"
            "notify flag . . %08x\n",
            parms->usStationId,
            parms->uchOptionIndicator,
            MapOptionIndicator(parms->uchOptionIndicator),
            parms->uchEventSet,
            parms->uchEvent,
            MapReadEvent(parms->uchEvent),
            parms->uchCriticalSubset,
            parms->ulNotificationFlag
            ));

        //
        // rest of table interpreted differently depending on whether status change
        //

        if (parms->uchEvent & 0x38) {
            PUT(("station id. . . %04x\n"
                "status code . . %04x [%s]\n"
                "FRMR data . . . %02x %02x %02x %02x %02x\n"
                "access pri. . . %02x\n"
                "remote addr . . %02x-%02x-%02x-%02x-%02x-%02x\n"
                "remote SAP. . . %02x\n"
                "reserved. . . . %02x\n"
                "user stat . . . %04x\n",
                parms->Type.Status.usStationId,
                parms->Type.Status.usDlcStatusCode,
                MapDlcStatus(parms->Type.Status.usDlcStatusCode),
                parms->Type.Status.uchFrmrData[0],
                parms->Type.Status.uchFrmrData[1],
                parms->Type.Status.uchFrmrData[2],
                parms->Type.Status.uchFrmrData[3],
                parms->Type.Status.uchFrmrData[4],
                parms->Type.Status.uchAccessPritority,
                parms->Type.Status.uchRemoteNodeAddress[0],
                parms->Type.Status.uchRemoteNodeAddress[1],
                parms->Type.Status.uchRemoteNodeAddress[2],
                parms->Type.Status.uchRemoteNodeAddress[3],
                parms->Type.Status.uchRemoteNodeAddress[4],
                parms->Type.Status.uchRemoteNodeAddress[5],
                parms->Type.Status.uchRemoteSap,
                parms->Type.Status.uchReserved,
                parms->Type.Status.usUserStatusValue
                ));
        } else {
            PUT(("CCB count . . . %04x\n"
                "CCB list. . . . %08x\n"
                "buffer count. . %04x\n"
                "buffer list . . %08x\n"
                "frame count . . %04x\n"
                "frame list. . . %08x\n"
                "error code. . . %04x\n"
                "error data. . . %04x %04x %04x\n",
                parms->Type.Event.usCcbCount,
                parms->Type.Event.pCcbCompletionList,
                parms->Type.Event.usBufferCount,
                parms->Type.Event.pFirstBuffer,
                parms->Type.Event.usReceivedFrameCount,
                parms->Type.Event.pReceivedFrame,
                parms->Type.Event.usEventErrorCode,
                parms->Type.Event.usEventErrorData[0],
                parms->Type.Event.usEventErrorData[1],
                parms->Type.Event.usEventErrorData[2]
                ));

            IF_DEBUG(DUMP_ASYNC_CCBS) {
                if (parms->Type.Event.usCcbCount) {
                    DumpCcb(parms->Type.Event.pCcbCompletionList,
                            TRUE,   // DumpAll
                            FALSE   // CcbIsInput
                            );
                }
            }

            IF_DEBUG(DUMP_RX_INFO) {
                if (parms->Type.Event.usReceivedFrameCount) {
                    DumpReceiveDataBuffer(parms->Type.Event.pReceivedFrame);
                }
            }
        }
    } except(1) {
        PUT(("*** Error: Bad READ Parameter Table @ %x ***\n", parms));
    }
}

PRIVATE
LPSTR
MapOptionIndicator(
    IN UCHAR OptionIndicator
    )
{
    switch (OptionIndicator) {
    case 0:
        return "Match READ command using station id nnss";

    case 1:
        return "Match READ command using SAP number nn00";

    case 2:
        return "Match READ command using all events";
    }
    return "*** Unknown READ Option Indicator ***";
}

PRIVATE LPSTR MapReadEvent(UCHAR Event) {
    switch (Event) {
    case 0x80:
        return "Reserved Event!";

    case 0x40:
        return "System Action (non-critical)";

    case 0x20:
        return "Network Status (non-critical)";

    case 0x10:
        return "Critical Exception";

    case 0x8:
        return "DLC Status Change";

    case 0x4:
        return "Receive Data";

    case 0x2:
        return "Transmit Completion";

    case 0x1:
        return "Command Completion";
    }
    return "*** Unknown READ Event ***";
}

PRIVATE LPSTR MapDlcStatus(WORD Status) {
    if (Status & 0x8000) {
        return "Link lost";
    } else if (Status & 0x4000) {
        return "DM/DISC Received -or- DISC ack'd";
    } else if (Status & 0x2000) {
        return "FRMR Received";
    } else if (Status & 0x1000) {
        return "FRMR Sent";
    } else if (Status & 0x0800) {
        return "SABME Received for open link station";
    } else if (Status & 0x0400) {
        return "SABME Received - link station opened";
    } else if (Status & 0x0200) {
        return "REMOTE Busy Entered";
    } else if (Status & 0x0100) {
        return "REMOTE Busy Left";
    } else if (Status & 0x0080) {
        return "Ti EXPIRED";
    } else if (Status & 0x0040) {
        return "DLC counter overflow - issue DLC.STATISTICS";
    } else if (Status & 0x0020) {
        return "Access Priority lowered";
    } else if (Status & 0x001e) {
        return "*** ERROR - INVALID STATUS ***";
    } else if (Status & 0x0001) {
        return "Entered LOCAL Busy";
    }
    return "*** Unknown DLC Status ***";
}

PRIVATE
VOID
DumpReadCancelParms(
    IN PVOID Parameters
    )
{
}

PRIVATE
VOID
DumpReceiveParms(
    IN  PVOID   Parameters
    )
{
    PLLC_RECEIVE_PARMS parms = (PLLC_RECEIVE_PARMS)Parameters;

    DumpParameterTableHeader("RECEIVE", Parameters);

    PUT(("station id. . . %04x\n"
        "user length . . %04x\n"
        "receive flag. . %08x\n"
        "first buffer. . %08x\n"
        "options . . . . %02x [%s]\n"
        "reserved. . . . %02x %02x %02x\n"
        "rcv read optns. %02x [%s]\n",
        parms->usStationId,
        parms->usUserLength,
        parms->ulReceiveFlag,
        parms->pFirstBuffer,
        parms->uchOptions,
        MapReceiveOptions(parms->uchOptions),
        parms->auchReserved1[0],
        parms->auchReserved1[1],
        parms->auchReserved1[2],
        parms->uchRcvReadOption,
        MapRcvReadOption(parms->uchRcvReadOption)
        ));
}

PRIVATE
LPSTR
MapReceiveOptions(
    IN UCHAR Options
    )
{
    static char buf[80];
    BOOL space = FALSE;

    buf[0] = 0;
    if (Options & 0x80) {
        strcat(buf, "Contiguous MAC");
        Options &= 0x7f;
        space = TRUE;
    }
    if (Options & 0x40) {
        if (space) {
            strcat(buf, " ");
        }
        strcat(buf, "Contiguous DATA");
        Options &= 0xbf;
        space = TRUE;
    }
    if (Options & 0x20) {
        if (space) {
            strcat(buf, " ");
        }
        strcat(buf, "Break");
        Options &= 0xdf;
        space = TRUE;
    }
    if (Options) {
        if (space) {
            strcat(buf, " ");
        }
        strcat(buf, "*** Invalid options ***");
    }
    return buf;
}

PRIVATE
LPSTR
MapRcvReadOption(
    IN UCHAR Option
    )
{
    switch (Option) {
    case 0:
        return "Receive frames not chained";

    case 1:
        return "Chain receive frames for link station";

    case 2:
        return "Chain receive frames for SAP";
    }
    return "*** Unknown option ***";
}

PRIVATE
VOID
DumpReceiveCancelParms(
    IN PVOID Parameters
    )
{
    PUT(("station id. . . %04x\n", HIWORD(Parameters)));
}

PRIVATE
VOID
DumpReceiveModifyParms(
    IN PVOID Parameters
    )
{
}

PRIVATE
VOID
DumpTransmitDirFrameParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.DIR.FRAME", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitIFrameParms(
    IN PVOID Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.I.FRAME", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitTestCmdParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.TEST.CMD", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitUiFrameParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.UI.FRAME", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitXidCmdParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.XID.CMD", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitXidRespFinalParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.XID.RESP.FINAL", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitXidRespNotFinalParms(
    IN  PVOID   Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.XID.RESP.NOT.FINAL", Parameters);
    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitFramesParms(
    IN PVOID Parameters
    )
{
    DumpParameterTableHeader("TRANSMIT.FRAMES", Parameters);
//    DumpTransmitParms(Parameters);
}

PRIVATE
VOID
DumpTransmitParms(
    IN PVOID Parameters
    )
{
    PLLC_TRANSMIT_PARMS parms = (PLLC_TRANSMIT_PARMS)Parameters;

    try {
        PUT(("StationId . . . %04x\n"
            "Transmit FS . . %02x\n"
            "Remote SAP. . . %02x\n"
            "Xmit Queue 1. . %08x\n"
            "Xmit Queue 2. . %08x\n"
            "Buffer Length 1 %02x\n"
            "Buffer Length 2 %02x\n"
            "Buffer 1. . . . %08x\n"
            "Buffer 2. . . . %08x\n"
            "Xmt Read Option %02x [%s]\n"
            "\n",
            parms->usStationId,
            parms->uchTransmitFs,
            parms->uchRemoteSap,
            parms->pXmitQueue1,
            parms->pXmitQueue2,
            parms->cbBuffer1,
            parms->cbBuffer2,
            parms->pBuffer1,
            parms->pBuffer2,
            parms->uchXmitReadOption,
            MapXmitReadOption(parms->uchXmitReadOption)
            ));

        IF_DEBUG(DUMP_TX_INFO) {
            if (parms->pXmitQueue1) {
                PUT(("XMIT_QUEUE_ONE:\n"));
                DumpTransmitQueue(parms->pXmitQueue1);
            }

            if (parms->pXmitQueue2) {
                PUT(("XMIT_QUEUE_TWO:\n"));
                DumpTransmitQueue(parms->pXmitQueue2);
            }
        }

        IF_DEBUG(DUMP_TX_DATA) {
            if (parms->cbBuffer1) {
                DumpData("BUFFER_ONE. . . ",
                        (PBYTE)parms->pBuffer1,
                        (DWORD)parms->cbBuffer1,
                        DD_NO_ADDRESS
                        | DD_LINE_AFTER
                        | DD_INDENT_ALL
                        | DD_UPPER_CASE
                        | DD_DOT_DOT_SPACE,
                        DEFAULT_FIELD_WIDTH
                        );
            }

            if (parms->cbBuffer2) {
                DumpData("BUFFER_TWO. . . ",
                        (PBYTE)parms->pBuffer2,
                        (DWORD)parms->cbBuffer2,
                        DD_NO_ADDRESS
                        | DD_LINE_AFTER
                        | DD_INDENT_ALL
                        | DD_UPPER_CASE
                        | DD_DOT_DOT_SPACE,
                        DEFAULT_FIELD_WIDTH
                        );
            }
        }
    } except(1) {
        PUT(("*** Error: Bad Transmit Parameter Table @ %x ***\n", parms));
    }
}

PRIVATE
VOID
DumpTransmitQueue(
    IN PLLC_XMIT_BUFFER Buffer
    )
{
    try {
        while (Buffer) {
            PUT(("Next. . . . . . %08x\n"
                "Reserved. . . . %04x\n"
                "Data In Buffer. %04x\n"
                "User Data . . . %04x\n"
                "User Length . . %04x\n"
                "\n",
                Buffer->pNext,
                Buffer->usReserved1,
                Buffer->cbBuffer,
                Buffer->usReserved2,
                Buffer->cbUserData
                ));

            IF_DEBUG(DUMP_TX_DATA) {
                DumpData(NULL,
                        (PBYTE)Buffer->auchData,
                        (DWORD)Buffer->cbBuffer + (DWORD)Buffer->cbUserData,
                        DD_DEFAULT_OPTIONS,
                        DEFAULT_FIELD_WIDTH
                        );
            }
            Buffer = Buffer->pNext;
        }
    } except(1) {
        PUT(("*** Error: Bad Transmit Queue/Buffer @ %x ***\n", Buffer));
    }
}

PRIVATE
LPSTR
MapXmitReadOption(
    IN UCHAR Option
    )
{
    switch (Option) {
    case 0:
        return "Chain this Transmit on Link station basis";

    case 1:
        return "Do not chain this Transmit completion";

    case 2:
        return "Chain this Transmit on SAP station basis";
    }
    return "*** Unknown XMIT_READ_OPTION ***";
}

VOID
DumpReceiveDataBuffer(
    IN PVOID Buffer
    )
{
    PLLC_BUFFER pBuf = (PLLC_BUFFER)Buffer;
    BOOL contiguous;
    WORD userLength;
    WORD dataLength;
    WORD userOffset;

    try {
        contiguous = pBuf->Contiguous.uchOptions & 0xc0;
        userLength = pBuf->Next.cbUserData;
        dataLength = pBuf->Next.cbBuffer;
        userOffset = pBuf->Next.offUserData;
    } except(1) {
        PUT(("*** Error: Bad received data buffer address %x ***\n", pBuf));
        return;
    }

    //
    // Buffer 1: [not] contiguous MAC/DATA
    //

    try {
        PUT(("\n"
            "%sContiguous MAC/DATA frame @%08x\n"
            "next buffer . . %08x\n"
            "frame length. . %04x\n"
            "data length . . %04x\n"
            "user offset . . %04x\n"
            "user length . . %04x\n"
            "station id. . . %04x\n"
            "options . . . . %02x\n"
            "message type. . %02x [%s]\n"
            "buffers left. . %04x\n"
            "rcv FS. . . . . %02x\n"
            "adapter num . . %02x\n"
            "next frame. . . %08x\n",
            contiguous ? "" : "Not",
            pBuf,
            pBuf->Contiguous.pNextBuffer,
            pBuf->Contiguous.cbFrame,
            pBuf->Contiguous.cbBuffer,
            pBuf->Contiguous.offUserData,
            pBuf->Contiguous.cbUserData,
            pBuf->Contiguous.usStationId,
            pBuf->Contiguous.uchOptions,
            pBuf->Contiguous.uchMsgType,
            MapMessageType(pBuf->Contiguous.uchMsgType),
            pBuf->Contiguous.cBuffersLeft,
            pBuf->Contiguous.uchRcvFS,
            pBuf->Contiguous.uchAdapterNumber,
            pBuf->Contiguous.pNextFrame
            ));

        if (!contiguous) {

            //
            // dump NotContiguous header
            //

            DWORD cbLanHeader = (DWORD)pBuf->NotContiguous.cbLanHeader;
            DWORD cbDlcHeader = (DWORD)pBuf->NotContiguous.cbDlcHeader;

            PUT(("LAN hdr len . . %02x\n"
                "DLC hdr len . . %02x\n",
                cbLanHeader,
                cbDlcHeader
                ));
            DumpData("LAN header. . . ",
                    pBuf->NotContiguous.auchLanHeader,
                    cbLanHeader,
                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL,
                    DEFAULT_FIELD_WIDTH
                    );
            DumpData("DLC header. . . ",
                    pBuf->NotContiguous.auchDlcHeader,
                    cbDlcHeader,
                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL,
                    DEFAULT_FIELD_WIDTH
                    );

            if (userLength) {
                DumpData("user space. . . ",
                        (PBYTE)pBuf + userOffset,
                        userLength,
                        DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                        DEFAULT_FIELD_WIDTH
                        );
            } else {
                PUT(("user space. . . \n"));
            }

            IF_DEBUG(DUMP_RX_DATA) {

                if (dataLength) {
                    DumpData("rcvd data . . . ",
                            (PBYTE)pBuf + userOffset + userLength,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                            DEFAULT_FIELD_WIDTH
                            );
                } else {
                    PUT(("rcvd data . . . \n"));
                }
            }
        } else {

            //
            // dump Contiguous header
            //
            // data length is size of frame in contiguous buffer?
            //

            if (userLength) {
                DumpData("user space. . . ",
                        (PBYTE)pBuf + userOffset,
                        userLength,
                        DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                        DEFAULT_FIELD_WIDTH
                        );
            } else {
                PUT(("user space. . . \n"));
            }

            IF_DEBUG(DUMP_RX_DATA) {

                dataLength = pBuf->Contiguous.cbFrame;

                if (dataLength) {
                    DumpData("rcvd data . . . ",
                            (PBYTE)pBuf + userOffset + userLength,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                            DEFAULT_FIELD_WIDTH
                            );
                } else {
                    PUT(("rcvd data . . . \n"));
                }
            }
        }

        //
        // dump second & subsequent buffers
        //

        IF_DEBUG(DUMP_DATA_CHAIN) {

            for (pBuf = pBuf->pNext; pBuf; pBuf = pBuf->pNext) {

                userLength = pBuf->Next.cbUserData;
                dataLength = pBuf->Next.cbBuffer;

                PUT(("\n"
                    "Buffer 2/Subsequent @%08x\n"
                    "next buffer . . %08x\n"
                    "frame length. . %04x\n"
                    "data length . . %04x\n"
                    "user offset . . %04x\n"
                    "user length . . %04x\n",
                    pBuf,
                    pBuf->pNext,
                    pBuf->Next.cbFrame,
                    dataLength,
                    pBuf->Next.offUserData,
                    userLength
                    ));

                if (userLength) {
                    DumpData("user space. . . ",
                            (PBYTE)&pBuf + pBuf->Next.offUserData,
                            userLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                            DEFAULT_FIELD_WIDTH
                            );
                } else {
                    PUT(("user space. . . \n"));
                }

                IF_DEBUG(DUMP_RX_DATA) {

                    //
                    // there must be received data
                    //

                    DumpData("rcvd data . . . ",
                            (PBYTE)pBuf + pBuf->Next.offUserData + userLength,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL | DD_DOT_DOT_SPACE,
                            DEFAULT_FIELD_WIDTH
                            );
                }
            }
        }

        if (((PLLC_BUFFER)Buffer)->Contiguous.pNextFrame) {
            DumpReceiveDataBuffer(((PLLC_BUFFER)Buffer)->Contiguous.pNextFrame);
        }

    } except(1) {
        PUT(("*** Error: Bad Receive Data Buffer @ %x ***\n", Buffer));
    }
}

PRIVATE
LPSTR
MapMessageType(
    IN UCHAR MessageType
    )
{
    switch (MessageType) {
    case 0x00:
        return "Direct Transmit Frame";

    case 0x02:
        return "MAC Frame (Direct Station on Token Ring only)";

    case 0x04:
        return "I-Frame";

    case 0x06:
        return "UI-Frame";

    case 0x08:
        return "XID Command (POLL)";

    case 0x0a:
        return "XID Command (not POLL)";

    case 0x0c:
        return "XID Response (FINAL)";

    case 0x0e:
        return "XID Response (not FINAL)";

    case 0x10:
        return "TEST Response (FINAL)";

    case 0x12:
        return "TEST Response (not FINAL)";

    case 0x14:
        return "Direct 802.2/OTHER - non-MAC frame (Direct Station only)";

    case 0x16:
        return "TEST Command (POLL)";

    case 0x18:
        return "Direct Ethernet Frame";

    case 0x1a:
        return "Last Frame Type";

//    case 0x5dd:
//        return "First Ethernet Frame Type";

    default:
        return "*** BAD FRAME TYPE ***";
    }
}

//PRIVATE
//VOID
//DumpData(
//    IN PBYTE Address,
//    IN DWORD Length
//    )
//{
//    char dumpBuf[80];
//    char* bufptr;
//    int i, n;
//
//    //
//    // the usual dump style: 16 columns of hex bytes, followed by 16 columns
//    // of corresponding ASCII characters, or '.' where the character is < 0x20
//    // (space) or > 0x7f (del?)
//    //
//
//    while (Length) {
//        bufptr = dumpBuf;
//        bufptr += sprintf(bufptr, "%08x: ", Address);
//        if (Length < 16) {
//            n = Length;
//        } else {
//            n = 16;
//        }
//        for (i = 0; i < n; ++i) {
//            bufptr += sprintf(bufptr, "%02x", Address[i]);
//            if (i == 7) {
//                *bufptr = '-';
//            } else {
//                *bufptr = ' ';
//            }
//            ++bufptr;
//        }
//        if (n < 16) {
//            for (i = 0; i < 16-n; ++i) {
//                bufptr += sprintf(bufptr, "   ");
//            }
//        }
//        bufptr += sprintf(bufptr, "  ");
//        for (i = 0; i < n; ++i) {
//            if (Address[i] < 0x20 || Address[i] > 0x7f) {
//                *bufptr++ = '.';
//            } else {
//                *bufptr++ = Address[i];
//            }
//        }
//        *bufptr++ = '\n';
//        *bufptr = 0;
//        PUT((dumpBuf));
//        Length -= n;
//        Address += n;
//    }
//    PUT(("\n"));
//}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\api\dlcdebug.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcdebug.h

Abstract:

    Contains debugging prototypes and manifests for ACSLAN

Author:

    Richard L Firth (rfirth) 28-May-1992

Revision History:

--*/

#define ARRAY_ELEMENTS(a)   (sizeof(a)/sizeof((a)[0]))
#define LAST_ELEMENT(a)     (ARRAY_ELEMENTS(a)-1)

#if DBG

#define PRIVATE

#define ACSLAN_DEBUG_ENV_VAR    "ACSLAN_DEBUG_FLAGS"
#define ACSLAN_DUMP_FILE_VAR    "ACSLAN_DUMP_FILE"
#define ACSLAN_DUMP_FILTER_VAR  "ACSLAN_DUMP_FILTER"

#define DEBUG_DUMP_INPUT_CCB    0x00000001L // dump CCB input to AcsLan
#define DEBUG_DUMP_OUTPUT_CCB   0x00000002L // dump CCB output from AcsLan
#define DEBUG_DUMP_TX_INFO      0x00000004L // dump transmit buffers
#define DEBUG_DUMP_RX_INFO      0x00000008L // dump receive buffers
#define DEBUG_DUMP_TX_DATA      0x00000010L // dump data buffer in TRANSMIT commands
#define DEBUG_DUMP_RX_DATA      0x00000020L // dump received data frames
#define DEBUG_DUMP_DATA_CHAIN   0x00000040L // dump entire chain of received data buffers
#define DEBUG_DUMP_FRAME_CHAIN  0x00000080L // dump entire chain of received frames
#define DEBUG_DUMP_TX_ASCII     0x00000100L // dump transmitted data as hex & ASCII
#define DEBUG_DUMP_RX_ASCII     0x00000200L // dump received data as hex & ASCII
#define DEBUG_DUMP_ASYNC_CCBS   0x00000400L // dump READ async. completed CCBs
#define DEBUG_RETURN_CODE       0x01000000L // dump return code from AcsLan/NtAcsLan
#define DEBUG_DUMP_NTACSLAN     0x02000000L // dump CCBs for NtAcsLan, not AcsLan
#define DEBUG_DUMP_ACSLAN       0x04000000L // dump CCBs for AcsLan, not NtAcsLan
#define DEBUG_DUMP_TIME         0x08000000L // dump relative time between commands
#define DEBUG_DLL_INFO          0x10000000L // dump info about DLL attach/detach
#define DEBUG_BREAKPOINT        0x20000000L // break at conditional breakpoints
#define DEBUG_TO_FILE           0x40000000L // dump info to file
#define DEBUG_TO_TERMINAL       0x80000000L // dump info to console

#define IF_DEBUG(c)             if (AcslanDebugFlags & DEBUG_##c)
#define PUT(x)                  AcslanDebugPrint x
#define DUMPCCB                 DumpCcb

//
// misc.
//

#define DEFAULT_FIELD_WIDTH     16          // amount of description before a number

//
// DumpData options
//

#define DD_DEFAULT_OPTIONS      0x00000000  // use defaults
#define DD_NO_ADDRESS           0x00000001  // don't display address of data
#define DD_LINE_BEFORE          0x00000002  // linefeed before first dumped line
#define DD_LINE_AFTER           0x00000004  // linefeed after last dumped line
#define DD_INDENT_ALL           0x00000008  // indent all lines
#define DD_NO_ASCII             0x00000010  // don't dump ASCII respresentation
#define DD_UPPER_CASE           0x00000020  // upper-case hex dump (F4 instead of f4)
#define DD_DOT_DOT_SPACE        0x00000040  // fill unused hex space with '..'

//
// Filters for individual CCB commands: 4 flags max, because each command is
// represented by a single ASCII character
//

#define CF_DUMP_CCB_IN          0x00000001  // dump CCB on input
#define CF_DUMP_CCB_OUT         0x00000002  // dump CCB on output
#define CF_DUMP_PARMS_IN        0x00000004  // dump parameter table on input
#define CF_DUMP_PARMS_OUT       0x00000008  // dump parameter table on output

//
// global data
//

#ifndef ACSLAN_DEBUG_FLAGS
#define ACSLAN_DEBUG_FLAGS      0
#endif

extern DWORD AcslanDebugFlags;
extern FILE* hDumpFile;

//
// prototypes
//

VOID
GetAcslanDebugFlags(
    VOID
    );

VOID
SetAcslanDebugFlags(
    IN DWORD Flags
    );

VOID
AcslanDebugPrint(
    IN LPSTR Format,
    IN ...
    );

VOID
DumpCcb(
    IN PLLC_CCB Ccb,
    IN BOOL DumpAll,
    IN BOOL CcbIsInput
    );

VOID
DumpData(
    IN LPSTR Title,
    IN PBYTE Address,
    IN DWORD Length,
    IN DWORD Options,
    IN DWORD Indent
    );

LPSTR
MapCcbRetcode(
    IN BYTE Retcode
    );

#else

#define PRIVATE                 static

#define IF_DEBUG(c)             if (0)
#define PUT(x)
#define DUMPCCB                 (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcbuf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcbuf.c

Abstract:

    This module implements the DLC buffer pool manager and provides routines
    to lock and unlock transmit buffers outside of the buffer pool

    DLC has a buffering scheme inherited from its progenitors right back to
    the very first DOS implementation. We must share a buffer pool with an
    application: the application allocates memory using any method it desires
    and gives us a pointer to that memory and the length. We page-align the
    buffer and carve it into pages. Any non page-aligned buffer at the start
    or end of the buffer are discarded.

    Once DLC has a buffer pool defined, it allocates buffers in a fashion
    similar to binary-buddy, or in a method that I shall call 'binary
    spouse'. Blocks are initially all contained in page sized units. As
    smaller blocks are required, a larger block is repeatedly split into 2
    until a i-block is generated where 2**i >= block size required. Unlike
    binary-buddy, the binary-spouse method does not coalesce buddy blocks to
    create larger buffers once split. Once divorced from each other, binary
    spouse blocks are unlikely to get back together.

    BufferPoolAllocate is the function that single-handedly implements the
    allocator mechanism. It basically handles 2 types of request in the same
    routine: the first request is from BUFFER.GET where a buffer will be
    returned to the app as a single buffer if we have a block available that
    is large enough to satisfy the request. If the request cannot be satisfied
    by a single block, we return a chain of smaller blocks. The second type of
    request is from the data receive DPC processing where we have to supply a
    single block to contain the data. Luckily, through the magic of MDLs, we
    can return several smaller blocks linked together by MDLs which masquerade
    as a single buffer. Additionally, we can create buffers larger than a
    single page in the same manner. This receive buffer must later be handed
    to the app in the same format as the buffer allocated by BUFFER.GET, so we
    need to be able to view this kind of buffer in 2 ways. This accounts for
    the complexity of the various headers and MDL descriptors which must be
    applied to the allocated blocks

    Contents:
        BufferPoolCreate
        BufferPoolExpand
        BufferPoolFreeExtraPages
        DeallocateBuffer
        AllocateBufferHeader
        BufferPoolAllocate
        BufferPoolDeallocate
        BufferPoolDeallocateList
        BufferPoolBuildXmitBuffers
        BufferPoolFreeXmitBuffers
        GetBufferHeader
        BufferPoolDereference
        BufferPoolReference
        ProbeVirtualBuffer
        AllocateProbeAndLockMdl
        BuildMappedPartialMdl
        UnlockAndFreeMdl

Author:

    Antti Saarenheimo 12-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>
#include <memory.h>
#include "dlcdebug.h"

//
// LOCK/UNLOCK_BUFFER_POOL - acquires or releases per-buffer pool spin lock.
// Use kernel spin locking calls. Assumes variables are called "pBufferPool" and
// "irql"
//

#define LOCK_BUFFER_POOL()      KeAcquireSpinLock(&pBufferPool->SpinLock, &irql)
#define UNLOCK_BUFFER_POOL()    KeReleaseSpinLock(&pBufferPool->SpinLock, irql)

//
// data
//

PDLC_BUFFER_POOL pBufferPools = NULL;


#define CHECK_FREE_SEGMENT_COUNT(pBuffer)

/*
Enable this, if the free segment size checking fails:

#define CHECK_FREE_SEGMENT_COUNT(pBuffer) CheckFreeSegmentCount(pBuffer)

VOID
CheckFreeSegmentCount(
    PDLC_BUFFER_HEADER pBuffer
    );

VOID
CheckFreeSegmentCount(
    PDLC_BUFFER_HEADER pBuffer
    )
{
    PDLC_BUFFER_HEADER pTmp;
    UINT FreeSegments = 0;

    for (pTmp = (pBuffer)->FreeBuffer.pParent->Header.pNextChild;
         pTmp != NULL;
         pTmp = pTmp->FreeBuffer.pNextChild) {
        if (pTmp->FreeBuffer.BufferState == BUF_READY) {
             FreeSegments += pTmp->FreeBuffer.Size;
        }
    }
    if (FreeSegments != (pBuffer)->FreeBuffer.pParent->Header.FreeSegments) {
        DbgBreakPoint();
    }
}
*/


/*++

DLC Buffer Manager
------------------

The buffer pool consists of virtual memory blocks, that must be allocated
by the application program. The buffer block descriptors are allocated
separately from the non-paged pool, because they must be safe from
any memory corruption done in by an application.

The memory allocation strategy is binary buddy. All segments are
exponents of 2 between 256 and 4096. There is no official connection with
the system page size, but actually all segments are allocated within
a page and thus we minimize MDL sizes needed for them.  Contiguous
buffer blocks decrease also the DMA overhead. The initial user buffer
is first split to its maximal binary components. The components
are split further in the run time, when the buffer manager runs
out of the smaller segments (eg. it splits a 1024 segment to one
512 segment and two 256 segments, if it run out of 256 segments and
there were no free 512 segments either).

The clients of the buffer manager allocates buffer lists. They consists
of minimal number of binary segments. For example, a 1600 bytes buffer
request would return a list of 1024, 512 and 256 segments. The smallest
segment is the first and the biggest is the last. The application
program must deallocate all segments returned to it in the receive.
The validity of all deallocated segments is checked with a reservation list.

Buffer Manager provides api commands:
- to initialize a buffer pool (pool constructor)
- to add locked and mapped virtual memory to the buffer
- to deallocate the buffer pool (destructor)
- to allocate a segment list (allocator)
- to deallocate a segment list (deallocator)
- to set Thresholds for the minimum buffer size

--*/


/*++


MEMORY COMMITMENT


The commitement of buffer pools is a special service expecially for
the local busy state management of the link stations.  By default
the uncommitted memory is the same as the free memory in the buffer
pool minus the minimum free Threshold, but when a link enters to a
busy state we know how much buffer space the link will need
to receive at least the next frame.  Actually we will commit all
I- packets received in the local busy state.  The local 'out of buffers' busy
state will be cleared only when there is enough uncommited space in the
buffer pool to receive all expected packets.  We still indicate the local
busy state to user, because the flow control function can expand the buffer
pool, if it is necessary.  We will just queue the clear local busy state
command to a command queue (even if we complete it immediately),
we don;t execute the queued command before there is enough uncommited space
to enable the link receive.

The buffer space is committed by the size of all expected packets,
when the local busy state of a link is cleared.
All received packets are subracted from the commited buffer space
as far as the link has any committed memory.  This may happen only
after a local busy states.


We will provide three macroes to

BufGetPacketSize(PacketSize) - returns probable size of packet in buffers
BufGetUncommittedSpace(hBufferPool) - gets the current uncommited space
BufCommitBuffers(hBufferPool, BufferSize) - commits the given size
BufUncommitBuffers(hBufferPool, PacketSize) - uncommites a packet

--*/

NTSTATUS
ProbeVirtualBuffer(
    IN PUCHAR pBuffer,
    IN LONG Length
    );


NTSTATUS
BufferPoolCreate(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PVOID pUserBuffer,
    IN LONG MaxBufferSize,
    IN LONG MinFreeSizeThreshold,
    OUT HANDLE *pBufferPoolHandle,
    OUT PVOID* AlignedAddress,
    OUT PULONG AlignedSize
    )

/*++

Routine Description:

    This routine performs initialization of the NT DLC API buffer pool.
    It allocates the buffer descriptor and the initial header blocks.

Arguments:

    pFileContext            - pointer to DLC_FILE_CONTEXT structure
    pUserBuffer             - virtual base address of the buffer
    MaxBufferSize           - the maximum size of the buffer space
    MinFreeSizeThreshold    - the minimum free space in the buffer
    pBufferPoolHandle       - the parameter returns the handle of buffer pool,
                              the same buffer pool may be shared by several
                              open contexts of one or more dlc applications.
    AlignedAddress          - we return the page-aligned buffer pool address
    AlignedSize             - and the page-aligned buffer pool size

Return Value:

    Returns NTSTATUS is a NT system call fails.

--*/

{
    NTSTATUS status;
    PDLC_BUFFER_POOL pBufferPool;
    PVOID pAlignedBuffer;
    INT i;
    register PPACKET_POOL pHeaderPool;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // page-align the buffer
    //

    pAlignedBuffer = (PVOID)(((ULONG_PTR)pUserBuffer + PAGE_SIZE - 1) & -(LONG)PAGE_SIZE);

    //
    // and make the length an integral number of pages
    //

    MaxBufferSize = (MaxBufferSize - (ULONG)((ULONG_PTR)pAlignedBuffer - (ULONG_PTR)pUserBuffer)) & -(LONG)PAGE_SIZE;

    //
    // the buffer size must be at least one page (BufferSize will be 0 if
    // this is not so)
    //

    if (MaxBufferSize <= 0) {
        return DLC_STATUS_BUFFER_SIZE_EXCEEDED;
    }

    //
    // if MinFreeSizeThreshold  < 0, we can have problems since it is negated later
    // on leaving buffer pool uninitialized
    //

    if (MinFreeSizeThreshold < 0) {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }

    //
    // if the size of the buffer is less than the minimum lock size then we lock
    // the entire buffer
    //

    if (MaxBufferSize < MinFreeSizeThreshold) {
        MinFreeSizeThreshold = MaxBufferSize;
    }

    //
    // allocate the DLC_BUFFER_POOL structure. This is followed by an array
    // of pointers to buffer headers describing the pages in the buffer pool
    //

    pBufferPool = ALLOCATE_ZEROMEMORY_DRIVER(sizeof(DLC_BUFFER_POOL)
                                             + sizeof(PVOID)
                                             * BYTES_TO_PAGES(MaxBufferSize)
                                             );
    if (!pBufferPool) {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    // pHeaderPool is a pool of DLC_BUFFER_HEADER structures - one of these
    // is used per page locked
    //

    pHeaderPool = CREATE_BUFFER_POOL_FILE(DlcBufferPoolObject,
                                          sizeof(DLC_BUFFER_HEADER),
                                          8
                                          );

    if (!pHeaderPool) {

        FREE_MEMORY_DRIVER(pBufferPool);

        return DLC_STATUS_NO_MEMORY;
    }

    //
    // initialize the buffer pool structure
    //

    pBufferPool->hHeaderPool = pHeaderPool;

    KeInitializeSpinLock(&pBufferPool->SpinLock);

    //
    // UncommittedSpace is the space above the minimum free threshold in the
    // locked region of the buffer pool. We set it to the negative of the
    // minimum free threshold here to cause BufferPoolExpand to lock down
    // the number of pages required to commit the minimum free threshold
    //

    pBufferPool->UncommittedSpace = -MinFreeSizeThreshold;

    //
    // MaxBufferSize is the size of the buffer pool rounded down to an integral
    // number of pages
    //

    pBufferPool->MaxBufferSize = (ULONG)MaxBufferSize;

    //
    // BaseOffset is the page-aligned address of the buffer pool
    //

    pBufferPool->BaseOffset = pAlignedBuffer;

    //
    // MaxOffset is the last byte + 1 (?) in the buffer pool
    //

    pBufferPool->MaxOffset = (PUCHAR)pAlignedBuffer + MaxBufferSize;

    //
    // MaximumIndex is the number of pages that describe the buffer pool. This
    // number is irrespective of the locked state of the pages
    //

    pBufferPool->MaximumIndex = (ULONG)(MaxBufferSize / MAX_DLC_BUFFER_SEGMENT);

    //
    // Link all unlocked pages to a link list.
    // Put the last pages in the buffer to the end of the list.
    //

    for (i = (INT)pBufferPool->MaximumIndex - 1; i >= 0; i--) {
        pBufferPool->BufferHeaders[i] = pBufferPool->pUnlockedEntryList;
        pBufferPool->pUnlockedEntryList = (PDLC_BUFFER_HEADER)&pBufferPool->BufferHeaders[i];
    }
    for (i = 0; i < DLC_BUFFER_SEGMENTS; i++) {
        InitializeListHead(&pBufferPool->FreeLists[i]);
    }
    InitializeListHead(&pBufferPool->PageHeaders);

    //
    // We can now lock the initial page buffers for the buffer pool.
    // The buffer pool allocation has been failed, if the procedure
    // returns an error.
    //

#if DBG
    status = BufferPoolExpand(pFileContext, pBufferPool);
#else
    status = BufferPoolExpand(pBufferPool);
#endif
    if (status != STATUS_SUCCESS) {

        //
        // We must use the standard procedure for deallocation,
        // because the memory locking may have succeeded partially.
        // The derefence free all resources in the buffer pool.
        //

        BufferPoolDereference(
#if DBG
            pFileContext,
#endif
            &pBufferPool
            );
    } else {

        KIRQL irql;

        //
        // Save the buffer pool handle to the link list of
        // buffer pools
        //

        ACQUIRE_DLC_LOCK(irql);

        pBufferPool->pNext = pBufferPools;
        pBufferPools = pBufferPool;

        RELEASE_DLC_LOCK(irql);

        *pBufferPoolHandle = pBufferPool;
        *AlignedAddress = pAlignedBuffer;
        *AlignedSize = MaxBufferSize;
    }
    return status;
}


NTSTATUS
BufferPoolExpand(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool
    )

/*++

Routine Description:

    The function checks the minimum and maximum size Thresholds and
    locks new pages or unlocks the extra pages and deallocates their
    buffer headers.
    The procedure uses the standard memory management functions
    to lock, probe and map the pages.

    The MDL buffer is split to smaller buffers (256, 512, ... 4096).
    The orginal buffer is split in the 4 kB even address (usually
    page border or even with any page size) to minimize PFNs associated
    with the MDLs (each MDL needs now only one PFN, to make
    DMA overhead smaller and to save locked memory).
    This procedure does not actually assume anything about the paging,
    but it should work quite well with any paging implementation.

    This procedure MUST be called only from the synchronous code path and
    all spinlocks unlocked, because of the page locking (the async
    code in always on the DPC level and you cannot make pagefaults on
    that level).

Arguments:

    pBufferPool - handle of buffer pool data structure.

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDLC_BUFFER_HEADER pBuffer;
    KIRQL irql;

    ASSUME_IRQL(DISPATCH_LEVEL);

    LOCK_BUFFER_POOL();

    //
    // UncommittedSpace < 0 just means that we've encroached past the minimum
    // free threshold and therefore we're in need of more buffer space (hence
    // this function)
    //

    if (((pBufferPool->UncommittedSpace < 0) || (pBufferPool->MissingSize > 0))
    && (pBufferPool->BufferPoolSize < pBufferPool->MaxBufferSize)) {

        UINT FreeSlotIndex;

        while ((pBufferPool->UncommittedSpace < 0) || (pBufferPool->MissingSize > 0)) {

            pBuffer = NULL;

            //
            // if there are no more pages to lock or we can't allocate a header
            // to describe the buffer then quit
            //

            if (!pBufferPool->pUnlockedEntryList
            || !(pBuffer = ALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool))) {
                status = DLC_STATUS_NO_MEMORY;
                break;
            }

            //
            // We use a direct mapping to find the immediately
            // the buffer headers.  Unallocated pages are in a single entry
            // link list in that table.  We must remove the locked entry
            // from the link list and save the buffer header address to the
            // new slot.  The offset of the entry defines also the free
            // unlocked buffer in the buffer pool.
            // I have used this funny structure to minimize header
            // information for the unlocked virtual pages (you could have
            // a huge virtual buffer pool with a very small overhead in DLC).
            //

            FreeSlotIndex = (UINT)(((ULONG_PTR)pBufferPool->pUnlockedEntryList - (ULONG_PTR)pBufferPool->BufferHeaders) / sizeof(PVOID));

            pBuffer->Header.BufferState = BUF_READY;
            pBuffer->Header.pLocalVa = (PVOID)((PCHAR)pBufferPool->BaseOffset + FreeSlotIndex * MAX_DLC_BUFFER_SEGMENT);
            pBufferPool->pUnlockedEntryList = pBufferPool->pUnlockedEntryList->pNext;
            pBufferPool->BufferHeaders[FreeSlotIndex] = pBuffer;

            //
            // Lock memory always outside the spin locks on 0 level.
            //

            UNLOCK_BUFFER_POOL();

            RELEASE_DRIVER_LOCK();

            pBuffer->Header.pMdl = AllocateProbeAndLockMdl(pBuffer->Header.pLocalVa,
                                                           MAX_DLC_BUFFER_SEGMENT
                                                           );

            ACQUIRE_DRIVER_LOCK();

            LOCK_BUFFER_POOL();

            if (pBuffer->Header.pMdl) {
                pBuffer->Header.pGlobalVa = MmGetSystemAddressForMdl(pBuffer->Header.pMdl);
                pBuffer->Header.FreeSegments = MAX_DLC_BUFFER_SEGMENT / MIN_DLC_BUFFER_SEGMENT;
                status = AllocateBufferHeader(
#if DBG
                            pFileContext,
#endif
                            pBufferPool,
                            pBuffer,
                            MAX_DLC_BUFFER_SEGMENT / MIN_DLC_BUFFER_SEGMENT,
                            0,                  // logical index within the page
                            0                   // page in the free page table
                            );
            } else {
                MemoryLockFailed = TRUE;
                status = DLC_STATUS_MEMORY_LOCK_FAILED;

#if DBG
                DbgPrint("DLC.BufferPoolExpand: AllocateProbeAndLockMdl(a=%x, l=%x) failed\n",
                        pBuffer->Header.pLocalVa,
                        MAX_DLC_BUFFER_SEGMENT
                        );
#endif

            }
            if (status != STATUS_SUCCESS) {

                //
                // It failed => free MDL (if non-null) and
                // restore the link list of available buffers
                //

                if (pBuffer->Header.pMdl != NULL) {
                    UnlockAndFreeMdl(pBuffer->Header.pMdl);
                }
                pBufferPool->BufferHeaders[FreeSlotIndex] = pBufferPool->pUnlockedEntryList;
                pBufferPool->pUnlockedEntryList = (PDLC_BUFFER_HEADER)&(pBufferPool->BufferHeaders[FreeSlotIndex]);

                DEALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool, pBuffer);

                break;
            }

#if LLC_DBG

            CHECK_FREE_SEGMENT_COUNT(pBuffer->Header.pNextChild);

#endif

            pBufferPool->FreeSpace += MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->UncommittedSpace += MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->BufferPoolSize += MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->MissingSize -= MAX_DLC_BUFFER_SEGMENT;
            LlcInsertTailList(&pBufferPool->PageHeaders, pBuffer);
        }
        pBufferPool->MissingSize = 0;

        //
        // We will return success, if at least the minimal amount
        // memory was allocated.  The initial pool size may be too
        // big for the current memory constraints set by the
        // operating system and actual available physical memory.
        //

        if (pBufferPool->UncommittedSpace < 0) {
            status = DLC_STATUS_NO_MEMORY;
        }
    }

    UNLOCK_BUFFER_POOL();

    return status;
}


VOID
BufferPoolFreeExtraPages(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool
    )

/*++

Routine Description:

    The function checks the maximum Thresholds and
    unlocks the extra pages and deallocates their buffer headers.

Arguments:

    pBufferPool - handle of buffer pool data structure.

Return Value:

    None.

--*/

{
    PDLC_BUFFER_HEADER pBuffer;
    KIRQL irql;
    PDLC_BUFFER_HEADER pNextBuffer;

    ASSUME_IRQL(DISPATCH_LEVEL);

/*
    DbgPrint("MaxBufferSize: %x\n", pBufferPool->MaxBufferSize);
    DbgPrint("Uncommitted size: %x\n", pBufferPool->UncommittedSpace);
    DbgPrint("BufferPoolSize: %x\n", pBufferPool->BufferPoolSize);
    DbgPrint("FreeSpace : %x\n", pBufferPool->FreeSpace);
*/

    LOCK_BUFFER_POOL();

    //
    // Free the extra pages until we have enough free buffer space.
    //

    pBuffer = (PDLC_BUFFER_HEADER)pBufferPool->PageHeaders.Flink;

    while ((pBufferPool->UncommittedSpace > MAX_FREE_SIZE_THRESHOLD)
    && (pBuffer != (PVOID)&pBufferPool->PageHeaders)) {

        //
        // We may free (unlock) only those buffers given, that have
        // all buffers free.
        //

        if ((UINT)(pBuffer->Header.FreeSegments == (MAX_DLC_BUFFER_SEGMENT / MIN_DLC_BUFFER_SEGMENT))) {
            pNextBuffer = pBuffer->Header.pNextHeader;
#if DBG
            DeallocateBuffer(pFileContext, pBufferPool, pBuffer);
#else
            DeallocateBuffer(pBufferPool, pBuffer);
#endif
            pBufferPool->FreeSpace -= MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->UncommittedSpace -= MAX_DLC_BUFFER_SEGMENT;
            pBufferPool->BufferPoolSize -= MAX_DLC_BUFFER_SEGMENT;
            pBuffer = pNextBuffer;
        } else {
            pBuffer = pBuffer->Header.pNextHeader;
        }
    }

    UNLOCK_BUFFER_POOL();

}


VOID
DeallocateBuffer(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pBuffer
    )

/*++

Routine Description:

    The routine unlinks all segments of a page from the free lists and
    deallocates the data structures.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    pBuffer     - the deallocated buffer header

Return Value:

    None

--*/

{
    UINT FreeSlotIndex;
    PDLC_BUFFER_HEADER pSegment, pNextSegment;

    //
    // First we unlink the segments from the free lists and
    // then free and unlock the data structs of segment.
    //

    for (pSegment = pBuffer->Header.pNextChild; pSegment != NULL; pSegment = pNextSegment) {
        pNextSegment = pSegment->FreeBuffer.pNextChild;

        //
        // Remove the buffer from the free lists (if it is there)
        //

        if (pSegment->FreeBuffer.BufferState == BUF_READY) {
            LlcRemoveEntryList(pSegment);
        }

#if LLC_DBG

        else {

            //
            // This else can be possible only if we are
            // deleting the whole buffer pool (ref count=0)
            //

            if (pBufferPool->ReferenceCount != 0) {
                DbgPrint("Error: Invalid buffer state!");
                DbgBreakPoint();
            }
            pSegment->FreeBuffer.pNext = NULL;
        }

#endif

        IoFreeMdl(pSegment->FreeBuffer.pMdl);

        DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);

        DEALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool, pSegment);
    }

    //
    // Link the page to the free page list in buffer pool header
    //

    FreeSlotIndex = (UINT)(((ULONG_PTR)pBuffer->Header.pLocalVa - (ULONG_PTR)pBufferPool->BaseOffset) / MAX_DLC_BUFFER_SEGMENT);
    pBufferPool->BufferHeaders[FreeSlotIndex] = pBufferPool->pUnlockedEntryList;
    pBufferPool->pUnlockedEntryList = (PDLC_BUFFER_HEADER)&(pBufferPool->BufferHeaders[FreeSlotIndex]);
    UnlockAndFreeMdl(pBuffer->Header.pMdl);
    LlcRemoveEntryList(pBuffer);

    DEALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool, pBuffer);

}


NTSTATUS
AllocateBufferHeader(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pParent,
    IN UCHAR Size,
    IN UCHAR Index,
    IN UINT FreeListTableIndex
    )

/*++

Routine Description:

    The routine allocates and initializes a new buffer segment
    and links it to the given free segment list.

Arguments:

    pBufferPool         - handle of buffer pool data structure.
    pParent             - the parent (page) node of this segemnt
    Size                - size of this segment in 256 byte units
    Index               - index of this segment in 256 byte units
    FreeListTableIndex  - log2(Size), (ie. 256 bytes=>0, etc.)

Return Value:

    Returns NTSTATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    PDLC_BUFFER_HEADER pBuffer;

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (!(pBuffer = ALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool))) {
        return DLC_STATUS_NO_MEMORY;
    }

    pBuffer->FreeBuffer.pMdl = IoAllocateMdl((PUCHAR)pParent->Header.pLocalVa
                                                + (UINT)Index * MIN_DLC_BUFFER_SEGMENT,
                                             (UINT)Size * MIN_DLC_BUFFER_SEGMENT,
                                             FALSE,       // not used (no IRP)
                                             FALSE,       // we can't take this from user quota
                                             NULL
                                             );
    if (pBuffer->FreeBuffer.pMdl == NULL) {

        DEALLOCATE_PACKET_DLC_BUF(pBufferPool->hHeaderPool, pBuffer);

        return DLC_STATUS_NO_MEMORY;
    }

    DBG_INTERLOCKED_INCREMENT(AllocatedMdlCount);

    pBuffer->FreeBuffer.pNextChild = pParent->Header.pNextChild;
    pParent->Header.pNextChild = pBuffer;
    pBuffer->FreeBuffer.pParent = pParent;
    pBuffer->FreeBuffer.Size = Size;
    pBuffer->FreeBuffer.Index = Index;
    pBuffer->FreeBuffer.BufferState = BUF_READY;
    pBuffer->FreeBuffer.FreeListIndex = (UCHAR)FreeListTableIndex;

    //
    // Link the full page buffer to the first free list
    //

    LlcInsertHeadList(&(pBufferPool->FreeLists[FreeListTableIndex]), pBuffer);
    return STATUS_SUCCESS;
}


NTSTATUS
BufferPoolAllocate(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferSize,
    IN UINT FrameHeaderSize,
    IN UINT UserDataSize,
    IN UINT FrameLength,
    IN UINT SegmentSizeIndex,
    IN OUT PDLC_BUFFER_HEADER *ppBufferHeader,
    OUT PUINT puiBufferSizeLeft
    )

/*++

Routine Description:

    Function allocates the requested buffer (locked and mapped) from the
    buffer pool and returns its MDL and descriptor table of user segments.
    The returned buffer is actually the minimal combination of some segments
    (256, 512, 1024, 2048, 4096).

    There is a header in each buffer segment. The size of the frame
    header and the user data added to all frames are defined by the caller.

    The allocated segments will be linked in three level:

        - Segment headers will be linked in the reserved list to
          be checked when the application program releases the buffers
          back to pool. The actual segments cannot be used, because
          they are located in unsafe user memory.

        - Segments are linked (from smaller to bigger) for application program,
          this link list is used nowhere in the driver (because it is in ...)

        - MDLs of the same buffer list are linked for the driver

        The link lists goes from smaller segment to bigger, because
        the last segment should be the biggest one in a transmit call
        (it actually works very nice with 2 or 4 token ring frames).

    DON'T TOUCH the calculation of the segment size (includes operations
    with BufferSize, ->Cont.DataLength and FirstHeaderSize),  the logic is
    very complex. The current code has been tested by hand using some
    test values, and it seems to work (BufferSize = 0, 1, 0xF3,
    FirstHeader = 0,2).

Arguments:

    pBufferPool         - handle of buffer pool data structure.

    BufferSize          - the size of the actual data in the requested buffers.
                          This must really be the actual data. Nobody can know
                          the size of all segment headers beforehand. The buffer
                          size must include the frame header size added to the
                          first buffer in the list!

    FrameHeaderSize     - the space reserved for the frame header depends on
                          buffer format (OS/2 or DOS) and if the data is read
                          contiguously or not. The buffer manager reserves four
                          bytes from the beginning of the first segment in frame
                          to link this frame to next frames.

    UserDataSize        - buffer area reserved for user data (nobody uses this)

    FrameLength         - the total frame length (may not be the same as
                          BufferSize, because the LAN and DLC headers may be
                          saved into the header.

    SegmentSizeIndex    - the client may ask a number segments having a fixed
                          size (256, 512, ... 4096).

    ppBufferHeader      - parameter returns the arrays of the user buffer
                          segments. The array is allocated in the end of this
                          buffer. This may include a pointer to a buffer pool,
                          that is already allocated. The old buffer list will
                          be linked behind the new buffers.

    puiBufferSizeLeft   - returns the size of buffer space, that is not yet
                          allocated. The client may extend the buffer pool
                          and then continue the allocation of the buffers.
                          Otherwise you could not allocate more buffers than
                          defined by MinFreeSizeThreshold.

Return Value:

    NTSTATUS
        STATUS_SUCCESS
        DLC_STATUS_NO_MEMORY - no available memory in the non paged pool

--*/

{
    INT i, j, k;        // loop indexes (three level loop)
    INT LastIndex;      // index of smallest allowed segment size.
    INT LastAvailable;  // Index of free list having biggest segments
    UINT SegmentSize;   // current segment size
    PDLC_BUFFER_HEADER pPrev;
    PMDL pPrevMdl;
    PDLC_BUFFER_HEADER pNew;
    PFIRST_DLC_SEGMENT pDlcBuffer, pLastDlcBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL irql;
    USHORT SavedDataLength;

    static USHORT SegmentSizes[DLC_BUFFER_SEGMENTS] = {
#if defined(ALPHA)
        8192,
#endif
        4096,
        2048,
        1024,
        512,
        256
    };

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Link the old buffers behind the new ones.
    // This is really sick:  BufferGet is calling this second (or more)
    // time after it has expanded the buffer pool for the new retry,
    // we must search the last buffer header, because the extra
    // buffer space is removed from it.
    //

    pPrev = *ppBufferHeader;
    if (pPrev != NULL) {
        for (pNew = pPrev;
            pNew->FrameBuffer.pNextSegment != NULL;
            pNew = pNew->FrameBuffer.pNextSegment) {
            ;       // NOP
        }
        pLastDlcBuffer = (PFIRST_DLC_SEGMENT)
                (
                    (PUCHAR)pNew->FreeBuffer.pParent->Header.pGlobalVa
                    + (UINT)pNew->FreeBuffer.Index * MIN_DLC_BUFFER_SEGMENT
                );
    }

    //
    // the first frame size has been added to the total length
    // (excluding the default header), but we must
    // exclude the default buffer header.
    //

    if (FrameHeaderSize > sizeof(NEXT_DLC_SEGMENT)) {
        FrameHeaderSize -= sizeof(NEXT_DLC_SEGMENT);
    } else {
        FrameHeaderSize = 0;
    }

    //
    // The frame header must be included in the total buffer space
    // just as any other stuff. We must add the maximum extra size
    // to get all stuff to fit into buffers.
    //

    BufferSize += MIN_DLC_BUFFER_SEGMENT - 1 + FrameHeaderSize;

    //
    // Initialize the index variables for the loop
    //

    if (SegmentSizeIndex == -1) {
        i = 0;
        LastIndex = DLC_BUFFER_SEGMENTS - 1;
        SegmentSize = MAX_DLC_BUFFER_SEGMENT;
    } else {
        i = SegmentSizeIndex;
        LastIndex = SegmentSizeIndex;
        SegmentSize = SegmentSizes[SegmentSizeIndex];
    }
    LastAvailable = 0;

    LOCK_BUFFER_POOL();

    //
    // Loop until we have found enough buffers for
    // the given buffer space (any kind, but as few as possible)
    // or for the given number of requested buffers.
    // Initialize each new buffer. The frame header is a special case.
    // We go from bigger segments to smaller ones.  The last (and smallest)
    // will be initialized as a frame header (if needed).
    //

    for (; (i <= LastIndex) && BufferSize; i++) {
        while (((SegmentSize - sizeof(NEXT_DLC_SEGMENT) - UserDataSize) < BufferSize) || (i == LastIndex)) {

            //
            // Check if there are any buffers having the optimal size
            //

            if (IsListEmpty(&pBufferPool->FreeLists[i])) {

                //
                // Split a bigger segment to smallers.  Link the
                // extra segments to the free lists and return
                // after that to the current size level.
                //

                for (j = i; j > LastAvailable; ) {
                    j--;
                    if (!IsListEmpty(&pBufferPool->FreeLists[j])) {

                        //
                        // Take the first available segment header in
                        // the free list
                        //

                        pNew = LlcRemoveHeadList(&pBufferPool->FreeLists[j]);

                        //
                        // Split segments until we reach the desired level.
                        // We leave every (empty) level between a new segment
                        // header (including the current level  (= i).
                        //

                        k = j;
                        do {
                            k++;

                            //
                            // We must also split the orginal buffer header
                            // and its MDL.
                            //

                            pNew->FreeBuffer.Size /= 2;
                            pNew->FreeBuffer.FreeListIndex++;

                            //
                            // We create the new buffer header for
                            // the upper half of the old buffer segment.
                            //

                            Status = AllocateBufferHeader(
#if DBG
                                            pFileContext,
#endif
                                            pBufferPool,
                                            pNew->FreeBuffer.pParent,
                                            pNew->FreeBuffer.Size,
                                            (UCHAR)(pNew->FreeBuffer.Index +
                                                    pNew->FreeBuffer.Size),
                                            (UINT)k
                                            );

                            //
                            // We cannot stop on error, but we try to
                            // allocate several smaller segments before
                            // we will give up.
                            //

                            if (Status != STATUS_SUCCESS) {

                                //
                                // We couldn't split the buffer, return
                                // the current buffer back to its slot.
                                //

                                pNew->FreeBuffer.Size *= 2;
                                pNew->FreeBuffer.FreeListIndex--;
                                LlcInsertHeadList(&pBufferPool->FreeLists[k-1],
                                                  pNew
                                                  );
                                break;
                            }
                        } while (k != i);
                        break;
                    }
                }

                //
                // Did we succeed to split the bigger segments
                // to smaller ones?
                //

                if (IsListEmpty(&pBufferPool->FreeLists[i])) {

                    //
                    // We have run out of bigger segments, let's try to
                    // use the smaller ones instead.  Indicate, that
                    // there exist no bigger segments than current one.
                    // THIS BREAK STARTS A NEW LOOP WITH A SMALLER
                    // SEGMENT SIZE.
                    //

                    LastAvailable = i;
                    break;
                }
            } else {
                pNew = LlcRemoveHeadList(&pBufferPool->FreeLists[i]);
            }
            pDlcBuffer = (PFIRST_DLC_SEGMENT)
                    ((PUCHAR)pNew->FreeBuffer.pParent->Header.pGlobalVa
                    + (UINT)pNew->FreeBuffer.Index * MIN_DLC_BUFFER_SEGMENT);

            //
            // The buffers must be chained together on three level:
            //      - using kernel Buffer headers (for driver)
            //      - by user pointer (for apps)
            //      - MDLs (for NDIS)
            //

            if (pPrev == NULL) {

                //
                // Frame header - initialize the list
                // HACK-HACK!!!!
                //

                pPrevMdl = NULL;
                pDlcBuffer->Cont.pNext = NULL;
                pLastDlcBuffer = pDlcBuffer;
            } else {
                pPrevMdl = pPrev->FrameBuffer.pMdl;
                pDlcBuffer->Cont.pNext = (PNEXT_DLC_SEGMENT)
                    ((PUCHAR)pPrev->FrameBuffer.pParent->Header.pLocalVa
                    + (UINT)pPrev->FrameBuffer.Index * MIN_DLC_BUFFER_SEGMENT);
            }
            pBufferPool->FreeSpace -= SegmentSize;
            pBufferPool->UncommittedSpace -= SegmentSize;
            pNew->FrameBuffer.pNextFrame = NULL;
            pNew->FrameBuffer.BufferState = BUF_USER;
            pNew->FrameBuffer.pNextSegment = pPrev;
            pNew->FrameBuffer.pParent->Header.FreeSegments -= pNew->FreeBuffer.Size;

#if LLC_DBG

            if ((UINT)(MIN_DLC_BUFFER_SEGMENT * pNew->FreeBuffer.Size) != SegmentSize) {
                DbgPrint("Invalid buffer size.\n");
                DbgBreakPoint();
            }
            CHECK_FREE_SEGMENT_COUNT(pNew);

#endif

            pPrev = pNew;
            pDlcBuffer->Cont.UserOffset = sizeof(NEXT_DLC_SEGMENT);
            pDlcBuffer->Cont.UserLength = (USHORT)UserDataSize;
            pDlcBuffer->Cont.FrameLength = (USHORT)FrameLength;
     	    // Save this length in a local var since pDlcBuffer->Cont.DataLength can be changed by user
            // but this is used later on also.
            SavedDataLength = (USHORT)(SegmentSize - sizeof(NEXT_DLC_SEGMENT) - UserDataSize);
            pDlcBuffer->Cont.DataLength = SavedDataLength;

            //
            // Check if we have done it!
            // Remember, that the buffer size have been round up/over to
            // the next 256 bytes even adderss => we never go negative.
            //
	
     	    // 127041: User can change this value between this and the last instruction
            //BufferSize -= pDlcBuffer->Cont.DataLength;
	        BufferSize -= SavedDataLength;

            if (BufferSize < MIN_DLC_BUFFER_SEGMENT) {
                pDlcBuffer->Cont.UserOffset += (USHORT)FrameHeaderSize;
                pDlcBuffer->Cont.DataLength -= (USHORT)FrameHeaderSize;
                SavedDataLength -= (USHORT)FrameHeaderSize;

                //
                // The data must be read to the beginning of the
                // buffer chain (eg. because of NdisTransferData).
                // => the first buffer must be full and the last
                // one must always be odd. The extra length
                // in the partial MDL does not matter.
                //

                BufferSize -= MIN_DLC_BUFFER_SEGMENT - 1;
                pLastDlcBuffer->Cont.DataLength += (USHORT)BufferSize;

                BuildMappedPartialMdl(
                    pNew->FrameBuffer.pParent->Header.pMdl,
                    pNew->FrameBuffer.pMdl,
                    pNew->FrameBuffer.pParent->Header.pLocalVa
                        + pNew->FrameBuffer.Index * MIN_DLC_BUFFER_SEGMENT
                        + FrameHeaderSize
         		        + UserDataSize
                        + sizeof(NEXT_DLC_SEGMENT),
                        SavedDataLength
                    );
                pNew->FrameBuffer.pMdl->Next = pPrevMdl;

                //
                // The buffer headers must be procted (the flag prevents
                // user to free them back buffer pool before we have
                // indicated the chained receive frames to him).
                // The linkage of frame headers will crash, if
                // the header buffer is released before the frame
                // was indicated!
                //

                pNew->FrameBuffer.BufferState = BUF_RCV_PENDING;
                BufferSize = 0;
                break;
            } else {

                //
                // MDL must exclude the buffer header from the actual data.
                //

                BuildMappedPartialMdl(
                    pNew->FrameBuffer.pParent->Header.pMdl,
                    pNew->FrameBuffer.pMdl,
                    pNew->FrameBuffer.pParent->Header.pLocalVa
                        + pNew->FrameBuffer.Index * MIN_DLC_BUFFER_SEGMENT
                        + UserDataSize
                        + sizeof(NEXT_DLC_SEGMENT),
                    pDlcBuffer->Cont.DataLength
                    );
                pNew->FrameBuffer.pMdl->Next = pPrevMdl;
            }
        }
        SegmentSize /= 2;
    }
    if (BufferSize == 0) {
        Status = STATUS_SUCCESS;
    } else {
        BufferSize -= (MIN_DLC_BUFFER_SEGMENT - 1);

        //
        // The client, that is not running in DPC level may extend
        // the buffer pool, if there is still available space left
        // in the buffer pool
        //

        if (pBufferPool->MaxBufferSize > pBufferPool->BufferPoolSize) {

            //
            // We can expand the buffer pool, sometimes we must
            // allocate new bigger segments, if the available
            // smaller segments cannot satisfy the request.
            //

            if ((LONG)BufferSize > pBufferPool->MissingSize) {
                pBufferPool->MissingSize = (LONG)BufferSize;
            }
            Status = DLC_STATUS_EXPAND_BUFFER_POOL;
        } else {
            Status = DLC_STATUS_INADEQUATE_BUFFERS;
        }
    }

    UNLOCK_BUFFER_POOL();

    *ppBufferHeader = pPrev;
    *puiBufferSizeLeft = BufferSize;

    return Status;
}


NTSTATUS
BufferPoolDeallocate(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferCount,
    IN PLLC_TRANSMIT_DESCRIPTOR pBuffers
    )

/*++

Routine Description:

    Function deallocates the requested buffers. It first checks
    the user buffer in the page table and then adds its header to
    the free list.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    BufferCount - number of user buffers to be released
    pBuffers    - array of the user buffers

Return Value:

    NTSTATUS

--*/

{
    PDLC_BUFFER_HEADER pBuffer;
    UINT i;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;

    ASSUME_IRQL(PASSIVE_LEVEL);

    LOCK_BUFFER_POOL();

    //
    // Return all buffers
    //

    for (i = 0; i < BufferCount; i++) {
        pBuffer = GetBufferHeader(pBufferPool, pBuffers[i].pBuffer);
        if (pBuffer && (pBuffer->FreeBuffer.BufferState == BUF_USER)) {

            register ULONG bufsize;

            //
            // Set the buffer state READY and restore the modified
            // size and offset fields in MDL
            //

            pBuffer->FreeBuffer.BufferState = BUF_READY;
            pBuffer->FreeBuffer.pParent->Header.FreeSegments += pBuffer->FreeBuffer.Size;

#if LLC_DBG
            if (pBuffer->FreeBuffer.pParent->Header.FreeSegments > 16) {
                DbgPrint("Invalid buffer size.\n");
                DbgBreakPoint();
            }
            CHECK_FREE_SEGMENT_COUNT(pBuffer);
#endif

            //
            // a microscopic performance improvement: the compiler (x86 at
            // least) generates the sequence of instructions to work out
            // the buffer size (number of blocks * block size) TWICE,
            // presumably because it can't assume that the structure hasn't
            // changed between the 2 accesses? Anyhow, Nature abhors a
            // vacuum, which is why my house is such a mess
            //

            bufsize = pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;
            pBufferPool->FreeSpace += bufsize;
            pBufferPool->UncommittedSpace += bufsize;
            LlcInsertTailList(&pBufferPool->FreeLists[pBuffer->FreeBuffer.FreeListIndex], pBuffer);
        } else {

            //
            // At least one of the released buffers is invalid,
            // may be already released, or it may not exist in
            // the buffer pool at all
            //

            status = DLC_STATUS_INVALID_BUFFER_ADDRESS;
        }
    }

    UNLOCK_BUFFER_POOL();

    return status;
}


VOID
BufferPoolDeallocateList(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pBufferList
    )

/*++

Routine Description:

    Function deallocates the requested buffer list.
    The buffer list may be circular or null terminated.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    pBufferList - link list of user

Return Value:

    None

--*/

{
    PDLC_BUFFER_HEADER pBuffer, pNextBuffer, pFrameBuffer, pNextFrameBuffer;
    KIRQL irql;

    if (pBufferList == NULL) {
        return;
    }

    LOCK_BUFFER_POOL();

    //
    // Return all buffers to the free lists.
    // The segments are always linked to a null terminated link list.
    // The frames are linked either circular or null terminated
    // link list!
    //
    // Note: both next segment and frame pointers are overlayed with
    // the pPrev and pNext pointers of the double linked free lists.
    //

    pNextFrameBuffer = pBufferList;
    do {
        pBuffer = pFrameBuffer = pNextFrameBuffer;
        pNextFrameBuffer = pFrameBuffer->FrameBuffer.pNextFrame;
        do {
            pNextBuffer = pBuffer->FrameBuffer.pNextSegment;

#if LLC_DBG

            if (pBuffer->FreeBuffer.BufferState != BUF_USER
            && pBuffer->FreeBuffer.BufferState != BUF_RCV_PENDING) {
                DbgBreakPoint();
            }
            if (pBuffer->FreeBuffer.pParent->Header.FreeSegments > 16) {
                DbgPrint("Invalid buffer size.\n");
                DbgBreakPoint();
            }
            CHECK_FREE_SEGMENT_COUNT(pBuffer);

#endif

            //
            // Set the buffer state READY and restore the modified
            // size and offset fields in MDL
            //

            pBuffer->FreeBuffer.BufferState = BUF_READY;
            pBuffer->FreeBuffer.pParent->Header.FreeSegments += pBuffer->FreeBuffer.Size;
            pBufferPool->FreeSpace += pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;
            pBufferPool->UncommittedSpace += pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;
            LlcInsertTailList(&pBufferPool->FreeLists[pBuffer->FreeBuffer.FreeListIndex],
                              pBuffer
                              );
        } while ( pBuffer = pNextBuffer );
    } while (pNextFrameBuffer && (pNextFrameBuffer != pBufferList));

    UNLOCK_BUFFER_POOL();

}


NTSTATUS
BufferPoolBuildXmitBuffers(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferCount,
    IN PLLC_TRANSMIT_DESCRIPTOR pBuffers,
    IN OUT PDLC_PACKET pPacket
    )

/*++

Routine Description:

    Function build a MDL and buffer header list for a frame defined by
    a scatter/gather array. All buffers outside the buffer pool
    are probed and locked. All MDLs (the locked and ones for buffer pool)
    are chained together. The buffer pool headers are also chained.
    If any errors have been found the buffers are released using the
    reverse function (BufferPoolFreeXmitBuffers).

    THIS FUNCTION HAS A VERY SPECIAL SPIN LOCKING DESIGN:

    First we free the global spin lock (and lower the IRQ level to the lowest),
    Then, if the transmit is made from DLC buffers, we lock the
    spin lock again using NdisSpinLock function, that saves and restores
    the IRQL level, when it acquires and releases the spin lock.

    This all is done to minimize the spin locking overhead when we are
    locking transmit buffers, that are usually DLC buffers or normal
    user memory but not both.

Arguments:

    pBufferPool - handle of buffer pool data structure, THIS MAY BE NULL!!!!
    BufferCount - number of user buffers in the frame
    pBuffers    - array of the user buffers of the frame
    pPacket     - generic DLC packet used in transmit

Return Value:

    NTSTATUS

--*/

{
    PDLC_BUFFER_HEADER pBuffer, pPrevBuffer = NULL;
    PMDL pMdl, pPrevMdl = NULL;
    INT i;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN FirstBuffer = TRUE;
    UINT InfoFieldLength = 0;
    BOOLEAN BufferPoolIsLocked = FALSE; // very neat optimization!
    KIRQL irql;

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // The client may allocate buffer headers without any buffers!
    //

    if (BufferCount != 0) {

        //
        // walk the buffers in a reverse order to build the
        // list in a convinient way.
        //

        for (i = BufferCount - 1; i >= 0; i--) {

            if (pBuffers[i].cbBuffer == 0) {
                continue;
            }

            InfoFieldLength += pBuffers[i].cbBuffer;

            //
            // Check first if the given address is in the same area as the
            // buffer pool
            //

            if (pBufferPool != NULL
            && (ULONG_PTR)pBuffers[i].pBuffer >= (ULONG_PTR)pBufferPool->BaseOffset
            && (ULONG_PTR)pBuffers[i].pBuffer < (ULONG_PTR)pBufferPool->MaxOffset) {

                //
                // Usually all transmit buffers are either in the buffer
                // pool or they are elsewhere in the user memory.
                // This boolean flag prevents us to toggle the buffer
                // pool spinlock for each transmit buffer segment.
                // (and nt spinlock is slower than its critical section!!!)
                //

                if (BufferPoolIsLocked == FALSE) {

                    LOCK_BUFFER_POOL();

                    BufferPoolIsLocked = TRUE;
                }
            }

            //
            // The previous check does not yet garantee, that the given buffer
            // if really a buffer pool segment, but the buffer pool is
            // is now unlocked if it was aboslutely outside of the buffer pool,
            // GetBufferHeader- function requires, that the buffer pool
            // is locked, when it is called!
            //

            if (BufferPoolIsLocked
            && (pBuffer = GetBufferHeader(pBufferPool, pBuffers[i].pBuffer)) != NULL) {

                //
                // The provided buffer must be inside the allocated
                // buffer, otherwise the user has corrupted its buffers.
                // user offset within buffer + user length <= buffer
                // length
                // The buffer must be also be owned by the user
                //

                if (((ULONG_PTR)pBuffers[i].pBuffer & (MIN_DLC_BUFFER_SEGMENT - 1))
                         + (ULONG)pBuffers[i].cbBuffer
                         > (ULONG)(pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT)
                    || (pBuffer->FrameBuffer.BufferState & BUF_USER) == 0) {

                    Status = DLC_STATUS_BUFFER_SIZE_EXCEEDED;
                    break;
                }

                //
                // The same DLC buffer may be referenced several times.
                // Create a partial MDL for it and add the reference
                // counter.
                //

                if (pBuffer->FrameBuffer.BufferState & BUF_LOCKED) {
                    pMdl = IoAllocateMdl(pBuffers[i].pBuffer,
                                         pBuffers[i].cbBuffer,
                                         FALSE, // not used (no IRP)
                                         FALSE, // can't charge from quota now
                                         NULL   // Do not link it to IRPs
                                         );
                    if (pMdl == NULL) {
                        Status = DLC_STATUS_NO_MEMORY;
                        break;
                    }

                    DBG_INTERLOCKED_INCREMENT(AllocatedMdlCount);

                    BuildMappedPartialMdl(pBuffer->FrameBuffer.pParent->Header.pMdl,
                                          pMdl,
                                          pBuffers[i].pBuffer,
                                          pBuffers[i].cbBuffer
                                          );
                    pBuffer->FrameBuffer.ReferenceCount++;

                    if (pBuffers[i].boolFreeBuffer) {
                        pBuffer->FrameBuffer.BufferState |= DEALLOCATE_AFTER_USE;
                    }

                } else {

                    //
                    // Modify the MDL for this request, the length must
                    // not be bigger than the buffer length and the
                    // offset must be within the first 255 bytes of
                    // the buffer.  Build also the buffer header list
                    // (i don't know why?)
                    //

                    pMdl = pBuffer->FrameBuffer.pMdl;

                    if (

                    ((UINT)(ULONG_PTR)pBuffers[i].pBuffer & (MIN_DLC_BUFFER_SEGMENT - 1))

                    + pBuffers[i].cbBuffer

                    > (UINT)pBuffer->FrameBuffer.Size * MIN_DLC_BUFFER_SEGMENT) {

                        Status = DLC_STATUS_INVALID_BUFFER_LENGTH;
                        break;
                    }

                    pBuffer->FrameBuffer.pNextSegment = pPrevBuffer;
                    pBuffer->FrameBuffer.BufferState |= BUF_LOCKED;
                    pBuffer->FrameBuffer.ReferenceCount = 1;

                    if (pBuffers[i].boolFreeBuffer) {
                        pBuffer->FrameBuffer.BufferState |= DEALLOCATE_AFTER_USE;
                    }
                    pPrevBuffer = pBuffer;

                    //
                    // DLC applications may change the user length or
                    // buffer length of the frames given to them =>
                    // we must reinitialize global buffer and its length
                    //

                    BuildMappedPartialMdl(pBuffer->FrameBuffer.pParent->Header.pMdl,
                                          pMdl,
                                          pBuffers[i].pBuffer,
                                          pBuffers[i].cbBuffer
                                          );
                }
            } else {
                if (BufferPoolIsLocked == TRUE) {

                    UNLOCK_BUFFER_POOL();

                    BufferPoolIsLocked = FALSE;
                }

                //
                // Setup the exception handler around the memory manager
                // calls and clean up any extra data if this fails.
                //

                pMdl = AllocateProbeAndLockMdl(pBuffers[i].pBuffer, pBuffers[i].cbBuffer);
                if (pMdl == NULL) {
                    Status = DLC_STATUS_MEMORY_LOCK_FAILED;

#if DBG
                    DbgPrint("DLC.BufferPoolBuildXmitBuffers: AllocateProbeAndLockMdl(a=%x, l=%x) failed\n",
                            pBuffers[i].pBuffer,
                            pBuffers[i].cbBuffer
                            );
#endif

                    break;
                }

#if LLC_DBG
                cLockedXmitBuffers++;
#endif

            }

            //
            // Chain all MDLs together
            //

            pMdl->Next = pPrevMdl;
            pPrevMdl = pMdl;
        }
    }
    if (BufferPoolIsLocked == TRUE) {

        UNLOCK_BUFFER_POOL();

    }

    pPacket->Node.pNextSegment = pPrevBuffer;
    pPacket->Node.pMdl = pPrevMdl;
    pPacket->Node.LlcPacket.InformationLength = (USHORT)InfoFieldLength;

    if (Status != STATUS_SUCCESS) {

        //
        // Free all allocated buffer (but the last one because there
        // was an error with it)
        //

        BufferPoolFreeXmitBuffers(pBufferPool, pPacket);
    }
    return Status;
}


VOID
BufferPoolFreeXmitBuffers(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_PACKET pXmitNode
    )

/*++

Routine Description:

    Function unlocks the xmit buffers that are not in the buffer pool.
    The caller must use DeallocateBufferPool routine to
    and deallocates and the buffers are returned back to the pool.
    The function has to separate the MDLs of user buffers and
    buffer pool MDLs.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    pXmitNode   - pointer to a structure, that includes the buffer header list,
                  MDL chain or it chains serveral transmits nodes and IRP together.

Return Value:

    None

--*/

{
    PDLC_BUFFER_HEADER pBuffer;
    PDLC_BUFFER_HEADER pOtherBuffer = NULL;
    PDLC_BUFFER_HEADER pNextBuffer = NULL;
    PMDL pMdl, pNextMdl;
    KIRQL irql;

#if LLC_DBG
    BOOLEAN FrameCounted = FALSE;
#endif

    //
    // Free all DLC buffers and MDLs linked in the transmit node.
    // MDL list may be larger than the buffer header list.
    //

    if (pXmitNode != NULL) {
        if (pBufferPool != NULL) {

            LOCK_BUFFER_POOL();

        }
        pBuffer = pXmitNode->Node.pNextSegment;
        for (pMdl = pXmitNode->Node.pMdl; pMdl != NULL; pMdl = pNextMdl) {
            pNextMdl = pMdl->Next;
            pMdl->Next = NULL;

            //
            // Unlock only those MDLs, that are outside the buffer pool.
            //

            if ((pBuffer == NULL || pBuffer->FrameBuffer.pMdl != pMdl)
            && (pOtherBuffer = GetBufferHeader(pBufferPool, MmGetMdlVirtualAddress(pMdl))) == NULL) {

#if LLC_DBG
                cUnlockedXmitBuffers++;
#endif

                UnlockAndFreeMdl(pMdl);
            } else {

                //
                // This pointer can be NULL only if the first condition
                // if the previous 'if statement' was true => this cannot
                // be an orginal buffer header.
                //

                if (pOtherBuffer != NULL) {

                    //
                    // This is not the first reference of the buffer pool
                    // segment, but a partial MDL created by a new
                    // reference to a buffer segment already in use.
                    // Free the paritial MDL and setup the buffer
                    // pointer for the next loop.
                    //

                    pNextBuffer = pBuffer;
                    pBuffer = pOtherBuffer;
                    pOtherBuffer = NULL;
                    IoFreeMdl(pMdl);
                    DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
                } else if (pBuffer != NULL) {

                    //
                    // This is the orginal refence of the buffer pool
                    // segment, we may advance also in the buffer header
                    // link list.
                    //

                    pNextBuffer = pBuffer->FrameBuffer.pNextSegment;
                }

                //
                // The same DLC buffer may be referenced several times.
                // Decrement the reference counter and free the
                // list if this was the last released reference.
                //

                pBuffer->FrameBuffer.ReferenceCount--;
                if (pBuffer->FrameBuffer.ReferenceCount == 0) {
                    if (pBuffer->FrameBuffer.BufferState & DEALLOCATE_AFTER_USE) {

                        //
                        // Set the buffer state READY and restore the modified
                        // size and offset fields in MDL
                        //

                        pBuffer->FreeBuffer.BufferState = BUF_READY;
                        pBuffer->FreeBuffer.pParent->Header.FreeSegments += pBuffer->FreeBuffer.Size;

#if LLC_DBG
                        if (pBuffer->FreeBuffer.pParent->Header.FreeSegments > 16) {
                            DbgPrint("Invalid buffer size.\n");
                            DbgBreakPoint();
                        }
                        CHECK_FREE_SEGMENT_COUNT(pBuffer);
#endif

                        pBufferPool->FreeSpace += (UINT)pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;
                        pBufferPool->UncommittedSpace += (UINT)pBuffer->FreeBuffer.Size * MIN_DLC_BUFFER_SEGMENT;

                        LlcInsertTailList(&pBufferPool->FreeLists[pBuffer->FreeBuffer.FreeListIndex], pBuffer);

#if LLC_DBG
                        if (FrameCounted == FALSE) {
                            FrameCounted = TRUE;
                            cFramesReleased++;
                        }
#endif

                    } else {
                        pBuffer->FreeBuffer.BufferState = BUF_USER;
                    }
                }
                pBuffer = pNextBuffer;
            }
        }
        if (pBufferPool != NULL) {

            UNLOCK_BUFFER_POOL();

        }
    }
}


PDLC_BUFFER_HEADER
GetBufferHeader(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PVOID pUserBuffer
    )

/*++

Routine Description:

    Function returns the buffer pool header of the given
    buffer in the user address space or NULL, if the given
    address has no buffer.

Arguments:

    pBufferPool - handle of buffer pool data structure.
    pUserBuffer - DLC buffer address in user memory

Return Value:

    Pointer of DLC buffer header
    or NULL (if not found)

--*/

{
    UINT PageTableIndex;
    UINT IndexWithinPage;
    PDLC_BUFFER_HEADER pBuffer;

    //
    // The buffer pool may not exist, when we are transmitting frames.
    //

    if (pBufferPool == NULL) {
        return NULL;
    }

    PageTableIndex = (UINT)(((ULONG_PTR)pUserBuffer - (ULONG_PTR)pBufferPool->BaseOffset)
                   / MAX_DLC_BUFFER_SEGMENT);

    //
    // We simply discard the buffers outside the preallocated
    // virtual buffer in user space.  We must also check,
    // that the buffer is really reserved and locked (ie.
    // it is not in the free list of unlocked entries).
    // Note, that the buffer pool base address have been aligned with
    // the maximum buffer segment size.
    //

    if (PageTableIndex >= (UINT)pBufferPool->MaximumIndex
    || ((ULONG_PTR)pBufferPool->BufferHeaders[PageTableIndex] >= (ULONG_PTR)pBufferPool->BufferHeaders
    && (ULONG_PTR)pBufferPool->BufferHeaders[PageTableIndex] < (ULONG_PTR)&pBufferPool->BufferHeaders[pBufferPool->MaximumIndex])) {
        return NULL;
    }

    IndexWithinPage = (UINT)(((ULONG_PTR)pUserBuffer & (MAX_DLC_BUFFER_SEGMENT - 1)) / MIN_DLC_BUFFER_SEGMENT);

    for (
        pBuffer = pBufferPool->BufferHeaders[PageTableIndex]->Header.pNextChild;
        pBuffer != NULL;
        pBuffer = pBuffer->FreeBuffer.pNextChild) {

        if (pBuffer->FreeBuffer.Index == (UCHAR)IndexWithinPage) {

            //
            // We MUST not return a locked buffer, otherwise the app
            // will corrupt the whole buffer pool.
            //

            if ((pBuffer->FreeBuffer.BufferState & BUF_USER) == 0) {
                return NULL;
            } else {
                return pBuffer;
            }
        }
    }
    return NULL;
}


VOID
BufferPoolDereference(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL *ppBufferPool
    )

/*++

Routine Description:

    This routine decrements the reference count of the buffer pool
    and deletes it when the reference count hits to zero.

Arguments:

    pFileContext    - pointer to DLC_FILE_CONTEXT
    pBufferPool     - opaque handle of buffer pool data structure.

Return Value:

    None

--*/

{
    PDLC_BUFFER_HEADER pBufferHeader, pNextHeader;
    KIRQL irql;
    PDLC_BUFFER_POOL pBufferPool = *ppBufferPool;

    ASSUME_IRQL(ANY_IRQL);

    *ppBufferPool = NULL;

    if (pBufferPool == NULL) {
        return;
    }

    LOCK_BUFFER_POOL();

    if (pBufferPool->ReferenceCount != 0) {
        pBufferPool->ReferenceCount--;
    }
    if (pBufferPool->ReferenceCount == 0) {

        KIRQL Irql2;

        ACQUIRE_DLC_LOCK(Irql2);

        RemoveFromLinkList((PVOID*)&pBufferPools, pBufferPool);

        RELEASE_DLC_LOCK(Irql2);

        //
        // The buffer pool does not exist any more !!!
        // => we can remove the spin lock and free all resources
        //

        UNLOCK_BUFFER_POOL();

        for (pBufferHeader = (PDLC_BUFFER_HEADER)pBufferPool->PageHeaders.Flink;
             !IsListEmpty(&pBufferPool->PageHeaders);
             pBufferHeader = pNextHeader) {

            pNextHeader = pBufferHeader->Header.pNextHeader;
#if DBG
            DeallocateBuffer(pFileContext, pBufferPool, pBufferHeader);
#else
            DeallocateBuffer(pBufferPool, pBufferHeader);
#endif

        }

        DELETE_BUFFER_POOL_FILE(&pBufferPool->hHeaderPool);

        FREE_MEMORY_DRIVER(pBufferPool);

    } else {

#if DBG

        DbgPrint("Buffer pool not released, reference count = %d\n",
                 pBufferPool->ReferenceCount
                 );

#endif

        UNLOCK_BUFFER_POOL();

    }
}


NTSTATUS
BufferPoolReference(
    IN HANDLE hExternalHandle,
    OUT PVOID *phOpaqueHandle
    )

/*++

Routine Description:

    This routine translates the the external buffer pool handle to
    a local opaque handle (=void pointer of the structure) and
    optioanlly checks the access rights of the current process to
    the buffer pool memory. The probing may raise an exeption to
    the IO- system, that will return error when this terminates.
    The function also increments the reference count of the buffer pool.

Arguments:

    hExternalHandle - buffer handle allocated from the handle table
    phOpaqueHandle  - opaque handle of buffer pool data structure

Return Value:

    None

--*/

{
    PDLC_BUFFER_POOL pBufferPool;
    NTSTATUS Status;
    KIRQL irql;

    ASSUME_IRQL(DISPATCH_LEVEL);

    ACQUIRE_DLC_LOCK(irql);

    for (pBufferPool = pBufferPools; pBufferPool != NULL; pBufferPool = pBufferPool->pNext) {
        if (pBufferPool == hExternalHandle) {
            break;
        }
    }

    RELEASE_DLC_LOCK(irql);

    if (pBufferPool == NULL) {
        return DLC_STATUS_INVALID_BUFFER_HANDLE;
    }

    //
    // We must do the optional probing outside of the spinlocks
    // and before we have incremented the reference count.
    // We do only read probing, because it is simpler.
    //

    RELEASE_DRIVER_LOCK();

    Status = ProbeVirtualBuffer(pBufferPool->BaseOffset, pBufferPool->BufferPoolSize);

    ACQUIRE_DRIVER_LOCK();

    if (Status == STATUS_SUCCESS) {

        LOCK_BUFFER_POOL();

        pBufferPool->ReferenceCount++;
        *phOpaqueHandle = (PVOID)pBufferPool;

        UNLOCK_BUFFER_POOL();

    }
    return Status;
}


NTSTATUS
ProbeVirtualBuffer(
    IN PUCHAR pBuffer,
    IN LONG Length
    )

/*++

Routine Description:

    Tests an address range for accessability. Actually reads the first and last
    DWORDs in the address range, and assumes the rest of the memory is paged-in.

Arguments:

    pBuffer - address to test
    Length  - in bytes of region to check

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_MEMORY_LOCK_FAILED

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    ASSUME_IRQL(PASSIVE_LEVEL);

    try {
        ProbeForRead(pBuffer, Length, sizeof(UCHAR));
    } except(EXCEPTION_EXECUTE_HANDLER) {

#if DBG
        DbgPrint("DLC.ProbeVirtualBuffer: Error: Can't ProbeForRead a=%x, l=%x\n",
                pBuffer,
                Length
                );
#endif

        status = DLC_STATUS_MEMORY_LOCK_FAILED;
    }
    return status;
}


PMDL
AllocateProbeAndLockMdl(
    IN PVOID UserBuffer,
    IN UINT UserBufferLength
    )

/*++

Routine Description:

    This function just allocates, probes, locks and optionally maps
    any user buffer to kernel space.  Returns NULL, if the operation
    fails for any reason.

Remarks:

    This routine can be called only below DPC level and when the user
    context is known (ie. a spin locks must not be set!).

Arguments:

    UserBuffer          - user space address
    UserBufferLength    - length of that buffer is user space

Return Value:

    PMDL - pointer if successful
    NULL if not successful

--*/

{
    PMDL pMdl;

    ASSUME_IRQL(PASSIVE_LEVEL);

    try {
        pMdl = IoAllocateMdl(UserBuffer,
                             UserBufferLength,
                             FALSE, // not used (no IRP)
                             FALSE, // we don't charge the non-paged pool quota
                             NULL   // Do not link it to IRP
                             );
        if (pMdl != NULL) {

#if DBG
            IF_DIAG(MDL_ALLOC) {

                PVOID caller, callerscaller;

                RtlGetCallersAddress(&caller, &callerscaller);
                DbgPrint("A: pMdl=%#x caller=%#x caller's=%#x\n",
                         pMdl,
                         caller,
                         callerscaller
                         );
            }
#endif

            DBG_INTERLOCKED_INCREMENT(AllocatedMdlCount);

            MmProbeAndLockPages(pMdl,
                                UserMode,   // Current user must have access!
                                IoModifyAccess
                                );

            DBG_INTERLOCKED_ADD(
                LockedPageCount,
                +(ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                    ((ULONG)pMdl->StartVa | pMdl->ByteOffset),
                    pMdl->ByteCount))
                );
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        DBG_INTERLOCKED_INCREMENT(FailedMemoryLockings);
        if (pMdl != NULL) {
            IoFreeMdl(pMdl);
            DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
            pMdl = NULL;
        }
    }
    return pMdl;
}


VOID
BuildMappedPartialMdl(
    IN PMDL pSourceMdl,
    IN OUT PMDL pTargetMdl,
    IN PVOID BaseVa,
    IN ULONG Length
    )

/*++

Routine Description:

    This function builds a partial MDL from a mapped source MDL.
    The target MDL must have been initialized for the given size.
    The target MDL cannot be used after the source MDL has been
    unmapped.

Remarks:

    MDL_PARTIAL_HAS_BEEN_MAPPED flag is not set in MdlFlag to
    prevent IoFreeMdl to unmap the virtual address.

Arguments:

    pSourceMdl  - Mapped source MDL
    pTargetMdl  - Allocate MDL
    BaseVa      - virtual base address
    Length      - length of the data

Return Value:

    None

--*/

{
    ASSUME_IRQL(ANY_IRQL);

    if (Length) {
        LlcMemCpy(&pTargetMdl[1],
                  &pSourceMdl[1],
                  (UINT)(sizeof(ULONG) * ADDRESS_AND_SIZE_TO_SPAN_PAGES(BaseVa, Length))
                  );
    }
    pTargetMdl->Next = NULL;
    pTargetMdl->StartVa = (PVOID)PAGE_ALIGN(BaseVa);
    pTargetMdl->ByteOffset = BYTE_OFFSET(BaseVa);
    pTargetMdl->ByteCount = Length;

    //
    // HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK-HACK
    //
    // The excellent NT memory manager doesn't provide any fast way to
    // create temporary MDLs that will be deallocated before their
    // actual source MDLs.
    // We will never map this MDL, because its mapped orginal source mdl
    // will be kept in memory until this (and its peers) have been
    // deallocated.
    //

    pTargetMdl->MdlFlags = (UCHAR)((pTargetMdl->MdlFlags & ~MDL_MAPPED_TO_SYSTEM_VA)
                         | MDL_SOURCE_IS_NONPAGED_POOL);

    pTargetMdl->MappedSystemVa = (PVOID)((PCHAR)MmGetSystemAddressForMdl(pSourceMdl)
                               + ((ULONG_PTR)BaseVa - (ULONG_PTR)MmGetMdlVirtualAddress(pSourceMdl)));
}


VOID
UnlockAndFreeMdl(
    PMDL pMdl
    )

/*++

Routine Description:

    This function unmaps (if not a partial buffer), unlocks and
    and free a MDL.

    OK to call at DISPATCH_LEVEL

Arguments:

    pMdl - pointer to MDL to free

Return Value:

    None

--*/

{
    ASSUME_IRQL(ANY_IRQL);

    DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
    DBG_INTERLOCKED_ADD(LockedPageCount,
                        -(ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                            ((ULONG)((PMDL)pMdl)->StartVa | ((PMDL)pMdl)->ByteOffset),
                            (((PMDL)pMdl)->ByteCount)))
                        );

    MmUnlockPages((PMDL)pMdl);
    IoFreeMdl((PMDL)pMdl);

#if DBG

    IF_DIAG(MDL_ALLOC) {

        PVOID caller, callerscaller;

        RtlGetCallersAddress(&caller, &callerscaller);
        DbgPrint("F: pMdl=%#x caller=%#x caller's=%#x\n",
                 pMdl,
                 caller,
                 callerscaller
                 );
    }

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlccncl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlccncl.c

Abstract:

    This module contains functions which handle IRP cancellations for DLC
    commands

    Contents:
        SetIrpCancelRoutine
        DlcCancelIrp
        CancelCommandIrp
        CancelTransmitIrp
        (MapIoctlCode)

Author:

    Richard L Firth (rfirth) 22-Mar-1993

Environment:

    kernel mode only

Revision History:

    22-Mar-1993 rfirth
        Created

--*/

#include "dlc.h"

VOID
CancelCommandIrp(
    IN PIRP Irp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PLIST_ENTRY Queue
    );

VOID
CancelTransmitIrp(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext
    );

#if DBG
PSTR MapIoctlCode(ULONG);

//BOOLEAN DebugCancel = TRUE;
BOOLEAN DebugCancel = FALSE;
#endif


VOID
SetIrpCancelRoutine(
    IN PIRP Irp,
    IN BOOLEAN Set
    )

/*++

Routine Description:

    Sets or resets the cancel routine in a cancellable IRP. We MUST NOT be
    holding the driver spinlock when we call this function - if another thread
    is cancelling an IRP we will deadlock - exactly the reason why we now only
    have a single spinlock for the DLC driver!

Arguments:

    Irp - pointer to cancellable IRP
    Set - TRUE if the cancel routine in the IRP is to be set to DlcCancelIrp
          else the cancel routine is set to NULL (no longer cancellable)

Return Value:

    None.

--*/

{
    KIRQL irql;

    
    IoAcquireCancelSpinLock(&irql);

    if (!Irp->Cancel) {

        IoSetCancelRoutine(Irp, Set ? DlcCancelIrp : NULL);

    }

    IoReleaseCancelSpinLock(irql);
}


VOID
DlcCancelIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is set as the cancel function in all cancellable DLC IRPs -
    TRANSMIT, RECEIVE and READ

    NB: !!! IopCancelSpinLock is held when this function is called !!!

Arguments:

    DeviceObject    - pointer to DEVICE_OBJECT
    Irp             - pointer to IRP being cancelled

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpStack;
    ULONG command;
    PDLC_FILE_CONTEXT pFileContext;
    PLIST_ENTRY queue;

    IoSetCancelRoutine(Irp, NULL);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    if (DebugCancel) {
        DbgPrint("DlcCancelIrp. IRP @ %08X Type = %08X [%s]\n",
                 Irp,
                 irpStack->Parameters.DeviceIoControl.IoControlCode,
                 MapIoctlCode(irpStack->Parameters.DeviceIoControl.IoControlCode)
                 );
    }
#endif

    pFileContext = irpStack->FileObject->FsContext;
    command = irpStack->Parameters.DeviceIoControl.IoControlCode;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    ACQUIRE_DRIVER_LOCK();

    ENTER_DLC(pFileContext);

    switch (command) {
    case IOCTL_DLC_READ:
    case IOCTL_DLC_READ2:
        queue = &pFileContext->CommandQueue;
        break;

    case IOCTL_DLC_RECEIVE:
    case IOCTL_DLC_RECEIVE2:
        queue = &pFileContext->ReceiveQueue;
        break;

    case IOCTL_DLC_TRANSMIT:
    case IOCTL_DLC_TRANSMIT2:
        CancelTransmitIrp(Irp, pFileContext);
        queue = NULL;
        break;

    default:

#if DBG
        DbgPrint("DlcCancelIrp: didn't expect to cancel %s: add handler!\n", MapIoctlCode(command));
#endif

        queue = NULL;

    }

    if (queue) {
        CancelCommandIrp(Irp, pFileContext, queue);
    }

    LEAVE_DLC(pFileContext);

    RELEASE_DRIVER_LOCK();

}


VOID
CancelCommandIrp(
    IN PIRP Irp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PLIST_ENTRY Queue
    )

/*++

Routine Description:

    Cancels a pending I/O request. Typically, this will be one of the DLC requests
    which stays pending for a long time e.g. READ or RECEIVE

Arguments:

    Irp             - IRP to cancel
    pFileContext    - file context owning command to cancel
    Queue           - pointer to command queue from which to delete

Return Value:

    None.

--*/

{
    PDLC_COMMAND pCmdPacket;
    PVOID searchHandle;
    BOOLEAN IsReceive;
    USHORT StationId;
    PDLC_OBJECT pAbortedObject = NULL;

#if DBG
    if (DebugCancel) {
        DbgPrint("CancelCommandIrp\n");
    }
#endif

    //
    // the thing to search for is the address of the CCB
    //

    searchHandle = ((PNT_DLC_PARMS)Irp->AssociatedIrp.SystemBuffer)->Async.Ccb.pCcbAddress;

    if (((PNT_DLC_PARMS)Irp->AssociatedIrp.SystemBuffer)->Async.Ccb.uchDlcCommand == LLC_RECEIVE) {
        StationId = ((PNT_DLC_PARMS)Irp->AssociatedIrp.SystemBuffer)->Async.Parms.Receive.usStationId;
        GetStation(pFileContext, StationId, &pAbortedObject);
        IsReceive = TRUE;
    } else {
        IsReceive = FALSE;
    }

    //
    // remove the command info from this file context's command queue
    //

    pCmdPacket = SearchAndRemoveSpecificCommand(Queue, searchHandle);
    if (pCmdPacket) {

        //
        // if we are cancelling a RECEIVE which has a non-NULL data completion
        // flag then we also need to dissociate the receive parameters (the
        // address of the system buffer in the IRP being cancelled)
        //

        if (IsReceive
        && pAbortedObject
        && pCmdPacket->pIrp->AssociatedIrp.SystemBuffer == pAbortedObject->pRcvParms) {
            pAbortedObject->pRcvParms = NULL;
        }

        //
        // increment file context reference count; CompleteAsyncCommand will
        // dereference the file context
        //

        ReferenceFileContext(pFileContext);
        CompleteAsyncCommand(pFileContext,
                             DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION,
                             Irp,
                             NULL,  // pointer for pNext field
                             TRUE   // called on cancel path
                             );

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pCmdPacket);

        DereferenceFileContext(pFileContext);
    } else {

        //
        // race condition?: the command completed before we got chance to cancel it
        //

#if DBG
        DbgPrint("DLC.CancelCommandIrp: Command NOT located. CCB=%08X\n", searchHandle);
#endif

    }
}


VOID
CancelTransmitIrp(
    IN PIRP Irp,
    IN PDLC_FILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Cancels a pending transmit command. We are only interested in I-Frame
    transmit requests since these only complete when a corresponding ACK is
    received from the remote station. U-Frame transmissions don't get retried
    so will normally complete virtually immediately

	This routine currently does nothing in the retail version, and just
	complains about things in the debug version.

	Cancel transmit is not defined in the IBM LAN Reference, nor is it
	defined for NT DLC.  This is only called by the IO subsystem when
	somebody terminates a thread or process with outstanding IO requests
	that include a DLC transmit request.

	For application termination, this is not really a problem since eventually
	the termination process will close the application's FileContext(s) and
	all SAPs, link stations, etc. belonging to the application will get closed
	down anyway.

	For thread termination, it is a real problem if an application abandons
	a transmit (usually Transmit I-Frame) by closing the thread that
	requested the transmit.  DLC has no defined course of action to toss
	the transmit, without changing the associated link station state.  This
	happened with hpmon.dll when the remote station (printer) got jammed
	and sent Receiver Not Ready in response to attempts to give it the
	frame.  When something like this happens, it is up to the application
	to reset or close the link station, or wait, and not rely on thread
	termination to do the right thing here (because it won't).

Arguments:

    Irp             - pointer to IRP to cancel
    pFileContext    - pointer to owning file context

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpStack;
    PNT_DLC_CCB pCcb;

#if DBG

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    pCcb = &((PNT_DLC_PARMS)Irp->AssociatedIrp.SystemBuffer)->Async.Ccb;

#endif

#if DBG

    DbgPrint("DLC.CancelTransmitIrp: Cancel %s not supported! CCB %08X\n",
             pCcb->uchDlcCommand == LLC_TRANSMIT_FRAMES ? "TRANSMIT_FRAMES"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_DIR_FRAME ? "TRANSMIT_DIR_FRAME"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_UI_FRAME ? "TRANSMIT_UI_FRAME"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_XID_CMD ? "TRANSMIT_XID_CMD"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_XID_RESP_FINAL ? "TRANSMIT_XID_RESP_FINAL"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_XID_RESP_NOT_FINAL ? "TRANSMIT_XID_RESP_NOT_FINAL"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_TEST_CMD ? "TRANSMIT_TEST_CMD"
             : pCcb->uchDlcCommand == LLC_TRANSMIT_I_FRAME ? "TRANSMIT_I_FRAME"
             : "UNKNOWN TRANSMIT COMMAND!",
             pCcb
             );

	ASSERT ( pCcb->uchDlcCommand != LLC_TRANSMIT_I_FRAME );

#endif

}

#if DBG
PSTR MapIoctlCode(ULONG IoctlCode) {
    switch (IoctlCode) {
    case IOCTL_DLC_READ:
        return "READ";

    case IOCTL_DLC_RECEIVE:
        return "RECEIVE";

    case IOCTL_DLC_TRANSMIT:
        return "TRANSMIT";

    case IOCTL_DLC_BUFFER_FREE:
        return "BUFFER_FREE";

    case IOCTL_DLC_BUFFER_GET:
        return "BUFFER_GET";

    case IOCTL_DLC_BUFFER_CREATE:
        return "BUFFER_CREATE";

    case IOCTL_DLC_SET_EXCEPTION_FLAGS:
        return "SET_EXCEPTION_FLAGS";

    case IOCTL_DLC_CLOSE_STATION:
        return "CLOSE_STATION";

    case IOCTL_DLC_CONNECT_STATION:
        return "CONNECT_STATION";

    case IOCTL_DLC_FLOW_CONTROL:
        return "FLOW_CONTROL";

    case IOCTL_DLC_OPEN_STATION:
        return "OPEN_STATION";

    case IOCTL_DLC_RESET:
        return "RESET";

    case IOCTL_DLC_READ_CANCEL:
        return "READ_CANCEL";

    case IOCTL_DLC_RECEIVE_CANCEL:
        return "RECEIVE_CANCEL";

    case IOCTL_DLC_QUERY_INFORMATION:
        return "QUERY_INFORMATION";

    case IOCTL_DLC_SET_INFORMATION:
        return "SET_INFORMATION";

    case IOCTL_DLC_TIMER_CANCEL:
        return "TIMER_CANCEL";

    case IOCTL_DLC_TIMER_CANCEL_GROUP:
        return "TIMER_CANCEL_GROUP";

    case IOCTL_DLC_TIMER_SET:
        return "TIMER_SET";

    case IOCTL_DLC_OPEN_SAP:
        return "OPEN_SAP";

    case IOCTL_DLC_CLOSE_SAP:
        return "CLOSE_SAP";

    case IOCTL_DLC_OPEN_DIRECT:
        return "OPEN_DIRECT";

    case IOCTL_DLC_CLOSE_DIRECT:
        return "CLOSE_DIRECT";

    case IOCTL_DLC_OPEN_ADAPTER:
        return "OPEN_ADAPTER";

    case IOCTL_DLC_CLOSE_ADAPTER:
        return "CLOSE_ADAPTER";

    case IOCTL_DLC_REALLOCTE_STATION:
        return "REALLOCTE_STATION";

    case IOCTL_DLC_READ2:
        return "READ2";

    case IOCTL_DLC_RECEIVE2:
        return "RECEIVE2";

    case IOCTL_DLC_TRANSMIT2:
        return "TRANSMIT2";

    case IOCTL_DLC_COMPLETE_COMMAND:
        return "COMPLETE_COMMAND";

    case IOCTL_DLC_TRACE_INITIALIZE:
        return "TRACE_INITIALIZE";

    }
    return "*** UNKNOWN IOCTL CODE ***";
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcdebug.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcdebug.h

Abstract:

    Contains various debugging/diagnostic stuff for DLC.SYS, checked

Author:

    Richard L Firth (rfirth) 25-Jun-1992

Revision History:

--*/

#if DBG

#ifdef DEFINE_DLC_DIAGNOSTICS

//
// we can preset the diagnostics at compile-time by defining DEFAULT_DIAGNOSTICS
//

#ifndef DEFAULT_DIAGNOSTICS

#define DEFAULT_DIAGNOSTICS 0

#endif

ULONG   DlcDiagnostics = DEFAULT_DIAGNOSTICS;

#else

extern  ULONG   DlcDiagnostics;

#endif

#define DIAG_FUNCTION_NAME  0x00000001
#define DIAG_MDL_ALLOC      0x00000002
#define DIAG_DEVICE_IO      0x00000004

#define IF_DIAG(p)          if (DlcDiagnostics & DIAG_ ## p)
#define DIAG_FUNCTION(s)    IF_DIAG(FUNCTION_NAME) { \
                                DbgPrint(s "\n"); \
                            }

#else

#define IF_DIAG(p)          if (0)
#define DIAG_FUNCTION(s)    if (0) {(void)(s);}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcindc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcindc.c

Abstract:

    This module includes primitives to handle all events
    and indications from the LLC (802.2 data link) module.

    Contents:
        LlcReceiveIndication
        LlcEventIndication
        LlcCommandCompletion
        CompleteTransmitCommand
        CompleteDlcCommand

Author:

    Antti Saarenheimo 01-Sep-1991

Environment:

    Kernel mode

Revision History:

--*/

//
// This define enables the private DLC function prototypes
// We don't want to export our data types to the llc layer.
// MIPS compiler doesn't accept hiding of the internal data
// structures by a PVOID in the function prototype.
// i386 will check the type defines
//

#ifndef i386
#define DLC_PRIVATE_PROTOTYPES
#endif
#include <dlc.h>
#include <smbgtpt.h>

#if 0

//
// if DLC and LLC share the same driver then we can use macros to access fields
// in the BINDING_CONTEXT and ADAPTER_CONTEXT structures
//

#if DLC_AND_LLC
#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif
#include "llcdef.h"
#include "llctyp.h"
#include "llcapi.h"
#endif
#endif

//
// Table includes all llc header length of different frame types
//

static UCHAR aDlcHeaderLengths[LLC_LAST_FRAME_TYPE / 2] = {
    0,  // DLC_UNDEFINED_FRAME_TYPE = 0,
    0,  // DLC_MAC_FRAME = 0x02,
    4,  // DLC_I_FRAME = 0x04,
    3,  // DLC_UI_FRAME = 0x06,
    3,  // DLC_XID_COMMAND_POLL = 0x08,
    3,  // DLC_XID_COMMAND_NOT_POLL = 0x0a,
    3,  // DLC_XID_RESPONSE_FINAL = 0x0c,
    3,  // DLC_XID_RESPONSE_NOT_FINAL = 0x0e,
    3,  // DLC_TEST_RESPONSE_FINAL = 0x10,
    3,  // DLC_TEST_RESPONSE_NOT_FINAL = 0x12,
    0,  // DLC_DIRECT_8022 = 0x14,
    3,  // DLC_TEST_COMMAND = 0x16,
    0   // DLC_DIRECT_ETHERNET_TYPE = 0x18
};


DLC_STATUS
LlcReceiveIndication(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
	IN NDIS_HANDLE MacReceiveContext,
    IN USHORT FrameType,
    IN PUCHAR pLookBuf,
    IN UINT cbPacketSize
    )

/*++

Routine Description:

    The primitive handles the receive data indication from
    the lower level
    the returned parameter block of the read command.

    IBM has successfully made the receive extremly complicated.
    We can distinguish at least four different ways to gather the
    receive information to the frame header, when we have received
    an I- frame for a link station:

    1. Rcv command for link station, frames linked in link basis
        - user length and read options from link object
        - receive buffer base in link object
        - station information from link object

    2. Rcv command for link station, frames linked in sap bases
        - user length and read options from link object
        - receive buffer base in sap object
        - station information from link object

    3. Rcv command only for sap station, frames linked in link basis
        - user length and read options from sap object
        - receive buffer base in link object
        - station information from link object

    4. Rcv command only for sap station, frames linked in sap basis
        - user length and read options from sap object
        - receive buffer base in sap object
        - station information from link object

    =>  We have three different DLC objects in receive:

    1. The orginal destination of the frame, we will read station id
       from that object.
    2. The owner of the receive, the read command must match to the
       station id of the events owner.  The owner also chains the
       the received data in its frame list.
    3. Receive object: the receive object defines the recieve options
       saved to the frame header and the read flag saved to the read
       parameters.

    At least two objects are same (the different ones in different cases),
    and in most cases all objects are the same dlc object.

    We will need to save these in rcv event:
    -  The owner dlc object
    -  Pointer to linked frame header list or to a single frame
       (defined by the receive read option in the next object).
       We can directly use the owner object, because the frames
       need to be chained.  In that case we must save directly the
       reference of the buffer header.
    -  The receive object,  the dlc object having a pending receive,
       that was used to received this event.

Arguments:

    pFileContext    - the device context of this DLC client
    pDlcObject      - the DLC client, that received the event.
    FrameType       - current frame type
    pLookBuf        - points to the data from the LLC header (ie. excludes the
                      LAN header). MAY NOT CONTAIN ALL DATA
    cbPacketSize    - amount of data to copy, including DLC header, but not
                      including LLC header

Return Value:

    DLC_STATUS:

--*/

{
    PDLC_OBJECT pRcvObject = pDlcObject;
    PDLC_OBJECT pOwnerObject;
    PDLC_BUFFER_HEADER pBufferHeader;
    DLC_STATUS Status = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    UINT uiLlcOffset;
    UINT FrameHeaderSize;
    UINT LlcLength;
    PDLC_EVENT pRcvEvent;
    UINT DataSize;
    PFIRST_DLC_SEGMENT pFirstBuffer;
    PDLC_COMMAND pDlcCommand;
    UINT BufferSizeLeft;

    //
    // this function is called in the context of a DPC: it is the receive data
    // indication from NDIS
    //

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('D');

    if (pFileContext->State != DLC_FILE_CONTEXT_OPEN) {
        return DLC_STATUS_ADAPTER_CLOSED;
    }

    ENTER_DLC(pFileContext);

#if LLC_DBG

    if (pDlcObject->State > DLC_OBJECT_CLOSED) {
       DbgPrint("Invalid object type!");
       DbgBreakPoint();
    }

#endif

    //
    // Search the first object having a pending receive, loop
    // the link, the sap and the direct station until we find one.
    //

    while (pRcvObject != NULL && pRcvObject->pRcvParms == NULL) {
        if (pRcvObject->Type == DLC_LINK_OBJECT) {
            pRcvObject = pRcvObject->u.Link.pSap;
        } else if (pRcvObject->Type == DLC_SAP_OBJECT) {
            pRcvObject = pFileContext->SapStationTable[0];
        } else if (pRcvObject->Type == DLC_DIRECT_OBJECT) {
            pRcvObject = NULL;
        }
    }

    //
    // return error status if we cannot find any receive command.
    //

    if (pRcvObject == NULL) {
        Status = DLC_STATUS_NO_RECEIVE_COMMAND;

//#if DBG
//        DbgPrint("DLC.LlcReceiveIndication.%d: Error: No receive command\n", __LINE__);
//#endif

        goto ErrorExit;
    }

    //
    // Now we must figure out the actual owner of the received frame.
    // There are actually only two special cases:
    //

    if (pRcvObject->pRcvParms->Async.Parms.Receive.uchRcvReadOption == LLC_RCV_CHAIN_FRAMES_ON_LINK
    && pRcvObject->Type == DLC_SAP_OBJECT) {
        pOwnerObject = pDlcObject;
    } else if (pRcvObject->pRcvParms->Async.Parms.Receive.uchRcvReadOption == LLC_RCV_CHAIN_FRAMES_ON_SAP
    && pRcvObject->Type == DLC_LINK_OBJECT) {
        pOwnerObject = pRcvObject->u.Link.pSap;
    } else {

        //
        // In all other cases we chain the frames to the receive object
        // (actually IBM has not defined the case), the frames are
        // chained for direct if the rcv read option is set chaining for
        // sap or link station
        //

        pOwnerObject = pRcvObject;

        //
        // direct station can recieve only the frame
        // types defined by station id of the receive command
        // There are three types, we need to check the one, that does not work:
        //
        //      DLC_DIRECT_ALL_FRAMES       0
        //      DLC_DIRECT_MAC_FRAMES       1
        //      DLC_DIRECT_NON_MAC_FRAMES   2
        //

        if (pRcvObject->Type == DLC_DIRECT_OBJECT) {
            if (FrameType == LLC_DIRECT_MAC) {
                if (pRcvObject->pRcvParms->Async.Parms.Receive.usStationId == LLC_DIRECT_8022) {
                    Status = DLC_STATUS_NO_RECEIVE_COMMAND;
                    goto ErrorExit;
                }
            } else {

                //
                // It must be a non-MAC frame
                //

                if (pRcvObject->pRcvParms->Async.Parms.Receive.usStationId == LLC_DIRECT_MAC) {
                    Status = DLC_STATUS_NO_RECEIVE_COMMAND;
                    goto ErrorExit;
                }
            }
        }
    }

    //
    // The frame length must be known when the buffers are allocated,
    // This may not be the same as the actual length of the received
    // LAN header (if we received a DIX frame)
    //

    uiLlcOffset = LlcGetReceivedLanHeaderLength(pFileContext->pBindingContext);

    //
    // Check first the buffer type (contiguous or non contiguous),
    // and then allocate it.
    // Note: WE DO NOT SUPPORT THE BREAK OPTION (because it would make
    // the current buffer management even more complicated)
    //

    LlcLength = aDlcHeaderLengths[FrameType / 2];

    //
    // DIX frames are a special case: they must be filtered
    // (DIX Llc header == ethernet type word is always 2 bytes,
    // nobody else use this llc type size).
    // A DIX application may define an offset, mask and match to
    // filter only those frames it is really needing.
    // This method works very well with XNS and TCP socket types
    //

	if ( LlcLength > cbPacketSize ) {
		Status = DLC_STATUS_INVALID_FRAME_LENGTH;
        goto ErrorExit;
	}

    if ((FrameType == LLC_DIRECT_ETHERNET_TYPE)
    && (pDlcObject->u.Direct.ProtocolTypeMask != 0)) {

        ULONG ProtocolType;

        //
        // there's a real good possibility here that if the app supplies a very
        // large value for the protocol offset, we will blow up - there's no
        // range checking performed!
        //

        ASSERT(pDlcObject->u.Direct.ProtocolTypeOffset >= 14);

        //
        // let's add that range check: if the protocol offset is before the
        // data part of the frame or past the end of this particular frame
        // then we say there's no receive defined for this frame
        //

        if ((pDlcObject->u.Direct.ProtocolTypeOffset < 14)
        || (pDlcObject->u.Direct.ProtocolTypeOffset > cbPacketSize + 10)) {
            return DLC_STATUS_NO_RECEIVE_COMMAND;
        }

        //
        // the offset to the protocol type field is given as offset from the
        // start of the frame: we only get to look in the lookahead buffer,
        // but we know that since this is an ethernet frame, the lookahead
        // buffer starts 14 bytes into the frame, so remove this length from
        // the protocol offset
        //

        ProtocolType = SmbGetUlong(&pLookBuf[pDlcObject->u.Direct.ProtocolTypeOffset - 14]);

        if ((ProtocolType & pDlcObject->u.Direct.ProtocolTypeMask) != pDlcObject->u.Direct.ProtocolTypeMatch) {
            return DLC_STATUS_NO_RECEIVE_COMMAND;
        }
    }

    //
    // The created MDL must not include the LAN header because it is not copied
    // by LlcTransferData. We use a temporary frame header size to allocate space
    // for the LAN header. The LLC header will be copied just as any other data
    //

    if (FrameType == LLC_DIRECT_MAC) {
        if (pRcvObject->pRcvParms->Async.Parms.Receive.uchOptions & DLC_CONTIGUOUS_MAC) {
            FrameHeaderSize = sizeof(DLC_CONTIGUOUS_RECEIVE) + uiLlcOffset;
            DataSize = cbPacketSize;
        } else {
            FrameHeaderSize = sizeof(DLC_NOT_CONTIGUOUS_RECEIVE);
            DataSize = cbPacketSize - LlcLength;
        }
    } else {
        if (pRcvObject->pRcvParms->Async.Parms.Receive.uchOptions & DLC_CONTIGUOUS_DATA) {
            FrameHeaderSize = sizeof(DLC_CONTIGUOUS_RECEIVE) + uiLlcOffset;
            DataSize = cbPacketSize;
        } else {
            FrameHeaderSize = sizeof(DLC_NOT_CONTIGUOUS_RECEIVE);
            DataSize = cbPacketSize - LlcLength;
        }
    }

    pBufferHeader = NULL;
    NtStatus = BufferPoolAllocate(
#if DBG
                pFileContext,
#endif
                pFileContext->hBufferPool,
                DataSize,                       // size of actual MDL buffers
                FrameHeaderSize,                // frame hdr (and possibly lan hdr)
                pRcvObject->pRcvParms->Async.Parms.Receive.usUserLength,
                cbPacketSize + uiLlcOffset,     // size of the packet
                (UINT)(-1),                     // any size is OK.
                &pBufferHeader,                 // returned buffer pointer
                &BufferSizeLeft
                );
    if (NtStatus != STATUS_SUCCESS) {
        if (FrameType != LLC_I_FRAME) {

            //
            // We must complete the receive with the given error status,
            // if this frame is not a I- frame.  (I-frames can be dropped
            // to the floor, the other frames completes the receive with
            // an error status)
            // -----------------------------------------------
            // We should not complete commands in receive lookahead.
            // The correct way could be to queue this somehow in
            // data link and process this, when the command is completed
            // in the command completion indication.
            // On the other hand, NBF DOES THIS FOR EVERY IRP!
            //

            pDlcCommand = SearchAndRemoveCommandByHandle(
                            &pFileContext->ReceiveQueue,
                            (ULONG)-1,
                            (USHORT)DLC_IGNORE_STATION_ID,
                            (USHORT)DLC_STATION_MASK_SPECIFIC,
                            pRcvObject->pRcvParms->Async.Ccb.pCcbAddress
                            );

            //
            // RLF 11/24/92
            //
            // if pDlcCommand is NULL then check the command queue - this may
            // be a receive without a RECEIVE_FLAG parameter
            //

            if (!pDlcCommand) {
                pDlcCommand = SearchAndRemoveCommandByHandle(
                                &pFileContext->CommandQueue,
                                (ULONG)-1,
                                (USHORT)DLC_IGNORE_STATION_ID,
                                (USHORT)DLC_STATION_MASK_SPECIFIC,
                                pRcvObject->pRcvParms->Async.Ccb.pCcbAddress
                                );
                ASSERT(pDlcCommand);
            }

            pRcvObject->pRcvParms = NULL;

#if LLC_DBG

            DbgPrint("cFramesReceived: %x\n", cFramesReceived);
            DbgPrint("cFramesIndicated: %x\n", cFramesIndicated);
            DbgPrint("cFramesReleased: %x\n", cFramesReleased);

            if (pDlcCommand == NULL) {
                DbgPrint("Lost receive command???");
            } else

#endif

            CompleteDlcCommand(pFileContext,
                               pRcvObject->StationId,
                               pDlcCommand,
                               DLC_STATUS_LOST_DATA_NO_BUFFERS
                               );
        }

        //
        // Free the partial buffer
        //

        BufferPoolDeallocateList(pFileContext->hBufferPool, pBufferHeader);

//#if DBG
//        DbgPrint("DLC.LlcReceiveIndication.%d: Error: Out of receive buffers\n", __LINE__);
//#endif

        Status = DLC_STATUS_OUT_OF_RCV_BUFFERS;
        goto ErrorExit;
    }

    //
    // A link station may have committed memory from the buffer pool
    // when it local busy state was enabled after a local busy state
    // because of 'out of receive buffers'.  We must uncommit all
    // packets received by that link station until the size of
    // the commited buffer space is zero
    //

    if (pDlcObject->CommittedBufferSpace != 0) {

        ULONG UncommittedBufferSpace;

        //
        // get the smaller
        //

        UncommittedBufferSpace = (pDlcObject->CommittedBufferSpace < BufGetPacketSize(cbPacketSize)
                               ? pDlcObject->CommittedBufferSpace
                               : BufGetPacketSize(cbPacketSize));

        pDlcObject->CommittedBufferSpace -= UncommittedBufferSpace;
        BufUncommitBuffers(pFileContext->hBufferPool, UncommittedBufferSpace);
    }

    //
    // By default this is linked only to itself.
    // We must create a event information every time,
    // because app might read the old chained frames
    // just between TransferData and its confirmation.
    // => we cannot chain frames before TransmitData is confirmed.
    // We should not either save any pointers to other objects,
    // because they might disappear before the confirm
    // (we use the pending transmit count to prevent OwnerObject
    // to disappear before the confirm)
    //

    pBufferHeader->FrameBuffer.pNextFrame = pBufferHeader;

    pRcvEvent = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pRcvEvent == NULL) {
        Status = DLC_STATUS_NO_MEMORY;
        BufferPoolDeallocateList(pFileContext->hBufferPool, pBufferHeader);

#if DBG
        DbgPrint("DLC.LlcReceiveIndication.%d: Error: Out of memory\n", __LINE__);
#endif

        goto ErrorExit;
    }

    pRcvEvent->Event = LLC_RECEIVE_DATA;
    pRcvEvent->StationId = pOwnerObject->StationId;
    pRcvEvent->pOwnerObject = pOwnerObject;
    pRcvEvent->Overlay.RcvReadOption = pRcvObject->pRcvParms->Async.Parms.Receive.uchRcvReadOption;
    pRcvEvent->SecondaryInfo = pRcvObject->pRcvParms->Async.Parms.Receive.ulReceiveFlag;
    pRcvEvent->pEventInformation = pBufferHeader;
    pOwnerObject->PendingLlcRequests++;

    pFirstBuffer = (PFIRST_DLC_SEGMENT)
        ((PUCHAR)pBufferHeader->FrameBuffer.pParent->Header.pGlobalVa
        + MIN_DLC_BUFFER_SEGMENT * pBufferHeader->FrameBuffer.Index);

    pFirstBuffer->Cont.Options = pRcvObject->pRcvParms->Async.Parms.Receive.uchOptions;
    pFirstBuffer->Cont.MessageType = (UCHAR)FrameType;
    pFirstBuffer->Cont.BuffersLeft = (USHORT)(BufferPoolCount(pFileContext->hBufferPool));
    pFirstBuffer->Cont.RcvFs = 0xCC;
    pFirstBuffer->Cont.AdapterNumber = pFileContext->AdapterNumber;
    pFirstBuffer->Cont.pNextFrame = NULL;
    pFirstBuffer->Cont.StationId = pDlcObject->StationId;

    //
    // A receive command without read flag is used only once.
    // The receive completion will complete also the receive command
    //

    if (pRcvObject->pRcvParms->Async.Parms.Receive.ulReceiveFlag == 0) {
        pRcvObject->pRcvParms = NULL;
    }

    //
    // copy NOT_CONTIGUOUS or CONTIGUOUS frame header to beginning of buffer
    //

    if (FrameHeaderSize == sizeof(DLC_NOT_CONTIGUOUS_RECEIVE)) {
        pFirstBuffer->Cont.UserOffset = sizeof(DLC_NOT_CONTIGUOUS_RECEIVE);
        LlcCopyReceivedLanHeader(pFileContext->pBindingContext,
                                 pFirstBuffer->NotCont.LanHeader,
                                 NULL
                                 );
        pFirstBuffer->NotCont.LanHeaderLength = (UCHAR)uiLlcOffset;
        if (FrameType != LLC_DIRECT_ETHERNET_TYPE) {
            pFirstBuffer->NotCont.DlcHeaderLength = (UCHAR)LlcLength;
            LlcMemCpy((PCHAR)pFirstBuffer->NotCont.DlcHeader,
                      (PCHAR)pLookBuf,
                      LlcLength
                      );
        } else {

            USHORT ethernetType = LlcGetEthernetType(pFileContext->pBindingContext);
            UCHAR byte = ethernetType & 0xff;

            pFirstBuffer->NotCont.DlcHeaderLength = 2;
            ethernetType >>= 8;
            ethernetType |= ((USHORT)byte) << 8;
            *(PUSHORT)&pFirstBuffer->NotCont.DlcHeader = ethernetType;
            LlcLength = 0;
        }
    } else {

        //
        // We have included the LAN header size in the frame header size to
        // make room for this copy, but now we fix the UserOffset and everything
        // should be OK
        //

        LlcLength = 0;
        pFirstBuffer->Cont.UserOffset = sizeof(DLC_CONTIGUOUS_RECEIVE);
        LlcCopyReceivedLanHeader(pFileContext->pBindingContext,
                                 (PCHAR)pFirstBuffer
                                    + sizeof(DLC_CONTIGUOUS_RECEIVE)
                                    + pFirstBuffer->Cont.UserLength,
                                 NULL
                                 );
    }

#if LLC_DBG
    cFramesReceived++;
#endif

    //
    // Save the event only if this is the first chained frame.
    // The sequential received frames will be queued behind it.
    //

    LEAVE_DLC(pFileContext);

    RELEASE_DRIVER_LOCK();

    LlcTransferData(
        pFileContext->pBindingContext,      // data link adapter context
		MacReceiveContext,
        &(pRcvEvent->LlcPacket),            // receive packet
        pBufferHeader->FrameBuffer.pMdl,    // destination mdl
        LlcLength,                          // offset in LookBuf to copy from
        cbPacketSize - LlcLength            // length of copied data
        );

    ACQUIRE_DRIVER_LOCK();

    //
    // Transfer data returns always a pending status,
    // the success/error status is returned asynchronously
    // in the the receive indication completion (really?)
    // We should copy the whole frame here, if is visiable
    // in the receive lookahead buffer.
    //

    return STATUS_SUCCESS;

ErrorExit:

    LEAVE_DLC(pFileContext);

    //
    // The receive status is very important for I- frames,
    // because  the llc driver set the link busy when we return
    // DLC_STATUS_NO_RECEIVE_COMMAND or DLC_STATUS_OUT_OF_RCV_BUFFERS.
    //

    if (Status == DLC_STATUS_NO_MEMORY) {
        Status = DLC_STATUS_OUT_OF_RCV_BUFFERS;
    }

    return Status;
}


VOID
LlcEventIndication(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PVOID hEventObject,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    )

/*++

Routine Description:

    The primitive handles all LLC and NDIS events
    and translates them to DLC events, that are either immediately
    executed by a pending (and matching) read command or
    they are queued to the event queue.
    LLC cannot provide any packet with these events, beacuse they
    were not initiated by the protocol, but they just happened
    asynchronously in the data link driver.

    Special:

    This routine must not call back the data link driver, if has
    gon any other DLC status indication except INDICATE_CONNECT_REQUEST
    (that may be closed by DLC, if there are no available station ids
    on the sap).

Arguments:

    pFileContext            - DLC object handle or a file context of the event
    hEventObject            - DLC object handle or a file context of the event
    Event                   - LLC event code. Usually it can be used directly as
                              a DLC event code
    pEventInformation       - information to DLC status change block
                              (or another pointer to some misc information)
    SecondaryInformation    - dword information used by some NDIS errors

Return Value:

    None.

--*/

{
    PDLC_OBJECT pDlcObject;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('E');

    if (pFileContext->State != DLC_FILE_CONTEXT_OPEN) {
        return;
    }

    ENTER_DLC(pFileContext);

    //
    // DLC status and NDIS adapter status events have different parameters,
    // => we cannot do any common preprocessing for them.
    //

    switch (Event) {
    case LLC_STATUS_CHANGE_ON_SAP:
        Event = LLC_STATUS_CHANGE;

    case LLC_STATUS_CHANGE:
        pDlcObject = (PDLC_OBJECT)hEventObject;

#if LLC_DBG

        if (pDlcObject != NULL && pDlcObject->State > DLC_OBJECT_CLOSED) {
            DbgPrint("Invalid object type!");
            DbgBreakPoint();
        }

#endif

        //
        // We must create a DLC driver object, if a
        // connect request has created a new link station
        // in the data link driver.
        //

        if (SecondaryInfo & INDICATE_CONNECT_REQUEST) {

            //
            // Create the DLC driver object, if remote connection
            // request created a new link station on LLC.
            // The connect request may be done as well for
            // a disconnected station.
            //

            if (pDlcObject->Type == DLC_SAP_OBJECT) {

                NTSTATUS Status;

                Status = InitializeLinkStation(
                            pFileContext,
                            pDlcObject,     // Sap station id
                            NULL,
                            ((PDLC_STATUS_TABLE)pEventInformation)->hLlcLinkStation,
                            &pDlcObject     // NEW Link station id
                            );
                if (Status != STATUS_SUCCESS) {

                    //
                    // This client has all its available link stations
                    // reserved or we are simply run out of memory.
                    // Several LLC clients may share the same SAP.
                    // All remote connections are handled by the
                    // first client registered on the sap
                    // until it runs out of available link stations.
                    // LlcCloseStation for a link indicating connect request
                    // will redirect the connection request to the next
                    // possible LLC client having opened the same sap or
                    // deletes the link station, if there are no clients left
                    //

                    LEAVE_DLC(pFileContext);

                    LlcCloseStation(
                        ((PDLC_STATUS_TABLE)pEventInformation)->hLlcLinkStation,
                        NULL
                        );

                    ENTER_DLC(pFileContext);

                    break;          // We have done it
                }
            }
        }

        //
        // The remotely created link station may send also other indications
        // than Connect, even if there is not yet a link station object
        // created in DLC driver. We must skip all those events.
        //

        if (pDlcObject->Type == DLC_LINK_OBJECT) {

            PDLC_EVENT pDlcEvent = pDlcObject->u.Link.pStatusEvent;

            pDlcEvent->Event = Event;
            pDlcEvent->StationId = pDlcObject->StationId;
            pDlcEvent->pOwnerObject = pDlcObject;
            pDlcEvent->pEventInformation = pEventInformation;
            pDlcEvent->SecondaryInfo |= SecondaryInfo;

            //
            // The next pointer is reset whenever the status event
            // packet is read and disconnected from the event queue.
            //

            if (pDlcEvent->LlcPacket.pNext == NULL) {
                QueueDlcEvent(pFileContext, (PDLC_PACKET)pDlcEvent);
            }
        }
        break;

    case NDIS_STATUS_RING_STATUS:

		ASSERT ( IS_NDIS_RING_STATUS(SecondaryInfo) );

        //
        // The secondary information is directly the
        // the network statys code as defined for
        // ibm token-ring and dlc api!
        //

        Event = LLC_NETWORK_STATUS;

        //
        // This event should go to all READ having defined the
        // the network status flag!
        //

        MakeDlcEvent(pFileContext,
                     Event,
                     (USHORT)(-1),
                     NULL,
                     pEventInformation,
                     NDIS_RING_STATUS_TO_DLC_RING_STATUS(SecondaryInfo),
                     FALSE
                     );
        break;

    case NDIS_STATUS_CLOSED:

        //
        // NDIS status closed is given only when the network
        // administrator is for some reason unloading NDIS.
        // Thus we must always return the 'System Action' error
        // code ('04') with LLC_CRITICAL_ERROR, but
        // we will add it later when all stations has been closed.
        //

        if (pFileContext->State != DLC_FILE_CONTEXT_CLOSED) {
            pFileContext->State = DLC_FILE_CONTEXT_CLOSED;
            CloseAllStations(
                pFileContext,
                NULL,                  // we don't have any command to complete
                LLC_CRITICAL_EXCEPTION,
                NULL,
                NULL,
                &pFileContext->ClosingPacket
                );
        }
        break;

    case LLC_TIMER_TICK_EVENT:

        //
        // This flag is used to limit the number of the failing expand
        // operations for the buffer pool.  We don't try to do it again
        // for a while, if we cannot lock memory.
        //

        MemoryLockFailed = FALSE;

        //
        // We free the extra locked pages in the buffer pool once
        // in five seconds. The unlocking takes some time, and we
        // don't want to do it whenever a read command is executed
        // (as we do with the expanding)
        //

        pFileContext->TimerTickCounter++;
        if ((pFileContext->TimerTickCounter % 10) == 0 && pFileContext->hBufferPool != NULL) {
            BufferPoolFreeExtraPages(
#if DBG
                                     pFileContext,
#endif
                                     (PDLC_BUFFER_POOL)pFileContext->hBufferPool
                                     );
        }

        //
        // Decrement the tick count of the first object in the timer queue
        // (if there is any) and complete its all sequential commands
        // having zero tickout.
        //

        if (pFileContext->pTimerQueue != NULL) {
            pFileContext->pTimerQueue->Overlay.TimerTicks--;

            while (pFileContext->pTimerQueue != NULL
            && pFileContext->pTimerQueue->Overlay.TimerTicks == 0) {

                PDLC_COMMAND pCommand;

                pCommand = pFileContext->pTimerQueue;
                pFileContext->pTimerQueue = (PDLC_COMMAND)pCommand->LlcPacket.pNext;

#if LLC_DBG

                pCommand->LlcPacket.pNext = NULL;

#endif

                CompleteDlcCommand(pFileContext, 0, pCommand, STATUS_SUCCESS);
            }
        }
        break;

#if LLC_DBG

    default:
        LlcInvalidObjectType();
        break;

#endif

    }

    LEAVE_DLC(pFileContext);
}


VOID
LlcCommandCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PDLC_PACKET pPacket
    )

/*++

Routine Description:

    The routine completes the asynchronous DLC operations: Transmit,
    TransferData (for receive), LlcConnect and LlcDisconnect.

Arguments:

    pFileContext    - DLC process and adapter specific file context
    pDlcObject      - the object, that was assosiated with the command
    pPacket         - packet assosiated with the command

Return Value:

    None

--*/

{
    PDLC_PACKET pRootNode;
    UINT Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('B');

    Status = (UINT)pPacket->LlcPacket.Data.Completion.Status;

    ENTER_DLC(pFileContext);

#if LLC_DBG

    if (pDlcObject != NULL && pDlcObject->State > DLC_OBJECT_CLOSED) {
        DbgPrint("Invalid object type!");
        DbgBreakPoint();
    }

#endif

    switch (pPacket->LlcPacket.Data.Completion.CompletedCommand) {
    case LLC_RECEIVE_COMPLETION:

        //
        // The receiving object may be different from the
        // actual object given by data link.
        // (this case should be moved to a subprocedure, that would
        // be called directly from the receive data handler, if
        // TransferData is executed synchronously (it always does it).
        // That would save at least 100 instructions.)
        //

        DLC_TRACE('h');

        pDlcObject = pPacket->Event.pOwnerObject;
        pDlcObject->PendingLlcRequests--;

        if (Status != STATUS_SUCCESS || pDlcObject->State != DLC_OBJECT_OPEN) {

            //
            // We must free the receive buffers, the packet
            // will be deallocated in the end of this procedure.
            //

            BufferPoolDeallocateList(pFileContext->hBufferPool,
                                     pPacket->Event.pEventInformation
                                     );

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

        } else {
            if (pPacket->Event.Overlay.RcvReadOption != LLC_RCV_READ_INDIVIDUAL_FRAMES) {

                //
                // The received frames must be chained,
                // add the new buffer header to the old
                // link list if there is any,  The buffers
                // are saved to a circular link list to make
                // possible to build easily the final link list in
                // application address space.
                //

                if (pDlcObject->pReceiveEvent != NULL) {

                    //
                    // new: pPacket->Event.pEventInformation
                    // base: pDlcObject->pReceiveEvent->pEventInformation
                    // Operations when a new element is added to base:
                    //

                    //
                    // 1. new->next = base->next
                    //

                    ((PDLC_BUFFER_HEADER)pPacket->Event.pEventInformation)->FrameBuffer.pNextFrame
                        = ((PDLC_BUFFER_HEADER)pDlcObject->pReceiveEvent->pEventInformation)->FrameBuffer.pNextFrame;

                    //
                    // 2. base->next = new
                    //

                    ((PDLC_BUFFER_HEADER)pDlcObject->pReceiveEvent->pEventInformation)->FrameBuffer.pNextFrame
                        = (PDLC_BUFFER_HEADER)pPacket->Event.pEventInformation;

                    //
                    // 3. base = new
                    //

                    pDlcObject->pReceiveEvent->pEventInformation = pPacket->Event.pEventInformation;

                    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

                    //
                    // This event is already queued =>
                    // we may leave this procedure
                    //

                    break;          // **********  EXIT ************
                } else {
                    pDlcObject->pReceiveEvent = &pPacket->Event;
                }
            }

            //
            // All receives are events.  The event is handled immediately
            // if there is a pending command in the command queue,
            // otherwise the command is queued to the event queue to be
            // read by a command issued later.
            //

            pPacket->Event.Overlay.StationIdMask = (USHORT)(-1);
            QueueDlcEvent(pFileContext, pPacket);
        }
        break;

    case LLC_SEND_COMPLETION:

        //
        // We first free or/and unlock all buffers, that
        // were used in the transmit of this frame.
        //

        DLC_TRACE('i');

        BufferPoolFreeXmitBuffers(pFileContext->hBufferPool, pPacket);

        //
        // Reset the local busy states, if there is now enough
        // buffers the receive the expected stuff for a link station.
        //

        if (!IsListEmpty(&pFileContext->FlowControlQueue)
        && pFileContext->hBufferPool != NULL
        && BufGetUncommittedSpace(pFileContext->hBufferPool) >= 0) {
            ResetLocalBusyBufferStates(pFileContext);
        }

        //
        // This code completes a transmit command.
        // It releases all resources allocated for the transmit
        // and completes the command, if this was the last
        // transmit associated with it.
        // Note:
        // Single transmit command may consists of several frames.
        // We must wait until all NDIS send requests have been completed
        // before we can complete the command. That's why the first transmit
        // node is also a root node.  All transmit nodes have a reference
        // to the root node.
        // (why we incrment/decrement the object reference count separately
        // for each frame,  we could do it only once for a transmit command).
        //

        pDlcObject->PendingLlcRequests--;
        pRootNode = pPacket->Node.pTransmitNode;

        //
        // Don't delete root node packet, we will need it to queue the
        // command completion (if the command completion flag is used)
        //

        if (pPacket != pRootNode) {

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

        }

        //
        // We will save and keep the first asynchronous error status
        //

        if (Status != STATUS_SUCCESS && pRootNode->Node.pIrp->IoStatus.Status == STATUS_SUCCESS) {
            pRootNode->Node.pIrp->IoStatus.Status = Status;
        }

        pRootNode->Node.FrameCount--;
        if (pRootNode->Node.FrameCount == 0) {
            CompleteTransmitCommand(pFileContext,
                                    pRootNode->Node.pIrp,
                                    pDlcObject,
                                    pRootNode
                                    );
        }
        break;

    case LLC_RESET_COMPLETION:
        pPacket->ResetPacket.pClosingInfo->CloseCounter--;
        if (pPacket->ResetPacket.pClosingInfo->CloseCounter == 0) {
            CompleteCloseReset(pFileContext, pPacket->ResetPacket.pClosingInfo);
        }

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

        break;

    case LLC_CONNECT_COMPLETION:

        DLC_TRACE('e');

        CompleteDlcCommand(pFileContext,
                           pDlcObject->StationId,
                           &pPacket->DlcCommand,
                           Status
                           );
        pDlcObject->PendingLlcRequests--;
        break;

    case LLC_DISCONNECT_COMPLETION:

        //
        // The disconnect is in dlc driver always connected to
        // the closing of the link station.  We just continue
        // the asynchronous command.  Still this process (waiting
        // the other side to ack to disconnect packet DISC)
        // may be interrupted by an immediate close command
        // (DLC.RESET or DIR.CLOSE.ADAPTER).
        //

        DLC_TRACE('g');

        if (pDlcObject->LlcObjectExists == TRUE) {
            pDlcObject->LlcObjectExists = FALSE;

            LEAVE_DLC(pFileContext);

            LlcCloseStation(pDlcObject->hLlcObject, (PLLC_PACKET)pPacket);

            ENTER_DLC(pFileContext);

            DereferenceLlcObject(pDlcObject);

            //
            // We don't want to complete a dlc object twice.
            //

            LEAVE_DLC(pFileContext);

            return;
        }

    case LLC_CLOSE_COMPLETION:

        //
        // Just free the command packet and update the reference counter.
        // The end of this procedure takes care of the rest.
        //

        DLC_TRACE('f');

        pDlcObject->PendingLlcRequests--;

        if (&pDlcObject->ClosePacket != (PLLC_PACKET) pPacket) {
            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);
        } else {
            pDlcObject->ClosePacketInUse = 0;
        }

        break;

#if LLC_DBG

    default:
        LlcInvalidObjectType();
        break;

#endif

    };

#if LLC_DBG

    if (pDlcObject != NULL && pDlcObject->PendingLlcRequests < 0) {
        DbgPrint("Error: PendingLlcRequests < 0!!!\n");
        DbgBreakPoint();
    }

#endif

    //
    // we can try to complete the close/reset only when there are no
    // pending commands issued to LLC (and NDIS).
    // The procedure will check, if there is still pending commands.
    //

    if (pDlcObject != NULL && pDlcObject->State != DLC_OBJECT_OPEN) {
        CompleteCloseStation(pFileContext, pDlcObject);
    }

    LEAVE_DLC(pFileContext);
}


VOID
CompleteTransmitCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PIRP pIrp,
    IN PDLC_OBJECT pChainObject,
    IN PDLC_PACKET pPacket
    )

/*++

Routine Description:

    The routine completes the DLC transmit command and optionally
    chains its CCB(s) to the completion list.
    The transmit read option defines, if the transmit commands
    are chained or if each command is completed with a separate
    READ- command.

Arguments:

    pFileContext    - DLC process and adapter specific file context
    pIrp            - Io- request packet of the completed command
    pChainObject    - the DLC object the packet(s) was transmitted from
    pPacket         - the orginal packet of the transmit command

Return Value:

    None

--*/

{
    PVOID pUserCcbPointer = NULL;
    PNT_DLC_PARMS pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

    //
    // MODMOD RLF 01/19/93
    //

    BOOLEAN queuePacket = FALSE;
    PVOID pCcb;
    ULONG eventFlags;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // MODMOD ends
    //

    pDlcParms->Async.Parms.Transmit.FrameStatus = 0xCC;

    //
    // Check if the transmit commands should be linked to the completion list
    //

    if (pDlcParms->Async.Ccb.CommandCompletionFlag != 0) {

        //
        // Are they linked together in the same completion event?
        //

        if (pDlcParms->Async.Parms.Transmit.XmitReadOption != LLC_COMPLETE_SINGLE_XMIT_FRAME) {
            if (pDlcParms->Async.Parms.Transmit.XmitReadOption == LLC_CHAIN_XMIT_COMMANDS_ON_SAP
            && pChainObject->Type == DLC_LINK_OBJECT) {
                pChainObject = pChainObject->u.Link.pSap;
            }
            pChainObject->ChainedTransmitCount++;
            pUserCcbPointer = pChainObject->pPrevXmitCcbAddress;
            pChainObject->pPrevXmitCcbAddress = pDlcParms->Async.Ccb.pCcbAddress;

            //
            // Make new event only for the first transmit completion
            //

            if (pChainObject->ChainedTransmitCount == 1) {
                pChainObject->pFirstChainedCcbAddress = pDlcParms->Async.Ccb.pCcbAddress;
                pPacket->Event.pOwnerObject = pChainObject;
            } else {

                //
                // There is already a pending event for the
                // this transmit command, we may free this one.
                // The space & speed optimal code execution requires
                // a shameful jump.
                //

                DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

                //
                // MODMOD RLF 01/21/93
                //

                pCcb = pDlcParms->Async.Ccb.pCcbAddress;

                //
                // MODMOD ends
                //

                //
                // ***** G-O-T-O ********
                //

                goto ThisIsA_SHAME;
            }
        } else {
            pPacket->Event.pOwnerObject = NULL;
        }

        //
        // MODMOD RLF 01/19/93
        //

        ////
        //// We translate the orginal transit packet to a new event packet
        ////
        //
        //pPacket->Event.Event = LLC_TRANSMIT_COMPLETION;
        //pPacket->Event.StationId = (USHORT)pChainObject->StationId;
        //pPacket->Event.pEventInformation = pDlcParms->Async.Ccb.pCcbAddress;
        //pPacket->Event.SecondaryInfo = pDlcParms->Async.Ccb.CommandCompletionFlag;
        //QueueDlcEvent(pFileContext, pPacket);

        queuePacket = TRUE;
        pCcb = pDlcParms->Async.Ccb.pCcbAddress;
        eventFlags = pDlcParms->Async.Ccb.CommandCompletionFlag;

        //
        // MODMOD ends
        //

    } else {

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

    }

ThisIsA_SHAME:

    //
    // Set the default value to the returned frame status
    //

    if (pIrp->IoStatus.Status != STATUS_SUCCESS) {

        //
        // Set the FS (frame status) error code, NDIS has
        // returned an FS-related error code.
        // Note: This error status is never returned in the
        // case of I- frames (or should it be?).
        //

        if (pIrp->IoStatus.Status == NDIS_STATUS_NOT_RECOGNIZED) {
            pDlcParms->Async.Parms.Transmit.FrameStatus = 0;
            pDlcParms->Async.Ccb.uchDlcStatus = LLC_STATUS_TRANSMIT_ERROR_FS;
        } else if (pIrp->IoStatus.Status == NDIS_STATUS_NOT_COPIED) {
            pDlcParms->Async.Parms.Transmit.FrameStatus = 0x44;
            pDlcParms->Async.Ccb.uchDlcStatus = LLC_STATUS_TRANSMIT_ERROR_FS;
        } else if (pIrp->IoStatus.Status == NDIS_STATUS_INVALID_PACKET) {
            pDlcParms->Async.Parms.Transmit.FrameStatus = 0;
            pDlcParms->Async.Ccb.uchDlcStatus = LLC_STATUS_INVALID_FRAME_LENGTH;
        } else {

            //
            // Don't overwrite the existing DLC error codes!
            //

            if (pIrp->IoStatus.Status < DLC_STATUS_ERROR_BASE
            || pIrp->IoStatus.Status > DLC_STATUS_MAX_ERROR) {
                pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)LLC_STATUS_TRANSMIT_ERROR;
            } else {
                pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)(pIrp->IoStatus.Status - DLC_STATUS_ERROR_BASE);
            }
        }
        pIrp->IoStatus.Status = STATUS_SUCCESS;
    } else {
        pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)STATUS_SUCCESS;
    }

    pDlcParms->Async.Ccb.pCcbAddress = pUserCcbPointer;

    //
    // Copy the optional second output buffer to user memory.
    //

    if (IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_DLC_TRANSMIT) {

        //
        // MODMOD RLF 01/21/93
        //
        // Transmit now uses METHOD_OUT_DIRECT which means we update the CCB
        // with the pNext and uchDlcStatus fields
        //

        PLLC_CCB pInputCcb;
        PUCHAR pFrameStatus;

        pInputCcb = (PLLC_CCB)MmGetSystemAddressForMdl(pIrp->MdlAddress);

        //
        // the pointer may be an unaligned VDM pointer!
        //

        RtlStoreUlongPtr((PULONG_PTR)(&pInputCcb->pNext),
                         (ULONG_PTR)pUserCcbPointer);
        pInputCcb->uchDlcStatus = pDlcParms->Async.Ccb.uchDlcStatus;

        //
        // MODMOD ends
        //

        //
        // performance (slight) improvement. The following copies A SINGLE BYTE
        // (the frame status field). Replace call to copy routine with single
        // byte move
        //

        //LlcMemCpy(MmGetSystemAddressForMdl((PMDL)pDlcParms->Async.Ccb.u.pMdl),
        //          &pDlcParms->Async.Parms.Transmit.FrameStatus,
        //          aSpecialOutputBuffers[IOCTL_DLC_TRANSMIT_INDEX]
        //          );

        pFrameStatus = (PUCHAR)MmGetSystemAddressForMdl((PMDL)pDlcParms->Async.Ccb.u.pMdl);
        *pFrameStatus = pDlcParms->Async.Parms.Transmit.FrameStatus;

        UnlockAndFreeMdl(pDlcParms->Async.Ccb.u.pMdl);
    }

    //
    // we are about to complete this IRP - remove the cancel routine
    //

//    RELEASE_DRIVER_LOCK();

    SetIrpCancelRoutine(pIrp, FALSE);
    IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);

//    ACQUIRE_DRIVER_LOCK();

    //
    // MODMOD RLF 01/19/93
    //
    // Moved queueing of the event until after the IoCompleteRequest because it
    // was possible for the following to occur:
    //
    //  Thread A:
    //
    //  1.  app allocates transmit CCB & submits it. Transmit completion is to
    //      be picked up on a READ CCB
    //  2.  transmit completes
    //  3.  DLC queues event for transmit completion
    //
    //  Thread B:
    //
    //  4.  app submits READ CCB
    //  5.  READ finds completed transmit event on DLC event queue & removes it
    //  6.  READ IRP is completed (IoCompleteRequest)
    //  7.  app checks READ CCB and deallocates transmit CCB
    //  8.  app reallocates memory previously used for transmit CCB
    //
    //  Thread A:
    //
    //  9.  transmit IRP is completed (IoCompleteRequest)
    //
    // At this point, the IoCompleteRequest for the transmit copies some
    // completion info over the area which used to be the original transmit CCB
    // but has since been reallocated, causing lachrymae maximus
    //
    // This is safe because in this case we know we have a transmit which is
    // destined to be picked up by a READ (its ulCompletionFlag parameter is
    // non-zero), so it doesn't do any harm if we complete the IRP before
    // queueing the event for a READ
    //

    if (queuePacket) {
        pPacket->Event.Event = LLC_TRANSMIT_COMPLETION;
        pPacket->Event.StationId = (USHORT)pChainObject->StationId;
        pPacket->Event.pEventInformation = pCcb;
        pPacket->Event.SecondaryInfo = eventFlags;
        QueueDlcEvent(pFileContext, pPacket);
    }

    //
    // MODMOD ends
    //

    DereferenceFileContext(pFileContext);
}


VOID
CompleteDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    IN PDLC_COMMAND pDlcCommand,
    IN UINT Status
    )

/*++

Routine Description:

    The routine completes the DLC command and optionally
    saves its CCB(s) to the completion list, if the command
    has a command completion flag.

Arguments:

    pFileContext    - DLC process and adapter specific file context
    StationId       - the station id of the completed command (0 for non station
                      based commands)
    pDlcCommand     - the caller must provide either command completion packet
                      or IRP
    Status          - command completion status

Return Value:

    None

--*/

{
    PVOID pCcbAddress;
    ULONG CommandCompletionFlag;
    PIRP pIrp;

    pIrp = pDlcCommand->pIrp;

    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pDlcCommand);

    pCcbAddress = ((PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer)->Async.Ccb.pCcbAddress;
    CommandCompletionFlag = ((PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer)->Async.Ccb.CommandCompletionFlag;
    CompleteAsyncCommand(pFileContext, Status, pIrp, NULL, FALSE);

    //
    // Queue command completion event, if the command completion flag was set
    //

    if (CommandCompletionFlag != 0) {
        MakeDlcEvent(pFileContext,
                     DLC_COMMAND_COMPLETION,
                     StationId,
                     NULL,
                     pCcbAddress,
                     CommandCompletionFlag,
                     FALSE
                     );
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcdef.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcdef.h

Abstract:

    This module includes all defines and constants of DLC API driver.

Author:

    Antti Saarenheimo 22-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <ntddk.h>  // required for PAGE_SIZE

//
// minima, maxima and defaults for registry parameters
//

#define MIN_TIMER_TICK_VALUE            1
#define MAX_TIMER_TICK_VALUE            255
#define MIN_AUTO_FRAMING_CACHE_SIZE     0   // means NO CACHING!
#define MAX_AUTO_FRAMING_CACHE_SIZE     256 // arbitrary maximum

//
// if non-TR cards && using max ethernet frame length then 1514 is the value
// we use (came from ELNKII, EE16, LANCE, et al)
//

#define MAX_ETHERNET_FRAME_LENGTH       1514

//
// default values for parameters retrieved from registry
//

#define DEFAULT_SWAP_ADDRESS_BITS       1
#define DEFAULT_DIX_FORMAT              0
#define DEFAULT_T1_TICK_ONE             5
#define DEFAULT_T1_TICK_TWO             25
#define DEFAULT_T2_TICK_ONE             1
#define DEFAULT_T2_TICK_TWO             10
#define DEFAULT_Ti_TICK_ONE             25
#define DEFAULT_Ti_TICK_TWO             125
#define DEFAULT_USE_ETHERNET_FRAME_SIZE 1
#define DEFAULT_AUTO_FRAMING_CACHE_SIZE 16

//
// The event and command queue structures overlaps => we cane save the
// duplicate code.  The defined name makes code more readable.
//

#define SearchAndRemoveEvent( a, b, c, d ) \
        (PDLC_EVENT)SearchAndRemoveCommand( a, b, c, d )

#define MAX_SAP_STATIONS                128
#define MAX_LINK_STATIONS               255
#define GROUP_SAP_BIT                   0x0100
#define DLC_INDIVIDUAL_SAP              0x04
#define XID_HANDLING_BIT                0x08

#define MIN_DLC_BUFFER_SIZE             PAGE_SIZE

#define MAX_FREE_SIZE_THRESHOLD         0x2000

#define INVALID_RCV_READ_OPTION         3
#define DLC_INVALID_OPTION_INDICATOR    3
#define DLC_NO_RECEIVE_COMMAND          4

#define DLC_CONTIGUOUS_MAC              0x80
#define DLC_CONTIGUOUS_DATA             0x40
#define DLC_BREAK                       0x20

#if defined(ALPHA)
#define DLC_BUFFER_SEGMENTS             6     // 256, 512, 1024, 2048, 4096, 8192 => 6
#else
#define DLC_BUFFER_SEGMENTS             5     // 256, 512, 1024, 2048, 4096 => 5
#endif

#define MAX_USER_DATA_LENGTH            128   // anything less than 256

//
// Transmit timeout = 20 * 250 ms = 5 seconds
//

#define MAX_TRANSMIT_RETRY              20
#define TRANSMIT_RETRY_WAIT             2500000L

#define LLC_RECEIVE_COMMAND_FLAG        0x80

#define DLC_IGNORE_SEARCH_HANDLE        NULL
#define DLC_MATCH_ANY_COMMAND           (PVOID)-1
#define DLC_IGNORE_STATION_ID           0x00ff
#define DLC_STATION_MASK_SPECIFIC       0xffff
#define DLC_STATION_MASK_SAP            0xff00
#define DLC_STATION_MASK_ALL            0


#define IOCTL_DLC_READ_INDEX            ((IOCTL_DLC_READ >> 2) & 0x0fff)
#define IOCTL_DLC_RECEIVE_INDEX         ((IOCTL_DLC_RECEIVE >> 2) & 0x0fff)
#define IOCTL_DLC_TRANSMIT_INDEX        ((IOCTL_DLC_TRANSMIT >> 2) & 0x0fff)
#define IOCTL_DLC_OPEN_ADAPTER_INDEX    ((IOCTL_DLC_OPEN_ADAPTER >> 2) & 0x0fff)

enum _DLC_OBJECT_STATES {
    DLC_OBJECT_OPEN,
    DLC_OBJECT_CLOSING,
    DLC_OBJECT_CLOSED,
    DLC_OBJECT_INVALID_TYPE
};

//
// The Token-Ring status codes documented in Appendix B of the IBM LAN
// Tech Reference are shifted right one bit from the NDIS values 
// documented in "ntddndis.h."
//
// In versions 3.xx of Windows NT, DLC returns a Network Status that
// agrees with the NDIS values.  In version 4.xx and newer, IBM
// compatible values are used.
//
// These macros may be used to convert between the two conventions.
//

#define NDIS_RING_STATUS_TO_DLC_RING_STATUS(status) ((status)>>1)
#define DLC_RING_STATUS_TO_NDIS_RING_STATUS(status) ((status)<<1)


#define NDIS_RING_STATUS_MASK \
	NDIS_RING_SIGNAL_LOSS\
	|NDIS_RING_HARD_ERROR\
	|NDIS_RING_SOFT_ERROR\
	|NDIS_RING_TRANSMIT_BEACON\
	|NDIS_RING_LOBE_WIRE_FAULT\
	|NDIS_RING_AUTO_REMOVAL_ERROR\
	|NDIS_RING_REMOVE_RECEIVED\
	|NDIS_RING_COUNTER_OVERFLOW\
	|NDIS_RING_SINGLE_STATION\
	|NDIS_RING_RING_RECOVERY

#define DLC_RING_STATUS_MASK NDIS_RING_STATUS_TO_DLC_RING_STATUS(NDIS_RING_STATUS_MASK)

#define IS_NDIS_RING_STATUS(status) (((status)&NDIS_RING_STATUS_MASK)!=0)
#define IS_DLC_RING_STATUS(status) (((status)&DLC_RING_STATUS_MASK)!=0)

//
// ENTER/LEAVE_DLC - acquires or releases the per-file context spin lock. Use
// Ndis spin locking calls
//

#define ENTER_DLC(p)    ACQUIRE_SPIN_LOCK(&p->SpinLock)
#define LEAVE_DLC(p)    RELEASE_SPIN_LOCK(&p->SpinLock)

//
// ACQUIRE/RELEASE_DLC_LOCK - acquires or releases global DLC spin lock. Use
// kernel spin locking calls
//

#define ACQUIRE_DLC_LOCK(i) KeAcquireSpinLock(&DlcSpinLock, &(i))
#define RELEASE_DLC_LOCK(i) KeReleaseSpinLock(&DlcSpinLock, (i))

#define ADAPTER_ERROR_COUNTERS          11  // # adapter error log counters

#define ReferenceFileContextByTwo(pFileContext) (pFileContext)->ReferenceCount += 2
#define ReferenceFileContext(pFileContext)      (pFileContext)->ReferenceCount++

#if DBG

#define DereferenceFileContext(pFileContext)                \
    if (pFileContext->ReferenceCount <= 0) {                \
        DbgPrint("DLC.DereferenceFileContext: Error: file context %08x: reference count %x\n",\
                pFileContext,                               \
                pFileContext->ReferenceCount                \
                );                                          \
        DbgBreakPoint();                                    \
    }                                                       \
    (pFileContext)->ReferenceCount--;                       \
    if ((pFileContext)->ReferenceCount <= 0) {              \
        DlcKillFileContext(pFileContext);                   \
    }

#define DereferenceFileContextByTwo(pFileContext)           \
    if (pFileContext->ReferenceCount <= 1) {                \
        DbgPrint("DLC.DereferenceFileContextByTwo: Error: file context %08x: reference count %x\n",\
                pFileContext,                               \
                pFileContext->ReferenceCount                \
                );                                          \
        DbgBreakPoint();                                    \
    }                                                       \
    (pFileContext)->ReferenceCount -= 2;                    \
    if ((pFileContext)->ReferenceCount <= 0) {              \
        DlcKillFileContext(pFileContext);                   \
    }

#else

#define DereferenceFileContext(pFileContext)                \
    (pFileContext)->ReferenceCount--;                       \
    if ((pFileContext)->ReferenceCount <= 0) {              \
        DlcKillFileContext(pFileContext);                   \
    }

#define DereferenceFileContextByTwo(pFileContext)           \
    (pFileContext)->ReferenceCount -= 2;                    \
    if ((pFileContext)->ReferenceCount <= 0) {              \
        DlcKillFileContext(pFileContext);                   \
    }

#endif  // DBG

#define BufferPoolCount(hBufferPool) \
    (((PDLC_BUFFER_POOL)hBufferPool)->FreeSpace >= (256L * 0x0000ffffL) ? \
        0xffff : \
        (((PDLC_BUFFER_POOL)hBufferPool)->FreeSpace / 256))

#define BufGetUncommittedSpace(handle) \
    ((PDLC_BUFFER_POOL)(handle))->UncommittedSpace

#define BufCommitBuffers(handle, BufferSize) \
    ExInterlockedAddUlong( \
        (PULONG)&((PDLC_BUFFER_POOL)(handle))->UncommittedSpace, \
        (ULONG)(-((LONG)BufferSize)), \
        &(((PDLC_BUFFER_POOL)(handle))->SpinLock))

#define BufUncommitBuffers(handle, BufferSize) \
    ExInterlockedAddUlong(\
        (PULONG)&((PDLC_BUFFER_POOL)(handle))->UncommittedSpace,\
        (ULONG)(BufferSize),\
        &(((PDLC_BUFFER_POOL)(handle))->SpinLock))

/*++

BOOLEAN
BufferPoolCheckThresholds(
    IN PDLC_BUFFER_POOL pBufferPool
    )

Routine Description:

    The function checks the minimum and maximum size Thresholds and
    returns TRUE, if buffer pool needs reallocation.

    We do this check outside the spinlocks to avoid
    unnecessary locking in 99 % of the cases.

Arguments:

    pBufferPool - handle of buffer pool data structure.

Return Value:

    Returns     TRUE => Buffer pool needs extending
                FALSE => no need for it
--*/
#define BufferPoolCheckThresholds( pBufferPool ) \
    (((pBufferPool) != NULL && \
      (((PDLC_BUFFER_POOL)(pBufferPool))->UncommittedSpace < 0 || \
       ((PDLC_BUFFER_POOL)(pBufferPool))->MissingSize > 0) && \
      ((PDLC_BUFFER_POOL)(pBufferPool))->BufferPoolSize < \
      ((PDLC_BUFFER_POOL)(pBufferPool))->MaxBufferSize && \
     MemoryLockFailed == FALSE) ? TRUE : FALSE)


//
//  These routines closes a llc object, when there are no
//  more references to it
//
#define ReferenceLlcObject( pDlcObject ) (pDlcObject)->LlcReferenceCount++

#define DereferenceLlcObject( pDlcObject ) { \
        (pDlcObject)->LlcReferenceCount--; \
        if ((pDlcObject)->LlcReferenceCount == 0) {\
            CompleteLlcObjectClose( pDlcObject ); \
        } \
        DLC_TRACE('O'); \
        DLC_TRACE( (UCHAR)(pDlcObject)->LlcReferenceCount ); \
    }


//
// We need the same kind of routines to reference the buffer pool.
// The adapter closing have quite many times deleted the buffer pool
// just before it was called (after LEAVE_DLC).
//

#define ReferenceBufferPool(pFileContext)   (pFileContext)->BufferPoolReferenceCount++

#if DBG

#define DereferenceBufferPool(pFileContext) {\
        (pFileContext)->BufferPoolReferenceCount--; \
        if ((pFileContext)->BufferPoolReferenceCount == 0) {\
            BufferPoolDereference( \
                pFileContext, \
                (PDLC_BUFFER_POOL*)&(pFileContext)->hBufferPool); \
        } \
    }

#else

#define DereferenceBufferPool(pFileContext) {\
        (pFileContext)->BufferPoolReferenceCount--; \
        if ((pFileContext)->BufferPoolReferenceCount == 0) {\
            BufferPoolDereference((PDLC_BUFFER_POOL*)&(pFileContext)->hBufferPool); \
        } \
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcinfo.c

Abstract:

    The module implements the Query/Set information commands.
    It also provides the statistics services for DLC api.

    Contents:
        GetDlcErrorCounters
        DlcQueryInformation
        DlcSetInformation
        GetOpenSapAndStationCount
        SetupGroupSaps

Author:

    Antti Saarenheimo (o-anttis) 29-AUG-1991

Revision History:

--*/

#include <dlc.h>

static ULONG aTokenringLogOid[ADAPTER_ERROR_COUNTERS] = {
    OID_802_5_LINE_ERRORS,
    0,
    OID_802_5_BURST_ERRORS,
    OID_802_5_AC_ERRORS,
    OID_802_5_ABORT_DELIMETERS,
    0,
    OID_802_5_LOST_FRAMES,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_5_FRAME_COPIED_ERRORS,
    OID_802_5_FREQUENCY_ERRORS,
    OID_802_5_TOKEN_ERRORS
};

static ULONG aEthernetLogOid[ADAPTER_ERROR_COUNTERS] = {
    OID_802_3_XMIT_TIMES_CRS_LOST,
    0,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    0,
    OID_GEN_XMIT_ERROR,
    0,
    OID_802_3_XMIT_MAX_COLLISIONS,
    OID_GEN_RCV_NO_BUFFER,
    0,
    0,
    0
};

static ULONG aFddiLogOid[ADAPTER_ERROR_COUNTERS] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};


VOID
GetDlcErrorCounters(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PUCHAR pAdapterErrors
    )

/*++

Routine Description:

    Procedure reads the cumulative 32-bit adapter error counters from
    ethernet or token-ring adapter and returns 8-bit DLC error counters,
    that supports read and read & reset commands.  It also maintains
    local copies of the NDIS error counters in the process specific
    adapter context, because NDIS counters cannot be reset.

Arguments:

    pFileContext    - DLC address object
    pAdapterErrors  - DLC errors counters, if NULL => NDIS values are
                      copied to file context.

Return Value:

    None.

--*/

{
    LLC_NDIS_REQUEST Request;
    PULONG pOidBuffer;
    ULONG counter;
    UINT i;
    UINT Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Token-ring and ethernet uses different error counters
    //

    switch (pFileContext->ActualNdisMedium) {
    case NdisMedium802_3:
        pOidBuffer = aEthernetLogOid;
        break;

    case NdisMedium802_5:
        pOidBuffer = aTokenringLogOid;
        break;

    case NdisMediumFddi:
        pOidBuffer = aFddiLogOid;
        break;
    }

    //
    // read all error counters having non null NDIS OID and
    // decrement the previous error count value from it.
    // Overflowed DLC error counter is set 255 (the maximum).
    //

    Request.Ndis.RequestType = NdisRequestQueryInformation;
    Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer = &counter;
    Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(counter);

    for (i = 0; i < ADAPTER_ERROR_COUNTERS; i++) {
        if (pOidBuffer[i] != 0) {

            Request.Ndis.DATA.QUERY_INFORMATION.Oid = pOidBuffer[i];

            LEAVE_DLC(pFileContext);

            RELEASE_DRIVER_LOCK();

            Status = LlcNdisRequest(pFileContext->pBindingContext, &Request);

            ACQUIRE_DRIVER_LOCK();

            ENTER_DLC(pFileContext);

            if (Status != STATUS_SUCCESS) {

#if DBG
				if ( Status != STATUS_NOT_SUPPORTED ){
					// Only print real errors.
					DbgPrint("DLC.GetDlcErrorCounters: LlcNdisRequest returns %x\n", Status);
				}
#endif

                counter = 0;
            } else if ((counter - pFileContext->NdisErrorCounters[i] > 255)
            && (pAdapterErrors != NULL)) {
                counter = 255;
            } else {
                counter -= pFileContext->NdisErrorCounters[i];
            }
            if (pAdapterErrors != NULL) {
                pAdapterErrors[i] = (UCHAR)counter;
            }
            pFileContext->NdisErrorCounters[i] += counter;
        }
    }
}


NTSTATUS
DlcQueryInformation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    The routine returns the DLC specific information of any DLC object.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC address object
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  - the length of output parameters

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        STATUS_INVALID_COMMAND

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID hClientHandle = pFileContext->pBindingContext;
    PDLC_OBJECT pDlcObject;
    PLLC_ADAPTER_DLC_INFO pDlcAdapter;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // NOTE: DlcQueryBuffer output buffer size was not checked by 
    //       DlcDeviceIoControl. For each class we check the size
    //       based on what it will copy. Although it did check that
    //       the input buffer size was at least NT_DLC_QUERY_INFORMATION_INPUT
    //       size.
    //

    switch (pDlcParms->DlcGetInformation.Header.InfoClass) {
    case DLC_INFO_CLASS_DLC_ADAPTER:

        // union NT_DLC_PARMS
        //     LLC_ADAPTER_DLC_INFO     
        if (OutputBufferLength < sizeof(LLC_ADAPTER_DLC_INFO))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // The output data is just written to the
        // beginning of the current system buffer.
        //

        pDlcAdapter = (PLLC_ADAPTER_DLC_INFO)pDlcParms;
        GetOpenSapAndStationCount(pFileContext,
                                  &pDlcAdapter->OpenSaps,
                                  (PUCHAR)&pDlcAdapter->OpenStations
                                  );
        pDlcAdapter->MaxSap = 127;
        pDlcAdapter->MaxStations = 255;
        pDlcAdapter->AvailStations = (UCHAR)255 - pDlcAdapter->OpenStations;
        break;

    case DLC_INFO_CLASS_ADAPTER_LOG:

        // union NT_DLC_PARMS   (pDlcParms)
        //     union NT_DLC_QUERY_INFORMATION_PARMS DlcGetInformation
        //         union NT_DLC_QUERY_INFORMATION_OUTPUT Info
        //             union LLC_ADAPTER_LOG  AdapterLog
        if (OutputBufferLength < sizeof(LLC_ADAPTER_LOG))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        GetDlcErrorCounters(pFileContext, (PUCHAR)&pDlcParms->DlcGetInformation);
        break;

    case DLC_INFO_CLASS_LINK_STATION:
        
        // union NT_DLC_PARMS (pDlcParms)
        //     union NT_DLC_QUERY_INFORMATION_PARMS DlcGetInformation
        //         union NT_DLC_QUERY_INFORMATION_OUTPUT Info
        //             struct _DlcLinkInfoGet
        //                  USHORT MaxInformationField
        if (OutputBufferLength < sizeof(USHORT))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        Status = GetLinkStation(pFileContext,
                                pDlcParms->DlcGetInformation.Header.StationId,
                                &pDlcObject
                                );
        if (Status == STATUS_SUCCESS) {

            //
            // Round always the information field length to the full
            // dword even number => some copy operations may be much
            // faster (usually not, but worth of effor in any way)
            //

            pDlcParms->DlcGetInformation.Info.Link.MaxInformationField = (USHORT)(pDlcObject->u.Link.MaxInfoFieldLength & -3);
        }
        break;

    case DLC_INFO_CLASS_STATISTICS:
    case DLC_INFO_CLASS_STATISTICS_RESET:
        Status = GetStation(pFileContext,
                            pDlcParms->DlcGetInformation.Header.StationId,
                            &pDlcObject
                            );
        if (Status != STATUS_SUCCESS) {
            return Status;
        }

        hClientHandle = pDlcObject->hLlcObject;

        //
        // **** FALL THROUGH ****
        //

    default:

        //
        //  LLC will return invalid command, if it is not supported
        //

        LEAVE_DLC(pFileContext);

        RELEASE_DRIVER_LOCK();

        //
        // LlcQueryInformation validates buffer size before copying.
        //

        Status = LlcQueryInformation(hClientHandle,
                                     pDlcParms->DlcGetInformation.Header.InfoClass,
                                     (PLLC_QUERY_INFO_BUFFER)&(pDlcParms->DlcGetInformation),
                                     (UINT)OutputBufferLength
                                     );

        ACQUIRE_DRIVER_LOCK();

        ENTER_DLC(pFileContext);

        break;
    }
    return (NTSTATUS)Status;
}


NTSTATUS
DlcSetInformation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:


    The routine sets new parameter values for the DLC objects.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC address object
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS
        STATUS_SUCCESS
        STATUS_INVALID_COMMAND
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDLC_OBJECT pDlcObject;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    switch (pDlcParms->DlcSetInformation.Header.InfoClass) {
    case DLC_INFO_CLASS_LINK_STATION:
    case DLC_INFO_CLASS_DIRECT_INFO:
        Status = GetStation(pFileContext,
                            pDlcParms->DlcSetInformation.Header.StationId,
                            &pDlcObject
                            );
        if (Status != STATUS_SUCCESS) {
            return Status;
        }

        LEAVE_DLC(pFileContext);

        Status = LlcSetInformation(pDlcObject->hLlcObject,
                                   pDlcParms->DlcSetInformation.Header.InfoClass,
                                   (PLLC_SET_INFO_BUFFER)&(
                                   pDlcParms->DlcSetInformation.Info.LinkStation),
                                   sizeof(DLC_LINK_PARAMETERS)
                                   );
        break;

    case DLC_INFO_CLASS_DLC_TIMERS:

        LEAVE_DLC(pFileContext);

        Status = LlcSetInformation(pFileContext->pBindingContext,
                                   pDlcParms->DlcSetInformation.Header.InfoClass,
                                   (PLLC_SET_INFO_BUFFER)&(pDlcParms->DlcSetInformation.Info.TimerParameters),
                                   sizeof(LLC_TICKS)
                                   );
        break;

    case DLC_INFO_CLASS_SET_FUNCTIONAL:
    case DLC_INFO_CLASS_RESET_FUNCTIONAL:
    case DLC_INFO_CLASS_SET_GROUP:
    case DLC_INFO_CLASS_SET_MULTICAST:

        LEAVE_DLC(pFileContext);

        Status = LlcSetInformation(pFileContext->pBindingContext,
                                   pDlcParms->DlcSetInformation.Header.InfoClass,
                                   (PLLC_SET_INFO_BUFFER)&(pDlcParms->DlcSetInformation.Info.Broadcast),
                                   sizeof(TR_BROADCAST_ADDRESS)
                                   );
        break;

    case DLC_INFO_CLASS_GROUP:

        //
        // Setup DLC group SAPs.  Group saps are used as a common address
        // of a SAP group.  They can only receive frames.
        //

        Status = GetStation(pFileContext,
                            pDlcParms->DlcSetInformation.Header.StationId,
                            &pDlcObject
                            );
        if (Status != STATUS_SUCCESS) {
            return Status;
        }
        Status = SetupGroupSaps(pFileContext,
                                pDlcObject,
                                (UINT)pDlcParms->DlcSetInformation.Info.Sap.GroupCount,
                                (PUCHAR)pDlcParms->DlcSetInformation.Info.Sap.GroupList
                                );
        LEAVE_DLC(pFileContext);

        break;

    default:

        LEAVE_DLC(pFileContext);

        Status = DLC_STATUS_INVALID_COMMAND;
        break;
    };

    ENTER_DLC(pFileContext);

    return Status;
}


//
// Function returns the number of open sap and link
// stations for a dlc application.
//
VOID
GetOpenSapAndStationCount(
    IN PDLC_FILE_CONTEXT pFileContext,
    OUT PUCHAR pOpenSaps,
    OUT PUCHAR pOpenStations
    )
{
    UINT i, SapCount = 0;

    for (i = 1; i < MAX_SAP_STATIONS; i++) {
        if (pFileContext->SapStationTable[i] != NULL) {
            SapCount++;
        }
    }
    *pOpenSaps = (UCHAR)SapCount;
    if (pFileContext->SapStationTable[0] != NULL) {
        SapCount++;
    }
    *pOpenStations = (UCHAR)(pFileContext->DlcObjectCount - SapCount);
}


NTSTATUS
SetupGroupSaps(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN UINT GroupSapCount,
    IN PUCHAR pGroupSapList
    )

/*++

Routine Description:

    The routine deletes the current group saps list and
    and new group saps. Fi the new group sap list is empty, then
    we just delete all current group saps.

Arguments:

    pFileContext    - DLC context
    pDlcObject      - SAP object
    GroupSapCount   - number of new group saps
    pGroupSapList   - list of new group saps

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        STATUS_INVALID_COMMAND

--*/

{
    UINT i;
    UINT OpenOptions;

    //
    // We must first remove all old groups sap defined for the
    // sap station (if any)
    //

    if (pDlcObject->u.Sap.GroupSapHandleList != NULL) {
        for (i = 0; i < pDlcObject->u.Sap.GroupSapCount; i++) {
            if (pDlcObject->u.Sap.GroupSapHandleList[i] != NULL) {

                LEAVE_DLC(pFileContext);

                LlcCloseStation(pDlcObject->u.Sap.GroupSapHandleList[i], NULL);

                ENTER_DLC(pFileContext);
            }
        }
        FREE_MEMORY_FILE(pDlcObject->u.Sap.GroupSapHandleList);
        pDlcObject->u.Sap.GroupSapHandleList = NULL;
    }

    //
    // Note: the old group saps can be deleted with a null list!
    //

    pDlcObject->u.Sap.GroupSapCount = (UCHAR)GroupSapCount;
    if (GroupSapCount != 0) {
        pDlcObject->u.Sap.GroupSapHandleList = (PVOID*)ALLOCATE_ZEROMEMORY_FILE(
                                                                GroupSapCount
                                                                * sizeof(PVOID)
                                                                );
        if (pDlcObject->u.Sap.GroupSapHandleList == NULL) {
            return DLC_STATUS_NO_MEMORY;
        }

        //
        // The groups sap implementation is based on the fact,
        // that the lower module things to run a normal sap.
        // The routing of UI, TEST and XID frames for all
        // saps sends the incoming U-frames automatically
        // all real saps registered to a sap.  This method
        // could theoretically use very much memory if there were
        // very many saps and group saps (eg: 50 * 50 = 2500 * 100),
        // but that situation is actually impossible.
        // SNA saps (3) have one command group sap and even SNA
        // sap is very rarely used (not used by CommServer)
        //

        for (i = 0; i < pDlcObject->u.Sap.GroupSapCount; i++) {

            UINT Status;

            OpenOptions = 0;
            if (~(pDlcObject->u.Sap.OptionsPriority & XID_HANDLING_BIT)) {
                OpenOptions = LLC_HANDLE_XID_COMMANDS;
            }

            LEAVE_DLC(pFileContext);

            Status = LlcOpenSap(pFileContext->pBindingContext,
                                (PVOID)pDlcObject,
                                (UINT)pGroupSapList[i] | 1,
                                OpenOptions,
                                &pDlcObject->u.Sap.GroupSapHandleList[i]
                                );

            ENTER_DLC(pFileContext);

            if (Status != STATUS_SUCCESS) {
                return Status;
            }
        }
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcext.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcext.h
Abstract:

    This module includes all internal prototypes and
    externals of dlc (api driver) module.

Author:

    Antti Saarenheimo 22-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

extern USHORT aSpecialOutputBuffers[];
extern BOOLEAN MemoryLockFailed;
extern KSPIN_LOCK DlcSpinLock;

NTSTATUS
BufferPoolCreate(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PVOID pUserBuffer,
    IN LONG MaxBufferSize,
    IN LONG MinFreeSizeThreshold,
    OUT HANDLE *pBufferPoolHandle,
    OUT PVOID* AlignedAddress,
    OUT PULONG AlignedSize
    );

NTSTATUS
BufferPoolExpand(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool
    );

VOID
BufferPoolFreeExtraPages(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool
    );

VOID
DeallocateBuffer(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pBuffer
    );

NTSTATUS
AllocateBufferHeader(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pParent,
    IN UCHAR Size,
    IN UCHAR Index,
    IN UINT FreeListTableIndex
    );

NTSTATUS
BufferPoolAllocate(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferSize,
    IN UINT FrameHeaderSize,
    IN UINT UserDataSize,
    IN UINT FrameLength,
    IN UINT SegmentSizeIndex,
    IN OUT PDLC_BUFFER_HEADER *ppBufferHeader,
    OUT PUINT puiBufferSizeLeft
    );

NTSTATUS
BufferPoolDeallocate(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferCount,
    IN PLLC_TRANSMIT_DESCRIPTOR pBuffers
    );

NTSTATUS
BufferPoolBuildXmitBuffers(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN UINT BufferCount,
    IN PLLC_TRANSMIT_DESCRIPTOR pBuffers,
    IN OUT PDLC_PACKET pPacket
    );

VOID
BufferPoolFreeXmitBuffers(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN OUT PDLC_PACKET pPacket
    );

PDLC_BUFFER_HEADER
GetBufferHeader(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PVOID pUserBuffer
    );

VOID
BufferPoolDereference(
#if DBG
    IN PDLC_FILE_CONTEXT pFileContext,
#endif
    IN PDLC_BUFFER_POOL *pBufferPool
    );

NTSTATUS
BufferPoolReference(
    IN HANDLE hExternalHandle,
    OUT PVOID *phOpaqueHandle
    );

VOID
BufferPoolDeallocateList(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PDLC_BUFFER_HEADER pBufferList
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
CreateAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
CloseAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
DlcKillFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    );

VOID
DlcDriverUnload(
    IN PDRIVER_OBJECT pDeviceObject
    );

NTSTATUS
CleanupAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
DlcDeviceIoControl(
    IN PDEVICE_OBJECT pDeviceContext,
    IN PIRP pIrp
    );

VOID
DlcCompleteIoRequest(
    IN PIRP pIrp,
    IN BOOLEAN InCancel
    );

VOID
DlcCancelIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SetIrpCancelRoutine(
    IN PIRP Irp,
    IN BOOLEAN Set
    );

#ifdef DLC_PRIVATE_PROTOTYPES

DLC_STATUS
LlcReceiveIndication(
    IN PDLC_FILE_CONTEXT hFileContext,
    IN PDLC_OBJECT hDlcObject,
	IN NDIS_HANDLE MacReceiveContext,
    IN USHORT FrameType,
    IN PUCHAR pLookBuf,
    IN UINT cbLookBuf
    );

VOID
LlcEventIndication(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PVOID hEventObject,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

VOID
LlcCommandCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PDLC_PACKET pPacket
    );

#else

DLC_STATUS
LlcReceiveIndication(
    IN PVOID hFileContext,
    IN PVOID hClientHandle,
	IN NDIS_HANDLE MacReceiveContext,
    IN USHORT FrameType,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf
    );

VOID
LlcEventIndication(
    IN PVOID hFileContext,
    IN PVOID hEventObject,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInformation
    );

VOID
LlcCommandCompletion(
    IN PVOID        hFileContext,
    IN PVOID        hDlcObject,
    IN PVOID        hRequest
    );

#endif

VOID
CompleteTransmitCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PIRP pIrp,
    IN PDLC_OBJECT pChainObject,
    IN PDLC_PACKET pRootXmitNode
    );

NTSTATUS
DlcQueryInformation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcSetInformation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

VOID
GetOpenSapAndStationCount(
    IN PDLC_FILE_CONTEXT pFileContext,
    OUT PUCHAR OpenSaps,
    OUT PUCHAR OpenStations
    );

NTSTATUS
SetupGroupSaps(
    IN PDLC_FILE_CONTEXT  pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN UINT GroupSapCount,
    IN PUCHAR pGroupSapList
    );

NTSTATUS
MakeDlcEvent(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN PDLC_OBJECT pDlcObject,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo,
    IN BOOLEAN FreeEventInfo
    );

NTSTATUS
QueueDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PIRP pIrp,
    IN PVOID AbortHandle,
    IN PFCOMPLETION_HANDLER pfCompletionHandler
    );

NTSTATUS
AbortCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID AbortHandle,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus,
    IN BOOLEAN SuppressCommandCompletion
    );

VOID
CancelDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_COMMAND pDlcCommand,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus,
    IN BOOLEAN SuppressCommandCompletion
    );

VOID
PurgeDlcEventQueue(
    IN PDLC_FILE_CONTEXT pFileContext
    );

VOID
PurgeDlcFlowControlQueue(
    IN PDLC_FILE_CONTEXT pFileContext
    );

VOID
CompleteDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    IN PDLC_COMMAND pDlcCommand,
    IN UINT Status
    );

PDLC_COMMAND
IsCommandOnList(
    IN PVOID RequestHandle,
    IN PLIST_ENTRY List
    );

PDLC_COMMAND
SearchAndRemoveCommand(
    IN PLIST_ENTRY pListHead,
    IN ULONG EventMask,
    IN USHORT StationId,
    IN USHORT StationIdMask
    );

PDLC_COMMAND
SearchAndRemoveCommandByHandle(
    IN PLIST_ENTRY pListHead,
    IN ULONG EventMask,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID AbortHandle
    );

PDLC_COMMAND
SearchAndRemoveSpecificCommand(
    IN PLIST_ENTRY pListHead,
    IN PVOID AbortHandle
    );

PDLC_COMMAND
SearchAndRemoveAnyCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID pSearchHandle
    );

VOID
SearchReadCommandForClose(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbAddress,
    IN ULONG CommandCompletionFlag,
    IN USHORT StationId,
    IN USHORT StationIdMask
    );

NTSTATUS
DlcBufferFree(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcBufferGet(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcBufferCreate(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcBufferMaintain(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcConnectStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcFlowControl(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcReallocate(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcReset(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
ConnectCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

NTSTATUS
DirSetExceptionFlags(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

VOID
DlcCompleteRequest(
    IN PIRP pIrp,
    IN PVOID pUserCcbPointer
    );

VOID
CompleteAsyncCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN UINT Status,
    IN PIRP pIrp,
    IN PVOID pUserCcbPointer,
    IN BOOLEAN InCancel
    );

NTSTATUS
GetLinkStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppLinkStation
    );

NTSTATUS
GetSapStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppLinkStation
    );

NTSTATUS
GetStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppStation
    );

NTSTATUS
DlcReadCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirOpenAdapter(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirCloseAdapter(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

VOID
CompleteDirInitialize(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbLink
    );

VOID
CompleteDirCloseAdapter(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbLink
    );

NTSTATUS
DlcTransmit(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pParameters,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirTimerSet(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
DirTimerSetCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN UINT Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

NTSTATUS
DirTimerCancelGroup(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirTimerCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

PDLC_COMMAND*
SearchTimerCommand(
    IN PDLC_COMMAND *ppQueue,
    IN PVOID pSearchHandle,
    IN BOOLEAN SearchCompletionFlags
    );

PDLC_COMMAND
SearchPrevCommandWithFlag(
    IN PDLC_COMMAND pQueueBase,
    IN ULONG Event,
    IN ULONG CommandCompletionFlag
    );

VOID
AbortCommandsWithFlag(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG CommandCompletionFlag,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus
    );

NTSTATUS
DlcOpenSap(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DirOpenDirect(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcOpenLinkStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
InitializeLinkStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT  pSap,
    IN PNT_DLC_PARMS pDlcParms OPTIONAL,
    IN PVOID LlcLinkHandle OPTIONAL,
    OUT PDLC_OBJECT *ppLinkStation
    );

NTSTATUS
DlcCloseStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
CloseAllStations(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PFCLOSE_COMPLETE pfCloseComplete,
    IN PNT_DLC_PARMS pDlcParms,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo
    );

VOID
CloseAnyStation(
    IN PDLC_OBJECT pDlcObject,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN BOOLEAN DoImmediateClose
    );

VOID
CompleteCloseReset(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo
    );

NTSTATUS
DlcReceiveRequest(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
ReceiveCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

NTSTATUS
DlcReadRequest(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

BOOLEAN
ReadCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

VOID
CreateBufferChain(
    IN PDLC_BUFFER_HEADER pBufferHeaders,
    OUT PVOID *pFirstBuffer,
    OUT PUSHORT pReceivedFrameCount
    );

NTSTATUS
DlcReceiveCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DlcCompleteCommand(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );

VOID
GetDlcErrorCounters(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PUCHAR pAdapterErrors
    );

VOID
QueueDlcEvent(
    IN PDLC_FILE_CONTEXT  pFileContext,
    IN PDLC_PACKET pPacket
    );

VOID
CompleteCloseStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject
    );

VOID
CloseStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN BOOLEAN DoImmediateClose
    );

VOID
CleanUpEvents(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PDLC_OBJECT pDlcObject
    );

VOID
CompleteCompletionPacket(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_COMPLETION_EVENT_INFO pCompletionInfo,
    IN OUT PNT_DLC_PARMS pParms
    );

PMDL
AllocateProbeAndLockMdl(
    IN PVOID UserBuffer,
    IN UINT UserBufferLength
    );

VOID
BuildMappedPartialMdl(
    IN PMDL pMappedSourceMdl,
    IN OUT PMDL pTargetMdl,
    IN PVOID BaseVa,
    IN ULONG Length
    );

VOID
BufferTrace(
    IN PDLC_BUFFER_POOL pBufferPool,
    IN PSZ  DebugString
    );

VOID
CheckIrql(
    PKIRQL  pOldIrqLevel
    );

VOID
ResetLocalBusyBufferStates(
    IN PDLC_FILE_CONTEXT pFileContext
    );

VOID
CompleteLlcObjectClose(
    IN PDLC_OBJECT pDlcObject
    );

VOID
UnlockAndFreeMdl(
    PMDL pMdl
    );

BOOLEAN
DecrementCloseCounters(
    PDLC_FILE_CONTEXT pFileContext,
    PDLC_CLOSE_WAIT_INFO pClosingInfo
    );

VOID
CompleteDirectOutIrp(
    IN PIRP Irp,
    IN UCHAR Status,
    IN PLLC_CCB NextCcb
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcdrvr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcdrvr.c

Abstract:

    This module contains code which implements the NT DLC driver API
    using the generic data link module.

    Contents:
        DriverEntry
        CreateAdapterFileContext
        CleanupAdapterFileContext
        DlcDriverUnload
        CloseAdapterFileContext
        DlcKillFileContext
        DlcDeviceIoControl
        DlcCompleteIoRequest

Author:

    Antti Saarenheimo 8-Jul-1991

Environment:

    Kernel mode

Revision History:


--*/

#define INCLUDE_IO_BUFFER_SIZE_TABLE        // includes the io buffer sizes

#include <dlc.h>
#include "dlcreg.h"
#include "dbgmsg.h"

#define DEFINE_DLC_DIAGNOSTICS
#include "dlcdebug.h"

/*++

The queueing of asynchronous commands (21 Oct. 1991)
----------------------------------------------------

DLC driver uses basically three different methods to queue and
complete its asyncronous commands:

1. Using LLC request handle

In this case the LLC driver takes care of the command queueing.
This method is used by:
- all transmit commands
- all close commands
- dlc connect
- dlc disconnect

2. DLC (READ / RECEIVE) Command queue (FIFO)

The read and receive commands are saved to the command completion
queue, that is is circular single enty link list.
The events are handled by the oldest pending command.
These commands also check the event queue and the command
is queued only if there are no pending events.

3. Timer queue

Timer queue is a null terminated single entry link list.
They are sorted by the relative expiration time.  The timer
tick completes all timer commands having the same expiration
time.  The expiration times are relative to all previous
commands.  For example, timer commands having expiration times 1, 2 and 3
would all have 1 tick count in the queue.  Thus the timer tick
needs to increment only one tick from the beginning of the list
and complete all timer commands having zero expiration time.
When command is cancelled, its tick count must be added
to the next element in the queue.

--*/


/*++

New stuff in Feb-20-1992


(reason: with a free build (because it is so fast) I run out of
 non-paged pool and several problems did arise in DLC driver:
 commands were sometimes lost, DLC.RESET did never complete and
 the adapter close


The recovery rules when no non-paged memory is available:

1. The adapter close (or file context close by handle) must work always =>
   the adapter close packet must be in the file context.

2. The commands must allocate all resources needed to complete the
   command before they return a pending status (transmit!), if that
   cannot be done then the command must fail immediately.

3. The received data must not be acknowledged before all resources
   have been allocated to receive it.

4. Probablem: we may lose an important link state change indication if we
   cannot allocate a packet for it.  For example, the application may
   not know, that the link is in the local busy state.  The dlc status events
   of quite many link stations (255) may also very soon eat all non-paged
   pool, if they are not read by client.  A static event packet would
   prevent that.
   A solution: a static event indication packet
   in the dlc object, connect and disconnect confirmation would be handled
   as now (they are indicated in the command completion entry).
   The indication status would be reset, when it is read from the command
   queue.  The same event indication may have several flags.


(Do first 1, 2, 3 and 4, make the test even more stressing for non-paged
 pool and test then what happens.  Then we may fix the bug in the buffer
 pool shrinkin and implement dynamic packet pools).

The long term solutions:

Dynamic memory management in dlc!  The current dlc memory management
is very fast and the top memory consumption is minimal (without the
default 33% overhead of binary buddy algorithm), but it never release
the resources, that it has once allocated.


1. The packet pools should release the extra memory when they are not
   needed any more, implementation: each memory block allocated for
   the packet pool has a reference count, that memory block is deallocated
   when the reference count is zero.  This cleanup could be done once in
   a second.  The algorithm scans the free list of packets, removes the
   packet from the free list, if the reference count of free packets
   is the same as the total packet count on a memory block.
   The memory blocks can be relesed in the next loop while the block itself
   is disconnected from the single entry list of all memory blocks in
   the packet pool.

2. The buffer pool memory management should also be able to shrink the
   number of locked pages (there must be a bug in the current implementation)
   AND also to free all MDLs and extra packets, when the buffer pool pages
   are unlocked.


3. Data link driver should not allocated any memory resources (except
   packet pools to send its own frames).  The objects should be created
   by in the dlc driver => all extra resources are released when
   a dlc driver is released (actually not a big deal, because dynamic
   packet pool management fixes the problem with the link stations).

--*/

//  Local IOCTL dispatcher table:
// ***************************************************
//  THE ORDER OF THESE FUNCTIONS MUST BE THE SAME AS
//  THE IOCTL COMMAND CODES IN NTDDDLC.H
// ***************************************************

static PFDLC_COMMAND_HANDLER DispatchTable[IOCTL_DLC_LAST_COMMAND] = {
    DlcReadRequest,
    DlcReceiveRequest,
    DlcTransmit,
    DlcBufferFree,
    DlcBufferGet,
    DlcBufferCreate,
    DirSetExceptionFlags,
    DlcCloseStation,                    // DLC.CLOSE.STATION
    DlcConnectStation,
    DlcFlowControl,
    DlcOpenLinkStation,
    DlcReset,
    DlcReadCancel,
    DlcReceiveCancel,
    DlcQueryInformation,
    DlcSetInformation,
    DirTimerCancel,
    DirTimerCancelGroup,
    DirTimerSet,
    DlcOpenSap,
    DlcCloseStation,                    // DLC.CLOSE.SAP
    DirOpenDirect,
    DlcCloseStation,                    // DIR.CLOSE.DIRECT
    DirOpenAdapter,
    DirCloseAdapter,
    DlcReallocate,
    DlcReadRequest,
    DlcReceiveRequest,
    DlcTransmit,
    DlcCompleteCommand
};

USHORT aSpecialOutputBuffers[3] = {
    sizeof(LLC_READ_OUTPUT_PARMS),
    sizeof(PVOID),                     // pFirstBuffer
    sizeof(UCHAR)                      // TransmitFrameStatus
};

NDIS_SPIN_LOCK DlcDriverLock;

#ifdef LOCK_CHECK

LONG DlcDriverLockLevel = 0;

ULONG __line = 0;
PCHAR __file = NULL;
LONG __last = 1;
HANDLE __process = (HANDLE)0;
HANDLE __thread = (HANDLE)0;

#endif

#if LLC_DBG

extern PVOID pAdapters;

ULONG AllocatedNonPagedPool = 0;
ULONG LockedPageCount = 0;
ULONG AllocatedMdlCount = 0;
ULONG AllocatedPackets = 0;
ULONG cExAllocatePoolFailed = 0;
ULONG FailedMemoryLockings = 0;
NDIS_SPIN_LOCK MemCheckLock;

ULONG cFramesReceived = 0;
ULONG cFramesIndicated = 0;
ULONG cFramesReleased = 0;

ULONG cLockedXmitBuffers = 0;
ULONG cUnlockedXmitBuffers = 0;

#endif

//UINT InputIndex = 0;
//LLC_SM_TRACE aLast[LLC_INPUT_TABLE_SIZE];

#if DBG & DLC_TRACE_ENABLED

UINT LlcTraceIndex = 0;
UCHAR LlcTraceTable[LLC_TRACE_TABLE_SIZE];

#endif // DBG & DLC_TRACE_ENABLED


//
// prototypes
//

VOID
LinkFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    );

PDLC_FILE_CONTEXT
UnlinkFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    );

//
// global data
//

BOOLEAN MemoryLockFailed = FALSE;   // this limits unneceasary memory locks
KSPIN_LOCK DlcSpinLock;             // syncnhronize the final cleanup
PDEVICE_OBJECT ThisDeviceContext;   // required for unloading driver

//
// we now maintain a singly-linked list of FILE_CONTEXTs for debug and retail
// versions
//

SINGLE_LIST_ENTRY FileContexts = {NULL};
KSPIN_LOCK FileContextsLock;
KIRQL PreviousIrql;

#if DBG

BOOLEAN Prolix;
MEMORY_USAGE DriverMemoryUsage;
MEMORY_USAGE DriverStringUsage; // how much string does it take to hang a DLC driver?

#endif

//
// external data
//


//
// functions
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This function is called when the I/O subsystem loads the DLC driver

    This routine performs the initialization of NT DLC API driver.
    Eventually this should be called after the first reference to
    DLC driver.

Arguments:

    pDriverObject   - Pointer to driver object created by the system
    RegistryPath    - The name of DLC's node in the registry

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS Status;
    PDEVICE_OBJECT pDeviceObject;
    UNICODE_STRING DriverName;

    ASSUME_IRQL(PASSIVE_LEVEL);

#if DBG
    if (Prolix) {
        DbgPrint("DLC.DriverEntry\n");
    }
    KeInitializeSpinLock(&DriverMemoryUsage.SpinLock);
    KeInitializeSpinLock(&DriverStringUsage.SpinLock);
    InitializeMemoryPackage();
#endif

    KeInitializeSpinLock(&FileContextsLock);

    //
    // load any initialization-time parameters from the registry
    //

    DlcRegistryInitialization(RegistryPath);
    LoadDlcConfiguration();

    //
    // LLC init makes ourselves known to the NDIS wrapper,
    // but we don't yet bind to any NDIS driver (don't know even the name)
    //

    Status = LlcInitialize();
    if (Status != STATUS_SUCCESS) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Create the DLC device object. For now, we simply create \Device\Dlc
    // using a Unicode string. In the future we may need to load an ACL
    //

    RtlInitUnicodeString(&DriverName, DD_DLC_DEVICE_NAME);

    //
    // Create the device object for DLC driver, we don't have any
    // device specific data, because DLC needs only one device context.
    // Thus it can just use statics and globals.
    //

    Status = IoCreateDevice(pDriverObject,
                            0,
                            &DriverName,
                            FILE_DEVICE_DLC,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &pDeviceObject
                            );
    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {

        //
        // need to keep a pointer to device context for IoDeleteDevice
        //

        ThisDeviceContext = pDeviceObject;
    }

    //
    // DLC driver never calls other device drivers: 1 I/O stack in IRP is enough
    //

    pDeviceObject->StackSize = 1;
    pDeviceObject->Flags |= DO_DIRECT_IO;

    KeInitializeSpinLock(&DlcSpinLock);

    NdisAllocateSpinLock(&DlcDriverLock);

    //
    // Initialize the driver object with this driver's entry points.
    //

    pDriverObject->MajorFunction[IRP_MJ_CREATE] = CreateAdapterFileContext;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = CloseAdapterFileContext;
    pDriverObject->MajorFunction[IRP_MJ_CLEANUP] = CleanupAdapterFileContext;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DlcDeviceIoControl;
    pDriverObject->DriverUnload = DlcDriverUnload;

    return STATUS_SUCCESS;
}


NTSTATUS
CreateAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This function is called when a handle to the DLC driver is opened (via
    NtCreateFile)

    The Create function creates file context for a DLC application.
    A DLC application needs at least one file context for each
    network adapter it is using.  The DLC file contexts may share
    the same buffer pool, but otherwise they are totally isolated
    from each other.

Arguments:

    DeviceObject    - Pointer to the device object for this driver
    Irp             - Pointer to the request packet representing the I/O request

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PDLC_FILE_CONTEXT pFileContext;
    PIO_STACK_LOCATION pIrpSp;

    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSUME_IRQL(PASSIVE_LEVEL);

#if LLC_DBG == 2
    PrintMemStatus();
#endif

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pFileContext = (PDLC_FILE_CONTEXT)ALLOCATE_ZEROMEMORY_DRIVER(sizeof(DLC_FILE_CONTEXT));
    if (pFileContext == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit2;
    }

    // #126745: Enqueue after initialization
    /*    //
    // add this file context to our global list of opened file contexts
    //

    LinkFileContext(pFileContext); */

#if DBG

    //
    // record who owns this memory usage and add it to our global list of
    // memory usages
    //

    pFileContext->MemoryUsage.Owner = (PVOID)pFileContext;
    pFileContext->MemoryUsage.OwnerObjectId = FileContextObject;
    LinkMemoryUsage(&pFileContext->MemoryUsage);
#endif

    pIrpSp->FileObject->FsContext = pFileContext;
    pFileContext->FileObject = pIrpSp->FileObject;

    InitializeListHead(&pFileContext->EventQueue);
    InitializeListHead(&pFileContext->CommandQueue);
    InitializeListHead(&pFileContext->ReceiveQueue);
    InitializeListHead(&pFileContext->FlowControlQueue);

    //
    // create pool of command/event packets
    //

    pFileContext->hPacketPool = CREATE_PACKET_POOL_FILE(DlcPacketPoolObject,
                                                        sizeof(DLC_PACKET),
                                                        8
                                                        );
    if (pFileContext->hPacketPool == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit1;
    }

    //
    // create pool of DLC-level SAP/LINK/DIRECT objects
    //

    pFileContext->hLinkStationPool = CREATE_PACKET_POOL_FILE(DlcLinkPoolObject,
                                                             sizeof(DLC_OBJECT),
                                                             4
                                                             );
    if (pFileContext->hLinkStationPool == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit1;
    }

    //
    // add this file context to our global list of opened file contexts
    //
    LinkFileContext(pFileContext); 

    //
    // set the file context reference count to 1 - this file context is ALIVE!
    //

    ReferenceFileContext(pFileContext);

    //
    // the call to open a handle to the driver may have succeeded, but we don't
    // yet have an open adapter context
    //

    pFileContext->State = DLC_FILE_CONTEXT_CLOSED;
    ALLOCATE_SPIN_LOCK(&pFileContext->SpinLock);

    KeInitializeEvent(&pFileContext->CleanupEvent, SynchronizationEvent, FALSE);

ErrorExit1:

    if (Status != STATUS_SUCCESS) {

        DELETE_PACKET_POOL_FILE(&pFileContext->hLinkStationPool);
        DELETE_PACKET_POOL_FILE(&pFileContext->hPacketPool);
        CHECK_MEMORY_RETURNED_FILE();

	// UnlinkFileContext(pFileContext);

#if DBG
        // UnlinkMemoryUsage(&pFileContext->MemoryUsage);
#endif

        FREE_MEMORY_DRIVER(pFileContext);
    }

ErrorExit2:

    pIrp->IoStatus.Status = Status;
    DlcCompleteIoRequest(pIrp, FALSE);
    return Status;
}


NTSTATUS
CleanupAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This function is called when the last reference to an open file handle is
    removed. This is an opportunity, given us by the I/O subsystem, to ensure
    that all pending I/O requests for the file object being closed have been
    completed

    The routine checks, that the file context is really closed.
    Otherwise it executes a panic closing of all resources in
    the same way as in the DirCloseAdapter call.
    It happens when an application makes process exit without
    calling the DirCloseAdapter.

Arguments:

    DeviceObject    - Pointer to the device object for this driver
    Irp             - Pointer to the request packet representing the I/O request

Return Value:

    The function value is the status of the operation.

--*/

{
    PIO_STACK_LOCATION pIrpSp;
    PDLC_FILE_CONTEXT pFileContext;
    NTSTATUS Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pDeviceObject);

    DIAG_FUNCTION("CleanupAdapterFileContext");

#if DBG
    if (Prolix) {
        DbgPrint("CleanupAdapterFileContext\n");
    }
#endif

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pFileContext = pIrpSp->FileObject->FsContext;

    //
    // We may have a pending close or Initialize operation going on
    //

    ACQUIRE_DRIVER_LOCK();

    ENTER_DLC(pFileContext);

    KeResetEvent(&pFileContext->CleanupEvent);
    
    if (pFileContext->State == DLC_FILE_CONTEXT_OPEN) {
        //
        // as for Ioctl processing, add 2 to the file context reference count
        // The combination of the dereference below, the completion of the
        // close adapter call and the processing of a close IRP will cause the
        // file context to be destroyed
        //

        ReferenceFileContextByTwo(pFileContext);
        Status = DirCloseAdapter(pIrp,
                                 pFileContext,
                                 NULL,
                                 0,
                                 0
                                 );

#if LLC_DBG
        if (Status != STATUS_PENDING) {
            DbgBreakPoint();
        }
#endif

        //
        // We always return a pending status from DirCloseAdapter
        //

        MY_ASSERT(Status == STATUS_PENDING);

        DereferenceFileContext(pFileContext);
    } 
    
    //
    // Remove the original DLC_FILE_CONTEXT reference.
    //

    DereferenceFileContext(pFileContext);

    LEAVE_DLC(pFileContext);
    RELEASE_DRIVER_LOCK();

    //
    // Wait for all references to the DLC_FILE_CONTEXT to be removed. When
    // the last reference is removed, DlcKillFileContext is called which will
    // clean up most of the file context's resources and then set the event.
    // CloseAdapterFileContext/IRP_MJ_CLOSE will free the actual memory
    // for the file context.
    //

    KeWaitForSingleObject(
        &pFileContext->CleanupEvent, 
        UserRequest,
        KernelMode,
        FALSE,
        NULL);

    DlcCompleteIoRequest(pIrp, FALSE);
    
    return Status;
}


VOID
DlcDriverUnload(
    IN PDRIVER_OBJECT pDeviceObject
    )

/*++

Routine Description:

    This functions is called when a called is made to the I/O subsystem to
    remove the DLC driver

Arguments:

    DeviceObject - Pointer to the device object for this driver.

Return Value:

    The function value is the status of the operation.

--*/

{
    UNREFERENCED_PARAMETER(pDeviceObject);

    ASSUME_IRQL(PASSIVE_LEVEL);

    DEBUGMSG(DBG_INIT,
        (TEXT("DlcDriverUnload(%#x)\n"), pDeviceObject));
    
    LlcTerminate();
    DlcRegistryTermination();

    CHECK_MEMORY_RETURNED_DRIVER();
    CHECK_STRING_RETURNED_DRIVER();
    CHECK_DRIVER_MEMORY_USAGE(TRUE);

    NdisFreeSpinLock(&DlcDriverLock);

    //
    // now tell I/O subsystem that this device context is no longer current
    //

    IoDeleteDevice(ThisDeviceContext);
}


NTSTATUS
CloseAdapterFileContext(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This routine is called when the file object reference count is zero. The file
    object is really being deleted by the I/O subsystem. The file context had
    better be closed by now (should have been cleared out by Cleanup)

Arguments:

    DeviceObject    - Pointer to the device object for this driver
    Irp             - Pointer to the request packet representing the I/O request

Return Value:

    The function value is the status of the operation.

--*/

{
    PIO_STACK_LOCATION pIrpSp;
    PDLC_FILE_CONTEXT pFileContext;

    UNREFERENCED_PARAMETER(pDeviceObject);

    DIAG_FUNCTION("CloseAdapterFileContext");

#if DBG
    if (Prolix) {
        DbgPrint("CloseAdapterFileContext\n");
    }
#endif

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pFileContext = pIrpSp->FileObject->FsContext;

    //
    // The original reference was removed in CleanupAdapterFileContext and
    // blocked until all references were removed and the file context 
    // resources cleaned up, except for the following. 
    //

    ASSERT(pFileContext->ReferenceCount == 0);
    ASSERT(UnlinkFileContext(pFileContext) == NULL);

    pIrpSp->FileObject->FsContext = NULL;
    DEALLOCATE_SPIN_LOCK(&pFileContext->SpinLock);
    FREE_MEMORY_DRIVER(pFileContext);

    //
    // complete the Close IRP
    //

    DlcCompleteIoRequest(pIrp, FALSE);

#if DBG
    if (Prolix) {
        CHECK_DRIVER_MEMORY_USAGE(FALSE);
    }
#endif

    return STATUS_SUCCESS;
}


VOID
DlcKillFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Called when the reference count on a file context structure is decremented
    to zero. Frees all memory owned by the file context and removes it from the
    file context list.

    After this function, no references to the file context structure can be made!

Arguments:

    pFileContext    - pointer to DLC file context structure to kill

Return Value:

    None.

--*/

{
    KIRQL irql;
    PVOID pBindingContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    // Shouldn't need lock since only called when reference count is 0.
    // ENTER_DLC(pFileContext);

    //
    // delete all events on the file context event list before we delete the
    // packet pool
    //

    PurgeDlcEventQueue(pFileContext);
    PurgeDlcFlowControlQueue(pFileContext);

    DELETE_PACKET_POOL_FILE(&pFileContext->hPacketPool);
    DELETE_PACKET_POOL_FILE(&pFileContext->hLinkStationPool);

    // LEAVE_DLC(pFileContext);


    pBindingContext = pFileContext->pBindingContext;

    //
    // Finally, close the NDIS adapter. we have already disabled all
    // indications from it
    //

    if (pBindingContext) {

        //
        // RLF 04/26/94
        //
        // We need to call LlcDisableAdapter here to terminate the DLC timer
        // if it is not already terminated. Else we can end up with the timer
        // still in the adapter's tick list (if there are other bindings to
        // the adapter), and sooner or later that will cause an access
        // violation, followed very shortly thereafter by a blue screen
        //

        LlcDisableAdapter(pBindingContext);
        LlcCloseAdapter(pBindingContext, TRUE);
    }

    CHECK_MEMORY_RETURNED_FILE();

    UnlinkFileContext(pFileContext);

#if DBG

    UnlinkMemoryUsage(&pFileContext->MemoryUsage);

#endif

    KeSetEvent(&pFileContext->CleanupEvent, 0, FALSE);

#if LLC_DBG

    if ((LockedPageCount != 0
    || AllocatedMdlCount != 0
    || AllocatedNonPagedPool != 0)
    && pAdapters == NULL) {
        DbgPrint("DLC.CloseAdapterFileContext: Error: Resources not released\n");
        //PrintMemStatus();
        DbgBreakPoint();
    }
    FailedMemoryLockings = 0;

#endif

}


NTSTATUS
DlcDeviceIoControl(
    IN PDEVICE_OBJECT pDeviceContext,
    IN PIRP pIrp
    )

/*++

Routine Description:

    This routine dispatches DLC requests to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various DLC request handlers so that they are
    not IRP-dependent.

    DlcDeviceControl and LlcReceiveIndication are the most time critical
    procedures in DLC.  This code has been optimized for the asynchronous
    command (read and transmit)

Arguments:

    pDeviceContext  - Pointer to the device object for this driver (unused)
    pIrp            - Pointer to the request packet representing the I/O request

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
                    The I/O request has been successfully completed

                  STATUS_PENDING
                    The I/O request has been submitted and will be completed
                    asynchronously

        Failure - DLC_STATUS_XXX
                  LLC_STATUS_XXX
                    The I/O request has been completed, but an error occurred

--*/

{
    USHORT TmpIndex;
    PDLC_FILE_CONTEXT pFileContext; // FsContext in FILE_OBJECT.
    PIO_STACK_LOCATION pIrpSp;
    ULONG ioControlCode;

    UNREFERENCED_PARAMETER(pDeviceContext);

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // Make sure status information is consistent every time
    //

    pIrp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Branch to the appropriate request handler, but do first
    // preliminary checking of the input and output buffers,
    // the size of the request block is performed here so that it is known
    // in the handlers that the minimum input parameters are readable.  It
    // is *not* determined here whether variable length input fields are
    // passed correctly; this is a check which must be made within each routine.
    //

    ioControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
    
    // Check the complete IoControl Code

    switch (ioControlCode) {
      case IOCTL_DLC_READ:
      case IOCTL_DLC_RECEIVE:
      case IOCTL_DLC_TRANSMIT:
      case IOCTL_DLC_BUFFER_FREE:
      case IOCTL_DLC_BUFFER_GET:
      case IOCTL_DLC_BUFFER_CREATE:
      case IOCTL_DLC_SET_EXCEPTION_FLAGS:
      case IOCTL_DLC_CLOSE_STATION:
      case IOCTL_DLC_CONNECT_STATION:
      case IOCTL_DLC_FLOW_CONTROL:
      case IOCTL_DLC_OPEN_STATION:
      case IOCTL_DLC_RESET:
      case IOCTL_DLC_READ_CANCEL:
      case IOCTL_DLC_RECEIVE_CANCEL:
      case IOCTL_DLC_QUERY_INFORMATION:
      case IOCTL_DLC_SET_INFORMATION:
      case IOCTL_DLC_TIMER_CANCEL:
      case IOCTL_DLC_TIMER_CANCEL_GROUP:
      case IOCTL_DLC_TIMER_SET:
      case IOCTL_DLC_OPEN_SAP:
      case IOCTL_DLC_CLOSE_SAP:
      case IOCTL_DLC_OPEN_DIRECT:
      case IOCTL_DLC_CLOSE_DIRECT:
      case IOCTL_DLC_OPEN_ADAPTER:
      case IOCTL_DLC_CLOSE_ADAPTER:
      case IOCTL_DLC_REALLOCTE_STATION:
      case IOCTL_DLC_READ2:
      case IOCTL_DLC_RECEIVE2:
      case IOCTL_DLC_TRANSMIT2:
      case IOCTL_DLC_COMPLETE_COMMAND:
      case IOCTL_DLC_TRACE_INITIALIZE:
        TmpIndex = (((USHORT)ioControlCode) >> 2) & 0x0fff;
        break;
      default:
        TmpIndex = IOCTL_DLC_LAST_COMMAND;
    }
    
    //    TmpIndex = (((USHORT)ioControlCode) >> 2) & 0x0fff;
    if (TmpIndex >= IOCTL_DLC_LAST_COMMAND) {

        pIrp->IoStatus.Information = 0;

        // DlcCompleteIoRequest(pIrp, FALSE);
        // Don't call DlcCompleteIoRequest, it tries to free MDLs we haven't yet allocated
        // Instead of putting some more checks in DlcCompleteIoRequest, complete request here itself

        pIrp->IoStatus.Status = DLC_STATUS_INVALID_COMMAND;
        SetIrpCancelRoutine(pIrp, FALSE);
        IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);
        return DLC_STATUS_INVALID_COMMAND;
    }

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength
                            < (ULONG)aDlcIoBuffers[TmpIndex].InputBufferSize
        ||

        pIrpSp->Parameters.DeviceIoControl.OutputBufferLength
                            < (ULONG)aDlcIoBuffers[TmpIndex].OutputBufferSize) {

        //
        // This error code should never be returned to user
        // If this happpens, then there is something wrong with ACSLAN
        //

        pIrp->IoStatus.Information = 0;

        // DlcCompleteIoRequest(pIrp, FALSE);
        // Don't call DlcCompleteIoRequest, it tries to free MDLs we haven't yet allocated
        // Instead of putting some more checks in DlcCompleteIoRequest, complete request here itself

        pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        SetIrpCancelRoutine(pIrp, FALSE);
        IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Save the length of the actual output buffer to Information field.
    // This number of bytes will be copied back to user buffer.
    //

    pIrp->IoStatus.Information = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // there are 3 cases of asynchronous commands where we need to lock extra
    // user memory for returned information. This goes in the parameter table
    // which can be anywhere in user memory (ie not near the CCB):
    //
    //  TRANSMIT
    //      - TRANSMIT_FS - a single byte!
    //
    //  RECEIVE
    //      - FIRST_BUFFER - a DWORD - pointer to the first received frame
    //
    //  READ
    //      - the entire parameter table needs to be locked. Virtually all
    //        the fields are output. Still, this is only a max of 30 bytes
    //

    if (TmpIndex <= IOCTL_DLC_TRANSMIT_INDEX) {

        PVOID pDestination;
        PNT_DLC_PARMS pDlcParms;

        pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

        //
        // Get the pointer of output parameters in user memory.
        // Note that we are not accessing anything in user address space.
        //

        switch (TmpIndex) {
        case IOCTL_DLC_READ_INDEX:
            pDestination = &pDlcParms->Async.Ccb.u.pParameterTable->Read.uchEvent;
            break;

        case IOCTL_DLC_RECEIVE_INDEX:
            pDestination = &pDlcParms->Async.Ccb.u.pParameterTable->Receive.pFirstBuffer;
            break;

        case IOCTL_DLC_TRANSMIT_INDEX:
            pDestination = &pDlcParms->Async.Ccb.u.pParameterTable->Transmit.uchTransmitFs;
            break;
        }

        //
        // allocate another MDL for the 1, 4, or 30 byte parameter table and lock
        // the page(s!)
        //

        pDlcParms->Async.Ccb.u.pMdl = AllocateProbeAndLockMdl(
                                            pDestination,
                                            aSpecialOutputBuffers[TmpIndex]
                                            );
        if (pDlcParms->Async.Ccb.u.pMdl == NULL) {
            pIrp->IoStatus.Status = DLC_STATUS_MEMORY_LOCK_FAILED;
            DlcCompleteIoRequest(pIrp, FALSE);
            return DLC_STATUS_MEMORY_LOCK_FAILED;
        }
    }

    pFileContext = (PDLC_FILE_CONTEXT)pIrpSp->FileObject->FsContext;

    ACQUIRE_DRIVER_LOCK();

    ENTER_DLC(pFileContext);

    //
    // We must leave immediately, if the reference counter is zero
    // or if we have a pending close or Initialize operation going on.
    // (This is not 100% safe, if app would create a file context,
    // open adapter, close adapter and immediately would close it again
    // when the previous command is pending, but that cannot be happen
    // with dlcapi.dll)
    //

    if ((pFileContext->ReferenceCount == 0)
    || ((pFileContext->State != DLC_FILE_CONTEXT_OPEN)
    && (TmpIndex != IOCTL_DLC_OPEN_ADAPTER_INDEX))) {

        LEAVE_DLC(pFileContext);

        RELEASE_DRIVER_LOCK();

        pIrp->IoStatus.Status = LLC_STATUS_ADAPTER_CLOSED;
        DlcCompleteIoRequest(pIrp, FALSE);
        return LLC_STATUS_ADAPTER_CLOSED;

    } else {

        NTSTATUS Status;

        DLC_TRACE('F');

        //
        // set the default IRP cancel routine. We are not going to handle
        // transmit cases now
        //

        //SetIrpCancelRoutine(pIrp,
        //                    (BOOLEAN)
        //                    !( (ioControlCode == IOCTL_DLC_TRANSMIT)
        //                    || (ioControlCode == IOCTL_DLC_TRANSMIT2) )
        //                    );

        //
        // and set the irp I/O status to pending
        //

        IoMarkIrpPending(pIrp);

        //
        // The reason why we add 2 here is that during the processing of the
        // current IRP we may complete the request, causing us to decrement the
        // reference counter on the file context. If we just incremented by 1
        // here, the decrement could cause a pending close IRP to be allowed to
        // delete the file context while we are still using it
        //

        ReferenceFileContextByTwo(pFileContext);

        //
        // Irp and IrpSp are used just as in NBF
        //

        Status = DispatchTable[TmpIndex](
                    pIrp,
                    pFileContext,
                    (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer,
                    pIrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    pIrpSp->Parameters.DeviceIoControl.OutputBufferLength
                    );

        //
        // ensure the function returned with the correct IRQL
        //

        ASSUME_IRQL(DISPATCH_LEVEL);

        //
        // the following error codes are valid:
        //
        //  STATUS_PENDING
        //      The request has been accepted
        //      The driver will complete the request asynchronously
        //      The output CCB should contain 0xFF in its status field (unless
        //      already completed)
        //
        //  STATUS_SUCCESS
        //      The request has successfully completed synchronously
        //      The output CCB should contain 0x00 in its status field
        //
        //  0x6001 - 0x6069
        //  0x6080 - 0x6081
        //  0x60A1 - 0x60A3
        //  0x60C0 - 0x60CB
        //  0x60FF
        //      The request has failed with a DLC-specific error
        //      The error code is converted to a DLC status code (-0x6000) and
        //      the output CCB status field is set to the DLC status code
        //      No asynchronous completion will be taken for this request
        //

        if (Status != STATUS_PENDING) {

            DLC_TRACE('G');

            pIrpSp->Control &= ~SL_PENDING_RETURNED;

            if (Status != STATUS_SUCCESS) {

                PNT_DLC_PARMS pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

                if (Status >= DLC_STATUS_ERROR_BASE && Status < DLC_STATUS_MAX_ERROR) {
                    Status -= DLC_STATUS_ERROR_BASE;
                }

                //
                // RLF 04/20/94
                //
                // make sure the CCB has the correct value written to it on
                // output if we're not returning pending status
                //

                pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)Status;

                //
                // the CCB request has failed. Make sure the pNext field is reset
                //

                if ((pIrpSp->Parameters.DeviceIoControl.IoControlCode & 3) == METHOD_OUT_DIRECT) {

                    //
                    // the CCB address may actually be unaligned DOS CCB1
                    //

                    LLC_CCB UNALIGNED * pCcb;

                    pCcb = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, NormalPagePriority);
                    
                    if (pCcb) {
                        pCcb->pNext = NULL;
                    }
                    // Failure case. Don't override previous failure status.
                    // It is likely STATUS_INSUFFICIENT_RESOURCES.
                } else {
                    pDlcParms->Async.Ccb.pCcbAddress = NULL;
                }
            }

            if (ioControlCode != IOCTL_DLC_RESET) {

                //
                // DLC.RESET returns an immediate status and does not complete
                // asynchronously
                //

                DereferenceFileContextByTwo(pFileContext);
            } else {

                //
                // everything else that returns a non-pending status completes
                // asynchronously, which also causes the other reference count
                // to be removed
                //

                DereferenceFileContext(pFileContext);
            }

            LEAVE_DLC(pFileContext);

            RELEASE_DRIVER_LOCK();

            //
            // RLF 06/07/93
            //
            // if the request is DLC.RESET, the IRP will have already been
            // completed if we're here, so don't complete it again (else we'll
            // bugcheck)
            //

            if (ioControlCode != IOCTL_DLC_RESET) {
                DlcCompleteIoRequest(pIrp, FALSE);
            }

            return Status;

        } else {

            DLC_TRACE('H');

            //
            // Reallocate the buffer pool size, if a threshold has been exceeded
            //

            if (BufferPoolCheckThresholds(pFileContext->hBufferPool)) {

                ReferenceBufferPool(pFileContext);

                LEAVE_DLC(pFileContext);

#if DBG
                BufferPoolExpand(pFileContext, (PDLC_BUFFER_POOL)pFileContext->hBufferPool);
#else 
                BufferPoolExpand((PDLC_BUFFER_POOL)pFileContext->hBufferPool);
#endif

                ENTER_DLC(pFileContext);

                DereferenceBufferPool(pFileContext);
            }

            LEAVE_DLC(pFileContext);

            //
            // if this dereference causes the count to go to 0, the file context
            // will be destroyed. Implicitly we must be closing the adapter and
            // have received a close IRP for this to happen
            //

            DereferenceFileContext(pFileContext);

            RELEASE_DRIVER_LOCK();

            return STATUS_PENDING;
        }
    }
}


VOID
DlcCompleteIoRequest(
    IN PIRP pIrp,
    IN BOOLEAN InCancel
    )

/*++

Routine Description:

    This routine completes the given DLC IRP

Arguments:

    pIrp        - Pointer to the request packet representing the I/O request.
    InCancel    - TRUE if called on Irp cancel path

Return Value:

    None

--*/

{
    //
    // we are about to complete this IRP - remove the cancel routine. The check
    // stops us spinning forever if this function is called from within an IRP
    // cancellation
    //

    if (!InCancel) {
        SetIrpCancelRoutine(pIrp, FALSE);
    }

    //
    // unlock and free any MDLs we allocated
    //

    if (IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL
    && IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode <= IOCTL_DLC_TRANSMIT) {

        //
        // We enter here only if something has gone wrong in the main
        // function of an async operation => the status field and
        // next pointer will be updated synchronously.
        // On the other hand, all other async functions having no output
        // parameters except CCB status and next pointer are upated
        // by the normal code path.  They should just copy
        // back the pending status and next pointer pointing to CCB itself.
        // That should not affect anything, because the DLL will update
        // those fields, when we return synchronous status
        //

        PNT_DLC_PARMS pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

        if (pDlcParms->Async.Ccb.u.pMdl != NULL) {
            UnlockAndFreeMdl(pDlcParms->Async.Ccb.u.pMdl);
        }
    }
    IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);
}

VOID
LinkFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    )
{
    KeAcquireSpinLock(&FileContextsLock, &PreviousIrql);
    PushEntryList(&FileContexts, &pFileContext->List);
    KeReleaseSpinLock(&FileContextsLock, PreviousIrql);
}

PDLC_FILE_CONTEXT
UnlinkFileContext(
    IN PDLC_FILE_CONTEXT pFileContext
    )
{
    PSINGLE_LIST_ENTRY p, prev = (PSINGLE_LIST_ENTRY)&FileContexts;

    KeAcquireSpinLock(&FileContextsLock, &PreviousIrql);
    for (p = FileContexts.Next; p && p != (PSINGLE_LIST_ENTRY)pFileContext; ) {
        prev = p;
        p = p->Next;
    }
    if (p) {
        prev->Next = p->Next;
//    } else {
//
//#if DBG
//        DbgPrint("DLC.UnlinkFileContext: Error: FILE_CONTEXT @%08X not on list??\n",
//                pFileContext
//                );
//#endif
//
    }
    KeReleaseSpinLock(&FileContextsLock, PreviousIrql);

    return (PDLC_FILE_CONTEXT)p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcque.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcque.c

Abstract:

    This module provides primitives to manage the dlc command and
    event queues.

    Contents:
        QueueDlcEvent
        MakeDlcEvent
        IsCommandOnList
        SearchAndRemoveCommand
        SearchAndRemoveAnyCommand
        SearchAndRemoveCommandByHandle
        SearchAndRemoveSpecificCommand
        QueueDlcCommand
        AbortCommand
        CancelDlcCommand
        PurgeDlcEventQueue
        PurgeDlcFlowControlQueue

Author:

    Antti Saarenheimo 29-Aug-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>
#include "dlcdebug.h"

/*++

Design notes about the DLC event and command queue management
-------------------------------------------------------------

In DLC API the READ command may be given before or after the actual
event has happened.  This means, that all DLC events of the READ command
must be queued and also the READ command must be queued to wait for
the set of events it was designated.

For each new DLC (READ) command the driver searches first the event queue
and then queues the command, if the desired event was not found.
The same thing is made also for the events:  the dlc command queue
is checked first and then the event is queued (if it was a read event)
or it is dropped away (if the event was not meant for READ and there
was no command waiting for it).

The events are implemented by the event masks.  The event is executed
if the result of bit-OR operation for the event masks in the command
and in the event is not zero.

All commands and receive events of a dlc station (direct, sap or link)
are returned as a DLC completion event when the station is closed.
The same operation is done also by the total reset or all sap stations
(and the only direct station).
A READ command may be used to read that command completion from
the event list.  The READ command may have been give before, in the
same time linked to the next CCB field of the close/reset command or
after the close/reset command has completed.
DirOpenAdapter command deletes all events (and commands) from the
event queue.  The received data and CCBs are not returned back, if
there is not given any READ command for that purpose.

(This has been fixed:
 There could be a minor incompatibility with IBM OS/2 DLC API,
 the NT DLC driver may not always complete a dlc command with
 the READ command linked to commmand's CCB,  if there is another
 matching DLC command pending)

    Here is the solution:

    Actually we could make a special
    READ command, that is chained to the very end of the command queue
    and that can be matched only with a CCB pointer of the completed
    DLC command.  We could modify the command aborting to support also
    this case, and there should be a special CCB input field in the
    NT READ for the completed command (do we also need to return
    the READ flag or command completion flag?).

----

We need at least these procedures:

MakeDlcEvent(
    pFileContext, Event, StationId, pOwnerObject, pEventInformation, SecInfo);

    - scans the command queues
    - saves the event if it can't find a matching command and
      if the command's event masks defines, that the event should be saved

QueueDlcCommand(
    pFileContext, Event, StationId, StationIdMask, pIrp, AbortHandle, pfComp );
    - scans the event queue for a matching event
    - saves the event if can't find a match

AbortCommand(
    pFileContext, Event, StationId, StationIdMask, AbortHandle, ppCcbLink );
    - aborts a command in the command queue

****** Subprocedures (used by the api functions)

PDLC_COMMAND
SearchPrevCommand(
    pQueue, EventMask, StationId, StationIdMask, SearchHandle, pPrevCommand
    - returns pointer to the previous element before the matching
      dlc command in a queue,

(Macro: SearchPrevEvent
            - searches and removes the given event from the event queue and
            returns its pointer)
--*/


VOID
QueueDlcEvent(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_PACKET pPacket
    )

/*++

Routine Description:

    The routine tries first to find a matching event in the command
    queues and queues the DLC event if it can't find anything and if
    the event belongs to the mask of the queued commands.
    There are two event queues, both having a mask for the checked
    events.  The queue is checked only if the event bits are found
    in the mask of the queue.

Arguments:

    pFileContext    - process specific adapter context
    pPacket         - Event packet

Return Value:

    None

--*/

{
    PDLC_COMMAND pDlcCommand;

    DIAG_FUNCTION("QueueDlcEvent");

    //
    // get search mask
    //

    pPacket->Event.Overlay.StationIdMask = (USHORT)((pPacket->Event.StationId == -1) ? 0 : -1);

    //
    // DLC commands can be completed with a special READ command,
    // that is linked to the CCB pointer of the command.
    // NT DLC must queue that special read command before the
    // command that it was linked.  We must check here
    // if there is a special READ command just for this command
    // completion.
    // **************  HACK-HACK-HACK   **************
    //     Close/Reset command completions use different
    //     EventInformation from the other command completions
    //     and they search the read command by themself =>
    //     we don't need to care about it.
    //     If SeconadryInfo == 0
    //     then this is a Close/Reset command completion
    //     and we don't search the special read command.
    //
    // **************  HACK-HACK-HACK   **************
    //

    if (!IsListEmpty(&pFileContext->CommandQueue)) {

        pDlcCommand = NULL;

        if (pPacket->Event.Event == DLC_COMMAND_COMPLETION
        && pPacket->Event.SecondaryInfo != 0) {

            pDlcCommand = SearchAndRemoveCommandByHandle(
                                &pFileContext->CommandQueue,
                                (ULONG)-1,              // mask for all events
                                (USHORT)DLC_IGNORE_STATION_ID,
                                (USHORT)DLC_STATION_MASK_SPECIFIC,
                                pPacket->Event.pEventInformation
                                );
        }

        if (pDlcCommand == NULL) {
            pDlcCommand = SearchAndRemoveCommand(&pFileContext->CommandQueue,
                                                 pPacket->Event.Event,
                                                 pPacket->Event.StationId,
                                                 pPacket->Event.Overlay.StationIdMask
                                                 );
        }

        if (pDlcCommand != NULL) {

            BOOLEAN DeallocateEvent;

            DeallocateEvent = pDlcCommand->Overlay.pfCompletionHandler(
                                pFileContext,
                                pPacket->Event.pOwnerObject,
                                pDlcCommand->pIrp,
                                (UINT)pPacket->Event.Event,
                                pPacket->Event.pEventInformation,
                                pPacket->Event.SecondaryInfo
                                );

            if (DeallocateEvent) {

                DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pPacket);

            }

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pDlcCommand);

            return;
        }
    }

    //
    // queue this event packet if it is to be picked up by a READ
    //

    if (pPacket->Event.Event & DLC_READ_FLAGS) {
        LlcInsertTailList(&pFileContext->EventQueue, pPacket);
    }
}


NTSTATUS
MakeDlcEvent(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN PDLC_OBJECT pDlcObject,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo,
    IN BOOLEAN FreeEventInfo
    )

/*++

Routine Description:

    The routine allocates a event packet, saves the event information
    into it and queues (or completes) the event packet.

Arguments:

    pFileContext        - process specific adapter context
    Event               - event code
    StationId           - station id the event is destined
    pDlcObject          - the optional dlc object used in the event completion
    pEventInformation   - generic event information
    SecondaryInfo       - optional misc. data
    FreeEventInfo       - TRUE if pEventInformation should be deallocated

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_NO_MEMORY

--*/

{
    PDLC_EVENT pDlcEvent;

    DIAG_FUNCTION("MakeDlcEvent");

    //
    // We couldn't find any matching commands for this event and
    // this event is a queued event => allocate a packet and
    // queue the event.
    //

    pDlcEvent = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pDlcEvent ==  NULL) {
        return DLC_STATUS_NO_MEMORY;
    }
    pDlcEvent->Event = Event;
    pDlcEvent->StationId = StationId;
    pDlcEvent->pOwnerObject = pDlcObject;
    pDlcEvent->SecondaryInfo = SecondaryInfo;
    pDlcEvent->pEventInformation = pEventInformation;
    pDlcEvent->bFreeEventInfo = FreeEventInfo;
    QueueDlcEvent(pFileContext, (PDLC_PACKET)pDlcEvent);
    return STATUS_SUCCESS;
}


PDLC_COMMAND
IsCommandOnList(
    IN PVOID RequestHandle,
    IN PLIST_ENTRY List
    )

/*++

Routine Description:

    Searches the command queue of a DLC file context for a 'request handle'
    which is the address (in user space) of a command CCB, such as a READ

    If RequestHandle is located, a pointer to the DLC_COMMAND containing
    it is returned, else NULL

    Note: Assumes that handles are not shared between processes (it looks
    as though the entire driver assumes this) and this function is called
    within the context of the process to which the searched handle belongs

Arguments:

    RequestHandle   - address of CCB to look for
    List            - address of a list of DLC_COMMAND structures

Return Value:

    PDLC_COMMAND
        Success - address of located DLC_COMMAND structure containing
                  RequestHandle (in AbortHandle field)
        Failure - NULL

--*/

{
    PLIST_ENTRY entry;

    if (!IsListEmpty(List)) {
        for (entry = List->Flink; entry != List; entry = entry->Flink) {
            if (((PDLC_COMMAND)entry)->AbortHandle == RequestHandle) {
                return (PDLC_COMMAND)entry;
            }
        }
    }
    return NULL;
}


PDLC_COMMAND
SearchAndRemoveCommand(
    IN PLIST_ENTRY pQueueBase,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask
    )

/*++

Routine Description:

    The routine searches and removes the given command or event from
    command, event or receive command queue.
    The station id, its mask, event mask and search handle are used
    to define the search.

Arguments:

    pQueueBase - address of queue's base pointer

    Event - event code

    StationId - station id of this command

    StationIdMask - station id mask for the event station id

    pSearchHandle - additional search key,  this is actually an
        orginal user mode ccb pointer (vdm or Windows/Nt)

Return Value:

    PDLC_COMMAND

--*/

{
    PDLC_COMMAND pCmd;

    DIAG_FUNCTION("SearchAndRemoveCommand");

    //
    // Events and commands are both saved to entry lists and this
    // procedure is used to search a macthing event for a command
    // or vice verse.  Commands has a masks, that may defines
    // the search for a specific station id, all stations on a sap
    // or all station ids.
    // the newest element in the list and the next element is the oldest
    // The commands are always scanned from the oldest to the newest.
    //

    if (!IsListEmpty(pQueueBase)) {

        for (pCmd = (PDLC_COMMAND)pQueueBase->Flink;
             pCmd != (PDLC_COMMAND)pQueueBase;
             pCmd = (PDLC_COMMAND)pCmd->LlcPacket.pNext) {

            if ((pCmd->Event & Event)
            && (pCmd->StationId & pCmd->StationIdMask & StationIdMask)
                == (StationId & pCmd->StationIdMask & StationIdMask)) {

                LlcRemoveEntryList(pCmd);
                return pCmd;
            }
        }
    }
    return NULL;
}


PDLC_COMMAND
SearchAndRemoveAnyCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG EventMask,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID pSearchHandle
    )

/*++

Routine Description:

    The routine searches a dlc command from the normal read command queue
    for events and the special receive command queue.

Arguments:

    pQueueBase - address of queue's base pointer

    Event - event code

    StationId - station id of this command

    StationIdMask - station id mask for the event station id

    pSearchHandle - additional search key,  this is actually an
        orginal user mode ccb pointer (vdm or Windows/Nt)

Return Value:

    PDLC_COMMAND

--*/

{
    PDLC_COMMAND pDlcCommand;

    DIAG_FUNCTION("SearchAndRemoveAnyCommand");

    pDlcCommand = SearchAndRemoveCommandByHandle(&pFileContext->CommandQueue,
                                                 EventMask,
                                                 StationId,
                                                 StationIdMask,
                                                 pSearchHandle
                                                 );
    if (pDlcCommand == NULL) {
        pDlcCommand = SearchAndRemoveCommandByHandle(&pFileContext->ReceiveQueue,
                                                     EventMask,
                                                     StationId,
                                                     StationIdMask,
                                                     pSearchHandle
                                                     );
    }
    return pDlcCommand;
}


PDLC_COMMAND
SearchAndRemoveCommandByHandle(
    IN PLIST_ENTRY pQueueBase,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID pSearchHandle
    )

/*++

Routine Description:

    The routine searches and removes the given command or event from
    command, event or receive command queue using a search handle.
    This search routine is tailored to find the commands belonging
    only to the deleted object (this searches only the exact macthes).
    The other search routine supports wild cards only for the read
    commands and thus it cannot be used here.  We just want to remove
    only those commands, that read events from the deleted object but not
    from elsewhere.

Arguments:

    pQueueBase      - address of queue's base pointer
    Event           - event code or mask for the searched events
    StationId       - station id of this command
    StationIdMask   - station id mask for the event station id
    pSearchHandle   - additional search key,  this is actually an orginal user
                      mode ccb pointer (vdm or Windows/Nt)

Return Value:

    PDLC_COMMAND

--*/

{
    PDLC_COMMAND pCmd;

    DIAG_FUNCTION("SearchAndRemoveCommandByHandle");

    if (!IsListEmpty(pQueueBase)) {

        for (pCmd = (PDLC_COMMAND)pQueueBase->Flink;
             pCmd != (PDLC_COMMAND)pQueueBase;
             pCmd = (PDLC_COMMAND)pCmd->LlcPacket.pNext) {

            //
            // The event mask match always!
            //

            if ((pCmd->Event & Event)
            && (pSearchHandle == DLC_MATCH_ANY_COMMAND
            || pSearchHandle == pCmd->AbortHandle
            || (pCmd->StationId & StationIdMask) == (StationId & StationIdMask))) {

                LlcRemoveEntryList(pCmd);
                return pCmd;
            }
        }
    }
    return NULL;
}


PDLC_COMMAND
SearchAndRemoveSpecificCommand(
    IN PLIST_ENTRY pQueueBase,
    IN PVOID pSearchHandle
    )

/*++

Routine Description:

    Searches for a DLC_COMMAND structure having a specific search handle (ie
    abort handle or application CCB address). If found, removes the DLC_COMMAND
    from the queue, else returns NULL

Arguments:

    pQueueBase      - address of queue's base pointer
    pSearchHandle   - additional search key,  this is actually an orginal user
                      mode ccb pointer (vdm or Windows/Nt)

Return Value:

    PDLC_COMMAND

--*/

{
    DIAG_FUNCTION("SearchAndRemoveSpecificCommand");

    if (!IsListEmpty(pQueueBase)) {

        PDLC_COMMAND pCmd;

        for (pCmd = (PDLC_COMMAND)pQueueBase->Flink;
             pCmd != (PDLC_COMMAND)pQueueBase;
             pCmd = (PDLC_COMMAND)pCmd->LlcPacket.pNext) {

            //
            // The event mask match always!
            //

            if (pSearchHandle == pCmd->AbortHandle) {
                LlcRemoveEntryList(pCmd);
                return pCmd;
            }
        }
    }
    return NULL;
}


NTSTATUS
QueueDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG Event,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PIRP pIrp,
    IN PVOID AbortHandle,
    IN PFCOMPLETION_HANDLER pfCompletionHandler
    )

/*++

Routine Description:

    The routine tries first to find a matching event in the event
    queue and  queues the DLC command if it can't find an event.

Arguments:

    pFileContext        - process specific adapter context
    Event               - event code
    StationId           - station id the event is destined
    StationIdMask       - mask used to define the destination station group
    pIrp                - the i/o request packet of the related DLC command,
                          link to the input and output parameters.
    AbortHandle         - handle used to cancel the command from the queue
    pfCompletionHandler - completion handler of the command, called when a
                          matching event has been found.

Return Value:

    NTSTATUS

--*/

{
    PDLC_COMMAND pDlcCommand;
    PDLC_EVENT pEvent;

    DIAG_FUNCTION("QueueDlcCommand");

    pEvent = SearchAndRemoveEvent(&pFileContext->EventQueue,
                                  Event,
                                  StationId,
                                  StationIdMask
                                  );
    if (pEvent != NULL) {

        BOOLEAN DeallocateEvent;

        DeallocateEvent = pfCompletionHandler(pFileContext,
                                              pEvent->pOwnerObject,
                                              pIrp,
                                              (UINT)pEvent->Event,
                                              pEvent->pEventInformation,
                                              pEvent->SecondaryInfo
                                              );
        if (DeallocateEvent) {

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pEvent);

        }
    } else {

        //
        // We couldn't find any matching command for this event and
        // this event is a queued event => allocate a packet and
        // queue the event.
        //

        pDlcCommand = (PDLC_COMMAND)ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pDlcCommand ==  NULL) {
            return DLC_STATUS_NO_MEMORY;
        }
        pDlcCommand->Event = Event;
        pDlcCommand->pIrp = pIrp;
        pDlcCommand->StationId = StationId;
        pDlcCommand->StationIdMask = StationIdMask;
        pDlcCommand->AbortHandle = AbortHandle;
        pDlcCommand->Overlay.pfCompletionHandler = pfCompletionHandler;

        //
        // The permanent receive commands, that do not actually read
        // anuting (just enable the data receiving) are put to another
        // queue to speed up the search of the read commands.
        //

        if (Event == LLC_RECEIVE_COMMAND_FLAG) {
            LlcInsertTailList(&pFileContext->ReceiveQueue, pDlcCommand);
        } else {
            LlcInsertTailList(&pFileContext->CommandQueue, pDlcCommand);
        }

        //
        // Asynchronous commands returns ALWAYS the pending status.
        //
    }
    return STATUS_PENDING;
}


NTSTATUS
AbortCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    IN USHORT StationIdMask,
    IN PVOID AbortHandle,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus,
    IN BOOLEAN SuppressCommandCompletion
    )

/*++

Routine Description:

    The routine searches and cancels a command from a command queue.
    The commands must always belong to the defined DLC object.
    A NULL value in abort handle selects all matching commands
    found in the queue.

Arguments:

    pFileContext                -
    StationId                   - station id the searched command is destined for
    StationIdMask               - station id mask used in the search
    AbortHandle                 - handle used to cancel the command from the
                                  queue. The whole command queue will be scanned
                                  if this handle is NULL
    ppCcbLink                   - the canceled commands are linked by their next
                                  CCB pointer fieldsr. The caller must provide
                                  the next CCB address in this parameter
                                  (usually *ppCcbLink == NULL) and the function
                                  will return the address of the last cancelled
                                  CCB field.
    CancelStatus                - Status for the command to be canceled
    SuppressCommandCompletion   - the flag is set, if the normal command
                                  completion is suppressed.

Return Value:

     - no mathing command was found
    STATUS_SUCCESS - the command was canceled

--*/

{
    PDLC_COMMAND pDlcCommand;

    DIAG_FUNCTION("AbortCommand");

    pDlcCommand = SearchAndRemoveAnyCommand(pFileContext,
                                            (ULONG)(-1), // search all commands
                                            StationId,
                                            StationIdMask,
                                            AbortHandle
                                            );
    if (pDlcCommand == NULL && AbortHandle == DLC_MATCH_ANY_COMMAND) {
        pDlcCommand = pFileContext->pTimerQueue;
        if (pDlcCommand != NULL) {
            pFileContext->pTimerQueue = (PDLC_COMMAND)pDlcCommand->LlcPacket.pNext;
        }
    }
    if (pDlcCommand != NULL) {
        CancelDlcCommand(pFileContext,
                         pDlcCommand,
                         ppCcbLink,
                         CancelStatus,
                         SuppressCommandCompletion
                         );
        return STATUS_SUCCESS;
    } else {
        return DLC_STATUS_INVALID_CCB_POINTER;
    }
}


VOID
CancelDlcCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_COMMAND pDlcCommand,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus,
    IN BOOLEAN SuppressCommandCompletion
    )

/*++

Routine Description:

    The cancels and optionally completes the given DLC command. Called when one
    DLC I/O request is used to kill another (e.g. READ.CANCEL, DIR.TIMER.CANCEL)

Arguments:

    pFileContext                -
    pDlcCommand                 -
    ppCcbLink                   - the canceled commands are linked by their next
                                  CCB pointer fields. The caller must provide
                                  the next CCB address in this parameter
                                  (usually *ppCcbLink == NULL) and the function
                                  will return the address of the last cancelled
                                  CCB field
    CancelStatus                - Status for the command to be canceled
    SuppressCommandCompletion   - if set, normal command completion is suppressed

Return Value:

    None

--*/

{
    PVOID pOldCcbLink;

    DIAG_FUNCTION("CancelDlcCommand");

    //
    // We must return the current CCB link to be linked to the next cancelled
    // CCB command (or to the CCB pointer of cancelling command). But first
    // save the previous CCB link before we read a new one
    //

    pOldCcbLink = *ppCcbLink;
    *ppCcbLink = ((PNT_DLC_PARMS)pDlcCommand->pIrp->AssociatedIrp.SystemBuffer)->Async.Ccb.pCcbAddress;

    //
    // Check if we must suppress any kind of command completion indications to
    // the applications. I/O system should not care, if its event handle is
    // removed
    //

    if (SuppressCommandCompletion) {
        pDlcCommand->pIrp->UserEvent = NULL;
    }
    CompleteAsyncCommand(pFileContext, CancelStatus, pDlcCommand->pIrp, pOldCcbLink, FALSE);

    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pDlcCommand);

}


VOID
PurgeDlcEventQueue(
    IN PDLC_FILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Deletes all events from a FILE_CONTEXT event queue. Called when the
    FILE_CONTEXT is being deleted and before we deallocate the packet pool from
    which the events were allocated

Arguments:

    pFileContext    - pointer to FILE_CONTEXT owning the queue

Return Value:

    None.

--*/

{
    PDLC_EVENT p;

    while (!IsListEmpty(&pFileContext->EventQueue)) {
        p = (PDLC_EVENT)RemoveHeadList(&pFileContext->EventQueue);
        if (p->bFreeEventInfo && p->pEventInformation) {

#if DBG
            DbgPrint("PurgeDlcEventQueue: deallocating pEventInformation: %x\n", p->pEventInformation);
#endif

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, p->pEventInformation);

        }

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, p);

    }
}


VOID
PurgeDlcFlowControlQueue(
    IN PDLC_FILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Deletes all packets from the flow control queue. Called when the FILE_CONTEXT
    is being deleted and before we deallocate the packet pool from which flow
    control packets were allocated

Arguments:

    pFileContext    - pointer to FILE_CONTEXT owning the queue

Return Value:

    None.

--*/

{
    PDLC_RESET_LOCAL_BUSY_CMD p;

    while (!IsListEmpty(&pFileContext->FlowControlQueue)) {
        p = (PDLC_RESET_LOCAL_BUSY_CMD)RemoveHeadList(&pFileContext->FlowControlQueue);

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, p);

    }
}


/*
//
//  Internal consistency check to hunt a bougus event in the event queue.
//
//extern BOOLEAN EventCheckDisabled;
//
int
CheckEventQueue(
    PDLC_FILE_CONTEXT   pFileContext
    )
{
    static PDLC_FILE_CONTEXT   pOldFileContext = NULL;

    if (pFileContext == NULL)
    {
        pFileContext = pOldFileContext;
    }
    else
    {
        pOldFileContext = pFileContext;
    }
    if (pFileContext == NULL)
        return 0;

    if (!IsListEmpty( &pFileContext->EventQueue ) &&
        pFileContext->EventQueue.Flink == pFileContext->EventQueue.Blink &&
        &pFileContext->EventQueue != pFileContext->EventQueue.Flink->Flink)
    {
        FooDebugBreak();
    }
    return 0;
}

int
FooDebugBreak()
{
    INT i;

    return i++;
}
*/
//    PDLC_EVENT  pEvent;
//
//    if (EventCheckDisabled || pFileContext->AdapterNumber != 0 ||
//        pFileContext->EventQueue == NULL)
//        return;
//
//    pEvent = (PDLC_EVENT)pFileContext->pEventQueue->LlcPacket.pNext;
//    for (;;)
//    {
//        if (pEvent->Event == LLC_STATUS_CHANGE &&
//            pEvent->pOwnerObject == NULL)
//            DebugBreak();
//        if (pEvent == pFileContext->pEventQueue)
//            break;
//        pEvent = (PDLC_EVENT)pEvent->LlcPacket.pNext;
//    }
//}
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcreg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcreg.h

Abstract:

    Defines, Structures, Typedefs, Macros, Externs and Prototypes for dlcreg.c

Author:

    Richard L Firth (rfirth) 31-Mar-1993

Revision History:

    30-Mar-1993 rfirth
        created

    04-May-1994 rfirth
        Exposed GetAdapterParameters

--*/

#ifndef _DLCREG_
#define _DLCREG_

//
// manifests
//

#define PARAMETER_AS_SPECIFIED      ((ULONG)-1)
#define PARAMETER_IS_BOOLEAN        1
#define PARAMETER_IS_UCHAR          2

//
// types
//

//
// REGISTRY_PARAMETER_DESCRIPTOR - structure used to get values from registry
// entries. Maintains information about a registry entry and supplies a default
// value should the registry entry not be available
//

typedef struct {
    ULONG   Type;       // expected type
    ULONG   RealType;   // eg. PARAMETER_BOOLEAN
    PVOID   Value;      // default value if REG_DWORD, or pointer to default value
    ULONG   Length;     // IN: expected length of variable; OUT: actual length
    PVOID   Variable;   // pointer to variable to update from registry
    ULONG   LowerLimit; // lower limit for REG_DWORD values
    ULONG   UpperLimit; // upper limit for REG_DWORD values
} REGISTRY_PARAMETER_DESCRIPTOR, *PREGISTRY_PARAMETER_DESCRIPTOR;

//
// DLC_REGISTRY_PARAMETER - describes an entry in the DLC\Parameters\<adapter>
// section. Supplies the name of the parameter and its default value
//

typedef struct {
    PWSTR ParameterName;
    PVOID DefaultValue;
    REGISTRY_PARAMETER_DESCRIPTOR Descriptor;
} DLC_REGISTRY_PARAMETER, *PDLC_REGISTRY_PARAMETER;

//
// ADAPTER_CONFIGURATION_INFO - for each adapter that DLC can talk to, there is
// potentially the following configuration information which can be stored in
// the DLC\Parameters\<adapter_name> key. The values are not necessarily stored
// in the format in which they are used internally
//

typedef struct {

    //
    // SwapAddressBits - when talking over Ethernet, defines whether to swap the
    // outgoing destination address bits and incoming source address bits
    //

    BOOLEAN SwapAddressBits;

    //
    // UseDix - if the Ethernet type in the DIR.OPEN.ADAPTER is set to default,
    // then we consult this flag to determine whether to send DIX or 802.3
    // format Ethernet frames. The default is 802.3 (ie UseDix = 0)
    //

    BOOLEAN UseDix;

    //
    // T1TickOne, T2TickOne, TiTickOne, T1TickTwo, T2TickTwo, TiTickTwo - timer
    // tick values in 40mSec increments. Contained in LLC_TICKS structure
    //

    LLC_TICKS TimerTicks;

    //
    // UseEthernetFrameSize - if set for a non-TR card then we use the value
    // reported by ethernet cards for the maximum frame size, else we query
    // the MAC for the maximum supported frame size.
    // Bridging is the mother of this invention: we need some way to influence
    // DLC's maximum frame size when talking over non-Token Ring nets - FDDI
    // and Ethernet in this case.
    //

    BOOLEAN UseEthernetFrameSize;

} ADAPTER_CONFIGURATION_INFO, *PADAPTER_CONFIGURATION_INFO;

//
// prototypes
//

VOID
DlcRegistryInitialization(
    IN PUNICODE_STRING RegistryPath
    );

VOID
DlcRegistryTermination(
    VOID
    );

VOID
LoadDlcConfiguration(
    VOID
    );

VOID
LoadAdapterConfiguration(
    IN PUNICODE_STRING AdapterName,
    OUT PADAPTER_CONFIGURATION_INFO ConfigInfo
    );

NTSTATUS
GetAdapterParameters(
    IN PUNICODE_STRING AdapterName,
    IN PDLC_REGISTRY_PARAMETER Parameters,
    IN ULONG NumberOfParameters,
    IN BOOLEAN SetOnFail
    );

#ifdef NDIS40
NTSTATUS
GetAdapterWaitTimeout(PULONG pulWait);
#endif // NDIS40

#endif // _DLCREG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcopen.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcopen.c

Abstract:

    This module implements all open and close operations for DLC objects

    Contents:
        DlcOpenSap
        DirOpenDirect
        DlcOpenLinkStation
        InitializeLinkStation
        DlcCloseStation
        CloseAllStations
        CloseAnyStation
        CloseStation
        CompleteCloseStation
        CompleteCloseReset
        CleanUpEvents
        SearchReadCommandForClose
        CompleteLlcObjectClose
        DecrementCloseCounters
        CompleteDirectOutIrp

Author:

    Antti Saarenheimo 29-Aug-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>
#include "dlcdebug.h"
#include <smbgtpt.h>


NTSTATUS
DlcOpenSap(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure implements DLC.OPEN.SAP function in DLC API.
    This implements DLC.OPEN.SAP.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  - not used

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    PDLC_OBJECT pDlcObject;
    UINT SapIndex = (pDlcParms->DlcOpenSap.SapValue >> 1);
    UINT Status;
    USHORT XidHandlingOption;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    DIAG_FUNCTION("DlcOpenSap");

    //
    //  The group saps do not have any open/close context in NT DLC,
    //  but there is an group sap object on data link level.
    //  The individual sap is registered to all its group saps
    //  and llc level automatically routes all packets sent to
    //  a group sap to all its registered members.  The groups saps
    //  are actually always open and they disappear automatically,
    //  when there are no references to them any more.
    //

    if (!(pDlcParms->DlcOpenSap.OptionsPriority &
          (LLC_INDIVIDUAL_SAP | LLC_MEMBER_OF_GROUP_SAP | LLC_GROUP_SAP))) {

        //
        //  Richard!!!!
        //  IBM spec says, that one of those bits must be set, on the
        //  other hand, Mike Allmond said, that IBM DLC accepts these
        //  command.  I don't belive it before a DOS application
        //  tries to open dlc sap with all bits reset, then you
        //  must accept it as a undocumented feature of IBM DLC.
        //

        return DLC_STATUS_INVALID_OPTION;
    } else if (!(pDlcParms->DlcOpenSap.OptionsPriority &
             (LLC_INDIVIDUAL_SAP | LLC_MEMBER_OF_GROUP_SAP))) {

        //
        //  It was a group sap, they do not have an open context,
        //  but their llc objects are created when they are referenced.
        //

        pDlcParms->DlcOpenSap.StationId = (USHORT)(((USHORT)pDlcParms->DlcOpenSap.SapValue << 8) | 0x0100);
        return STATUS_SUCCESS;
    }

    //
    //  The lowest byte in sap value is undefine, we must reset
    //  it to make it a valid individual DLC SAP number.
    //

    pDlcParms->DlcOpenSap.SapValue &= 0xfe;

    //
    //  Check the double open, the slot must be empty
    //

    if (SapIndex == 0
    || SapIndex >= MAX_SAP_STATIONS
    || pFileContext->SapStationTable[SapIndex] != NULL) {
        return DLC_STATUS_INVALID_SAP_VALUE;
    }

    //
    //  All DLC objects have the same size and they are allocated from
    //  the packet pool (the normal binary buddy allocation has an average
    //  33% overhead).
    //

    pDlcObject = (PDLC_OBJECT)ALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool);

    if (pDlcObject) {
        pFileContext->SapStationTable[SapIndex] = pDlcObject;
    } else {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    //  We should do here some security checking using the security
    //  descriptor of the current file context, but we do
    //  not yet care about those things (nbf must implement
    //  them first!)
    //

    pDlcObject->pFileContext = pFileContext;
    pDlcObject->Type = DLC_SAP_OBJECT;
    pDlcParms->DlcOpenSap.StationId = pDlcObject->StationId = (USHORT)pDlcParms->DlcOpenSap.SapValue << 8;
    pDlcObject->u.Sap.OptionsPriority = pDlcParms->DlcOpenSap.OptionsPriority;
    pDlcObject->u.Sap.DlcStatusFlag = pDlcParms->DlcOpenSap.DlcStatusFlag;
    pDlcObject->u.Sap.UserStatusValue = pDlcParms->DlcOpenSap.UserStatusValue;
    pDlcObject->u.Sap.MaxStationCount = pDlcParms->DlcOpenSap.StationCount;
    pDlcParms->DlcOpenSap.AvailableStations = pFileContext->LinkStationCount;

    XidHandlingOption = 0;
    if (!(pDlcObject->u.Sap.OptionsPriority & (UCHAR)XID_HANDLING_BIT)) {
        XidHandlingOption = LLC_HANDLE_XID_COMMANDS;
    }
    Status = LlcOpenSap(pFileContext->pBindingContext,
                        pDlcObject,
                        (UINT)pDlcParms->DlcOpenSap.SapValue,
                        XidHandlingOption,
                        &pDlcObject->hLlcObject
                        );

    if (Status == STATUS_SUCCESS) {

        //
        //  We will save the access priority bits with the other
        //  link station parameters using LlcSetInformation.
        //

        pDlcParms->DlcOpenSap.LinkParameters.TokenRingAccessPriority = pDlcParms->DlcOpenSap.OptionsPriority & (UCHAR)0xE0;

        //
        //  We know, that there will be no call backs from this
        //  set information function => we don't need to release spin
        //  locks.
        //

        LEAVE_DLC(pFileContext);

        Status = LlcSetInformation(pDlcObject->hLlcObject,
                                   DLC_INFO_CLASS_LINK_STATION,
                                   (PLLC_SET_INFO_BUFFER)&(pDlcParms->DlcOpenSap.LinkParameters),
                                   sizeof(DLC_LINK_PARAMETERS)
                                   );

        ENTER_DLC(pFileContext);
    }
    if (Status == STATUS_SUCCESS) {

        //
        //  The global group SAP (0xFF) is opened for all sap
        //  stations of dlc api.
        //  BUG-BUG-BUG: How incompatible XID handling options are
        //      handled in the case of the global group sap.
        //

        Status = LlcOpenSap(pFileContext->pBindingContext,
                            pDlcObject,
                            0xff,
                            LLC_HANDLE_XID_COMMANDS,
                            &pDlcObject->u.Sap.GlobalGroupSapHandle
                            );
    }
    if (Status == STATUS_SUCCESS) {

        //
        //  Each SAP station 'allocates' a fixed number link stations.
        //  This compatibility feature was implemented, because
        //  some dlc apps might assume to be have only a fixed number
        //  of link stations.  We can't do the check earlier, because
        //  another DlcOpenSap command would have been able to allocate
        //  the link stations before this moment.
        //

        if (pDlcParms->DlcOpenSap.StationCount > pFileContext->LinkStationCount) {
            Status = DLC_STATUS_INADEQUATE_LINKS;
        } else {
            pFileContext->LinkStationCount -= pDlcObject->u.Sap.MaxStationCount;
            pDlcObject->State = DLC_OBJECT_OPEN;
            pFileContext->DlcObjectCount++;

            //
            //  The flag and these reference counters keeps the llc object
            //  alive, when we are working on it.  We decerement
            //  the llc object reference count when we don't have any more
            //  synchronous commands going on.  Zero llc reference count
            //  on Dlc object dereferences the llc object.
            //

            pDlcObject->LlcObjectExists = TRUE;
            ReferenceLlcObject(pDlcObject);
            LlcReferenceObject(pDlcObject->hLlcObject);
            return STATUS_SUCCESS;
        }
    }

    //
    // error handling
    //

    pDlcParms->DlcOpenSap.AvailableStations = pFileContext->LinkStationCount;
    if (pDlcObject->hLlcObject != NULL) {
        pDlcObject->PendingLlcRequests++;

        LEAVE_DLC(pFileContext);

        LlcCloseStation(pDlcObject->hLlcObject, NULL);
        if (pDlcObject->u.Sap.GlobalGroupSapHandle != NULL) {
            LlcCloseStation(pDlcObject->u.Sap.GlobalGroupSapHandle, NULL);
        }

        ENTER_DLC(pFileContext);
    }

#if LLC_DBG
    pDlcObject->pLinkStationList = NULL;
#endif

    DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pDlcObject);

    pFileContext->SapStationTable[SapIndex] = NULL;
    return Status;
}


NTSTATUS
DirOpenDirect(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure opens the only direct station for a process specific adapter
    context. This implements DIR.OPEN.STATION.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  - the length of output parameters

Return Value:

    NTSTATUS:
            STATUS_SUCCESS
            DLC_STATUS_NO_MEMORY
            DLC_STATUS_DIRECT_STATIONS_NOT_AVAILABLE
--*/

{
    PDLC_OBJECT pDlcObject;
    UINT Status;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    //  Check the double open, the slot must be empty
    //

    if (pFileContext->SapStationTable[0] != NULL) {
        return DLC_STATUS_DIRECT_STATIONS_NOT_AVAILABLE;
    }

    //
    //  All DLC objects are allocated from the same size
    //  optimized pool (the std binary buddy has ave. 33% overhead).
    //

    pDlcObject = pFileContext->SapStationTable[0] = (PDLC_OBJECT)ALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool);

    if (pDlcObject == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    //  We should do here some security checking, but we do
    //  not care about those things now (nbf must implement
    //  them first!)
    //

    pDlcObject->pFileContext = pFileContext;
    pDlcObject->Type = DLC_DIRECT_OBJECT;
    pDlcObject->StationId = 0;
    pDlcObject->State = DLC_OBJECT_OPEN;

    LEAVE_DLC(pFileContext);

    if (pDlcParms->DirOpenDirect.usEthernetType > 1500) {

        //
        //  Open a dix station to receive the defined frames
        //

        Status = LlcOpenDixStation(pFileContext->pBindingContext,
                                   (PVOID)pDlcObject,
                                   pDlcParms->DirOpenDirect.usEthernetType,
                                   &pDlcObject->hLlcObject
                                   );

        pDlcObject->u.Direct.ProtocolTypeMask = pDlcParms->DirOpenDirect.ulProtocolTypeMask;
        pDlcObject->u.Direct.ProtocolTypeMatch = pDlcParms->DirOpenDirect.ulProtocolTypeMatch;
        pDlcObject->u.Direct.ProtocolTypeOffset = pDlcParms->DirOpenDirect.usProtocolTypeOffset;
    } else {

        //
        //  Open a dix station to receive the defined frames
        //

        Status = LlcOpenDirectStation(pFileContext->pBindingContext,
                                      (PVOID)pDlcObject,
                                      0,
                                      &pDlcObject->hLlcObject
                                      );
    }

    ENTER_DLC(pFileContext);

    if (Status == STATUS_SUCCESS) {

        //
        //  The flag and these reference counters keeps the llc object
        //  alive, when we are working on it.  We decerement
        //  the llc object reference count when we don't have any more
        //  synchronous commands going on.  Zero llc reference count
        //  on Dlc object dereferences the llc object.
        //

        pDlcObject->LlcObjectExists = TRUE;
        ReferenceLlcObject(pDlcObject);
        LlcReferenceObject(pDlcObject->hLlcObject);

        //
        //  We will receive ALL mac frame types if any of the
        //  mac bits has been set in the open options.
        //

        if (pDlcParms->DirOpenDirect.usOpenOptions & LLC_DIRECT_OPTIONS_ALL_MACS) {
            pDlcObject->u.Direct.OpenOptions = (USHORT)(-1);
        } else {
            pDlcObject->u.Direct.OpenOptions = (USHORT)~DLC_RCV_MAC_FRAMES;
        }
        pFileContext->DlcObjectCount++;
    } else {
        pFileContext->SapStationTable[0] = NULL;

#if LLC_DBG
        pDlcObject->pLinkStationList = NULL;
#endif

        DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pDlcObject);

    }
    return Status;
}


NTSTATUS
DlcOpenLinkStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure opens a new link station. DlcConnect is still needed to
    create the actual connection to the remote node.
    This implements DLC.OPEN.STATION

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS:
            STATUS_SUCCESS
            DLC_STATUS_NO_MEMORY
            DLC_STATUS_INADEQUATE_LINKS
--*/

{
    NTSTATUS    Status;
    PDLC_OBJECT pDlcObject;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // The local SAP must not be the NULL SAP or a group SAP!
    //

    if ((pDlcParms->DlcOpenStation.LinkStationId & 0x100) != 0
    || pDlcParms->DlcOpenStation.LinkStationId == 0) {
        return DLC_STATUS_INVALID_SAP_VALUE;
    }

    //
    // This must be a SAP station!
    //

    Status = GetSapStation(pFileContext,
                           pDlcParms->DlcOpenStation.LinkStationId,
                           &pDlcObject
                           );
    if (Status == STATUS_SUCCESS) {

        //
        // Check the remote destination address, the broadcast bit
        // must not be set in that address.  The remote SAP must not
        // either be a group or nul SAP
        //

        if ((pDlcParms->DlcOpenStation.aRemoteNodeAddress[0] & 0x80) != 0
        || pDlcParms->DlcOpenStation.RemoteSap == 0
        || (pDlcParms->DlcOpenStation.RemoteSap & 1) != 0) {
            return DLC_STATUS_INVALID_REMOTE_ADDRESS;
        }
        Status = InitializeLinkStation(pFileContext,
                                       pDlcObject,
                                       pDlcParms,
                                       NULL,    // this is a local connect, no LLC link handle
                                       &pDlcObject
                                       );

        //
        // Set also the link station parameters,  all nul
        // parameters are discarded by the data link.
        //

        if (Status == STATUS_SUCCESS) {
            LlcSetInformation(
                pDlcObject->hLlcObject,
                DLC_INFO_CLASS_LINK_STATION,
                (PLLC_SET_INFO_BUFFER)&pDlcParms->DlcOpenStation.LinkParameters,
                sizeof(DLC_LINK_PARAMETERS)
                );
        }
    }
    return Status;
}


NTSTATUS
InitializeLinkStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT  pSap,
    IN PNT_DLC_PARMS pDlcParms OPTIONAL,
    IN PVOID LlcLinkHandle OPTIONAL,
    OUT PDLC_OBJECT *ppLinkStation
    )

/*++

Routine Description:

    This procedure allocates and initializes the link station.

Arguments:

    pFileContext    - DLC adapter context
    pSap            - Sap object of the new link station
    pDlcParms       - the current parameter block
    LlcHandle       - Handle
    ppLinkStation   - the new created link station

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                  DLC_STATUS_INADEQUATE_LINKS

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pLinkStation;
    UINT LinkIndex;

    //
    // There is allocated a limited number link stations for
    // this SAP, check if there is available link stations
    //

    if (pSap->u.Sap.LinkStationCount >= pSap->u.Sap.MaxStationCount) {
        return DLC_STATUS_INADEQUATE_LINKS;
    }

    //
    // Search the first free link station id
    //

    for (LinkIndex = 0;
        LinkIndex < MAX_LINK_STATIONS
        && pFileContext->LinkStationTable[LinkIndex] != NULL;
        LinkIndex++) {
        ; // NOP
    }

//#ifdef DEBUG_CHK
//    //
//    //  Link counters are out of sync ????
//    //
//    if (LinkIndex == MAX_LINK_STATIONS)
//    {
//        DEBUG_ERROR("DLC: Linkstation counters are out of sync!");
//        return DLC_STATUS_INADEQUATE_LINKS;
//    }
//#endif

    //
    // Allocate the link station and initialize the station id field
    //

    pLinkStation = ALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool);

    if (pLinkStation == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    // Each link station has a preallocated event packet to receive
    // all DLC Status indications from the data link.  There can
    // be several status indications set in the same status word.
    // The status is reset when its read from the event queue.
    //

    pLinkStation->u.Link.pStatusEvent = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pLinkStation->u.Link.pStatusEvent == NULL) {

#if LLC_DBG
        pLinkStation->pLinkStationList = NULL;
#endif

        DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pLinkStation);

        return DLC_STATUS_NO_MEMORY;
    }
    *ppLinkStation = pLinkStation;
    pFileContext->LinkStationTable[LinkIndex] = pLinkStation;
    pLinkStation->StationId = pSap->StationId | (USHORT)(LinkIndex + 1);
    pLinkStation->Type = DLC_LINK_OBJECT;
    pLinkStation->State = DLC_OBJECT_OPEN;
    pLinkStation->pFileContext = pFileContext;
    pSap->u.Sap.LinkStationCount++;

    //
    // Check if this is local or remote connection request, the remote
    // connection requests have already created an LLC link object
    //

    if (LlcLinkHandle == NULL) {

        //
        // local connection request
        //

        Status = LlcOpenLinkStation(pSap->hLlcObject,   // SAP handle!
                                    pDlcParms->DlcOpenStation.RemoteSap,
                                    pDlcParms->DlcOpenStation.aRemoteNodeAddress,
                                    NULL,
                                    pLinkStation,
                                    &pLinkStation->hLlcObject
                                    );
        if (Status != STATUS_SUCCESS) {

            //
            // It didn't work for some reason, we are probably out of memory.
            // Free the slot in the link station table.
            //

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pLinkStation->u.Link.pStatusEvent);

#if LLC_DBG
            pLinkStation->pLinkStationList = NULL;
#endif

            DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pLinkStation);

            pFileContext->LinkStationTable[LinkIndex] = NULL;
            pSap->u.Sap.LinkStationCount--;
            return Status;
        }
        pDlcParms->DlcOpenStation.LinkStationId = pLinkStation->StationId;
    } else {

        //
        // remote connection request
        //

        pLinkStation->hLlcObject = LlcLinkHandle;

        //
        // We must give the upper protocol handle to the link station,
        // otherwise the system bug checks, when the link is closed
        // before it is connected.
        //

        LlcBindLinkStation(LlcLinkHandle, pLinkStation);
    }

    //
    // The flag and these reference counters keeps the LLC object
    // alive, when we are working on it.  We decerement
    // the LLC object reference count when we don't have any more
    // synchronous commands going on.  Zero LLC reference count
    // on DLC object dereferences the LLC object
    //

    pLinkStation->LlcObjectExists = TRUE;
    ReferenceLlcObject(pLinkStation);
    LlcReferenceObject(pLinkStation->hLlcObject);

    //
    // Link this link station to the link list of all
    // link stations belonging to this sap (!?)
    //

    pFileContext->DlcObjectCount++;
    pLinkStation->u.Link.pSap = pSap;
    pLinkStation->pLinkStationList = pSap->pLinkStationList;
    pSap->pLinkStationList = pLinkStation;
    return STATUS_SUCCESS;
}


NTSTATUS
DlcCloseStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure closes a link, SAP or direct station. This implements
    DLC.CLOSE.STATION, DLC.CLOSE.SAP and DIR.CLOSE.DIRECT

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
                  STATUS_PENDING
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    PDLC_OBJECT pDlcObject;
    NTSTATUS Status;
    PDLC_CLOSE_WAIT_INFO pClosingInfo;

    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    DIAG_FUNCTION("DlcCloseStation");

    //
    // It's OK to close any group sap id (we don't test them, because
    // those objects exists only in llc driver.  The full implementation
    // of group saps would make this driver just too complicated)
    //

    if (pDlcParms->Async.Ccb.u.dlc.usStationId & 0x0100) {
        CompleteDirectOutIrp(pIrp, STATUS_SUCCESS, NULL);
        CompleteAsyncCommand(pFileContext, STATUS_SUCCESS, pIrp, NULL, FALSE);
        return STATUS_PENDING;
    }

    //
    // Procedure checks the sap and link station ids and
    // returns the requested link station.
    // The error status indicates a wrong sap or station id.
    //

    Status = GetStation(pFileContext,
                        pDlcParms->Async.Ccb.u.dlc.usStationId,
                        &pDlcObject
                        );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    //
    // Sap station cannot be closed until its all link stations
    // have been closed.
    //

    if ((pDlcObject->Type == DLC_SAP_OBJECT)
    && (pDlcObject->u.Sap.LinkStationCount != 0)) {
        return DLC_STATUS_LINK_STATIONS_OPEN;
    }

    pClosingInfo = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pClosingInfo == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }
    pClosingInfo->pIrp = pIrp;
    pClosingInfo->CloseCounter = 0;
    pClosingInfo->Event = DLC_COMMAND_COMPLETION;
    pClosingInfo->CancelStatus = DLC_STATUS_CANCELLED_BY_USER;
    pClosingInfo->CancelReceive = TRUE;

    if (pDlcParms->Async.Ccb.CommandCompletionFlag != 0) {
        pClosingInfo->ChainCommands = TRUE;
        SearchReadCommandForClose(pFileContext,
                                  pClosingInfo,
                                  pDlcParms->Async.Ccb.pCcbAddress,
                                  pDlcParms->Async.Ccb.CommandCompletionFlag,
                                  pDlcObject->StationId,
                                  (USHORT)DLC_STATION_MASK_SPECIFIC
                                  );
    }

    CloseAnyStation(pDlcObject, pClosingInfo, FALSE);

    return STATUS_PENDING;
}

/*++

Design notes about the dlc close commands
-----------------------------------------

All close operation must wait until the pending NDIS transmits
have been completed.  Thus they are asynchronous commands.
The close commands of a DLC object will also return all
CCBs of the pending commands and the received frames not yet read
with the read command.  The normal non-urgent close commands must
wait also the queued DLC transmit to complete.


There are three functions closing the dlc stations:
- DlcCloseObject
- DlcReset (sap and its link stations or all link stations)
- DirCloseAdapter (almost same as reset, except marks the file object closed,
    the actual file close disconnects the NDIS adapter.

All higher level functions allocates close completion data structure,
that is used to complete the command, when there are no pending
transmits in the associated stations.

The lower level functions
    CloseAllStations - closes all open sap stations and the only direct station
    CloseAnyStation  - initializes the close of any station,
                       for a sap station it also calls recursively the
                       link stations.
    CloseStation    - closes the object immediately or waits
                      until transmits have been completed and then
                      does the same thing again.


About the simultaneous reset and close commands
-------------------------------------------------

There are some very difficult problems with the
simultaneous reset and close commands:  each command
must wait until all dlc objects associated with the command
has been closed before the command itself cab be completed.
It is completely legal to make first close for a station, then
reset the sap of the same station (before the close completes) and
then reset all sap stations (before the sap reset completes).
On the other hand a dlc object can be linked only to one
close/reset command and in this case all three commands should wait
the completion of the same link station.

//Solution 1 (a bad one):
//There can be any number aof simultaneous close commands, because it
//can be done to a dlc object only if it has no open substations.
//There must be no other pending reset or close commands when a reset
//command is executed, because some of its substations may already
//be closing and they cannot be linked to the reset command.
//
//=>
//We have a global close/reset command counter and a link list for the
//pending reset commands.  A close command can be given in any time
//(even during a reset command, because all stations associated with
//a reset are already closed and cannot be closed again).
//A reset can be executed only if the global close/reset is zero.
//The pending resets are queued.  The close command completion
//routines executes the first reset command from the queue, if the
//!! Reset command must immediately mark all associated stations
//   closed to prevent any further use of those commands.

Solution 2 (the final solution):
-------------------------------

The sequential and simultaneous close and reset commands can be given
only to the dlc object being higher (or same) level than the destination
of the previous command (close link, reset sap, reset all saps, close adapter)
=> close/reset events can be linked in the dlc objects (simultaneous
close commands creates a split tree).
The counters in all close/reset events are decremented and possibly
executed when the dlc object is closed (when all transmits have been
completed and the link stations disconnected).


    //
    //  IBM has implemented the different close commands in this way:
    //
    //  1. DIR.CLOSE.DIRECT
    //      - Undefined, I will do the same as with DLC.CLOSE.X commands
    //  2. DLC.CLOSE.SAP, DLC.CLOSE.STATION
    //      - receive ccb linked to next ccb field without completion flag,
    //        the receive command is completed normally, only return code
    //        is set.
    //      - all terminated commands linked after the receive ccb if
    //        completion flag was defined and command itself read by
    //        READ from the compeltion list.
    //        The terminated commands (except receive) are completed normally.
    //  3. DLC.RESET
    //      - The terminated pending CCBs are linked only if command completion
    //        flag was defined.
    //  4. DIR.CLOSE.ADAPTER, DIR.INITIALIZE
    //      - the terminated CCBs linked to the next ccb field of the command.
    //        The command itself can be read with read command, if defined.
    //
    //  (and now we do the same (12-FEB-1992))

    Note: all close functions returns VOID, because they can never fail.
    A hanging close command hangs up the process or event the whole system.
    We have a problem: the llc adapter may be closed, while there are
    still active LLC command packets pending in the NDIS queues => the
    NDIS adapter close must wait (sleep and loop) until its all objects
    have been deleted.

--*/


BOOLEAN
CloseAllStations(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PIRP pIrp OPTIONAL,
    IN ULONG Event,
    IN PFCLOSE_COMPLETE pfCloseComplete OPTIONAL,
    IN PNT_DLC_PARMS pDlcParms OPTIONAL,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo
    )

/*++

Routine Description:

    This routine initializes closing all DLC stations. The command is
    asynchronously completed when all pending transmits have been sent
    and the link stations have been disconnected

Arguments:

    pFileContext    - process specific device context
    pIrp            - the i.o request packet of the related command
    Event           - event flag used to search a matching read for this command
    pfCloseComplete - completion appendage used when the DLC driver (or its
                      process context) is closed.
    pDlcParms       - DLC parameters from original system call
    pClosingInfo    - pointer to DLC_CLOSE_WAIT_INFO structure

Return Value:

    None - this must succeed always!

--*/

{
    PDLC_PACKET pPacket;
    USHORT i;
    USHORT FirstSap;
    BOOLEAN DoImmediateClose;
    NT_DLC_CCB AsyncCcb;

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pDlcParms == NULL) {

        //
        // Adapter Close always returns a pending status!
        // It completes the io- request by itself.
        //

        pDlcParms = (PNT_DLC_PARMS)&AsyncCcb;
        LlcZeroMem(&AsyncCcb, sizeof(AsyncCcb));
    }

    pClosingInfo->pIrp = pIrp;
    pClosingInfo->CloseCounter = 1; // keep object alive during sync path
    pClosingInfo->Event = Event;
    pClosingInfo->pfCloseComplete = pfCloseComplete;
    pClosingInfo->CancelStatus = (ULONG)DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION;

    //
    // We zero the memory by default:
    //      pClosingInfo->pCcbLink = NULL
    //      pClosingInfo->pReadCommand = NULL
    //

    //
    // DLC.RESET must not close the direct station.
    // This flag is false for DLC.RESET but set for DIR.CLOSE.ADAPTER etc.
    //

    if (pDlcParms->Async.Ccb.uchDlcCommand == LLC_DLC_RESET) {
        FirstSap = 1;                   // don't delete the direct station
        DoImmediateClose = FALSE;
        pClosingInfo->CancelStatus = DLC_STATUS_CANCELLED_BY_USER;
    } else {
        FirstSap = 0;   // if DIR.CLOSE.ADAPTER, can close everything
        DoImmediateClose = TRUE;
        pClosingInfo->ClosingAdapter = TRUE;
    }

    //
    // Chain the cancelled CCBs to the adapter close command or to a closing
    // event, if this is a global close command for adapter or a normal close
    // command (dlc.close.xxx, dlc.reset, dir.close.station) with a command
    // completion flag
    //

    if (Event == LLC_CRITICAL_EXCEPTION || pDlcParms->Async.Ccb.CommandCompletionFlag != 0) {
        pClosingInfo->ChainCommands = TRUE;
        SearchReadCommandForClose(pFileContext,
                                  pClosingInfo,
                                  pDlcParms->Async.Ccb.pCcbAddress,
                                  pDlcParms->Async.Ccb.CommandCompletionFlag,
                                  0,
                                  0 // search commands for all station ids
                                  );
    }

    //
    // This flag has been set, when user has issued DIR.INITIALIZE command,
    // that makes the hard reset for NDIS
    //

    if (pDlcParms->Async.Ccb.uchDlcCommand == LLC_DIR_INITIALIZE) {

        //
        // We cannot stop to closing, if the memory allocation fails,
        // It's better just to close the adapter without hard reset
        // that to fail the whole DIR.INITIALIZE command.
        //

        pPacket = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pPacket != NULL) {
            pClosingInfo->CloseCounter++;

            pPacket->ResetPacket.pClosingInfo = pClosingInfo;

            //
            // The reset command cancels all pending transmit requests!
            // => the closing of the stations should be very fast
            //

            LEAVE_DLC(pFileContext);

            LlcNdisReset(pFileContext->pBindingContext, &pPacket->LlcPacket);

            ENTER_DLC(pFileContext);

        }
    }
    if (pFileContext->DlcObjectCount != 0) {
        for (i = FirstSap; i < MAX_SAP_STATIONS; i++) {
            if (pFileContext->SapStationTable[i] != NULL) {
                CloseAnyStation(pFileContext->SapStationTable[i],
                                pClosingInfo,
                                DoImmediateClose
                                );
            }
        }
    }

    //
    // Complete close command, if this was the last reference
    // of the close information
    //

    return DecrementCloseCounters(pFileContext, pClosingInfo);
}


VOID
CloseAnyStation(
    IN PDLC_OBJECT pDlcObject,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN BOOLEAN DoImmediateClose
    )

/*++

Routine Description:

    Procedure closes any station, and in the case of sap station it
    also calls recursively sap's all link stations before
    it closes the actual sap station.

Arguments:

    pDlcObject          - DLC object
    pClosingInfo        - the information needed for the close/reset command
                          completion (optionally by DLC read).
    DoImmediateClose    - flag set when the stations are closed immediately

Return Value:

    None - this must succeed always!

--*/

{
    PDLC_FILE_CONTEXT pFileContext = pDlcObject->pFileContext;
    PDLC_CLOSE_WAIT_INFO pCurrentClosingInfo;
    UINT i;

    DIAG_FUNCTION("CloseAnyStation");

    //
    // first close all link stations on this SAP. This must be done before the
    // object can be marked as deleted
    //

    if (pDlcObject->Type == DLC_SAP_OBJECT) {

        BOOLEAN SapObjectIsBadFood = FALSE;

        //
        //  Delete all link stations using the current sap station.
        //

        for (i = 0; i < MAX_LINK_STATIONS; i++) {
            if (pFileContext->LinkStationTable[i] != NULL
            && pFileContext->LinkStationTable[i]->u.Link.pSap == pDlcObject) {

                //
                // the SAP object will be deleted when its last link object has
                // been deleted
                //

                if (pDlcObject->State == DLC_OBJECT_CLOSING) {
                    SapObjectIsBadFood = TRUE;
                }
                CloseAnyStation(pFileContext->LinkStationTable[i],
                                pClosingInfo,
                                DoImmediateClose
                                );
            }
        }

        //
        // it is highly probable that the SAP object is already deleted. The
        // close info counter was also decremented because the current closing
        // info packet was linked behind the old close packet by link station
        // cleanup, then completed when the SAP was closed after its last link
        // station was deleted
        //

        if (SapObjectIsBadFood) {
            return;
        }
    }

    //
    // We must queue simultaneous close/reset commands
    //

    if (pDlcObject->State == DLC_OBJECT_OPEN) {
        pDlcObject->State = DLC_OBJECT_CLOSING;
        pDlcObject->pClosingInfo = pClosingInfo;

        //
        // The close command has been queued, increment the counter
        //

        pClosingInfo->CloseCounter++;
    } else {

        //
        // Queue all simultaneous close/reset commands to a spanning TREE
        //
        // The linked closing info packets creates a spanning tree.
        // The newest (and stronges) close command is always the
        // root node.  Even stronger close command would combine
        // the separate spanning trees to one single tree.
        // The root commands are completed, when its all sub-stations
        // have been closed and older commands have been completed.
        //
        // It is possible to have simultaneously pending:
        //     1. Close link station (pending)
        //     2. Close sap station (pending)
        //     3. Reset sap station (pending)
        //     4. Reset all saps with single command (pending)
        //     5. Resetting NDIS adapter with DirInitialize
        //        OR Closing adapter with DirCloseAdapter
        //        OR close initiated by process exit
        //
        // The commands cannot be executed in the reverse order,
        // because the stronger command would have already closed
        // affected station(s) or adapter.
        //

        for (pCurrentClosingInfo = pDlcObject->pClosingInfo;
            pCurrentClosingInfo != pClosingInfo;
            pCurrentClosingInfo = pCurrentClosingInfo->pNext) {

            if (pCurrentClosingInfo->pNext == NULL) {
                pCurrentClosingInfo->pNext = pClosingInfo;

                //
                // We link this close packet to many other close commands,
                // => we must add the count of all pending closing stations
                // to the current packet
                // (fix 28-03-1992, bug check when process exit during a
                // pending dlc reset).
                // (Bug-bug: close counter is not correct, when the previous
                // close command is still in sync code path => dlc reset
                // must decrement the next pointers in the queue).
                //

                pClosingInfo->CloseCounter += pCurrentClosingInfo->CloseCounter;
                break;
            }
        }
    }

    CloseStation(pFileContext, pDlcObject, DoImmediateClose);
}


VOID
CloseStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN BOOLEAN DoImmediateClose
    )

/*++

Routine Description:

    This procedure starts the asychronous close of any DLC station
    object.  It creates an asynchronous command completion packet
    for the station and returns.

Arguments:

    pFileContext        -
    pDlcObject          - DLC object
    DoImmediateClose    - the flag is set when the LLC object must be closed
                          immediately without waiting the pending transmits

Return Value:

    None - this must succeed always!

--*/

{
    PLLC_PACKET pClosePacket;

    DIAG_FUNCTION("CloseStation");

    //
    // we must cancel all pending transmits immediately,
    // when the adapter is closed.
    //

    if ((pDlcObject->State == DLC_OBJECT_CLOSING
    && (DoImmediateClose || pDlcObject->PendingLlcRequests == 0)
    && !(pDlcObject->Type == DLC_SAP_OBJECT && pDlcObject->u.Sap.LinkStationCount != 0))

    ||

    //
    // This condition forces the link to close even if
    // there was a pending disconnect command (it may be
    // waiting the other side and that may take a quite a while).
    // Otherwise the exit of a DLC app may hung up to 5 - 60 seconds)
    //

    (DoImmediateClose
    && pDlcObject->hLlcObject != NULL
    && pDlcObject->Type == DLC_LINK_OBJECT)) {

        //
        // Llc objects can be closed in any phase of operation.
        // The close command will cancel all transmit commands
        // not yet queued to NDIS and returns an asynchronous
        // completion status, when the pending NDIS commands
        // have been completed.  The CloseCompletion indication
        // handler uses the same PendingLlcRequestser as
        // with the normal pending transmit commands.
        // The immediate close first closes the LLC object and then
        // waits the pending transmits (=> waits only transmits
        // queued on NDIS).
        // A graceful close does it vice versa: it first waits
        // pending transmits and then does the actual close.
        //

        ASSERT(pDlcObject->ClosePacketInUse == 0);

        if (pDlcObject->ClosePacketInUse == 1) {
            pClosePacket = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

            if (pClosePacket == NULL) {
                //
                // We don't have enough memory to make a graceful closing,
                // We must do it in a quick and dirty way.
                // We cannoot either wait llc to acknowledge the
                // close, because we don't have any close packet
                //
                DoImmediateClose = TRUE;
            } else {
                pDlcObject->PendingLlcRequests++;
            }
        } else {
            pClosePacket = &pDlcObject->ClosePacket;
            pDlcObject->ClosePacketInUse = 1;
            pDlcObject->PendingLlcRequests++;
        }

        pDlcObject->State = DLC_OBJECT_CLOSED;
        if (pDlcObject->Type == DLC_LINK_OBJECT && !DoImmediateClose) {

            //
            // LlcDisconnect completion routine will close the link
            // station and call this routine again, when the
            // link station routine completes.
            // We must reference the LLC object before the operation,
            // otherwise there is a very small time window, that allows
            // LLC object to be deleted while the disconnect
            // operation is going on (and crash the system).
            // (I hate pointer based interfaces)
            //

            ReferenceLlcObject(pDlcObject);

            LEAVE_DLC(pFileContext);

            //
            // Data link driver returns a synchronous status only if
            // if cannot complete command asynchronously, because it
            // doesn't have a handle to the DLC object (the link
            // station has not yet been
            //

            LlcDisconnectStation(pDlcObject->hLlcObject, pClosePacket);

            ENTER_DLC(pFileContext);

            DereferenceLlcObject(pDlcObject);
        } else {

            //
            // we must close the link station immediately, if we for
            // some reason cannot disconnect it normally.
            //

            if (pDlcObject->LlcObjectExists == TRUE) {
                pDlcObject->LlcObjectExists = FALSE;

                LEAVE_DLC(pFileContext);

                LlcCloseStation(pDlcObject->hLlcObject, pClosePacket);

                ENTER_DLC(pFileContext);

                DereferenceLlcObject(pDlcObject);
            }
        }

        //
        // We must be able to close the driver even in out of memory conditions.
        // LLC driver won't acknowledge the close if we connot allocate a packet
        // for it
        //

        if (pClosePacket == NULL) {
            CompleteCloseStation(pFileContext, pDlcObject);
        }
    }
}


VOID
CompleteCloseStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject
    )

/*++

Routine Description:

    Procedure completes the close operation for any station object.
    It also completes all close commands, that have been waiting
    the closing of this station (or this station as the last member
    of a group).

Arguments:

    pFileContext    - identifies owner of object
    pDlcObject      - dlc object

Return Value:

    None.

--*/

{
    //
    // We must keep the LLC object alive, as far as there is any
    // pending (transmit) commands in LLC.
    //

    if (pDlcObject->PendingLlcRequests == 0) {

        //
        //  The station may still be waiting its transmit (and receive)
        //  commands to complete.  We must poll the close station.
        //  if the status is still just closing.
        //

        if (pDlcObject->State == DLC_OBJECT_CLOSING) {
            CloseStation(pFileContext, pDlcObject, FALSE);
        } else {

            PDLC_OBJECT pSapObject = NULL;
            PDLC_CLOSE_WAIT_INFO pClosingInfo;

            DLC_TRACE('N');

            //
            //  The object must have been deleted from the file
            //  context when we enable spin lock in the next time,
            //  because the object is not any more in a consistent
            //  state.
            //

            if (pDlcObject->Type == DLC_LINK_OBJECT) {

                DLC_TRACE('c');

                //
                //  Remove the link station from the link station
                //  link list of its sap and link station table
                //  of the file context.
                //

                RemoveFromLinkList((PVOID *)&(pDlcObject->u.Link.pSap->pLinkStationList),
                                   pDlcObject
                                   );
                pFileContext->LinkStationTable[(pDlcObject->StationId & 0xff) - 1] = NULL;

                //
                //  Data link events have always the next pointer
                //  non-null, when they are in the event queue.
                //  The cleanup routine will remove and deallocate
                //  the packet when it is in the event queue.
                //

                if (pDlcObject->u.Link.pStatusEvent->LlcPacket.pNext == NULL) {

                    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool,
                                              pDlcObject->u.Link.pStatusEvent
                                              );

                }

                //
                //  Remove the possible memory committed by this link
                //  station during a buffer busy state.  Normally
                //  the committed space is zero.
                //

                if (pFileContext->hBufferPool != NULL) {
                    BufUncommitBuffers(pFileContext->hBufferPool,
                                       pDlcObject->CommittedBufferSpace
                                       );
                }

                //
                //  The sap station must wait until its all link stations
                //  have been closed.
                //  Otherwise we will corrupt memory!!!!!!!!!
                //  ((would have been very hard and uncommon bug: reset
                //    of one station migth have corrupted a new dlc object
                //    created simultaneusly))
                //

                pDlcObject->u.Link.pSap->u.Sap.LinkStationCount--;
                if (pDlcObject->u.Link.pSap->u.Sap.LinkStationCount == 0
                && pDlcObject->u.Link.pSap->State == DLC_OBJECT_CLOSING) {
                    pSapObject = pDlcObject->u.Link.pSap;
                }
            } else {

                //
                //  SAP station must wait until its all link stations
                //  have been closed!
                //

                if (pDlcObject->Type == DLC_SAP_OBJECT) {
                    if (pDlcObject->u.Sap.LinkStationCount != 0) {
                        return;
                    }

                    DLC_TRACE('d');

                    //
                    //  All link stations have now been deleted, we can return
                    //  the sap's link stations back to the global pool.
                    //  The group sap can be deleted also.
                    //

                    pFileContext->LinkStationCount += pDlcObject->u.Sap.MaxStationCount;

                    LEAVE_DLC(pFileContext);

                    LlcCloseStation(pDlcObject->u.Sap.GlobalGroupSapHandle, NULL);

                    ENTER_DLC(pFileContext);

                    //
                    //  Delete all group saps defined for this sap station
                    //

                    SetupGroupSaps(pFileContext, pDlcObject, 0, NULL);
                }
                pFileContext->SapStationTable[pDlcObject->StationId >> 9] = NULL;
            }
            pFileContext->DlcObjectCount--;

            //
            //  The first and most specific close command will get all
            //  received frames and the transmit chain of the deleted object.
            //

            CleanUpEvents(pFileContext, pDlcObject->pClosingInfo, pDlcObject);

            //
            //  The parallel close/reset commands have been queued in a
            //  link list,  We must decrement and notify all dlc objects
            //

//            DecrementCloseCounters(pFileContext, pDlcObject->pClosingInfo);

            //
            //  It's best to deallocate event packet after the
            //  cleanup of the event queue
            //

#if LLC_DBG
            pDlcObject->pLinkStationList = NULL;
            pDlcObject->State = DLC_OBJECT_INVALID_TYPE;
#endif

            //
            // RLF 08/17/94
            //
            // grab the pointer to the closing info structure before deallocating
            // the DLC object
            //

            pClosingInfo = pDlcObject->pClosingInfo;
            DEALLOCATE_PACKET_DLC_OBJ(pFileContext->hLinkStationPool, pDlcObject);

            //
            //  the close completion of the last link station closes
            //  also the sap object of that link station, if the
            //  sap closing was waiting to closing of the link station
            //

            if (pSapObject != NULL) {
                CloseStation(pFileContext, pSapObject, TRUE);

                                                    //
                                                    // TRUE: must be at least
                                                    // DLC.RESET
                                                    //

            }

            //
            // RLF 08/17/94
            //
            // Moved this call to DecrementCloseCounters from its previous
            // place above. Once again, we find that things are happening out
            // of sequence: this time, if we decrement the close counters,
            // causing them to go to zero before we have freed the DLC object
            // then the file context structure and its buffer pools are
            // deallocated. But the DLC object was allocated from the now
            // deleted pool, meaning sooner or later we corrupt non-paged pool
            //

            //
            //  The parallel close/reset commands have been queued in a
            //  link list,  We must decrement and notify all dlc objects
            //

            DecrementCloseCounters(pFileContext, pClosingInfo);
        }
    }
}


VOID
CompleteCloseReset(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo
    )

/*++

Routine Description:

    The primitive builds a completion event for the close/reset
    of a dlc object. The close/reset may have been initiated by
    DlcReset, DirCloseAdapter, DirInitialize or because the NDIS
    driver is closing (eg. Unbind command).
    In the last case pClosingInfo->pIrp is NULL, because there
    is no command related to the event.

    The only (major) difference from the IBM OS/2 DLC is, that
    the first_buffer_addr parameter is not supported, because it
    is meaningless with he NT buffer management.
    The buffer pool is managed by dlc, not by the application.

Arguments:

    FileContext     - the process specific device context
    pClosingInfo    - all information needed for close or reset command completion
    pDlcObject      - the closed or deleted object

Return Value:

    None.

--*/

{
    BOOLEAN completeRead = FALSE;
    BOOLEAN deallocatePacket = FALSE;
    BOOLEAN derefFileContext = FALSE;

    //
    // Now we can cancel and chain all commands, that are still left,
    // if we are really closing this adapter context
    // (there should be no events any more, because the were deleted
    // with their owner objects).
    //

    if (pClosingInfo->ClosingAdapter) {
        for (;;) {

            NTSTATUS Status;

            Status = AbortCommand(
                        pFileContext,
                        DLC_IGNORE_STATION_ID,      // station id may be anything
                        DLC_STATION_MASK_ALL,       // mask for all station ids!
                        DLC_MATCH_ANY_COMMAND,      // mask for all commands
                        &pClosingInfo->pCcbLink,    // link them to here
                        pClosingInfo->CancelStatus, // cancel with this status
                        FALSE                       // Don't suppress completion
                        );
            if (Status != STATUS_SUCCESS) {
                break;
            }
            pClosingInfo->CcbCount++;
        }
    }

    //
    // The receive command must be linked to the first CCB immediately
    // after the actual cancelling command.
    //

    if (pClosingInfo->pRcvCommand != NULL) {
        CancelDlcCommand(pFileContext,
                         pClosingInfo->pRcvCommand,
                         &pClosingInfo->pCcbLink,
                         pClosingInfo->CancelStatus,
                         TRUE   // disable command completion for RECEIVE
                         );
        pClosingInfo->CcbCount++;
    }

    //
    // Should the completed commands to be saved as a completion event.
    //

    if (pClosingInfo->pCompletionInfo != NULL) {

        PDLC_COMPLETION_EVENT_INFO pCompletionInfo;

        pCompletionInfo = pClosingInfo->pCompletionInfo;

        //
        // search all receive data events destinated to the closed or
        // reset station or stations.  We must chain all those
        // buffer to the single NULL terminated list
        //

        pCompletionInfo->CcbCount = (USHORT)(pClosingInfo->CcbCount + 1);

        //
        // Save the received frames to the completion information!
        // NOTE: The received frames returned by DIR.CLOSE.ADAPTER
        // cannot be released using the same adapter handle.
        // They are released and unlocked if the closed adapter
        // was the only user of the pool.  Otherwise those frames
        // must be unlocked using another adapter handle, that
        // shares the same buffer pool.
        // !!! Actually we should automatically free all receive
        //     buffers when an adapter is closed and do not to return
        //     them to application !!!
        //

        pCompletionInfo->pReceiveBuffers = pClosingInfo->pRcvFrames;

        //
        // Execute the old READ command or queue the command completion
        // request to the command queue.
        //

        if (pClosingInfo->pReadCommand != NULL) {

            //
            // RLF 03/25/94
            //
            // See below
            //

            completeRead = TRUE;

            /*

            pClosingInfo->pReadCommand->Overlay.pfCompletionHandler(
                pFileContext,
                NULL,
                pClosingInfo->pReadCommand->pIrp,
                (UINT)pClosingInfo->Event,
                pCompletionInfo,
                0
                );

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClosingInfo->pReadCommand);

            */

        } else {

            //
            // Queue the completion event, Note: we will return all
            // CCBs linked to the issued close CCB in any way.
            // It does not matter for eg. DirCloseAdapter, if there
            // is an extra event queued. It will be deleted when
            // the command completes and all memory resources are
            // released.
            //

            MakeDlcEvent(pFileContext,
                         pClosingInfo->Event,
                         pCompletionInfo->StationId,
                         NULL,
                         pCompletionInfo,
                         0,
                         pClosingInfo->FreeCompletionInfo
                         );
        }
    } else if (pFileContext->hBufferPool != NULL) {

        //
        // Free the received frames in the buffer pool, they are
        // not saved to the command completion list.
        //

        BufferPoolDeallocateList(pFileContext->hBufferPool,
                                 pClosingInfo->pRcvFrames
                                 );
    }

    //
    // DirCloseAdapter requires a special post routine, that will
    // close the NDIS binding when all pending transmits have completed
    // and the the requests have been cancelled.
    // Note: the close adapter packet is not allocated from packet pool!
    //

    /*

    //
    // RLF 08/17/94
    //

    if (pClosingInfo->pfCloseComplete != NULL) {
        pClosingInfo->pfCloseComplete(pFileContext,
                                      pClosingInfo,
                                      pClosingInfo->pCcbLink
                                      );

    } else {

    */

    if (pClosingInfo->pfCloseComplete == NULL) {
        if (pClosingInfo->pIrp != NULL) {
            CompleteDirectOutIrp(pClosingInfo->pIrp,
                                 STATUS_SUCCESS,
                                 pClosingInfo->pCcbLink
                                 );
            CompleteAsyncCommand(pFileContext,
                                 STATUS_SUCCESS,
                                 pClosingInfo->pIrp,
                                 pClosingInfo->pCcbLink,
                                 FALSE
                                 );
        }

#if LLC_DBG
        pClosingInfo->pNext = NULL;
#endif

        //
        // RLF 03/25/94
        //
        // More asynchronicity with READs causing fatal errors in an application.
        // This actual case was in HPMON:
        //
        //      1. application submits DLC.CLOSE.STATION
        //      2. this routine puts DLC.CLOSE.STATION command in command complete
        //         list of READ parameter table. READ IRP is completed
        //      3. app gets READ completion, sees DLC.CLOSE.STATION is complete
        //         and frees DLC.CLOSE.STATION CCB to heap: heap manager writes
        //         signature data over freed CCB
        //      4. this routine completes original DLC.CLOSE.STATION IRP, writing
        //         8 bytes over original CCB, now just part of heap
        //      5. some time later, heap allocation request made. Heap manager
        //         finds the heap has been trashed and goes on strike
        //

        if (completeRead) {
            pClosingInfo->pReadCommand->Overlay.pfCompletionHandler(
                pFileContext,
                NULL,
                pClosingInfo->pReadCommand->pIrp,
                (UINT)pClosingInfo->Event,
                pClosingInfo->pCompletionInfo,
                0
                );

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClosingInfo->pReadCommand);

        }

        //
        // RLF 08/17/94
        //
        // don't deallocate the packet now - we may need to use it if we call
        // the close completion handler below
        //

        deallocatePacket = TRUE;

        /*
        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClosingInfo);
        */

    }

    //
    // RLF 08/17/94
    //
    // Moved the DirCloseAdapter processing here to give the client chance to
    // receive the event before we close the adapter and maybe kill the file
    // context
    //

    if (pClosingInfo->pfCloseComplete) {

        //
        // RLF 08/17/94
        //
        // This is bad: this close complete call may cause the file context to
        // become completely dereferenced, and hence free it and its buffer
        // pools. But we still have the closing info packet allocated, so
        // increase the reference count, free up the packet below, then deref
        // the file context again, and cause it to be deleted (if that would
        // have happened anyway)
        //

        ReferenceFileContext(pFileContext);
        derefFileContext = TRUE;

        pClosingInfo->pfCloseComplete(pFileContext, pClosingInfo, pClosingInfo->pCcbLink);
    }

    if (deallocatePacket) {
        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClosingInfo);
    }

    if (derefFileContext) {
        DereferenceFileContext(pFileContext);
    }
}


VOID
CleanUpEvents(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PDLC_OBJECT pDlcObject
    )

/*++

Routine Description:

    The primitive cleans up or modifies all events having a pointer
    to the closed station object.  This also chains one and only one
    transmit ccb chain to the end of CCB chain, because the completed
    commands (as transmit and command completion events in the event queue)
    cannot be linked any more to other commands.  Thus there can be
    only one single chain in the end of the actual chain of the pending
    commands.

    This routines cleans up the commands as well.

Arguments:

    FileContext     - the process specific device context
    pClosingInfo    - all information needed for close or reset command
                      completion
    pDlcObject      - the closed or deleted object

Return Value:

    STATUS_SUCCESS

--*/

{
    PDLC_EVENT pNextEvent;
    PDLC_EVENT pEvent;
    BOOLEAN RemoveNextPacket;

    for (pEvent = (PDLC_EVENT)pFileContext->EventQueue.Flink;
        pEvent != (PDLC_EVENT)&pFileContext->EventQueue;
        pEvent = pNextEvent) {

        pNextEvent = (PDLC_EVENT)pEvent->LlcPacket.pNext;

        if (pEvent->pOwnerObject == pDlcObject) {

            //
            //  By defult we free the next packet
            //

            RemoveNextPacket = TRUE;

            switch (pEvent->Event) {
            case LLC_RECEIVE_DATA:

                //
                //  The received frames are saved to circular lists,
                //  where the head points to the newest frame and
                //  the next element from it is the oldest one.
                //  We simply the new frames to the old head of list.
                //

                if (pClosingInfo->pRcvFrames == NULL) {
                    pClosingInfo->pRcvFrames = pEvent->pEventInformation;
                } else {

                    //
                    //  Initial state:
                    //      H1 = N1->O1...->N1  and  H2 = N2->O2...->N2
                    //
                    //  End state:
                    //      H1 = N1->O2...->N2->O1...->N1
                    //
                    //  => Operations must be:
                    //      Temp = H2->Next;
                    //      H2->Next = H1->Next;
                    //      H1->Next = Temp;
                    //  (where H = list head, N = newest element, O = oldest)
                    //

                    PDLC_BUFFER_HEADER pTemp;

                    pTemp = ((PDLC_BUFFER_HEADER)pEvent->pEventInformation)->FrameBuffer.pNextFrame;
                    ((PDLC_BUFFER_HEADER)pEvent->pEventInformation)->FrameBuffer.pNextFrame =
                        ((PDLC_BUFFER_HEADER)pClosingInfo->pRcvFrames)->FrameBuffer.pNextFrame;
                    ((PDLC_BUFFER_HEADER)pClosingInfo->pRcvFrames)->FrameBuffer.pNextFrame = pTemp;
                }
                pDlcObject->pReceiveEvent = NULL;
                break;

            case LLC_TRANSMIT_COMPLETION:

                //
                //  We cannot do nothing for single transmit commands, because
                //  they have already been completed, and the completed CCBs
                //  cannot any more be linked together.  Thus we leave
                //  them to the event queue and will hope, that somebody
                //  will read them from the event queue.  The memory is
                //  released when the file context is closed (eg. file close in
                //  the process exit).  We just reset the dlc object pointer,
                //  that nobody would later use invalid pointer.
                //
                //  The transmit commands chained of one closed station can
                //  be removed from the event list and chained to
                //  the end of the CCBs, BUT ONLY ONE!  All other
                //  transmit completion events must be saved as a normal
                //  events with an invalid CCB count!!!!!
                //

                if (pClosingInfo->pCcbLink == NULL && pClosingInfo->ChainCommands) {
                    pClosingInfo->pCcbLink = pDlcObject->pPrevXmitCcbAddress;
                    pClosingInfo->CcbCount += pDlcObject->ChainedTransmitCount;
                } else {

                    //
                    //  We must change the format of this transmit completion
                    //  into the similar to the command completion event
                    //  packet of close command.  Otherwise the application
                    //  could lose the transmit CCBs, when it closes or
                    //  resets a station.
                    //

                    PDLC_COMPLETION_EVENT_INFO pCompletionInfo;

                    pCompletionInfo = (PDLC_COMPLETION_EVENT_INFO)
                                        ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

                    if (pCompletionInfo != NULL) {
                        pCompletionInfo->CcbCount = pDlcObject->ChainedTransmitCount;
                        pCompletionInfo->pCcbAddress = pDlcObject->pPrevXmitCcbAddress;
                        pCompletionInfo->CommandCompletionFlag = pEvent->SecondaryInfo;
                        pEvent->SecondaryInfo = 0;
                        pEvent->pEventInformation = pCompletionInfo;
                        pEvent->bFreeEventInfo = TRUE;
                        RemoveNextPacket = FALSE;
                    }
                }
                break;

                //
                //  case DLC_COMMAND_COMPLETION ?
                //  The command completions have been saved without the
                //  the link to the Dlc structure -> they are automatically
                //  left into the completion queue.
                //

            case LLC_STATUS_CHANGE:

                //
                //  Link station status changes cannot mean anytging after the
                //  link station has been deleted.
                //

                break;

#if LLC_DBG
            default:
                LlcInvalidObjectType();
                break;
#endif
            };
            if (RemoveNextPacket) {
                LlcRemoveEntryList(pEvent);

                DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pEvent);

            } else {

                //
                //  We must remove the reference to the deleted object
                //

                pEvent->pOwnerObject = NULL;
            }
        }
    }

    //
    //  The optional receive command must be removed first, otherwise
    //  it is cancelled with the other commands given to the deleted
    //  object.
    //

    if (pClosingInfo->CancelReceive && pDlcObject->pRcvParms != NULL) {

        //
        //  The receive command linked to the DLC object is a special case:
        //  we must link it immediately after the close CCB
        //

        pClosingInfo->pRcvCommand = SearchAndRemoveAnyCommand(
                                        pFileContext,
                                        (ULONG)(-1),
                                        (USHORT)DLC_IGNORE_STATION_ID,
                                        (USHORT)DLC_STATION_MASK_SPECIFIC,
                                        pDlcObject->pRcvParms->Async.Ccb.pCcbAddress
                                        );
        pDlcObject->pRcvParms = NULL;
    }

    //
    //  Cleanup the commands given to the dleted object
    //

    for (;;) {

        NTSTATUS Status;

        Status = AbortCommand(pFileContext,
                              pDlcObject->StationId,
                              (USHORT)(pDlcObject->Type == (UCHAR)DLC_SAP_OBJECT
                                ? DLC_STATION_MASK_SAP
                                : DLC_STATION_MASK_SPECIFIC),
                              DLC_IGNORE_SEARCH_HANDLE,
                              &pClosingInfo->pCcbLink,
                              pClosingInfo->CancelStatus,
                              FALSE                       // Don't suppress completion
                              );
        if (Status != STATUS_SUCCESS) {
           break;
        }

        //
        //  Now we can cancel and chain all commands destinated to the
        //  closed/reset station id.
        //  We always complete the commands given to the deletcd object,
        //  but we chain them together only if this flag has been set.
        //

        if (pClosingInfo->ChainCommands == FALSE) {

            //
            //  Don't link the cancelled CCBs together
            //

            pClosingInfo->pCcbLink = NULL;
        } else {
            pClosingInfo->CcbCount++;
        }
    }
}


VOID
SearchReadCommandForClose(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbAddress,
    IN ULONG CommandCompletionFlag,
    IN USHORT StationId,
    IN USHORT StationIdMask
    )

/*++

Routine Description:

    The primitive searches a read command for a close command
    and saves it into the closing info structure.

Arguments:

    FileContext     - the process specific device context
    pClosingInfo    - all information needed for close or reset command
                      completion
    pCcbAddress     - ccb address of the searched read command
    StationId       -
    StationIdMask   -

Return Value:

    None.

--*/

{
    //
    // Allocate the parameter buffer for command completion with
    // read if it is needed OR if we are closing everything because
    // of a critical exception (ie. pIrp == NULL)
    //

    pClosingInfo->pCompletionInfo = (PDLC_COMPLETION_EVENT_INFO)
                                        ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pClosingInfo->pCompletionInfo != NULL) {

        pClosingInfo->FreeCompletionInfo = TRUE;

        //
        // We must link all commands given to the deleted objects
        //

        pClosingInfo->pCompletionInfo->pCcbAddress = pCcbAddress;
        pClosingInfo->pCompletionInfo->CommandCompletionFlag = CommandCompletionFlag;
        pClosingInfo->ChainCommands = TRUE;

        //
        // A link station close command we be read as a command completion
        // on its sap, but the other close commands cannot use any station id
        //

        if (StationIdMask == DLC_STATION_MASK_SPECIFIC) {
            pClosingInfo->pCompletionInfo->StationId = (USHORT)(StationId & DLC_STATION_MASK_SAP);
        } else {
            pClosingInfo->pCompletionInfo->StationId = 0;
        }

        //
        // Search first a special READ command dedicated only for
        // this command completion.  We must read the optional
        // read command NOW. Otherwise it will be canceled
        // with the other commands, that have been given for
        // the deleted station(s).
        //

        pClosingInfo->pReadCommand = SearchAndRemoveCommandByHandle(
                                            &pFileContext->CommandQueue,
                                            pClosingInfo->Event,
                                            (USHORT)DLC_IGNORE_STATION_ID,
                                            (USHORT)DLC_STATION_MASK_SPECIFIC,
                                            pCcbAddress
                                            );
        if (pClosingInfo->pReadCommand == NULL) {

            //
            // We do not really care about the result, because
            // it is OK to return NULL.  This completion event
            // may be read sometime later.
            //

            pClosingInfo->pReadCommand = SearchAndRemoveCommand(
                                            &pFileContext->CommandQueue,
                                            pClosingInfo->Event,
                                            StationId,
                                            StationIdMask
                                            );
        }
    }
}


VOID
CompleteLlcObjectClose(
    IN PDLC_OBJECT pDlcObject
    )

/*++

Routine Description:

    This routine just derefernces a llc object, when its reference count
    in DLC driver has been decremented to zero.
    The reference count is used to prevent the closing of llc object
    when it is simultaneously called elsewhere (that would invalidate
    the llc object pointer)

Arguments:

    pDlcObject  - any DLC object.

Return Value:

    none

--*/

{
    PVOID hLlcObject = pDlcObject->hLlcObject;

    if (hLlcObject != NULL) {

        DLC_TRACE('P');

        pDlcObject->hLlcObject = NULL;
        LEAVE_DLC(pDlcObject->pFileContext);

        LlcDereferenceObject(hLlcObject);

        ENTER_DLC(pDlcObject->pFileContext);
    }
}


BOOLEAN
DecrementCloseCounters(
    PDLC_FILE_CONTEXT pFileContext,
    PDLC_CLOSE_WAIT_INFO pClosingInfo
    )

/*++

Routine Description:

    This routine decrements the count of existing objects in the
    chianed close command packets and completes the close commands,
    if the count of the existing objects hits zero.

Arguments:

    pFileContext    - file handle context
    pClosingInfo    - close command packet

Return Value:

    BOOLEAN
        TRUE    - all pending close/resets have been completed
        FALSE   - close/resets still pending

--*/

{
    PDLC_CLOSE_WAIT_INFO pNextClosingInfo;
    UINT loopCounter, closeCounter;

    //
    //  Complete the reset command if all objects have been deleted,
    //  There may be another DirCloseAdapter chained its next pointer
    //

    for (loopCounter = 0, closeCounter = 0;
        pClosingInfo != NULL;
        pClosingInfo = pNextClosingInfo, ++loopCounter) {

        pNextClosingInfo = pClosingInfo->pNext;
        pClosingInfo->CloseCounter--;
        if (pClosingInfo->CloseCounter == 0) {

            //
            // Call the completion routine of the close command.
            // We don't need to check the status code.
            //

            CompleteCloseReset(pFileContext, pClosingInfo);
            ++closeCounter;
        }
    }

    //
    // if we completed every close/reset we found then return TRUE
    //

    return loopCounter == closeCounter;
}


VOID
CompleteDirectOutIrp(
    IN PIRP Irp,
    IN UCHAR Status,
    IN PLLC_CCB NextCcb
    )

/*++

Routine Description:

    For an IRP submitted as method DIRECT_OUT (DLC.CLOSE.STATION) complete the
    CCB in user space by getting the mapped system address of the CCB and update
    it with the completion code and next CCB pointer

Arguments:

    Irp     - pointer to DIRECT_OUT IRP to complete
    Status  - DLC status code
    NextCcb - pointer to next CCB to chain

Return Value:

    None.

--*/

{
    PLLC_CCB ccb;

    ccb = (PLLC_CCB)MmGetSystemAddressForMdl(Irp->MdlAddress);
    RtlStoreUlongPtr((PULONG_PTR)&ccb->pNext, (ULONG_PTR)NextCcb);
    ccb->uchDlcStatus = Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcreq.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcreq.c

Abstract:

    This module handles the miscellaneous DLC requests (set & query information)

    Contents:
        DlcBufferFree
        DlcBufferGet
        DlcBufferCreate
        DlcConnectStation
        DlcFlowControl
        ResetLocalBusyBufferStates
        DlcReallocate
        DlcReset
        DirSetExceptionFlags
        CompleteAsyncCommand
        GetLinkStation
        GetSapStation
        GetStation
        DlcReadCancel
        DirOpenAdapter
        DirCloseAdapter
        CompleteDirCloseAdapter
        DlcCompleteCommand

Author:

    Antti Saarenheimo 22-Jul-1991 (o-anttis)

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>
#include "dlcdebug.h"

#if 0

//
// if DLC and LLC share the same driver then we can use macros to access fields
// in the BINDING_CONTEXT and ADAPTER_CONTEXT structures
//

#if DLC_AND_LLC
#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif
#include "llcdef.h"
#include "llctyp.h"
#include "llcapi.h"
#endif
#endif


NTSTATUS
DlcBufferFree(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure simply releases the given user buffers.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC address object
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_INADEQUATE_BUFFERS   - buffer pool does not exist
        DLC_STATUS_INVALID_STATION_ID   -
        DLC_STATUS_INVALID_BUFFER_LENGTH -

        NOTE!!!  BUFFER.FREE does not return error, if the
            given buffer is invalid, or released twice!!!

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (!pFileContext->hBufferPool) {
        return DLC_STATUS_INADEQUATE_BUFFERS;
    }

    //
    // The parameter list is a DLC desriptor array.
    // Get the number of descriptor elements in the array.
    //

    if (InputBufferLength != (sizeof(NT_DLC_BUFFER_FREE_PARMS)
                           - sizeof(LLC_TRANSMIT_DESCRIPTOR)
                           + pDlcParms->BufferFree.BufferCount
                           * sizeof(LLC_TRANSMIT_DESCRIPTOR))) {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }

    //
    // We refernce the buffer pool, because otherwise it may disappear
    // immeadiately after DLC_LEAVE (when the adapter is closed)
    //

    ReferenceBufferPool(pFileContext);

    //
    // Don't try to allocate 0 buffers, it will fail.
    //

    if (pDlcParms->BufferFree.BufferCount) {

        LEAVE_DLC(pFileContext);

        RELEASE_DRIVER_LOCK();

        status = BufferPoolDeallocate(pFileContext->hBufferPool,
                                      pDlcParms->BufferFree.BufferCount,
                                      pDlcParms->BufferFree.DlcBuffer
                                      );

        ACQUIRE_DRIVER_LOCK();

        ENTER_DLC(pFileContext);

        //
        // Reset the local busy states, if there is now enough
        // buffers the receive the expected stuff.
        //

        if (!IsListEmpty(&pFileContext->FlowControlQueue)
        && BufGetUncommittedSpace(pFileContext->hBufferPool) >= 0) {
            ResetLocalBusyBufferStates(pFileContext);
        }

#if LLC_DBG
        cFramesReleased++;
#endif

    }

    pDlcParms->BufferFree.cBuffersLeft = (USHORT)BufferPoolCount(pFileContext->hBufferPool);

    DereferenceBufferPool(pFileContext);

    return status;
}


NTSTATUS
DlcBufferGet(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure allocates the requested number or size of DLC buffers
    and returns them back to user in a single entry link list..

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT SegmentSize;
    UINT SizeIndex;
    UINT BufferSize;
    UINT PrevBufferSize;
    UINT cBuffersToGet;
    PDLC_BUFFER_HEADER pBufferHeader = NULL;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pFileContext->hBufferPool == NULL) {
        return DLC_STATUS_INADEQUATE_BUFFERS;
    }

    //
    // If the segment size is 0, then we return the optimal mix
    // of buffer for the requested size.  Non null buffer count defines
    // how many buffers having the requested size is returned.
    //

    cBuffersToGet = pDlcParms->BufferGet.cBuffersToGet;

/*******************************************************************************

#if PAGE_SIZE == 8192
    if (cBuffersToGet == 0) {
        cBuffersToGet = 1;
        SegmentSize = pDlcParms->BufferGet.cbBufferSize;
        SizeIndex = (UINT)(-1);
    } else if (pDlcParms->BufferGet.cbBufferSize <= 256) {
        SegmentSize = 256 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 5;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 512) {
        SegmentSize = 512 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 4;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 1024) {
        SegmentSize = 1024 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 3;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 2048) {
        SegmentSize = 2048 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 2;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 4096) {
        SegmentSize = 4096 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 1;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 8192) {
        SegmentSize = 8192 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 0;
    } else {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
#elif PAGE_SIZE == 4096
    if (cBuffersToGet == 0) {
        cBuffersToGet = 1;
        SegmentSize = pDlcParms->BufferGet.cbBufferSize;
        SizeIndex = (UINT)(-1);
    } else if (pDlcParms->BufferGet.cbBufferSize <= 256) {
        SegmentSize = 256 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 4;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 512) {
        SegmentSize = 512 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 3;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 1024) {
        SegmentSize = 1024 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 2;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 2048) {
        SegmentSize = 2048 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 1;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 4096) {
        SegmentSize = 4096 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 0;
    } else {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
#else
#error "Target machine page size not 4096 or 8192"
#endif

*******************************************************************************/

#if defined(ALPHA)
    if (cBuffersToGet == 0) {
        cBuffersToGet = 1;
        SegmentSize = pDlcParms->BufferGet.cbBufferSize;
        SizeIndex = (UINT)(-1);
    } else if (pDlcParms->BufferGet.cbBufferSize <= 256) {
        SegmentSize = 256 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 5;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 512) {
        SegmentSize = 512 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 4;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 1024) {
        SegmentSize = 1024 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 3;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 2048) {
        SegmentSize = 2048 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 2;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 4096) {
        SegmentSize = 4096 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 1;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 8192) {
        SegmentSize = 8192 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 0;
    } else {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
#else
    if (cBuffersToGet == 0) {
        cBuffersToGet = 1;
        SegmentSize = pDlcParms->BufferGet.cbBufferSize;
        SizeIndex = (UINT)(-1);
    } else if (pDlcParms->BufferGet.cbBufferSize <= 256) {
        SegmentSize = 256 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 4;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 512) {
        SegmentSize = 512 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 3;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 1024) {
        SegmentSize = 1024 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 2;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 2048) {
        SegmentSize = 2048 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 1;
    } else if (pDlcParms->BufferGet.cbBufferSize <= 4096) {
        SegmentSize = 4096 - sizeof(NEXT_DLC_SEGMENT);
        SizeIndex = 0;
    } else {
        return DLC_STATUS_INVALID_BUFFER_LENGTH;
    }
#endif

    //
    // We refernce the buffer pool, because otherwise it may disappear
    // immeadiately after DLC_LEAVE (when the adapter is closed)
    //

    ReferenceBufferPool(pFileContext);

    //
    // We don't need to initialize the LAN and DLC header sizes
    // in the buffer header and we allocate the requested
    // frame as a single buffer.
    //

    BufferSize = SegmentSize * cBuffersToGet;
    if (BufferSize != 0) {

        pBufferHeader = NULL;
        PrevBufferSize = 0;

        LEAVE_DLC(pFileContext);

        do {

            //
            // We must again do this interlocked to avoid the buffer
            // pool to be deleted while we are allocating buffers.
            //

            Status = BufferPoolAllocate(
#if DBG
                        pFileContext,
#endif
                        (PDLC_BUFFER_POOL)pFileContext->hBufferPool,
                        BufferSize,
                        0,                  // FrameHeaderSize,
                        0,                  // UserDataSize,
                        0,                  // frame length
                        SizeIndex,          // fixed segment size set
                        &pBufferHeader,
                        &BufferSize
                        );

#if DBG
            BufferPoolExpand(pFileContext, (PDLC_BUFFER_POOL)pFileContext->hBufferPool);
#else
            BufferPoolExpand((PDLC_BUFFER_POOL)pFileContext->hBufferPool);
#endif

            //
            // Don't try to expand buffer pool any more, if it doesn't help!
            //

            if (BufferSize == PrevBufferSize) {
                break;
            }
            PrevBufferSize = BufferSize;

        } while (Status == DLC_STATUS_EXPAND_BUFFER_POOL);

        ENTER_DLC(pFileContext);

        if (pBufferHeader != NULL) {
            pBufferHeader->FrameBuffer.BufferState = BUF_USER;
        }

        if (Status == STATUS_SUCCESS) {
            pDlcParms->BufferGet.pFirstBuffer = (PLLC_XMIT_BUFFER)
                ((PUCHAR)pBufferHeader->FrameBuffer.pParent->Header.pLocalVa +
                  MIN_DLC_BUFFER_SEGMENT * pBufferHeader->FrameBuffer.Index);
        } else {
            BufferPoolDeallocateList(pFileContext->hBufferPool, pBufferHeader);
        }
    }

    pDlcParms->BufferGet.cBuffersLeft = (USHORT)BufferPoolCount(pFileContext->hBufferPool);

    DereferenceBufferPool(pFileContext);

    return Status;
}


NTSTATUS
DlcBufferCreate(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure creates a new buffer pool and allocates the initial
    space for it.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_DUPLICATE_COMMAND

--*/

{
    NTSTATUS status;
    PVOID newBufferAddress;
    ULONG newBufferSize;
    PVOID hExternalBufferPool;
    PVOID hBufferPool;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // if we already have a buffer pool defined for this handle, fail the
    // request
    //

    if (pFileContext->hBufferPool) {
        return DLC_STATUS_DUPLICATE_COMMAND;
    }

    hExternalBufferPool = pFileContext->hExternalBufferPool;

    LEAVE_DLC(pFileContext);

#if DBG
    status = BufferPoolCreate(pFileContext,
#else
    status = BufferPoolCreate(
#endif
                              pDlcParms->BufferCreate.pBuffer,
                              pDlcParms->BufferCreate.cbBufferSize,
                              pDlcParms->BufferCreate.cbMinimumSizeThreshold,
                              &hExternalBufferPool,
                              &newBufferAddress,
                              &newBufferSize
                              );

    ENTER_DLC(pFileContext);
    pFileContext->hExternalBufferPool = hExternalBufferPool;

    if (status == STATUS_SUCCESS) {

        //
        // The reference count keeps the buffer pool alive
        // when it is used (and simultaneously deleted by another
        // thread)
        //

        pFileContext->BufferPoolReferenceCount = 1;
	hBufferPool = pFileContext->hBufferPool;

	LEAVE_DLC(pFileContext);

        status = BufferPoolReference(hExternalBufferPool,
                                     &hBufferPool
                                     );
	
	ENTER_DLC(pFileContext);
	pFileContext->hBufferPool = hBufferPool;
        pDlcParms->BufferCreate.hBufferPool = pFileContext->hExternalBufferPool;
    }

    //    ENTER_DLC(pFileContext);

    return status;
}


NTSTATUS
DlcConnectStation(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure connects an local link station to a remote node
    or accepts a remote connection request.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    PDLC_OBJECT pLinkStation;
    NTSTATUS Status;
    PUCHAR pSourceRouting = NULL;
    PDLC_COMMAND pPacket;

    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // Procedure checks the sap and link station ids and
    // returns the requested link station.
    // The error status indicates a wrong sap or station id.
    //

    Status = GetLinkStation(pFileContext,
                            pDlcParms->Async.Parms.DlcConnectStation.StationId,
                            &pLinkStation
                            );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    pPacket = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pPacket == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    pPacket->pIrp = pIrp;

    //
    // IBM LAN Tech. Ref p 3-48 (DLC.CONNECT.STATION) states that ROUTING_ADDR
    // field is ignored if the link was created due to receipt of a SABME from
    // the remote station, EVEN IF THE ADDRESS IS NON-ZERO
    //

    if (pDlcParms->Async.Parms.DlcConnectStation.RoutingInformationLength != 0) {
        pSourceRouting = pDlcParms->Async.Parms.DlcConnectStation.aRoutingInformation;
    }
    pLinkStation->PendingLlcRequests++;
    ReferenceLlcObject(pLinkStation);

    LEAVE_DLC(pFileContext);

    //
    // LlcConnect returns the maximum information field,
    // through the tr bridges!
    //

    LlcConnectStation(pLinkStation->hLlcObject,
                      (PLLC_PACKET)pPacket,
                      pSourceRouting,
                      &pLinkStation->u.Link.MaxInfoFieldLength
                      );

    ENTER_DLC(pFileContext);

    DereferenceLlcObject(pLinkStation);

    return STATUS_PENDING;
}


NTSTATUS
DlcFlowControl(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure sets or resets the loacl busy state on the given link station
    or on all link stations of a sap station.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pDlcObject;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Procedure checks the sap and link station ids and
    // returns the requested link station.
    // The error status indicates a wrong sap or station id.
    //

    Status = GetStation(pFileContext,
                        pDlcParms->DlcFlowControl.StationId,
                        &pDlcObject
                        );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    //
    // We will queue all reset local busy buffer commands
    // given to the link stations
    //

    if (((pDlcParms->DlcFlowControl.FlowControlOption & LLC_RESET_LOCAL_BUSY_BUFFER) == LLC_RESET_LOCAL_BUSY_BUFFER)
    && (pDlcObject->Type == DLC_LINK_OBJECT)) {

        PDLC_RESET_LOCAL_BUSY_CMD pClearCmd;

        pClearCmd = (PDLC_RESET_LOCAL_BUSY_CMD)ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pClearCmd == NULL) {
            return DLC_STATUS_NO_MEMORY;
        }
        pClearCmd->StationId = pDlcParms->DlcFlowControl.StationId;
        pClearCmd->RequiredBufferSpace = 0;
        LlcInsertTailList(&pFileContext->FlowControlQueue, pClearCmd);
        ResetLocalBusyBufferStates(pFileContext);
    } else {
        ReferenceLlcObject(pDlcObject);

        LEAVE_DLC(pFileContext);

        Status = LlcFlowControl(pDlcObject->hLlcObject,
                                pDlcParms->DlcFlowControl.FlowControlOption
                                );

        ENTER_DLC(pFileContext);

        DereferenceLlcObject(pDlcObject);
    }
    return Status;
}


VOID
ResetLocalBusyBufferStates(
    IN PDLC_FILE_CONTEXT pFileContext
    )
/*++

Routine Description:

    Procedure executes the pending busy state resets when there is
    enough memory in the buffer pool to receive the expected data.

Arguments:

    pFileContext    - DLC adapter context

Return Value:

    None

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pDlcObject;
    PDLC_RESET_LOCAL_BUSY_CMD pClearCmd;

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // We cannot reset anything, if the buffer pool is not yet
    // defined.
    //

    if (pFileContext->hBufferPool == NULL) {
        return;
    }

    ReferenceBufferPool(pFileContext);

    while (!IsListEmpty(&pFileContext->FlowControlQueue)) {
        pClearCmd = LlcRemoveHeadList(&pFileContext->FlowControlQueue);

        Status = GetLinkStation(pFileContext,
                                pClearCmd->StationId,
                                &pDlcObject
                                );

        //
        // All commands having an invalid station id will be just removed
        // from the queue. The local busy state can be reset only
        // for the existing link stations
        //

        if (Status == STATUS_SUCCESS) {

            //
            // The required space is nul, when a mew packet is checked
            // in the first time, the non-null value just prevents
            // us to check the commited memory in the second time.
            //

            if (pClearCmd->RequiredBufferSpace == 0) {

                //
                // We must also remove the old uncommited space,
                // otherwise the same buffer size could be
                // committed several times, but uncommitted only once
                //

                if (pDlcObject->CommittedBufferSpace != 0) {
                    BufUncommitBuffers(pFileContext->hBufferPool,
                                       pDlcObject->CommittedBufferSpace
                                       );
                }

                pDlcObject->CommittedBufferSpace =
                pClearCmd->RequiredBufferSpace = LlcGetCommittedSpace(pDlcObject->hLlcObject);

                BufCommitBuffers(pFileContext->hBufferPool,
                                 pDlcObject->CommittedBufferSpace
                                 );
            }

            //
            // We are be removing a local buffer busy state =>
            // we must expand the buffer pools before the local busy
            // is removed, but only if we are not calling this
            // from a DPC level.
            //

            if (BufGetUncommittedSpace(pFileContext->hBufferPool) < 0) {

                LEAVE_DLC(pFileContext);

#if DBG
                BufferPoolExpand(pFileContext, pFileContext->hBufferPool);
#else
                BufferPoolExpand(pFileContext->hBufferPool);
#endif

                ENTER_DLC(pFileContext);
            }

            //
            // Now we have expanded the buffer pool for the new
            // flow control command, check if we have now enough
            // memory to receive the commited size of data.
            //

            if (BufGetUncommittedSpace(pFileContext->hBufferPool) >= 0
            && pDlcObject->hLlcObject != NULL) {

                ReferenceLlcObject(pDlcObject);

                LEAVE_DLC(pFileContext);

                Status = LlcFlowControl(pDlcObject->hLlcObject,
                                        LLC_RESET_LOCAL_BUSY_BUFFER
                                        );

                ENTER_DLC(pFileContext);

                DereferenceLlcObject(pDlcObject);
            } else {

                //
                // We must exit this loop when there is not enough available
                // space in the buffer pool, but we must return
                // the command back to the head of the list
                //

                LlcInsertHeadList(&pFileContext->FlowControlQueue, pClearCmd);
                break;
            }
        }

        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pClearCmd);

    }

    DereferenceBufferPool(pFileContext);
}


NTSTATUS
DlcReallocate(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure changes the number of link stations allocated to a SAP
    without closing or reopening the sap station.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    PDLC_OBJECT pSap;
    UCHAR ExtraStations;
    UCHAR StationCount;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // Procedure checks the sap and returns the requested sap station.
    // The error status indicates an invalid sap station id.
    //

    Status = GetSapStation(pFileContext,
                           pDlcParms->DlcReallocate.usStationId,
                           &pSap
                           );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    //
    // The new link station count must be more than current number
    // of open link stations but less than the available number
    // of link stations for the file context
    //

    StationCount = pDlcParms->DlcReallocate.uchStationCount;
    if (StationCount != 0 && Status == STATUS_SUCCESS) {

        //
        // Bit7 set in options => decrease the number of available
        // stations by the given station count.  Otherwise we increase it.
        //

        if (pDlcParms->DlcReallocate.uchOption & 0x80) {
            ExtraStations = pSap->u.Sap.MaxStationCount - pSap->u.Sap.LinkStationCount;
            if (StationCount > ExtraStations) {
                StationCount = ExtraStations;
                Status = DLC_STATUS_INADEQUATE_LINKS;
            }
            pFileContext->LinkStationCount += StationCount;
            pSap->u.Sap.MaxStationCount -= StationCount;
        } else {
            if (pFileContext->LinkStationCount < StationCount) {
                StationCount = pFileContext->LinkStationCount;
                Status = DLC_STATUS_INADEQUATE_LINKS;
            }
            pFileContext->LinkStationCount -= StationCount;
            pSap->u.Sap.MaxStationCount += StationCount;
        }
    }

    //
    // Set the return parameters even if there would be an error
    // (inadequate stations is a non fatal error)
    //

    pDlcParms->DlcReallocate.uchStationsAvailOnAdapter = pFileContext->LinkStationCount;
    pDlcParms->DlcReallocate.uchStationsAvailOnSap = pSap->u.Sap.MaxStationCount - pSap->u.Sap.LinkStationCount;
    pDlcParms->DlcReallocate.uchTotalStationsOnAdapter = MAX_LINK_STATIONS;
    pDlcParms->DlcReallocate.uchTotalStationsOnSap = pSap->u.Sap.MaxStationCount;
    return Status;
}


NTSTATUS
DlcReset(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure closes immediately a sap and its all link stations or
    all saps and all link stations.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        STATUS_PENDING
        DLC_STATUS_NO_MEMORY
--*/

{
    PDLC_OBJECT pDlcObject;
    PDLC_CLOSE_WAIT_INFO pClosingInfo;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // Station id 0 resets the whole DLC
    //

    if (pDlcParms->Async.Ccb.u.dlc.usStationId == 0) {

        PDLC_CLOSE_WAIT_INFO pClosingInfo;

        pClosingInfo = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pClosingInfo == NULL) {
            Status = DLC_STATUS_NO_MEMORY;
        } else {
            CloseAllStations(pFileContext,
                             pIrp,
                             DLC_COMMAND_COMPLETION,
                             NULL,
                             pDlcParms,
                             pClosingInfo
                             );
            Status = STATUS_PENDING;
        }
    } else {

        BOOLEAN allClosed;

        //
        // We have a specific sap station
        //

        Status = GetSapStation(pFileContext,
                               pDlcParms->Async.Ccb.u.dlc.usStationId,
                               &pDlcObject
                               );
        if (Status != STATUS_SUCCESS) {
            return Status;
        }

        //
        // Allocate the close/reset command completion info,
        // the station count is the number of link stations and
        // the sap station itself
        //

        pClosingInfo = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

        if (pClosingInfo == NULL) {
            return DLC_STATUS_NO_MEMORY;
        }
        pClosingInfo->pIrp = pIrp;
        pClosingInfo->Event = DLC_COMMAND_COMPLETION;
        pClosingInfo->CancelStatus = DLC_STATUS_CANCELLED_BY_USER;
        pClosingInfo->CloseCounter = 1; // keep command alive over sync path

        (USHORT)(pDlcObject->u.Sap.LinkStationCount + 1);

        CloseAnyStation(pDlcObject, pClosingInfo, FALSE);

        //
        // RLF 05/09/93
        //
        // PC/3270 (DOS program) is hanging forever when we try to quit.
        // It is doing this because we returned STATUS_PENDING to a DLC.RESET,
        // even though the reset completed; the DOS program spins forever on
        // the CCB.uchDlcStatus field, waiting for it to go non-0xFF, which it
        // will never do.
        //
        // If we determine that the station has been reset (all links closed)
        // then return success, else pending
        //

        allClosed = DecrementCloseCounters(pFileContext, pClosingInfo);

        //
        // RLF 07/21/92 Always return PENDING. Can't complete before return?
        //

        Status = allClosed ? STATUS_SUCCESS : STATUS_PENDING;
    }
    return Status;
}


NTSTATUS
DirSetExceptionFlags(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure sets the exception flags for the current adapter context.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    pFileContext->AdapterCheckFlag = pDlcParms->DirSetExceptionFlags.ulAdapterCheckFlag;
    pFileContext->NetworkStatusFlag = pDlcParms->DirSetExceptionFlags.ulNetworkStatusFlag;
    pFileContext->PcErrorFlag = pDlcParms->DirSetExceptionFlags.ulPcErrorFlag;
    pFileContext->SystemActionFlag = pDlcParms->DirSetExceptionFlags.ulSystemActionFlag;
    return STATUS_SUCCESS;
}


VOID
CompleteAsyncCommand(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN UINT Status,
    IN PIRP pIrp,
    IN PVOID pUserCcbPointer,
    IN BOOLEAN InCancel
    )

/*++

Routine Description:

    Procedure completes an asynchronous DLC command.
    It also copies the optional output parameters to user parameter
    table, if there is the second output buffer.

Arguments:

    pFileContext    - DLC driver client context.
    Status          - status of the complete command.
    pIrp            - the completed I/O request packet.
    pUserCcbPointer - the next CCB address to which the command will be linked.
    InCancel        - TRUE if called on Irp cancel path

Return Value:

    None.

--*/

{
    PNT_DLC_PARMS pDlcParms;

    UNREFERENCED_PARAMETER(pFileContext);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("CompleteAsyncCommand");

    pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

    //
    // We first map the 32-bit DLC driver status code to 8- bit API status
    //

    if (Status == STATUS_SUCCESS) {
        pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)STATUS_SUCCESS;
    } else if (Status >= DLC_STATUS_ERROR_BASE && Status < DLC_STATUS_MAX_ERROR) {

        //
        //  We can map the normal DLC error codes directly to the 8-bit
        //  DLC API error codes.
        //

        pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)(Status - DLC_STATUS_ERROR_BASE);
    } else {

        //
        // we have an unknown NT error status => we will return it in the CCB
        //

        pDlcParms->Async.Ccb.uchDlcStatus = (UCHAR)(DLC_STATUS_NT_ERROR_STATUS & 0xff);
    }
    pDlcParms->Async.Ccb.pCcbAddress = pUserCcbPointer;

    //
    // We always return success status to the I/O system. The actual status is
    // copied to the CCB (= the dafault output buffer)
    //

    LEAVE_DLC(pFileContext);

    RELEASE_DRIVER_LOCK();

    DlcCompleteIoRequest(pIrp, InCancel);

    ACQUIRE_DRIVER_LOCK();

    ENTER_DLC(pFileContext);

    DereferenceFileContext(pFileContext);
}


NTSTATUS
GetLinkStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppLinkStation
    )

/*++

Routine Description:

    Procedure checks and returns link station

Arguments:

    pFileContext    - DLC driver client context
    StationId       - DLC station id (ssnn, where ss = sap and nn = link station id
    ppDlcObject     - the returned link station

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_INVALID_SAP_VALUE
        DLC_STATUS_INVALID_STATION_ID

--*/

{
    if ((StationId & 0xff) == 0 || (StationId & 0xff00) == 0) {
        return DLC_STATUS_INVALID_STATION_ID;
    }
    return GetStation(pFileContext, StationId, ppLinkStation);
}


NTSTATUS
GetSapStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppStation
    )

/*++

Routine Description:

    Procedure checks and returns link station

Arguments:

    pFileContext    - DLC driver client context
    StationId       - DLC station id (ssnn, where ss = sap and nn = link station id
    ppDlcObject     - the returned link station

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_INVALID_SAP_VALUE
        DLC_STATUS_INVALID_STATION_ID

--*/

{
    UINT SapId = StationId >> 9;

    if (SapId >= MAX_SAP_STATIONS
    || SapId == 0
    || (StationId & GROUP_SAP_BIT)
    || (*ppStation = pFileContext->SapStationTable[SapId]) == NULL
    || (*ppStation)->State != DLC_OBJECT_OPEN) {
        return DLC_STATUS_INVALID_SAP_VALUE;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
GetStation(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN USHORT StationId,
    OUT PDLC_OBJECT *ppStation
    )

/*++

Routine Description:

    Procedure checks the given station id and returns a pointer to
    sap, direct or link station object.

Arguments:

    pFileContext    - DLC driver client context
    StationId       - DLC station id (ssnn, where ss = sap and nn = link station id
    ppStation       - the returned station object

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_INVALID_STATION_ID

--*/

{
    UINT SapId = StationId >> 9;

    //
    // Check if the sap or direct station exists,
    // but check also the link station, if we found a valid sap id.
    //

    if (SapId >= MAX_SAP_STATIONS
    || (StationId & GROUP_SAP_BIT)
    || (*ppStation = pFileContext->SapStationTable[SapId]) == NULL
    || (*ppStation)->State != DLC_OBJECT_OPEN) {
        if (SapId == 0) {
            return DLC_STATUS_DIRECT_STATIONS_NOT_AVAILABLE;
        } else {
            return DLC_STATUS_INVALID_STATION_ID;
        }
    }

    //
    // The link station table will never be read, if we have found
    // a valid sap or direct station.  Link station must exist and
    // it must be opened.
    //

    if (SapId != 0
    && (StationId & 0xff) != 0
    && (*ppStation = pFileContext->LinkStationTable[((StationId & 0xff) - 1)]) == NULL
    || (*ppStation)->State != DLC_OBJECT_OPEN) {
        return DLC_STATUS_INVALID_STATION_ID;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
DlcReadCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive cancels a READ command, that have the given CCB pointer.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    DLC_STATUS:
        STATUS_SUCCESS

--*/

{
    PVOID pCcbAddress = NULL;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    DLC_TRACE('Q');

    return AbortCommand(pFileContext,
                        (USHORT)DLC_IGNORE_STATION_ID,
                        (USHORT)DLC_STATION_MASK_SPECIFIC,
                        pDlcParms->DlcCancelCommand.CcbAddress,
                        &pCcbAddress,
                        DLC_STATUS_CANCELLED_BY_USER,
                        TRUE    // Suppress completion
                        );
}


NTSTATUS
DirOpenAdapter(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive binds the DLC API driver to an adapter context of
    the LLC module.  The LLC mode may also bind to the given NDIS driver
    and open it, if this is the first reference to the driver from DLC.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    DLC_STATUS:
        STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    UINT OpenErrorCode;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    if (pDlcParms->DirOpenAdapter.NtDlcIoctlVersion != NT_DLC_IOCTL_VERSION) {
        return DLC_STATUS_INVALID_VERSION;
    }

    //
    // This makes the DirOpenAdapter safe, even if there were two adapter
    // opens going on simultaneously
    //

    //
    // RLF 04/22/94
    //
    // this only protects against 2 threads in the same process performing
    // simultaneous opens on the same adapter
    //

    if (pFileContext->pBindingContext) {
        return DLC_STATUS_DUPLICATE_COMMAND;
    }
    pFileContext->pBindingContext = (PVOID)-1;

    //
    // if a buffer pool handle was supplied (i.e. the app already created a
    // buffer pool or is otherwise sharing one) then reference it for this
    // file context
    //

    if (pDlcParms->DirOpenAdapter.hBufferPoolHandle) {
        Status = BufferPoolReference(pDlcParms->DirOpenAdapter.hBufferPoolHandle,
                                     &pFileContext->hBufferPool
                                     );
        if (Status == STATUS_SUCCESS) {
            pFileContext->BufferPoolReferenceCount = 1;
            pFileContext->hExternalBufferPool = pDlcParms->DirOpenAdapter.hBufferPoolHandle;
        } else {

            //
            // Invalid buffer pool handle, hopefully this status
            // code indicates correctly, that the buffer pool
            // handle is not valid.
            //

			pFileContext->pBindingContext = NULL;
            return DLC_STATUS_INVALID_BUFFER_LENGTH;
        }
    }

    LEAVE_DLC(pFileContext);

    //
    // XXXXXXX: BringUpDiagnostics are still missing!!!
    //

    //
    // RLF 04/19/93
    //
    // The string we pass to LlcOpenAdapter is a pointer to a zero terminated
    // wide character string, NOT a pointer to a UNICODE_STRING structure. The
    // string MUST be in system memory space, i.e. copied across the kernel
    // interface by NtDeviceIoControlFile
    //

    Status = LlcOpenAdapter(&pDlcParms->DirOpenAdapter.Buffer[0],
                            (PVOID)pFileContext,
                            LlcCommandCompletion,
                            LlcReceiveIndication,
                            LlcEventIndication,
                            NdisMedium802_5,    // Always token-ring!
                            pDlcParms->DirOpenAdapter.LlcEthernetType,
                            pDlcParms->DirOpenAdapter.AdapterNumber,
                            &pFileContext->pBindingContext,
                            &OpenErrorCode,
                            &pFileContext->MaxFrameLength,
                            &pFileContext->ActualNdisMedium
                            );

    //
    // make sure LlcOpenAdapter didn't return with lowered IRQL
    //

    ASSUME_IRQL(DISPATCH_LEVEL);

    //
    // IBM LAN Tech. Ref. defines the open error code as a 16-bit value, the
    // high 8 bits of which are 0. The MAC inclusive-ORs the open error code
    // into the NDIS status. Extract it
    //

    pDlcParms->DirOpenAdapter.Adapter.usOpenErrorCode = (USHORT)(UCHAR)OpenErrorCode;
    if (Status != STATUS_SUCCESS) {

        ENTER_DLC(pFileContext);

        //
        // It does not matter, if we have null buffer pool handle!
        //

#if DBG

        BufferPoolDereference(pFileContext,
                              (PDLC_BUFFER_POOL*)&pFileContext->hBufferPool
                              );

#else

        BufferPoolDereference((PDLC_BUFFER_POOL*)&pFileContext->hBufferPool);

#endif

        //
        // set the BINDING_CONTEXT pointer back to NULL - other routines check
        // for this value, like CloseAdapterFileContext
        //

        pFileContext->pBindingContext = NULL;

        //
        // Probably the adapter was missing or it was installed improperly
        //

        Status = DLC_STATUS_ADAPTER_NOT_INSTALLED;
    } else {

        //
        // Set the optional timer tick one/two values
        // (if they have been set in registry)
        //

        LlcSetInformation(pFileContext->pBindingContext,
                          DLC_INFO_CLASS_DLC_TIMERS,
                          (PLLC_SET_INFO_BUFFER)&(pDlcParms->DirOpenAdapter.LlcTicks),
                          sizeof(LLC_TICKS)
                          );

        LlcQueryInformation(pFileContext->pBindingContext,
                            DLC_INFO_CLASS_DIR_ADAPTER,
                            (PLLC_QUERY_INFO_BUFFER)pDlcParms->DirOpenAdapter.Adapter.auchNodeAddress,
                            sizeof(LLC_ADAPTER_INFO)
                            );

        ENTER_DLC(pFileContext);

        //
        // take the missing parameters from the hat
        //

        pDlcParms->DirOpenAdapter.Adapter.usOpenOptions = 0;
        pDlcParms->DirOpenAdapter.Adapter.usMaxFrameSize = (USHORT)(pFileContext->MaxFrameLength + 6);
        pDlcParms->DirOpenAdapter.Adapter.usBringUps = 0;
        pDlcParms->DirOpenAdapter.Adapter.InitWarnings = 0;

        pFileContext->AdapterNumber = pDlcParms->DirOpenAdapter.AdapterNumber;
        pFileContext->LinkStationCount = 255;
        pFileContext->pSecurityDescriptor = pDlcParms->DirOpenAdapter.pSecurityDescriptor;

        //
        // Read the most recent cumulative NDIS error counters
        // to the file context. DLC error counters will be counted
        // from 0 and they may be reset.
        //

        GetDlcErrorCounters(pFileContext, NULL);
        pFileContext->State = DLC_FILE_CONTEXT_OPEN;
    }

    //
    // We may directly return whatever the LLC binding primitive gives us
    //

    return Status;
}


NTSTATUS
DirCloseAdapter(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive initializes the close adapter operation.
    It first closes all open link and sap stations and
    then optionally chains the canceled commands and
    receive buffers to a READ command.  If no read commands
    was found, then the CCBs are linked to the CCB pointer
    of this command.

    The actual file close should only delete the file
    object, except, if the application exits, when it still has
    open dlc api handles. In that case the file close routine
    will call this procedure to shut down the dlc file context.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS

        STATUS_PENDING
            The adapter is being closed

        DLC_STATUS_ADAPTER_CLOSED
            The adapter is already closed

            NOTE: This is a SYNCHRONOUS return code! And will cause the IRP
                  to be completed

--*/

{
    UNREFERENCED_PARAMETER(pDlcParms);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("DirCloseAdapter");

    DLC_TRACE('J');

    if (pFileContext->State != DLC_FILE_CONTEXT_OPEN) {
        return DLC_STATUS_ADAPTER_CLOSED;
    }

#if LLC_DBG == 2
    DbgPrint( "*** Top memory consumption (before adapter close) *** \n" );
    PrintMemStatus();
#endif

    //
    // This disables any further commands (including DirCloseAdapter)
    //

    pFileContext->State = DLC_FILE_CONTEXT_CLOSE_PENDING;

    //
    // Remove first all functional, group or multicast addresses
    // set in the adapter by the current DLC application process
    //

    if (pFileContext->pBindingContext) {

        LEAVE_DLC(pFileContext);

        LlcResetBroadcastAddresses(pFileContext->pBindingContext);

        ENTER_DLC(pFileContext);
    }

    //
    // We must use the static closing packet, because the adapter close
    // must succeed even if we could not allocate any packets
    //

    CloseAllStations(pFileContext,
                     pIrp,
                     DLC_COMMAND_COMPLETION,
                     CompleteDirCloseAdapter,
                     pDlcParms,
                     &pFileContext->ClosingPacket
                     );

    return STATUS_PENDING;
}


VOID
CompleteDirCloseAdapter(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbLink
    )

/*++

Routine Description:

    Finishes DIR.CLOSE.ADAPTER command

Arguments:

    pFileContext    - DLC adapter open context
    pClosingInfo    - packet structure, that includes all data of this command
    pCcbLink        - the orginal user mode ccb address on the next CCB, that
                      will be chained to the completed command.

Return Value:

    None

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('K');

    //
    // reference the file context to stop any of the dereferences below, or in
    // functions called by this routine destroying it
    //

    ReferenceFileContext(pFileContext);

    //
    // Disconnect (or unbind) llc driver from us
    //

    if (pFileContext->pBindingContext) {

        LEAVE_DLC(pFileContext);

        LlcDisableAdapter(pFileContext->pBindingContext);

        ENTER_DLC(pFileContext);
    }
    if (IoGetCurrentIrpStackLocation(pClosingInfo->pIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
        CompleteAsyncCommand(pFileContext, STATUS_SUCCESS, pClosingInfo->pIrp, pCcbLink, FALSE);
    } else {

        //
        // This is a normal FILE CLOSE !!! (IRP_MJ_CLEANUP)
        //

        ASSERT(IoGetCurrentIrpStackLocation(pClosingInfo->pIrp)->MajorFunction == IRP_MJ_CLEANUP);
        
        //
        // Dereference for the cleanup. This will allow cleanup to become
        // unblocked.
        //

        DereferenceFileContext(pFileContext);
    }

    //
    // We must delete the buffer pool now, because the dereference
    // of the driver object starts the final process exit
    // completion, that bug chekcs, if the number of the locked
    // pages is non zero.
    //

    DereferenceBufferPool(pFileContext);

    //
    // We create two references for file context, when it is created
    // the other is decremented here and the other when the synchronous
    // part of command completion has been done
    //

    pFileContext->State = DLC_FILE_CONTEXT_CLOSED;

    //
    // This should be the last reference of the file context
    // (if no IRPs operations are in execution or pending.
    //

    DereferenceFileContext(pFileContext);
}


NTSTATUS
DlcCompleteCommand(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure queues the given CCB to the completion list.
    This routine is used to save the synchronous commands from
    DLC API DLL to event queue.  This must be done whenever a
    synchronous command has a non null command completion flag.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC address object
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  -

Return Value:

    NTSTATUS:
        STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    if (pDlcParms->CompleteCommand.CommandCompletionFlag == 0
    || pDlcParms->CompleteCommand.pCcbPointer == NULL) {

        //
        // This is more likely an internal error!
        //

        return DLC_STATUS_INTERNAL_ERROR;
    }
    return MakeDlcEvent(pFileContext,
                        DLC_COMMAND_COMPLETION,
                        pDlcParms->CompleteCommand.StationId,
                        NULL,
                        pDlcParms->CompleteCommand.pCcbPointer,
                        pDlcParms->CompleteCommand.CommandCompletionFlag,
                        FALSE
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcreg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcreg.c

Abstract:

    This module accesses the registry for DLC.SYS

    Contents:
        DlcRegistryInitialization
        LoadDlcConfiguration
        LoadAdapterConfiguration
        GetAdapterParameters
        OpenDlcRegistryHandle
        OpenDlcAdapterRegistryHandle
        GetRegistryParameter
        SetRegistryParameter
        DlcpGetParameter
        DlcRegistryTermination

Author:

    Richard L Firth (rfirth) 31-Mar-1993

Environment:

    kernel mode only

Revision History:

    30-Mar-1993 rfirth
        created

    04-May-1994 rfirth
        Exposed GetAdapterParameters

--*/

#include <ntddk.h>
#include <windef.h>
#include <dlcapi.h>
#include <dlcio.h>
#include <ndis.h>
#include "llcapi.h"
#include "dlcdef.h"
#include "dlcreg.h"
#include "dlctyp.h"
#include "llcdef.h"
#include "llcmem.h"
#include "llctyp.h"
#include "llcext.h"

//
// manifests
//

#define MAX_ADAPTER_NAME_LENGTH 32  // ?
#define MAX_INFORMATION_BUFFER_LENGTH   256 // ?
#define PARAMETERS_STRING       L"Parameters"

//
// indicies of parameters within parameter table
//

#define SWAP_INDEX              0
#define USEDIX_INDEX            1
#define T1_TICK_ONE_INDEX       2
#define T2_TICK_ONE_INDEX       3
#define Ti_TICK_ONE_INDEX       4
#define T1_TICK_TWO_INDEX       5
#define T2_TICK_TWO_INDEX       6
#define Ti_TICK_TWO_INDEX       7
#define FRAME_SIZE_INDEX        8

//
// typedefs
//

//
// macros
//

#define CloseDlcRegistryHandle(handle)      ZwClose(handle)
#define CloseAdapterRegistryHandle(handle)  ZwClose(handle)

//
// Global data
//

//
// private data
//

UNICODE_STRING DlcRegistryPath;
UNICODE_STRING ParametersPath;

//
// AdapterParameterTable - used for loading DLC parameters from registry in
// data-driven manner. Each adapter that DLC talks to can have a set of all
// or part of the following variables
//

DLC_REGISTRY_PARAMETER AdapterParameterTable[] = {
    L"Swap",
    (PVOID)DEFAULT_SWAP_ADDRESS_BITS,
    {
        REG_DWORD,
        PARAMETER_IS_BOOLEAN,
        NULL,
        sizeof(ULONG),
        NULL,
        0,
        0
    },

    L"UseDixOverEthernet",
    (PVOID)DEFAULT_DIX_FORMAT,
    {
        REG_DWORD,
        PARAMETER_IS_BOOLEAN,
        NULL,
        sizeof(ULONG),
        NULL,
        0,
        0
    },

    L"T1TickOne",
    (PVOID)DEFAULT_T1_TICK_ONE,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"T2TickOne",
    (PVOID)DEFAULT_T2_TICK_ONE,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"TiTickOne",
    (PVOID)DEFAULT_Ti_TICK_ONE,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"T1TickTwo",
    (PVOID)DEFAULT_T1_TICK_TWO,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"T2TickTwo",
    (PVOID)DEFAULT_T2_TICK_TWO,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"TiTickTwo",
    (PVOID)DEFAULT_Ti_TICK_TWO,
    {
        REG_DWORD,
        PARAMETER_IS_UCHAR,
        NULL,
        sizeof(ULONG),
        NULL,
        MIN_TIMER_TICK_VALUE,
        MAX_TIMER_TICK_VALUE
    },

    L"UseEthernetFrameSize",
    (PVOID)DEFAULT_USE_ETHERNET_FRAME_SIZE,
    {
        REG_DWORD,
        PARAMETER_IS_BOOLEAN,
        NULL,
        sizeof(ULONG),
        NULL,
        0,
        0
    }
};

#ifdef NDIS40
DLC_REGISTRY_PARAMETER AdapterInitTimeout = 
{
    L"WaitForAdapter",
    (PVOID) 15, // Default is 15 seconds.
    {
        REG_DWORD,
        PARAMETER_AS_SPECIFIED,
        NULL,
        sizeof(ULONG),
        NULL,
        0, // Min acceptable value
        (ULONG) -1 // Allow to set anything.
    }
};
#endif // NDIS40

#define NUMBER_OF_DLC_PARAMETERS (sizeof(AdapterParameterTable)/sizeof(AdapterParameterTable[0]))

//
// private function prototypes
//

NTSTATUS
OpenDlcRegistryHandle(
    IN PUNICODE_STRING RegistryPath,
    OUT PHANDLE DlcRegistryHandle
    );

NTSTATUS
OpenDlcAdapterRegistryHandle(
    IN HANDLE DlcRegistryHandle,
    IN PUNICODE_STRING AdapterName,
    OUT PHANDLE DlcAdapterRegistryHandle,
    OUT PBOOLEAN Created
    );

NTSTATUS
GetRegistryParameter(
    IN HANDLE KeyHandle,
    IN PDLC_REGISTRY_PARAMETER Parameter,
    IN BOOLEAN SetOnFail
    );

NTSTATUS
SetRegistryParameter(
    IN HANDLE KeyHandle,
    IN PDLC_REGISTRY_PARAMETER Parameter
    );

NTSTATUS
DlcpGetParameter(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

//
// debug display options
//

#if DBG
BOOLEAN DebugConfig = TRUE;
#endif


//
// functions
//

VOID
DlcRegistryInitialization(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Initializes memory structures for functions in this module

Arguments:

    RegistryPath    - pointer to UNICODE_STRING giving base of DLC section in
                      registry

Return Value:

    None.

--*/

{
    ASSUME_IRQL(PASSIVE_LEVEL);

    LlcInitUnicodeString(&DlcRegistryPath, RegistryPath);
    RtlInitUnicodeString(&ParametersPath, PARAMETERS_STRING);
}


VOID
DlcRegistryTermination(
    VOID
    )

/*++

Routine Description:

    Undoes anything done in DlcRegistryInitialization

Arguments:

    None.

Return Value:

    None.

--*/

{
    ASSUME_IRQL(PASSIVE_LEVEL);

    LlcFreeUnicodeString(&DlcRegistryPath);
}


VOID
LoadDlcConfiguration(
    VOID
    )

/*++

Routine Description:

    Initializes the data structures used to access the registry and loads any
    configuration parameters for the driver

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // nothing else to do at present since we made all currently known
    // configuration parameters per-adapter
    //
}


VOID
LoadAdapterConfiguration(
    IN PUNICODE_STRING AdapterName,
    OUT PADAPTER_CONFIGURATION_INFO ConfigInfo
    )

/*++

Routine Description:

    Loads all of DLC initialization parameters for an adapter from registry:

        Swap                    0 or 1, default 1
        UseDixOverEthernet      0 or 1, default 0
        T1TickOne               1 - 255, default 5
        T1TickTwo               1 - 255, default 25
        T2TickOne               1 - 255, default 1
        T2TickTwo               1 - 255, default 10
        TiTickOne               1 - 255, default 25
        TiTickTwo               1 - 255, default 125
        UseEthernetFrameSize    0 or 1, default 1

    If any of the parameters do not exist in the DLC\Parameters\<AdapterName>
    section, then they are created

Arguments:

    AdapterName - pointer to UNICODE_STRING structure giving the name of the
                  adapter we are opening. This is the value of a key in the
                  DLC\Parameters section.
                  The string is EXPECTED to be of the form \Device\<adapter>
    ConfigInfo  - pointer to the structure that receives the values on output

Return Value:

    None.

--*/

{
    UINT i;
    PDLC_REGISTRY_PARAMETER parameterTable;

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // fill in the adapter configuration structure with default values. These
    // will be used to update the registry if the value entry doesn't currently
    // exist
    //

    ConfigInfo->SwapAddressBits = (BOOLEAN)DEFAULT_SWAP_ADDRESS_BITS;
    ConfigInfo->UseDix = (BOOLEAN)DEFAULT_DIX_FORMAT;
    ConfigInfo->TimerTicks.T1TickOne = (UCHAR)DEFAULT_T1_TICK_ONE;
    ConfigInfo->TimerTicks.T2TickOne = (UCHAR)DEFAULT_T2_TICK_ONE;
    ConfigInfo->TimerTicks.TiTickOne = (UCHAR)DEFAULT_Ti_TICK_ONE;
    ConfigInfo->TimerTicks.T1TickTwo = (UCHAR)DEFAULT_T1_TICK_TWO;
    ConfigInfo->TimerTicks.T2TickTwo = (UCHAR)DEFAULT_T2_TICK_TWO;
    ConfigInfo->TimerTicks.TiTickTwo = (UCHAR)DEFAULT_Ti_TICK_TWO;
    ConfigInfo->UseEthernetFrameSize = (BOOLEAN)DEFAULT_USE_ETHERNET_FRAME_SIZE;

    //
    // create and initialize a copy of the DLC adapter parameters template
    //

    parameterTable = (PDLC_REGISTRY_PARAMETER)ALLOCATE_MEMORY_DRIVER(
                            sizeof(*parameterTable) * NUMBER_OF_DLC_PARAMETERS);
    if (parameterTable) {
        RtlCopyMemory(parameterTable, AdapterParameterTable, sizeof(AdapterParameterTable));
        for (i = 0; i < NUMBER_OF_DLC_PARAMETERS; ++i) {
            parameterTable[i].Descriptor.Value = (PVOID)&parameterTable[i].DefaultValue;
            switch (i) {
            case SWAP_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->SwapAddressBits;
                break;

            case USEDIX_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->UseDix;
                break;

            case T1_TICK_ONE_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.T1TickOne;
                break;

            case T2_TICK_ONE_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.T2TickOne;
                break;

            case Ti_TICK_ONE_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.TiTickOne;
                break;

            case T1_TICK_TWO_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.T1TickTwo;
                break;

            case T2_TICK_TWO_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.T2TickTwo;
                break;

            case Ti_TICK_TWO_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->TimerTicks.TiTickTwo;
                break;

            case FRAME_SIZE_INDEX:
                parameterTable[i].Descriptor.Variable = &ConfigInfo->UseEthernetFrameSize;
                break;

            }
        }
        GetAdapterParameters(AdapterName, parameterTable, NUMBER_OF_DLC_PARAMETERS, FALSE);
        FREE_MEMORY_DRIVER(parameterTable);
    }

#if DBG
    if (DebugConfig) {
        DbgPrint("DLC.LoadAdapterConfigurationFromRegistry for adapter %ws:\n"
                 "\tSwap . . . . . . . . . : %d\n"
                 "\tUseDixOverEthernet . . : %d\n"
                 "\tT1TickOne. . . . . . . : %d\n"
                 "\tT2TickOne. . . . . . . : %d\n"
                 "\tTiTickOne. . . . . . . : %d\n"
                 "\tT1TickTwo. . . . . . . : %d\n"
                 "\tT2TickTwo. . . . . . . : %d\n"
                 "\tTiTickTwo. . . . . . . : %d\n"
                 "\tUseEthernetFrameSize . : %d\n",
                 AdapterName->Buffer,
                 ConfigInfo->SwapAddressBits,
                 ConfigInfo->UseDix,
                 ConfigInfo->TimerTicks.T1TickOne,
                 ConfigInfo->TimerTicks.T2TickOne,
                 ConfigInfo->TimerTicks.TiTickOne,
                 ConfigInfo->TimerTicks.T1TickTwo,
                 ConfigInfo->TimerTicks.T2TickTwo,
                 ConfigInfo->TimerTicks.TiTickTwo,
                 ConfigInfo->UseEthernetFrameSize
                 );
    }
#endif

}

#ifdef NDIS40

NTSTATUS
GetAdapterWaitTimeout(
    PULONG pulWait)

/*++

 Routine Description:
       
    Some adapters are delayed during initialization and are not completed
    even after the PnPBindsComplete event (such as ATM LANE adapter). 
    This timeout value 'WaitForAdapter' indicates how many seconds to wait for
    an adapter if is not already present/bound in LlcOpenAdapter    

 Arguments:
    
    pulWait -- Pointer to variable to store the wait timeout.
    
 Return Value:
 
    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/

{
    NTSTATUS          NtStatus;
    HANDLE            hDlc;
    HANDLE            hDlcParms;
    OBJECT_ATTRIBUTES ObjAttribs;
    ULONG             ulDisp;

    NtStatus = OpenDlcRegistryHandle(&DlcRegistryPath, &hDlc);

    if (NT_SUCCESS(NtStatus))
    {
        InitializeObjectAttributes(
            &ObjAttribs,
            &ParametersPath,
            OBJ_CASE_INSENSITIVE,
            hDlc,
            NULL);
    
        NtStatus = ZwCreateKey(
            &hDlcParms,
            KEY_READ,
            &ObjAttribs,
            0,
            NULL,
            0,
            &ulDisp);

        if (NT_SUCCESS(NtStatus))
        {
            PDLC_REGISTRY_PARAMETER pWaitTimeout;

            pWaitTimeout = (PDLC_REGISTRY_PARAMETER) ALLOCATE_MEMORY_DRIVER(
                sizeof(DLC_REGISTRY_PARAMETER));

            if (pWaitTimeout)
            {
                RtlCopyMemory(
                    pWaitTimeout, 
                    &AdapterInitTimeout, 
                    sizeof(AdapterInitTimeout));

                pWaitTimeout->Descriptor.Variable = pulWait;
                pWaitTimeout->Descriptor.Value = (PVOID)&pWaitTimeout->DefaultValue;

                NtStatus = GetRegistryParameter(
                    hDlcParms,
                    pWaitTimeout,
                    FALSE); // Don't set on fail.
            
                FREE_MEMORY_DRIVER(pWaitTimeout);
            }
            else
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            ZwClose(hDlcParms);
        }

        CloseDlcRegistryHandle(hDlc);
    }

    return (NtStatus);
}
#endif // NDIS40


NTSTATUS
GetAdapterParameters(
    IN PUNICODE_STRING AdapterName,
    IN PDLC_REGISTRY_PARAMETER Parameters,
    IN ULONG NumberOfParameters,
    IN BOOLEAN SetOnFail
    )

/*++

Routine Description:

    Retrieves a list of parameters from the DLC\Parameters\<AdapterName> section
    in the registry

Arguments:

    AdapterName         - pointer to UNICODE_STRING identifying adapter section
                          in DLC section of registry to open
    Parameters          - pointer to array of DLC_REGISTRY_PARAMETER structures
                          describing variables and default values to retrieve
    NumberOfParameters  - number of structures in Parameters array
    SetOnFail           - TRUE if we should set the registry parameter if we
                          fail to get it

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    NTSTATUS status;
    HANDLE dlcHandle;

    ASSUME_IRQL(PASSIVE_LEVEL);

    status = OpenDlcRegistryHandle(&DlcRegistryPath, &dlcHandle);
    if (NT_SUCCESS(status)) {

        HANDLE adapterHandle;
        BOOLEAN created;

        status = OpenDlcAdapterRegistryHandle(dlcHandle,
                                              AdapterName,
                                              &adapterHandle,
                                              &created
                                              );
        if (NT_SUCCESS(status)) {
            while (NumberOfParameters--) {

                //
                // if this adapter section was created then create the parameter
                // value entries and set them to the defaults, else retrieve the
                // current registry values
                //

                if (created) {
                    SetRegistryParameter(adapterHandle, Parameters);
                } else {
                    GetRegistryParameter(adapterHandle, Parameters, SetOnFail);
                }
                ++Parameters;
            }
            CloseAdapterRegistryHandle(adapterHandle);
        }
        CloseDlcRegistryHandle(dlcHandle);
    }
    return status;
}


NTSTATUS
OpenDlcRegistryHandle(
    IN PUNICODE_STRING RegistryPath,
    OUT PHANDLE DlcRegistryHandle
    )

/*++

Routine Description:

    Opens a handle to the DLC section in the registry

Arguments:

    RegistryPath        - pointer to UNICODE_STRING giving full registry path to
                          DLC section
    DlcRegistryHandle   - returned handle

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    ULONG disposition;

    ASSUME_IRQL(PASSIVE_LEVEL);

    InitializeObjectAttributes(&objectAttributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    status = ZwCreateKey(DlcRegistryHandle,
                         KEY_WRITE, // might want to update something in registry
                         &objectAttributes,
                         0,         // title index
                         NULL,      // class
                         0,         // create options
                         &disposition
                         );

#if DBG
    if (DebugConfig) {
        if (!NT_SUCCESS(status)) {
            DbgPrint("DLC.OpenDlcRegistryHandle: Error: %08x\n", status);
        }
    }
#endif

    return status;
}


NTSTATUS
OpenDlcAdapterRegistryHandle(
    IN HANDLE DlcRegistryHandle,
    IN PUNICODE_STRING AdapterName,
    OUT PHANDLE DlcAdapterRegistryHandle,
    OUT PBOOLEAN Created
    )

/*++

Routine Description:

    Opens a handle to the DLC\Parameters\<AdapterName> section in the registry.
    If this node does not exist, it is created

Arguments:

    DlcRegistryHandle           - open handle to DLC section in registry
    AdapterName                 - name of adapter in Parameters section. This
                                  MUST be of the form \Device\<adapter_name>
    DlcAdapterRegistryHandle    - returned open handle
    Created                     - returned TRUE if the handle was created

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    UNICODE_STRING keyName;
    UNICODE_STRING adapterName;
    WCHAR keyBuffer[sizeof(PARAMETERS_STRING) + MAX_ADAPTER_NAME_LENGTH];
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    ULONG disposition;

    ASSUME_IRQL(PASSIVE_LEVEL);

    keyName.Buffer = keyBuffer;
    keyName.Length = 0;
    keyName.MaximumLength = sizeof(keyBuffer);
    RtlCopyUnicodeString(&keyName, &ParametersPath);

    RtlInitUnicodeString(&adapterName, AdapterName->Buffer);
    adapterName.Buffer += sizeof(L"\\Device") / sizeof(L"") - 1;
    adapterName.Length -= sizeof(L"\\Device") - sizeof(L"");
    adapterName.MaximumLength -= sizeof(L"\\Device") - sizeof(L"");
    RtlAppendUnicodeStringToString(&keyName, &adapterName);

    InitializeObjectAttributes(&objectAttributes,
                               &keyName,
                               OBJ_CASE_INSENSITIVE,
                               DlcRegistryHandle,
                               NULL
                               );

    //
    // if the DLC\Parameters\<adapter_name> key does not exist, then we will
    // create it
    //

    status = ZwCreateKey(DlcAdapterRegistryHandle,
                         KEY_WRITE,
                         &objectAttributes,
                         0,
                         NULL,
                         0,
                         &disposition
                         );
    *Created = (disposition == REG_CREATED_NEW_KEY);

#if DBG
    if (DebugConfig) {
        if (!NT_SUCCESS(status)) {
            DbgPrint("DLC.OpenDlcAdapterRegistryHandle: Error: %08x\n", status);
        }
    }
#endif

    return status;
}


NTSTATUS
GetRegistryParameter(
    IN HANDLE KeyHandle,
    IN PDLC_REGISTRY_PARAMETER Parameter,
    IN BOOLEAN SetOnFail
    )

/*++

Routine Description:

    Retrieves a parameter from a section of the registry. If the section cannot
    be accessed or returns invalid data, then we get the default value from the
    Parameter structure

Arguments:

    KeyHandle   - open handle to the required section in the registry
    Parameter   - pointer to DLC_REGISTRY_PARAMETER structure giving address and
                  type of the parameter to be retrieved, etc.
    SetOnFail   - if we fail to get the value from the registry, we try to set
                  the default value in the registry

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    NTSTATUS status;
    UNICODE_STRING parameterName;
    UCHAR informationBuffer[MAX_INFORMATION_BUFFER_LENGTH];
    PKEY_VALUE_FULL_INFORMATION valueInformation = (PKEY_VALUE_FULL_INFORMATION)informationBuffer;
    ULONG informationLength;

    ASSUME_IRQL(PASSIVE_LEVEL);

    RtlInitUnicodeString(&parameterName, Parameter->ParameterName);
    status = ZwQueryValueKey(KeyHandle,
                             &parameterName,
                             KeyValueFullInformation,
                             (PVOID)valueInformation,
                             sizeof(informationBuffer),
                             &informationLength
                             );
    if (NT_SUCCESS(status) && valueInformation->DataLength) {

        //
        // use the value retrieved from the registry
        //

        status = DlcpGetParameter(Parameter->ParameterName,
                                  valueInformation->Type,
                                  (PVOID)&informationBuffer[valueInformation->DataOffset],
                                  valueInformation->DataLength,
                                  NULL,
                                  (PVOID)&Parameter->Descriptor
                                  );
    } else {

#if DBG

        if (DebugConfig) {
            if (!NT_SUCCESS(status)) {
                DbgPrint("DLC.GetRegistryParameter: Error: %08x\n", status);
            } else {
                DbgPrint("DLC.GetRegistryParameter: Error: valueInformation->DataLength is 0\n");
            }
        }

#endif

        if (!NT_SUCCESS(status) && SetOnFail) {
            SetRegistryParameter(KeyHandle, Parameter);
        }

        //
        // set the default value
        //

        status = DlcpGetParameter(Parameter->ParameterName,
                                  Parameter->Descriptor.Type,
                                  Parameter->Descriptor.Value,
                                  Parameter->Descriptor.Length,
                                  NULL,
                                  (PVOID)&Parameter->Descriptor
                                  );
    }
    return status;
}


NTSTATUS
SetRegistryParameter(
    IN HANDLE KeyHandle,
    IN PDLC_REGISTRY_PARAMETER Parameter
    )

/*++

Routine Description:

    Sets a parameter in the DLC\Parameters\<AdapterName> section

Arguments:

    KeyHandle   - open handle to required section in registry
    Parameter   - pointer to DLC_REGISTRY_PARAMETER containing all required
                  parameter information

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{
    NTSTATUS status;
    UNICODE_STRING name;

    ASSUME_IRQL(PASSIVE_LEVEL);

    RtlInitUnicodeString(&name, Parameter->ParameterName);
    status = ZwSetValueKey(KeyHandle,
                           &name,
                           0,   // TitleIndex
                           Parameter->Descriptor.Type,
                           Parameter->Descriptor.Value,
                           Parameter->Descriptor.Length
                           );

#if DBG

    if (DebugConfig) {
        if (!NT_SUCCESS(status)) {
            DbgPrint("DLC.SetRegistryParameter: Error: %08x\n", status);
        }
    }

#endif

    return status;
}


NTSTATUS
DlcpGetParameter(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    Call-back function which copies the data retrieved from the registry to
    a variable

Arguments:

    ValueName       - pointer to name of parameter being set (ignored)
    ValueType       - type of parameter being set
    ValueData       - pointer to data retrieved from registry
    ValueLength     - length of data retrieved
    Context         - ignored
    EntryContext    - pointer to REGISTRY_PARAMETER_DESCRIPTOR structure

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
        Failure -

--*/

{

#define Descriptor ((PREGISTRY_PARAMETER_DESCRIPTOR)EntryContext)

    //
    // if we have a registry entry for the parameter, but it is a different
    // type from that expected (say REG_SZ instead of REG_DWORD) then we use
    // the default type, length and value
    //

    if (ValueType != Descriptor->Type) {

#if DBG
        DbgPrint("DLC.DlcpGetParameter: Error: type for %ws is %d, expected %d, using default\n",
                 ValueName,
                 ValueType,
                 Descriptor->Type
                 );
#endif

        ValueType = Descriptor->Type;
        ValueData = Descriptor->Value;
        ValueLength = Descriptor->Length;
    }

    switch (ValueType) {
    case REG_DWORD: {

        ULONG value;

        if (Descriptor->RealType == PARAMETER_IS_BOOLEAN) {
            value = (*(PULONG)ValueData != 0);
            *(PBOOLEAN)(Descriptor->Variable) = (BOOLEAN)value;

            //
            // no limit check for BOOLEAN type
            //

            break;
        } else {
            value = *(PULONG)ValueData;
        }

        //
        // check range. If outside range, use default. Comparison is ULONG
        //

        if (value < Descriptor->LowerLimit || value > Descriptor->UpperLimit) {

#if DBG
            DbgPrint("DLC.DlcpGetParameter: Error: Parameter %ws = %d: Out of range (%d..%d). Using default = %d\n",
                     ValueName,
                     value,
                     Descriptor->LowerLimit,
                     Descriptor->UpperLimit,
                     *(PULONG)(Descriptor->Value)
                     );
#endif

            value = *(PULONG)(Descriptor->Value);
        }
        if (Descriptor->RealType == PARAMETER_IS_UCHAR) {
            *(PUCHAR)(Descriptor->Variable) = (UCHAR)value;
        } else {
            *(PULONG)(Descriptor->Variable) = value;
        }
        break;
    }

#if DBG
    default:
        DbgPrint("DLC.DlcpGetParameter: Error: didn't expect ValueType %d\n", ValueType);
#endif

    }
    return STATUS_SUCCESS;

#undef pDescriptor

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcrcv.c ===
/*++

Copyright (c) 1991 Microsoft Corporation Copyright
          (c) 1991 Nokia Data Systems AB

Module Name:

    dlcrcv.c

Abstract:

    This module implements the DLC receive and read commands

    Contents:
        DlcReceiveRequest
        ReceiveCompletion
        DlcReadRequest
        ReadCompletion
        CompleteCompletionPacket
        CreateBufferChain
        DlcReceiveCancel

Author:

    Antti Saarenheimo 22-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif

#include <dlc.h>
#include "dlcdebug.h"
#include "llc.h"        // SwapMemCpy

//
// Option indicator defines how we will use the command and event queues:
// 0 => only this station id
// 1 => all events for the sap number in station id
// 2 => all events to any station id
// This table maps the option indicators to station id masks:
//

static USHORT StationIdMasks[3] = {
    (USHORT)(-1),
    0xff00,
    0
};

//
// receive station id of a direct station defines
// the received frame types.  This table swaps around
// the bits used by IBM.
//

static UCHAR DirectReceiveTypes[LLC_DIR_RCV_ALL_ETHERNET_TYPES + 1] = {
    DLC_RCV_MAC_FRAMES | DLC_RCV_8022_FRAMES,
    DLC_RCV_MAC_FRAMES,
    DLC_RCV_8022_FRAMES,
    0,                      // DLC_RCV_SPECIFIC_DIX,
    DLC_RCV_MAC_FRAMES | DLC_RCV_8022_FRAMES | DLC_RCV_DIX_FRAMES,
    DLC_RCV_DIX_FRAMES
};


NTSTATUS
DlcReceiveRequest(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    DLC RECEIVE implements two different commands:

        1. It may receive a frame asynchronously when receive flag is zero

        2. It may enable data permanent receiving.  The received frames
           are save to event queue from which they read with READ command.

    The case 1 is not very much used, because there can be only
    one simultaneusly receive command on a dlc station and the frames
    are lost very easily before the next command can be be issued.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    ParameterLength     - not used
    OutputBufferLength  - not used

Return Value:

    NTSTATUS:
        DLC_STATUS_DUPLICATE_COMMAND
        STATUS_PENDING

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pRcvObject;
    ULONG Event;
    USHORT OpenOptions;

    UNREFERENCED_PARAMETER(OutputBufferLength);
    UNREFERENCED_PARAMETER(ParameterLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("DlcReceiveRequest");

    Status = GetStation(pFileContext,
                        pDlcParms->Async.Parms.Receive.usStationId,
                        &pRcvObject
                        );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }
    if (pFileContext->hBufferPool == NULL) {
        return DLC_STATUS_INADEQUATE_BUFFERS;
    }

    //
    // There can be only one simultaneous receive command
    //

    if (pRcvObject->pRcvParms != NULL) {
        return DLC_STATUS_DUPLICATE_COMMAND;
    }

    if (pDlcParms->Async.Parms.Receive.usUserLength > MAX_USER_DATA_LENGTH) {
        return DLC_STATUS_USER_LENGTH_TOO_LARGE;
    }

    if (pDlcParms->Async.Parms.Receive.ulReceiveFlag != 0) {
        if (pDlcParms->Async.Parms.Receive.uchRcvReadOption >= INVALID_RCV_READ_OPTION) {
            return DLC_STATUS_INVALID_OPTION;
        }

        //
        // Everything is ready for the receive, we will now use buffer pool
        // to receive frames sent to this object, but applications must
        // make READ command to get the data from the buffer pool.
        //

        Event = LLC_RECEIVE_COMMAND_FLAG;
    } else {

        //
        // Receive read option flag is set also for the normal receive
        // to make its handling the same as the data receiving with READ
        //

        Event = LLC_RECEIVE_DATA;    // we do only a normal receive
    }

    //
    // The receive command for a direct station defines the
    // type of the receive frames => we must set the
    // receive flags every time the receive command is issued
    // and remove them, when it is completed or canceled.
    //

    if (pRcvObject->Type == DLC_DIRECT_OBJECT) {
        if (pDlcParms->Async.Parms.Receive.usStationId > LLC_DIR_RCV_ALL_ETHERNET_TYPES) {
            return DLC_STATUS_INVALID_STATION_ID;
        }

        //
        // The two lowest bits the receive mask are inverted =>
        // They must be changed, when the llc driver is called.
        // ---
        // The MAC frames must have been enabled by the open options
        // of the direct station.
        //

        OpenOptions = (USHORT)(DirectReceiveTypes[pDlcParms->Async.Parms.Receive.usStationId]
                                & pRcvObject->u.Direct.OpenOptions);

        //
        // We create an appropriate LLC object only when the direct station
        // has an active receive. The LLC object is deleted when the receive
        // terminates. This feature is implemented to support two different
        // kinds of LLC objects: (i) DLC Direct stations receiving MAC and
        // IEEE 802.2 frames and (ii) DIX ethernet type stations receiving
        // all frames having the selected ethernet type
        //

        if (OpenOptions & LLC_VALID_RCV_MASK) {
            LlcSetDirectOpenOptions(pRcvObject->hLlcObject, OpenOptions);
        }
    }
    pRcvObject->pRcvParms = pDlcParms;

    //
    // this IRP is cancellable
    //

//    RELEASE_DRIVER_LOCK();

    SetIrpCancelRoutine(pIrp, TRUE);

//    ACQUIRE_DRIVER_LOCK();

    //
    // We must queue both receive command types, the other can receive
    // data normally, but the second is in the queue only be cancelled
    // with its CCB address.
    //

    Status = QueueDlcCommand(pFileContext,
                             Event,
                             pRcvObject->StationId,
                             (USHORT)(-1),                   // only this station id
                             pIrp,                           // IRP
                             pDlcParms->Async.Ccb.pCcbAddress,
                             ReceiveCompletion               // completion handler
                             );

    //
    // Reset receive parameter link if this receive
    // command was not pending for some reason (eg. an error)
    //

    if (Status != STATUS_PENDING) {
        pRcvObject->pRcvParms = NULL;
    } else if (pRcvObject->Type != DLC_DIRECT_OBJECT) {

        //
        // The link station may be in a local busy state, if they
        // do not have a pending receive.  That's why we must
        // clear the local busy states for a single link station
        // or all link stations of a sap station, if the receive
        // is made for the whole sap.  This will clear simultaneously
        // also the "out of receive buffers" states, but
        // it does nto matter, because they can be set again.
        // This command does not change the local busy state, if
        // it has been set by user.
        //

        ReferenceLlcObject(pRcvObject);

        LEAVE_DLC(pFileContext);

        LlcFlowControl(pRcvObject->hLlcObject, LLC_RESET_LOCAL_BUSY_BUFFER);

        ENTER_DLC(pFileContext);

        DereferenceLlcObject(pRcvObject);
    }
    return Status;
}


BOOLEAN
ReceiveCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    )

/*++

Routine Description:

    The function handles the data receive event and completes
    the pending receive command.

Arguments:

    pFileContext
    pDlcObject          - the DLC object (sap, link or direct station) of the
                          current event (or/and the read command)
    pIrp                - interrupt request packet of this READ command
    Event               - event code
    pEventInformation   - event specific information
    SecondaryInfo       - used as a miscellaneous secondary parameter
                          at least the ReadFlag of the received frame, as a
                          command completion flag in transmit completion

Return Value:

    BOOLEAN

--*/

{
    PNT_DLC_PARMS pDlcParms;
    USHORT ReceivedFrameCount;

    UNREFERENCED_PARAMETER(Event);
    UNREFERENCED_PARAMETER(SecondaryInfo);

    DIAG_FUNCTION("ReceiveCompletion");

    pDlcParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;

    CreateBufferChain((PDLC_BUFFER_HEADER)pEventInformation,
                      (PVOID *)&pDlcParms->Async.Parms.Receive.pFirstBuffer,
                      &ReceivedFrameCount   // this should be always 1
                      );

    //
    // IBM DLC API defines, that there can be only one receive command
    // pending for an object.  The receive parameter table pointer
    // disables the further receive commands while one is pending.
    //

    pDlcObject->pRcvParms = NULL;

    //
    // Queue a command completion event, if the command completion
    // flag has been defined in the CCB
    //

    if (pDlcParms->Async.Ccb.CommandCompletionFlag != 0) {
        MakeDlcEvent(pFileContext,
                     DLC_COMMAND_COMPLETION,
                     pDlcObject->StationId,
                     NULL,
                     pDlcParms->Async.Ccb.pCcbAddress,
                     pDlcParms->Async.Ccb.CommandCompletionFlag,
                     FALSE
                     );
    }

    //
    // If this is RECEIVE2 (CCB and its parameter block catenated
    // together), then we copy back the whole buffer).
    // => change the size of the parameter block copied back to user.
    // The default output buffer size is defined for the receive commands
    // with a read flag.
    //

    if (IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_DLC_RECEIVE2) {
        pIrp->IoStatus.Information = sizeof(LLC_RECEIVE_PARMS) + sizeof(NT_DLC_CCB);
    } else {

        //
        // MODMOD RLF 01/23/93
        //
        // Performance (slight). The following is a single-dword write
        //

        //LlcMemCpy(MmGetSystemAddressForMdl((PMDL)pDlcParms->Async.Ccb.u.pMdl),
        //          &pDlcParms->Async.Parms.Receive.pFirstBuffer,
        //          aSpecialOutputBuffers[IOCTL_DLC_RECEIVE_INDEX]
        //          );

        PVOID* pChain;

        pChain = (PVOID*)MmGetSystemAddressForMdl((PMDL)pDlcParms->Async.Ccb.u.pMdl);
        *pChain = pDlcParms->Async.Parms.Receive.pFirstBuffer;

        //
        // MODMOD ends
        //

        UnlockAndFreeMdl(pDlcParms->Async.Ccb.u.pMdl);

        //
        // RLF 02/23/94
        //
        // zap the pMdl field to avoid trying to unlock and free the MDL again
        //

        pDlcParms->Async.Ccb.u.pMdl = NULL;
    }
    CompleteAsyncCommand(pFileContext, STATUS_SUCCESS, pIrp, NULL, FALSE);
    return TRUE;
}


NTSTATUS
DlcReadRequest(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    The READ command emulates all posting features provided in DOS DLC API.

    The command can be used:
        1. To receive data
        2. To read DLC status indications (connect and disconnect indications)
        3. To complele other asynchronous commands (transmit, receive,
           close, reset, connect)
        4. To handle exceptions on NDIS (or on DLC) driver

    See IBM documentation for more information about DLC READ.

Arguments:

    pIrp            - current io request packet
    pFileContext    - DLC process specific adapter context
    pDlcParms       - the current parameter block
    ParameterLength - the length of input parameters

Return Value:

    DLC_STATUS:

--*/

{
    NTSTATUS Status;
    PDLC_OBJECT pReadObject;
    PVOID AbortHandle;

    UNREFERENCED_PARAMETER(OutputBufferLength);
    UNREFERENCED_PARAMETER(ParameterLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("DlcReadRequest");

//
//  Receive request alread checks, that buffer pool has been defined,
//  and we may complete commands or read dlc events before
//  the buffer pool has been created.
//
//    if (pFileContext->hBufferPool == NULL)
//    {
//        return DLC_STATUS_INADEQUATE_BUFFERS;
//    }

    //
    // RLF 04/09/93
    //
    // It should not be possible to have the same READ CCB queued more than once.
    // It could get the app into all sorts of difficulty
    //

    if (IsCommandOnList((PVOID)pDlcParms->Async.Ccb.pCcbAddress, &pFileContext->CommandQueue)) {

#if DBG
        DbgPrint("DLC.DlcReadRequest: Error: CCB %08X already on list\n",
                pDlcParms->Async.Ccb.pCcbAddress
                );
        DbgBreakPoint();
#endif

        return DLC_STATUS_DUPLICATE_COMMAND;
    }

    //
    // Check the input parameters of DLC READ
    //

    if (pDlcParms->Async.Parms.ReadInput.OptionIndicator >= DLC_INVALID_OPTION_INDICATOR) {
        return DLC_STATUS_INVALID_OPTION;
    }

    //
    // If the read is destined for a specific station then we check that the
    // station really exists
    //

    if ((UCHAR)pDlcParms->Async.Parms.ReadInput.OptionIndicator < LLC_OPTION_READ_ALL) {

        Status = GetStation(pFileContext,
                            (USHORT)(pDlcParms->Async.Parms.ReadInput.StationId
                                & StationIdMasks[pDlcParms->Async.Parms.ReadInput.OptionIndicator]),
                            &pReadObject
                            );

        if (Status != STATUS_SUCCESS) {
            return Status;
        }
    }

    //
    // Read commands can be linked to another command by CCB pointer,
    // command completion flag and read flag are a special case.  They
    // can be used only for the completion of a the given command.
    // We use the commands CCB address as a search handle and
    // save it as an abort handle instead of the read command's
    // own CCB address.
    //

    if (pDlcParms->Async.Parms.ReadInput.CommandCompletionCcbLink != NULL) {
        AbortHandle = pDlcParms->Async.Parms.ReadInput.CommandCompletionCcbLink;
        pDlcParms->Async.Parms.ReadInput.EventSet = LLC_RECEIVE_COMMAND_FLAG;
    } else {
        AbortHandle = pDlcParms->Async.Ccb.pCcbAddress;
        pDlcParms->Async.Parms.ReadInput.EventSet &= LLC_READ_ALL_EVENTS;
        if (pDlcParms->Async.Parms.ReadInput.EventSet == 0) {
            return DLC_STATUS_PARAMETER_MISSING;
        }
    }

    //
    // this IRP is cancellable
    //

//    RELEASE_DRIVER_LOCK();

    SetIrpCancelRoutine(pIrp, TRUE);

//    ACQUIRE_DRIVER_LOCK();

    return QueueDlcCommand(pFileContext,
                           (ULONG)pDlcParms->Async.Parms.ReadInput.EventSet,
                           pDlcParms->Async.Parms.ReadInput.StationId,
                           StationIdMasks[pDlcParms->Async.Parms.ReadInput.OptionIndicator],
                           pIrp,
                           AbortHandle,
                           ReadCompletion
                           );
}


BOOLEAN
ReadCompletion(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    )

/*++

Routine Description:

    The command reads a DLC event and saves its information to
    the returned parameter block of the read command.

Arguments:

    pFileContext        - process specific open context
    pDlcObject          - the DLC object (sap, link or direct station) of the
                          current event (or/and the read command)
    pIrp                - interrupt request packet of this READ command
    Event               - event code
    pEventInformation   - event specific information
    SecondaryInfo       - a miscallaneous secondary parameter, eg. the ReadFlag
                          of the received frame or the command completion flag
                          in transmit completion.

Return Value:

    BOOLEAN
        TRUE    - The packet containing the event information can be returned
                  to its pool
        FALSE   - Do not deallocate the event packet

--*/

{
    BOOLEAN boolDeallocatePacket;
    PNT_DLC_PARMS pParms;

    ASSUME_IRQL(DISPATCH_LEVEL);

    DIAG_FUNCTION("ReadCompletion");

    pParms = (PNT_DLC_PARMS)pIrp->AssociatedIrp.SystemBuffer;
    boolDeallocatePacket = TRUE;

    //
    // Reset always all unrefernced variables
    // (otherwise they may be garbage)
    //

    LlcZeroMem((PVOID)&pParms->Async.Parms.Read.Event, sizeof(NT_DLC_READ_PARMS) - 4);
    pParms->Async.Parms.Read.Event = (UCHAR)Event;

    switch (Event) {
    case LLC_RECEIVE_DATA:

        //
        // The caller checks always if the DLC object is ready to receive data
        // with read and to selects the correct receive buffer pool
        //

        pParms->Async.Parms.Read.NotificationFlag = SecondaryInfo;

        //
        // The read always resets the receive event
        //

        if (pDlcObject != NULL) {
            pDlcObject->pReceiveEvent = NULL;
        }
        CreateBufferChain(pEventInformation,
                          (PVOID*)&pParms->Async.Parms.Read.u.Event.pReceivedFrame,
                          &pParms->Async.Parms.Read.u.Event.ReceivedFrameCount
                          );
        break;

    case LLC_TRANSMIT_COMPLETION:
        if (SecondaryInfo == 0) {

            //
            // We have created a special completion packet for those chained
            // transmit command completions, whose DLC object have been deleted
            //

            CompleteCompletionPacket(pFileContext,
                                     (PDLC_COMPLETION_EVENT_INFO)pEventInformation,
                                     pParms
                                     );
        } else {

            //
            // Transmit commands do not use any command completion packets,
            // because the LLC module takes care of the command queueing
            // and completion routine. The previous transmit command
            // completion has left its CCB pointer to current object.
            // The sequential non null transmit CCBs create a CCB link
            // list, that is terminated in every READ call.
            //
            // Unlink the command completion event having the xmit
            // commands chained (the next xmit command with the
            // chaining option will setup the link again).
            //

            if (pDlcObject != NULL) {
                pEventInformation = pDlcObject->pPrevXmitCcbAddress;
                pDlcObject->pPrevXmitCcbAddress = NULL;
                pParms->Async.Parms.Read.u.Event.CcbCount = pDlcObject->ChainedTransmitCount;
                pDlcObject->ChainedTransmitCount = 0;
            } else {

                //
                // This is only an lonely unchained xmit completion
                // event. The CCB counter must be always one.
                //

                pParms->Async.Parms.Read.u.Event.CcbCount = 1;
            }
            pParms->Async.Parms.Read.NotificationFlag = SecondaryInfo;
            pParms->Async.Parms.Read.u.Event.pCcbCompletionList = pEventInformation;
        }
        break;

    case DLC_COMMAND_COMPLETION:

        //
        // Close command completions needs a special command completion
        // packet, the other command completions consists only of
        // the ccb address and command completion flag (secondary data).
        // The close command completions have reset the secondary data
        //

        if (SecondaryInfo != 0) {

            //
            // This is the command completion of a normal DLC command.
            //

            pParms->Async.Parms.Read.u.Event.CcbCount = 1;
            pParms->Async.Parms.Read.NotificationFlag = SecondaryInfo;
            pParms->Async.Parms.Read.u.Event.pCcbCompletionList = pEventInformation;
        } else {
            CompleteCompletionPacket(pFileContext,
                                     (PDLC_COMPLETION_EVENT_INFO)pEventInformation,
                                     pParms
                                     );
       }
       break;

    case LLC_CRITICAL_EXCEPTION:

// THIS DEPENDS ON NDIS 3.0
// Talk with Johnson about this case:
// Dos NDIS first return RING_STATUS and then CLOSING status
// LLC should put them together to CRITICAL_EXCEPTION.

        //
        // This event is not handled (?)
        //

        break;

    case LLC_NETWORK_STATUS:

        //
        // The network status change is not a fatal event.
        //

        pParms->Async.Parms.Read.NotificationFlag = pFileContext->NetworkStatusFlag;
        pParms->Async.Parms.Read.u.Event.EventErrorCode = (USHORT)SecondaryInfo;
        break;

    case LLC_STATUS_CHANGE:

        //
        // This is a DLC status change, WE MAY COPY SOME GRABAGE
        // IF THE LINK STATION HAS BEEN DELETED MEANWHILE, But
        // it does not matter, because the non-paged memory
        // alaways exists, and the status table can only be
        // owned by another link station (because the
        // link stations are allocated from a packet pool)
        //

        LlcMemCpy(&pParms->Async.Parms.Read.u.Status.DlcStatusCode,
                  pEventInformation,
                  sizeof(DLC_STATUS_TABLE) - sizeof(PVOID)
                  );

        //
        // RLF 02/23/93 If this is a CONNECT_REQUEST and the medium is Ethernet
        // or FDDI then swap the bits in the reported net address
        //

        if ((pParms->Async.Parms.Read.u.Status.DlcStatusCode == LLC_INDICATE_CONNECT_REQUEST)
        && ((pFileContext->ActualNdisMedium == NdisMedium802_3)
        || (pFileContext->ActualNdisMedium == NdisMediumFddi))) {

            //
            // swap bytes in situ
            //

            SwapMemCpy(TRUE,
                       &pParms->Async.Parms.Read.u.Status.RemoteNodeAddress[0],
                       &pParms->Async.Parms.Read.u.Status.RemoteNodeAddress[0],
                       6
                       );
        }
        pParms->Async.Parms.Read.u.Status.StationId = pDlcObject->StationId;
        pParms->Async.Parms.Read.u.Status.UserStatusValue = pDlcObject->u.Link.pSap->u.Sap.UserStatusValue;
        pParms->Async.Parms.Read.NotificationFlag = pDlcObject->u.Link.pSap->u.Sap.DlcStatusFlag;
        pParms->Async.Parms.Read.u.Status.DlcStatusCode = (USHORT)SecondaryInfo;

        //
        // Each link stations has a DLC status event packet.
        // Those packets must not be deallocated back to the
        // packet pool as the other event packets.
        //

        pDlcObject->u.Link.pStatusEvent->LlcPacket.pNext = NULL;
        pDlcObject->u.Link.pStatusEvent->SecondaryInfo = 0;
        boolDeallocatePacket = FALSE;
        break;

        //
        // System actions are based on the fact, that all apps share the
        // DLC same dlc and physical network adapter.
        // NT NDIS and DLC architectures provide full DLC for each
        // application separately => The system action indications are
        // not needed in NT DLC.
        //
        //        case LLC_SYSTEM_ACTION:
        //            break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif
    };

    //
    // Copy the optional second output buffer to user memory.
    //

    if (IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_DLC_READ) {
        LlcMemCpy(MmGetSystemAddressForMdl((PMDL)pParms->Async.Ccb.u.pMdl),
                  &pParms->Async.Parms.Read.Event,
                  aSpecialOutputBuffers[IOCTL_DLC_READ_INDEX] -
				  ( (PCHAR)&pParms->Async.Parms.Read.Event -
				    (PCHAR)&pParms->Async.Parms.Read )
                  );
        UnlockAndFreeMdl(pParms->Async.Ccb.u.pMdl);
    }
    pParms->Async.Ccb.uchDlcStatus = (UCHAR)STATUS_SUCCESS;
    pParms->Async.Ccb.pCcbAddress = NULL;

    //
    // we are about to complete this IRP - remove the cancel routine
    //

//    RELEASE_DRIVER_LOCK();

    SetIrpCancelRoutine(pIrp, FALSE);
    IoCompleteRequest(pIrp, (CCHAR)IO_NETWORK_INCREMENT);

//    ACQUIRE_DRIVER_LOCK();

    DereferenceFileContext(pFileContext);
    return boolDeallocatePacket;
}


VOID
CompleteCompletionPacket(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_COMPLETION_EVENT_INFO pCompletionInfo,
    IN OUT PNT_DLC_PARMS pParms
    )

/*++

Routine Description:

    Procedure reads the completion information from
    the command completion packet and saves it to the
    read parameter table.

Arguments:

    pFileContext    - process specific open context
    pCompletionInfo - dlc completion packet
    pParms          - pointer to DLC parameter table

Return Value:

    None

--*/

{
    pParms->Async.Parms.Read.u.Event.CcbCount = pCompletionInfo->CcbCount;
    pParms->Async.Parms.Read.NotificationFlag = pCompletionInfo->CommandCompletionFlag;
    pParms->Async.Parms.Read.u.Event.pCcbCompletionList = pCompletionInfo->pCcbAddress;
    CreateBufferChain(pCompletionInfo->pReceiveBuffers,
                      (PVOID*)&pParms->Async.Parms.Read.u.Event.pReceivedFrame,
                      &pParms->Async.Parms.Read.u.Event.ReceivedFrameCount
                      );

    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pCompletionInfo);

}


VOID
CreateBufferChain(
    IN PDLC_BUFFER_HEADER pBufferHeaders,
    OUT PVOID *pFirstBuffer,
    OUT PUSHORT pReceivedFrameCount
    )

/*++

Routine Description:

    The procudedure links the received frames in user's address space
    to the same order as they were received.

    We will take all frames linked to the queue.
    We must count the received frames to get
    the exact number of them. We cound count the frames
    also in the fly, but this is probably fastest and
    simplest way to do it (usually there is only one frame).

    The received frames are always in a circular link list.
    and in a reverse order.  The newest
    frame is pointed by the list header and the oldes one
    is the next from it.

Arguments:

    pBufferHeaders      - circular DLC buffer list, the head point to the
                          newest frame.
    pFirstBuffer        - returned user's address space address of the
                          first received frame
    pReceivedFrameCount - returned number of the received frame

Return Value:

    None

--*/

{
    PDLC_BUFFER_HEADER pBuffer;

    if (pBufferHeaders != NULL) {
        pBuffer = pBufferHeaders->FrameBuffer.pNextFrame;
        pBufferHeaders->FrameBuffer.pNextFrame = NULL;
        do {
            *pFirstBuffer = (PVOID)((PCHAR)pBuffer->FrameBuffer.pParent->Header.pLocalVa
                          + MIN_DLC_BUFFER_SEGMENT * pBuffer->FrameBuffer.Index);
            pFirstBuffer = (PVOID*)&((PFIRST_DLC_SEGMENT)
                    ((PUCHAR)pBuffer->FrameBuffer.pParent->Header.pGlobalVa
                    + MIN_DLC_BUFFER_SEGMENT * pBuffer->FrameBuffer.Index))->Cont.pNextFrame;
            (*pReceivedFrameCount)++;

#if LLC_DBG
            cFramesIndicated++;
#endif

            //
            // The new state makes it possible to free the
            // buffer immediately (should this be interlocked???)
            //

            {
                PDLC_BUFFER_HEADER pNextBuffer;

                pNextBuffer = pBuffer->FrameBuffer.pNextFrame;
                pBuffer->FrameBuffer.BufferState = BUF_USER;
                pBuffer = pNextBuffer;
            }
        } while (pBuffer != NULL);

#if LLC_DBG
        if (*pFirstBuffer != NULL) {
            DbgPrint("Improperly formed frame link list!!!\n");
            DbgBreakPoint();
        }
#endif

    }
}


NTSTATUS
DlcReceiveCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive cancels a pending receive command.  This is different
    from the general cancel command used for READ and DirTimerSet,
    because we must find the object having the active receive and
    disable it.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    ParameterLength     - the length of input parameters
    OutputBufferLength  -

Return Value:

    DLC_STATUS:
        Success - STATUS_SUCCESS
        Failure - DLC_INVALID_CCB_PARAMETER1

--*/

{
    PDLC_OBJECT pRcvObject;
    PDLC_COMMAND pDlcCommand;
    PVOID pCcbLink = NULL;
    PNT_DLC_PARMS pCanceledParms;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(OutputBufferLength);
    UNREFERENCED_PARAMETER(ParameterLength);

    pDlcCommand = SearchAndRemoveAnyCommand(pFileContext,
                                            (ULONG)(LLC_RECEIVE_DATA | LLC_RECEIVE_COMMAND_FLAG),
                                            (USHORT)DLC_IGNORE_STATION_ID,
                                            (USHORT)DLC_STATION_MASK_SPECIFIC,
                                            pDlcParms->ReceiveCancel.pCcb
                                            );
    if (pDlcCommand != NULL) {
        pCanceledParms = (PNT_DLC_PARMS)pDlcCommand->pIrp->AssociatedIrp.SystemBuffer;
        GetStation(pFileContext,
                   pCanceledParms->Async.Parms.Receive.usStationId,
                   &pRcvObject
                   );

        //
        // I can't see any reason why the station id should be missing
        // => we don't check the error code.
        //

        pRcvObject->pRcvParms = NULL;

        //
        // We return the canceled CCB pointer
        //

        CancelDlcCommand(pFileContext,
                         pDlcCommand,
                         &pCcbLink,
                         DLC_STATUS_CANCELLED_BY_USER,
                         TRUE   // SuppressCommandCompletion !!!
                         );
    }

    //
    // IBM LAN Tech Ref didn't define any possible error code for the
    // case, if the receive command could not be found => we
    // must return a successful status.
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlctimr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlctimr.c

Abstract:

    This module implements timer services of NT DLC API.

    Contents:
        DirTimerSet
        DirTimerCancelGroup
        DirTimerCancel
        SearchTimerCommand
        AbortCommandsWithFlag

Author:

    Antti Saarenheimo 02-Sep-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>


NTSTATUS
DirTimerSet(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure queues a timer set command to a special timer command
    queue.  The timer commands are queue by the cumulative time in
    such way, that only the timer tick needs to decrement (and possibly
    to complete) only the first command in the queue.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters
    OutputBufferLength  - the length of output parameters

Return Value:

    NTSTATUS:
            STATUS_SUCCESS

--*/

{
    PDLC_COMMAND* ppNode;
    PDLC_COMMAND pDlcCommand;
    UINT TimerTicks;

    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // Check the timer value (I don't know what 13107 half seconds
    // means, this is just as in IBM spec).
    //

    TimerTicks = pDlcParms->Async.Ccb.u.dir.usParameter0 + 1;
    if (TimerTicks > 13108) {
        return DLC_STATUS_TIMER_ERROR;
    }

    //
    // DIR.TIMER.CANCEL returns wrong error code !!!!
    // (0x0a insted of TIMER_ERROR)
    //

    pDlcCommand = (PDLC_COMMAND)ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pDlcCommand ==  NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    pDlcCommand->Event = 0;
    pDlcCommand->pIrp = pIrp;
    pDlcCommand->StationId = 0;
    pDlcCommand->StationIdMask = (USHORT)(-1);
    pDlcCommand->AbortHandle = pDlcParms->Async.Ccb.pCcbAddress;

    //
    // find the right place in the list to put this timer
    //

    for (ppNode = &pFileContext->pTimerQueue; ; ) {
        if (*ppNode == NULL) {
            pDlcCommand->LlcPacket.pNext = NULL;
            break;
        } else if ((*ppNode)->Overlay.TimerTicks >= TimerTicks) {
            (*ppNode)->Overlay.TimerTicks -= TimerTicks;
            pDlcCommand->LlcPacket.pNext = (PLLC_PACKET)*ppNode;
            break;
        } else {
            TimerTicks -= (*ppNode)->Overlay.TimerTicks;
        }
        ppNode = (PDLC_COMMAND *)&(*ppNode)->LlcPacket.pNext;
    }
    *ppNode = pDlcCommand;
    pDlcCommand->Overlay.TimerTicks = TimerTicks;
    return STATUS_PENDING;
}


NTSTATUS
DirTimerCancelGroup(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    Procedure cancels all DirTimerSet commands having the given
    command completion flag.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS:
            STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    //
    // All terminated DirTimerSet commands are chained to the
    // CCB pointer of this cancel group command.
    // Terminate the link list of the canceled CCBs.
    //

    pDlcParms->InputCcb.pCcbAddress = NULL;
    AbortCommandsWithFlag(pFileContext,
                          pDlcParms->InputCcb.u.ulParameter, // CompletionFlag
                          &pDlcParms->InputCcb.pCcbAddress,
                          DLC_STATUS_CANCELLED_BY_USER
                          );
    return STATUS_SUCCESS;
}


NTSTATUS
DirTimerCancel(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This primitive cancels the given timer command in a
    special timer queue.

Arguments:

    pIrp                - current io request packet
    pFileContext        - DLC process specific adapter context
    pDlcParms           - the current parameter block
    InputBufferLength   - the length of input parameters

Return Value:

    NTSTATUS:
        STATUS_SUCCESS
        DLC_STATUS_TIMER_ERROR
--*/

{
    PDLC_COMMAND pDlcCommand;
    PDLC_COMMAND *ppDlcCommand;
    PVOID pCcbAddress = NULL;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    ppDlcCommand = SearchTimerCommand(&pFileContext->pTimerQueue,
                                      pDlcParms->DlcCancelCommand.CcbAddress,
                                      FALSE
                                      );

    //
    // if the timer queue is not empty, cancel the timed DLC request else
    // return an error
    //

    if (ppDlcCommand != NULL && *ppDlcCommand != NULL) {
        pDlcCommand = *ppDlcCommand;
        *ppDlcCommand = (PDLC_COMMAND)pDlcCommand->LlcPacket.pNext;

// >>> SNA bug #10126
		//
		// If there's a next timer after the canceled one we need to update
		// it's tick count. Things will go really wrong if the next timer's tick
		// count is 0 (it expires at the same time as the canceled one) because
		// the timer tick routine (LlcEventIndication) first decrements the tick
		// value and then checks if the result is 0.
		//
		if( *ppDlcCommand )
		{
			(*ppDlcCommand)->Overlay.TimerTicks += pDlcCommand->Overlay.TimerTicks;
			if((*ppDlcCommand)->Overlay.TimerTicks == 0)
			{
                (*ppDlcCommand)->Overlay.TimerTicks++;
			}
		}
// >>> SNA bug #10126

#if LLC_DBG
        pDlcCommand->LlcPacket.pNext = NULL;
#endif

        CancelDlcCommand(pFileContext,
                         pDlcCommand,
                         &pCcbAddress,
                         DLC_STATUS_CANCELLED_BY_USER,
                         TRUE
                         );
        return STATUS_SUCCESS;
    } else {
        return DLC_STATUS_TIMER_ERROR;
    }
}


PDLC_COMMAND*
SearchTimerCommand(
    IN PDLC_COMMAND *ppQueue,
    IN PVOID pSearchHandle,
    IN BOOLEAN SearchCompletionFlags
    )

/*++

Routine Description:

    This primitive cancels the given timer command in a
    special timer queue.

Arguments:

    ppQueue - the base address of the command queue

    pSearchHandle - command completion flag or ccb address of
        the timer command.

    SearchCompletionFlags - ste TRUE, if we are searching a completion flag

Return Value:

    PDLC_COMMAND * the address of the address of the found timer command

--*/

{
    PDLC_COMMAND pCmd;

    for (; *ppQueue != NULL; ppQueue = (PDLC_COMMAND *)&(*ppQueue)->LlcPacket.pNext) {

        pCmd = *ppQueue;

        //
        // A Timer command can be cancelled either by its CCB address
        // or by its command completion flag.  The boolean flag
        // defines the used search condition.
        // We will rather space than speed optimize the rarely used
        // procedures like this one.
        //

        if (pSearchHandle
            == (SearchCompletionFlags
                ? (PVOID)
                    UlongToPtr(((PNT_DLC_CCB)pCmd->pIrp->AssociatedIrp.SystemBuffer)->CommandCompletionFlag)
                : pCmd->AbortHandle)) {

            return ppQueue;

        }
    }
    return NULL;
}


VOID
AbortCommandsWithFlag(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN ULONG CommandCompletionFlag,
    IN OUT PVOID *ppCcbLink,
    IN UINT CancelStatus
    )

/*++

Routine Description:

    The command cancels all (timer) commands having the given command
    completion flag.

Arguments:

    pFileContext - process specific adapetr context

    EventMask - the event mask defining the canceled command

    CommandCompletionFlag - the command completion flag of the canceled
        commands

    ppCcbLink - the canceled commands are linked by their next CCB pointer
        fields together.  The caller must provide the next CCB address
        in this parameter (usually *ppCcbLink == NULL) and the function
        will return the address of the last canceled CCB field.

Return Value:

    DLC_STATUS_TIMER_ERROR - no mathing command was found
    STATUS_SUCCESS - the command was canceled

--*/

{
    PDLC_COMMAND pDlcCommand;
    PDLC_COMMAND *ppQueue;
    PVOID pNextCcb = NULL;

    ppQueue = &pFileContext->pTimerQueue;

    for (;;) {

        ppQueue = SearchTimerCommand(ppQueue,
                                     (PVOID)UlongToPtr(CommandCompletionFlag),
                                     TRUE
                                     );
        if (ppQueue != NULL) {
            pDlcCommand = *ppQueue;
            *ppQueue = (PDLC_COMMAND)pDlcCommand->LlcPacket.pNext;

#if LLC_DBG
            pDlcCommand->LlcPacket.pNext = NULL;
#endif

            *ppCcbLink = ((PNT_DLC_PARMS)pDlcCommand->pIrp->AssociatedIrp.SystemBuffer)->Async.Ccb.pCcbAddress;

            //
            // We must suppress any kind of command
            // completion indications to the applications.
            // It is very intersting to see, if Io- system hangs up
            // because of this modification.
            //

            pDlcCommand->pIrp->UserEvent = NULL;
            pDlcCommand->pIrp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
            pDlcCommand->pIrp->Overlay.AsynchronousParameters.UserApcContext = NULL;
            CompleteAsyncCommand(pFileContext, CancelStatus, pDlcCommand->pIrp, pNextCcb, FALSE);
            pNextCcb = *ppCcbLink;

            DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pDlcCommand);

        } else {

            //
            // This procedure do not care if we find any commands
            // or not. Everything is ok, when there are no commands
            // in the queue.
            //

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    llc.h

Abstract:

    This module includes all files needed by LLC data link modules.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/


//
//  This define enables the private DLC function prototypes
//  We don't want to export our data types to the dlc layer.
//  MIPS compiler doesn't accept hiding of the internal data
//  structures by a PVOID in the function prototype.
//  i386 builds will use the same prototypes everywhere (and thus
//  they checks that the numebr of parameters is correct)

//
#ifndef i386

#define LLC_PRIVATE_PROTOTYPES

#ifndef LLC_PUBLIC_NDIS_PROTOTYPES
#define LLC_PRIVATE_NDIS_PROTOTYPES
#endif

#endif


#ifndef DLC_INCLUDED

#include <ntddk.h>
#include <ndis.h>

#define APIENTRY
#include <dlcapi.h>
#include <dlcio.h>
#include <llcapi.h>

#include <memory.h>

#endif

#include "dlcreg.h"

#ifndef LLC_INCLUDED

#define LLC_INCLUDED

#include <llcdef.h>
#include <llctyp.h>
#include <llcext.h>
#include <llcmac.h>

#endif // LLC_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcdef.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dldef.h

Abstract:

    This module defines all internal constants in data link driver.

Author:

    Antti Saarenheimo (o-anttis) 25-MAY-1991

Revision History:

--*/

#define DEBUG_VERSION 1

//
// Marks for FSM compiler
//

#define FSM_DATA
#define FSM_PREDICATE_CASES
#define FSM_ACTION_CASES
#define FSM_CONST

#define MAX_NDIS_PACKETS        5       // 5 for XID/TEST and 5 for others
#define LLC_OPEN_TIMEOUT        1200    // 60 seconds (enough for tr open?)

#define DEFAULT_TR_ACCESS       0x50
#define NON_MAC_FRAME           0x40

//
// 2nd source routing control bit
//

#define SRC_ROUTING_LF_MASK     0x70

#define MAX_TR_LAN_HEADER_SIZE  32
#define LLC_MAX_LAN_HEADER      32
#define MAX_TR_SRC_ROUTING_INFO 18

//
// the next status values are used internally by DLCAPI driver:
//

#define CONFIRM_CONNECT         0x0008
#define CONFIRM_DISCONNECT      0x0004
#define CONFIRM_CONNECT_FAILED  0x0002

//
// The following structures define I-frame, U-frame, and S-frame DLC headers.
//

#define LLC_SSAP_RESPONSE       0x0001  // if (ssap & LLC_SSAP_RESP),it's a response.
#define LLC_DSAP_GROUP          0x0001  // Dsap lowest bit set when group sap
#define LLC_SSAP_GLOBAL         0x00ff  // the global SAP.
#define LLC_SSAP_NULL           0x0000  // the null SAP.
#define LLC_SSAP_MASK           0x00fe  // mask to wipe out the response bit.
#define LLC_DSAP_MASK           0x00fe  // mask to wipe out the group SAP bit.

#define LLC_RR                  0x01    // command code for RR.
#define LLC_RNR                 0x05    // command code for RNR.
#define LLC_REJ                 0x09    // command code for REJ.

#define LLC_SABME               0x6f    // command code for SABME.
#define LLC_DISC                0x43    // command code for DISC.
#define LLC_UA                  0x63    // command code for UA.
#define LLC_DM                  0x0f    // command code for DM.
#define LLC_FRMR                0x87    // command code for FRMR.
#define LLC_UI                  0x03    // command code for UI.
#define LLC_XID                 0xaf    // command code for XID.
#define LLC_TEST                0xe3    // command code for TEST.
#define IEEE_802_XID_ID         0x81    // IEEE 802.2 XID identifier
#define LLC_CLASS_II            3       // we support LLC Class II

#define LLC_S_U_TYPE_MASK       3
#define LLC_U_TYPE              3
#define LLC_U_TYPE_BIT          2
#define LLC_S_TYPE              1

#define LLC_NOT_I_FRAME         0x01
#define LLC_U_INDICATOR         0x03  // (cmd & LLC_U_IND) == LLC_U_IND --> U-frame.
#define LLC_U_POLL_FINAL        0x10  // (cmd & LLC_U_PF) -> poll/final set.

#define LLC_I_S_POLL_FINAL      1

//
// You may use 2048 or 1024 if you want to make link more aggressively to
// increment the transmit window when there has been a I-c1 retransmission
// after a T1 timeout.
//

#define LLC_MAX_T1_TO_I_RATIO   4096

//
// Link station flags
//

#define DLC_WAITING_RESPONSE_TO_POLL        0x01
#define DLC_FIRST_POLL                      0x02
#define DLC_ACTIVE_REMOTE_CONNECT_REQUEST   0x04
#define DLC_SEND_DISABLED                   0x10
#define DLC_FINAL_RESPONSE_PENDING_IN_NDIS  0x20

#define DLC_LOCAL_BUSY_BUFFER   0x40
#define DLC_LOCAL_BUSY_USER     0x80

//
// Test file for FSM compiler!!!!
//

#ifdef FSM_CONST

enum eLanLlcInput {
    DISC0 = 0,
    DISC1 = 1,
    DM0 = 2,
    DM1 = 3,
    FRMR0 = 4,
    FRMR1 = 5,
    SABME0 = 6,
    SABME1 = 7,
    UA0 = 8,
    UA1 = 9,
    IS_I_r0 = 10,
    IS_I_r1 = 11,
    IS_I_c0 = 12,
    IS_I_c1 = 13,
    OS_I_r0 = 14,
    OS_I_r1 = 15,
    OS_I_c0 = 16,
    OS_I_c1 = 17,
    REJ_r0 = 18,
    REJ_r1 = 19,
    REJ_c0 = 20,
    REJ_c1 = 21,
    RNR_r0 = 22,
    RNR_r1 = 23,
    RNR_c0 = 24,
    RNR_c1 = 25,
    RR_r0 = 26,
    RR_r1 = 27,
    RR_c0 = 28,
    RR_c1 = 29,
    LPDU_INVALID_r0 = 30,
    LPDU_INVALID_r1 = 31,
    LPDU_INVALID_c0 = 32,
    LPDU_INVALID_c1 = 33,
    ACTIVATE_LS = 34,
    DEACTIVATE_LS = 35,
    ENTER_LCL_Busy = 36,
    EXIT_LCL_Busy = 37,
    SEND_I_POLL = 38,
    SET_ABME = 39,
    SET_ADM = 40,
    Ti_Expired = 41,
    T1_Expired = 42,
    T2_Expired = 43
};

enum eLanLlcState {
    LINK_CLOSED = 0,
    DISCONNECTED = 1,
    LINK_OPENING = 2,
    DISCONNECTING = 3,
    FRMR_SENT = 4,
    LINK_OPENED = 5,
    LOCAL_BUSY = 6,
    REJECTION = 7,
    CHECKPOINTING = 8,
    CHKP_LOCAL_BUSY = 9,
    CHKP_REJECT = 10,
    RESETTING = 11,
    REMOTE_BUSY = 12,
    LOCAL_REMOTE_BUSY = 13,
    REJECT_LOCAL_BUSY = 14,
    REJECT_REMOTE_BUSY = 15,
    CHKP_REJECT_LOCAL_BUSY = 16,
    CHKP_CLEARING = 17,
    CHKP_REJECT_CLEARING = 18,
    REJECT_LOCAL_REMOTE_BUSY = 19,
    FRMR_RECEIVED = 20
};

#endif

#define MAX_LLC_LINK_STATE      21      // KEEP THIS IN SYNC WITH PREV ENUM!!!!

#define DLC_DSAP_OFFSET         0
#define DLC_SSAP_OFFSET         1
#define DLC_COMMAND_OFFSET      2
#define DLC_XID_INFO_ID         3
#define DLC_XID_INFO_TYPE       4
#define DLC_XID_INFO_WIN_SIZE   5

#define MAX_XID_TEST_RESPONSES  20

enum _LLC_FRAME_XLATE_MODES {
    LLC_SEND_UNSPECIFIED = -1,
    LLC_SEND_802_5_TO_802_3,
    LLC_SEND_802_5_TO_DIX,
    LLC_SEND_802_5_TO_802_5,
    LLC_SEND_802_5_TO_FDDI,
    LLC_SEND_DIX_TO_DIX,
    LLC_SEND_802_3_TO_802_3,
    LLC_SEND_802_3_TO_DIX,
    LLC_SEND_802_3_TO_802_5,
    LLC_SEND_UNMODIFIED,
    LLC_SEND_FDDI_TO_FDDI,
    LLC_SEND_FDDI_TO_802_5,
    LLC_SEND_FDDI_TO_802_3
};

#define DLC_TOKEN_RESPONSE  0
#define DLC_TOKEN_COMMAND   2

//*********************************************************************
//  **** Objects in _DLC_CMD_TOKENs enumeration and in auchLlcCommands
//  **** table bust MUST ABSOLUTELY BE IN THE SAME ORDER, !!!!!!!!
//  **** THEY ARE USED TO COMPRESS                             ********
//  **** THE SEND INITIALIZATION                               ********
//
enum _DLC_CMD_TOKENS {
    DLC_REJ_TOKEN = 4,
    DLC_RNR_TOKEN = 8,
    DLC_RR_TOKEN = 12,
    DLC_DISC_TOKEN = 16 | DLC_TOKEN_COMMAND,
    DLC_DM_TOKEN = 20,
    DLC_FRMR_TOKEN = 24,
    DLC_SABME_TOKEN = 28 | DLC_TOKEN_COMMAND,
    DLC_UA_TOKEN = 32
};

enum _LLC_PACKET_TYPES {
    LLC_PACKET_8022 = 0,
    LLC_PACKET_MAC,
    LLC_PACKET_DIX,
    LLC_PACKET_OTHER_DESTINATION,
    LLC_PACKET_MAX
};

#define MAX_DIX_TABLE 13      // good odd number!

enum _LlcSendCompletionTypes {
    LLC_XID_RESPONSE,       // 802.2 XID response packet
    LLC_U_COMMAND_RESPONSE, // link command response
    LLC_MIN_MDL_PACKET,     // all packets above this have MDL
    LLC_DIX_DUPLICATE,      // used to duplicate TEST and XID packets
    LLC_TEST_RESPONSE,      // Test response (buffer in non Paged Pool)
    LLC_MAX_RESPONSE_PACKET,// all packets above this are indicated to user
    LLC_TYPE_1_PACKET,
    LLC_TYPE_2_PACKET,

    //
    // We use extra status bits to indicate, when I- packet has been both
    // completed by NDIS and acknowledged the other side of link connection.
    // An I packet can be queued to the completion queue by
    // the second guy (either state machine or SendCompletion handler)
    // only when the first guy has set completed its work.
    // An I packet could be acknowledged by the other side before
    // its completion is indicated by NDIS.  Dlc Driver deallocates
    // the packet immediately, when Llc driver completes the acknowledged
    // packet => possible data corruption (if packet is reused before
    // NDIS has completed it).  This is probably not possible in a
    // single processor  NT- system, but very possible in multiprocessor
    // NT or systems without a single level DPC queue (like OS/2 and DOS).
    //

    LLC_I_PACKET_COMPLETE = 0x10,
    LLC_I_PACKET_UNACKNOWLEDGED = 0x20,
    LLC_I_PACKET_PENDING_NDIS   = 0x40,
    LLC_I_PACKET                = 0x70,          // when we are sending it
    LLC_I_PACKET_WAITING_NDIS   = 0x80
};

#define LLC_MAX_MULTICAST_ADDRESS 32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcapi.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcapi.h

Abstract:

    This module defined the kernel API of data link driver.
    All function prototypes and typedefs of the interface
    have been defined here.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

#ifndef _LLC_API_
#define _LLC_API_

#include "llcmem.h"

//
//  The debug switches
//

//
//  LLC_DBG:
//
//  0   => No debug code is generated
//  1   => Enables the memory allocation accounting, state machine tracing,
//         procedure call tracing and internal consistency checks
//  2   => Enables memory block overflow checking
//
//

#define LLC_DBG  0
#define DBG_MP   0   // enables the MP safe versions of the accounting macros

#define DLC_TRACE_ENABLED 1	// Procedure call tracing, debug only.

extern NDIS_SPIN_LOCK DlcDriverLock;

//
// ANY_IRQL: pseudo value used in ASSUME_IRQL to mean routine is not IRQL sensitive.
// Use this value with ASSUME_IRQL instead of omitting ASSUME_IRQL from a routine
// (shows that we didn't forget this routine)
//

#define ANY_IRQL    ((ULONG)-1)

#if defined(LOCK_CHECK)

extern LONG DlcDriverLockLevel;
extern ULONG __line;
extern PCHAR __file;
extern LONG __last;
extern HANDLE __process;
extern HANDLE __thread;

//
// _strip - quick functionette to strip out the path garbage from __FILE__
//

__inline char* _strip(char* s) {

    char* e = s + strlen(s) - 1;

    while (e != s) {
        if (*e == '\\') {
            return e + 1;
        }
        --e;
    }
    return s;
}

#define $$_PLACE            "%s!%d"
#define $$_FILE_AND_LINE    _strip(__FILE__), __LINE__

//
// ACQUIRE_DRIVER_LOCK - acquires the global DLC driver Spin Lock, using
// NdisAcquireSpinLock(). We also check for re-entrancy and incorrect ordering
// of spin lock calls
//

#define ACQUIRE_DRIVER_LOCK() \
{ \
    KIRQL currentIrql; \
    HANDLE hprocess; \
    HANDLE hthread; \
\
    currentIrql = KeGetCurrentIrql(); \
    if (currentIrql == PASSIVE_LEVEL) { \
\
        PETHREAD pthread; \
\
        pthread = PsGetCurrentThread(); \
        hprocess = pthread->Cid.UniqueProcess; \
        hthread = pthread->Cid.UniqueThread; \
    } else { \
        hprocess = (HANDLE)-1; \
        hthread = (HANDLE)-1; \
    } \
    NdisAcquireSpinLock(&DlcDriverLock); \
    if (++DlcDriverLockLevel != 1) { \
        __last = DlcDriverLockLevel; \
        DbgPrint("%d.%d:" $$_PLACE ": ACQUIRE_DRIVER_LOCK: level = %d. Last = %d.%d:" $$_PLACE "\n", \
                 hprocess, \
                 hthread, \
                 $$_FILE_AND_LINE, \
                 DlcDriverLockLevel, \
                 __process, \
                 __thread, \
                 __file, \
                 __line \
                 ); \
        DbgBreakPoint(); \
    } \
    __file = _strip(__FILE__); \
    __line = __LINE__; \
    __process = hprocess; \
    __thread = hthread; \
    ASSUME_IRQL(DISPATCH_LEVEL); \
}

//
// RELEASE_DRIVER_LOCK - releases the global DLC driver Spin Lock, using
// NdisReleaseSpinLock(). We also check for re-entrancy and incorrect ordering
// of spin lock calls
//

#define RELEASE_DRIVER_LOCK() \
    if (DlcDriverLockLevel != 1) { \
        DbgPrint($$_PLACE ": RELEASE_DRIVER_LOCK: level = %d. Last = %d.%d:" $$_PLACE "\n", \
                 $$_FILE_AND_LINE, \
                 DlcDriverLockLevel, \
                 __process, \
                 __thread, \
                 __file, \
                 __line \
                 ); \
        DbgBreakPoint(); \
    } \
    --DlcDriverLockLevel; \
    __file = _strip(__FILE__); \
    __line = __LINE__; \
    NdisReleaseSpinLock(&DlcDriverLock);

//
// ASSUME_IRQL - used to check that a routine is being called at the IRQL we
// expect. Due to the design of DLC, most functions are called at raised IRQL
// (DISPATCH_LEVEL). Used mainly to assure that IRQL is at PASSIVE_LEVEL when
// we do something which may incur a page fault e.g.
//

#define ASSUME_IRQL(level) \
    if (((level) != ANY_IRQL) && (KeGetCurrentIrql() != (level))) { \
        DbgPrint($$_PLACE ": ASSUME_IRQL(%d): Actual is %d\n", \
                 $$_FILE_AND_LINE, \
                 level, \
                 KeGetCurrentIrql() \
                 ); \
        DbgBreakPoint(); \
    }

//
// MY_ASSERT - since ASSERT only expands to something meaningful in the checked
// build, we use this when we want an assertion check in a free build
//

#define MY_ASSERT(x) \
    if (!(x)) { \
        DbgPrint($$_PLACE ": Assertion Failed: " # x "\n", \
                 $$_FILE_AND_LINE \
                 ); \
        DbgBreakPoint(); \
    }

//
// IF_LOCK_CHECK - conditional compilation made cleaner
//

#define IF_LOCK_CHECK \
    if (TRUE)

#else

#define ACQUIRE_DRIVER_LOCK()   NdisAcquireSpinLock(&DlcDriverLock)
#define RELEASE_DRIVER_LOCK()   NdisReleaseSpinLock(&DlcDriverLock)
#define ASSUME_IRQL(level)      /* NOTHING */
#define MY_ASSERT(x)            /* NOTHING */
#define IF_LOCK_CHECK           if (FALSE)

#endif

//
// in the Unilock DLC, we do not need the LLC spin-lock
//

#if defined(DLC_UNILOCK)

#define ACQUIRE_LLC_LOCK(i)
#define RELEASE_LLC_LOCK(i)

#define ACQUIRE_SPIN_LOCK(p)
#define RELEASE_SPIN_LOCK(p)

#define ALLOCATE_SPIN_LOCK(p)
#define DEALLOCATE_SPIN_LOCK(p)

#else

#define ACQUIRE_LLC_LOCK(i)     KeAcquireSpinLock(&LlcSpinLock, (i))
#define RELEASE_LLC_LOCK(i)     KeReleaseSpinLock(&LlcSpinLock, (i))

#define ACQUIRE_SPIN_LOCK(p)    NdisAcquireSpinLock((p))
#define RELEASE_SPIN_LOCK(p)    NdisReleaseSpinLock((p))

#define ALLOCATE_SPIN_LOCK(p)   KeInitializeSpinLock(&(p)->SpinLock)
#define DEALLOCATE_SPIN_LOCK(p)

#endif

//
// IS_SNA_DIX_FRAME - TRUE if the frame just received & therefore described in
// the ADAPTER_CONTEXT (p) has DIX framing (SNA)
//

#define IS_SNA_DIX_FRAME(p) \
    (((PADAPTER_CONTEXT)(p))->IsSnaDixFrame)

//
// IS_AUTO_BINDING - TRUE if the BINDING_CONTEXT was created with
// LLC_ETHERNET_TYPE_AUTO
//

#define IS_AUTO_BINDING(p) \
    (((PBINDING_CONTEXT)(p))->EthernetType == LLC_ETHERNET_TYPE_AUTO)

#define FRAME_MASK_LLC_LOCAL_DEST       0x0001
#define FRAME_MASK_NON_LLC_LOCAL_DEST   0x0002
#define FRAME_MASK_NON_LOCAL_DEST       0x0004
#define FRAME_MASK_ALL_FRAMES           0x0007

#define LLC_EXCLUSIVE_ACCESS            0x0001
#define LLC_HANDLE_XID_COMMANDS         0x0002

//
// Direct station receive flags (bits 0 and 1 are inverted from dlcapi!!!)
//

#define DLC_RCV_SPECIFIC_DIX            0
#define DLC_RCV_MAC_FRAMES              1
#define DLC_RCV_8022_FRAMES             2
#define DLC_RCV_DIX_FRAMES              4
#define LLC_VALID_RCV_MASK              7
#define DLC_RCV_OTHER_DESTINATION       8

#define MAX_LLC_FRAME_TYPES 10

//
// The DLC link states reported by DLC API
//

enum _DATA_LINK_STATES {

    //
    // Primary states
    //

    LLC_LINK_CLOSED             = 0x80,
    LLC_DISCONNECTED            = 0x40,
    LLC_DISCONNECTING           = 0x20,
    LLC_LINK_OPENING            = 0x10,
    LLC_RESETTING               = 0x08,
    LLC_FRMR_SENT               = 0x04,
    LLC_FRMR_RECEIVED           = 0x02,
    LLC_LINK_OPENED             = 0x01,

    //
    // Secondary states (when primary state is LLC_LINK_OPENED)
    //

    LLC_CHECKPOINTING           = 0x80,
    LLC_LOCAL_BUSY_USER_SET     = 0x40,
    LLC_LOCAL_BUSY_BUFFER_SET   = 0x20,
    LLC_REMOTE_BUSY             = 0x10,
    LLC_REJECTING               = 0x08,
    LLC_CLEARING                = 0x04,
    LLC_DYNMIC_WIN_ALG_RUNNIG   = 0x02,
    LLC_NO_SECONDARY_STATE      = 0
};

//
// LAN802_ADDRESS - 8 bytes of frame address. Typically 6 bytes LAN address
// plus 1 byte destination SAP, plus 1 byte source SAP
//

typedef union {

    struct {
        UCHAR DestSap;
        UCHAR SrcSap;
        USHORT usHigh;
        ULONG ulLow;
    } Address;

    struct {
        ULONG High;
        ULONG Low;
    } ul;

    struct {
        USHORT Raw[4];
    } aus;

    struct {
        UCHAR DestSap;
        UCHAR SrcSap;
        UCHAR auchAddress[6];
    }  Node;

    UCHAR auchRawAddress[8];

} LAN802_ADDRESS, *PLAN802_ADDRESS;

//
// Structure is used by DlcNdisRequest function
//

typedef struct {
    NDIS_STATUS AsyncStatus;
    KEVENT SyncEvent;
    NDIS_REQUEST Ndis;
} LLC_NDIS_REQUEST, *PLLC_NDIS_REQUEST;

#define NDIS_INFO_BUF_SIZE          20

#define DLC_ANY_STATION             (-1)

//
// Internal event flags used by Timer, DlcConnect
// and DlcClose commands.
//

#define DLC_REPEATED_FLAGS          0x0700
#define LLC_TIMER_TICK_EVENT        0x0100
#define LLC_STATUS_CHANGE_ON_SAP    0x0800

//
// These enum types are used also as the index of a mapping table!
//

enum _LLC_OBJECT_TYPES {
    LLC_DIRECT_OBJECT,
    LLC_SAP_OBJECT,
    LLC_GROUP_SAP_OBJECT,
    LLC_LINK_OBJECT,
    LLC_DIX_OBJECT
};

//
// We moved these defines here because the macro is used by data link
//

#define MIN_DLC_BUFFER_SEGMENT      256
////#define MAX_DLC_BUFFER_SEGMENT      4096
//#define MAX_DLC_BUFFER_SEGMENT      8192
#define MAX_DLC_BUFFER_SEGMENT      PAGE_SIZE

#define BufGetPacketSize( PacketSize ) \
                (((PacketSize) + 2 * MIN_DLC_BUFFER_SEGMENT - 1) & \
                -MIN_DLC_BUFFER_SEGMENT)

//
// READ Event flags:
//

#define DLC_READ_FLAGS              0x007f
#define LLC_SYSTEM_ACTION           0x0040
#define LLC_NETWORK_STATUS          0x0020
#define LLC_CRITICAL_EXCEPTION      0x0010
#define LLC_STATUS_CHANGE           0x0008
#define LLC_RECEIVE_DATA            0x0004
#define LLC_TRANSMIT_COMPLETION     0x0002
#define DLC_COMMAND_COMPLETION      0x0001

#define ALL_DLC_EVENTS              -1

//
// LLC_STATUS_CHANGE indications:
//

#define INDICATE_LINK_LOST              0x8000
#define INDICATE_DM_DISC_RECEIVED       0x4000
#define INDICATE_FRMR_RECEIVED          0x2000
#define INDICATE_FRMR_SENT              0x1000
#define INDICATE_RESET                  0x0800
#define INDICATE_CONNECT_REQUEST        0x0400
#define INDICATE_REMOTE_BUSY            0x0200
#define INDICATE_REMOTE_READY           0x0100
#define INDICATE_TI_TIMER_EXPIRED       0x0080
#define INDICATE_DLC_COUNTER_OVERFLOW   0x0040
#define INDICATE_ACCESS_PRTY_LOWERED    0x0020
#define INDICATE_LOCAL_STATION_BUSY     0x0001

//
// LLC Command completion indications.
//

enum _LLC_COMPLETION_CODES {
    LLC_RECEIVE_COMPLETION,
    LLC_SEND_COMPLETION,
    LLC_REQUEST_COMPLETION,
    LLC_CLOSE_COMPLETION,
    LLC_RESET_COMPLETION,
    LLC_CONNECT_COMPLETION,
    LLC_DISCONNECT_COMPLETION
};

typedef union {
    LLC_ADAPTER_INFO Adapter;
    DLC_LINK_PARAMETERS LinkParms;
    LLC_TICKS Timer;
    DLC_LINK_LOG LinkLog;
    DLC_SAP_LOG SapLog;
    UCHAR PermanentAddress[6];
    UCHAR auchBuffer[1];
} LLC_QUERY_INFO_BUFFER, *PLLC_QUERY_INFO_BUFFER;

typedef union {
    DLC_LINK_PARAMETERS LinkParms;
    LLC_TICKS Timers;
    UCHAR auchFunctionalAddress[4];
    UCHAR auchGroupAddress[4];
    UCHAR auchBuffer[1];
} LLC_SET_INFO_BUFFER, *PLLC_SET_INFO_BUFFER;

//
// LLC_FRMR_INFORMATION - 5 bytes of FRaMe Reject code
//

typedef struct {
    UCHAR Command;              // format: mmmpmm11, m=modifiers, p=poll/final.
    UCHAR Ctrl;                 // control field of rejected frame.
    UCHAR Vs;                   // our next send when error was detected.
    UCHAR Vr;                   // our next receive when error was detected.
    UCHAR Reason;               // reason for sending FRMR: 000VZYXW.
} LLC_FRMR_INFORMATION, *PLLC_FRMR_INFORMATION;

//
// DLC_STATUS_TABLE - format of status information returned in a READ command
//

typedef struct {
    USHORT StatusCode;
    LLC_FRMR_INFORMATION FrmrData;
    UCHAR uchAccessPriority;
    UCHAR auchRemoteNode[6];
    UCHAR uchRemoteSap;
    UCHAR uchLocalSap;
    PVOID hLlcLinkStation;
} DLC_STATUS_TABLE, *PDLC_STATUS_TABLE;

typedef struct {
    ULONG IsCompleted;
    ULONG Status;
} ASYNC_STATUS, *PASYNC_STATUS;

union _LLC_OBJECT;
typedef union _LLC_OBJECT LLC_OBJECT, *PLLC_OBJECT;

struct _BINDING_CONTEXT;
typedef struct _BINDING_CONTEXT BINDING_CONTEXT, *PBINDING_CONTEXT;

//
// LLC packet headers
//

//
// LLC_XID_INFORMATION - 3 information bytes in a standard LLC XID packet
//

typedef struct {
    UCHAR FormatId;             // format of this XID frame.
    UCHAR Info1;                // first information byte.
    UCHAR Info2;                // second information byte.
} LLC_XID_INFORMATION, *PLLC_XID_INFORMATION;

//
// LLC_TEST_INFORMATION - information field for TEST frame
//

typedef struct {
    UCHAR Padding[4];
    PMDL pMdl;                  // we keep test MDL in the same slot as U-MDL
} LLC_TEST_INFORMATION, *PLLC_TEST_INFORMATION;

typedef union {
    LLC_XID_INFORMATION Xid;    // XID information.
    LLC_FRMR_INFORMATION Frmr;  // FRMR information.
    LLC_TEST_INFORMATION Test;  // Test MDL pointer
    UCHAR Padding[8];           //
} LLC_RESPONSE_INFO, *PLLC_RESPONSE_INFO;

//
// LLC_U_HEADER - Unnumbered format frame LLC header
//

typedef struct {
    UCHAR Dsap;                 // Destination Service Access Point.
    UCHAR Ssap;                 // Source Service Access Point.
    UCHAR Command;              // command code.
} LLC_U_HEADER, *PLLC_U_HEADER;

//
// LLC_S_HEADER - Supervisory format frame LLC header
//

typedef struct {
    UCHAR Dsap;                 // Destination Service Access Point.
    UCHAR Ssap;                 // Source Service Access Point.
    UCHAR Command;              // RR, RNR, REJ command code.
    UCHAR Nr;                   // receive seq #, bottom bit is poll/final.
} LLC_S_HEADER, *PLLC_S_HEADER;

//
// LLC_I_HEADER - Information frame LLC header
//

typedef struct {
    UCHAR Dsap;                 // Destination Service Access Point.
    UCHAR Ssap;                 // Source Service Access Point.
    UCHAR Ns;                   // send sequence number, bottom bit 0.
    UCHAR Nr;                   // rcv sequence number, bottom bit p/f.
} LLC_I_HEADER, *PLLC_I_HEADER;

typedef struct {
    LLC_U_HEADER U;             // normal U- frame
    UCHAR Type;                 // its lan header conversion type
} LLC_U_PACKET_HEADER, *PLLC_U_PACKET_HEADER;

typedef union {
    LLC_S_HEADER S;
    LLC_I_HEADER I;
    LLC_U_HEADER U;
    ULONG ulRawLLc;
    UCHAR auchRawBytes[4];
    USHORT EthernetType;
} LLC_HEADER, *PLLC_HEADER;

typedef struct _LLC_PACKET {

    struct _LLC_PACKET* pNext;
    struct _LLC_PACKET* pPrev;
    UCHAR CompletionType;
    UCHAR cbLlcHeader;
    USHORT InformationLength;
    PBINDING_CONTEXT pBinding;

    union {

        struct {
            PUCHAR pLanHeader;
            LLC_HEADER LlcHeader;
            PLLC_OBJECT pLlcObject;
            PMDL pMdl;
        } Xmit;

        struct {
            PUCHAR pLanHeader;
            UCHAR TranslationType;
            UCHAR Dsap;
            UCHAR Ssap;
            UCHAR Command;
            PLLC_OBJECT pLlcObject;
            PMDL pMdl;
        } XmitU;

        struct {
            PUCHAR pLanHeader;
            UCHAR TranslationType;
            UCHAR EthernetTypeHighByte;
            UCHAR EthernetTypeLowByte;
            UCHAR Padding;
            PLLC_OBJECT pLlcObject;
            PMDL pMdl;
        } XmitDix;

        struct {
            PUCHAR pLanHeader;
            UCHAR TranslationType;
            UCHAR Dsap;
            UCHAR Ssap;
            UCHAR Command;
            LLC_RESPONSE_INFO Info;
        } Response;

        //
        // Link station data packet may be acknowledged by the other
        // side, before it is completed by NDIS.  Ndis completion
        // routine expects to find pLlcObject link => we must not change
        // that field, when the xmit packet is translated to
        // a completion packet.  Otherwise is corrupt pFileContext pointer,
        // when NdisSendCount is incremented.
        //

        struct {
            ULONG Status;
            ULONG CompletedCommand;
            PLLC_OBJECT pLlcObject;
            PVOID hClientHandle;
        } Completion;

    } Data;

} LLC_PACKET, *PLLC_PACKET;

//
// DLC API return codes
//
// The base value of the error codes is not compatible with the other
// nt error codes, but it doesn't matter because these are internal
// for DLC driver (and its data link layer).
// 16 bit- error codes are used, because in MIPS they need less
// instructions (MIPS cannot load directly over 16 bits constants)
// and this code can also be emuulated on OS/2.
//

typedef enum _DLC_STATUS {
    DLC_STATUS_SUCCESS                          = 0,
    DLC_STATUS_ERROR_BASE                       = 0x6000,
    DLC_STATUS_INVALID_COMMAND                  = 0x01 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_DUPLICATE_COMMAND                = 0x02 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ADAPTER_OPEN                     = 0x03 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ADAPTER_CLOSED                   = 0x04 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_PARAMETER_MISSING                = 0x05 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_OPTION                   = 0x06 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_COMMAND_CANCELLED_FAILURE        = 0x07 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CANCELLED_BY_USER                = 0x0A + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_SUCCESS_NOT_OPEN                 = 0x0C + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_TIMER_ERROR                      = 0x11 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_NO_MEMORY                        = 0x12 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LOST_LOG_DATA                    = 0x15 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_BUFFER_SIZE_EXCEEDED             = 0x16 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_BUFFER_LENGTH            = 0x18 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INADEQUATE_BUFFERS               = 0x19 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_USER_LENGTH_TOO_LARGE            = 0x1A + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_CCB_POINTER              = 0x1B + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_POINTER                  = 0x1C + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_ADAPTER                  = 0x1D + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_FUNCTIONAL_ADDRESS       = 0x1E + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LOST_DATA_NO_BUFFERS             = 0x20 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_TRANSMIT_ERROR_FS                = 0x22 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_TRANSMIT_ERROR                   = 0x23 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_UNAUTHORIZED_MAC                 = 0x24 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LINK_NOT_TRANSMITTING            = 0x27 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_FRAME_LENGTH             = 0x28 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_NODE_ADDRESS             = 0x32 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_RECEIVE_BUFFER_LENGTH    = 0x33 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_TRANSMIT_BUFFER_LENGTH   = 0x34 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_STATION_ID               = 0x40 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LINK_PROTOCOL_ERROR              = 0x41 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_PARMETERS_EXCEEDED_MAX           = 0x42 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_SAP_VALUE                = 0x43 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_ROUTING_INFO             = 0x44 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_LINK_STATIONS_OPEN               = 0x47 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INCOMPATIBLE_COMMAND_IN_PROGRESS = 0x4A + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CONNECT_FAILED                   = 0x4D + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_REMOTE_ADDRESS           = 0x4F + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CCB_POINTER_FIELD                = 0x50 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INADEQUATE_LINKS                 = 0x57 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_PARAMETER_1              = 0x58 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_DIRECT_STATIONS_NOT_AVAILABLE    = 0x5C + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_DEVICE_DRIVER_NOT_INSTALLED      = 0x5d + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ADAPTER_NOT_INSTALLED            = 0x5e + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CHAINED_DIFFERENT_ADAPTERS       = 0x5f + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INIT_COMMAND_STARTED             = 0x60 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION       = 0x62 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_MEMORY_LOCK_FAILED               = 0x69 + DLC_STATUS_ERROR_BASE,

    //
    // New Nt DLC specific error codes begin from 0x80
    // These error codes are for new Windows/Nt DLC apps.
    // This far we have tried too much use the OS/2 error codes,
    // that results often uninformative return codes.
    //

    DLC_STATUS_INVALID_BUFFER_ADDRESS           = 0x80 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_BUFFER_ALREADY_RELEASED          = 0x81 + DLC_STATUS_ERROR_BASE,


    DLC_STATUS_INVALID_VERSION                  = 0xA1 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INVALID_BUFFER_HANDLE            = 0xA2 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_NT_ERROR_STATUS                  = 0xA3 + DLC_STATUS_ERROR_BASE,

    //
    // These error codes are just internal for LLC- kernel level interface
    // and they are not returned to application level.
    //

    DLC_STATUS_UNKNOWN_MEDIUM                   = 0xC0 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_DISCARD_INFO_FIELD               = 0xC1 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_NO_ACTION                        = 0xC2 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ACCESS_DENIED                    = 0xC3 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_IGNORE_FRAME                     = 0xC4 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_WAIT_TIMEOUT                     = 0xC5 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_NO_RECEIVE_COMMAND               = 0xC6 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_FILE_CONTEXT_DELETED             = 0xC7 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_EXPAND_BUFFER_POOL               = 0xC8 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_INTERNAL_ERROR                   = 0xC9 + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_ASYNC_DATA_TRANSFER_FAILED       = 0xCA + DLC_STATUS_ERROR_BASE,
    DLC_STATUS_OUT_OF_RCV_BUFFERS               = 0xCB + DLC_STATUS_ERROR_BASE,

    DLC_STATUS_PENDING                          = 0xFF + DLC_STATUS_ERROR_BASE,

    DLC_STATUS_MAX_ERROR                        = 0xFF + DLC_STATUS_ERROR_BASE
} DLC_STATUS;

//
// Data link indication handler prototypes.
// The protocols registering to data link driver
// must provide these entry points.
//

typedef
DLC_STATUS
(*PFLLC_RECEIVE_INDICATION)(
    IN PVOID hClientContext,
    IN PVOID hClientHandle,
	IN NDIS_HANDLE MacReceiveContext,
    IN USHORT FrameType,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf
    );

typedef
VOID
(*PFLLC_COMMAND_COMPLETE)(
    IN PVOID hClientContext,
    IN PVOID hClientHandle,
    IN PVOID hPacket
    );

typedef
VOID
(*PFLLC_EVENT_INDICATION)(
    IN PVOID hClientContext,
    IN PVOID hClientHandle,
    IN UINT uiEvent,
    IN PVOID pDlcStatus,
    IN ULONG SecondaryInformation
    );

UINT
LlcBuildAddressFromLanHeader(
    IN NDIS_MEDIUM NdisMedium,
    IN PUCHAR pRcvFrameHeader,
    IN OUT PUCHAR pLanHeader
    );

DLC_STATUS
LlcInitialize(
    VOID
    );

UINT
LlcBuildAddress(
    IN NDIS_MEDIUM NdisMedium,
    IN PUCHAR DestinationAddress,
    IN PVOID pSrcRouting,
    IN OUT PUCHAR pLanHeader
    );

USHORT
LlcGetMaxInfoField(
    IN NDIS_MEDIUM NdisMedium,
    IN PVOID hBinding,
    IN PUCHAR pLanHeader
    );

DLC_STATUS
LlcQueryInformation(
    IN PVOID hObject,
    IN UINT InformationType,
    IN PLLC_QUERY_INFO_BUFFER pQuery,
    IN UINT QueryBufferSize
    );

DLC_STATUS
LlcSetInformation(
    IN PVOID hObject,
    IN UINT InformationType,
    IN PLLC_SET_INFO_BUFFER pSetInfo,
    IN UINT ParameterBufferSize
    );

DLC_STATUS
LlcNdisRequest(
    IN PVOID hBindingContext,
    IN PLLC_NDIS_REQUEST pDlcParms
    );

DLC_STATUS
LlcOpenAdapter(
    IN PWSTR pAdapterName,
    IN PVOID hClientContext,
    IN PFLLC_COMMAND_COMPLETE pfCommandComplete,
    IN PFLLC_RECEIVE_INDICATION pfReceiveIndication,
    IN PFLLC_EVENT_INDICATION pfEventIndication,
    IN NDIS_MEDIUM NdisMedium,
    IN LLC_ETHERNET_TYPE EthernetType,
    IN UCHAR AdapterNumber,
    OUT PVOID *phBindingContext,
    OUT PUINT puiOpenStatus,
    OUT PUSHORT puiMaxFrameLength,
    OUT PNDIS_MEDIUM pActualNdisMedium
    );


#define LlcOpenSap(Context, Handle, Sap, Options, phSap) \
    LlcOpenStation(Context, Handle, (USHORT)(Sap), LLC_SAP_OBJECT, (USHORT)(Options), phSap)

#define LlcOpenDirectStation(Context, Handle, Sap, phSap) \
    LlcOpenStation(Context, Handle, (USHORT)(Sap), LLC_DIRECT_OBJECT, 0, phSap)

#define LlcOpenDixStation(Context, Handle, Sap, phSap) \
    LlcOpenStation(Context, Handle, (USHORT)(Sap), LLC_DIX_OBJECT, 0, phSap)


VOID
RemoveFromLinkList(
    OUT PVOID* ppBase,
    IN PVOID pElement
    );

VOID
LlcSleep(
    IN LONG lMicroSeconds
    );

VOID
LlcTerminate(
    VOID
    );

VOID
LlcDereferenceObject(
    IN PVOID pStation
    );

VOID
LlcReferenceObject(
    IN PVOID pStation
    );

DLC_STATUS
LlcTraceInitialize(
    IN PVOID UserTraceBuffer,
    IN ULONG UserTraceBufferSize,
    IN ULONG TraceFlags
    );

VOID
LlcTraceClose(
    VOID
    );

VOID
LlcTraceWrite(
    IN UINT Event,
    IN UCHAR AdapterNumber,
    IN UINT DataBufferSize,
    IN PVOID DataBuffer
    );

VOID
LlcTraceDump(
    IN UINT    LastEvents,
    IN UINT    AdapterNumber,
    IN PUCHAR  pRemoteNode
    );

VOID
LlcTraceDumpAndReset(
    IN UINT    LastEvents,
    IN UINT    AdapterNumber,
    IN PUCHAR  pRemoteNode
    );

#if DBG

typedef struct {
    USHORT Input;
    USHORT Time;
    PVOID pLink;
} LLC_SM_TRACE;

#define LLC_INPUT_TABLE_SIZE    500

extern ULONG AllocatedNonPagedPool;
extern ULONG LockedPageCount;
extern ULONG AllocatedMdlCount;
extern ULONG AllocatedPackets;
extern NDIS_SPIN_LOCK MemCheckLock;
extern ULONG cExAllocatePoolFailed;
extern ULONG FailedMemoryLockings;

VOID PrintMemStatus(VOID);

extern ULONG cFramesReceived;
extern ULONG cFramesIndicated;
extern ULONG cFramesReleased;

extern ULONG cLockedXmitBuffers;
extern ULONG cUnlockedXmitBuffers;

extern LLC_SM_TRACE aLast[];
extern UINT InputIndex;

#endif

//
// The inline memcpy and memset functions are faster,
// in x386 than RtlMoveMemory
//

#if defined(i386)

#define LlcMemCpy(Dest, Src, Len)   memcpy(Dest, Src, Len)
#define LlcZeroMem(Ptr, Len)        memset(Ptr, 0, Len)

#else

#define LlcMemCpy(Dest, Src, Len)   RtlMoveMemory(Dest, Src, Len)
#define LlcZeroMem(Ptr, Len)        RtlZeroMemory(Ptr, Len)

#endif

//
//
//  PVOID
//  PopEntryList(
//      IN PQUEUE_PACKET ListHead,
//      );
//

#define PopFromList(ListHead)               \
    (PVOID)(ListHead);                      \
    (ListHead) = (PVOID)(ListHead)->pNext;


//
//  VOID
//  PushToList(
//      IN PQUEUE_PACKET ListHead,
//      IN PQUEUE_PACKET Entry
//      );
//

#define PushToList(ListHead,Entry) {    \
    (Entry)->pNext = (PVOID)(ListHead); \
    (ListHead) = (Entry);               \
    }

//
//  About 30% of all bugs are related with the invalid operations with
//  packets.  A packet may be inserted to another list before it
//  has been removed from the previous one, etc.
//  The debug version of the list macroes reset the next pointer
//  every time it is removed from the list and check it when it is
//  inserted to a new list or released to a packet pool.  The packet
//  alloc will reset the next pointer automatically.
//  Problem: the packets are used for many other purposes as well =>
//  we must do quite a lot conditional code.
//

#if LLC_DBG

#if LLC_DBG_MP

#define DBG_INTERLOCKED_INCREMENT(Count)    \
    InterlockedIncrement(                   \
        (PLONG)&(Count)                     \
        )

#define DBG_INTERLOCKED_DECREMENT(Count)    \
    InterlockedDecrement(                   \
        (PLONG)&(Count)                     \
        )

#define DBG_INTERLOCKED_ADD(Added, Value)   \
    ExInterlockedAddUlong(                  \
        (PULONG)&(Added),                   \
        (ULONG)(Value),                     \
        &MemCheckLock.SpinLock              \
        )
#else

#define DBG_INTERLOCKED_INCREMENT(Count)    (Count)++
#define DBG_INTERLOCKED_DECREMENT(Count)    (Count)--
#define DBG_INTERLOCKED_ADD(Added, Value)   (Added) += (Value)

#endif // LLC_DBG_MP

#else

#define DBG_INTERLOCKED_INCREMENT(Count)
#define DBG_INTERLOCKED_DECREMENT(Count)
#define DBG_INTERLOCKED_ADD(Added, Value)

#endif // LLC_DBG


#if LLC_DBG

VOID LlcBreakListCorrupt( VOID );

#define LlcRemoveHeadList(ListHead)             \
    (PVOID)(ListHead)->Flink;                   \
    {                                           \
        PLIST_ENTRY FirstEntry;                 \
        FirstEntry = (ListHead)->Flink;         \
        FirstEntry->Flink->Blink = (ListHead);  \
        (ListHead)->Flink = FirstEntry->Flink;  \
        FirstEntry->Flink = NULL;               \
    }

#define LlcRemoveTailList(ListHead)             \
    (ListHead)->Blink;                          \
    {                                           \
        PLIST_ENTRY FirstEntry;                 \
        FirstEntry = (ListHead)->Blink;         \
        FirstEntry->Blink->Flink = (ListHead);  \
        (ListHead)->Blink = FirstEntry->Blink;  \
        FirstEntry->Flink = NULL;               \
    }

#define LlcRemoveEntryList(Entry)               \
    {                                           \
        RemoveEntryList((PLIST_ENTRY)Entry);    \
        ((PLIST_ENTRY)(Entry))->Flink = NULL;   \
    }

#define LlcInsertTailList(ListHead,Entry)       \
    if (((PLIST_ENTRY)(Entry))->Flink != NULL){ \
        LlcBreakListCorrupt();                  \
    }                                           \
    InsertTailList(ListHead, (PLIST_ENTRY)Entry)

#define LlcInsertHeadList(ListHead,Entry)                   \
            if (((PLIST_ENTRY)(Entry))->Flink != NULL) {    \
                LlcBreakListCorrupt();                      \
            }                                               \
            InsertHeadList(ListHead,(PLIST_ENTRY)Entry)

/*
#define DeallocatePacket( PoolHandle, pBlock ) {                        \
            if (((PLIST_ENTRY)pBlock)->Flink != NULL) {                 \
                LlcBreakListCorrupt();                                  \
            }                                                           \
            DBG_INTERLOCKED_DECREMENT( AllocatedPackets );              \
            ExFreeToZone(                                               \
                &(((PEXTENDED_ZONE_HEADER)PoolHandle)->Zone),           \
                pBlock);                                                \
        }
*/

#else


//
//  PVOID
//  LlcRemoveHeadList(
//      IN PLIST_ENTRY ListHead
//      );
//

#define LlcRemoveHeadList(ListHead) (PVOID)RemoveHeadList(ListHead)


//
//  PLIST_ENTRY
//  LlcRemoveTailList(
//      IN PLIST_ENTRY ListHead
//      );
//

#define LlcRemoveTailList(ListHead)             \
    (ListHead)->Blink; {                        \
        PLIST_ENTRY FirstEntry;                 \
        FirstEntry = (ListHead)->Blink;         \
        FirstEntry->Blink->Flink = (ListHead);  \
        (ListHead)->Blink = FirstEntry->Blink;  \
    }


//
//  VOID
//  LlcRemoveEntryList(
//      IN PVOID Entry
//      );
//

#define LlcRemoveEntryList(Entry) RemoveEntryList((PLIST_ENTRY)Entry)


//
//  VOID
//  LlcInsertTailList(
//      IN PLIST_ENTRY ListHead,
//      IN PVOID Entry
//      );
//

#define LlcInsertTailList(ListHead,Entry) \
            InsertTailList(ListHead, (PLIST_ENTRY)Entry)

//
//  VOID
//  LlcInsertHeadList(
//      IN PLIST_ENTRY ListHead,
//      IN PVOID Entry
//      );
//

#define LlcInsertHeadList(ListHead,Entry) \
            InsertHeadList(ListHead,(PLIST_ENTRY)Entry)

//
//  VOID
//  DeallocatePacket(
//      PEXTENDED_ZONE_HEADER PoolHandle,
//      PVOID pBlock
//      );
//

/*
#define DeallocatePacket( PoolHandle, pBlock ) {                        \
            ExFreeToZone( &(((PEXTENDED_ZONE_HEADER)PoolHandle)->Zone), \
                pBlock);                                                \
        }
*/

#endif // DBG

#if LLC_DBG == 2

VOID LlcMemCheck(VOID);

#define MEM_CHECK() LlcMemCheck()

#else

#define MEM_CHECK()

#endif


VOID LlcInvalidObjectType(VOID);

/*++

    Trace codes

    Big letters are reserved for actions, small letters are used to identify
    objects and packet types.  The trace macroes simply writes to DLC
    trace tree (remember: we have another trace for the state machine!!!)

    'a' = dix stations
    'b' = direct station
    'c' = link station
    'd' = sap station

    'e' = Connect command
    'f' = Close command
    'g' = Disconnect command
    'h' = Receive command
    'i' = transmit command

    'j' = Type1 packet
    'k' = type 2 packet
    'l' = data link packet

    'A' = CompleteSendAndLock
    'B' = LlcCommandCompletion
    'C' = LlcCloseStation
    'D' = LlcReceiveIndication
    'E' = LlcEventIndication
    'F' = DlcDeviceIoControl
    'G' = DlcDeviceIoControl sync exit
    'H' = DlcDeviceIoControl async exit
    'I' = LlcSendI
    'J' = DirCloseAdapter
    'K' = CompleteDirCloseAdapter
    'L' = LlcDereferenceObject
    'M' = LlcReferenceObject
    'N' = CompleteCloseStation (final)
    'O' = DereferenceLlcObject (in dlc)
    'P' = CompleteLlcObjectClose (final)
    'Q' = DlcReadCancel
    'R' =
    'S' =
    'T' = DlcTransmit
    'U' = LlcSendU
    'V' =
    'W' =
    'X' =
    'Y' =
    'Z' =

--*/

#if DBG & DLC_TRACE_ENABLED

#define LLC_TRACE_TABLE_SIZE    0x400   // this must be exponent of 2!

extern UINT LlcTraceIndex;
extern UCHAR LlcTraceTable[];

#define DLC_TRACE(a)  {\
    LlcTraceTable[LlcTraceIndex] = (a);\
    LlcTraceIndex = (LlcTraceIndex + 1) & (LLC_TRACE_TABLE_SIZE - 1);\
}

#else

#define DLC_TRACE(a)

#endif  // LLC_DBG

//
// the following functions can be macros if DLC and LLC live in the same driver
// and each knows about the other's structures
//

#if DLC_AND_LLC

//
//  UINT
//  LlcGetReceivedLanHeaderLength(
//      IN PVOID pBinding
//      );
//

#if 0

//
// this gives the wrong length for DIX lan header
//

#define LlcGetReceivedLanHeaderLength(pBinding) \
    ((((PBINDING_CONTEXT)(pBinding))->pAdapterContext->NdisMedium == NdisMedium802_3) \
        ? (((PBINDING_CONTEXT)(pBinding))->pAdapterContext->FrameType == LLC_DIRECT_ETHERNET_TYPE) \
            ? 12 \
            : 14 \
        : (((PBINDING_CONTEXT)(pBinding))->pAdapterContext->NdisMedium == NdisMediumFddi) \
            ? 14 \
            : ((PBINDING_CONTEXT)(pBinding))->pAdapterContext->RcvLanHeaderLength)

#else

//
// this always returns 14 as the DIX lan header length
//

#define LlcGetReceivedLanHeaderLength(pBinding) \
    ((((PBINDING_CONTEXT)(pBinding))->pAdapterContext->NdisMedium == NdisMedium802_3) \
        ? 14 \
        : (((PBINDING_CONTEXT)(pBinding))->pAdapterContext->NdisMedium == NdisMediumFddi) \
            ? 14 \
            : ((PBINDING_CONTEXT)(pBinding))->pAdapterContext->RcvLanHeaderLength)

#endif

//
//  USHORT
//  LlcGetEthernetType(
//      IN PVOID hContext
//      );
//

#define LlcGetEthernetType(hContext) \
    (((PBINDING_CONTEXT)(hContext))->pAdapterContext->EthernetType)

//
//  UINT
//  LlcGetCommittedSpace(
//      IN PVOID hLink
//      );
//

#define LlcGetCommittedSpace(hLink) \
    (((PDATA_LINK)(hLink))->BufferCommitment)

#else

//
// separation of church and state, or DLC and LLC even
//

UINT
LlcGetReceivedLanHeaderLength(
    IN PVOID pBinding
    );

USHORT
LlcGetEthernetType(
    IN PVOID hContext
    );

UINT
LlcGetCommittedSpace(
    IN PVOID hLink
    );

#endif // DLC_AND_LLC

#endif // _LLC_API_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcext.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlext.h

Abstract:

    This module includes all internal function prototypes
    and external global variables.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

//
// External variables:
//

extern DLC_LINK_PARAMETERS DefaultParameters;
extern UCHAR auchLlcCommands[];
extern UCHAR Swap[];
extern LLC_TICKS TimerTicks;
extern ULONG AbsoluteTime;
extern BOOLEAN TraceEnabled;
extern LLC_XID_INFORMATION Ieee802Xid;
extern PMDL pXidMdl;
extern KSPIN_LOCK LlcSpinLock;
extern PVOID LlcProtocolHandle;
extern NDIS_PROTOCOL_CHARACTERISTICS LlcCharacteristics;
extern KMUTEX NdisAccessMutex;
extern KSEMAPHORE OpenAdapterSemaphore;
extern UINT NdisSendCount;
extern PADAPTER_CONTEXT pAdapters;
extern UCHAR PrimaryStates[];
extern UCHAR SecondaryStates[];
#ifdef NDIS40
extern NDIS_EVENT PnPBindsComplete;
#endif // NDIS40

UINT
CopyReceivedLanHeader(
    IN UINT TransltionCase,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress
    );

UCHAR
CopyLanHeader(
    IN UINT AddressTranslationMode,
    IN PUCHAR pSrcLanHeader,
    IN PUCHAR pNodeAddress,
    OUT PUCHAR pDestLanHeader,
    IN BOOLEAN SwapAddressBits
    );

VOID
SwappingMemCpy(
    IN PUCHAR pDest,
    IN PUCHAR pSrc,
    IN UINT Len
    );

UINT
RunStateMachine(
    IN OUT PDATA_LINK pLink,
    IN USHORT usInput,
    IN BOOLEAN boolPollFinal,
    IN BOOLEAN boolResponse
    );

UINT
RunInterlockedStateMachineCommand(
    PDATA_LINK pStation,
    USHORT Command
    );

VOID
SaveStatusChangeEvent(
    IN PDATA_LINK pLink,
    IN PUCHAR puchLlcHdr,
    IN BOOLEAN boolResponse
    );

VOID
ResendPackets(
    IN OUT PDATA_LINK pLink    // data link strcuture
    );

VOID
UpdateVa(
    IN OUT PDATA_LINK pLink    // data link station strcuture
    );

VOID
UpdateVaChkpt(
    IN OUT PDATA_LINK pLink     // data link station strcuture
    );

VOID
AdjustWw(
    IN OUT PDATA_LINK pLink    // data link strcuture
    );

VOID
SendAck(
    IN OUT PDATA_LINK pLink
    );

UINT
RunStateMachineCommand(
    IN OUT PVOID hLink,
    IN UINT uiInput
    );

PDATA_LINK
SearchLink(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN LAN802_ADDRESS LanAddr
    );

PDATA_LINK *
SearchLinkAddress(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN LAN802_ADDRESS LanAddr
    );

DLC_STATUS
SetLinkParameters(
    IN OUT PDATA_LINK pLink,
    IN PUCHAR pNewParameters
    );

DLC_STATUS
CheckLinkParameters(
    PDLC_LINK_PARAMETERS pParms
    );

VOID
CopyLinkParameters(
    OUT PUCHAR pOldParameters,
    IN PUCHAR pNewParameters,
    IN PUCHAR pDefaultParameters
    );

VOID
CompleteClose(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status
    );

NDIS_STATUS
InitNdisPackets(
    OUT PLLC_NDIS_PACKET * ppLlcPacketPool,
    IN NDIS_HANDLE hNdisPool
    );

VOID
LlcResetPacket(
    IN OUT PLLC_NDIS_PACKET pNdisPacket
    );

NDIS_STATUS
GetNdisParameter(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_OID NdisOid,
    IN PVOID pDataAddress,
    IN UINT DataSize
    );

DLC_STATUS
SyncNdisRequest(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_NDIS_REQUEST pRequest
    );

NDIS_STATUS
WaitAsyncOperation(
    IN PKEVENT pEvent,
    IN PNDIS_STATUS pAsyncStatus,
    IN NDIS_STATUS Status
    );

#ifdef LLC_PRIVATE_NDIS_PROTOTYPES

NDIS_STATUS
LlcNdisReceiveIndication (
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_HANDLE MacReceiveContext,
    IN PVOID pHeadBuf,
    IN UINT cbHeadBuf,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf,
    IN UINT cbPacketSize
    );

VOID
LlcNdisSendComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_PACKET pNdisPacket,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisReceiveComplete(
    IN PADAPTER_CONTEXT pAdapterContext
    );

VOID
LlcNdisTransferDataComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_PACKET pPacket,
    IN NDIS_STATUS NdisStatus,
    IN UINT uiBytesTransferred
    );

VOID
LlcNdisOpenAdapterComplete(
    IN PVOID hAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN NDIS_STATUS OpenErrorStatus
    );

VOID
LlcNdisCloseComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisRequestComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisResetComplete(
    PADAPTER_CONTEXT pAdapterContext,
    NDIS_STATUS NdisStatus
    );

VOID
NdisStatusHandler(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    );

#else

VOID
NdisStatusHandler(
    IN PVOID hAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    );

VOID
LlcNdisTransferDataComplete(
    IN PVOID hAdapterContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS NdisStatus,
    IN UINT uiBytesTransferred
    );

VOID
LlcNdisRequestComplete(
    IN PVOID hAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisOpenAdapterComplete(
    PVOID hAdapterContext,
    NDIS_STATUS NdisStatus,
    NDIS_STATUS OpenErrorStatus
    );

VOID
LlcNdisStatus(
    IN PVOID hAdapterContext,
    IN NDIS_STATUS Status,
    IN UINT SpecificStatus
    );

VOID
LlcNdisStatusComplete(
    IN PVOID hAdapterContext
    );

NDIS_STATUS
LlcNdisReceiveIndication (
    IN PVOID pAdapterContext,
    IN NDIS_HANDLE MacReceiveContext,
    IN PVOID pHeadBuf,
    IN UINT cbHeadBuf,
    IN PVOID pLookBuf,
    IN UINT cbLookBuf,
    IN UINT cbPacketSize
    );

VOID
LlcNdisSendComplete(
    IN PVOID hAdapter,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdisResetComplete(
    PVOID hAdapterContext,
    NDIS_STATUS NdisStatus
    );

VOID
LlcNdisCloseComplete(
    PVOID hAdapterContext,
    NDIS_STATUS NdisStatus
    );

VOID
LlcNdisReceiveComplete(
    IN PVOID hAdapter
    );

#ifdef NDIS40
VOID
LlcBindAdapterHandler(
    OUT PNDIS_STATUS  pStatus,
    IN  NDIS_HANDLE   BindContext,
    IN  PNDIS_STRING  pDeviceName,
    IN  PVOID         SystemSpecific1,
    IN  PVOID         SystemSpecific2
    );

VOID
LlcUnbindAdapterHandler(
    OUT PNDIS_STATUS pStatus,
    IN  NDIS_HANDLE  ProtocolBindingContext,
    IN  NDIS_HANDLE  UnbindContext
    );

NDIS_STATUS
LlcPnPEventHandler(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_PNP_EVENT          pNetPnPEvent
    );

VOID
CloseAllAdapters();

#endif // NDIS40


#endif

VOID
ProcessType1_Frames(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_SAP pSap,
    IN LLC_HEADER LlcHeader
    );

VOID
MakeRcvIndication(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_OBJECT pStation
    );

VOID
ProcessType2_Frames(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN OUT PDATA_LINK pLink,
    IN LLC_HEADER LlcHeader
    );

VOID
ProcessNewSabme(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_SAP pSap,
    IN LLC_HEADER LlcHeader
    );

VOID
SaveReceiveEvent(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_TRANSFER_PACKET pTransferPacket
    );

VOID
RunSendTaskAndUnlock(
    IN PADAPTER_CONTEXT pAdapterContext
    );

VOID
BackgroundProcessAndUnlock(
    IN PADAPTER_CONTEXT pAdapter
    );

VOID
BackgroundProcess(
    IN PADAPTER_CONTEXT pAdapter
    );

PLLC_PACKET
GetI_Packet(
    IN PADAPTER_CONTEXT pAdapter
    );

VOID
StartSendProcess(
    IN PADAPTER_CONTEXT pAdapter,
    IN PDATA_LINK pLink
    );

VOID
EnableSendProcess(
    IN PDATA_LINK pLink
    );

VOID
StopSendProcess(
    IN PADAPTER_CONTEXT pAdapter,
    IN PDATA_LINK pLink
    );

VOID DisableSendProcess(
    IN PDATA_LINK pLink
    );

PLLC_PACKET
BuildDirOrU_Packet(
    PADAPTER_CONTEXT pAdapter
    );

DLC_STATUS
SendLlcFrame(
    IN PDATA_LINK pLink,
    IN UCHAR LlcCommandId
    );

PLLC_PACKET
GetLlcCommandPacket(
    PADAPTER_CONTEXT pAdapter
    );

VOID
SendNdisPacket(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_PACKET pPacket
    );

VOID
CompleteSendAndLock(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_NDIS_PACKET NdisPacket,
    IN NDIS_STATUS NdisStatus
    );

VOID
RespondTestOrXid(
    IN PADAPTER_CONTEXT pAdapterContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN LLC_HEADER LlcHeader,
    IN UINT SourceSap
    );

VOID
CopyNonZeroBytes(
    OUT PUCHAR pOldParameters,
    IN PUCHAR pNewParameters,
    IN PUCHAR pDefaultParameters,
    IN UINT Length
    );

VOID
ScanTimersDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
TerminateTimer(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_TIMER pTimer
    );

DLC_STATUS
InitializeLinkTimers(
    IN OUT PDATA_LINK pLink
    );

DLC_STATUS
InitializeTimer(
    IN PADAPTER_CONTEXT pAdapterContext,
    PLLC_TIMER pTimer,
    UCHAR TickCount,
    UCHAR TickOne,
    UCHAR TickTwo,
    UINT Input,
    PVOID hContextHandle,
    UINT DefaultDelay,
    IN BOOLEAN StartNewTimer
    );

VOID
StartTimer(
    IN PLLC_TIMER pTimer
    );

BOOLEAN
StopTimer(
    IN PLLC_TIMER pTimer
    );

VOID
SwapMemCpy(
    IN BOOLEAN SwapBytes,
    IN PUCHAR pDest,
    IN PUCHAR pSrc,
    IN UINT Len
    );

VOID
LlcSleep(
    IN LONG lMicroSeconds
    );

DLC_STATUS
LlcInitUnicodeString(
    IN PUNICODE_STRING pStringDest,
    IN PUNICODE_STRING pStringSrc
    );

VOID
LlcFreeUnicodeString(
    IN PUNICODE_STRING UnicodeString
    );

VOID
InitiateAsyncLinkCommand(
    IN PDATA_LINK pLink,
    IN PLLC_PACKET pPacket,
    UINT StateMachineCommand,
    UINT CompletionCode
    );

VOID
AllocateCompletionPacket(
    IN PLLC_OBJECT pLlcObject,
    IN UINT CompletionCode,
    IN PVOID pPacket
    );

VOID
QueueCommandCompletion(
    IN PLLC_OBJECT pLlcObject,
    IN UINT CompletionCode,
    IN UINT Status
    );

DLC_STATUS
LinkFlowControl(
    IN PDATA_LINK pLink,
    IN UCHAR FlowControlState
    );

VOID
LlcInitializeTimerSystem(
    VOID
    );

VOID
LlcTerminateTimerSystem(
    VOID
    );

VOID
ExecuteAllBackroundProcesses(
    VOID
    );

DLC_STATUS
UpdateFunctionalAddress(
    IN PADAPTER_CONTEXT pAdapter
    );

DLC_STATUS
UpdateGroupAddress(
    IN PADAPTER_CONTEXT pAdapter,
    IN PBINDING_CONTEXT pBindingContext
    );

NDIS_STATUS
SetNdisParameter(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID pRequestInfo,
    IN UINT RequestLength
    );

VOID
CancelTransmitCommands(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status
    );

VOID
CancelTransmitsInQueue(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status,
    IN PLIST_ENTRY pQueue,
    IN PLLC_QUEUE pLlcQueue
    );

VOID
LlcNdis30RequestComplete(
    IN PVOID hAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_REQUEST_TYPE RequestType,
    IN NDIS_STATUS NdisStatus
    );

VOID
LlcNdis30TransferDataComplete(
    IN PVOID pAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_STATUS NdisStatus
    );

VOID
CompletePendingLlcCommand(
    PLLC_OBJECT pLlcObject
    );

DLC_STATUS
CheckAndDuplicatePacket(
#if DBG
    IN PADAPTER_CONTEXT pAdapterContext,
#endif
    IN PBINDING_CONTEXT pBinding,
    IN PLLC_PACKET pPacket,
    IN PLLC_QUEUE pQueue
    );

VOID
QueuePacket(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_QUEUE pQueue,
    IN PLLC_PACKET pPacket
    );

VOID
PrintLastInputs(
    IN PUCHAR pszMessage,
    IN PDATA_LINK pLink
    );

VOID
BackgroundProcessWithinLock(
    IN PADAPTER_CONTEXT pAdapterContext
    );


#ifdef LLC_PRIVATE_PROTOTYPES

//
// LLCADDR.C...
//

UINT
LlcCopyReceivedLanHeader(
    IN PBINDING_CONTEXT pBinding,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress
    );

//
// LLCLINK.C...
//

DLC_STATUS
LlcOpenLinkStation(
    IN PLLC_SAP pSap,
    IN UCHAR DestinationSap,
    IN PUCHAR pDestinationAddress OPTIONAL,
    IN PUCHAR pReceivedLanHeader OPTIONAL,
    IN PVOID hClientStation,
    OUT PVOID *phLlcHandle
    );

VOID
LlcBindLinkStation(
    IN PDATA_LINK pStation,
    IN PVOID hClientHandle
    );

VOID
LlcConnectStation(
    IN PDATA_LINK pStation,
    IN PLLC_PACKET pPacket,
    IN PVOID pSourceRouting OPTIONAL,
    IN PUSHORT pusMaxInformationField
    );

VOID
LlcDisconnectStation(
    IN PDATA_LINK pLink,
    IN PLLC_PACKET pPacket
    );

DLC_STATUS
LlcFlowControl(
    IN PLLC_OBJECT pStation,
    IN UCHAR FlowControlState
    );

DLC_STATUS
LlcResetBroadcastAddresses(
    IN PBINDING_CONTEXT pBindingContext
    );

//
// LLCNDIS.C...
//

VOID
LlcDisableAdapter(
    IN PBINDING_CONTEXT pBindingContext
    );

DLC_STATUS
LlcCloseAdapter(
    IN PBINDING_CONTEXT pBindingContext,
    IN BOOLEAN CloseAtNdisLevel
    );

VOID
LlcNdisReset(
    IN PBINDING_CONTEXT pBindingContext,
    IN PLLC_PACKET pPacket
    );

//
// LLCOBJ.C...
//

DLC_STATUS
LlcOpenStation(
    IN PBINDING_CONTEXT pBindingContext,
    IN PVOID hClientHandle,
    IN USHORT ObjectAddress,
    IN UCHAR ObjectType,
    IN USHORT OpenOptions,
    OUT PVOID* phStation
    );

DLC_STATUS
LlcCloseStation(
    IN PLLC_OBJECT pStation,
    IN PLLC_PACKET pCompletionPacket
    );

VOID
CompleteObjectDelete(
    IN PLLC_OBJECT pStation
    );

VOID
LlcSetDirectOpenOptions(
    IN PLLC_OBJECT pDirect,
    IN USHORT OpenOptions
    );

//
// LLCRCV.C...
//

VOID
LlcTransferData(
    IN PBINDING_CONTEXT pBindingContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_PACKET pPacket,
    IN PMDL pMdl,
    IN UINT uiCopyOffset,
    IN UINT cbCopyLength
    );

//
// LLCSEND.C...
//

VOID
LlcSendI(
    IN PDATA_LINK pStation,
    IN PLLC_PACKET pPacket
    );

VOID
LlcSendU(
    IN PLLC_OBJECT pStation,
    IN PLLC_PACKET pPacket,
    IN UINT eFrameType,
    IN UINT uDestinationSap
    );

#else

//
// LLCADDR.C...
//

UINT
LlcCopyReceivedLanHeader(
    IN PVOID pBinding,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress
    );

//
// LLCLINK.C...
//

DLC_STATUS
LlcOpenLinkStation(
    IN PVOID pSap,
    IN UCHAR DestinationSap,
    IN PUCHAR pDestinationAddress OPTIONAL,
    IN PUCHAR pReceivedLanHeader OPTIONAL,
    IN PVOID hClientStation,
    OUT PVOID *phLlcHandle
    );

VOID
LlcBindLinkStation(
    IN PVOID pStation,
    IN PVOID hClientHandle
    );

VOID
LlcConnectStation(
    IN PVOID pStation,
    IN PLLC_PACKET pPacket,
    IN PVOID pSourceRouting OPTIONAL,
    IN PUSHORT pusMaxInformationField
    );

VOID
LlcDisconnectStation(
    IN PVOID pLink,
    IN PLLC_PACKET pPacket
    );

DLC_STATUS
LlcFlowControl(
    IN PVOID pStation,
    IN UCHAR FlowControlState
    );

DLC_STATUS
LlcResetBroadcastAddresses(
    IN PVOID pBindingContext
    );

//
// LLCNDIS.C...
//

VOID
LlcDisableAdapter(
    IN PVOID pBindingContext
    );


DLC_STATUS
LlcCloseAdapter(
    IN PVOID pBindingContext,
    IN BOOLEAN CloseAtNdisLevel
    );

VOID
LlcNdisReset(
    IN PVOID pBindingContext,
    IN PLLC_PACKET pPacket
    );

//
// LLCOBJ.C...
//

DLC_STATUS
LlcOpenStation(
    IN PVOID pBindingContext,
    IN PVOID hClientHandle,
    IN USHORT ObjectAddress,
    IN UCHAR ObjectType,
    IN USHORT OpenOptions,
    OUT PVOID* phStation
    );

DLC_STATUS
LlcCloseStation(
    IN PVOID pStation,
    IN PLLC_PACKET pCompletionPacket
    );

VOID
CompleteObjectDelete(
    IN PVOID pStation
    );

VOID
LlcSetDirectOpenOptions(
    IN PVOID pDirect,
    IN USHORT OpenOptions
    );

//
// LLCRCV.C...
//
VOID
LlcTransferData(
    IN PBINDING_CONTEXT pBindingContext,
	IN NDIS_HANDLE MacReceiveContext,
    IN PLLC_PACKET pPacket,
    IN PMDL pMdl,
    IN UINT uiCopyOffset,
    IN UINT cbCopyLength
    );

//
// LLCSEND.C...
//

VOID
LlcSendI(
    IN PVOID pStation,
    IN PLLC_PACKET pPacket
    );

VOID
LlcSendU(
    IN PVOID pStation,
    IN PLLC_PACKET pPacket,
    IN UINT eFrameType,
    IN UINT uDestinationSap
    );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcinfo.c

Abstract:

    Includes set/get information primitives of the data link driver.

    Contents:
        LlcQueryInformation
        LlcSetInformation
        UpdateFunctionalAddress
        UpdateGroupAddress

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

#include <llc.h>

//
// We are using only a single state state machine defined
// in IBM Token-Ring Architecture.  On the other hand, DLC
// API requires a state machine having primary and secondary
// states.  The secondary states are used only when the link is
// open.  These tables converts the single internal state to
// the primary and secondary states.
//

UCHAR PrimaryStates[MAX_LLC_LINK_STATE] = {
    LLC_LINK_CLOSED,        //  LINK_CLOSED,
    LLC_DISCONNECTED,       //  DISCONNECTED,
    LLC_LINK_OPENING,       //  LINK_OPENING,
    LLC_DISCONNECTING,      //  DISCONNECTING,
    LLC_FRMR_SENT,          //  FRMR_SENT,
    LLC_LINK_OPENED,        //  LINK_OPENED,
    LLC_LINK_OPENED,        //  LOCAL_BUSY,
    LLC_LINK_OPENED,        //  REJECTION
    LLC_LINK_OPENED,        //  CHECKPOINTING
    LLC_LINK_OPENED,        //  CHKP_LOCAL_BUSY
    LLC_LINK_OPENED,        //  CHKP_REJECT
    LLC_RESETTING,          //  RESETTING
    LLC_LINK_OPENED,        //  REMOTE_BUSY
    LLC_LINK_OPENED,        //  LOCAL_REMOTE_BUSY
    LLC_LINK_OPENED,        //  REJECT_LOCAL_BUSY
    LLC_LINK_OPENED,        //  REJECT_REMOTE_BUSY
    LLC_LINK_OPENED,        //  CHKP_REJECT_LOCAL_BUSY
    LLC_LINK_OPENED,        //  CHKP_CLEARING
    LLC_LINK_OPENED,        //  CHKP_REJECT_CLEARING
    LLC_LINK_OPENED,        //  REJECT_LOCAL_REMOTE_BUSY
    LLC_FRMR_RECEIVED       //  FRMR_RECEIVED
};

//
// Note: the local busy state must be set separately!
//

UCHAR SecondaryStates[MAX_LLC_LINK_STATE] = {
    LLC_NO_SECONDARY_STATE,             //  LINK_CLOSED,
    LLC_NO_SECONDARY_STATE,             //  DISCONNECTED,
    LLC_NO_SECONDARY_STATE,             //  LINK_OPENING,
    LLC_NO_SECONDARY_STATE,             //  DISCONNECTING,
    LLC_NO_SECONDARY_STATE,             //  FRMR_SENT,
    LLC_NO_SECONDARY_STATE,             //  LINK_OPENED,
    LLC_NO_SECONDARY_STATE,             //  LOCAL_BUSY,
    LLC_REJECTING,                      //  REJECTION
    LLC_CHECKPOINTING,                  //  CHECKPOINTING
    LLC_CHECKPOINTING,                  //  CHKP_LOCAL_BUSY
    LLC_CHECKPOINTING|LLC_REJECTING,    //  CHKP_REJECT
    LLC_NO_SECONDARY_STATE,             //  RESETTING
    LLC_REMOTE_BUSY,                    //  REMOTE_BUSY
    LLC_REMOTE_BUSY,                    //  LOCAL_REMOTE_BUSY
    LLC_REJECTING,                      //  REJECT_LOCAL_BUSY
    LLC_REJECTING|LLC_REMOTE_BUSY,      //  REJECT_REMOTE_BUSY
    LLC_CHECKPOINTING|LLC_REJECTING,    //  CHKP_REJECT_LOCAL_BUSY
    LLC_CHECKPOINTING|LLC_CLEARING,     //  CHKP_CLEARING
    LLC_CHECKPOINTING|LLC_CLEARING|LLC_REJECTING,   //  CHKP_REJECT_CLEARING
    LLC_REJECTING|LLC_REMOTE_BUSY,      //  REJECT_LOCAL_REMOTE_BUSY
    LLC_NO_SECONDARY_STATE              //  FRMR_RECEIVED
};


DLC_STATUS
LlcQueryInformation(
    IN PVOID hObject,
    IN UINT InformationType,
    IN PLLC_QUERY_INFO_BUFFER pQuery,
    IN UINT QueryBufferSize
    )

/*++

Routine Description:

    Procedure returns the statistics or parameter information of
    the given LLC object.

Arguments:

    hObject         - LLC object
    InformationType - the requested information (NDIS, Statistics, params)
    pQuery          - buffer for the queried parameters
    QueryBufferSize - size of the buffer

Return Value:

    DLC_STATUS

--*/

{
    PVOID CopyBuffer = NULL;    // no warnings when -W4
    UINT CopyLength = 0;        // no warnings when -W4
    DLC_STATUS Status = STATUS_SUCCESS;
    PADAPTER_CONTEXT pAdapterContext;

    switch (InformationType) {
    case DLC_INFO_CLASS_STATISTICS:
    case DLC_INFO_CLASS_STATISTICS_RESET:
        switch (((PDATA_LINK)hObject)->Gen.ObjectType) {
        case LLC_DIRECT_OBJECT:

            //
            // We don't gather any staticstics for direct objects
            //

            CopyBuffer = &(((PLLC_STATION_OBJECT)hObject)->Statistics);
            CopyLength = sizeof(SAP_STATISTICS);
            break;

        case LLC_SAP_OBJECT:

            //
            // copy the SAP statistics, reset the old data if necessary.
            // We don't check the buffer, the upper part if responsible
            // of that.
            //

            CopyBuffer = &(((PLLC_SAP)hObject)->Statistics);
            CopyLength = sizeof(SAP_STATISTICS);
            break;

        case LLC_LINK_OBJECT:
            CopyBuffer = &(((PDATA_LINK)hObject)->Statistics);
            CopyLength = sizeof(LINK_STATION_STATISTICS);
            break;

#if LLC_DBG
        default:
            LlcInvalidObjectType();
#endif
        }

        //
        // Check the size of the receive buffers
        //

        if (CopyLength <= QueryBufferSize) {
            LlcMemCpy(pQuery->auchBuffer, CopyBuffer, CopyLength);

            //
            // Copy also the specific link station information
            //

            if (((PDATA_LINK)hObject)->Gen.ObjectType == LLC_LINK_OBJECT) {
                pQuery->LinkLog.uchLastCmdRespReceived = ((PDATA_LINK)hObject)->LastCmdOrRespReceived;
                pQuery->LinkLog.uchLastCmdRespTransmitted = ((PDATA_LINK)hObject)->LastCmdOrRespSent;
                pQuery->LinkLog.uchPrimaryState = PrimaryStates[((PDATA_LINK)hObject)->State];
                pQuery->LinkLog.uchSecondaryState = SecondaryStates[((PDATA_LINK)hObject)->State];

                //
                // We keep a separate state by whom the local
                // busy state has been set.
                //

                if (((PDATA_LINK)hObject)->Flags & DLC_LOCAL_BUSY_USER) {
                    pQuery->LinkLog.uchSecondaryState |= LLC_LOCAL_BUSY_USER_SET;
                }
                if (((PDATA_LINK)hObject)->Flags & DLC_LOCAL_BUSY_BUFFER) {
                    pQuery->LinkLog.uchSecondaryState |= LLC_LOCAL_BUSY_BUFFER_SET;
                }
                pQuery->LinkLog.uchSendStateVariable = ((PDATA_LINK)hObject)->Vs / (UCHAR)2;
                pQuery->LinkLog.uchReceiveStateVariable = ((PDATA_LINK)hObject)->Vr / (UCHAR)2;
                pQuery->LinkLog.uchLastNr = (UCHAR)(((PDATA_LINK)hObject)->Nr / 2);

                //
                // The lan header used by the link is in the same
                // format as the received lan headers
                //

                pQuery->LinkLog.cbLanHeader = (UCHAR)LlcCopyReceivedLanHeader(
                        ((PLLC_STATION_OBJECT)hObject)->Gen.pLlcBinding,
                        pQuery->LinkLog.auchLanHeader,
                        ((PDATA_LINK)hObject)->auchLanHeader
                        );
            }
        } else {

            //
            // The data will be lost, when it is reset
            //

            Status = DLC_STATUS_LOST_LOG_DATA;
            CopyLength = QueryBufferSize;
        }
        if (InformationType == DLC_INFO_CLASS_STATISTICS_RESET) {
            LlcZeroMem(CopyBuffer, CopyLength);
        }
        break;

    case DLC_INFO_CLASS_DLC_TIMERS:
        if (QueryBufferSize < sizeof( LLC_TICKS)) {

            //
            // This is a wrong error message, but there is no better one
            //

            return DLC_STATUS_INVALID_BUFFER_LENGTH;
        }
        LlcMemCpy(&pQuery->Timer,
                  &((PBINDING_CONTEXT)hObject)->pAdapterContext->ConfigInfo.TimerTicks,
                  sizeof(LLC_TICKS)
                  );
        break;

    case DLC_INFO_CLASS_DIR_ADAPTER:
        if (QueryBufferSize < sizeof(LLC_ADAPTER_INFO)) {
            return DLC_STATUS_INVALID_BUFFER_LENGTH;
        }

        pAdapterContext = ((PBINDING_CONTEXT)hObject)->pAdapterContext;
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   pQuery->Adapter.auchFunctionalAddress,
                   ((PBINDING_CONTEXT)hObject)->Functional.auchAddress,
                   4
                   );
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   pQuery->Adapter.auchGroupAddress,
                   (PUCHAR)&((PBINDING_CONTEXT)hObject)->ulBroadcastAddress,
                   4
                   );
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   pQuery->Adapter.auchNodeAddress,
                   pAdapterContext->Adapter.Node.auchAddress,
                   6
                   );
        pQuery->Adapter.usMaxFrameSize = (USHORT)pAdapterContext->MaxFrameSize;
        pQuery->Adapter.ulLinkSpeed = pAdapterContext->LinkSpeed;

        if (pAdapterContext->NdisMedium == NdisMedium802_3) {
            pQuery->Adapter.usAdapterType = 0x0100;     // Ethernet type in OS/2
        } else if (pAdapterContext->NdisMedium == NdisMediumFddi) {

            //
            // NOTE: Using a currently free value to indicate FDDI
            //

            pQuery->Adapter.usAdapterType = 0x0200;
        } else {

            //
            // All token-ring adapters use type "IBM tr 16/4 Adapter A",
            //

            pQuery->Adapter.usAdapterType = 0x0040;
        }
        break;

    case DLC_INFO_CLASS_PERMANENT_ADDRESS:
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   pQuery->PermanentAddress,
                   ((PBINDING_CONTEXT)hObject)->pAdapterContext->PermanentAddress,
                   6
                   );
        break;

    default:
        return DLC_STATUS_INVALID_COMMAND;
    }
    return Status;
}


DLC_STATUS
LlcSetInformation(
    IN PVOID hObject,
    IN UINT InformationType,
    IN PLLC_SET_INFO_BUFFER pSetInfo,
    IN UINT ParameterBufferSize
    )

/*++

Routine Description:

    Procedure sets different parameter sets to the link station objects.

Arguments:

    hObject             - LLC object
    InformationType     - the requested information (NDIS, Statistics, params)
    ParameterBuffer     - buffer for the queried parameters
    ParameterBufferSize - size of the buffer

Special:

    Must be called IRQL < DPC (at least when broadcast addresses
    are modifiled)

Return Value:

--*/

{
    DLC_STATUS Status = STATUS_SUCCESS;
    TR_BROADCAST_ADDRESS TempFunctional;

    //
    // There is only one high level functions, but InformationType
    // and the destination station type defines the actual changed
    // information.
    //

    ASSUME_IRQL(DISPATCH_LEVEL);

    switch (InformationType) {
    case DLC_INFO_CLASS_LINK_STATION:
        switch (((PDATA_LINK)hObject)->Gen.ObjectType) {
        case LLC_LINK_OBJECT:
            if (ParameterBufferSize < sizeof(DLC_LINK_PARAMETERS)) {
                return DLC_STATUS_INVALID_BUFFER_LENGTH;
            }
            Status = CheckLinkParameters(&pSetInfo->LinkParms);

            if (Status != STATUS_SUCCESS) {
                return Status;
            }

            ACQUIRE_SPIN_LOCK(&(((PLLC_GENERIC_OBJECT)hObject)->pAdapterContext->SendSpinLock));

            SetLinkParameters((PDATA_LINK)hObject, pSetInfo->auchBuffer);

            RELEASE_SPIN_LOCK(&(((PLLC_GENERIC_OBJECT)hObject)->pAdapterContext->SendSpinLock));

            break;

        case LLC_SAP_OBJECT:
            if (ParameterBufferSize < sizeof(DLC_LINK_PARAMETERS)) {
                return DLC_STATUS_INVALID_BUFFER_LENGTH;
            }
            Status = CheckLinkParameters(&pSetInfo->LinkParms);
            if (Status != STATUS_SUCCESS) {
                return Status;
            }
            CopyLinkParameters((PUCHAR)&((PLLC_SAP)hObject)->DefaultParameters,
                               (PUCHAR)&pSetInfo->LinkParms,
                               (PUCHAR)&DefaultParameters
                               );
            break;

        default:
            return DLC_STATUS_INVALID_STATION_ID;
        }
        break;

    case DLC_INFO_CLASS_DLC_TIMERS:
        if (ParameterBufferSize < sizeof(LLC_TICKS)) {
            return DLC_STATUS_INVALID_BUFFER_LENGTH;
        }

        //
        // We will copy all non-zero timer tick values from the
        // the given buffer.
        //

        CopyNonZeroBytes((PUCHAR)&((PBINDING_CONTEXT)hObject)->pAdapterContext->ConfigInfo.TimerTicks,
                         (PUCHAR)&pSetInfo->Timers,
                         (PUCHAR)&((PBINDING_CONTEXT)hObject)->pAdapterContext->ConfigInfo.TimerTicks,
                         sizeof(LLC_TICKS)
                         );
        break;

    case DLC_INFO_CLASS_SET_GROUP:
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   (PUCHAR)&((PBINDING_CONTEXT)hObject)->ulBroadcastAddress,
                   pSetInfo->auchGroupAddress,
                   sizeof(TR_BROADCAST_ADDRESS)
                   );

        Status = UpdateGroupAddress(((PBINDING_CONTEXT)hObject)->pAdapterContext,
                                    (PBINDING_CONTEXT)hObject
                                    );
        break;

    case DLC_INFO_CLASS_RESET_FUNCTIONAL:
    case DLC_INFO_CLASS_SET_FUNCTIONAL:
        SwapMemCpy(((PBINDING_CONTEXT)hObject)->SwapCopiedLanAddresses,
                   TempFunctional.auchAddress,
                   pSetInfo->auchFunctionalAddress,
                   sizeof(TR_BROADCAST_ADDRESS)
                   );

        //
        // We have now swapped the bits to ethernet format,
        // Highest bit is now 0x01... and lowest ones are ..30,
        // Reset the bits if highest (0x01) is set and set
        // them if it is zero, but do not hange yje orginal
        // bits: 31,1,0  that are now mapped to ethernet format.
        //

        if (InformationType == DLC_INFO_CLASS_SET_FUNCTIONAL) {
            ((PBINDING_CONTEXT)hObject)->Functional.ulAddress |= TempFunctional.ulAddress;
        } else {
            ((PBINDING_CONTEXT)hObject)->Functional.ulAddress &= ~TempFunctional.ulAddress;
        }
        ((PBINDING_CONTEXT)hObject)->ulFunctionalZeroBits = ~((PBINDING_CONTEXT)hObject)->Functional.ulAddress;
        Status = UpdateFunctionalAddress(((PBINDING_CONTEXT)hObject)->pAdapterContext);
        break;

    case DLC_INFO_CLASS_SET_MULTICAST:
        memcpy(&((PBINDING_CONTEXT)hObject)->usBroadcastAddress,
               pSetInfo->auchBuffer,
               6
               );
        Status = UpdateFunctionalAddress(((PBINDING_CONTEXT)hObject)->pAdapterContext);
        break;

    default:
        return DLC_STATUS_INVALID_COMMAND;
    }
    return Status;
}


DLC_STATUS
UpdateFunctionalAddress(
    IN PADAPTER_CONTEXT pAdapterContext
    )

/*++

Routine Description:

    Procedure first makes inclusive or between the functionl address of
    this process context and the functional address defined
    for all bindings and then saves the new functional address to NDIS.
    The NT mutex makes this operation atomic.

Arguments:

    pAdapterContext - LLC context of the current adapter

Return Value:

--*/

{
    UCHAR aMulticastList[LLC_MAX_MULTICAST_ADDRESS * 6];
    TR_BROADCAST_ADDRESS NewFunctional;
    UINT MulticastListSize;
    ULONG CurrentMulticast;
    PBINDING_CONTEXT pBinding;
    UINT i;
    NDIS_STATUS Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    NewFunctional.ulAddress = 0;

    //
    // We cannot be setting several functional addresses simultanously!
    //

    RELEASE_DRIVER_LOCK();

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeWaitForSingleObject(&NdisAccessMutex, UserRequest, KernelMode, FALSE, NULL);

    ACQUIRE_DRIVER_LOCK();

    //
    // The access to global data structures must be procted by
    // the spin lock.
    //

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    for (pBinding = pAdapterContext->pBindings; pBinding; pBinding = pBinding->pNext) {
        NewFunctional.ulAddress |= pBinding->Functional.ulAddress;
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    if ((pAdapterContext->NdisMedium == NdisMedium802_3)
    || (pAdapterContext->NdisMedium == NdisMediumFddi)) {

        //
        // Each bit in the functional address is translated
        // to a ethernet multicast address.
        // The bit order within byte has already been swapped.
        //

        CurrentMulticast = 1;
        MulticastListSize = 0;
        for (i = 0; i < 31; i++) {
            if (CurrentMulticast & NewFunctional.ulAddress) {
                aMulticastList[MulticastListSize] = 0x03;
                aMulticastList[MulticastListSize + 1] = 0;
                LlcMemCpy(&aMulticastList[MulticastListSize + 2],
                          &CurrentMulticast,
                          sizeof(CurrentMulticast)
                          );
                MulticastListSize += 6;
            }
            CurrentMulticast <<= 1;
        }

        //
        // Add the group addresses of all bindings behind
        // the functional addresses in the table.
        //

        for (pBinding = pAdapterContext->pBindings; pBinding; pBinding = pBinding->pNext) {

            //
            // We may drop some group addresses, but I don't expect that
            // it will ever happen (i don't know anybody using tr
            // group address, the possibility to have all functional
            // address bits in use and more than one group address in system
            // is almost impossible)
            //

            if (pBinding->ulBroadcastAddress != 0
            && MulticastListSize < LLC_MAX_MULTICAST_ADDRESS * 6) {

                //
                // Set the default bits in the group address,
                // but use ethernet bit order.
                //

                LlcMemCpy(&aMulticastList[MulticastListSize],
                          &pBinding->usBroadcastAddress,
                          6
                          );
                MulticastListSize += 6;
            }
        }

        RELEASE_DRIVER_LOCK();

        Status = SetNdisParameter(pAdapterContext,
                                  (pAdapterContext->NdisMedium == NdisMediumFddi)
                                    ? OID_FDDI_LONG_MULTICAST_LIST
                                    : OID_802_3_MULTICAST_LIST,
                                  aMulticastList,
                                  MulticastListSize
                                  );
    } else {

        //
        // The functional address bit (bit 0) must be always reset!
        //

        NewFunctional.auchAddress[0] &= ~0x80;

        RELEASE_DRIVER_LOCK();

        Status = SetNdisParameter(pAdapterContext,
                                  OID_802_5_CURRENT_FUNCTIONAL,
                                  &NewFunctional,
                                  sizeof(NewFunctional)
                                  );
    }

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeReleaseMutex(&NdisAccessMutex, FALSE);

    ACQUIRE_DRIVER_LOCK();

    if (Status != STATUS_SUCCESS) {
        return DLC_STATUS_INVALID_FUNCTIONAL_ADDRESS;
    }
    return STATUS_SUCCESS;
}


DLC_STATUS
UpdateGroupAddress(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    Procedure updates token-ring' group address.
    It is converted automatically multicast address
    on the ethernet.

Arguments:

    pAdapterContext - describes adapter to update group addresses for
    pBindingContext - describes binding context

Return Value:

    DLC_STATUS

--*/

{
    NDIS_STATUS Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    if ((pAdapterContext->NdisMedium == NdisMedium802_3)
    || (pAdapterContext->NdisMedium == NdisMediumFddi)) {

        PUCHAR pMulticastAddress = (PUCHAR)&pBindingContext->usBroadcastAddress;

        pMulticastAddress[0] = 0x03;
        pMulticastAddress[1] = 0;
        pMulticastAddress[2] |= 1;

        //
        // Because functional and group addresses are mapped into
        // the multicast addresses, the updated global multicast list
        // must inlcude both address types of all bindings,
        //

        Status = UpdateFunctionalAddress(pAdapterContext);
        return Status;
    } else {

        PUCHAR pGroupAddress = (PUCHAR)&pBindingContext->usBroadcastAddress;

        pGroupAddress[0] = 0xC0;
        pGroupAddress[1] = 0;

        //
        // The group/functional address bit must be always set!
        //

        pGroupAddress[2] |= 0x80;

        RELEASE_DRIVER_LOCK();

        Status = SetNdisParameter(pAdapterContext,
                                  OID_802_5_CURRENT_GROUP,
                                  &pGroupAddress[2],
                                  4
                                  );

        ACQUIRE_DRIVER_LOCK();

        //
        // The error status code is wrong, but IBM has defined no
        // error code for this case.
        //

        if (Status != STATUS_SUCCESS) {
            return DLC_STATUS_INVALID_FUNCTIONAL_ADDRESS;
        } else {
            return STATUS_SUCCESS;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlctyp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlctyp.h

Abstract:

    This module defines all data structures of the DLC module.

Author:

    Antti Saarenheimo 22-Jul-1991

Environment:

    Kernel mode

Revision History:

--*/

//
// forward declarations
//

struct _DLC_OBJECT;
typedef struct _DLC_OBJECT DLC_OBJECT, *PDLC_OBJECT;

struct _DLC_EVENT;
typedef struct _DLC_EVENT DLC_EVENT, *PDLC_EVENT;

struct _DLC_COMMAND;
typedef struct _DLC_COMMAND DLC_COMMAND, *PDLC_COMMAND;

struct _DLC_CLOSE_WAIT_INFO;
typedef struct _DLC_CLOSE_WAIT_INFO DLC_CLOSE_WAIT_INFO, *PDLC_CLOSE_WAIT_INFO;

union _DLC_PACKET;
typedef union _DLC_PACKET DLC_PACKET, *PDLC_PACKET;

union _DLC_BUFFER_HEADER;
typedef union _DLC_BUFFER_HEADER DLC_BUFFER_HEADER;
typedef DLC_BUFFER_HEADER *PDLC_BUFFER_HEADER;

struct _DLC_FILE_CONTEXT;
typedef struct _DLC_FILE_CONTEXT DLC_FILE_CONTEXT;
typedef DLC_FILE_CONTEXT *PDLC_FILE_CONTEXT;

enum _DLC_FILE_CONTEXT_STATUS {
    DLC_FILE_CONTEXT_OPEN,
    DLC_FILE_CONTEXT_CLOSE_PENDING,
    DLC_FILE_CONTEXT_CLOSED
};

enum DlcObjectTypes {
    DLC_ADAPTER_OBJECT,
    DLC_SAP_OBJECT,
    DLC_LINK_OBJECT,
    DLC_DIRECT_OBJECT
};

//
// DLC structures/objects
//

struct _DLC_OBJECT {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // single-linked list of link stations if this is a SAP object
    //

    PDLC_OBJECT pLinkStationList;

    //
    // pointer to owning FILE_CONTEXT
    //

    PDLC_FILE_CONTEXT pFileContext;

    //
    // pointer to RECEIVE command parameters active for this SAP/link station
    //

    PNT_DLC_PARMS pRcvParms;

    //
    // 'handle' (aka pointer to) of corresponding object in LLC
    //

    PVOID hLlcObject;
    PDLC_EVENT pReceiveEvent;
    PVOID pPrevXmitCcbAddress;
    PVOID pFirstChainedCcbAddress;
    PDLC_CLOSE_WAIT_INFO pClosingInfo;
    ULONG CommittedBufferSpace;

    USHORT ChainedTransmitCount;
    SHORT PendingLlcRequests;

    USHORT StationId;                       // nn00 or nnss
    UCHAR Type;
    UCHAR LinkAllCcbs;

    UCHAR State;
    BOOLEAN LlcObjectExists;
    USHORT LlcReferenceCount;               // protects LLC objects when used

    // Need to have a close packet just in case we are out of resources and
    // can't allocate a packet to close. 
    LLC_PACKET ClosePacket;
    UCHAR      ClosePacketInUse;

    //
    // u - variant fields depending on object type: SAP, LINK or DIRECT station
    //

    union {

        struct {
            ULONG DlcStatusFlag;
            PVOID GlobalGroupSapHandle;
            PVOID* GroupSapHandleList;
            USHORT GroupSapCount;
            USHORT UserStatusValue;
            UCHAR LinkStationCount;
            UCHAR OptionsPriority;
            UCHAR MaxStationCount;
        } Sap;

        struct {
            struct _DLC_OBJECT* pSap;
            PDLC_EVENT pStatusEvent;        // permanent status event
            USHORT MaxInfoFieldLength;
        } Link;

        struct {
            USHORT OpenOptions;
            USHORT ProtocolTypeOffset;
            ULONG ProtocolTypeMask;
            ULONG ProtocolTypeMatch;
        } Direct;

    } u;
};

typedef
VOID
(*PFCLOSE_COMPLETE)(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_CLOSE_WAIT_INFO pClosingInfo,
    IN PVOID pCcbLink
    );

typedef
BOOLEAN
(*PFCOMPLETION_HANDLER)(
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PDLC_OBJECT pDlcObject,
    IN PIRP pIrp,
    IN ULONG Event,
    IN PVOID pEventInformation,
    IN ULONG SecondaryInfo
    );

//
// DLC_COMMAND and DLC_EVENT structures may be
// overloaded by the code.  Do not change the field
// order and add the new fields only to the end.
//

struct _DLC_COMMAND {

    //
    // !!!!! Keep this fixed - same fields with DLC_EVENT !!!!!
    //

    LLC_PACKET LlcPacket;
    ULONG Event;
    USHORT StationId;
    USHORT StationIdMask;

    //
    // !!!!! Keep this fixed - same fields with DLC_EVENT !!!!!
    //

    PVOID AbortHandle;
    PIRP pIrp;

    union {
        PFCOMPLETION_HANDLER pfCompletionHandler;
        ULONG TimerTicks;
    } Overlay;
};

struct _DLC_EVENT {
    LLC_PACKET LlcPacket;
    ULONG Event;
    USHORT StationId;           // -1 => global event

    union {
        USHORT StationIdMask;
        UCHAR RcvReadOption;
    } Overlay;

    PDLC_OBJECT pOwnerObject;   // if null => no owner
    PVOID pEventInformation;
    ULONG SecondaryInfo;

    BOOLEAN bFreeEventInfo;
};

typedef struct {
    LLC_PACKET LlcPacket;
    PVOID pCcbAddress;
    PDLC_BUFFER_HEADER pReceiveBuffers;
    ULONG CommandCompletionFlag;
    USHORT CcbCount;
    USHORT StationId;
} DLC_COMPLETION_EVENT_INFO, *PDLC_COMPLETION_EVENT_INFO;

//
// CLOSE_WAIT_INFO
//
// The pointer of this structure is provided to CompleteReadRequest in
// the command completion of close/reset commands.  The info pointer
// is null for the other command completions.
//

struct _DLC_CLOSE_WAIT_INFO {
    PDLC_CLOSE_WAIT_INFO pNext;
    PIRP pIrp;
    ULONG Event;
    PFCLOSE_COMPLETE pfCloseComplete;
    PDLC_BUFFER_HEADER pRcvFrames;
    PVOID pCcbLink;
    PDLC_COMMAND pReadCommand;
    PDLC_COMMAND pRcvCommand;
    PDLC_COMPLETION_EVENT_INFO pCompletionInfo;
    ULONG CancelStatus;
    USHORT CcbCount;
    USHORT CloseCounter;        // event sent when 0
    BOOLEAN ChainCommands;
    BOOLEAN CancelReceive;
    BOOLEAN ClosingAdapter;
    BOOLEAN FreeCompletionInfo;
};


//
// This is a queued FlowControl command (the flow control commands
// are completed immediately synchronously, but the local 'out of buffers'
// busy state of the link is cleared when there is enough buffers
// in the buffer pool to receive all expected data.
//

typedef struct {
    LIST_ENTRY List;
    LONG RequiredBufferSpace;
    USHORT StationId;
} DLC_RESET_LOCAL_BUSY_CMD, *PDLC_RESET_LOCAL_BUSY_CMD;

//
// The transmit commands are not queued as a standard commands
// but using the linked buffer headers (each frame has own xmit
// header having links to buffer header list and MDL list).
// The xmit nodes of the same send are queued together.
//

typedef struct {
    LLC_PACKET LlcPacket;
    PDLC_BUFFER_HEADER pNextSegment;
    PDLC_PACKET pTransmitNode;
    PIRP pIrp;
    ULONG FrameCount;
    PMDL pMdl;
} DLC_XMIT_NODE, *PDLC_XMIT_NODE;

//
// DLC driver use the same packet pool for many small packets
// that have approximately the same size.
//

union _DLC_PACKET {
    union _DLC_PACKET* pNext;
    LLC_PACKET LlcPacket;
    DLC_XMIT_NODE Node;
    DLC_EVENT Event;
    DLC_COMMAND DlcCommand;
    DLC_CLOSE_WAIT_INFO ClosingInfo;
    DLC_RESET_LOCAL_BUSY_CMD ClearCmd;

    struct {
        LLC_PACKET LlcPacket;
        PDLC_CLOSE_WAIT_INFO pClosingInfo;
    } ResetPacket;
};

//
// The buffer pool states protects the app to corrupt the buffer pool!!
// All states are needed because of internal consistency checking code
// and implementation of the receive.
//

enum _DLC_BUFFER_STATES {

    //
    // major states:
    //

    BUF_READY = 0x01,           // buffer/page locked and ready for I/O
    BUF_USER = 0x02,            // buffer owned by user
    BUF_LOCKED = 0x04,          // buffer have been locked for I/O
    BUF_RCV_PENDING = 0x08,     // buffer not yet chained to other frames!

    //
    // free xmit buffer when used
    //

    DEALLOCATE_AFTER_USE = 0x80

};

union _DLC_BUFFER_HEADER {

    //
    // This struct is the header of the buffers split from a page.
    // We save the local and global virtual addresses here.
    // The individual offset is always GlobalVa + Index * 256.
    // An entry in main page table points to this header,
    // if the page has been locked in the memory.
    //

    struct {
        PDLC_BUFFER_HEADER pNextHeader;
        PDLC_BUFFER_HEADER pPrevHeader;
        PDLC_BUFFER_HEADER pNextChild;
        PUCHAR pLocalVa;
        PUCHAR pGlobalVa;
        UCHAR FreeSegments;           // free segments ready for alloc
        UCHAR SegmentsOut;            // number of segments given to user
        UCHAR BufferState;            // BUF_READY, BUF_USER, BUF_LOCKED ...
        UCHAR Reserved;               //
        PMDL pMdl;
    } Header;

    //
    // Structure is used in the double linked free lists.
    // All segments having the same buffer size have been linked
    // to the same link list.
    // On another level each segment is linked to the parent (Header)
    // and all childs of a parent are also linked together.
    //

    struct {
        PDLC_BUFFER_HEADER pNext;
        PDLC_BUFFER_HEADER pPrev;
        PDLC_BUFFER_HEADER pParent;
        PDLC_BUFFER_HEADER pNextChild;
        ULONG ReferenceCount;         // number of references to this buffer
        UCHAR Size;                   // size in 256 blocks
        UCHAR Index;                  // offset = Index * 256
        UCHAR BufferState;            // BUF_READY, BUF_USER, BUF_LOCKED ...
        UCHAR FreeListIndex;          //
        PMDL pMdl;
    } FreeBuffer;

    //
    // The allocated frames are linked in different ways:
    // - the segments of the same frame are together
    // - the frames are linked together
    // These links are discarded, when the frame is given to
    // client (the client may free them in any order back to the buffer pool)
    // (The last extra pointer doesn't actually take any extra space,
    // because packets are round up to next 8 byte boundary)
    //

    struct {
        PDLC_BUFFER_HEADER pReserved;
        PDLC_BUFFER_HEADER pNextFrame;
        PDLC_BUFFER_HEADER pParent;
        PDLC_BUFFER_HEADER pNextChild;
        ULONG ReferenceCount;         // number of references to this buffer
        UCHAR Size;                   // size in 256 blocks
        UCHAR Index;                  // offset = Index * 256
        UCHAR BufferState;            // BUF_READY, BUF_USER, BUF_LOCKED ...
        UCHAR FreeListIndex;
        PMDL pMdl;
        PDLC_BUFFER_HEADER pNextSegment;
    } FrameBuffer;

    PDLC_BUFFER_HEADER pNext;

};

typedef struct _DLC_BUFFER_POOL {

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

    //
    // control fields
    //

    struct _DLC_BUFFER_POOL* pNext;
    KSPIN_LOCK SpinLock;
    LONG ReferenceCount;                        // when -1 => deallocate

    //
    // buffer pool description fields (addresses, various lengths)
    //

    PVOID BaseOffset;                           // page-aligned base address of the pool
    PVOID MaxOffset;                            // maximum byte address in the pool + 1
    ULONG MaxBufferSize;                        // the maximum (free) size
    ULONG BufferPoolSize;                       // size of all memory in the pool
    ULONG FreeSpace;                            // size of free memory in the pool
    LONG UncommittedSpace;                      // size of free and reserved memory
    LONG MissingSize;                           // the size missing the last request
    ULONG MaximumIndex;                         // maximum index of buffer table
    PVOID hHeaderPool;                          // packet pool for buffer headers
    LIST_ENTRY PageHeaders;                     // the allocated blocks

    //
    // pUnlockedEntryList is a singly-linked list of DLC_BUFFER_HEADERS which
    // describe the free pages in the pool
    //

    PDLC_BUFFER_HEADER pUnlockedEntryList;

    //
    // FreeLists is an array of doubly-linked lists - one for each size of
    // block that can exists in the pool. The blocks start out at a page
    // length (4K on x86) and are successively halved until they reach
    // 256 bytes which is the smallest buffer that the DLC buffer manager
    // can deal with
    //

    LIST_ENTRY FreeLists[DLC_BUFFER_SEGMENTS];

    //
    // appended to the DLC_BUFFER_POOL structure is an array of pointers to
    // DLC_BUFFER_HEADER structures that describe the pages that comprise
    // the pool. There are MaximumIndex of these
    //

    PDLC_BUFFER_HEADER BufferHeaders[];

} DLC_BUFFER_POOL, *PDLC_BUFFER_POOL;

//
// The buffer header and frame headers have been define in the
// IBM LAN Architecture reference in the end of chapter 2.
// They have also been defined in dlcapi.h, but for cosmetic reason
// I want to use version without those funny prefixes.
//

typedef struct _NEXT_DLC_SEGMENT {
    struct _NEXT_DLC_SEGMENT* pNext;
    USHORT FrameLength;
    USHORT DataLength;
    USHORT UserOffset;
    USHORT UserLength;
} NEXT_DLC_SEGMENT, *PNEXT_DLC_SEGMENT;

union _FIRST_DLC_SEGMENT;
typedef union _FIRST_DLC_SEGMENT FIRST_DLC_SEGMENT, *PFIRST_DLC_SEGMENT;

typedef struct {
    PNEXT_DLC_SEGMENT pNext;
    USHORT FrameLength;
    USHORT DataLength;
    USHORT UserOffset;
    USHORT UserLength;
    USHORT StationId;
    UCHAR Options;
    UCHAR MessageType;
    USHORT BuffersLeft;
    UCHAR RcvFs;
    UCHAR AdapterNumber;
    PFIRST_DLC_SEGMENT pNextFrame;
} DLC_CONTIGUOUS_RECEIVE, *PDLC_CONTIGUOUS_RECEIVE;

typedef struct {
    PNEXT_DLC_SEGMENT pNext;
    USHORT FrameLength;
    USHORT DataLength;
    USHORT UserOffset;
    USHORT UserLength;
    USHORT StationId;
    UCHAR Options;
    UCHAR MessageType;
    USHORT BuffersLeft;
    UCHAR RcvFs;
    UCHAR AdapterNumber;
    PFIRST_DLC_SEGMENT pNextFrame;
    UCHAR LanHeaderLength;
    UCHAR DlcHeaderLength;
    UCHAR LanHeader[32];
    UCHAR DlcHeader[4];
} DLC_NOT_CONTIGUOUS_RECEIVE, *PDLC_NOT_CONTIGUOUS_RECEIVE;

union _FIRST_DLC_SEGMENT {
    DLC_CONTIGUOUS_RECEIVE Cont;
    DLC_NOT_CONTIGUOUS_RECEIVE NotCont;
};


//
// Each application using DLC create its own file
// context with the DlcOpenAdapter command.
//

struct _DLC_FILE_CONTEXT {

    //
    // all file contexts are put on single-entry list
    //

    SINGLE_LIST_ENTRY List;             // linked list of file contexts

#if DBG

    //
    // DEBUG version - we have a 16-byte identifier header for consistency
    // checking and to help when looking at DLC using the kernel debugger
    //

//    DBG_OBJECT_ID;

#endif

#if !defined(DLC_UNILOCK)

    NDIS_SPIN_LOCK SpinLock;            // global lock for this file context

#endif

    //
    // hBufferPool - handle of buffer pool created by BufferPoolCreate
    //

    PVOID hBufferPool;
    PVOID hExternalBufferPool;
    PVOID hPacketPool;
    PVOID hLinkStationPool;
    PVOID pBindingContext;

    //
    // Notification flags for error situations
    //

    ULONG AdapterCheckFlag;
    ULONG NetworkStatusFlag;
    ULONG PcErrorFlag;
    ULONG SystemActionFlag;

    LIST_ENTRY EventQueue;
    LIST_ENTRY CommandQueue;
    LIST_ENTRY ReceiveQueue;
    LIST_ENTRY FlowControlQueue;

    PDLC_COMMAND pTimerQueue;
    PVOID pSecurityDescriptor;
    PFILE_OBJECT FileObject;            // back link to file obejct!

    ULONG WaitingTransmitCount;
    NDIS_MEDIUM ActualNdisMedium;

    LONG ReferenceCount;
    ULONG BufferPoolReferenceCount;
    ULONG TimerTickCounter;
    USHORT DlcObjectCount;              // count of all DLC objects
    USHORT State;
    USHORT MaxFrameLength;
    UCHAR AdapterNumber;
    UCHAR LinkStationCount;
    PDLC_OBJECT SapStationTable[MAX_SAP_STATIONS];
    PDLC_OBJECT LinkStationTable[MAX_LINK_STATIONS];
    ULONG NdisErrorCounters[ADAPTER_ERROR_COUNTERS];
    DLC_CLOSE_WAIT_INFO ClosingPacket;  // to close the adapter context

    // Event used to make cleanup synchronous and wait for all references on
    // DLC_FILE_CONTEXT to be removed before completing.
    KEVENT CleanupEvent;

#if DBG

    //
    // Debug allocation counters
    //

    MEMORY_USAGE MemoryUsage;

#endif

};

typedef
NTSTATUS
(*PFDLC_COMMAND_HANDLER)(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcaddr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcaddr.c

Abstract:

    This module provides a network independent interface to build
    lan headers for the sent and received frames.
    This is a re-entarnt library module having no access to the data
    structures of data link module.

    Contents:
        LlcBuildAddress
        LlcBuildAddressFromLanHeader
        LlcGetMaxInfoField
        LlcCopyReceivedLanHeader
        CopyLanHeader

Author:

    Antti Saarenheimo (o-anttis) 30-MAY-1991

Revision History:

--*/

#include <llc.h>

#define FDDI_FC 0x57    // Frame Control: async, 48-bit address, LLC, pri 7

static USHORT ausLongestFrameTranslation[8] = {
    516,
    1470,
    2052,
    4472,
    8144,
    11407,
    17800,
    17800
};


UINT
LlcBuildAddress(
    IN NDIS_MEDIUM NdisMedium,
    IN PUCHAR DestinationAddress,
    IN PVOID pSrcRouting,
    IN OUT PUCHAR pLanHeader
    )

/*++

Routine Description:

    The primitive implements a network independent handling of
    the address information in the LAN header. It builds LAN a
    802.3, DIX or 802.5 header from an address and an optional source
    routing info. The source SAP number and the current node address are
    provided by the link driver.

Arguments:

    NdisMedium          - medium that MAC talks over
    DestinationAddress  - LAN destination address (or a broadcast/multicast/
                          functional address).
    pSrcRouting         - optional source routing information. Must be set
                          NULL when not used.
    pLanHeader          - buffer provided by the upper protocol for the
                          address information of the frame header.

Return Value:

    length of the LAN header

--*/

{
    UCHAR SourceRoutingIndicator = 0x01;
    UINT minimumLanHeader = 14;

    if (NdisMedium == NdisMediumFddi) {
        pLanHeader[0] = FDDI_FC;
        ++pLanHeader;
        minimumLanHeader = 13;
    } else if (NdisMedium == NdisMedium802_5) {
        pLanHeader[0] = 0;          // DEFAULT_TR_ACCESS;
        pLanHeader[1] = 0x40;       // NON_MAC_FRAME;
        pLanHeader += 2;
        SourceRoutingIndicator = 0x80;
    } else {

        //
        // We build always the DIX ethernet header, even if it is not used
        // when the link works in 802.3.  IN the automatic mode
        // we need just to copy the lan header length from all received U-
        // command frames and we are using the same mode as the other side.
        // However, there is a problem: the remote node may response
        // the SAMBE request with Rxx or even with I-frame, but we
        // don't want to put any extra checking on our main code path
        // (U- command frames would definitely be outside of it).
        // The other side will send RR- if it cannot get any acknowledge
        // from us, and after a while it closes the link.
        //-----
        // We considered the using of connect timeout to change the
        // ethernet mode, but that might have procedured too long waithing
        // times (something 1s and 30s)
        //-----
        // Usually the client tries to connect to the host and the client
        // sends first the data.  We may also assume, that IBM host machines
        // use the standard LLC implementations (SABME is always acknowledged
        // by UA)
        //

        pLanHeader[12] = 0x80;
        pLanHeader[13] = 0xD5;
    }
    LlcMemCpy(pLanHeader, DestinationAddress, 6);

    //
    // We must support the source routing information also for
    // ethernet, because the underlaying network could be token-ring.
    // The source routing bit must be a local variable, because it
    // is different in token-ring and ethernet
    //

    if (!pSrcRouting) {
        pLanHeader[6] &= ~SourceRoutingIndicator;
        return minimumLanHeader;
    } else {
        pLanHeader[6] |= SourceRoutingIndicator;
        pLanHeader[0] &= ~SourceRoutingIndicator;

        //
        // 5 Lowest bits are the source routing information length.
        //

        if ( (*((PUCHAR)pSrcRouting) & 0x1f) > MAX_TR_SRC_ROUTING_INFO) {
            return DLC_STATUS_INVALID_ROUTING_INFO;
        }
        LlcMemCpy(&pLanHeader[12],
                  pSrcRouting,
                  *((PUCHAR)pSrcRouting) & 0x1f      // Length
                  );
        return minimumLanHeader + *((PUCHAR)pSrcRouting) & 0x1f;
    }
}


UINT
LlcBuildAddressFromLanHeader(
    IN NDIS_MEDIUM NdisMedium,
    IN PUCHAR pRcvLanHeader,
    IN OUT PUCHAR pLanHeader
    )

/*++

Routine Description:

    The routine builds a transmit lan header form the received frame and
    returns the frames header length, nul if invalid address

Arguments:

    NdisMedium      - Ndis menium of the address information
    pRcvFrameHeader - pointer to any frame received from the network.
                      The buffer must include the whole LAN header of the frame
                      including the LLC header.
    pLanHeader      - buffer to receive the information (minimum size is 32 bytes)

Return Value:

    None

--*/

{
    UINT LlcOffset;

    if (NdisMedium == NdisMedium802_3) {

#ifndef SUPPORT_ETHERNET_CLIENT

        LlcOffset = LlcBuildAddress(NdisMedium,
                                    &pRcvLanHeader[6],
                                    NULL,
                                    pLanHeader
                                    );

#else

        LlcOffset = LlcBuildAddress(NdisMedium,
                                    &pRcvLanHeader[6],
                                    (pRcvLanHeader[6] & 0x01)
                                        ? &pRcvLanHeader[12]
                                        : NULL,
                                    pLanHeader
                                    );

        //
        // We must swap the direction bit and reset the possible
        // broadcast type in the source routing header.
        //

        if (pLanHeader[6] & 0x01) {
            pLanHeader[12] &= 0x1f;
            pLanHeader[13] ^= 0x80;
        }

#endif

    } else if (NdisMedium == NdisMediumFddi) {
        LlcOffset = LlcBuildAddress(NdisMedium,
                                    &pRcvLanHeader[7],
                                    NULL,   // no source routing in FDDI
                                    pLanHeader
                                    );
    } else {
        LlcOffset = LlcBuildAddress(NdisMedium,
                                    &pRcvLanHeader[8],
                                    (pRcvLanHeader[8] & 0x80)
                                        ? &pRcvLanHeader[14]
                                        : NULL,
                                    pLanHeader
                                    );

        //
        // We must swap the direction bit and reset the possible broadcast type
        //

        if (pLanHeader[8] & 0x80) {
            pLanHeader[14] &= 0x1f;
            pLanHeader[15] ^= 0x80;
        }
    }
    return LlcOffset;
}


USHORT
LlcGetMaxInfoField(
    IN NDIS_MEDIUM NdisMedium,
    IN PVOID hBinding,
    IN PUCHAR pLanHeader
    )

/*++

Routine Description:

    Procedure returns the maximum informatiuon field for
    the given LAN header.  It checks both the source routing
    information and the maximum packet length defined for
    the adapter and decrements the LAN and LLC headers
    from the length

Arguments:

    NdisMedium  - Ndis medium of the address information
    pBinding    - current binding context on data link driver
    pLanHeader  - any lan header

Return Value:

    Maximum information field length

--*/

{
    PUCHAR pSourceRouting;
    UCHAR LanHeaderLength = 14;
    USHORT MaxFrameSize;
    USHORT usMaxBridgeSize;

    MaxFrameSize = (USHORT)((PBINDING_CONTEXT)hBinding)->pAdapterContext->MaxFrameSize;

    //
    // We may run DLC within the DIX in ethernet network, so add 3 bytes for
    // SNA DIX LAN header and padding
    //

    if (((PBINDING_CONTEXT)hBinding)->pAdapterContext->NdisMedium == NdisMedium802_3) {
        LanHeaderLength += 3;
    }

    pSourceRouting = NULL;
    if (NdisMedium == NdisMedium802_5) {
        if (pLanHeader[8] & 0x80) {
            pSourceRouting = pLanHeader + 14;
        }
    } else if (NdisMedium == NdisMediumFddi) {
        if (pLanHeader[6] & 0x80) {
            pSourceRouting = pLanHeader + 13;
        }
    } else {
        if (pLanHeader[6] & 0x01) {
            pSourceRouting = pLanHeader + 12;
        }
    }
    if (pSourceRouting != NULL) {

        //
        // Add the source routing info length to the LAN header length
        //

        LanHeaderLength += (UCHAR)(*pSourceRouting & (UCHAR)0x1f);
        usMaxBridgeSize = ausLongestFrameTranslation[(pSourceRouting[1] & SRC_ROUTING_LF_MASK) >> 4];

        //
        // RLF 10/01/92. Ignore the 'bridge size'. This is misleading. For
        // instance, the IBM mainframe is currently sending RI of 02 80 in
        // all frames, indicating that the max I-frame it can accept/transmit
        // is 516 bytes (x000xxxx in byte #2). It later sends us a 712 byte
        // frame, 683 bytes of which are info field. We reject it (FRMR)
        //

        //
        // must work this out properly
        //

        //if (MaxFrameSize > usMaxBridgeSize) {
        //    MaxFrameSize = usMaxBridgeSize;
        //}
    }
    return (USHORT)(MaxFrameSize - LanHeaderLength - sizeof(LLC_HEADER));
}


UINT
LlcCopyReceivedLanHeader(
    IN PBINDING_CONTEXT pBinding,
    IN PUCHAR DestinationAddress,
    IN PUCHAR SourceAddress
    )

/*++

Routine Description:

    Function copies and translates the received lan header to
    the address format used by the client.  By default the
    source is the current received frame.

Arguments:

    pBinding            - pointer to Binding Context
    DestinationAddress  - pointer to output destination net address
    SourceAddress       - pointer to input source net address

Return Value:

    Length of copied LAN header

--*/

{
    if (SourceAddress == NULL) {
        SourceAddress = pBinding->pAdapterContext->pHeadBuf;
    }
    if (pBinding->pAdapterContext->FrameType == LLC_DIRECT_ETHERNET_TYPE) {

        //
        // when receiving a DIX frame, the LAN header is always the 12 bytes
        // before the ethernet type field
        //

        LlcMemCpy(DestinationAddress, SourceAddress, 12);
        return 12;
    } else {

        UCHAR LanHeaderLength = 14;

        switch (pBinding->AddressTranslation) {
        case LLC_SEND_802_5_TO_802_5:

            //
            // Copy also the source routing info, if it has been defined
            //

            LlcMemCpy(DestinationAddress,
                      SourceAddress,
                      (SourceAddress[8] & 0x80)
                        ? LanHeaderLength + (SourceAddress[14] & 0x1f)
                        : LanHeaderLength
                      );
            break;

        case LLC_SEND_802_5_TO_802_3:
        case LLC_SEND_802_5_TO_DIX:
            DestinationAddress[0] = 0;          // default AC
            DestinationAddress[1] = 0x40;       // default frame type: non-MAC

            //
            // RLF 03/31/93
            //
            // we are receiving an Ethernet frame. We always reverse the bits
            // in the destination address (ie our node address). We reverse the
            // source (sender's node address) based on the SwapAddressBits flag.
            // If this is TRUE (default) then we also swap the source address
            // bits so that ethernet addresses are presented to the app in
            // standard non-canonical format. If SwapAddressBits is FALSE then
            // we leave them in canonical format (a real ethernet address) or
            // presumably the address is a Token Ring address from the other
            // side of an ethernet-token ring bridge
            //

            SwappingMemCpy(&DestinationAddress[2],
                           SourceAddress,
                           6
                           );
            SwapMemCpy(pBinding->pAdapterContext->ConfigInfo.SwapAddressBits,
                       &DestinationAddress[8],
                       SourceAddress+6,
                       6
                       );
            break;

        case LLC_SEND_802_5_TO_FDDI:
            DestinationAddress[0] = 0;
            DestinationAddress[1] = 0x40;
            SwappingMemCpy(&DestinationAddress[2],
                           SourceAddress+1,
                           6
                           );
            SwapMemCpy(pBinding->pAdapterContext->ConfigInfo.SwapAddressBits,
                       &DestinationAddress[8],
                       SourceAddress+7,
                       6
                       );
            break;

#ifdef SUPPORT_ETHERNET_CLIENT
        case LLC_SEND_802_3_TO_802_3:
        case LLC_SEND_802_3_TO_DIX:
            LlcMemCpy(DestinationAddress, SourceAddress, LanHeaderLength);
            break;

        case LLC_SEND_802_3_TO_802_5:

            //
            // check the source routing bit
            //

            SwappingMemCpy(DestinationAddress, &SourceAddress[2], 12);

            if (SourceAddress[8] & 0x80) {
                LanHeaderLength += SourceAddress[14] & 0x1f;
                LlcMemCpy(&DestinationAddress[12],
                          &SourceAddress[14],
                          SourceAddress[14] & 0x1f
                          );
            }
            break;
#endif

        case LLC_SEND_FDDI_TO_FDDI:
            DestinationAddress[0] = FDDI_FC;
            LlcMemCpy(DestinationAddress+1, SourceAddress, 12);
            return 13;

#if LLC_DBG
        default:
            LlcInvalidObjectType();
            break;
#endif

        }
        return LanHeaderLength;
    }
}


UCHAR
CopyLanHeader(
    IN UINT AddressTranslationMode,
    IN PUCHAR pSrcLanHeader,
    IN PUCHAR pNodeAddress,
    OUT PUCHAR pDestLanHeader,
    IN BOOLEAN SwapAddressBits
    )

/*++

Routine Description:

    The primitive translates the given LAN header and its type to
    a real network header and patches the local node address to
    the source address field.  It also returns the length
    of the LAN header (== offset of LLC header).

Arguments:

    AddressTranslationMode  - the network format mapping case
    pSrcLanHeader           - the initial LAN header
    pNodeAddress            - the current node address
    pDestLanHeader          - storage for the new LAN header
    SwapAddressBits         - TRUE if we will swap address bits for Ethernet/FDDI

Return Value:

    Length of the built network header

--*/

{
    UCHAR LlcOffset = 14;
    UCHAR NodeAddressOffset = 6;
    UCHAR SourceRoutingFlag = 0;

    //
    // LLC driver API supports both 802.3 (ethernet) and 802.5 (token-ring)
    // address presentation formats. The 802.3 header may include the source
    // routing information, when it is used on token-ring.
    //
    // Internally LLC supports 802.3, DIX and 802.5 networks.
    // The transport level driver needs to support only one format. It is
    // translated to the actual network header by LLC.
    // Thus we have these six address mappings.
    //

    switch (AddressTranslationMode) {
    case LLC_SEND_802_5_TO_802_5:

        //
        // TOKEN-RING 802.5 -> TOKEN-RING 802.5
        //

        NodeAddressOffset = 8;
        LlcMemCpy(pDestLanHeader, pSrcLanHeader, 8);

        //
        // set the AC & FC bytes: FC = 0x40 == LLC-level frame
        //
        // THIS MAY NOT BE THE CORRECT PLACE TO DO THIS, UNLESS MAC
        // LEVEL FRAMES CHANGE FC BACK TO 0x00 AFTER THIS ROUTINE AND
        // BEFORE THE FRAME IS PUT ON THE WIRE
        //

        pDestLanHeader[0] = 0;      // AC = no pritority
        pDestLanHeader[1] = 0x40;   // FS = Non-MAC
        SourceRoutingFlag = pSrcLanHeader[8] & (UCHAR)0x80;
        if (SourceRoutingFlag) {

            //
            // Copy the source routing info
            //

            LlcOffset += pSrcLanHeader[14] & 0x1f;
            LlcMemCpy(&pDestLanHeader[14],
                      &pSrcLanHeader[14],
                      pSrcLanHeader[14] & 0x1f
                      );
        }
        break;

    case LLC_SEND_802_5_TO_DIX:

        //
        // TOKEN-RING -> DIX-ETHERNET
        //
        // The ethernet type is a small endiand!!
        //

        pDestLanHeader[12] = 0x80;
        pDestLanHeader[13] = 0xD5;
        LlcOffset = 17;

        //
        // **** FALL THROUGH ****
        //

    case LLC_SEND_802_5_TO_802_3:

        //
        // TOKEN-RING 802.5 -> ETHERNET 802.3
        //

        //
        // RLF 03/31/93
        //
        // Once again, we swap the bits in the destination address ONLY if the
        // SwapAddressBits flag is TRUE.
        // This *could* be a frame intended to go to an ethernet-token ring
        // bridge. The bridge may or may not swap the destination address bits
        // depending on whether there's a 'y' in the month
        //

        SwapMemCpy(SwapAddressBits,
                   pDestLanHeader,
                   &pSrcLanHeader[2],
                   6
                   );
        break;

    case LLC_SEND_802_5_TO_FDDI:
        pDestLanHeader[0] = FDDI_FC;
        SwapMemCpy(SwapAddressBits, pDestLanHeader+1, &pSrcLanHeader[2], 6);
        NodeAddressOffset = 7;
        LlcOffset = 13;
        break;

    case LLC_SEND_DIX_TO_DIX:
        LlcOffset = 12;

    case LLC_SEND_802_3_TO_802_3:

        //
        // ETHERNET 802.3 -> ETHERNET 802.3
        //

        LlcMemCpy(pDestLanHeader, pSrcLanHeader, 6);
        break;

    case LLC_SEND_802_3_TO_DIX:

        //
        // The ethernet type is a small endiand!!
        //

        pDestLanHeader[12] = 0x80;
        pDestLanHeader[13] = 0xD5;
        LlcOffset = 17;

        //
        // ETHERNET 802.3 -> DIX-ETHERNET
        //

        LlcMemCpy(pDestLanHeader, pSrcLanHeader, 6);
        break;

#ifdef SUPPORT_ETHERNET_CLIENT

    case LLC_SEND_802_3_TO_802_5:

        //
        // ETHERNET 802.3 -> TOKEN-RING 802.5
        //

        NodeAddressOffset = 8;
        pDestLanHeader[0] = 0;      // AC = no pritority
        pDestLanHeader[1] = 0x40;   // FS = Non-MAC
        SwappingMemCpy(pDestLanHeader + 2, pSrcLanHeader, 6);

        //
        // Note: Ethernet source routing info indication flag is swapped!
        //

        if (pSrcLanHeader[6] & 0x01) {
            SourceRoutingFlag = 0x80;

            //
            // Copy the source routing info, the source routing info
            // must always be in token-ring bit order (reverse)
            //

            pDestLanHeader[8] |= 0x80;
            LlcOffset += pSrcLanHeader[12] & 0x1f;
            LlcMemCpy(&pDestLanHeader[14],
                      &pSrcLanHeader[12],
                      pSrcLanHeader[12] & 0x1f
                      );
        }
        break;
#endif

    case LLC_SEND_UNMODIFIED:
        return 0;
        break;

    case LLC_SEND_FDDI_TO_FDDI:
        LlcMemCpy(pDestLanHeader, pSrcLanHeader, 7);
        NodeAddressOffset = 7;
        LlcOffset = 13;
        break;

    case LLC_SEND_FDDI_TO_802_5:
        break;

    case LLC_SEND_FDDI_TO_802_3:
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif

    }

    //
    // copy the source address from the node address (ie. our adapter's address)
    // in the correct format for the medium (canonical or non-canonical address
    // format)
    //

    LlcMemCpy(&pDestLanHeader[NodeAddressOffset], pNodeAddress, 6);
    pDestLanHeader[NodeAddressOffset] |= SourceRoutingFlag;

    return LlcOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\dlcxmit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems AB

Module Name:

    dlcxmit.c

Abstract:

    This module implements all transmit commands of Windows/Nt DLC API

    Contents:
        DlcTransmit

Author:

    Antti Saarenheimo 01-Aug-1991

Environment:

    Kernel mode

Revision History:

--*/

#include <dlc.h>

NTSTATUS
DlcTransmit(
    IN PIRP pIrp,
    IN PDLC_FILE_CONTEXT pFileContext,
    IN PNT_DLC_PARMS pDlcParms,
    IN ULONG ParameterLength,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    The procedure implements the gather send of one or more frames.
    DLC API DLL translates all transmit commands to the single command,
    that is implemented by this driver.  All frames must have the same type.

    The general pseudo code for procedure:
        Check input parameters
        for all frames until error
        {
            lock xmit buffers (buffer in buffer pool are already locked)
            if UI, TEST or XID command
                build DLC frame, set the sources address
            send frame
            if command status not pending
                call asynchronous completion routine
        }

Arguments:

    pIrp            - current io request packet
    pFileContext    - DLC process specific adapter context
    pParameters     - the current parameter block
    ParameterLength - the length of input parameters

Return Value:

    NTSTATUS
        STATUS_PENDING
        DLC_STATUS_TRANSMIT_ERROR
        DLC_STATUS_NO_MEMORY
        DLC_STATUS_INVALID_OPTION
        DLC_STATUS_INVALID_STATION_ID;

--*/

{
    PDLC_OBJECT pTransmitObject;
    UINT i;
    PDLC_PACKET pXmitNode, pRootXmitNode;
    UINT FirstSegment;
    NTSTATUS Status;
    UINT DescriptorCount;
    USHORT FrameType;
    USHORT RemoteSap;
    static LARGE_INTEGER UnlockTimeout = { (ULONG) -TRANSMIT_RETRY_WAIT, -1 };
    BOOLEAN mapFrameType = FALSE;

    UNREFERENCED_PARAMETER(OutputBufferLength);

    ASSUME_IRQL(DISPATCH_LEVEL);

    DLC_TRACE('T');

    //
    // first, get and check the DLC station (Direct, SAP or Link)
    //

    Status = GetStation(pFileContext,
                        pDlcParms->Async.Parms.Transmit.StationId,
                        &pTransmitObject
                        );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    RemoteSap = (USHORT)pDlcParms->Async.Parms.Transmit.RemoteSap;
    FrameType = pDlcParms->Async.Parms.Transmit.FrameType;

    //
    // The object type and the transmitted frame types must be compatible!
    //

    if (FrameType == LLC_I_FRAME) {
        if (pTransmitObject->Type != DLC_LINK_OBJECT) {
            return DLC_STATUS_INVALID_STATION_ID;
        }
    } else if (FrameType == LLC_DIRECT_TRANSMIT
    || FrameType == LLC_DIRECT_MAC
    || FrameType == LLC_DIRECT_8022
    || FrameType >= LLC_FIRST_ETHERNET_TYPE) {

        if (pTransmitObject->Type != DLC_DIRECT_OBJECT) {
            return DLC_STATUS_INVALID_STATION_ID;
        }

        //
        // RLF 3/4/94
        //
        // This is somewhat bogus: it was originally intended that AcsLan would
        // pass in a meaningful FrameType value for TRANSMIT.DIR.FRAME.
        // However, it always passes through LLC_TRANSMIT_DIRECT. It is obvious
        // that for DIX frames, FrameType should contain the DIX type field. For
        // example, the RIPL server talks using DIX frame type 0x0600. Therefore,
        // the FrameType *should* be 0x0600 if comments and some of the code in
        // this driver is to be believed (not entirely a good idea). However,
        // AcsLan is missing an important piece of information: it doesn't know
        // if the direct station was opened to transmit DIX frames on ethernet,
        // or if its the originally intended direct station used to send and
        // receive MAC frames on Token Ring (although it wouldn't be too difficult
        // to make a good guess at this). So AcsLan just punts and hands
        // responsibility to this routine which then abnegates that responsibility.
        // So this following if (...) is always going to branch to the next block
        // if we were entered as a consequence of AcsLan (virtual 100% probability).
        // We'll leave it here just in case somebody has forsaken AcsLan and used
        // their own call into the driver (but lets face it, DIX frames will never
        // work without this fix, so its moot).
        // We instead set mapFrameType = TRUE if FrameType was LLC_DIRECT_TRANSMIT
        // on entry AND the protocol offset in the DIX station object is not zero.
        // Just before we submit the frame to LlcSendU we will convert the FrameType
        // and RemoteSap parameters - at that point we have all the information and
        // we know exactly where the DIX type field is kept
        //

        if (FrameType >= LLC_FIRST_ETHERNET_TYPE) {

            //
            // LlcSendU requires the ethernet type in RemoteSap
            //

            RemoteSap = FrameType;
            FrameType = 0;
        } else if (FrameType == LLC_DIRECT_TRANSMIT) {
            if (pTransmitObject->u.Direct.ProtocolTypeOffset) {
                mapFrameType = TRUE;
            }
        }
    } else if (FrameType > LLC_TEST_COMMAND_POLL || FrameType & 1) {
        return DLC_STATUS_INVALID_OPTION;
    } else {
        if (pTransmitObject->Type != DLC_SAP_OBJECT) {
            return DLC_STATUS_INVALID_STATION_ID;
        }
    }

    if (pDlcParms->Async.Parms.Transmit.XmitReadOption > DLC_CHAIN_XMIT_IN_SAP) {
        return DLC_STATUS_INVALID_OPTION;
    }

    //
    // check the input buffer size and that it is consistent
    // with the descriptor count
    //

    DescriptorCount = (UINT)pDlcParms->Async.Parms.Transmit.XmitBufferCount;

    if (sizeof(LLC_TRANSMIT_DESCRIPTOR) * (DescriptorCount - 1)
        + sizeof(NT_DLC_TRANSMIT_PARMS)
        + sizeof(NT_DLC_CCB) != (UINT)ParameterLength) {

        return DLC_STATUS_TRANSMIT_ERROR;
    }

    //
    // The transmit node (or packet) of the frame is also the root node of all
    // frames in this command. The transmit command is completed when all its
    // frames have been sent or acknowledged (if we are sending I-frames)
    //

    pXmitNode = pRootXmitNode = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

    if (pRootXmitNode == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }

    //
    // This counter keeps this object alive, when the transmit command is being
    // processed (actually it doesn't help when the adapter is closed or a DLC
    // SAP is reset)
    //

    pTransmitObject->PendingLlcRequests++;
    pRootXmitNode->Node.FrameCount = 1;
    pRootXmitNode->Node.pIrp = pIrp;
    FirstSegment = 0;

    for (i = 1; ; i++) {

        if (i == DescriptorCount
        || pDlcParms->Async.Parms.Transmit.XmitBuffer[i].eSegmentType == LLC_FIRST_DATA_SEGMENT) {

            //
            // The send completion routine will complete the whole IRP,
            // when the frame count hits zero => we must have one
            // extra frame all the time to prevent the command
            // to complete when we are still sending it in LLC.
            //

            pRootXmitNode->Node.FrameCount++;
            pTransmitObject->PendingLlcRequests++;

            //
            // We must reference the LLC object to keep it alive,
            // when the transmit command is queued on LLC.
            // For example, Control-C could kill the llc object and
            // reset its pointer while we are calling the llc object
            // (that really happened!)
            //

            ReferenceLlcObject(pTransmitObject);

            //
            // The xmit buffer building may cause a page fault =>
            // we must lower the IRQ level and release the spin locks.
            //

            LEAVE_DLC(pFileContext);

            RELEASE_DRIVER_LOCK();

            //
            // We don't need to reference the buffer pool, that may
            // exist, because the llc object reference counter
            // protects also the buffer pool.  The buffer pool
            // is not deleted before all llc objects have been deleted!
            //

            //
            // Operating system allows each process lock physical memory
            // only a limited amount.  The whole system may also be out
            // of the available physical memory (and it's a very typical
            // situation in Windows/Nt)
            //

            Status = BufferPoolBuildXmitBuffers(
                        pFileContext->hBufferPool,
                        i - FirstSegment,
                        &pDlcParms->Async.Parms.Transmit.XmitBuffer[FirstSegment],
                        pXmitNode
                        );

            ACQUIRE_DRIVER_LOCK();

            if (Status != STATUS_SUCCESS) {

                //
                // The muliple packet sends are very difficult to recover.
                // The caller cannot really know which frames were sent
                // and which ones were lost.  Thus we just spend 1 second
                // sleeping and retrying to send the data.  Note: this
                // time is aways from from any abortive closing, thus
                // this cannot be any longer wait.  Keep this stuff is also
                // outside of the main transmit code path.
                //

                if (i < DescriptorCount) {

                    UINT RetryCount;

                    for (RetryCount = 0;
                        (RetryCount < 10) && (Status != STATUS_SUCCESS);
                        RetryCount++) {

                        RELEASE_DRIVER_LOCK();

                        //
                        // Sleep 100 ms and try again.
                        //

                        LlcSleep(100000L);        // this is microseconds!

                        Status = BufferPoolBuildXmitBuffers(
                            pFileContext->hBufferPool,
                            i - FirstSegment,
                            &pDlcParms->Async.Parms.Transmit.XmitBuffer[FirstSegment],
                            pXmitNode
                            );

                        ACQUIRE_DRIVER_LOCK();

//#if DBG
//                            if (Status != STATUS_SUCCESS) {
//                                DbgPrint("DLC.DlcTransmit: Error: Can't build transmit buffer, retrying. Status=%x\n",
//                                        Status
//                                        );
//                            }
//#endif

                    }
                }
                if (Status != STATUS_SUCCESS) {

                    ENTER_DLC(pFileContext);

                    //
                    // We failed, cancel the transmit command
                    //

                    DereferenceLlcObject(pTransmitObject);

                    //
                    // The first error cancels the whole transmit command.
                    // Usually there is no sense to send more frames when
                    // the send of a frame has been failed.
                    //

                    pTransmitObject->PendingLlcRequests--;
                    pRootXmitNode->Node.FrameCount--;
                    if (pXmitNode != pRootXmitNode) {

                        DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pXmitNode);

                        pXmitNode = NULL;
                    }
                    pIrp->IoStatus.Status = Status;

//#if DBG
//                    DbgPrint("DLC.DlcTransmit: Error: Can't build transmit buffer. Status=%x\n",
//                            Status
//                            );
//#endif

                    goto DlcTransmit_ErrorExit;
                }
            }

            //
            // Chain the returned buffers to the root xmit node
            // of this transmit command
            //

            pXmitNode->Node.pTransmitNode = pRootXmitNode;
            FirstSegment = i;

            if (FrameType == LLC_I_FRAME) {
                pXmitNode->LlcPacket.Data.Xmit.pMdl = pXmitNode->Node.pMdl;

                LlcSendI(pTransmitObject->hLlcObject,
                         &(pXmitNode->LlcPacket)
                         );
            } else {

                //
                // For non-I frames the LAN header and its actual information
                // buffers are in diffenret MDLs. The first MDL includes the
                // LAN header. The LAN header length must be excluded from the
                // length of the information field ?
                // We don't need to know the LAN header length, because figured
                // out by the data link layer (actually we could not know it
                // here, the real packet length depends on the LAN header type
                // we are really using).
                //

                pXmitNode->LlcPacket.Data.Xmit.pLanHeader = MmGetSystemAddressForMdl(pXmitNode->Node.pMdl);
                pXmitNode->LlcPacket.Data.Xmit.pMdl = pXmitNode->Node.pMdl->Next;
                pXmitNode->LlcPacket.InformationLength -= (USHORT)MmGetMdlByteCount(pXmitNode->Node.pMdl);

                //
                // RLF 3/4/94
                //
                // if the frame is being sent on the direct station, but we are
                // on ethernet and actually have the direct station open in DIX
                // mode, then we need to convert the FrameType and RemoteSap to
                // be 0 and the DIX identifier, respectively
                //

                if (mapFrameType) {

                    PUCHAR lanHeader = pXmitNode->LlcPacket.Data.Xmit.pLanHeader;

                    //
                    // the DIX format is fixed, and unlike the rest of DLC,
                    // expects ethernet format addresses, with no AC or FC
                    // bytes
                    //

                    RemoteSap = ((USHORT)lanHeader[12]) << 8 | lanHeader[13];
                    FrameType = 0;
                }

                LlcSendU(pTransmitObject->hLlcObject,
                         &(pXmitNode->LlcPacket),
                         FrameType,
                         RemoteSap
                         );
            }

            ENTER_DLC(pFileContext);

            //
            // Note: Llc object may be deleted during this dereference,
            // but is does not delete the DLC object.
            // We will return with an error, if there are more frames
            // to be sent and the dlc object is not any more open
            // (but not yet deleted).
            //

            DereferenceLlcObject(pTransmitObject);

            //
            // Allocate a new packet, if we are sending multiple packets,
            // We must also check, that the current object is still
            // alive and that we can send the packets
            //

            if (i < DescriptorCount) {
                if (pTransmitObject->State != DLC_OBJECT_OPEN) {
                    pIrp->IoStatus.Status = DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION;
                    break;
                }
                pXmitNode = ALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool);

                if (pXmitNode == NULL) {
                    pIrp->IoStatus.Status = DLC_STATUS_NO_MEMORY;
                    break;
                }
            } else {
                break;
            }
        }
    }

    //
    // fall through here on normal exit
    //

DlcTransmit_Exit:

    //
    // Decrement the frame counter to the correct value to make
    // the IRP command completion possible.
    //

    //
    // If we determine that we couldn't give the frame to LLC then we will
    // complete the transmit request with an immediate status IF there was
    // only 1 frame submitted. If the request was TRANSMIT.FRAMES then we
    // may have already submitted several frames which may have been completed
    // asynchronously
    //
    // If we are completed the request synchronously make sure that we have
    // gotten rid of any resources we allocated
    //

    ASSUME_IRQL(DISPATCH_LEVEL);

    pRootXmitNode->Node.FrameCount--;
    if (pRootXmitNode->Node.FrameCount == 0) {
        CompleteTransmitCommand(pFileContext, pIrp, pTransmitObject, pRootXmitNode);
    }
#if DBG
	else
	{
		//
		// this IRP is cancellable
		//

		SetIrpCancelRoutine(pIrp, TRUE);

	}
#endif	// DBG

    Status = STATUS_PENDING;

    //
    // Now this transmit operation is complete,
    // We must decrement the reference counter and
    // check, if we should call the close completion routine.
    //

DlcTransmit_CheckClose:

    pTransmitObject->PendingLlcRequests--;
    if (pTransmitObject->State != DLC_OBJECT_OPEN) {
        CompleteCloseStation(pFileContext, pTransmitObject);
    }

    //
    // The DLC completion routine will always complete the transmit
    // commands.   Usually the command is already completed here in
    // the case of connectionless frames.
    //

    return Status;

DlcTransmit_ErrorExit:

    //
    // come here if we determine that we couldn't give a frame to LLC. This may
    // be a single frame transmit, or multiple (TRANSMIT.FRAMES). If multiple
    // then we have to take the asynchronous way out if frames have already been
    // submitted. If a single frame then we can complete the IRP synchronously
    // and return an immediate error status
    //

    if (pRootXmitNode->Node.FrameCount > 1) {

        //
        // multiple frames!
        //

//#if DBG
//        DbgPrint("DLC.DlcTransmit: Multiple frame error exit! (%d). Status = %x\n",
//                pRootXmitNode->Node.FrameCount,
//                Status
//                );
//#endif

        goto DlcTransmit_Exit;
    }
    pRootXmitNode->Node.FrameCount--;

    ASSERT(pRootXmitNode->Node.FrameCount == 0);

    DEALLOCATE_PACKET_DLC_PKT(pFileContext->hPacketPool, pRootXmitNode);

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    if (Status >= DLC_STATUS_ERROR_BASE && Status <= DLC_STATUS_MAX_ERROR) {
        Status -= DLC_STATUS_ERROR_BASE;
    }

    ASSERT(Status <= LLC_STATUS_MAX_ERROR);

    pDlcParms->Async.Ccb.uchDlcStatus = (LLC_STATUS)Status;

//#if DBG
//    DbgPrint("DLC.DlcTransmit: Returning Immediate Status %x\n", Status);
//#endif

    goto DlcTransmit_CheckClose;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcmac.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlmacro.h

Abstract:

    This module all c- macros of 802.2 data link driver.

Author:

    Antti Saarenheimo (o-anttis) 17-MAY-1991

Revision History:

--*/

//
//  This routine just swaps the bits within bytes of
//  a network address, used only for a fast address
//  swapping to ethernet frame
//        
#define SwapCopy6( a, b )   (a)[0]=Swap[(b)[0]];\
                            (a)[1]=Swap[(b)[1]];\
                            (a)[2]=Swap[(b)[2]];\
                            (a)[3]=Swap[(b)[3]];\
                            (a)[4]=Swap[(b)[4]];\
                            (a)[5]=Swap[(b)[5]]


//
//  Copies and swaps the memory unconditionally
//
//VOID
//SwappingMemCpy(
//    IN PUCHAR pDest,
//    IN PUCHAR pSrc,
//    IN UINT Len 
//    )
//
#define SwappingMemCpy( pDest, pSrc, Len ) {\
    UINT i; \
    for (i = 0; i < Len; i++) \
        ((PUCHAR)pDest)[i] = Swap[ ((PUCHAR)pSrc)[i] ]; \
}

/*++

VOID
LlcResetPacket( 
    IN OUT PLLC_NDIS_PACKET pNdisPacket
    )

Routine Description: 

    Function rets the private partion of a NDIS packet.

Arguments: 

    pNdisPacket - 
        
Return Value:

    None

--*/
#define ResetNdisPacket( pNdisPacket ) { \
    (pNdisPacket)->private.PhysicalCount = 0;\
    (pNdisPacket)->private.TotalLength = 0;\
    (pNdisPacket)->private.Head = 0;\
    (pNdisPacket)->private.Tail = 0;\
    (pNdisPacket)->private.Count = 0;\
    }


/*++

AllocateCompletionPacket( 
    IN PLLC_OBJECT pLlcObject,
    IN UINT CompletionCode,
    IN PLLC_PACKET pPacket
    )

Routine Description:

    The function inserts and initializes a command completion packet 
    of an asynchronous command.

Arguments:

    pLlcObject - LLC object (link, sap or direct)

    CompletionCode - command completion code returned to upper protocol

Return Value:
    
    STATUS_SUCCESS
    DLC_STATUS_NO_MEMORY

--*/
#define AllocateCompletionPacket( pLlcObject, CompletionCode, pPacket ) {\
    pPacket->pBinding = pLlcObject->Gen.pLlcBinding; \
    pPacket->Data.Completion.CompletedCommand = (UCHAR)CompletionCode; \
    pPacket->Data.Completion.hClientHandle = pLlcObject->Gen.hClientHandle; \
    pPacket->pNext = pLlcObject->Gen.pCompletionPackets; \
    pLlcObject->Gen.pCompletionPackets = pPacket; \
    }


#define RunStateMachineCommand( pLink, uiInput ) \
            RunStateMachine( (PDATA_LINK)pLink, (USHORT)uiInput, 0, 0 )



//
//  VOID
//  ScheduleQueue( 
//      IN PLIST_ENTRY ListHead 
//      );
//
//  The macro swaps the list element from the head to the tail 
//  if there are more than one element in the list.
//

#define ScheduleQueue( ListHead ) \
    if ((ListHead)->Blink != (ListHead)->Flink) \
    { \
        PLIST_ENTRY  pListEntry; \
        pListEntry = LlcRemoveHeadList( (ListHead) ); \
        LlcInsertTailList( (ListHead), pListEntry ); \
    }


#define ReferenceObject( pStation ) (pStation)->Gen.ReferenceCount++

//
//  We have made the most common functions macroes to
//  make the main code path as fast as possible. 
//  With the debug switch we use their local versions.
//
#if LLC_DBG >= 2

#define SEARCH_LINK( pAdapterContext, LanAddr, pLink ) \
            pLink = SearchLink( pAdapterContext, LanAddr )

#else

/*++

SEARCH_LINK(
    IN PADAPTER_CONTEXT pAdapterContext, 
    IN LAN802_ADDRESS LanAddr,
    IN PDATA_LINK pLink
    )
Routine Description:

    The routine searches a link from the hash table. 
    All links in the same hash node has been saved to a simple
    link list. 
    
    Note: the full link address is actually 61 bits long =
    7 (SSAP) + 7 (DSAP) + 47 (any non-broadcast source address).
    We save the address information into two ULONGs, that are used
    in the actual search. The hash key will be calculated by xoring
    all 8 bytes in the address.
    
Arguments:

    pAdapterContext - MAC adapter context of data link driver

    LanAddr - the complete 64 bit address of link (48 bit source addr + saps)

Return Value:
    PDATA_LINK - pointer to LLC link object or NULL if not found

--*/
#define SEARCH_LINK( pAdapterContext, LanAddr, pLink )\
{ \
    USHORT      usHash; \
    usHash = \
        LanAddr.aus.Raw[0] ^ LanAddr.aus.Raw[1] ^ \
        LanAddr.aus.Raw[2] ^ LanAddr.aus.Raw[3]; \
    pLink = \
        pAdapterContext->aLinkHash[ \
            ((((PUCHAR)&usHash)[0] ^ ((PUCHAR)&usHash)[1]) % LINK_HASH_SIZE)]; \
    while (pLink != NULL && \
           (pLink->LinkAddr.ul.Low != LanAddr.ul.Low || \
            pLink->LinkAddr.ul.High != LanAddr.ul.High)) \
    { \
        pLink = pLink->pNextNode; \
    } \
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcndis.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems Ab

Module Name:

    llcndis.c

Abstract:

    The module binds and unbinds a protocol level module to DLC and binds the
    data link driver to an NDIS driver if it is necessary.

    All NDIS specific code is also gathered into this module such as the network
    status indications.

    Note: The DLC driver assumes that all DLC level code assumes a Token Ring
    adapter. If we bind to an ethernet adapter, or the required NDIS medium
    type is Ethernet, then we set up DLC to transform Token Ring addresses and
    packet formats to Ethernet (including DIX ethernet format). However, we can
    build a version of DLC/LLC which understands Ethernet format at the API
    level. Define SUPPORT_ETHERNET_CLIENT in order to build such a DLC

    NB: As of 07/13/92, SUPPORT_ETHERNET_CLIENT code has not been tested!

    Contents:
        LlcOpenAdapter
        LlcNdisOpenAdapterComplete
        LlcDisableAdapter
        LlcCloseAdapter
        LlcResetBroadcastAddresses
        InitNdisPackets
        LlcNdisCloseComplete
        NdisStatusHandler
        GetNdisParameter
        SetNdisParameter
        SyncNdisRequest
        WaitAsyncOperation
        LlcNdisRequest
        LlcNdisRequestComplete
        LlcNdisReset
        LlcNdisResetComplete
        UnicodeStringCompare
        PurgeLlcEventQueue

Author:

    Antti Saarenheimo (o-anttis) 30-MAY-1991

Revision History:

    04-AUG-1991,    o-anttis
        Rewritten for NDIS 3.0 (and for real use).

    28-Apr-1994 rfirth

        * Modified to use single driver-level spinlock

        * Cleaned-up open/close - found a few bugs when stressing adapter
          open & close

    04-May-1994 rfirth

        * Added MAC address caching for TEST/XID/SABME frames when adapter
          opened in LLC_ETHERNET_TYPE_AUTO mode

--*/

#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif
#include <dlc.h>    // need DLC_FILE_CONTEXT for memory allocation charged to handle
#include <llc.h>
#include <dbgmsg.h>

#if DBG 
int DbgSettings = 0x80000000;
//int DbgSettings = 0xC0000007;
#endif // DBG

//
// private prototypes
//

BOOLEAN
UnicodeStringCompare(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    );

VOID
PurgeLlcEventQueue(
    IN PBINDING_CONTEXT pBindingContext
    );

#ifdef NDIS40

//
// Private prototypes for PnP.
//

PADAPTER_CONTEXT
AllocateAdapterContext(
    PNDIS_STRING pAdapterName
    );

VOID
FreeAdapterContext(
    PADAPTER_CONTEXT pAdapterContext
    );

NDIS_STATUS
OpenAdapter(
    PADAPTER_CONTEXT pAdapterContext,
    BOOLEAN          fFirstOpen
    );

VOID
CloseAdapter(
    PVOID pv_pAdapterContext
    );

#endif 

//
// Internal statics used in NDIS 3.1 initialization in NT OS/2
//

KSPIN_LOCK LlcSpinLock;
PVOID LlcProtocolHandle;
PADAPTER_CONTEXT pAdapters = NULL;

#ifdef NDIS40
NDIS_EVENT  PnPBindsComplete;
ULONG       gWaitForAdapter;
#endif // NDIS40

//
// We do not support FDDI because it is the same as token-ring
//

UINT LlcMediumArray[3] = {
    NdisMedium802_5,
    NdisMedium802_3,
    NdisMediumFddi
};


DLC_STATUS
LlcOpenAdapter(
    IN PWSTR pAdapterName,
    IN PVOID hClientContext,
    IN PFLLC_COMMAND_COMPLETE pfCommandComplete,
    IN PFLLC_RECEIVE_INDICATION pfReceiveIndication,
    IN PFLLC_EVENT_INDICATION pfEventIndication,
    IN NDIS_MEDIUM NdisMedium,
    IN LLC_ETHERNET_TYPE EthernetType,
    IN UCHAR AdapterNumber,
    OUT PVOID *phBindingContext,
    OUT PUINT puiOpenStatus,
    OUT PUSHORT pusMaxFrameLength,
    OUT PNDIS_MEDIUM pActualNdisMedium
    )

/*++

Routine Description:

    The first call to a new adapter initializes the NDIS interface
    and allocates internal data structures for the new adapter.

    Subsequent opens for the same adapter only increment the reference count
    of that adapter context.

    The execution is synchronous! The procedure waits (sleeps) until
    the adapter has been opened by the MAC.

Special:

    Must be called IRQL < DPC

Arguments:

    pAdapterName......... MAC adapter name. Zero-terminated, wide-character string

    hClientContext....... client context for this adapter

    pfCommandComplete.... send/receive/request command completion handler of the
                          client

    pfReceiveIndication.. receive data indication handler of the client

    pfEventIndication.... event indication handler of the client

    NdisMedium........... the NdisMedium used by the protocol driver (ie DLC).
                          Only NdisMedium802_5 is supported

    EthernetType......... type of Ethernet connection - 802.3 or DIX

    AdapterNumber........ adapter mapping from CCB

    phBindingContext..... the returned binding context handle used with the file
                          context (by DirOpenAdapter)

    puiOpenStatus........ status of NdisOpenAadapter

    pusMaxFrameLength.... returned maximum I-frame length

    pActualNdisMedium.... returned actual NDIS medium; may be different from
                          that requested (NdisMedium)

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - all NDIS error status from NdisOpenAdapter
                  DLC_STATUS_TIMEOUT
                    asynchronous NdisOpenAdapter failed.

--*/

{
    NDIS_STATUS NdisStatus;
    PADAPTER_CONTEXT pAdapterContext;
    UINT OpenStatus = STATUS_SUCCESS;
    PBINDING_CONTEXT pBindingContext;
    UINT MediumIndex;
    KIRQL irql;
    BOOLEAN DoNdisClose = FALSE;
    UNICODE_STRING unicodeString;
    BOOLEAN newAdapter;
    ULONG cacheEntries;
    BOOLEAN initUnicodeString = TRUE;
    NTSTATUS ntstatus;

#ifdef NDIS40
    LONG          BindState;
    ULONG         DelaySeconds;
    LARGE_INTEGER SleepSec;
#endif // NDIS40

#if DBG

    PDLC_FILE_CONTEXT pFileContext = (PDLC_FILE_CONTEXT)hClientContext;

#endif

    DEBUGMSG(DBG_NDIS_OPEN,
        (TEXT("+LlcOpenAdapter(%#x...)\n"), pAdapterName));

    ASSUME_IRQL(DISPATCH_LEVEL);


#ifdef SUPPORT_ETHERNET_CLIENT

    if (NdisMedium != NdisMedium802_3 && NdisMedium != NdisMedium802_5) {
        return DLC_STATUS_UNKNOWN_MEDIUM;

    }

#else

    if (NdisMedium != NdisMedium802_5) {
        return DLC_STATUS_UNKNOWN_MEDIUM;
    }

#endif

    RELEASE_DRIVER_LOCK();

    ASSUME_IRQL(PASSIVE_LEVEL);

#ifdef NDIS40
    //
    // Wait for all NDIS bindings to have completed before trying to open
    // the adapter.
    //

    if (NdisWaitEvent(&PnPBindsComplete, 0) == FALSE)
    {

        ACQUIRE_DRIVER_LOCK();
        return (DLC_STATUS_WAIT_TIMEOUT);
    }
#endif // NDIS40

    //
    // RLF 04/19/93
    //
    // The adapter name passed to this routine is a zero-terminated wide
    // character string mapped to system space. Create a UNICODE_STRING for
    // the name and use standard Rtl function to compare with names of adapters
    // already opened by DLC
    //

    // Although its assumed that the adapter name is NULL-terminated,
    // we will anyway check whether this is the case or not
    // We know the length of the wide character string is 260 (MAX_PATH)
    // BUG: 127246 (security bug)

    {
      ULONG  len  = 0;

      while (len < MAX_PATH) {
        if (pAdapterName[len] == L'\0') {
          break;
        }
        len++;
      }

      if (len == MAX_PATH) {
        // the wchar string is not NULL terminated
        ACQUIRE_DRIVER_LOCK();
        return DLC_STATUS_INVALID_ADAPTER;
      }
    }

    RtlInitUnicodeString(&unicodeString, pAdapterName);

    //
    // if the adapter is being opened in LLC_ETHERNET_TYPE_AUTO mode then we
    // get the cache size from the registry
    //

    if (EthernetType == LLC_ETHERNET_TYPE_AUTO) {

        static DLC_REGISTRY_PARAMETER framingCacheParameterTemplate = {
            L"AutoFramingCacheSize",
            (PVOID)DEFAULT_AUTO_FRAMING_CACHE_SIZE,
            {
                REG_DWORD,
                PARAMETER_AS_SPECIFIED,
                NULL,
                sizeof(ULONG),
                NULL,
                MIN_AUTO_FRAMING_CACHE_SIZE,
                MAX_AUTO_FRAMING_CACHE_SIZE
            }
        };
        PDLC_REGISTRY_PARAMETER parameterTable;

        //
        // create a private copy of the parameter table descriptor
        //

        parameterTable = (PDLC_REGISTRY_PARAMETER)
                                ALLOCATE_ZEROMEMORY_DRIVER(sizeof(*parameterTable));
        if (!parameterTable) {
            ACQUIRE_DRIVER_LOCK();
            return DLC_STATUS_NO_MEMORY;
        }
        RtlCopyMemory(parameterTable,
                      &framingCacheParameterTemplate,
                      sizeof(framingCacheParameterTemplate)
                      );

        //
        // point the Variable field at cacheEntries and set it to the default
        // value then call GetRegistryParameters to retrieve the registry value.
        // (and set it if not already in the registry). Ignore the return value
        // - if GetAdapterParameters failed, cacheEntries will still contain the
        // default value
        //

        cacheEntries = DEFAULT_AUTO_FRAMING_CACHE_SIZE;
        parameterTable->Descriptor.Variable = (PVOID)&cacheEntries;
        parameterTable->Descriptor.Value = (PVOID)&parameterTable->DefaultValue;
        GetAdapterParameters(&unicodeString, parameterTable, 1, TRUE);
        FREE_MEMORY_DRIVER(parameterTable);
    } else {
        cacheEntries = 0;
    }

    //
    // allocate a BINDING_CONTEXT with enough additional space to store the
    // required framing discovery cache
    //
    // DEBUG: BINDING_CONTEXT structures are charged to the FILE_CONTEXT
    //

#if defined(DEBUG_DISCOVERY)

    DbgPrint("cacheEntries=%d\n", cacheEntries);

#endif

    pBindingContext = (PBINDING_CONTEXT)
                        ALLOCATE_ZEROMEMORY_FILE(sizeof(BINDING_CONTEXT)
                                                 + cacheEntries
                                                 * sizeof(FRAMING_DISCOVERY_CACHE_ENTRY)
                                                 );
    if (!pBindingContext) {
        ACQUIRE_DRIVER_LOCK();
        return DLC_STATUS_NO_MEMORY;
    }

    //
    // set the maximum size of the framing discovery cache. Will be zero if the
    // requested ethernet type is not LLC_ETHERNET_TYPE_AUTO
    //

    pBindingContext->FramingDiscoveryCacheEntries = cacheEntries;

#if DBG

    //
    // we need the FILE_CONTEXT structure in the BINDING_CONTEXT in the event
    // the open fails and we need to deallocate memory. Normally this field is
    // not set til everything has successfully been completed
    //

    pBindingContext->hClientContext = hClientContext;

#endif

    //
    // RtlUpcaseUnicodeString is a paged routine - lower IRQL
    //

    //
    // to avoid having to case-insensitive compare unicode strings every time,
    // we do a one-shot convert to upper-cased unicode strings. This also helps
    // out since we do our own unicode string comparison (case-sensitive)
    //
    // Note that this modifies the input parameter
    //

    RtlUpcaseUnicodeString(&unicodeString, &unicodeString, FALSE);

    //
    // before we re-acquire the driver spin-lock, we wait on the OpenAdapter
    // semaphore. We serialize access to the following code because simultaneous
    // opens (in different processes) and closes (different threads within
    // same process) check to see if the adapter is on the pAdapters list.
    // We don't want multiple processes creating the same adapter context
    // simultaneously. Similarly, we must protect against the situation where
    // one process is adding a binding and another could be closing what it
    // thinks is the sole binding, thereby deleting the adapter context we
    // are about to update
    // Note that this is a non-optimal solution since it means an app opening
    // or closing an ethernet adapter could get stuck behind another opening
    // a token ring adapter (slow)
    //

    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    //
    // grab the global LLC spin lock whilst we are looking at/updating the list
    // of adapters
    //

    ACQUIRE_LLC_LOCK(irql);

    //
    // because we are doing the compare within spinlock, we use our own function
    // which checks for an exact match (i.e. case-sensitive). This is ok since
    // always upper-case the string before comparing it or storing it in an
    // ADAPTER_CONTEXT
    //

    for (pAdapterContext = pAdapters; pAdapterContext; pAdapterContext = pAdapterContext->pNext) {
        if (UnicodeStringCompare(&unicodeString, &pAdapterContext->Name)) {
            break;
        }
    }

    //
    // if we didn't locate an adapter context with our adapter name then we're
    // creating a new binding: allocate a new adapter context structure
    //

#ifdef NDIS40
    //
    // Some adapters may come up after the PnPBindsComplete event, such
    // as an ATM LANE. Just in case the adapter initialization is delayed,
    // we will wait for 'gWaitForAdapter' seconds or until the adapter
    // is found.
    //

    DEBUGMSG(DBG_NDIS_OPEN && pAdapterContext == NULL,
        (TEXT("LlcOpenAdapter - WaitForAdapter %d\n"),
        gWaitForAdapter));
    
    SleepSec.QuadPart = -(10*1000*1000); // 1 second.

    for (DelaySeconds = gWaitForAdapter; 
         (DelaySeconds > 0) && (pAdapterContext == NULL); 
         DelaySeconds--)
    {
        DEBUGMSG(DBG_NDIS_OPEN && DBG_VERBOSE,
            (TEXT("LlcOpenAdapter - waiting %d\n"), DelaySeconds));
        
        KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);
    
        KeDelayExecutionThread(KernelMode, FALSE, &SleepSec);
        
        KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                              Executive,
                              KernelMode,
                              FALSE,        // not alertable
                              NULL          // wait until object is signalled
                              );

        // Search for the adapter again.
        for (pAdapterContext = pAdapters; 
             pAdapterContext != NULL; 
             pAdapterContext = pAdapterContext->pNext) 
        {
            if (UnicodeStringCompare(&unicodeString, &pAdapterContext->Name)) 
            {
                break;
            }
        }
    }

    //
    // For NDIS40, with bind and unbind handlers, the ADAPTER_CONTEXT is 
    // managed by the bind/unbind handler. If the adapter is in the list,
    // then we can attach the binding context, else fail the open request.
    //

    newAdapter = FALSE;

    //
    // If NDIS has never indicated a binding for this adapter, then fail
    // open adapter request.
    //

    if (pAdapterContext == NULL)
    {
        DEBUGMSG(DBG_NDIS_OPEN || DBG_WARN,
            (TEXT("LlcOpenAdapter - adapter '%ws' not found.\n"),
             pAdapterName));
        
        RELEASE_LLC_LOCK(irql);

        FREE_MEMORY_FILE(pBindingContext);

        KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

        ACQUIRE_DRIVER_LOCK();

        return (DLC_STATUS_ADAPTER_NOT_INSTALLED);
    }

    //
    // Reference count the NdisBindingHandle to make sure that it doesn't
    // go away while initializing this binding instance.
    //

    REFADD(&pAdapterContext->AdapterRefCnt, 'nepO');

    //
    // Check to see if the adapter is BOUND/enabled.
    //

    BindState = InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND);

    if (BindState != BIND_STATE_BOUND)
    {
        //
        // Adapter is currently unbound (or unbinding).
        //

        RELEASE_LLC_LOCK(irql);

        FREE_MEMORY_FILE(pBindingContext);

        KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

        ACQUIRE_DRIVER_LOCK();
        
        REFDEL(&pAdapterContext->AdapterRefCnt, 'nepO');

        DEBUGMSG(DBG_NDIS_OPEN || DBG_WARN,
            (TEXT("LlcOpenAdapter - adapter %#x not bound.\n"),
             pAdapterName));
        
        return (DLC_STATUS_ADAPTER_NOT_INSTALLED);
    }
    
    //
    // if we allocated a framing discovery cache, but this adapter is not
    // ethernet or FDDI then disable the cache (we should free the
    // memory used by the cache in this case!!)
    //

    if ((pAdapterContext->NdisMedium != NdisMedium802_3) && 
        (pAdapterContext->NdisMedium != NdisMediumFddi)) 
    {
        pBindingContext->FramingDiscoveryCacheEntries = 0;

#if defined(DEBUG_DISCOVERY)

        DbgPrint("LlcOpenAdapter: setting cache entries to 0 (medium = %s)\n",
            (pAdapterContext->NdisMedium == NdisMedium802_5)       ? "802.5" :
            (pAdapterContext->NdisMedium == NdisMediumWan)         ? "WAN" :
            (pAdapterContext->NdisMedium == NdisMediumLocalTalk)   ? "LocalTalk" :
            (pAdapterContext->NdisMedium == NdisMediumDix)         ? "DIX?" :
            (pAdapterContext->NdisMedium == NdisMediumArcnetRaw)   ? "ArcnetRaw" :
            (pAdapterContext->NdisMedium == NdisMediumArcnet878_2) ? "Arcnet878_2" :
            "UNKNOWN!");
            
#endif
    }

    //
    // Fall through and link the BIND_CONTEXT with the adapter context.
    //

#else // NDIS40

    if (!pAdapterContext) {

        //
        // DEBUG: ADAPTER_CONTEXT structures are charged to the driver
        //

        pAdapterContext = (PADAPTER_CONTEXT)
                            ALLOCATE_ZEROMEMORY_DRIVER(sizeof(ADAPTER_CONTEXT));
        if (!pAdapterContext) {

            RELEASE_LLC_LOCK(irql);

            //
            // DEBUG: refund memory charged for BINDING_CONTEXT to FILE_CONTEXT
            //

            FREE_MEMORY_FILE(pBindingContext);

            KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

            ACQUIRE_DRIVER_LOCK();

            return DLC_STATUS_NO_MEMORY;
        }

        newAdapter = TRUE;

#if DBG

        //
        // record who owns this memory usage structure and add it to the
        // list of all memory usages created in the driver
        //

        pAdapterContext->MemoryUsage.Owner = (PVOID)pAdapterContext;
        pAdapterContext->MemoryUsage.OwnerObjectId = AdapterContextObject;
        pAdapterContext->StringUsage.Owner = (PVOID)pAdapterContext;
        pAdapterContext->StringUsage.OwnerObjectId = AdapterContextObject;
        LinkMemoryUsage(&pAdapterContext->MemoryUsage);
        LinkMemoryUsage(&pAdapterContext->StringUsage);

#endif

        //
        // We must allocate all spinlocks immediately after the
        // adapter context has been allocated, because
        // they can also deallocated simultaneously.
        //

        ALLOCATE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
        ALLOCATE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

        //
        // allocate space for the adapter name string from non-paged pool
        // and initialize the name in the adapter context structure
        //

        NdisStatus = LlcInitUnicodeString(&pAdapterContext->Name,
                                          &unicodeString
                                          );
        if (NdisStatus != STATUS_SUCCESS) {
	    initUnicodeString = FALSE;
            goto CleanUp;
        }

        pAdapterContext->OpenCompleteStatus = NDIS_STATUS_PENDING;

        //
        // and release the global spin lock: we have finished updating the
        // adapter list and initializing this adapter context. From now
        // on we use spin locks specific to this adapter context
        //

        RELEASE_LLC_LOCK(irql);

        //
        // We must initialize the list heads before we open the adapter!!!
        //

        InitializeListHead(&pAdapterContext->QueueEvents);
        InitializeListHead(&pAdapterContext->QueueCommands);
        InitializeListHead(&pAdapterContext->NextSendTask);

        pAdapterContext->OpenErrorStatus = NDIS_STATUS_PENDING;

        ASSUME_IRQL(PASSIVE_LEVEL);

        KeInitializeEvent(&pAdapterContext->Event, NotificationEvent, FALSE);

        //
        // when the NDIS level adapter open completes, it will call
        // LlcNdisOpenAdapterComplete which will reset the kernel event that
        // we are now going to wait on (note: this plagiarized from Nbf)
        //

        NdisOpenAdapter(&NdisStatus,
                        &pAdapterContext->OpenErrorStatus,
                        &pAdapterContext->NdisBindingHandle,
                        &MediumIndex,
                        (NDIS_MEDIUM *)&LlcMediumArray[0],
                        sizeof(LlcMediumArray),
                        (NDIS_HANDLE)LlcProtocolHandle,
                        (NDIS_HANDLE)pAdapterContext,
                        &pAdapterContext->Name,
                        NDIS_OPEN_RECEIVE_NOT_REENTRANT,
                        NULL    // no addressing information
                        );

        if (NdisStatus == NDIS_STATUS_PENDING) {

            ASSUME_IRQL(PASSIVE_LEVEL);

	    do {
	      ntstatus = KeWaitForSingleObject(&pAdapterContext->Event,
					       Executive,
					       KernelMode,
					       TRUE, // alertable
					       (PLARGE_INTEGER)NULL
					       );

	    } while (ntstatus == STATUS_ALERTED);

            //
            // get the return status from the Ndis adapter open call
            //

            NdisStatus = pAdapterContext->AsyncOpenStatus;

            //
            // place the event in not-signalled state. We don't expect to use
            // this event for this adapter context again: currently it's only
            // used for the adapter open at NDIS level
            //

            KeResetEvent(&pAdapterContext->Event);
        }

        *puiOpenStatus = (UINT)pAdapterContext->OpenErrorStatus;
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: NdisOpenAdapter failed\n");
            }

            goto CleanUp;
        } else {

            //
            // from this point on, if this function fails, we have to call
            // LlcCloseAdapter to close the adapter @ NDIS level
            //

            DoNdisClose = TRUE;
        }

        pAdapterContext->NdisMedium = LlcMediumArray[MediumIndex];

        ASSUME_IRQL(PASSIVE_LEVEL);

        //
        // fill-in some medium-specific fields
        //

        switch (pAdapterContext->NdisMedium) {
        case NdisMedium802_5:
            pAdapterContext->cbMaxFrameHeader = 32;  // 6 + 6 + 2 + 18

            //
            // the top bit of the destination address signifies a broadcast
            // frame. On Token Ring, the top bit is bit 7
            //

            pAdapterContext->IsBroadcast = 0x80;

            //
            // functional address starts C0-00-... The top 2 bytes are compared
            // as a USHORT = 0x00C0
            //

            pAdapterContext->usHighFunctionalBits = 0x00C0;
            pAdapterContext->AddressTranslationMode = LLC_SEND_802_5_TO_802_5;
            break;

        case NdisMedium802_3:
            pAdapterContext->cbMaxFrameHeader = 14;  // 6 + 6 + 2

            //
            // the top bit of the destination address signifies a broadcast
            // frame. On Ethernet, the top bit is bit 0
            //

            pAdapterContext->IsBroadcast = 0x01;

            //
            // functional address starts 03-00-... The top 2 bytes are compared as
            // a USHORT = 0x0003
            //

            pAdapterContext->usHighFunctionalBits = 0x0003;
            pAdapterContext->AddressTranslationMode = LLC_SEND_802_3_TO_802_3;
            break;

        case NdisMediumFddi:
            pAdapterContext->cbMaxFrameHeader = 13;  // 1 + 6 + 6

            //
            // bits are in same order as for ethernet
            //

            pAdapterContext->IsBroadcast = 0x01;
            pAdapterContext->usHighFunctionalBits = 0x0003;
            pAdapterContext->AddressTranslationMode = LLC_SEND_FDDI_TO_FDDI;
            break;

        }

        //
        // allocate the ndis packets. The NDIS packet must have space
        // for the maximum frame header and the maximum LLC response
        // and its information field (quite small)
        //

        NdisAllocatePacketPool(&NdisStatus,
                               &pAdapterContext->hNdisPacketPool,
                               MAX_NDIS_PACKETS + 1,
                               sizeof(LLC_NDIS_PACKET) - sizeof(NDIS_MAC_PACKET)
                               );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: NdisAllocatePacketPool failed\n");
            }

            goto CleanUp;
        }

        NdisStatus = InitNdisPackets(&pAdapterContext->pNdisPacketPool,
                                     pAdapterContext->hNdisPacketPool
                                     );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: InitNdisPackets failed\n");
            }

            goto CleanUp;
        }

        //
        // Initialize the LLC packet pool
        //

        pAdapterContext->hPacketPool = CREATE_PACKET_POOL_ADAPTER(
                                            LlcPacketPoolObject,
                                            sizeof(UNITED_PACKETS),
                                            8
                                            );
        if (!pAdapterContext->hPacketPool) {
            NdisStatus = DLC_STATUS_NO_MEMORY;

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: CreatePacketPool failed\n");
            }

            goto CleanUp;
        }
        pAdapterContext->hLinkPool = CREATE_PACKET_POOL_ADAPTER(
                                            LlcLinkPoolObject,
                                            pAdapterContext->cbMaxFrameHeader
                                            + sizeof(DATA_LINK),
                                            2
                                            );

        if (!pAdapterContext->hLinkPool) {
            NdisStatus = DLC_STATUS_NO_MEMORY;

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: CreatePacketPool #2 failed\n");
            }

            goto CleanUp;
        }

        //
        // Read the current node address and maximum frame size
        //

        NdisStatus = GetNdisParameter(pAdapterContext,
                                      (pAdapterContext->NdisMedium == NdisMedium802_3)
                                        ? OID_802_3_CURRENT_ADDRESS
                                        : (pAdapterContext->NdisMedium == NdisMediumFddi)
                                            ? OID_FDDI_LONG_CURRENT_ADDR
                                            : OID_802_5_CURRENT_ADDRESS,
                                      pAdapterContext->NodeAddress,
                                      sizeof(pAdapterContext->NodeAddress)
                                      );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: GetNdisParameter failed\n");
            }

            goto CleanUp;
        }

        NdisStatus = GetNdisParameter(pAdapterContext,
                                      (pAdapterContext->NdisMedium == NdisMedium802_3)
                                        ? OID_802_3_PERMANENT_ADDRESS
                                        : (pAdapterContext->NdisMedium == NdisMediumFddi)
                                            ? OID_FDDI_LONG_PERMANENT_ADDR
                                            : OID_802_5_PERMANENT_ADDRESS,
                                      pAdapterContext->PermanentAddress,
                                      sizeof(pAdapterContext->PermanentAddress)
                                      );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: GetNdisParameter #2 failed\n");
            }

            goto CleanUp;
        }

        {
            //
            // Mod RLF 07/10/92
            //
            // apparently, TR adapter does not support NDIS_PACKET_TYPE_MULTICAST
            // as a filter. Up to now, it seems to have been reasonably happy
            // with this type. However, we're not going to include it from now on
            //

            //
            // Mod RLF 01/13/93
            //
            // Similarly, Ethernet doesn't support FUNCTIONAL addresses (Token
            // Ring's functional address is equivalent to Ethernet's multicast
            // address)
            //

            ULONG PacketFilter = NDIS_PACKET_TYPE_DIRECTED
                               | NDIS_PACKET_TYPE_BROADCAST
                               | (((pAdapterContext->NdisMedium == NdisMedium802_3)
                               || (pAdapterContext->NdisMedium == NdisMediumFddi))
                                  ? NDIS_PACKET_TYPE_MULTICAST
                                  : NDIS_PACKET_TYPE_FUNCTIONAL
                               );

            //
            // EndMod
            //

            NdisStatus = SetNdisParameter(pAdapterContext,
                                          OID_GEN_CURRENT_PACKET_FILTER,
                                          &PacketFilter,
                                          sizeof(PacketFilter)
                                          );
#if DBG

            if (NdisStatus != NDIS_STATUS_SUCCESS) {
                DbgPrint("Error: NdisStatus = %x\n", NdisStatus);
                ASSERT(NdisStatus == NDIS_STATUS_SUCCESS);
            }

#endif

        }

        LlcMemCpy(pAdapterContext->Adapter.Node.auchAddress,
                  pAdapterContext->NodeAddress,
                  6
                  );

        NdisStatus = GetNdisParameter(pAdapterContext,
                                      OID_GEN_MAXIMUM_TOTAL_SIZE,
                                      &pAdapterContext->MaxFrameSize,
                                      sizeof(pAdapterContext->MaxFrameSize)
                                      );
        if (NdisStatus == STATUS_SUCCESS) {
            NdisStatus = GetNdisParameter(pAdapterContext,
                                          OID_GEN_LINK_SPEED,
                                          &pAdapterContext->LinkSpeed,
                                          sizeof(pAdapterContext->LinkSpeed)
                                          );
        }
        if (NdisStatus != STATUS_SUCCESS) {

            IF_LOCK_CHECK {
                DbgPrint("LlcOpenAdapter: GetNdisParameter #3/#4 failed\n");
            }

            goto CleanUp;
        }

        //
        // RLF 04/12/93
        //
        // Here we used to load the LLC_TICKS array from TimerTicks - a global
        // array of timer tick values.
        // Instead, we get any per-adapter configuration information stored in
        // the registry
        //

        LoadAdapterConfiguration(&pAdapterContext->Name,
                                 &pAdapterContext->ConfigInfo
                                 );

        //
        // RLF 04/02/94
        //
        // if this is not a Token Ring card then check the MaxFrameSize retrieved
        // above. If the UseEthernetFrameSize parameter was set in the registry
        // then we use the smaller of the ethernet size (1514) and the value
        // reported by the MAC. If the parameter was not set then we just use
        // the value already retrieved. If the card is Token Ring then we use
        // the value already retrieved
        //

        if (pAdapterContext->NdisMedium != NdisMedium802_5
        && pAdapterContext->ConfigInfo.UseEthernetFrameSize
        && pAdapterContext->MaxFrameSize > MAX_ETHERNET_FRAME_LENGTH) {
            pAdapterContext->MaxFrameSize = MAX_ETHERNET_FRAME_LENGTH;
        }

        pAdapterContext->QueueI.pObject = (PVOID)GetI_Packet;

        InitializeListHead(&pAdapterContext->QueueI.ListHead);

        pAdapterContext->QueueDirAndU.pObject = (PVOID)BuildDirOrU_Packet;

        InitializeListHead(&pAdapterContext->QueueDirAndU.ListHead);

        pAdapterContext->QueueExpidited.pObject = (PVOID)GetLlcCommandPacket;

        InitializeListHead(&pAdapterContext->QueueExpidited.ListHead);

        pAdapterContext->AdapterNumber = (UCHAR)AdapterNumber;

        pAdapterContext->OpenCompleteStatus = STATUS_SUCCESS;

        //
        // if we allocated a framing discovery cache, but this adapter is not
        // ethernet or FDDI then disable the cache (we should free the
        // memory used by the cache in this case!!)
        //

        if ((pAdapterContext->NdisMedium != NdisMedium802_3)
        && (pAdapterContext->NdisMedium != NdisMediumFddi)) {

            pBindingContext->FramingDiscoveryCacheEntries = 0;

#if defined(DEBUG_DISCOVERY)

            DbgPrint("LlcOpenAdapter: setting cache entries to 0 (medium = %s)\n",
                     (pAdapterContext->NdisMedium == NdisMedium802_5) ? "802.5" :
                     (pAdapterContext->NdisMedium == NdisMediumWan) ? "WAN" :
                     (pAdapterContext->NdisMedium == NdisMediumLocalTalk) ? "LocalTalk" :
                     (pAdapterContext->NdisMedium == NdisMediumDix) ? "DIX?" :
                     (pAdapterContext->NdisMedium == NdisMediumArcnetRaw) ? "ArcnetRaw" :
                     (pAdapterContext->NdisMedium == NdisMediumArcnet878_2) ? "Arcnet878_2" :
                     "UNKNOWN!"
                     );

#endif

        }
    } else {
        newAdapter = FALSE;
    }
#endif // !NDIS40

    //
    // at this point, we have an allocated, but as yet not filled in binding
    // context and an adapter context that we either found on the pAdapters
    // list, or we just allocated and filled in. We are currently operating
    // at PASSIVE_LEVEL. Re-acquire the driver lock and fill in the binding
    // context
    //

    ACQUIRE_DRIVER_LOCK();

    ASSUME_IRQL(DISPATCH_LEVEL);

    switch (pAdapterContext->NdisMedium) {
    case NdisMedium802_5:
        pBindingContext->EthernetType = LLC_ETHERNET_TYPE_802_3;
        pBindingContext->InternalAddressTranslation = LLC_SEND_802_5_TO_802_5;

#ifdef SUPPORT_ETHERNET_CLIENT

        if (NdisMedium == NdisMedium802_3) {
            pBindingContext->SwapCopiedLanAddresses = TRUE;
            pBindingContext->AddressTranslation = LLC_SEND_802_3_TO_802_5;
        } else {
            pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_802_5;
        }

#else

        pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_802_5;

#endif

        pBindingContext->SwapCopiedLanAddresses = FALSE;
        break;

    case NdisMediumFddi:
        pBindingContext->EthernetType = LLC_ETHERNET_TYPE_802_3;
        pBindingContext->InternalAddressTranslation = LLC_SEND_FDDI_TO_FDDI;
        pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_FDDI;
        pBindingContext->SwapCopiedLanAddresses = TRUE;
        break;

    case NdisMedium802_3:

        //
        // if EthernetType is LLC_ETHERNET_TYPE_DEFAULT then set it to DIX based
        // on the UseDix entry in the registry
        //

        if (EthernetType == LLC_ETHERNET_TYPE_DEFAULT) {
            EthernetType = pAdapterContext->ConfigInfo.UseDix
                         ? LLC_ETHERNET_TYPE_DIX
                         : LLC_ETHERNET_TYPE_802_3
                         ;
        }
        pBindingContext->EthernetType = (USHORT)EthernetType;

        if (EthernetType == LLC_ETHERNET_TYPE_DIX) {
            pBindingContext->InternalAddressTranslation = LLC_SEND_802_3_TO_DIX;
        } else {
            pBindingContext->InternalAddressTranslation = LLC_SEND_802_3_TO_802_3;
        }

#ifdef SUPPORT_ETHERNET_CLIENT

        if (NdisMedium == NdisMedium802_3) {
            pBindingContext->AddressTranslation = LLC_SEND_802_3_TO_802_3;
            if (EthernetType == LLC_ETHERNET_TYPE_DIX) {
                pBindingContext->AddressTranslation = LLC_SEND_802_3_TO_DIX;
            }
        } else {
            pBindingContext->SwapCopiedLanAddresses = TRUE;
            pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_802_3;
            if (EthernetType == LLC_ETHERNET_TYPE_DIX) {
                pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_DIX;
            }
        }

#else

        pBindingContext->SwapCopiedLanAddresses = TRUE;
        pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_802_3;
        if (EthernetType == LLC_ETHERNET_TYPE_DIX) {
            pBindingContext->AddressTranslation = LLC_SEND_802_5_TO_DIX;
        }

#endif

    }

    pBindingContext->NdisMedium = NdisMedium;
    pBindingContext->hClientContext = hClientContext;
    pBindingContext->pfCommandComplete = pfCommandComplete;
    pBindingContext->pfReceiveIndication = pfReceiveIndication;
    pBindingContext->pfEventIndication = pfEventIndication;
    *pusMaxFrameLength = (USHORT)pAdapterContext->MaxFrameSize;
    *pActualNdisMedium = pAdapterContext->NdisMedium;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // create a new timer tick (or update one that already exists) and add a
    // timer to it for the DLC timer (used by the DIR.TIMER.XXX routines). The
    // DLC timer fires every 0.5 seconds. The LLC timer fires every 40 mSec. The
    // multiplier is therefore 13 (13 * 40 mSec = 520 mSec). We need to add 5
    // because InitializeTimer is expecting DLC timer tick values of 1-5 and
    // 6-10. If the timer tick value is greater than 5, InitializeTimer will
    // subtract 5 and multiply by the second multiplier value
    //

    NdisStatus = InitializeTimer(pAdapterContext,
                                 &pBindingContext->DlcTimer,
                                 (UCHAR)13 + 5,
                                 (UCHAR)1,
                                 (UCHAR)1,
                                 LLC_TIMER_TICK_EVENT,
                                 pBindingContext,
                                 0, // ResponseDelay
                                 FALSE
                                 );
    if (NdisStatus != STATUS_SUCCESS) {

        IF_LOCK_CHECK {
            DbgPrint("LlcOpenAdapter: InitializeTimer failed\n");
        }

        //
        // we failed to initialize the timer. Free up all resources and return
        // the error
        //

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        RELEASE_DRIVER_LOCK();

        ASSUME_IRQL(PASSIVE_LEVEL);

        goto CleanUp;
    } else {
        StartTimer(&pBindingContext->DlcTimer);

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    }

    //
    // everything worked: point the binding context at the adapter context,
    // point the adapter context at the binding context, incrementing the binding
    // count (note that if this is the first binding, the count field will be
    // zero since we allocated the adapter context from ZeroMemory). Finally add
    // the adapter context to pAdapters if it wasn't already on the list
    //

    pBindingContext->pAdapterContext = pAdapterContext;

    IF_LOCK_CHECK {
        if (!pAdapterContext->BindingCount) {
            if (pAdapterContext->pBindings) {
                DbgPrint("**** binding count/pointer mismatch ****\n");
                DbgBreakPoint();
            }
        }
    }

    pBindingContext->pNext = pAdapterContext->pBindings;
    pAdapterContext->pBindings = pBindingContext;
    ++pAdapterContext->BindingCount;

    //
    // we can now add this adapter context structure to the global list
    // of adapter contexts
    //

#ifdef NDIS40
    ASSERT(newAdapter == FALSE);
#else // NDIS40
    if (newAdapter) {
        pAdapterContext->pNext = pAdapters;
        pAdapters = pAdapterContext;
    }
#endif // !NDIS40

    //
    // now release the semaphore, allowing any other threads waiting to open an
    // adapter to check the pAdapter list
    //

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

#ifdef NDIS40
    //
    // Release the NdisBindingHandle reference.
    //

    REFDEL(&pAdapterContext->AdapterRefCnt, 'nepO');
#endif // NDIS40

    //
    // return a pointer to the allocated binding context
    //

    *phBindingContext = (PVOID)pBindingContext;

    return STATUS_SUCCESS;

CleanUp:

    //
    // an error occurred. If we just allocated and (partially) filled in an
    // adapter context then close the adapter (if required), release the adapter
    // context resources and free the adapter context.
    // We have a binding context that we just allocated. Deallocate it
    // N.B. We cannot be here if the binding context's timer was successfully
    // initialized/started
    //

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // if we are to close this adapter then this is the first and only open of
    // this adapter, so we don't need to worry about synchronizing other threads
    // open the same adapter
    //

#ifdef NDIS40
    ASSERT(DoNdisClose == FALSE);
    
    //
    // Release the NdisBindingHandle reference.
    //

    ASSERT(pAdapterContext);
    REFDEL(&pAdapterContext->AdapterRefCnt, 'nepO');
#else // NDIS40
    if (DoNdisClose) {

        NDIS_STATUS status;

        pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;
        NdisCloseAdapter(&status,
                         pAdapterContext->NdisBindingHandle
                         );
        WaitAsyncOperation(&pAdapterContext->Event,
						   &(pAdapterContext->AsyncCloseResetStatus),
						   status);
        pAdapterContext->NdisBindingHandle = NULL;
    }
#endif // !NDIS40

    //
    // release the semaphore - any other threads can now get in and access
    // pAdapters
    //

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

#ifdef NDIS40
    ASSERT(newAdapter == FALSE);
#else // NDIS40
    //
    // if a newly allocated adapter context, release any resources allocated
    //

    if (newAdapter) {
        if (pAdapterContext->hNdisPacketPool) {

            //
            // Free MDLs allocated for each NDIS packet.
            //

            while (pAdapterContext->pNdisPacketPool) {

                PLLC_NDIS_PACKET pNdisPacket;

                pNdisPacket = PopFromList(((PLLC_PACKET)pAdapterContext->pNdisPacketPool));
                IoFreeMdl(pNdisPacket->pMdl);

                NdisFreePacket((PNDIS_PACKET)pNdisPacket);

                DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
            }

            NdisFreePacketPool(pAdapterContext->hNdisPacketPool);
        }

        //
        // DEBUG: refund memory charged for UNICODE buffer to driver string usage
        //
	
	if (initUnicodeString) {
	   FREE_STRING_DRIVER(pAdapterContext->Name.Buffer);
	}

        DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hLinkPool);
        DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hPacketPool);

        CHECK_MEMORY_RETURNED_ADAPTER();
        CHECK_STRING_RETURNED_ADAPTER();

        UNLINK_MEMORY_USAGE(pAdapterContext);
        UNLINK_STRING_USAGE(pAdapterContext);

        //
        // free the adapter context
        //

        FREE_MEMORY_DRIVER(pAdapterContext);

    }
#endif // !NDIS40

    //
    // free the binding context
    //

    FREE_MEMORY_FILE(pBindingContext);

    //
    // finally retake the spin lock and return the error status
    //

    ACQUIRE_DRIVER_LOCK();

    return NdisStatus;
}


VOID
LlcNdisOpenAdapterComplete(
    IN PVOID hAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN NDIS_STATUS OpenErrorStatus
    )

/*++

Routine Description:

    The routine completes the adapter opening.
    It only clears and sets the status flags, that are
    polled by the BindToAdapter primitive.

Arguments:

    hAdapterContext - describes adapter being opened
    NdisStatus      - the return status of NdisOpenAdapter
    OpenErrorStatus - additional error info from NDIS

Return Value:

    None.

--*/

{
    ASSUME_IRQL(DISPATCH_LEVEL);

    DEBUGMSG(DBG_NDIS_BIND,
        (TEXT("LLcNdisOpenAdapterComplete(%#x, %#x, %#x)\n"),
        hAdapterContext, NdisStatus, OpenErrorStatus));
    
    //
    // set the relevant fields in the adapter context
    //

    ((PADAPTER_CONTEXT)hAdapterContext)->AsyncOpenStatus = NdisStatus;
    ((PADAPTER_CONTEXT)hAdapterContext)->OpenErrorStatus = OpenErrorStatus;

    //
    // signal the event that LlcOpenAdapter is waiting on
    //

    ASSUME_IRQL(ANY_IRQL);

    KeSetEvent(&((PADAPTER_CONTEXT)hAdapterContext)->Event, 0L, FALSE);
}


VOID
LlcDisableAdapter(
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    The primitive disables all network indications on a data link binding.
    This routine can be called from a llc indication handler.

Arguments:

    pBindingContext - The context of the current adapter binding.

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    pAdapterContext = pBindingContext->pAdapterContext;
    if (pAdapterContext) {

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        TerminateTimer(pAdapterContext, &pBindingContext->DlcTimer);

        //
        // RLF 04/27/94
        //
        // this is a slight hack: we zap the pointer to the timer tick structure
        // so that if this is called again, TerminateTimer will see that the
        // pointer to the timer tick is NULL and will return immediately. We
        // shouldn't have to do this - we shouldn't poke around inside the
        // timer 'object' - but this function can potentially be called from two
        // places on the termination path - from DirCloseAdapter and now from
        // CloseAdapterFileContext.
        // We only do this for the DLC timer; if we did it for all timers - in
        // TerminateTimer - DLC would break (scandalous, I know)
        //

        pBindingContext->DlcTimer.pTimerTick = NULL;

#ifdef LOCK_CHECK

            pBindingContext->DlcTimer.Disabled = 0xd0bed0be; // do be do be do...

#endif

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    }
}


DLC_STATUS
LlcCloseAdapter(
    IN PBINDING_CONTEXT pBindingContext,
    IN BOOLEAN CloseAtNdisLevel
    )

/*++

Routine Description:

    remove a binding from an adapter. The binding context structure is unlinked
    from the adapter context structure and the count of bindings to the adapter
    context is decremented. The binding context structure is freed. If this is
    the last binding to the adapter then close the adapter at NDIS level, unlink
    the adapter context structure from the global adapter list and free the
    memory used by the adapter context structure

Arguments:

    pBindingContext     - describes adapter to close
    CloseAtNdisLevel    - TRUE if we need to perform NdisCloseAdapter

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - All NDIS error status from NdisCloseAdapter

--*/

{
    PADAPTER_CONTEXT pAdapterContext;
    NDIS_STATUS NdisStatus = STATUS_SUCCESS;
    KIRQL irql;
    USHORT bindingCount;

#if DBG

    PDLC_FILE_CONTEXT pFileContext = (PDLC_FILE_CONTEXT)(pBindingContext->hClientContext);

#endif

#ifdef LOCK_CHECK

    PBINDING_CONTEXT p;
    BOOLEAN found = FALSE;

    DEBUGMSG(DBG_NDIS_OPEN, (TEXT("+LlcCloseAdapter(%#x, %#x)\n"),
        pBindingContext, CloseAtNdisLevel));
    
#endif

    ASSUME_IRQL(DISPATCH_LEVEL);

    pAdapterContext = pBindingContext->pAdapterContext;

    if (!pAdapterContext) {

#if DBG

        DbgPrint("*** LlcCloseAdapter: NULL adapter context! ***\n");
        DbgBreakPoint();

#endif

        return STATUS_SUCCESS;
    }

    //
    // we must wait on the OpenAdapterSemaphore. We need to do this because a
    // thread in another process may be simultaneously generating a new binding
    // to this adapter context - it mustn't be removed until we are certain
    // there are no threads accessing this adapter context
    //

    RELEASE_DRIVER_LOCK();

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    ACQUIRE_DRIVER_LOCK();

    ASSUME_IRQL(DISPATCH_LEVEL);

    ACQUIRE_LLC_LOCK(irql);

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

#ifdef LOCK_CHECK

    for (p = pAdapterContext->pBindings; p; p = p->pNext) {
        if (p == pBindingContext) {
            found = TRUE;
            break;
        }
    }
    if (!found) {
        DbgPrint("\n**** LlcCloseAdapter: can't find BC %x ****\n\n", pBindingContext);
        DbgBreakPoint();
    } else if (p->pNext == p) {
        DbgPrint("\n**** LlcCloseAdapter: circular list ****\n\n");
        DbgBreakPoint();
    }

#endif

    RemoveFromLinkList((PVOID*)&(pAdapterContext->pBindings), pBindingContext);
    bindingCount = --pAdapterContext->BindingCount;

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

#ifdef LOCK_CHECK

    if (!pBindingContext->DlcTimer.Disabled) {
        DbgPrint("LlcCloseAdapter: mashing active timer. bc=%x\n", pBindingContext);
        DbgBreakPoint();
    }

#endif

    //
    // RLF 08/20/94
    //
    // here we must kill any events on the adapter context that may access
    // this binding context's event indication function pointer. If not, we
    // can end up with a blue screen (hey! it happened)
    //

    PurgeLlcEventQueue(pBindingContext);

    //
    // DEBUG: refund memory charged for BINDING_CONTEXT to FILE_CONTEXT
    //

    FREE_MEMORY_FILE(pBindingContext);


#ifdef NDIS40
    //
    // For PnP, the ADAPTER_CONTEXT is not cleaned up nor the NdisBindingHandle
    // closed when the last reference goes away. Instead this is controlled
    // by the NDIS bind/unbind handlers.
    //
    
    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();
#else
    if (!bindingCount) {

        RemoveFromLinkList((PVOID*)&pAdapters, pAdapterContext);

        //
        // Now the adapter is isolated from any global connections.
        // We may clear the global spin lock and free all resources
        // allocated for the adapter context.
        //

        RELEASE_LLC_LOCK(irql);

        RELEASE_DRIVER_LOCK();

        ASSUME_IRQL(PASSIVE_LEVEL);

        //
        // Out of memory conditions the upper driver cannot properly
        // wait until all pending NDIS packets have been sent.
        // In that case we must poll here.
        // (This should happen only if ExAllocatePool fails, but
        // after an inproper shutdown we will loop here forever)
        //

#if DBG

        if (pAdapterContext->ObjectCount) {
            DbgPrint("Waiting LLC objects to be closed ...\n");
        }

#endif

        while (pAdapterContext->ObjectCount) {
            LlcSleep(1000L);      // check the situation after 1 ms
        }

        //
        // RLF 10/26/92
        //
        // we used to test pAdapterContext->NdisBindingHandle for NULL here,
        // but that is an unreliable test since the NdisBindingHandle can be
        // non-NULL even though the binding was not made. We now use the
        // CloseAtNdisLevel parameter to indicate whether we should call the
        // Ndis function to close the adapter
        //

        //
        // MunilS 6/13/96
        //
        // Moved NdisFreePacketPool etc after NdisCloseAdapter to prevent
        // bugcheck in NDIS while handling outstanding sends.
        //

        if (CloseAtNdisLevel)
        {
            pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;

            NdisCloseAdapter(&NdisStatus,
                             pAdapterContext->NdisBindingHandle
                             );

            WaitAsyncOperation(&pAdapterContext->Event,
							   &(pAdapterContext->AsyncCloseResetStatus),
							   NdisStatus);
            pAdapterContext->NdisBindingHandle = NULL;
        }

        if (pAdapterContext->hNdisPacketPool)
        {

           //
           // Free MDLs allocated for each NDIS packet.
           //

           while (pAdapterContext->pNdisPacketPool) {

               PLLC_NDIS_PACKET pNdisPacket;

               pNdisPacket = PopFromList(((PLLC_PACKET)pAdapterContext->pNdisPacketPool));

               IoFreeMdl(pNdisPacket->pMdl);
	
               NdisFreePacket((PNDIS_PACKET)pNdisPacket);
	
               DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
           }

           NdisFreePacketPool(pAdapterContext->hNdisPacketPool);
       }

       //
       // DEBUG: refund memory charged for UNICODE buffer to driver string usage
       //

       FREE_STRING_DRIVER(pAdapterContext->Name.Buffer);

       DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hLinkPool);

       DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hPacketPool);

       CHECK_MEMORY_RETURNED_ADAPTER();

       CHECK_STRING_RETURNED_ADAPTER();

       UNLINK_MEMORY_USAGE(pAdapterContext);

       UNLINK_STRING_USAGE(pAdapterContext);

       FREE_MEMORY_DRIVER(pAdapterContext);

    } else {

       RELEASE_LLC_LOCK(irql);

       RELEASE_DRIVER_LOCK();

    }
#endif // !NDIS40

    //
    // now we can enable any other threads waiting on the open semaphore
    //

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

    ACQUIRE_DRIVER_LOCK();

    return NdisStatus;
}


DLC_STATUS
LlcResetBroadcastAddresses(
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    The primitive deletes the broadcast addresses used by the binding.
    In the case of ethernet it updates multicast address list on
    the adapter, that excludes any addresses set by this binding.
    The last binding actually gives an empty list, that resets
    all addresses set by this protocol binding.

Arguments:

    pBindingContext - The context of the current adapter binding.

Return Value:

    DLC_STATUS:
        Success - STATUS_SUCCESS
        Failure - All NDIS error status from NdisCloseAdapter

--*/

{
    PADAPTER_CONTEXT pAdapterContext;

    ASSUME_IRQL(DISPATCH_LEVEL);

    pAdapterContext = pBindingContext->pAdapterContext;

    if (pAdapterContext == NULL) {
        return STATUS_SUCCESS;
    }

    //
    // Reset the functional and group addresses of this binding context.
    // In the case of ethernet,  functional and group addresses of
    // binding contexts are mapped to one global multicast list of
    // this NDIS binding.  Token-ring may have only one group
    // address, that must be reset, when the application owning it
    // is closing its dlc adapter context.  Functional address
    // must also set again in that case.
    //

    pBindingContext->Functional.ulAddress = 0;
    UpdateFunctionalAddress(pAdapterContext);

    if (pBindingContext->ulBroadcastAddress != 0) {
        pBindingContext->ulBroadcastAddress = 0;
        UpdateGroupAddress(pAdapterContext, pBindingContext);
    }

    return STATUS_SUCCESS;
}


NDIS_STATUS
InitNdisPackets(
    OUT PLLC_NDIS_PACKET* ppLlcPacketPool,
    IN NDIS_HANDLE hNdisPool
    )

/*++

Routine Description:

    The primitive copies Ndis packets from the NDIS pool to the
    given internal packet pool.

Arguments:

    ppLlcPacketPool - pointer to pointer to packet pool
    hNdisPool       - handle of NDIS packet pool

Return Value:

    NDIS_STATUS
--*/

{
    PLLC_NDIS_PACKET pNdisPacket;
    NDIS_STATUS NdisStatus;
    UINT i;

    ASSUME_IRQL(PASSIVE_LEVEL);

    for (i = 0; i < MAX_NDIS_PACKETS; i++) {
        NdisAllocatePacket(&NdisStatus,
                           (PNDIS_PACKET*)&pNdisPacket,
                           hNdisPool
                           );
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            return NdisStatus;
        }

        //
        // Every NDIS packet includes a MDL, that has been
        // initialized for the data buffer within the same
        // structure. Thus data link driver does need to
        // do any MDL calls during the runtime
        //

        pNdisPacket->pMdl = IoAllocateMdl(pNdisPacket->auchLanHeader,
                                          sizeof(pNdisPacket->auchLanHeader),
                                          FALSE,
                                          FALSE,
                                          NULL
                                          );
        if (pNdisPacket->pMdl == NULL) {
	    NdisFreePacket((PNDIS_PACKET) pNdisPacket);
            return DLC_STATUS_NO_MEMORY;
        }

        DBG_INTERLOCKED_INCREMENT(AllocatedMdlCount);

        MmBuildMdlForNonPagedPool(pNdisPacket->pMdl);

        PushToList(((PLLC_PACKET)*ppLlcPacketPool),
                   ((PLLC_PACKET)pNdisPacket)
                   );
    }

    return NDIS_STATUS_SUCCESS;
}


VOID
LlcNdisCloseComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    call-back from NDIS when the adapter close operation is completed

Arguments:

    pAdapterContext - describes the adapter being closed
    NdisStatus      - the return status of NdisOpenAdapter

Return Value:

        None
--*/

{
    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_LLC_LOCK(irql);

    pAdapterContext->AsyncCloseResetStatus = NdisStatus;

    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();

    KeSetEvent(&pAdapterContext->Event, 0L, FALSE);

}


VOID
NdisStatusHandler(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_STATUS NdisStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    )

/*++

Routine Description:

    indication handler for all NDIS status events

Arguments:

    pAdapterContext     - context of the NDIS adapter
    NdisStatus          - the major NDIS status code
    StatusBuffer        - A buffer holding more status information
    StatusBufferSize    - The length of StatusBuffer.

Return Value:

    None.

--*/

{
    PBINDING_CONTEXT pBinding;
    PEVENT_PACKET pEvent;
    KIRQL irql;

    //
    // seems that this handler can be called at PASSIVE_LEVEL too
    //

    ASSUME_IRQL(ANY_IRQL);

    //
    // We must synchronize the access to the binding list,
    // the reference count will not allow the client
    // to delete or modify the bindings list while
    // we are routing the status indication to the
    // clients.
    //

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_LLC_LOCK(irql);

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // The NDIS send process is stopped by the reset flag.
    //

    if (NdisStatus == NDIS_STATUS_RESET_START) {
        pAdapterContext->ResetInProgress = TRUE;
    } else if (NdisStatus == NDIS_STATUS_RESET_END) {
        pAdapterContext->ResetInProgress = FALSE;
    } else if (StatusBufferSize == sizeof(NTSTATUS)) {

        //
        // ADAMBA - Declare and assign SpecificStatus locally.
        //

        NTSTATUS SpecificStatus = *(PULONG)StatusBuffer;

		if ( NdisStatus == NDIS_STATUS_RING_STATUS ) {
#if DBG
			ASSERT (IS_NDIS_RING_STATUS(SpecificStatus));
#else	// DBG
			if (IS_NDIS_RING_STATUS(SpecificStatus))
#endif	// DBG
			{
				SpecificStatus = NDIS_RING_STATUS_TO_DLC_RING_STATUS(SpecificStatus);
			}
		}

        //
        // These ndis status codes are indicated to all LLC
        // protocol drivers, that have been bound to this adapter:
        //
        // NDIS_STATUS_ONLINE
        // NDIS_STATUS_CLOSED
        // NDIS_STATUS_RING_STATUS
        //

        for (pBinding = pAdapterContext->pBindings;
             pBinding;
             pBinding = pBinding->pNext) {

            pEvent = ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

            if (pEvent) {
                pEvent->pBinding = pBinding;
                pEvent->hClientHandle = NULL;
                pEvent->Event = LLC_NETWORK_STATUS;
                pEvent->pEventInformation = (PVOID)UlongToPtr(NdisStatus);
                pEvent->SecondaryInfo = SpecificStatus;
                LlcInsertTailList(&pAdapterContext->QueueEvents, pEvent);
            }
        }
    }

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();
}


NDIS_STATUS
GetNdisParameter(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_OID NdisOid,
    IN PVOID pDataBuffer,
    IN UINT DataSize
    )

/*++

Routine Description:

    get parameter from NDIS using OID interface

Arguments:

    pAdapterContext - describes adapter
    NdisOid         - indentifies the requested NDIS data
    pDataBuffer     - the buffer for the returned data
    DataSize        - size of pDataBuffer

Return Value:

    NDIS_STATUS

--*/

{
    LLC_NDIS_REQUEST Request;

    ASSUME_IRQL(PASSIVE_LEVEL);

    Request.Ndis.RequestType = NdisRequestQueryInformation;
    Request.Ndis.DATA.QUERY_INFORMATION.Oid = NdisOid;
    Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer = pDataBuffer;
    Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = DataSize;

    return SyncNdisRequest(pAdapterContext, &Request);
}


NDIS_STATUS
SetNdisParameter(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN NDIS_OID NdisOid,
    IN PVOID pRequestInfo,
    IN UINT RequestLength
    )

/*++

Routine Description:

    set NDIS parameter using OID interface

Arguments:

    pAdapterContext - describes adapter
    NdisOid         - describes info to set
    pRequestInfo    - pointer to info
    RequestLength   - size of info

Return Value:

    NDIS_STATUS

--*/

{
    LLC_NDIS_REQUEST Request;

    ASSUME_IRQL(PASSIVE_LEVEL);

    Request.Ndis.RequestType = NdisRequestSetInformation;
    Request.Ndis.DATA.SET_INFORMATION.Oid = NdisOid;
    Request.Ndis.DATA.SET_INFORMATION.InformationBuffer = pRequestInfo;
    Request.Ndis.DATA.SET_INFORMATION.InformationBufferLength = RequestLength;
    return SyncNdisRequest(pAdapterContext, &Request);
}


DLC_STATUS
SyncNdisRequest(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PLLC_NDIS_REQUEST pRequest
    )

/*++

Routine Description:

    Perform an NDIS request synchronously, even if the actual request would
    be asynchronous

Arguments:

    pAdapterContext - pointer to adapter context
    pRequest        - pointer to NDIS request structure

Return Value:

    DLC_STATUS

--*/

{
    DLC_STATUS Status;

    ASSUME_IRQL(PASSIVE_LEVEL);

    KeInitializeEvent(&pRequest->SyncEvent, NotificationEvent, FALSE);

#ifdef NDIS40
    REFADD(&pAdapterContext->AdapterRefCnt, 'tqeR');

    if (InterlockedCompareExchange(
        &pAdapterContext->BindState,
        BIND_STATE_BOUND,
        BIND_STATE_BOUND) != BIND_STATE_BOUND)
    {                                           
        REFDEL(&pAdapterContext->AdapterRefCnt, 'tqeR');
        return (NDIS_STATUS_ADAPTER_NOT_OPEN);
    }

    // Above reference is removed by WaitAsyncOperation.
#endif // NDIS40

    pRequest->AsyncStatus = NDIS_STATUS_PENDING;
    NdisRequest((PNDIS_STATUS)&Status, pAdapterContext->NdisBindingHandle, &pRequest->Ndis);
    
    Status = (DLC_STATUS)WaitAsyncOperation(&pRequest->SyncEvent,
										  &(pRequest->AsyncStatus),
										  Status);

#ifdef NDIS40
    REFDEL(&pAdapterContext->AdapterRefCnt, 'tqeR');
#endif // NDIS40

    return (Status);
}


NDIS_STATUS
WaitAsyncOperation(
    IN PKEVENT pEvent,
    IN PNDIS_STATUS pAsyncStatus,
    IN NDIS_STATUS  NdisStatus
    )

/*++

Routine Description:

    Wait for an asynchronous NDIS operation to complete

Arguments:

    pAsyncStatus    - pointer to status returned from NDIS
    NdisStatus      - status to wait for. Should be NDIS_STATUS_PENDING

Return Value:

    NDIS_STATUS

--*/

{
    NDIS_STATUS AsyncStatus;

    ASSUME_IRQL(PASSIVE_LEVEL);

    //
    // Check if we got a synchronous status
    //

    if (NdisStatus != NDIS_STATUS_PENDING) {
        AsyncStatus = NdisStatus;
    }

	else{
		//
		// Wait until the async status flag has been set
		//

		for ( ; ; ) {

			KIRQL irql;
			NTSTATUS ntstatus;

			do {
			ntstatus = KeWaitForSingleObject(pEvent,
							 Executive,
							 KernelMode,
							 TRUE, // alertable
							 (PLARGE_INTEGER)NULL
							 );
			} while (ntstatus == STATUS_ALERTED);

			//
			// The result may be undefined, if we read it in a wrong time.
			// Do it interlocked.
			//

			ACQUIRE_DRIVER_LOCK();

			ACQUIRE_LLC_LOCK(irql);

			AsyncStatus = *pAsyncStatus;

			RELEASE_LLC_LOCK(irql);

			RELEASE_DRIVER_LOCK();

			if (AsyncStatus != NDIS_STATUS_PENDING) {
				break;
			}
			else{
				KeClearEvent(pEvent);
			}

		}
        KeClearEvent(pEvent);
	}
    return AsyncStatus;
}


DLC_STATUS
LlcNdisRequest(
    IN PVOID hBindingContext,
    IN PLLC_NDIS_REQUEST pDlcParms
    )

/*++

Routine Description:

    makes an NDIS request

Arguments:

    hBindingContext - pointer to binding context
    pDlcParms       - pointer to request-specific parameters

Return Value:

    DLC_STATUS

--*/

{
    return SyncNdisRequest(((PBINDING_CONTEXT)hBindingContext)->pAdapterContext,
                           pDlcParms
                           );
}


VOID
LlcNdisRequestComplete(
    IN PADAPTER_CONTEXT pAdapterContext,
    IN PNDIS_REQUEST RequestHandle,
    IN NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    receives control when an aync NDIS command completes

Arguments:

    pAdapterContext - pointer to ADAPTER_CONTEXT for which request was made
    RequestHandle   - handle of request
    NdisStatus      - returned status from NDIS

Return Value:

    None.

--*/

{
    KIRQL irql;
	PLLC_NDIS_REQUEST pLlcNdisRequest =
		CONTAINING_RECORD ( RequestHandle, LLC_NDIS_REQUEST, Ndis );

    UNREFERENCED_PARAMETER(pAdapterContext);

    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    ACQUIRE_LLC_LOCK(irql);

	pLlcNdisRequest->AsyncStatus = NdisStatus;

    RELEASE_LLC_LOCK(irql);

    RELEASE_DRIVER_LOCK();

    KeSetEvent(&pLlcNdisRequest->SyncEvent, 0L, FALSE);

}


VOID
LlcNdisReset(
    IN PBINDING_CONTEXT pBindingContext,
    IN PLLC_PACKET pPacket
    )

/*++

Routine Description:

    The routine issues a hardware reset command for a network adapter.

Arguments:

    pBindingContext - context of protocol module bound to the data link
    pPacket         - command packet

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pBindingContext->pAdapterContext;
    BOOLEAN ResetIt;
    NDIS_STATUS Status;

    ASSUME_IRQL(DISPATCH_LEVEL);

    pPacket->pBinding = pBindingContext;
    pPacket->Data.Completion.CompletedCommand = LLC_RESET_COMPLETION;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    ResetIt = FALSE;
    if (pAdapterContext->pResetPackets != NULL) {
        ResetIt = TRUE;
    }
    pPacket->pNext = pAdapterContext->pResetPackets;
    pAdapterContext->pResetPackets = pPacket;

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    //
    // We don't reset NDIS, if there is already a pending reset command
    //

    RELEASE_DRIVER_LOCK();

    if (ResetIt) {
        NdisReset(&Status, pAdapterContext->NdisBindingHandle);
    }

    if (Status != STATUS_PENDING) {
        LlcNdisResetComplete(pAdapterContext, Status);
    }

    //
    // Note: we will return always a pending status =>
    // multiple protocols may issue simultaneous reset
    // and complete it normally.
    //

    ACQUIRE_DRIVER_LOCK();
}


VOID
LlcNdisResetComplete(
    PADAPTER_CONTEXT pAdapterContext,
    NDIS_STATUS NdisStatus
    )

/*++

Routine Description:

    The routine is called when a hard reset command is complete.

Arguments:

    pAdapterContext - describes adapter being reset
    NdisStatus      - result of adapter reset operation from NDIS

Return Value:

    None.

--*/

{
    PLLC_PACKET pPacket;

    //
    // this function can be called from an NDIS DPC or from LlcNdisReset (above)
    //

    ASSUME_IRQL(ANY_IRQL);

    ACQUIRE_DRIVER_LOCK();

    //
    // Indicate the completed reset command completion to all
    // protocols, that had a pending reset command.
    //

    for (;;) {

        ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        pPacket = pAdapterContext->pResetPackets;
        if (pPacket != NULL) {
            pAdapterContext->pResetPackets = pPacket->pNext;
        }

        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

        if (pPacket == NULL) {
            break;
        } else {
            pPacket->Data.Completion.Status = NdisStatus;
            pPacket->pBinding->pfCommandComplete(pPacket->pBinding->hClientContext,
                                                 NULL,
                                                 pPacket
                                                 );
        }
    }

    RELEASE_DRIVER_LOCK();
}


BOOLEAN
UnicodeStringCompare(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    )

/*++

Routine Description:

    Compare 2 unicode strings. Difference between this and RtlEqualUnicodeString
    is that this is callable from within spinlocks (i.e. non-pageable)

Arguments:

    String1 - pointer to UNICODE_STRING 1
    String2 - pointer to UNICODE_STRING 2

Return Value:

    BOOLEAN
        TRUE    - String1 == String2
        FALSE   - String1 != String2

--*/

{
    if (String1->Length == String2->Length) {

        USHORT numChars = String1->Length / sizeof(*String1->Buffer);
        PWSTR buf1 = String1->Buffer;
        PWSTR buf2 = String2->Buffer;

        while (numChars) {
            if (*buf1++ == *buf2++) {
                --numChars;
            } else {
                return FALSE;
            }
        }
        return TRUE;
    }
    return FALSE;
}


VOID
PurgeLlcEventQueue(
    IN PBINDING_CONTEXT pBindingContext
    )

/*++

Routine Description:

    If there are any outstanding events on the adapter context waiting to be
    indicated to the client of the current binding, they are removed

Arguments:

    pBindingContext - pointer to BINDING_CONTEXT about to be deleted

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pBindingContext->pAdapterContext;
    ASSUME_IRQL(DISPATCH_LEVEL);

    if (!IsListEmpty(&pAdapterContext->QueueEvents)) {

        PEVENT_PACKET pEventPacket;
        PEVENT_PACKET nextEventPacket;

        for (pEventPacket = (PEVENT_PACKET)pAdapterContext->QueueEvents.Flink;
             pEventPacket != (PEVENT_PACKET)&pAdapterContext->QueueEvents;
             pEventPacket = nextEventPacket) {

            nextEventPacket = pEventPacket->pNext;
            if (pEventPacket->pBinding == pBindingContext) {
                RemoveEntryList((PLIST_ENTRY)&pEventPacket->pNext);

#if DBG
                DbgPrint("PurgeLlcEventQueue: BC=%x PKT=%x\n", pBindingContext, pEventPacket);
#endif

                DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pEventPacket);

            }
        }
    }
}

#ifdef NDIS40

PADAPTER_CONTEXT
AllocateAdapterContext(
    PNDIS_STRING pAdapterName
    )
{
    PADAPTER_CONTEXT pAdapterContext;
    NDIS_STATUS      NdisStatus = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_NDIS_BIND,
        (TEXT("+AllocateAdapterContext(%#x)\n"), pAdapterName));
    
    pAdapterContext = (PADAPTER_CONTEXT) ALLOCATE_ZEROMEMORY_DRIVER(
        sizeof(ADAPTER_CONTEXT));

    if (pAdapterContext == NULL)
    {
        NdisStatus = NDIS_STATUS_RESOURCES;
        goto done;
    }
    
    //
    // New PnP structure members.
    //

    REFINIT(
        &pAdapterContext->AdapterRefCnt,
        pAdapterContext,
        CloseAdapter,
        'tpdA');

    KeInitializeEvent(&pAdapterContext->CloseAdapterEvent, NotificationEvent, FALSE);

    pAdapterContext->BindState = BIND_STATE_UNBOUND;

#if DBG

    //
    // record who owns this memory usage structure and add it to the
    // list of all memory usages created in the driver
    //

    pAdapterContext->MemoryUsage.Owner = (PVOID)pAdapterContext;
    pAdapterContext->MemoryUsage.OwnerObjectId = AdapterContextObject;
    pAdapterContext->StringUsage.Owner = (PVOID)pAdapterContext;
    pAdapterContext->StringUsage.OwnerObjectId = AdapterContextObject;
    LinkMemoryUsage(&pAdapterContext->MemoryUsage);
    LinkMemoryUsage(&pAdapterContext->StringUsage);

#endif

    //
    // We must allocate all spinlocks immediately after the
    // adapter context has been allocated, because
    // they can also deallocated simultaneously.
    //

    ALLOCATE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
    ALLOCATE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    //
    // allocate space for the adapter name string from non-paged pool
    // and initialize the name in the adapter context structure
    //

    NdisStatus = LlcInitUnicodeString(
        &pAdapterContext->Name,
        pAdapterName);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        goto done;
    }

    pAdapterContext->OpenCompleteStatus = NDIS_STATUS_PENDING;

    //
    // We must initialize the list heads before we open the adapter!!!
    //

    InitializeListHead(&pAdapterContext->QueueEvents);
    InitializeListHead(&pAdapterContext->QueueCommands);
    InitializeListHead(&pAdapterContext->NextSendTask);

    pAdapterContext->OpenErrorStatus = NDIS_STATUS_PENDING;

    KeInitializeEvent(&pAdapterContext->Event, NotificationEvent, FALSE);


done:

    if (NdisStatus != NDIS_STATUS_SUCCESS &&
        pAdapterContext)
    {
        FreeAdapterContext(pAdapterContext);
        pAdapterContext = NULL;
    }

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-AllocateAdapterContext [%#x]\n"), NdisStatus));

    return (pAdapterContext);
}


VOID
FreeAdapterContext(
    PADAPTER_CONTEXT pAdapterContext
    )
{
    ASSERT(pAdapterContext);

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("+FreeAdapterContext(%#x)\n"), pAdapterContext));
    
    if (pAdapterContext->hNdisPacketPool)
    {
        //
        // Free MDLs for each NDIS packet.
        //

        while (pAdapterContext->pNdisPacketPool)
        {
            PLLC_NDIS_PACKET pNdisPacket;

            pNdisPacket = PopFromList(((PLLC_PACKET)pAdapterContext->pNdisPacketPool));
            IoFreeMdl(pNdisPacket->pMdl);
            NdisFreePacket((PNDIS_PACKET)pNdisPacket);

            DBG_INTERLOCKED_DECREMENT(AllocatedMdlCount);
        }

        NdisFreePacketPool(pAdapterContext->hNdisPacketPool);
    }

    if (pAdapterContext->Name.Buffer)
    {
        FREE_STRING_DRIVER(pAdapterContext->Name.Buffer);
    }

    if (pAdapterContext->hLinkPool)
    {
        DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hLinkPool);
    }

    if (pAdapterContext->hPacketPool)
    {
        DELETE_PACKET_POOL_ADAPTER(&pAdapterContext->hPacketPool);
    }

    CHECK_MEMORY_RETURNED_ADAPTER();
    CHECK_STRING_RETURNED_ADAPTER();
    
    UNLINK_MEMORY_USAGE(pAdapterContext);
    UNLINK_STRING_USAGE(pAdapterContext);
    
    FREE_MEMORY_DRIVER(pAdapterContext);
    
    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-FreeAdapterContext\n")));
    
    return;
}


NDIS_STATUS
OpenAdapter(
    PADAPTER_CONTEXT pAdapterContext,
    BOOLEAN          fFirstOpen
    )

/*++

 Routine Description:


 Arguments:

    pAdapterContext - Context describing the adapter to open.
    
    fFirstOpen - On first time opening the adapter, need to configure some
                 ADAPTER_CONTEXT data members.

 Return Value:

    NDIS_STATUS_SUCCESS - Successfully opened the adapter and configured.
    
    

--*/

{
    NDIS_STATUS NdisStatus;
    NTSTATUS    NtStatus;
    UINT        MediumIndex;
    LONG        BindState;

    LLC_NDIS_REQUEST Request;

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("OpenAdapter(%#x) %ws\n"), 
        pAdapterContext, 
        pAdapterContext->Name.Buffer)); // This buffer is null terminated.
    
    KeClearEvent(&pAdapterContext->Event);
    pAdapterContext->OpenErrorStatus = NDIS_STATUS_PENDING;

    // Initialize the event for the request.
    KeInitializeEvent(&Request.SyncEvent, NotificationEvent, FALSE);

    NdisOpenAdapter(
        &NdisStatus,
        &pAdapterContext->OpenErrorStatus,
        &pAdapterContext->NdisBindingHandle,
        &MediumIndex,
        (PNDIS_MEDIUM)&LlcMediumArray[0],
        sizeof(LlcMediumArray),
        (NDIS_HANDLE) LlcProtocolHandle,
        (NDIS_HANDLE) pAdapterContext,
        &pAdapterContext->Name,
        NDIS_OPEN_RECEIVE_NOT_REENTRANT,
        NULL);      // No addressing info.

    if (NdisStatus == NDIS_STATUS_PENDING)
    {
        ASSUME_IRQL(PASSIVE_LEVEL);

        DEBUGMSG(DBG_NDIS_BIND, (TEXT("OpenAdapter - NdisOpenAdapter pending.\n")));
        
        do
        {
            NtStatus = KeWaitForSingleObject(
                &pAdapterContext->Event,
                Executive,
                KernelMode,
                TRUE, // Alertable.
                (PLARGE_INTEGER) NULL);
        } 
        while (NtStatus == STATUS_ALERTED);

        //
        // Get the open return status.
        //

        NdisStatus = pAdapterContext->AsyncOpenStatus;

        KeResetEvent(&pAdapterContext->Event);
    }

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - NdisOpenAdapter failure.\n")));
        pAdapterContext->NdisBindingHandle = NULL;
        goto done;
    }

    //
    // Reference count the NDIS binding handle.
    //

    REFADD(&pAdapterContext->AdapterRefCnt, 'dniB');

    //
    // On the first time opening adapter, we need to initialize some members
    // of the ADAPTER_CONTEXT.
    //

    if (fFirstOpen == TRUE)
    {
        pAdapterContext->NdisMedium = LlcMediumArray[MediumIndex];
    
        DEBUGMSG(DBG_NDIS_BIND,
            (TEXT("OpenAdapter - adapter %ws open, medium = %s (%d)\n"),
            pAdapterContext->Name.Buffer, 
            pAdapterContext->NdisMedium == NdisMedium802_5 ? TEXT("802_5") :
            pAdapterContext->NdisMedium == NdisMedium802_3 ? TEXT("802_3") :
            pAdapterContext->NdisMedium == NdisMediumFddi ? TEXT("Fddi")   : 
                TEXT("Unknown!!"),
            pAdapterContext->NdisMedium));
    
        //
        // fill-in some medium-specific fields
        //
    
        switch (pAdapterContext->NdisMedium)
        {
            case NdisMedium802_5:
                pAdapterContext->cbMaxFrameHeader = 32;  // 6 + 6 + 2 + 18
    
                //
                // the top bit of the destination address signifies a broadcast
                // frame. On Token Ring, the top bit is bit 7
                //
    
                pAdapterContext->IsBroadcast = 0x80;
    
                //
                // functional address starts C0-00-... The top 2 bytes are compared
                // as a USHORT = 0x00C0
                //
    
                pAdapterContext->usHighFunctionalBits = 0x00C0;
                pAdapterContext->AddressTranslationMode = LLC_SEND_802_5_TO_802_5;
                break;
    
            case NdisMedium802_3:
                pAdapterContext->cbMaxFrameHeader = 14;  // 6 + 6 + 2
    
                //
                // the top bit of the destination address signifies a broadcast
                // frame. On Ethernet, the top bit is bit 0
                //
    
                pAdapterContext->IsBroadcast = 0x01;
    
                //
                // functional address starts 03-00-... The top 2 bytes are compared as
                // a USHORT = 0x0003
                //
    
                pAdapterContext->usHighFunctionalBits = 0x0003;
                pAdapterContext->AddressTranslationMode = LLC_SEND_802_3_TO_802_3;
                break;
    
            case NdisMediumFddi:
                pAdapterContext->cbMaxFrameHeader = 13;  // 1 + 6 + 6
    
                //
                // bits are in same order as for ethernet
                //
    
                pAdapterContext->IsBroadcast = 0x01;
                pAdapterContext->usHighFunctionalBits = 0x0003;
                pAdapterContext->AddressTranslationMode = LLC_SEND_FDDI_TO_FDDI;
                break;
        }
    
        //
        // allocate the ndis packets. The NDIS packet must have space
        // for the maximum number frame header and the maximum LLC response
        // and its information field (quite small)
        //
    
        NdisAllocatePacketPool(
            &NdisStatus,
            &pAdapterContext->hNdisPacketPool,
            MAX_NDIS_PACKETS + 1,
            sizeof(LLC_NDIS_PACKET) - sizeof(NDIS_MAC_PACKET));
    
        if (NdisStatus != NDIS_STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - NdisAllocatePacketPool failure.\n")));
            goto done;
        }
    
        NdisStatus = InitNdisPackets(
            &pAdapterContext->pNdisPacketPool,
            pAdapterContext->hNdisPacketPool);
    
        if (NdisStatus != NDIS_STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - InitNdisPackets failure.\n")));
            goto done;
        }
    
        //
        // Initialize the LLC packet pool
        //
    
        pAdapterContext->hPacketPool = CREATE_PACKET_POOL_ADAPTER(
            LlcPacketPoolObject,
            sizeof(UNITED_PACKETS),
            8);
    
        if (pAdapterContext->hPacketPool == NULL) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - CREATE_PACKET_POOL_ADAPTER hPacketPool failure.\n")));
            NdisStatus = NDIS_STATUS_RESOURCES;
            goto done;
        }
    
        pAdapterContext->hLinkPool = CREATE_PACKET_POOL_ADAPTER(
            LlcLinkPoolObject,
            pAdapterContext->cbMaxFrameHeader + sizeof(DATA_LINK),
            2);
    
        if (pAdapterContext->hLinkPool == NULL) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - CREATE_PACKET_POOL_ADAPTER hLinkPool failure.\n")));
            NdisStatus = NDIS_STATUS_RESOURCES;
            goto done;
        }
    
        //
        // Read the current node address and maximum frame size
        //
    
        // Can't use GetNdisParameter since it checks to see if adapter is bound,
        // which is isn't since we don't want anyone to use it until we are done
        // initialization.
    
    
        Request.Ndis.RequestType = NdisRequestQueryInformation;
        Request.Ndis.DATA.QUERY_INFORMATION.Oid =         
            (pAdapterContext->NdisMedium == NdisMedium802_3) ? OID_802_3_CURRENT_ADDRESS  : 
            (pAdapterContext->NdisMedium == NdisMediumFddi)  ? OID_FDDI_LONG_CURRENT_ADDR : 
            OID_802_5_CURRENT_ADDRESS;
    
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer       = pAdapterContext->NodeAddress;
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(pAdapterContext->NodeAddress);;
    
        Request.AsyncStatus = NDIS_STATUS_PENDING;
        NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
    
        NdisStatus = WaitAsyncOperation(
            &Request.SyncEvent,
            &Request.AsyncStatus,
            NdisStatus);
    
    //  NdisStatus = GetNdisParameter(
    //      pAdapterContext,
    //      (pAdapterContext->NdisMedium == NdisMedium802_3) ? OID_802_3_CURRENT_ADDRESS  : 
    //      (pAdapterContext->NdisMedium == NdisMediumFddi)  ? OID_FDDI_LONG_CURRENT_ADDR : 
    //       OID_802_5_CURRENT_ADDRESS,
    //      pAdapterContext->NodeAddress,
    //      sizeof(pAdapterContext->NodeAddress));
        
        if (NdisStatus != NDIS_STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - GetNdisParm CURR_ADDRESS failure %#x.\n"),
                NdisStatus));
            goto done;
        }
    
        Request.Ndis.RequestType = NdisRequestQueryInformation;
        Request.Ndis.DATA.QUERY_INFORMATION.Oid =         
            (pAdapterContext->NdisMedium == NdisMedium802_3) ? OID_802_3_PERMANENT_ADDRESS  : 
            (pAdapterContext->NdisMedium == NdisMediumFddi)  ? OID_FDDI_LONG_PERMANENT_ADDR : 
            OID_802_5_PERMANENT_ADDRESS;
    
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer       = pAdapterContext->PermanentAddress;
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(pAdapterContext->PermanentAddress);;
    
        Request.AsyncStatus = NDIS_STATUS_PENDING;
        NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
    
        NdisStatus = WaitAsyncOperation(
            &Request.SyncEvent,
            &Request.AsyncStatus,
            NdisStatus);
    
    //  NdisStatus = GetNdisParameter(
    //      pAdapterContext,
    //      (pAdapterContext->NdisMedium == NdisMedium802_3) ? OID_802_3_PERMANENT_ADDRESS  : 
        //      (pAdapterContext->NdisMedium == NdisMediumFddi)  ? OID_FDDI_LONG_PERMANENT_ADDR : 
    //       OID_802_5_PERMANENT_ADDRESS,
    //      pAdapterContext->PermanentAddress,
    //      sizeof(pAdapterContext->PermanentAddress));
    
        if (NdisStatus != NDIS_STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - GetNdisParm PERM_ADDRESS failure.\n")));
            goto done;
        }
    
        {
            //
            // Mod RLF 07/10/92
            //
            // apparently, TR adapter does not support NDIS_PACKET_TYPE_MULTICAST
            // as a filter. Up to now, it seems to have been reasonably happy
            // with this type. However, we're not going to include it from now on
            //
    
            //
            // Mod RLF 01/13/93
            //
            // Similarly, Ethernet doesn't support FUNCTIONAL addresses (Token
            // Ring's functional address is equivalent to Ethernet's multicast
            // address)
            //
    
            ULONG PacketFilter = 
                NDIS_PACKET_TYPE_DIRECTED  | 
                NDIS_PACKET_TYPE_BROADCAST | 
                (((pAdapterContext->NdisMedium == NdisMedium802_3) || (pAdapterContext->NdisMedium == NdisMediumFddi))
                                  ? NDIS_PACKET_TYPE_MULTICAST
                                  : NDIS_PACKET_TYPE_FUNCTIONAL);
    
            //
            // EndMod
            //
    
            Request.Ndis.RequestType                                  = NdisRequestSetInformation;
            Request.Ndis.DATA.SET_INFORMATION.Oid                     = OID_GEN_CURRENT_PACKET_FILTER;
            Request.Ndis.DATA.SET_INFORMATION.InformationBuffer       = &PacketFilter;
            Request.Ndis.DATA.SET_INFORMATION.InformationBufferLength = sizeof(PacketFilter);
        
            Request.AsyncStatus = NDIS_STATUS_PENDING;
            NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
        
            NdisStatus = WaitAsyncOperation(
                &Request.SyncEvent,
                &Request.AsyncStatus,
                NdisStatus);
        
    //      NdisStatus = SetNdisParameter(
    //          pAdapterContext,
    //          OID_GEN_CURRENT_PACKET_FILTER,
    //          &PacketFilter,
    //          sizeof(PacketFilter));
    
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - SetNdisParm PACKET_FILTER failure.\n")));
                ASSERT(FALSE);
                goto done;
            }
        }
    
        LlcMemCpy(
            pAdapterContext->Adapter.Node.auchAddress,
            pAdapterContext->NodeAddress,
            6);
    
        Request.Ndis.RequestType                                    = NdisRequestQueryInformation;
        Request.Ndis.DATA.QUERY_INFORMATION.Oid                     = OID_GEN_MAXIMUM_TOTAL_SIZE;
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer       = &pAdapterContext->MaxFrameSize;
        Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(pAdapterContext->MaxFrameSize);
    
        Request.AsyncStatus = NDIS_STATUS_PENDING;
        NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
    
        NdisStatus = WaitAsyncOperation(
            &Request.SyncEvent,
            &Request.AsyncStatus,
            NdisStatus);
    
    //  NdisStatus = GetNdisParameter(
    //      pAdapterContext,
    //      OID_GEN_MAXIMUM_TOTAL_SIZE,
    //      &pAdapterContext->MaxFrameSize,
    //      sizeof(pAdapterContext->MaxFrameSize));
    
        if (NdisStatus == STATUS_SUCCESS) 
        {
            Request.Ndis.RequestType                                    = NdisRequestQueryInformation;
            Request.Ndis.DATA.QUERY_INFORMATION.Oid                     = OID_GEN_LINK_SPEED;
            Request.Ndis.DATA.QUERY_INFORMATION.InformationBuffer       = &pAdapterContext->LinkSpeed;
            Request.Ndis.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(pAdapterContext->LinkSpeed);
        
            Request.AsyncStatus = NDIS_STATUS_PENDING;
            NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
        
            NdisStatus = WaitAsyncOperation(
                &Request.SyncEvent,
                &Request.AsyncStatus,
                NdisStatus);
        
    //      NdisStatus = GetNdisParameter(
    //          pAdapterContext,
    //          OID_GEN_LINK_SPEED,
    //          &pAdapterContext->LinkSpeed,
    //          sizeof(pAdapterContext->LinkSpeed));
        }
    
        if (NdisStatus != STATUS_SUCCESS) 
        {
            DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - GetNdisParm MAX_SIZE/LINK_SPEED failure.\n")));
            goto done;
        }
    
        //
        // RLF 04/12/93
        //
        // Here we used to load the LLC_TICKS array from TimerTicks - a global
        // array of timer tick values.
        // Instead, we get any per-adapter configuration information stored in
        // the registry
        //
    
        LoadAdapterConfiguration(
            &pAdapterContext->Name,
            &pAdapterContext->ConfigInfo);
    
    
        //
        // RLF 04/02/94
        //
        // if this is not a Token Ring card then check the MaxFrameSize retrieved
        // above. If the UseEthernetFrameSize parameter was set in the registry
        // then we use the smaller of the ethernet size (1514) and the value
        // reported by the MAC. If the parameter was not set then we just use
        // the value already retrieved. If the card is Token Ring then we use
        // the value already retrieved
        //
    
        if (pAdapterContext->NdisMedium != NdisMedium802_5   && 
            pAdapterContext->ConfigInfo.UseEthernetFrameSize && 
            pAdapterContext->MaxFrameSize > MAX_ETHERNET_FRAME_LENGTH) 
        {
            pAdapterContext->MaxFrameSize = MAX_ETHERNET_FRAME_LENGTH;
        }
        
        pAdapterContext->QueueI.pObject = (PVOID)GetI_Packet;
    
        InitializeListHead(&pAdapterContext->QueueI.ListHead);
    
        pAdapterContext->QueueDirAndU.pObject = (PVOID)BuildDirOrU_Packet;
    
        InitializeListHead(&pAdapterContext->QueueDirAndU.ListHead);
    
        pAdapterContext->QueueExpidited.pObject = (PVOID)GetLlcCommandPacket;
    
        InitializeListHead(&pAdapterContext->QueueExpidited.ListHead);
    
        pAdapterContext->OpenCompleteStatus = STATUS_SUCCESS;
    }
    else
    {
        //
        // Re-opening adapter. Don't really need to do much configuration.
        // Need to set packet filter.
        //

        // Still should be same medium for the adapter.
        ASSERT(pAdapterContext->NdisMedium == LlcMediumArray[MediumIndex]);
        
        {
            //
            // Mod RLF 07/10/92
            //
            // apparently, TR adapter does not support NDIS_PACKET_TYPE_MULTICAST
            // as a filter. Up to now, it seems to have been reasonably happy
            // with this type. However, we're not going to include it from now on
            //
    
            //
            // Mod RLF 01/13/93
            //
            // Similarly, Ethernet doesn't support FUNCTIONAL addresses (Token
            // Ring's functional address is equivalent to Ethernet's multicast
            // address)
            //
    
            ULONG PacketFilter = 
                NDIS_PACKET_TYPE_DIRECTED  | 
                NDIS_PACKET_TYPE_BROADCAST | 
                (((pAdapterContext->NdisMedium == NdisMedium802_3) || (pAdapterContext->NdisMedium == NdisMediumFddi))
                                  ? NDIS_PACKET_TYPE_MULTICAST
                                  : NDIS_PACKET_TYPE_FUNCTIONAL);
    
            //
            // EndMod
            //
    
            Request.Ndis.RequestType                                  = NdisRequestSetInformation;
            Request.Ndis.DATA.SET_INFORMATION.Oid                     = OID_GEN_CURRENT_PACKET_FILTER;
            Request.Ndis.DATA.SET_INFORMATION.InformationBuffer       = &PacketFilter;
            Request.Ndis.DATA.SET_INFORMATION.InformationBufferLength = sizeof(PacketFilter);
        
            Request.AsyncStatus = NDIS_STATUS_PENDING;
            NdisRequest(&NdisStatus, pAdapterContext->NdisBindingHandle, &Request.Ndis);
        
            NdisStatus = WaitAsyncOperation(
                &Request.SyncEvent,
                &Request.AsyncStatus,
                NdisStatus);
        
    //      NdisStatus = SetNdisParameter(
    //          pAdapterContext,
    //          OID_GEN_CURRENT_PACKET_FILTER,
    //          &PacketFilter,
    //          sizeof(PacketFilter));
    
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                DEBUGMSG(DBG_ERROR, (TEXT("OpenAdapter - SetNdisParm PACKET_FILTER failure.\n")));
                ASSERT(FALSE);
                goto done;
            }
        }
    
    }

    //
    // Adapter can now be used, so put state to bound. Sends and requests
    // will fail if the state is not BIND_STATE_BOUND.
    //

    BindState = InterlockedExchange(&pAdapterContext->BindState, BIND_STATE_BOUND);
    ASSERT(BindState == BIND_STATE_UNBOUND);

done:

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        if (pAdapterContext->NdisBindingHandle != NULL)
        {
            NDIS_STATUS CloseNdisStatus;

            pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;

            NdisCloseAdapter(
                &CloseNdisStatus,
                pAdapterContext->NdisBindingHandle);

            WaitAsyncOperation(
                &pAdapterContext->Event,
                &pAdapterContext->AsyncCloseResetStatus,
                CloseNdisStatus);

            pAdapterContext->NdisBindingHandle = NULL;
            
            REFDEL(&pAdapterContext->AdapterRefCnt, 'dniB');
        }
    }

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-OpenAdapter - Adapter %#x [%#x]\n"), 
        pAdapterContext, NdisStatus));
    
    return (NdisStatus);
}


VOID
CloseAdapter(
    PVOID pv_pAdapterContext
    )

/*++

 Routine Description:

    This function is called when the reference count on the NdisBindingHandle
    for the AdapterContext goes to zero. The CloseAdapterEvent is set to
    indicate to the unbind handler that all references to the adapter are 
    removed and it can complete the unbind/close adapter.

 Arguments:

    pv_pAdapterContext - Context describing open adapter.

 Return Value:

    None.

    
--*/

{
    PADAPTER_CONTEXT pAdapterContext = (PADAPTER_CONTEXT) pv_pAdapterContext;
    KeSetEvent(&pAdapterContext->CloseAdapterEvent, 0L, FALSE); 
}


VOID
LlcBindAdapterHandler(
    OUT PNDIS_STATUS  pStatus,
    IN  NDIS_HANDLE   BindContext,
    IN  PNDIS_STRING  pDeviceName,
    IN  PVOID         SystemSpecific1,
    IN  PVOID         SystemSpecific2
    )

/*++

 Routine Description:

    Protocol bind adapter handler. This is called by NDIS to bind
    to an adapter.

 Arguments:

    pStatus - The status to returned by this bind adapter call.

    BindContext - Handle used when indicating completion using
                  NdisCompleteBindAdapter.

    pDeviceName - Zero-terminated Unicode string  with the name of the
                  underlying NIC to bind to.

    SystemSpecific1 - Registry path used by NdisOpenProtocolConfiguration.

    SystemSpecific2 - Reserved.

 Return Value:

    None.

 Notes:

    Runs at IRQL_PASSIVE_LEVEL.
    
    This function creates an ADAPTER_CONTEXT, initializes it and opens the
    adapter. This adapter is stored in a global adapter list so that DLC
    can find and use the adapter context.

--*/
{
    PADAPTER_CONTEXT    pAdapterContext = NULL;
    NDIS_STATUS         NdisStatus      = NDIS_STATUS_SUCCESS;
    BOOLEAN             fNewAdapter     = FALSE;

    DEBUGMSG(DBG_NDIS_BIND,
        (TEXT("+LlcBindAdapterHandler(%#x, %#x, %#x, %#x %#x)\n"),
        pStatus, BindContext, pDeviceName, 
        SystemSpecific1, SystemSpecific2));
    
    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    //
    // Check for re-bind case.
    //

    for (pAdapterContext = pAdapters; 
         pAdapterContext != NULL; 
         pAdapterContext = pAdapterContext->pNext)
    {
        if (UnicodeStringCompare(pDeviceName, &pAdapterContext->Name))
        {
            // Found the adapter.
            break;
        }
    }

    if (pAdapterContext == NULL)
    {
        pAdapterContext = AllocateAdapterContext(pDeviceName);

        if (pAdapterContext == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            goto done;
        }

        fNewAdapter = TRUE;
    }
    else
    {
        // 
        // ADAPTER_CONTEXT already exists. This must be the re-bind scenario.
        //

        ASSERT(pAdapterContext->BindState == BIND_STATE_UNBOUND);
    }

    //
    // Open the NDIS adapter. OpenAdapter should not return pending.
    //

    NdisStatus = OpenAdapter(pAdapterContext, fNewAdapter);
    ASSERT(NdisStatus != NDIS_STATUS_PENDING);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (TEXT("LlcBindAdapterHandler - OpenAdapter failure.\n")));
        goto done;
    }

    //
    // If we just created this adapter context, then put in global adapter
    // list.
    //

    if (fNewAdapter == TRUE)
    {
        pAdapterContext->pNext = pAdapters;
        pAdapters              = pAdapterContext;
    }
                    
done:

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);
    
    // All above requests were serialized.
    ASSERT(NdisStatus != NDIS_STATUS_PENDING);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        if (pAdapterContext && fNewAdapter == TRUE)
        {
            ASSERT(pAdapterContext->pNext == NULL);
            FreeAdapterContext(pAdapterContext);
        }
    }

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-LlcBindAdapter [%#x]\n"), NdisStatus));
    
    *pStatus = NdisStatus;
    return;
}


VOID
LlcUnbindAdapterHandler(
    OUT PNDIS_STATUS pStatus,
    IN  NDIS_HANDLE  ProtocolBindingContext,
    IN  NDIS_HANDLE  UnbindContext
    )

/*++

 Routine Description:

    This is called by NDIS to unbind an adapter.

 Arguments:

    pStatus - The status to be returned by this unbind adapter call.

    ProtocolBindingContext - Protocol allocated binding context to the adapter
                             to unbind to.

    UnbindContext - Handle used when indicating completion using
                    NdisCompleteUnbindAdapter.

 Return Value:

    None.

 Notes:

    Runs at IRQL_PASSIVE_LEVEL.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = (PADAPTER_CONTEXT) ProtocolBindingContext;
    LONG             BindState;
    NDIS_STATUS      NdisStatus;

    DEBUGMSG(DBG_NDIS_BIND,
        (TEXT("+LlcUnbindAdapterHandler(%#x, %#x, %#x)\n"), 
        pStatus, ProtocolBindingContext, UnbindContext));
    
    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    //
    // Update bind state.
    // 

    BindState = InterlockedExchange(
        &pAdapterContext->BindState,
        BIND_STATE_UNBINDING);

    ASSERT(BindState == BIND_STATE_BOUND);

    //
    // Remove the reference count that NDIS has on the adapter handle since we 
    // will close the adapter.
    //

    KeResetEvent(&pAdapterContext->CloseAdapterEvent);
    REFDEL(&pAdapterContext->AdapterRefCnt, 'dniB');

    //
    // Wait until the reference goes to zero, then we are signalled. The above
    // REFDEL would have signalled the event if this is the last reference.
    //

    KeWaitForSingleObject(
        &pAdapterContext->CloseAdapterEvent,
        Executive,
        KernelMode,
        FALSE,
        NULL);
    
    //
    // Now we can safely close the NdisBindingHandle.
    //

    pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;
    ASSERT(pAdapterContext->NdisBindingHandle);

    NdisCloseAdapter(
        &NdisStatus,
        pAdapterContext->NdisBindingHandle);

    NdisStatus = WaitAsyncOperation(
        &pAdapterContext->Event,
        &(pAdapterContext->AsyncCloseResetStatus),
        NdisStatus);

    ASSERT(NdisStatus != NDIS_STATUS_PENDING);
    pAdapterContext->NdisBindingHandle = NULL;

    //
    // Update state.
    //

    BindState = InterlockedExchange(
        &pAdapterContext->BindState, 
        BIND_STATE_UNBOUND);

    ASSERT(BindState == BIND_STATE_UNBINDING);

    //
    // Clean up and save status before completing.
    //

    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

    *pStatus = NdisStatus;

    DEBUGMSG(DBG_NDIS_BIND, (TEXT("-LlcUnbindAdapterHandler [%#x]\n"), NdisStatus));
    
    return;
}


NDIS_STATUS
LlcPnPEventHandler(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNET_PNP_EVENT          pNetPnPEvent
    )

/*++

 Routine Description:

    PnP events indicated to the protocol. Currently, we are only interested
    in the binds complete event.

 Arguments:

    ProtocolBindingContext - Protocol allocated binding context to the adapter.
                             This can be NULL for some events.

    pNetPnPEvent - Describes PnP event.

 Return Value:

    NDIS_STATUS_SUCCESS     - Always return success, even for those PnP events
                              which are not supported.

--*/

{
    switch (pNetPnPEvent->NetEvent)
    {
        case NetEventBindsComplete:

            //
            // Block all LlcOpenAdapter requests until we are sure all adapters
            // have been indicated to the protocol.
            //

            NdisSetEvent(&PnPBindsComplete);
            break;
    }

    return (NDIS_STATUS_SUCCESS);
}


VOID
CloseAllAdapters(
    )

/*++

 Routine Description:
       
    Closes all adapters. This should only be called from the unload 
    routine.

 Arguments:
 
    None.

 Return Value:
 
    None.

--*/

{

    PADAPTER_CONTEXT pAdapterContext;
    PADAPTER_CONTEXT pNextAdapter;
    LONG             BindState;
    NDIS_STATUS      NdisStatus;

    DEBUGMSG(DBG_NDIS_OPEN, (TEXT("+CloseAllAdapters()\n")));

    KeWaitForSingleObject((PVOID)&OpenAdapterSemaphore,
                          Executive,
                          KernelMode,
                          FALSE,        // not alertable
                          NULL          // wait until object is signalled
                          );

    pAdapterContext = pAdapters;
    
    while (pAdapterContext)
    {
        // Save next adapter since we are going to free memory.
        pNextAdapter = pAdapterContext->pNext;

        //
        // Update bind state.
        // 
    
        BindState = InterlockedExchange(
            &pAdapterContext->BindState,
            BIND_STATE_UNBINDING);
    
        if (BindState == BIND_STATE_BOUND)
        {
            //
            // Poll to see if any objects are still attached to adapter.
            //
    
            DEBUGMSG(DBG_WARN && pAdapterContext,
                (TEXT("CloseAllAdapters - waiting for adapter LLC objects to close...\n")));
            
            while (pAdapterContext->ObjectCount)
            {
                DEBUGMSG(DBG_WARN && DBG_VERBOSE,
                    (TEXT("CloseAllAdapters - still waiting...\n")));
                
                LlcSleep(1000L); // 1ms
            }
    
            //
            // Remove the reference count that NDIS has on the adapter handle since we 
            // will close the adapter.
            //
        
            KeResetEvent(&pAdapterContext->CloseAdapterEvent);
            REFDEL(&pAdapterContext->AdapterRefCnt, 'dniB');
        
            //
            // Wait until the reference goes to zero, then we are signalled. The above
            // REFDEL would have signalled the event if this is the last reference.
            //
        
            KeWaitForSingleObject(
                &pAdapterContext->CloseAdapterEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
            
            //
            // Now we can safely close the NdisBindingHandle.
            //
        
            pAdapterContext->AsyncCloseResetStatus = NDIS_STATUS_PENDING;
            ASSERT(pAdapterContext->NdisBindingHandle);
        
            NdisCloseAdapter(
                &NdisStatus,
                pAdapterContext->NdisBindingHandle);
        
            NdisStatus = WaitAsyncOperation(
                &pAdapterContext->Event,
                &(pAdapterContext->AsyncCloseResetStatus),
                NdisStatus);
        
            ASSERT(NdisStatus != NDIS_STATUS_PENDING);
            pAdapterContext->NdisBindingHandle = NULL;
        
            //
            // Update state.
            //
        
            BindState = InterlockedExchange(
                &pAdapterContext->BindState, 
                BIND_STATE_UNBOUND);
        
            ASSERT(BindState == BIND_STATE_UNBINDING);
        }

        // Remove adapter from the list.
        RemoveFromLinkList((PVOID *)&pAdapters, pAdapterContext);

        FreeAdapterContext(pAdapterContext);

        // Adjust pointer.
        pAdapterContext = pNextAdapter;
    }
    
    KeReleaseSemaphore(&OpenAdapterSemaphore, 0, 1, FALSE);

    DEBUGMSG(DBG_NDIS_OPEN, (TEXT("-CloseAllAdapters\n")));
    
    return;
}

#endif // NDIS40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcobj.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems Ab

Module Name:

    llcobj.c

Abstract:

    The module implements the open and close primitives
    for all data link driver objects.

    Contents:
        LlcOpenStation
        LlcCloseStation
        CompleteClose
        CancelTransmitCommands
        CancelTransmitsInQueue
        LlcSetDirectOpenOptions
        CompleteObjectDelete
        CompletePendingLlcCommand
        LlcDereferenceObject
        LlcReferenceObject
        LlcGetReceivedLanHeaderLength
        LlcGetEthernetType
        LlcGetCommittedSpace

Author:

    Antti Saarenheimo (o-anttis) 29-MAY-1991

Revision History:

--*/

#if DBG
#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif
#include "dlc.h"    // need DLC_FILE_CONTEXT for memory charged to file handle
#endif

#include <llc.h>

static USHORT ObjectSizes[] = {
    sizeof(LLC_STATION_OBJECT), // direct station
    sizeof(LLC_SAP ),           // SAP station
    sizeof(LLC_STATION_OBJECT), // group SAP
    (USHORT)(-1),               // link station
    sizeof(LLC_STATION_OBJECT)  // DIX station
};


DLC_STATUS
LlcOpenStation(
    IN PBINDING_CONTEXT pBindingContext,
    IN PVOID hClientHandle,
    IN USHORT ObjectAddress,
    IN UCHAR ObjectType,
    IN USHORT OpenOptions,
    OUT PVOID* phStation
    )

/*++

Routine Description:

    The primitive opens a LLC SAP exclusively for the upper protocol
    driver. The upper protocol must provide the storage for the
    SAP object. The correct size of the object has been defined in the
    characteristics table of the LLC driver.

    The first call to a new adapter initializes also the NDIS interface
    and allocates internal data structures for the new adapter.

Arguments:

    pBindingContext - binding context of the llc client
    hClientHandle   - The client protocol gets this handle in all indications
                      of the SAP
    ObjectAddress   - LLC SAP number or dix
    ObjectType      - type of the created object
    OpenOptions     - various open options set for the new object
    phStation       - returned opaque handle

Special:  Must be called IRQL < DPC (at least when direct station opened)

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                  DLC_STATUS_INVALID_SAP_VALUE
                  DLC_STATUS_INVALID_OPTION
                  DLC_STATUS_INVALID_STATION_ID

--*/

{
    PADAPTER_CONTEXT pAdapterContext;
    PLLC_OBJECT pStation;
    DLC_STATUS LlcStatus = STATUS_SUCCESS;
    PVOID* ppListBase;
    ULONG PacketFilter;

#if DBG
    PDLC_FILE_CONTEXT pFileContext = (PDLC_FILE_CONTEXT)(pBindingContext->hClientContext);
#endif

    pAdapterContext = pBindingContext->pAdapterContext;

    //
    // Allocate and initialize the SAP, but do not yet connect
    // it to the adapter
    //

    ASSERT(ObjectSizes[ObjectType] != (USHORT)(-1));

    pStation = (PLLC_OBJECT)ALLOCATE_ZEROMEMORY_FILE(ObjectSizes[ObjectType]);

    if (pStation == NULL) {
        return DLC_STATUS_NO_MEMORY;
    }
    if (ObjectType == LLC_SAP_OBJECT && (ObjectAddress & 1)) {
        ObjectType = LLC_GROUP_SAP_OBJECT;
        ASSERT(phStation);
    }

    pStation->Gen.hClientHandle = hClientHandle;
    pStation->Gen.pLlcBinding = pBindingContext;
    pStation->Gen.pAdapterContext = pAdapterContext;
    pStation->Gen.ObjectType = (UCHAR)ObjectType;

    //
    // The LLC objects must be referenced whenever they should be kept alive
    // over a long operation, that opens the spin locks (especially async
    // operations)
    // The first reference is for open/close
    //

    ReferenceObject(pStation);

    //
    // These values are common for SAP, direct (and DIX objects)
    //

    pStation->Sap.OpenOptions = OpenOptions;
    pStation->Dix.ObjectAddress = ObjectAddress;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    switch (pStation->Gen.ObjectType) {
    case LLC_SAP_OBJECT:

        //
        // RLF 05/13/93
        //
        // don't allow multiple applications to open the same SAP. This is
        // incompatible with OS/2 DLC
        //

        if (pAdapterContext->apSapBindings[ObjectAddress] == NULL) {
            ppListBase = (PVOID*)&(pAdapterContext->apSapBindings[ObjectAddress]);
            LlcMemCpy(&pStation->Sap.DefaultParameters,
                      &DefaultParameters,
                      sizeof(DefaultParameters)
                      );

            ALLOCATE_SPIN_LOCK(&pStation->Sap.FlowControlLock);

        } else {

            FREE_MEMORY_FILE(pStation);

            RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

            return DLC_STATUS_INVALID_SAP_VALUE;
        }
        break;

    case LLC_GROUP_SAP_OBJECT:
        ppListBase = (PVOID*)&(pAdapterContext->apSapBindings[ObjectAddress]);

        //
        // All members of the same group/individual SAP muust have set
        // the same XID handling option
        //

        if (pAdapterContext->apSapBindings[ObjectAddress] != NULL) {
            if ((OpenOptions & LLC_EXCLUSIVE_ACCESS)
            || (pAdapterContext->apSapBindings[ObjectAddress]->OpenOptions
                  & LLC_EXCLUSIVE_ACCESS)) {
                LlcStatus = DLC_STATUS_INVALID_SAP_VALUE;
            } else if ((pAdapterContext->apSapBindings[ObjectAddress]->OpenOptions &
                  LLC_HANDLE_XID_COMMANDS) != (OpenOptions & LLC_HANDLE_XID_COMMANDS)) {
                LlcStatus = DLC_STATUS_INVALID_OPTION;
            }
        }

        ALLOCATE_SPIN_LOCK(&pStation->Sap.FlowControlLock);

        break;

    case LLC_DIRECT_OBJECT:
        ppListBase = (PVOID*)&pAdapterContext->pDirectStation;
        break;

    case LLC_DIX_OBJECT:
        if (pAdapterContext->NdisMedium != NdisMedium802_3) {
            LlcStatus = DLC_STATUS_INVALID_STATION_ID;
        } else {
            ppListBase = (PVOID*)&(pAdapterContext->aDixStations[ObjectAddress % MAX_DIX_TABLE]);
        }
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif
    }

    if (LlcStatus == STATUS_SUCCESS) {
        pStation->Gen.pNext = *ppListBase;
        *phStation = *ppListBase = pStation;

        pAdapterContext->ObjectCount++;
    } else {

        FREE_MEMORY_FILE(pStation);

    }

    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    if (LlcStatus == STATUS_SUCCESS
    && pStation->Gen.ObjectType == LLC_DIRECT_OBJECT
    && OpenOptions & DLC_RCV_MAC_FRAMES
    && !(pAdapterContext->OpenOptions & DLC_RCV_MAC_FRAMES)) {

        //
        // We enable the MAC frames, if they have once been enabled,
        // but they will never be disabled again.  The receiving
        // of MAC frames is quite exceptional case, and it is
        // not really worth of it to maintain local and global
        // Ndis flag states just because of it
        //

        PacketFilter = NDIS_PACKET_TYPE_DIRECTED
                     | NDIS_PACKET_TYPE_MULTICAST
                     | NDIS_PACKET_TYPE_FUNCTIONAL
                     | NDIS_PACKET_TYPE_MAC_FRAME;

        pAdapterContext->OpenOptions |= DLC_RCV_MAC_FRAMES;
        LlcStatus = SetNdisParameter(pAdapterContext,
                                     OID_GEN_CURRENT_PACKET_FILTER,
                                     &PacketFilter,
                                     sizeof(PacketFilter)
                                     );
    }
    return LlcStatus;
}


DLC_STATUS
LlcCloseStation(
    IN PLLC_OBJECT pStation,
    IN PLLC_PACKET pCompletionPacket
    )

/*++

Routine Description:

    The primitive closes a direct, sap or link station object.
    All pending transmit commands are terminated.
    This primitive does not support graceful termination, but
    the upper level must wait the pending transmit commands, if
    it want to make a clean close (without deleting the transmit queue).

    For a link station this  primitive releases a disconnected link
    station or discards a remote connection request.

Arguments:

    pStation            - handle of a link, sap or direct station
    pCompletionPacket   - returned context, when the command is complete

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_INVALID_PARAMETERS
                    the SAP has still active link stations. All active link
                    stations must be closed before sap can be closed.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;
    PBINDING_CONTEXT pOldBinding;
    PDATA_LINK* ppLink;
    PVOID* ppLinkListBase;
    PEVENT_PACKET pEvent;

    if (pStation->Gen.ObjectType == LLC_LINK_OBJECT) {

        //
        // The remote connection requests are routed through all
        // SAP station reqistered on a SAP until someone accepts
        // the connection request or it has been routed to all
        // clients having opened the sap station.
        //

        if (pStation->Link.Flags & DLC_ACTIVE_REMOTE_CONNECT_REQUEST) {

            ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

            pOldBinding = pStation->Gen.pLlcBinding;
            if (pStation->Link.pSap->Gen.pNext != NULL) {
                pStation->Gen.pLlcBinding = pStation->Link.pSap->Gen.pNext->Gen.pLlcBinding;
            }

            RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

            //
            // Complete the close command immediately, if
            // the connect request was redirected to another
            // SAP station
            //

            if (pStation->Gen.pLlcBinding != pOldBinding) {

                ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                pEvent = ALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool);

                if (pEvent != NULL) {
                    LlcInsertTailList(&pAdapterContext->QueueEvents, pEvent);
                    pEvent->pBinding = pStation->Gen.pLlcBinding;
                    pEvent->hClientHandle = pStation->Link.pSap->Gen.hClientHandle;
                    pEvent->Event = LLC_STATUS_CHANGE_ON_SAP;
                    pEvent->pEventInformation = &pStation->Link.DlcStatus;
                    pEvent->SecondaryInfo = INDICATE_CONNECT_REQUEST;
                }

                RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

                if (pEvent != NULL) {
                    return STATUS_SUCCESS;
                }
            } else {

                //
                // Nobody accepted this connect request, we must discard it.
                //

                RunInterlockedStateMachineCommand((PDATA_LINK)pStation, SET_ADM);
            }
        }
    }
    ACQUIRE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);
    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    DLC_TRACE('C');

    switch (pStation->Gen.ObjectType) {
    case LLC_DIRECT_OBJECT:

        //
        // This Direct must be in the linked list of Directs (having
        // the same source Direct).
        //

        ppLinkListBase = (PVOID*)&pAdapterContext->pDirectStation;

        DLC_TRACE('b');
        break;

    case LLC_DIX_OBJECT:

        //
        // This Direct must be in the linked list of Directs (having
        // the same source Direct).
        //

        ppLinkListBase = (PVOID*)&pAdapterContext->aDixStations[pStation->Dix.ObjectAddress % MAX_DIX_TABLE];
        DLC_TRACE('a');
        break;

    case LLC_SAP_OBJECT:

#if LLC_DBG
        if (pStation->Sap.pActiveLinks != NULL) {
            DbgPrint("Closing SAP before link stations!!!\n");
            DbgBreakPoint();

            //
            // Open the spin locks and return thge error status
            //

            RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
            RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

            return DLC_STATUS_LINK_STATIONS_OPEN;
        }
#endif

        DLC_TRACE('d');

    case LLC_GROUP_SAP_OBJECT:

        //
        // This SAP must be in the linked list of SAPs (having
        // the same source SAP).
        //

        ppLinkListBase = (PVOID*)&pAdapterContext->apSapBindings[pStation->Sap.SourceSap];

        DEALLOCATE_SPIN_LOCK(&pStation->Sap.FlowControlLock);

        break;

    case LLC_LINK_OBJECT:

        //
        // Only a disconnected link station can be deactivated.
        // If this fails, then we must disconnect the link station,
        // if it is not already disconnected.
        //

        if (RunStateMachineCommand((PDATA_LINK)pStation, DEACTIVATE_LS) != STATUS_SUCCESS
        && pStation->Link.State != DISCONNECTING) {

            //
            // We must disconnect the link station immediately.
            // We don't care if we are at the moment in
            // a checkpoint state, that would delay the disconnection
            // until the other side has acknowledged it.
            // The link station must be killed now!
            //

            SendLlcFrame((PDATA_LINK)pStation, DLC_DISC_TOKEN | 1);
            DisableSendProcess((PDATA_LINK)pStation);
        }
        pStation->Link.State = LINK_CLOSED;
        ppLinkListBase = (PVOID *)&pStation->Link.pSap->pActiveLinks;
        ppLink =  SearchLinkAddress(pAdapterContext, pStation->Link.LinkAddr);
        *ppLink = pStation->Link.pNextNode;

        TerminateTimer(pAdapterContext, &pStation->Link.T1);
        TerminateTimer(pAdapterContext, &pStation->Link.T2);
        TerminateTimer(pAdapterContext, &pStation->Link.Ti);
        DLC_TRACE('c');
        break;

#if LLC_DBG
    default:
        LlcInvalidObjectType();
        break;
#endif
    }
    RemoveFromLinkList(ppLinkListBase, pStation);

    //
    // Queue the asynchronous close command. Group sap and
    // disabling of non-existing link station may use
    // a null packet, because those commands are executed
    // synchronously (they cannot have pending packets)
    //

    if (pCompletionPacket != NULL) {
        AllocateCompletionPacket(pStation, LLC_CLOSE_COMPLETION, pCompletionPacket);
    }

    //
    // OK. Everything has been processed =>
    // now we can decrement the object counter.
    //

    RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
    RELEASE_SPIN_LOCK(&pAdapterContext->ObjectDataBase);

    //
    // Delete the object NOW, if this was the last reference to it
    //

    LlcDereferenceObject(pStation);

    return STATUS_PENDING;
}


VOID
CompleteClose(
    IN PLLC_OBJECT pLlcObject,
    IN UINT CancelStatus
    )

/*++

Routine Description:

    Procedure cancel all pending commands of llc object and
    deletes the object.
    The procedure returns a pending status as far the object
    has pending  transmits in NDIS.

Arguments:

    pLlcObject      - LLC object
    CancelStatus    - the status returned in the cancelled (completed) commands

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pLlcObject->Gen.pAdapterContext;
    UINT Status;

#if DBG
    PDLC_FILE_CONTEXT pFileContext = (PDLC_FILE_CONTEXT)(pLlcObject->Gen.pLlcBinding->hClientContext);
#endif

    if (pLlcObject->Gen.ReferenceCount != 0) {
        return;
    }

    //
    // Cancel the queue transmit commands
    //

    CancelTransmitCommands(pLlcObject, CancelStatus);

    //
    // Queue also all commands queued in the link stations
    // (actually only LlcConnect and LlcDisconnect),
    // Note: the queue command eats the list of completion packets.
    //

    while (pLlcObject->Gen.pCompletionPackets != NULL) {
        Status = CancelStatus;
        if (pLlcObject->Gen.pCompletionPackets->Data.Completion.CompletedCommand == LLC_CLOSE_COMPLETION) {
            Status = STATUS_SUCCESS;
        }
        QueueCommandCompletion(pLlcObject,
                               (UINT)pLlcObject->Gen.pCompletionPackets->Data.Completion.CompletedCommand,
                               Status
                               );
    }

    //
    // release link station specific resources
    //

    if (pLlcObject->Gen.ObjectType == LLC_LINK_OBJECT) {

        //
        // The link may have been closed because of an error
        // or timeout (eg. somebody has turned the power off in the
        // other side). We must complete all pending transmits with
        // an error. We assume, that the link has not any more
        // any packets in NDIS queues, but is does not matter,
        // because NDIS packets of a link station will never be
        // directly indicated to the user (they may not exist any
        // more). Thus nothing fatal can happen, if we simply
        // complete all packets and return them to the main
        // packet storage.
        //

        DEALLOCATE_PACKET_LLC_LNK(pAdapterContext->hLinkPool, pLlcObject);

    } else {

        FREE_MEMORY_FILE(pLlcObject);

    }
    pAdapterContext->ObjectCount--;
}


VOID
CancelTransmitCommands(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status
    )

/*++

Routine Description:

    Procedure removes the transmit commands of the given LLC client
    from the transmit queue.  This cannot cancel those dir/sap transmit
    already queued in NDIS, but the caller must first wait that the
    object has no commands in the NDIS queue.

Arguments:

    pLlcObject  - LLC object
    Status      - status to set in cancelled transmit commands

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pLlcObject->Gen.pAdapterContext;

    //
    // We can (and must) cancel all pending transmits on a link
    // without any global locks, when the station has first
    // been removed from all global data structures,
    //

    if (pLlcObject->Gen.ObjectType == LLC_LINK_OBJECT) {
        CancelTransmitsInQueue(pLlcObject,
                               Status,
                               &((PDATA_LINK)pLlcObject)->SendQueue.ListHead,
                               NULL
                               );
        CancelTransmitsInQueue(pLlcObject,
                               Status,
                               &((PDATA_LINK)pLlcObject)->SentQueue,
                               NULL
                               );
        StopSendProcess(pAdapterContext, (PDATA_LINK)pLlcObject);

        //
        // We cannot leave any S- commands with a reference to the
        // link lan header.
        //

        CancelTransmitsInQueue(pLlcObject,
                               Status,
                               &pAdapterContext->QueueExpidited.ListHead,
                               &pAdapterContext->QueueExpidited
                               );
    } else {
        CancelTransmitsInQueue(pLlcObject,
                               Status,
                               &pAdapterContext->QueueDirAndU.ListHead,
                               &pAdapterContext->QueueDirAndU
                               );
    }
}


VOID
CancelTransmitsInQueue(
    IN PLLC_OBJECT pLlcObject,
    IN UINT Status,
    IN PLIST_ENTRY pQueue,
    IN PLLC_QUEUE pLlcQueue OPTIONAL
    )

/*++

Routine Description:

    Procedure removes the transmit commands of the given LLC client
    from the transmit queue.  This cannot cancel those dir/sap transmit
    already queued in NDIS, but the caller must first wait that the
    object has no commands in the NDIS queue.

Arguments:

    pLlcObject  - LLC object
    Status      - the status returned by the completed transmit commands
    pQueue      - a data links transmit queue
    pLlcQueue   - an optional LLC queue, that is disconnected from the send
                  task if the subqueue becomes empty.

Return Value:

    None.

--*/

{
    PLLC_PACKET pPacket;
    PLLC_PACKET pNextPacket;
    PADAPTER_CONTEXT pAdapterContext = pLlcObject->Gen.pAdapterContext;

    //
    // Cancel all pending transmit commands in LLC queues,
    // check first, if the transmit queue is empty.
    //

    if (IsListEmpty(pQueue)) {
        return;
    }

    for (pPacket = (PLLC_PACKET)pQueue->Flink; pPacket != (PLLC_PACKET)pQueue; pPacket = pNextPacket) {
        pNextPacket = pPacket->pNext;

        //
        // Complete the packet only if it has a correct binding handle
        // and it belongs the given client object.  Note: if binding
        // handle is null, then client object handle may be garbage!
        //

        if (pPacket->CompletionType > LLC_MAX_RESPONSE_PACKET
        && pPacket->Data.Xmit.pLlcObject == pLlcObject) {
            LlcRemoveEntryList(pPacket);

            //
            // We MUST NOT cancel those transmit commands, that are
            // still in the NDIS queue!!!!  The command completion would
            // make the MDLs in NDIS packet invalid => system would crash.
            //

            if (((pPacket->CompletionType) & LLC_I_PACKET_PENDING_NDIS) == 0) {
                if (pPacket->pBinding != NULL) {
                    LlcInsertTailList(&pAdapterContext->QueueCommands, pPacket);
                    pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
                    pPacket->Data.Completion.Status = Status;
                    pPacket->Data.Completion.hClientHandle = pLlcObject->Gen.hClientHandle;
                } else {

                    DEALLOCATE_PACKET_LLC_PKT(pAdapterContext->hPacketPool, pPacket);

                }
            } else {

                //
                // The I-frames must be discarded by the link protocol, because
                // the link is now dead, and we will complete them immediately
                // when NdisSend the completes.
                //

                pPacket->CompletionType &= ~LLC_I_PACKET_UNACKNOWLEDGED;
                pPacket->Data.Completion.CompletedCommand = LLC_SEND_COMPLETION;
                pPacket->Data.Completion.Status = Status;
                pPacket->Data.Completion.hClientHandle = pLlcObject->Gen.hClientHandle;
            }
        }
    }

    //
    // Disconnect the list from the send task, if is now empty,
    // We don't use this check with the I- frame queues
    // (StopSendProcess does the same thing for them).
    //

    if (pLlcQueue != NULL
    && IsListEmpty(&pLlcQueue->ListHead)
    && pLlcQueue->ListEntry.Flink != NULL) {
        LlcRemoveEntryList(&pLlcQueue->ListEntry);
        pLlcQueue->ListEntry.Flink = NULL;
    }
}


//
//  Procedure sets new open options (receive mask) for a direct station.
//  The MAC frames must have been enabled, when the direct
//  object was opened on data link.
//  This is called whenever DLC receive command is issued for direct station.
//
VOID
LlcSetDirectOpenOptions(
    IN PLLC_OBJECT pDirect,
    IN USHORT OpenOptions
    )
{
    pDirect->Dir.OpenOptions = OpenOptions;
}


VOID
CompleteObjectDelete(
    IN PLLC_OBJECT pStation
    )

/*++

Routine Description:

    The function completes the delete operation for a llc object.

Arguments:

    pStation - link, sap or direct station handle

Return Value:

    None.

--*/

{
    PADAPTER_CONTEXT pAdapterContext = pStation->Gen.pAdapterContext;

    ACQUIRE_SPIN_LOCK(&pAdapterContext->SendSpinLock);

    if (pStation->Gen.ReferenceCount == 0) {
        CompletePendingLlcCommand(pStation);
        BackgroundProcessAndUnlock(pAdapterContext);
    } else {
        RELEASE_SPIN_LOCK(&pAdapterContext->SendSpinLock);
    }
}


VOID
CompletePendingLlcCommand(
    PLLC_OBJECT pLlcObject
    )

/*++

Routine Description:

    The routines cleans up all commands and event of a llc object
    from the the data link driver.

Arguments:

    pLlObject   - a data link object handle (opeque pointer)

Return Value:

    None.

--*/

{
    //
    // The reference count is zero only if the object is deleted,
    // otherwise this is just a reset for a link station.
    //

    if (pLlcObject->Gen.ReferenceCount == 0) {
        CompleteClose(pLlcObject, DLC_STATUS_CANCELLED_BY_SYSTEM_ACTION);
    } else {
        CancelTransmitCommands(pLlcObject, DLC_STATUS_LINK_NOT_TRANSMITTING);
    }
}


VOID
LlcDereferenceObject(
    IN PVOID pStation
    )

/*++

Routine Description:

    The function dereferences any LLC object.
    THIS ROUTINE MUST BE CALLED ALL SPIN LOCKS UNLOCKED,
    BECAUSE IT MAY CALL BACK !!!!

Arguments:

    pStation - link, sap or direct station handle

Return Value:

    None.

--*/

{
    DLC_TRACE('L');
    DLC_TRACE((UCHAR)((PLLC_OBJECT)pStation)->Gen.ReferenceCount - 1);

    if (InterlockedDecrement((PLONG)&(((PLLC_OBJECT)(pStation))->Gen.ReferenceCount)) == 0) {
        CompleteObjectDelete(pStation);
    }

    /* pStation might have been freed by now
    DLC_TRACE('L');
    DLC_TRACE((UCHAR)((PLLC_OBJECT)pStation)->Gen.ReferenceCount); */
}


VOID
LlcReferenceObject(
    IN PVOID pStation
    )

/*++

Routine Description:

    The function references any LLC object.  The non-zero
    reference counter keeps LLC objects alive.

Arguments:

    pStation - link, sap or direct station handle

Return Value:

    None.

--*/

{
    InterlockedIncrement((PLONG)&(((PLLC_OBJECT)pStation)->Gen.ReferenceCount));
    DLC_TRACE('M');
    DLC_TRACE((UCHAR)((PLLC_OBJECT)pStation)->Gen.ReferenceCount);
}


#if !DLC_AND_LLC

//
// the following routines can be used as macros if DLC and LLC live in the same
// driver and the one knows about the other's structures
//

UINT
LlcGetReceivedLanHeaderLength(
    IN PVOID pBinding
    )

/*++

Routine Description:

    Returns the length of the LAN header of the frame last received from NDIS.
    The size is 14 for all Ethernet types except direct Ethernet frames, and
    whatever we stored in the RcvLanHeaderLength field of the ADAPTER_CONTEXT
    for Token Ring (can contain source routing)

Arguments:

    pBinding    - pointer to BINDING_CONTEXT structure describing adapter
                  on which frame of interest was received

Return Value:

    UINT

--*/

{
    return (((PBINDING_CONTEXT)pBinding)->pAdapterContext->NdisMedium == NdisMedium802_3)
        ? (((PBINDING_CONTEXT)pBinding)->pAdapterContext->FrameType == LLC_DIRECT_ETHERNET_TYPE)
            ? 12
            : 14
        : ((PBINDING_CONTEXT)pBinding)->pAdapterContext->RcvLanHeaderLength;
}


USHORT
LlcGetEthernetType(
    IN PVOID hContext
    )

/*++

Routine Description:

    Returns the Ethernet type set in the adapter context

Arguments:

    hContext    - handle of/pointer to BINDING_CONTEXT structure

Return Value:

    USHORT

--*/

{
    return ((PBINDING_CONTEXT)hContext)->pAdapterContext->EthernetType;
}


UINT
LlcGetCommittedSpace(
    IN PVOID hLink
    )

/*++

Routine Description:

    Returns the amount of committed buffer space

Arguments:

    hLink   -

Return Value:

    UINT

--*/

{
    return ((PDATA_LINK)hLink)->BufferCommitment;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llclib.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llclib.c

Abstract:

    This module includes some general purpose library routines

    Contents:
        SwapMemCpy
        RemoveFromLinkList
        LlcSleep
        LlcInitUnicodeString
        LlcFreeUnicodeString

Author:

    Antti Saarenheimo (o-anttis) 20-MAY-1991

Revision History:

--*/

#include <llc.h>
#include <memory.h>

//
// This table is used to swap the bits within each byte.
// The bits are in a reverse order in the token-ring frame header.
// We must swap the bits in a ethernet frame header, when the header
// is copied to a user buffer.
//

UCHAR Swap[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
};


VOID
SwapMemCpy(
    IN BOOLEAN boolSwapBytes,
    IN PUCHAR pDest,
    IN PUCHAR pSrc,
    IN UINT Len
    )

/*++

Routine Description:

    conditionally swaps the bits within the copied bytes.

Arguments:

    boolSwapBytes   - TRUE if bytes are to be bit-swapped
    pDest           - where to copy to
    pSrc            - where to copy from
    Len             - number of bytes to copy

Return Value:

    None.

--*/

{
    if (boolSwapBytes) {
        SwappingMemCpy(pDest, pSrc, Len);
    } else {
        LlcMemCpy(pDest, pSrc, Len);
    }
}


VOID
RemoveFromLinkList(
    IN OUT PVOID* ppBase,
    IN PVOID pElement
    )

/*++

Routine Description:

    Searches and removes the given element from a single-entry link list.

    ASSUMES: the link points to the link field in the next object

Arguments:

    ppBase      - pointer to pointer to queue
    pElement    - pointer to element to remove from queue

Return Value:

    None.

--*/

{
    for (; (PQUEUE_PACKET)*ppBase; ppBase = (PVOID*)&(((PQUEUE_PACKET)*ppBase)->pNext)) {
        if (*ppBase == pElement) {
            *ppBase = ((PQUEUE_PACKET)pElement)->pNext;

#if LLC_DBG
            ((PQUEUE_PACKET)pElement)->pNext = NULL;
#endif

            break;
        }
    }
}


VOID
LlcSleep(
    IN LONG lMicroSeconds
    )

/*++

Routine Description:

    Suspends thread execution for a short time

Arguments:

    lMicroSeconds   - number of microseconds to wait

Return Value:

    None.

--*/

{
    TIME t;

    t.LowTime = -(lMicroSeconds * 10);
    t.HighTime = -1;
    KeDelayExecutionThread(UserMode, FALSE, &t);
}


DLC_STATUS
LlcInitUnicodeString(
    OUT PUNICODE_STRING pStringDest,
    IN PUNICODE_STRING pStringSrc
    )

/*++

Routine Description:

    initialize a UNICODE_STRING

Arguments:

    pStringDest - pointer to UNICODE_STRING structure to initialize
    pStringSrc  - pointer to UNICODE_STRING structure containing valid string

Return Value:

    DLC_STATUS
        Success - STATUS_SUCCESS
        Failure - DLC_STATUS_NO_MEMORY
                    Couldn't allocate memory from non-paged pool

--*/

{
    pStringDest->MaximumLength = (USHORT)(pStringSrc->Length + sizeof(WCHAR));
    pStringDest->Buffer = ALLOCATE_STRING_DRIVER(pStringDest->MaximumLength);
    if (pStringDest->Buffer == NULL) {
        return DLC_STATUS_NO_MEMORY;
    } else {
        RtlCopyUnicodeString(pStringDest, pStringSrc);
        return STATUS_SUCCESS;
    }
}


VOID
LlcFreeUnicodeString(
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    Companion routine to LlcInitUnicodeString - frees memory allocated from
    non-paged pool for a UNICODE string

Arguments:

    UnicodeString   - pointer to UNICODE_STRING structure, the buffer for which
                      was allocated in LlcInitUnicodeString

Return Value:

    None.

--*/

{
    FREE_STRING_DRIVER(UnicodeString->Buffer);
}

//#if LLC_DBG
//
//VOID
//LlcInvalidObjectType( VOID )
//{
//    DbgPrint( "DLC: Invalid object type!\n");
//    DbgBreakPoint();
//}
//
//
//VOID LlcBreakListCorrupt( VOID )
//{
//    DbgPrint( "Link list is corrupt! ");
//    DbgBreakPoint();
//}
//
//static PUCHAR aLanLlcInputStrings[] = {
//    "DISC0",
//    "DISC1",
//    "DM0",
//    "DM1",
//    "FRMR0",
//    "FRMR1",
//    "SABME0",
//    "SABME1",
//    "UA0",
//    "UA1",
//    "IS_I_r0",
//    "IS_I_r1",
//    "IS_I_c0",
//    "IS_I_c1",
//    "OS_I_r0",
//    "OS_I_r1",
//    "OS_I_c0",
//    "OS_I_c1",
//    "REJ_r0",
//    "REJ_r1",
//    "REJ_c0",
//    "REJ_c1",
//    "RNR_r0",
//    "RNR_r1",
//    "RNR_c0",
//    "RNR_c1",
//    "RR_r0",
//    "RR_r1",
//    "RR_c0",
//    "RR_c1",
//    "LPDU_INVALID_r0",
//    "LPDU_INVALID_r1",
//    "LPDU_INVALID_c0",
//    "LPDU_INVALID_c1",
//    "ACTIVATE_LS",
//    "DEACTIVATE_LS",
//    "ENTER_LCL_Busy",
//    "EXIT_LCL_Busy",
//    "SEND_I_POLL",
//    "SET_ABME",
//    "SET_ADM",
//    "Ti_Expired",
//    "T1_Expired",
//    "T2_Expired"
//};
//
////
////  Procedure prints the last global inputs and time stamps. This
////  does not print the stamps of a specific link station!!!
////
//VOID
//PrintLastInputs(
//    IN PUCHAR pszMessage,
//    IN PDATA_LINK  pLink
//    )
//{
//    UINT    i;
//    UINT    j = 0;
//
//    DbgPrint( pszMessage );
//
//    //
//    //  Print 20 last time stamps and state inputs of the given
//    //  link station.
//    //
//    for (i = InputIndex - 1; i > InputIndex - LLC_INPUT_TABLE_SIZE; i--)
//    {
//        if (aLast[ i % LLC_INPUT_TABLE_SIZE ].pLink == pLink)
//        {
//            DbgPrint(
//                "%4x:%10s, ",
//                aLast[i % LLC_INPUT_TABLE_SIZE].Time,
//                aLanLlcInputStrings[ aLast[i % LLC_INPUT_TABLE_SIZE].Input]
//                );
//            j++;
//            if ((j % 4) == 0)
//            {
//                DbgPrint( "\n" );
//            }
//            if (j == 20)
//            {
//                break;
//            }
//        }
//    }
//}
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcmem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcmem.c

Abstract:

    Functions for allocating & freeing memory. Split out from llclib.c. The
    reasons this module created are to isolate the memory allocators and to
    convert from using the Zone package to just using non-paged pool for all
    of DLC's memory requirements.

    Functions in this module are used by both DLC & LLC. These functions must
    go into a statically-linked library if DLC is ever divorced from LLC

    We use pools to avoid the overhead of calling the system allocation & free
    functions (although in practice, we end up allocating additional memory
    because the packet count in the pool is usually insufficient). The downside
    is that we may allocate memory that in the majority of situations is not
    used, but the packets in pools tend to be small and few in number

    To aid in tracking memory resources, DLC/LLC now defines the following
    memory categories:

        Memory
            - arbitrary sized blocks allocated out of non-paged pool using
              ExAllocatePool(NonPagedPool, ...)

        ZeroMemory
            - arbitrary sized blocks allocated out of non-paged pool using
              ExAllocatePool(NonPagedPool, ...) and initialized to zeroes

        Pool
            - small sets of (relatively) small packets are allocated in one
              block from Memory or ZeroMemory as a Pool and then subdivided
              into packets (CreatePacketPool, DeletePacketPool, AllocatePacket,
              DeallocatePacket)

        Object
            - structures which may be packets allocated from Pool which have
              a known size and initialization values. Pseudo-category mainly
              for debugging purposes

    Contents:
        InitializeMemoryPackage (DEBUG)
        PullEntryList           (DEBUG)
        LinkMemoryUsage         (DEBUG)
        UnlinkMemoryUsage       (DEBUG)
        ChargeNonPagedPoolUsage (DEBUG)
        RefundNonPagedPoolUsage (DEBUG)
        AllocateMemory          (DEBUG)
        AllocateZeroMemory
        DeallocateMemory        (DEBUG)
        AllocateObject          (DEBUG)
        FreeObject              (DEBUG)
        ValidateObject          (DEBUG)
        GetObjectSignature      (DEBUG)
        GetObjectBaseSize       (DEBUG)
        CreatePacketPool
        DeletePacketPool
        AllocatePacket
        DeallocatePacket
        CreateObjectPool        (DEBUG)
        AllocatePoolObject      (DEBUG)
        DeallocatePoolObject    (DEBUG)
        DeleteObjectPool        (DEBUG)
        CheckMemoryReturned     (DEBUG)
        CheckDriverMemoryUsage  (DEBUG)
        MemoryAllocationError   (DEBUG)
        UpdateCounter           (DEBUG)
        MemoryCounterOverflow   (DEBUG)
        DumpMemoryMetrics       (DEBUG)
        DumpPoolStats           (DEBUG)
        MapObjectId             (DEBUG)
        DumpPool                (DEBUG)
        DumpPoolList            (DEBUG)
        DumpPacketHead          (DEBUG)
        DumpMemoryUsageList     (DEBUG)
        DumpMemoryUsage         (DEBUG)
        x86SleazeCallersAddress (DEBUG)
        CollectReturnAddresses  (DEBUG)
        GetLastReturnAddress    (DEBUG)
        VerifyElementOnList     (DEBUG)
        CheckList               (DEBUG)
        CheckEntryOnList        (DEBUG)
        DumpPrivateMemoryHeader (DEBUG)
        ReportSwitchSettings    (DEBUG)

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    kernel mode only.

Notes:

    In non-debug version, DeallocateMemory is replaced with a macro which calls
    ExFreePool(...) and AllocateMemory is replaced by a macro which calls
    ExAllocatePool(NonPagedPool, ...)

Revision History:

    09-Mar-1993 RFirth
        Created

--*/

#ifndef i386
#define LLC_PRIVATE_PROTOTYPES
#endif

#include <ntddk.h>
#include <ndis.h>
#define APIENTRY
#include <dlcapi.h>
#include <dlcio.h>
#include "llcapi.h"
#include "dlcdef.h"
#include "dlcreg.h"
#include "dlctyp.h"
#include "llcdef.h"
#include "llcmem.h"
#include "llctyp.h"

#define DWORD_ROUNDUP(d)    (((d) + 3) & ~3)

#define YES_NO(thing)       ((thing) ? "Yes" : "No")


#if DBG

//
// some variables to keep track of memory allocations from non-paged pool. These
// are the cumulative totals for all of DLC's non-paged pool memory usage
//

KSPIN_LOCK MemoryCountersLock;
KIRQL MemoryCountersIrql;

ULONG GoodNonPagedPoolAllocs = 0;
ULONG BadNonPagedPoolAllocs = 0;
ULONG GoodNonPagedPoolFrees = 0;
ULONG BadNonPagedPoolFrees = 0;
ULONG NonPagedPoolRequested = 0;
ULONG NonPagedPoolAllocated = 0;
ULONG TotalNonPagedPoolRequested = 0;
ULONG TotalNonPagedPoolAllocated = 0;
ULONG TotalNonPagedPoolFreed = 0;

KSPIN_LOCK MemoryAllocatorLock;
ULONG InMemoryAllocator = 0;

KSPIN_LOCK PoolCreatorLock;
ULONG InPoolCreator = 0;

//
// MemoryUsageList - linked list of all MEMORY_USAGE structures in driver. If we
// allocate something that has a MEMORY_USAGE structure (& what doesn't?) then
// don't delete it, we can later scan this list to find out what is still allocated
//

PMEMORY_USAGE MemoryUsageList = NULL;
KSPIN_LOCK MemoryUsageLock;

//
// flags to aid in debugging - change states via debugger
//

//BOOLEAN DebugDump = TRUE;
BOOLEAN DebugDump = FALSE;

//BOOLEAN DeleteBusyListAnyway = TRUE;
BOOLEAN DeleteBusyListAnyway = FALSE;

BOOLEAN MemoryCheckNotify = TRUE;
//BOOLEAN MemoryCheckNotify = FALSE;

BOOLEAN MemoryCheckStop = TRUE;
//BOOLEAN MemoryCheckStop = FALSE;

BOOLEAN MaintainPrivateLists = TRUE;
//BOOLEAN MaintainPrivateLists = FALSE;

BOOLEAN MaintainGlobalLists = TRUE;
//BOOLEAN MaintainGlobalLists = FALSE;

BOOLEAN ZapDeallocatedPackets = TRUE;
//BOOLEAN ZapDeallocatedPackets = FALSE;

BOOLEAN ZapFreedMemory = TRUE;
//BOOLEAN ZapFreedMemory = FALSE;

//
// DlcGlobalMemoryList - every block that is allocated is linked to this list
// and removed when deleted. Helps us keep track of who allocated which block
//

KSPIN_LOCK DlcGlobalMemoryListLock;
LIST_ENTRY DlcGlobalMemoryList;
ULONG DlcGlobalMemoryListCount = 0;

//
// local function prototypes
//

VOID MemoryAllocationError(PCHAR, PVOID);
VOID UpdateCounter(PULONG, LONG);
VOID MemoryCounterOverflow(PULONG, LONG);
VOID DumpMemoryMetrics(VOID);
VOID DumpPoolStats(PCHAR, PPACKET_POOL);
PCHAR MapObjectId(DLC_OBJECT_TYPE);
VOID DumpPool(PPACKET_POOL);
VOID DumpPoolList(PCHAR, PSINGLE_LIST_ENTRY);
VOID DumpPacketHead(PPACKET_HEAD, ULONG);
VOID DumpMemoryUsageList(VOID);
VOID DumpMemoryUsage(PMEMORY_USAGE, BOOLEAN);
VOID CollectReturnAddresses(PVOID*, ULONG, ULONG);
PVOID* GetLastReturnAddress(PVOID**);
VOID x86SleazeCallersAddress(PVOID*, PVOID*);
BOOLEAN VerifyElementOnList(PSINGLE_LIST_ENTRY, PSINGLE_LIST_ENTRY);
VOID CheckList(PSINGLE_LIST_ENTRY, ULONG);
VOID CheckEntryOnList(PLIST_ENTRY, PLIST_ENTRY, BOOLEAN);
VOID DumpPrivateMemoryHeader(PPRIVATE_NON_PAGED_POOL_HEAD);
VOID ReportSwitchSettings(PSTR);

#define GRAB_SPINLOCK() KeAcquireSpinLock(&MemoryCountersLock, &MemoryCountersIrql)
#define FREE_SPINLOCK() KeReleaseSpinLock(&MemoryCountersLock, MemoryCountersIrql)

#ifdef i386
#define GET_CALLERS_ADDRESS x86SleazeCallersAddress
#else
#define GET_CALLERS_ADDRESS RtlGetCallersAddress
#endif

//
// private prototypes
//

ULONG
GetObjectSignature(
    IN DLC_OBJECT_TYPE ObjectType
    );

ULONG
GetObjectBaseSize(
    IN DLC_OBJECT_TYPE ObjectType
    );

#else

#define GRAB_SPINLOCK()
#define FREE_SPINLOCK()

#endif

//
// functions
//



#if DBG

VOID
InitializeMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Performs initialization for memory allocation functions

Arguments:

    None.

Return Value:

    None.

--*/

{
    KeInitializeSpinLock(&MemoryCountersLock);
    KeInitializeSpinLock(&MemoryAllocatorLock);
    KeInitializeSpinLock(&PoolCreatorLock);
    KeInitializeSpinLock(&MemoryUsageLock);
    KeInitializeSpinLock(&DlcGlobalMemoryListLock);
    DriverMemoryUsage.OwnerObjectId = DlcDriverObject;
    DriverMemoryUsage.OwnerInstance = 0x4D454D; // 'MEM'
    InitializeListHead(&DriverMemoryUsage.PrivateList);
    LinkMemoryUsage(&DriverMemoryUsage);
    DriverStringUsage.OwnerObjectId = DlcDriverObject;
    DriverStringUsage.OwnerInstance = 0x535452; // 'STR'
    InitializeListHead(&DriverStringUsage.PrivateList);
    LinkMemoryUsage(&DriverStringUsage);
    InitializeListHead(&DlcGlobalMemoryList);
    ReportSwitchSettings("DLC.InitializeMemoryPackage (DEBUG version only)");
}


PSINGLE_LIST_ENTRY
PullEntryList(
    IN PSINGLE_LIST_ENTRY List,
    IN PSINGLE_LIST_ENTRY Element
    )

/*++

Routine Description:

    The missing SINGLE_LIST_ENTRY function. Removes an entry from a single-linked
    list. The entry can be anywhere on the list. Reduces size of list elements
    by one pointer, at expense of increased time to traverse list.

    This function SHOULD NOT return NULL: if it does then the code is broken
    since it assumes that an element is on a list, when it ain't

Arguments:

    List    - pointer to singly-linked list anchor. This MUST be the address of
              the pointer to the list, not the first element in the list
    Element - pointer to element to remove from List

Return Value:

    PSINGLE_LIST_ENTRY
        Success - Element
        Failure - NULL

--*/

{
    PSINGLE_LIST_ENTRY prev = List;

    ASSERT(List);
    ASSERT(Element);

    while (List = List->Next) {
        if (List == Element) {
            prev->Next = Element->Next;
            return Element;
        }
        prev = List;
    }
    return NULL;
}


VOID
LinkMemoryUsage(
    IN PMEMORY_USAGE pMemoryUsage
    )

/*++

Routine Description:

    Add pMemoryUsage to linked list of MEMORY_USAGE structures

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure to add

Return Value:

    None.

--*/

{
    KIRQL irql;

    KeAcquireSpinLock(&MemoryUsageLock, &irql);
    PushEntryList((PSINGLE_LIST_ENTRY)&MemoryUsageList, (PSINGLE_LIST_ENTRY)pMemoryUsage);
    KeReleaseSpinLock(&MemoryUsageLock, irql);
}


VOID
UnlinkMemoryUsage(
    IN PMEMORY_USAGE pMemoryUsage
    )

/*++

Routine Description:

    Remove pMemoryUsage from linked list of MEMORY_USAGE structures

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure to remove

Return Value:

    None.

--*/

{
    KIRQL irql;

    ASSERT(pMemoryUsage);
    CheckMemoryReturned(pMemoryUsage);
    KeAcquireSpinLock(&MemoryUsageLock, &irql);
    ASSERT(PullEntryList((PSINGLE_LIST_ENTRY)&MemoryUsageList, (PSINGLE_LIST_ENTRY)pMemoryUsage));
    KeReleaseSpinLock(&MemoryUsageLock, irql);
}


VOID
ChargeNonPagedPoolUsage(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size,
    IN PPRIVATE_NON_PAGED_POOL_HEAD Block
    )

/*++

Routine Description:

    Charges this non-paged pool allocation to a specific memory user

Arguments:

    pMemoryUsage    - pointer to structure recording memory usage
    Size            - size of block allocated
    Block           - pointer to private header of allocated block

Return Value:

    None.

--*/

{
    KIRQL irql;

    KeAcquireSpinLock(&pMemoryUsage->SpinLock, &irql);
    if (pMemoryUsage->NonPagedPoolAllocated + Size < pMemoryUsage->NonPagedPoolAllocated) {
        if (MemoryCheckNotify) {
            DbgPrint("DLC.ChargeNonPagedPoolUsage: Overcharged? Usage @ %08x\n", pMemoryUsage);
        }
        if (MemoryCheckStop) {
            DumpMemoryUsage(pMemoryUsage, TRUE);
            DbgBreakPoint();
        }
    }
    pMemoryUsage->NonPagedPoolAllocated += Size;
    ++pMemoryUsage->AllocateCount;

    //
    // link this block to the memory usage private list
    //

    if (MaintainPrivateLists) {
        if (pMemoryUsage->PrivateList.Flink == NULL) {

            //
            // slight hack to make initializing MEMORY_USAGEs easier...
            //

            InitializeListHead(&pMemoryUsage->PrivateList);
        }
        InsertTailList(&pMemoryUsage->PrivateList, &Block->PrivateList);
    }
    KeReleaseSpinLock(&pMemoryUsage->SpinLock, irql);
}


VOID
RefundNonPagedPoolUsage(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size,
    IN PPRIVATE_NON_PAGED_POOL_HEAD Block
    )

/*++

Routine Description:

    Refunds a non-paged pool allocation to a specific memory user

Arguments:

    pMemoryUsage    - pointer to structure recording memory usage
    Size            - size of block allocated
    Block           - pointer to private header of allocated block

Return Value:

    None.

--*/

{
    KIRQL irql;

    KeAcquireSpinLock(&pMemoryUsage->SpinLock, &irql);
    if (pMemoryUsage->NonPagedPoolAllocated - Size > pMemoryUsage->NonPagedPoolAllocated) {
        if (MemoryCheckNotify) {
            DbgPrint("DLC.RefundNonPagedPoolUsage: Error: Freeing unallocated memory? Usage @ %08x, %d\n",
                     pMemoryUsage,
                     Size
                     );
        }
        if (MemoryCheckStop) {
            DumpMemoryUsage(pMemoryUsage, TRUE);
            DbgBreakPoint();
        }
    }

    //
    // unlink this block from the memory usage private list
    //

    if (MaintainPrivateLists) {
        CheckEntryOnList(&Block->PrivateList, &pMemoryUsage->PrivateList, TRUE);
        RemoveEntryList(&Block->PrivateList);
    }
    pMemoryUsage->NonPagedPoolAllocated -= Size;
    ++pMemoryUsage->FreeCount;
    KeReleaseSpinLock(&pMemoryUsage->SpinLock, irql);
}


PVOID
AllocateMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory out of non-paged pool. For the debug version, we round up
    the requested size to the next 4-byte boundary and we add header and tail
    sections which contain a signature to check for over-write, and in-use and
    size information

    In the non-debug version, this function is replaced by a call to
    ExAllocatePool(NonPagedPool, ...)

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    Size            - number of bytes to allocate

Return Value:

    PVOID
        Success - pointer to allocated memory
        Failure - NULL

--*/

{
    PVOID pMem;
    ULONG OriginalSize = Size;
    PUCHAR pMemEnd;

/*
    KIRQL irql;

    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    if (InMemoryAllocator) {
        DbgPrint("DLC.AllocateMemory: Error: Memory allocator clash on entry. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    ++InMemoryAllocator;
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

    Size = DWORD_ROUNDUP(Size)
         + sizeof(PRIVATE_NON_PAGED_POOL_HEAD)
         + sizeof(PRIVATE_NON_PAGED_POOL_TAIL);

    pMem = ExAllocatePoolWithTag(NonPagedPool, (ULONG)Size, DLC_POOL_TAG);
    if (pMem) {
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Size = Size;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->OriginalSize = OriginalSize;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Flags = MEM_FLAGS_IN_USE;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Signature = SIGNATURE1;

        pMemEnd = (PUCHAR)pMem
                + DWORD_ROUNDUP(OriginalSize)
                + sizeof(PRIVATE_NON_PAGED_POOL_HEAD);

        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Size = Size;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Signature = SIGNATURE2;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Pattern1 = PATTERN1;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Pattern2 = PATTERN2;

        GRAB_SPINLOCK();
        UpdateCounter(&GoodNonPagedPoolAllocs, 1);
        UpdateCounter(&NonPagedPoolAllocated, (LONG)Size);
        UpdateCounter(&NonPagedPoolRequested, (LONG)OriginalSize);
        UpdateCounter(&TotalNonPagedPoolRequested, (LONG)OriginalSize);
        UpdateCounter(&TotalNonPagedPoolAllocated, (LONG)Size);
        FREE_SPINLOCK();

        if (MaintainGlobalLists) {

            KIRQL irql;

            //
            // record the caller and add this block to the global list
            //

            GET_CALLERS_ADDRESS(&((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Stack[0],
                                &((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Stack[1]
                                );
            KeAcquireSpinLock(&DlcGlobalMemoryListLock, &irql);
            InsertTailList(&DlcGlobalMemoryList,
                           &((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->GlobalList
                           );
            ++DlcGlobalMemoryListCount;
            KeReleaseSpinLock(&DlcGlobalMemoryListLock, irql);
        }
        ChargeNonPagedPoolUsage(pMemoryUsage, Size, (PPRIVATE_NON_PAGED_POOL_HEAD)pMem);
        pMem = (PVOID)((PUCHAR)pMem + sizeof(PRIVATE_NON_PAGED_POOL_HEAD));
    } else {
        GRAB_SPINLOCK();
        UpdateCounter(&BadNonPagedPoolAllocs, 1);
        FREE_SPINLOCK();
    }

/*
    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    --InMemoryAllocator;
    if (InMemoryAllocator) {
        DbgPrint("DLC.AllocateMemory: Error: Memory allocator clash on exit. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

    return pMem;
}


VOID
DeallocateMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID Pointer
    )

/*++

Routine Description:

    frees memory to non-paged pool

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    Pointer         - pointer to previously allocated non-paged pool memory

Return Value:

    None.

--*/

{
    PPRIVATE_NON_PAGED_POOL_HEAD pHead;
    PPRIVATE_NON_PAGED_POOL_TAIL pTail;

/*
    KIRQL irql;

    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    if (InMemoryAllocator) {
        DbgPrint("DLC.DeallocateMemory: Error: Memory allocator clash on entry. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    ++InMemoryAllocator;
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

    pHead = (PPRIVATE_NON_PAGED_POOL_HEAD)((PUCHAR)Pointer - sizeof(PRIVATE_NON_PAGED_POOL_HEAD));
    pTail = (PPRIVATE_NON_PAGED_POOL_TAIL)((PUCHAR)pHead + pHead->Size - sizeof(PRIVATE_NON_PAGED_POOL_TAIL));

    if (MaintainGlobalLists) {
        CheckEntryOnList(&pHead->GlobalList, &DlcGlobalMemoryList, TRUE);

        if (pHead->GlobalList.Flink == NULL
        || pHead->GlobalList.Blink == NULL) {
            if (MemoryCheckNotify) {
                DbgPrint("DLC.DeallocateMemory: Error: Block already globally freed: %08x\n", pHead);
            }
            if (MemoryCheckStop) {
                DbgBreakPoint();
            }
        }
    }

    if (pHead->Signature != SIGNATURE1
    || !(pHead->Flags & MEM_FLAGS_IN_USE)
    || pTail->Size != pHead->Size
    || pTail->Signature != SIGNATURE2
    || pTail->Pattern1 != PATTERN1
    || pTail->Pattern2 != PATTERN2) {
        if (MemoryCheckNotify || MemoryCheckStop) {
            MemoryAllocationError("DeallocateMemory", (PVOID)pHead);
        }
        GRAB_SPINLOCK();
        UpdateCounter(&BadNonPagedPoolFrees, 1);
        FREE_SPINLOCK();
    } else {
        GRAB_SPINLOCK();
        UpdateCounter(&GoodNonPagedPoolFrees, 1);
        FREE_SPINLOCK();
    }
    GRAB_SPINLOCK();
    UpdateCounter(&NonPagedPoolRequested, -(LONG)pHead->OriginalSize);
    UpdateCounter(&NonPagedPoolAllocated, -(LONG)pHead->Size);
    UpdateCounter(&TotalNonPagedPoolFreed, (LONG)pHead->Size);
    FREE_SPINLOCK();

    //
    // access Size field before ExFreePool zaps it/somebody else allocates memory
    //

    RefundNonPagedPoolUsage(pMemoryUsage, pHead->Size, pHead);

    if (MaintainGlobalLists) {

        //
        // remove this block from the global list
        //

        RemoveEntryList(&pHead->GlobalList);
        --DlcGlobalMemoryListCount;
        pHead->GlobalList.Flink = pHead->GlobalList.Flink = NULL;
    }

    if (ZapFreedMemory) {
        RtlFillMemory(pHead + 1,
                           DWORD_ROUNDUP(pHead->OriginalSize),
                           ZAP_EX_FREE_VALUE
                           );
    }

    ExFreePool((PVOID)pHead);

/*
    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    --InMemoryAllocator;
    if (InMemoryAllocator) {
        DbgPrint("DLC.DeallocateMemory: Error: Memory allocator clash on exit. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/
}


PVOID
AllocateObject(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG ObjectSize
    )

/*++

Routine Description:

    Allocates a pseudo-object

Arguments:

    ObjectType      - type of object to allocate
    ObjectSize      - size of object; mainly because some objects have variable size
    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage

Return Value:

    PVOID
        Success - pointer to object allocated from non-paged pool
        Failure - NULL

--*/

{
    POBJECT_ID pObject;
    ULONG signature;
    ULONG baseSize;

    signature = GetObjectSignature(ObjectType);
    baseSize = GetObjectBaseSize(ObjectType);
    if (baseSize < ObjectSize) {
        DbgPrint("DLC.AllocateObject: Error: Invalid size %d for ObjectType %08x (should be >= %d)\n",
                ObjectSize,
                ObjectType,
                baseSize
                );
        DbgBreakPoint();
    }
    pObject = (POBJECT_ID)AllocateZeroMemory(pMemoryUsage, ObjectSize);
    if (pObject) {
        pObject->Signature = signature;
        pObject->Type = ObjectType;
        pObject->Size = baseSize;
        pObject->Extra = ObjectSize - baseSize;
    }
    return (PVOID)pObject;
}


VOID
FreeObject(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID pObject,
    IN DLC_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    Deallocates a pseudo-object

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    pObject         - pointer to object allocated with AllocateObject
    ObjectType      - type of object pObject supposed to be

Return Value:

    None.

--*/

{
    ValidateObject(pObject, ObjectType);
    DeallocateMemory(pMemoryUsage, pObject);
}


VOID
ValidateObject(
    IN POBJECT_ID pObject,
    IN DLC_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    Checks that an object is what its supposed to be

Arguments:

    pObject     - pointer to object to check
    ObjectType  - type of object pObject supposed to point to

Return Value:

    None.

--*/

{
    ULONG signature = GetObjectSignature(ObjectType);
    ULONG baseSize = GetObjectBaseSize(ObjectType);

    if (pObject->Signature != signature
    || pObject->Type != ObjectType
    || pObject->Size != baseSize) {
        DbgPrint("DLC.ValidateObject: Error: InvalidObject %08x, Type=%08x\n",
                pObject,
                ObjectType
                );
        DbgBreakPoint();
    }
}


ULONG
GetObjectSignature(
    IN DLC_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    returns the signature for an object type

Arguments:

    ObjectType  - type of object to return signature for

Return Value:

    ULONG

--*/

{
    switch (ObjectType) {
    case FileContextObject:
        return SIGNATURE_FILE;

    case AdapterContextObject:
        return SIGNATURE_ADAPTER;

    case BindingContextObject:
        return SIGNATURE_BINDING;

    case DlcSapObject:
    case DlcGroupSapObject:
        return SIGNATURE_DLC_SAP;

    case DlcLinkObject:
        return SIGNATURE_DLC_LINK;

    case DlcDixObject:
        return SIGNATURE_DIX;

    case LlcDataLinkObject:
        return SIGNATURE_LLC_LINK;

    case LlcSapObject:
    case LlcGroupSapObject:
        return SIGNATURE_LLC_SAP;

    default:
        DbgPrint("DLC.GetObjectSignature: Error: unknown object type %08x\n", ObjectType);
        DbgBreakPoint();
        return 0;
    }

}


ULONG
GetObjectBaseSize(
    IN DLC_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    returns the base size for an object

Arguments:

    ObjectType  - type of object to return base size for

Return Value:

    ULONG

--*/

{
    switch (ObjectType) {
    case FileContextObject:
        return sizeof(DLC_FILE_CONTEXT);

    case AdapterContextObject:
        return sizeof(ADAPTER_CONTEXT);

    case BindingContextObject:
        return sizeof(BINDING_CONTEXT);

    case DlcSapObject:
    case DlcGroupSapObject:
        return sizeof(DLC_OBJECT);

    case DlcLinkObject:
        return sizeof(DLC_OBJECT);

    case DlcDixObject:
        return sizeof(DLC_OBJECT);

    case LlcDataLinkObject:
        return sizeof(DATA_LINK);

    case LlcSapObject:
    case LlcGroupSapObject:
        return sizeof(LLC_OBJECT);

    default:
        DbgPrint("DLC.GetObjectBaseSize: Error: unknown object type %08x\n", ObjectType);
        DbgBreakPoint();
        return 0;
    }
}

#endif


PVOID
AllocateZeroMemory(
#if DBG
    IN PMEMORY_USAGE pMemoryUsage,
#endif
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory out of non-paged pool. For the debug version, we round up
    the requested size to the next 4-byte boundary and we add header and tail
    sections which contain a signature to check for over-write, and in-use and
    size information

    The memory is zeroed before being returned to the caller

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    Size            - number of bytes to allocate

Return Value:

    PVOID
        Success - pointer to allocated memory
        Failure - NULL

--*/

{
    PVOID pMem;

#if DBG

    ULONG OriginalSize = Size;
    PUCHAR pMemEnd;

/*
    KIRQL irql;

    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    if (InMemoryAllocator) {
        DbgPrint("DLC.AllocateZeroMemory: Error: Memory allocator clash on entry. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    ++InMemoryAllocator;
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

    Size = DWORD_ROUNDUP(Size)
         + sizeof(PRIVATE_NON_PAGED_POOL_HEAD)
         + sizeof(PRIVATE_NON_PAGED_POOL_TAIL);

#endif

    pMem = ExAllocatePoolWithTag(NonPagedPool, (ULONG)Size, DLC_POOL_TAG);
    if (pMem) {
        LlcZeroMem(pMem, Size);

#if DBG

        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Size = Size;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->OriginalSize = OriginalSize;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Flags = MEM_FLAGS_IN_USE;
        ((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Signature = SIGNATURE1;

        pMemEnd = (PUCHAR)pMem
                + DWORD_ROUNDUP(OriginalSize)
                + sizeof(PRIVATE_NON_PAGED_POOL_HEAD);

        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Size = Size;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Signature = SIGNATURE2;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Pattern1 = PATTERN1;
        ((PPRIVATE_NON_PAGED_POOL_TAIL)pMemEnd)->Pattern2 = PATTERN2;

        GRAB_SPINLOCK();
        UpdateCounter(&GoodNonPagedPoolAllocs, 1);
        UpdateCounter(&NonPagedPoolAllocated, (LONG)Size);
        UpdateCounter(&NonPagedPoolRequested, (LONG)OriginalSize);
        UpdateCounter(&TotalNonPagedPoolRequested, (LONG)OriginalSize);
        UpdateCounter(&TotalNonPagedPoolAllocated, (LONG)Size);
        FREE_SPINLOCK();

        if (MaintainGlobalLists) {

            KIRQL irql;

            //
            // record the caller and add this block to the global list
            //

            GET_CALLERS_ADDRESS(&((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Stack[0],
                                &((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->Stack[1]
                                );

            KeAcquireSpinLock(&DlcGlobalMemoryListLock, &irql);
            InsertTailList(&DlcGlobalMemoryList,
                           &((PPRIVATE_NON_PAGED_POOL_HEAD)pMem)->GlobalList
                           );
            ++DlcGlobalMemoryListCount;
            KeReleaseSpinLock(&DlcGlobalMemoryListLock, irql);
        }
        ChargeNonPagedPoolUsage(pMemoryUsage, Size, (PPRIVATE_NON_PAGED_POOL_HEAD)pMem);
        pMem = (PVOID)((PUCHAR)pMem + sizeof(PRIVATE_NON_PAGED_POOL_HEAD));
    } else {
        GRAB_SPINLOCK();
        UpdateCounter(&BadNonPagedPoolAllocs, 1);
        FREE_SPINLOCK();
    }

/*
    KeAcquireSpinLock(&MemoryAllocatorLock, &irql);
    --InMemoryAllocator;
    if (InMemoryAllocator) {
        DbgPrint("DLC.AllocateZeroMemory: Error: Memory allocator clash on exit. Count = %d\n",
                InMemoryAllocator
                );
//        DbgBreakPoint();
    }
    KeReleaseSpinLock(&MemoryAllocatorLock, irql);
*/

#else

    }

#endif

    return pMem;
}


PPACKET_POOL
CreatePacketPool(
#if DBG
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID pOwner,
    IN DLC_OBJECT_TYPE ObjectType,
#endif
    IN ULONG PacketSize,
    IN ULONG NumberOfPackets
    )

/*++

Routine Description:

    creates a packet pool. A packet pool is a collection of same-sized packets

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    pOwner          - pointer to owner object
    ObjectType      - type of object for owner
    PacketSize      - size of packet in bytes
    NumberOfPackets - initial number of packets in pool

Return Value:

    PPACKET_POOL
        Success - pointer to PACKET_POOL structure allocated from non-paged pool
        Failure - NULL

--*/

{
    PPACKET_POOL pPacketPool;
    PPACKET_HEAD pPacketHead;

#if DBG
/*
//    DbgPrint("DLC.CreatePacketPool(%d, %d)\n", PacketSize, NumberOfPackets);
    if (InPoolCreator) {
        DbgPrint("DLC.CreatePacketPool: Error: Pool Creator clash on entry. Count = %d\n",
                InPoolCreator
                );
//        DbgBreakPoint();
    }
    ++InPoolCreator;
*/

    pPacketPool = AllocateZeroMemory(pMemoryUsage, sizeof(PACKET_POOL));
#else
    pPacketPool = AllocateZeroMemory(sizeof(PACKET_POOL));
#endif

    if (pPacketPool) {

#if DBG
        pPacketPool->OriginalPacketCount = NumberOfPackets;
        pPacketPool->MemoryUsage.Owner = pPacketPool;
        pPacketPool->MemoryUsage.OwnerObjectId = ObjectType;
#endif

        while (NumberOfPackets--) {

#if DBG

            //
            // charge memory for individual packets to the pool
            //

            pPacketHead = (PPACKET_HEAD)AllocateZeroMemory(&pPacketPool->MemoryUsage,
                                                           sizeof(PACKET_HEAD) + PacketSize
                                                           );
#else
            pPacketHead = (PPACKET_HEAD)AllocateZeroMemory(sizeof(PACKET_HEAD) + PacketSize);
#endif

            if (pPacketHead) {
#if DBG
                pPacketHead->Signature = PACKET_HEAD_SIGNATURE;
                pPacketHead->pPacketPool = pPacketPool;
                ++pPacketPool->FreeCount;
#endif

                pPacketHead->Flags = PACKET_FLAGS_FREE;
                PushEntryList(&pPacketPool->FreeList, (PSINGLE_LIST_ENTRY)pPacketHead);
            } else {
                while (pPacketPool->FreeList.Next) {

                    PVOID ptr = (PVOID)PopEntryList(&pPacketPool->FreeList);

#if DBG
                    DeallocateMemory(&pPacketPool->MemoryUsage, ptr);
#else
                    DeallocateMemory(ptr);
#endif
                }

#if DBG
                DbgPrint("DLC.CreatePacketPool: Error: couldn't allocate %d packets\n",
                         pPacketPool->OriginalPacketCount
                         );
                DeallocateMemory(pMemoryUsage, pPacketPool);
/*
                --InPoolCreator;
                if (InPoolCreator) {
                    DbgPrint("DLC.CreatePacketPool: Error: Pool Creator clash on exit. Count = %d\n",
                            InPoolCreator
                            );
//                    DbgBreakPoint();
                }
*/

#else
                DeallocateMemory(pPacketPool);
#endif

                return NULL;
            }
        }
        KeInitializeSpinLock(&pPacketPool->PoolLock);
        pPacketPool->PacketSize = PacketSize;

#if DBG
        pPacketPool->Signature = PACKET_POOL_SIGNATURE;
        pPacketPool->Viable = TRUE;
        pPacketPool->CurrentPacketCount = pPacketPool->OriginalPacketCount;
        pPacketPool->Flags = POOL_FLAGS_IN_USE;
        pPacketPool->pMemoryUsage = pMemoryUsage;

        //
        // add the memory usage structure for this pool to the memory usage
        // list
        //

        LinkMemoryUsage(&pPacketPool->MemoryUsage);

        if (DebugDump) {
            DbgPrint("DLC.CreatePacketPool: %08x\n", pPacketPool);
            DumpPool(pPacketPool);
        }
    } else {
        DbgPrint("DLC.CreatePacketPool: Error: couldn't allocate memory for PACKET_POOL\n");
    }

    //
    // debug counters in PACKET_POOL structure are already zero thanks to
    // AllocateZeroMemory automatically zeroing all memory allocated from
    // non-paged pool
    //

/*
    --InPoolCreator;
    if (InPoolCreator) {
        DbgPrint("DLC.CreatePacketPool: Error: Pool Creator clash on exit. Count = %d\n",
                InPoolCreator
                );
//        DbgBreakPoint();
    }
*/

#else

    }

#endif

    return pPacketPool;
}


VOID
DeletePacketPool(
#if DBG
    IN PMEMORY_USAGE pMemoryUsage,
#endif
    IN PPACKET_POOL* ppPacketPool
    )

/*++

Routine Description:

    frees a previously created packet pool

Arguments:

    pMemoryUsage    - pointer to MEMORY_USAGE structure for charging mem usage
    ppPacketPool    - pointer to pointer to PACKET_POOL structure. Zero on return

Return Value:

    None.

--*/

{
    KIRQL irql;
    PPACKET_HEAD pPacketHead;
    PPACKET_POOL pPacketPool = *ppPacketPool;

#if DBG
    ULONG packetCount;
#endif

    //
    // for various reasons, we can receive a NULL pointer. No action in this case
    //

    if (pPacketPool == NULL) {

#if DBG
        PVOID callerAddress, callersCaller;

        GET_CALLERS_ADDRESS(&callerAddress, &callersCaller);
        DbgPrint("DLC.DeletePacketPool: NULL pointer. Caller = %x (caller's caller = %x)\n",
                callerAddress,
                callersCaller
                );
#endif

        return;
    }

#if DBG
//    DbgPrint("DLC.DeletePacketPool(%08x)\n", pPacketPool);
//    DumpPool(pPacketPool);
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.DeletePacketPool: Error: Memory allocator clash on entry: Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    ++pPacketPool->ClashCount;

    if (pPacketPool->Signature != PACKET_POOL_SIGNATURE) {
        DbgPrint("DLC.DeletePacketPool: Error: Invalid Pool Handle %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    if (!pPacketPool->Viable) {
        DbgPrint("DLC.DeletePacketPool: Error: Unviable Packet Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
#endif

    KeAcquireSpinLock(&pPacketPool->PoolLock, &irql);

#if DBG

    //
    // mark the packet pool structure as unviable: if anybody tries to allocate
    // or deallocate while we are destroying the pool, we will break into debugger
    //

    pPacketPool->Viable = FALSE;
    pPacketPool->Signature = 0xFFFFFFFF;

    //
    // assert that the busy list is empty
    //

    if (pPacketPool->BusyList.Next != NULL) {
        DbgPrint("DLC.DeletePacketPool: Error: %d packets busy. Pool = %08x\n",
                 pPacketPool->BusyCount,
                 pPacketPool
                 );
        if (!DeleteBusyListAnyway) {
            DumpPool(pPacketPool);
            DbgBreakPoint();
        } else {
            DbgPrint("DLC.DeletePacketPool: Deleting BusyList anyway\n");
        }
    }

    packetCount = 0;

#endif

    while (pPacketPool->FreeList.Next != NULL) {
        pPacketHead = (PPACKET_HEAD)PopEntryList(&pPacketPool->FreeList);

#if DBG
        if (pPacketHead->Signature != PACKET_HEAD_SIGNATURE
        || pPacketHead->pPacketPool != pPacketPool
        || (pPacketHead->Flags & PACKET_FLAGS_BUSY)
        || !(pPacketHead->Flags & PACKET_FLAGS_FREE)) {
            DbgPrint("DLC.DeletePacketPool: Error: Bad packet %08x. Pool = %08x\n",
                    pPacketHead,
                    pPacketPool
                    );
            DbgBreakPoint();
        }
        ++packetCount;
        DeallocateMemory(&pPacketPool->MemoryUsage, pPacketHead);
#else
        DeallocateMemory(pPacketHead);
#endif

    }

#if DBG

    if (DeleteBusyListAnyway) {
        while (pPacketPool->BusyList.Next != NULL) {
            pPacketHead = (PPACKET_HEAD)PopEntryList(&pPacketPool->BusyList);

            if (pPacketHead->Signature != PACKET_HEAD_SIGNATURE
            || pPacketHead->pPacketPool != pPacketPool
            || (pPacketHead->Flags & PACKET_FLAGS_FREE)
            || !(pPacketHead->Flags & PACKET_FLAGS_BUSY)) {
                DbgPrint("DLC.DeletePacketPool: Error: Bad packet %08x. Pool = %08x\n",
                        pPacketHead,
                        pPacketPool
                        );
                DbgBreakPoint();
            }
            ++packetCount;
            DeallocateMemory(&pPacketPool->MemoryUsage, pPacketHead);
        }
    }

    //
    // did any packets get unwittingly added or removed?
    //

    if (packetCount != pPacketPool->CurrentPacketCount) {
        DbgPrint("DLC.DeletePacketPool: Error: PacketCount (%d) != PoolCount (%d)\n",
                packetCount,
                pPacketPool->CurrentPacketCount
                );
        DumpPool(pPacketPool);
        DbgBreakPoint();
    }

    //
    // ensure we returned all the memory allocated to this pool
    //

    CheckMemoryReturned(&pPacketPool->MemoryUsage);

    //
    // dump the counters every time we delete a pool
    //

//    DumpPoolStats("DeletePacketPool", pPacketPool);

    //
    // remove the pool's memory usage structure - all memory allocated has been
    // freed, so we're in the clear for this one
    //

    UnlinkMemoryUsage(&pPacketPool->MemoryUsage);

#endif

    KeReleaseSpinLock(&pPacketPool->PoolLock, irql);

#if DBG
    DeallocateMemory(pMemoryUsage, pPacketPool);
#else
    DeallocateMemory(pPacketPool);
#endif

    *ppPacketPool = NULL;
}


PVOID
AllocatePacket(
    IN PPACKET_POOL pPacketPool
    )

/*++

Routine Description:

    allocates a packet from a packet pool. We expect that we can always get a
    packet from the previously allocated pool. However, if all packets are
    currently in use, allocate another from non-paged pool

Arguments:

    pPacketPool - pointer to PACKET_POOL structure

Return Value:

    PVOID
        Success - pointer to allocated packet
        Failure - NULL

--*/

{
    KIRQL irql;
    PPACKET_HEAD pPacketHead;

#if DBG
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.AllocatePacket: Error: Memory allocator clash on entry: Pool %08x, Count %d\n",
                pPacketPool,
                pPacketPool->ClashCount
                );
//        DbgBreakPoint();
    }
    ++pPacketPool->ClashCount;
#endif

    KeAcquireSpinLock(&pPacketPool->PoolLock, &irql);

#if DBG
    if (pPacketPool->Signature != PACKET_POOL_SIGNATURE) {
        DbgPrint("DLC.AllocatePacket: Error: Invalid Pool Handle %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    if (!pPacketPool->Viable) {
        DbgPrint("DLC.AllocatePacket: Error: Unviable Packet Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
#endif

    if (pPacketPool->FreeList.Next != NULL) {
        pPacketHead = (PPACKET_HEAD)PopEntryList(&pPacketPool->FreeList);

#if DBG
        --pPacketPool->FreeCount;
        if (pPacketHead->Flags & PACKET_FLAGS_BUSY
        || !(pPacketHead->Flags & PACKET_FLAGS_FREE)) {
            DbgPrint("DLC.AllocatePacket: Error: BUSY packet %08x on FreeList; Pool=%08x\n",
                    pPacketHead,
                    pPacketPool
                    );
            DumpPacketHead(pPacketHead, 0);
            DbgBreakPoint();
        }
#endif

    } else {

        //
        // Miscalculated pool usage
        //

#if DBG
        pPacketHead = (PPACKET_HEAD)AllocateZeroMemory(&pPacketPool->MemoryUsage,
                                                       sizeof(PACKET_HEAD) + pPacketPool->PacketSize
                                                       );
#else
        pPacketHead = (PPACKET_HEAD)AllocateZeroMemory(sizeof(PACKET_HEAD) + pPacketPool->PacketSize);
#endif

        if (pPacketHead) {

            //
            // mark this packet as allocated after the pool was created - this
            // means our initial estimation of packet requirement for this
            // pool was inadequate
            //

            pPacketHead->Flags = PACKET_FLAGS_POST_ALLOC | PACKET_FLAGS_FREE;
        }

#if DBG
        ++pPacketPool->NoneFreeCount;
        if (pPacketHead) {

            PVOID caller;
            PVOID callersCaller;

            GET_CALLERS_ADDRESS(&caller, &callersCaller);
            if (DebugDump) {
                DbgPrint("DLC.AllocatePacket: Adding new packet %08x to pool %08x. ret=%08x,%08x\n",
                        pPacketHead,
                        pPacketPool,
                        caller,
                        callersCaller
                        );
            }
            pPacketHead->Signature = PACKET_HEAD_SIGNATURE;
            pPacketHead->pPacketPool = pPacketPool;

            ++pPacketPool->CurrentPacketCount;
            DumpPoolStats("AllocatePacket", pPacketPool);
        } else {
            DbgPrint("DLC.AllocatePacket: Error: couldn't allocate packet for Pool %08x\n",
                     pPacketPool
                     );
        }
#endif

    }
    if (pPacketHead) {

        //
        // turn on BUSY flag, turn off FREE flag
        //

        pPacketHead->Flags ^= (PACKET_FLAGS_FREE | PACKET_FLAGS_BUSY);

        //
        // zero the contents of the packet!
        //

        LlcZeroMem((PVOID)(pPacketHead + 1), pPacketPool->PacketSize);
        PushEntryList(&pPacketPool->BusyList, (PSINGLE_LIST_ENTRY)pPacketHead);

#if DBG
        GET_CALLERS_ADDRESS(&pPacketHead->CallersAddress_A,
                            &pPacketHead->CallersCaller_A
                            );
        ++pPacketPool->BusyCount;
        ++pPacketPool->Allocations;
        ++pPacketPool->MaxInUse;
#endif

    }

    KeReleaseSpinLock(&pPacketPool->PoolLock, irql);

#if DBG
    --pPacketPool->ClashCount;
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.AllocatePacket: Error: Memory allocator clash on exit: Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
#endif

    //
    // return pointer to packet body, not packet header
    //

    return pPacketHead ? (PVOID)(pPacketHead + 1) : (PVOID)pPacketHead;
}


VOID
DeallocatePacket(
    IN PPACKET_POOL pPacketPool,
    IN PVOID pPacket
    )

/*++

Routine Description:

    Returns a packet to its pool

Arguments:

    pPacketPool - pointer to PACKET_POOL structure describing this pool
    pPacket     - pointer to previously allocated packet

Return Value:

    None.

--*/

{
    KIRQL irql;
    PPACKET_HEAD pPacketHead = ((PPACKET_HEAD)pPacket) - 1;
    PSINGLE_LIST_ENTRY p;
    PSINGLE_LIST_ENTRY prev;

#if DBG
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.DeallocatePacket: Error: Memory allocator clash on entry: Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    ++pPacketPool->ClashCount;
#endif

    KeAcquireSpinLock(&pPacketPool->PoolLock, &irql);

#if DBG
    if (pPacketPool->Signature != PACKET_POOL_SIGNATURE) {
        DbgPrint("DLC.DeallocatePacket: Error: Invalid Pool Handle %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    if (!pPacketPool->Viable) {
        DbgPrint("DLC.DeallocatePacket: Error: Unviable Packet Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
    if (pPacketHead->Signature != PACKET_HEAD_SIGNATURE
    || pPacketHead->pPacketPool != pPacketPool
    || !(pPacketHead->Flags & PACKET_FLAGS_BUSY)
    || pPacketHead->Flags & PACKET_FLAGS_FREE) {
        DbgPrint("DLC.DeallocatePacket: Error: Invalid Packet Header %08x, Pool = %08x\n",
                pPacketHead,
                pPacketPool
                );
        DbgBreakPoint();
    }
#endif

    //
    // remove this packet from single linked list on BusyList
    //

    prev = (PSINGLE_LIST_ENTRY)&pPacketPool->BusyList;
    for (p = prev->Next; p; p = p->Next) {
        if (p == (PSINGLE_LIST_ENTRY)pPacketHead) {
            break;
        } else {
            prev = p;
        }
    }

#if DBG
    if (!p) {
        DbgPrint("DLC.DeallocatePacket: Error: packet %08x not on BusyList of pool %08x\n",
                pPacketHead,
                pPacketPool
                );
        DumpPool(pPacketPool);
        DbgBreakPoint();
    }
#endif

    prev->Next = pPacketHead->List.Next;

#if DBG
    if (ZapDeallocatedPackets) {

        //
        // fill the deallocated packet with 'Z's. This will quickly tell us if
        // the packet is still being used after it is deallocated
        //

        RtlFillMemory(pPacketHead + 1, pPacketPool->PacketSize, ZAP_DEALLOC_VALUE);
    }
#endif

    PushEntryList(&pPacketPool->FreeList, (PSINGLE_LIST_ENTRY)pPacketHead);

    //
    // turn off BUSY flag, turn on FREE flag
    //

    pPacketHead->Flags ^= (PACKET_FLAGS_BUSY | PACKET_FLAGS_FREE);

#if DBG
    ++pPacketPool->FreeCount;
    --pPacketPool->BusyCount;
    ++pPacketPool->Frees;
    --pPacketPool->MaxInUse;
//    pPacketHead->CallersAddress_A = (PVOID)-1;
//    pPacketHead->CallersCaller_A = (PVOID)-1;
    GET_CALLERS_ADDRESS(&pPacketHead->CallersAddress_D,
                        &pPacketHead->CallersCaller_D
                        );
#endif

    KeReleaseSpinLock(&pPacketPool->PoolLock, irql);

#if DBG
    --pPacketPool->ClashCount;
    if (pPacketPool->ClashCount) {
        DbgPrint("DLC.DeallocatePacket: Error: Memory allocator clash on exit: Pool %08x\n", pPacketPool);
        DbgBreakPoint();
    }
#endif

}


#if DBG

#ifdef TRACK_DLC_OBJECTS

POBJECT_POOL
CreateObjectPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG SizeOfObject,
    IN ULONG NumberOfObjects
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pMemoryUsage    -
    ObjectType      -
    SizeOfObject    -
    NumberOfObjects -

Return Value:

    POBJECT_POOL

--*/

{
}


VOID
DeleteObjectPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN POBJECT_POOL pObjectPool
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pMemoryUsage    -
    ObjectType      -
    pObjectPool     -

Return Value:

    None.

--*/

{
}


POBJECT_HEAD
AllocatePoolObject(
    IN POBJECT_POOL pObjectPool
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pObjectPool -

Return Value:

    POBJECT_HEAD

--*/

{
}


POBJECT_POOL
FreePoolObject(
    IN DLC_OBJECT_TYPE ObjectType,
    IN POBJECT_HEAD pObjectHead
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    ObjectType  -
    pObjectHead -

Return Value:

    POBJECT_POOL

--*/

{
}

#endif // TRACK_DLC_OBJECTS


VOID
CheckMemoryReturned(
    IN PMEMORY_USAGE pMemoryUsage
    )

/*++

Routine Description:

    Called when a 'handle' which owns a MEMORY_USAGE structure is being closed.
    Checks that all memory has been returned and that number of allocations is
    the same as number of frees

Arguments:

    pMemoryUsage    -  pointer to MEMORY_USAGE structure to check

Return Value:

    None.

--*/

{
    if (pMemoryUsage->AllocateCount != pMemoryUsage->FreeCount || pMemoryUsage->NonPagedPoolAllocated) {
        if (MemoryCheckNotify) {
            if (pMemoryUsage->AllocateCount != pMemoryUsage->FreeCount) {
                DbgPrint("DLC.CheckMemoryReturned: Error: AllocateCount != FreeCount. Usage @ %08x\n",
                         pMemoryUsage
                         );
            } else {
                DbgPrint("DLC.CheckMemoryReturned: Error: NonPagedPoolAllocated != 0. Usage @ %08x\n",
                         pMemoryUsage
                         );
            }
        }
        if (MemoryCheckStop) {
            DumpMemoryUsage(pMemoryUsage, TRUE);
            DbgBreakPoint();
        }
    }
}


VOID
CheckDriverMemoryUsage(
    IN BOOLEAN Break
    )

/*++

Routine Description:

    Checks if the driver has allocated memory & dumps usage to debugger

Arguments:

    Break   - if true && driver has memory, breaks into debugger

Return Value:

    None.

--*/

{
    DbgPrint("DLC.CheckDriverMemoryUsage\n");
    DumpMemoryMetrics();
    if (Break && NonPagedPoolAllocated) {
        if (MemoryCheckNotify) {
            DbgPrint("DLC.CheckDriverMemoryUsage: Error: Driver still has memory allocated\n");
        }
        if (MemoryCheckStop) {
            DbgBreakPoint();
        }
    }
}


VOID MemoryAllocationError(PCHAR Routine, PVOID Address) {
    DbgPrint("DLC.%s: Error: Memory Allocation error in block @ %08x\n", Routine, Address);
    DumpMemoryMetrics();
    DbgBreakPoint();
}

VOID UpdateCounter(PULONG pCounter, LONG Value) {
    if (Value > 0) {
        if (*pCounter + Value < *pCounter) {
            MemoryCounterOverflow(pCounter, Value);
        }
    } else {
        if (*pCounter + Value > *pCounter) {
            MemoryCounterOverflow(pCounter, Value);
        }
    }
    *pCounter += Value;
}

VOID MemoryCounterOverflow(PULONG pCounter, LONG Value) {
    DbgPrint("DLC: Memory Counter Overflow: &Counter=%08x, Count=%d, Value=%d\n",
            pCounter,
            *pCounter,
            Value
            );
    DumpMemoryMetrics();
}

VOID DumpMemoryMetrics() {
    DbgPrint("DLC Device Driver Non-Paged Pool Usage:\n"
             "\tNumber Of Good Non-Paged Pool Allocations. : %d\n"
             "\tNumber Of Bad  Non-Paged Pool Allocations. : %d\n"
             "\tNumber Of Good Non-Paged Pool Frees. . . . : %d\n"
             "\tNumber Of Bad  Non-Paged Pool Frees. . . . : %d\n",
             GoodNonPagedPoolAllocs,
             BadNonPagedPoolAllocs,
             GoodNonPagedPoolFrees,
             BadNonPagedPoolFrees
             );
    DbgPrint("\tTotal Non-Paged Pool Currently Requested . : %d\n"
             "\tTotal Non-Paged Pool Currently Allocated . : %d\n"
             "\tCumulative Total Non-Paged Pool Requested. : %d\n"
             "\tCumulative Total Non-Paged Pool Allocated. : %d\n"
             "\tCumulative Total Non-Paged Pool Freed. . . : %d\n"
             "\n",
             NonPagedPoolRequested,
             NonPagedPoolAllocated,
             TotalNonPagedPoolRequested,
             TotalNonPagedPoolAllocated,
             TotalNonPagedPoolFreed
             );
     DumpMemoryUsageList();
}

VOID DumpPoolStats(PCHAR Routine, PPACKET_POOL pPacketPool) {
    if (!DebugDump) {
        return;
    }
    DbgPrint("DLC.%s: Stats For Pool %08x:\n"
             "\tPool Owner . . . . . . . . . . . . . . . . . . . : %08x\n"
             "\tPool Owner Object ID . . . . . . . . . . . . . . : %08x [%s]\n",
             Routine,
             pPacketPool,
             pPacketPool->pMemoryUsage->Owner,
             pPacketPool->pMemoryUsage->OwnerObjectId,
             MapObjectId(pPacketPool->pMemoryUsage->OwnerObjectId)
             );
    DbgPrint("\tFree List. . . . . . . . . . . . . . . . . . . . : %08x\n"
             "\tBusy List. . . . . . . . . . . . . . . . . . . . : %08x\n",
             pPacketPool->FreeList,
             pPacketPool->BusyList
             );
    DbgPrint("\tPacket Size. . . . . . . . . . . . . . . . . . . : %d\n"
             "\tOriginal Number Of Packets In Pool . . . . . . . : %d\n"
             "\tCurrent Number Of Packets In Pool. . . . . . . . : %d\n"
             "\tNumber Of Allocations From Pool. . . . . . . . . : %d\n"
             "\tNumber Of Deallocations To Pool. . . . . . . . . : %d\n"
             "\tNumber Of Times No Available Packets On Allocate : %d\n"
             "\tMax. Number Of Packets Allocated At Any One Time : %d\n"
             "\tNumber Of Packets On Free List . . . . . . . . . : %d\n"
             "\tNumber Of Packets On Busy List . . . . . . . . . : %d\n"
             "\n",
             pPacketPool->PacketSize,
             pPacketPool->OriginalPacketCount,
             pPacketPool->CurrentPacketCount,
             pPacketPool->Allocations,
             pPacketPool->Frees,
             pPacketPool->NoneFreeCount,
             pPacketPool->MaxInUse,
             pPacketPool->FreeCount,
             pPacketPool->BusyCount
             );
    DumpMemoryUsage(&pPacketPool->MemoryUsage, FALSE);
}

PCHAR MapObjectId(DLC_OBJECT_TYPE ObjectType) {
    switch (ObjectType) {
    case DlcDriverObject:
        return "DlcDriverObject";

    case FileContextObject:
        return "FileContextObject";

    case AdapterContextObject:
        return "AdapterContextObject";

    case BindingContextObject:
        return "BindingContextObject";

    case DlcSapObject:
        return "DlcSapObject";

    case DlcGroupSapObject:
        return "DlcGroupSapObject";

    case DlcLinkObject:
        return "DlcLinkObject";

    case DlcDixObject:
        return "DlcDixObject";

    case LlcDataLinkObject:
        return "LlcDataLinkObject";

    case LLcDirectObject:
        return "LLcDirectObject";

    case LlcSapObject:
        return "LlcSapObject";

    case LlcGroupSapObject:
        return "LlcGroupSapObject";

    case DlcBufferPoolObject:
        return "DlcBufferPoolObject";

    case DlcLinkPoolObject:
        return "DlcLinkPoolObject";

    case DlcPacketPoolObject:
        return "DlcPacketPoolObject";

    case LlcLinkPoolObject:
        return "LlcLinkPoolObject";

    case LlcPacketPoolObject:
        return "LlcPacketPoolObject";

    default:
        return "*** UNKNOWN OBJECT TYPE ***";
    }
}

VOID DumpPool(PPACKET_POOL pPacketPool) {
    if (!DebugDump) {
        return;
    }
    DumpPoolStats("DumpPool", pPacketPool);
    DumpPoolList("Free", &pPacketPool->FreeList);
    DumpPoolList("Busy", &pPacketPool->BusyList);
}

VOID DumpPoolList(PCHAR Name, PSINGLE_LIST_ENTRY List) {

    ULONG count = 0;

    if (List->Next) {
        DbgPrint("\n%s List @ %08x:\n", Name,  List);
        while (List->Next) {
            List = List->Next;
            DumpPacketHead((PPACKET_HEAD)List, ++count);
        }
    } else {
        DbgPrint("%s List is EMPTY\n\n", Name);
    }
}

VOID DumpPacketHead(PPACKET_HEAD pPacketHead, ULONG Number) {

    CHAR numbuf[5];

    if (!DebugDump) {
        return;
    }
    if (Number) {

        int i;
        ULONG div = 1000;   // 1000 packets in a pool?

        while (!(Number / div)) {
            div /= 10;
        }
        for (i = 0; Number; ++i) {
            numbuf[i] = (CHAR)('0' + Number / div);
            Number %= div;
            div /= 10;
        }
        numbuf[i] = 0;
        Number = 1; // flag
    }
    DbgPrint("%s\tPACKET_HEAD @ %08x:\n"
             "\tList . . . . . . . . : %08x\n"
             "\tFlags. . . . . . . . : %08x\n"
             "\tSignature. . . . . . : %08x\n"
             "\tpPacketPool. . . . . : %08x\n"
             "\tCallers Address (A). : %08x\n"
             "\tCallers Caller (A) . : %08x\n"
             "\tCallers Address (D). : %08x\n"
             "\tCallers Caller (D) . : %08x\n"
             "\n",
             Number ? numbuf : "",
             pPacketHead,
             pPacketHead->List,
             pPacketHead->Flags,
             pPacketHead->Signature,
             pPacketHead->pPacketPool,
             pPacketHead->CallersAddress_A,
             pPacketHead->CallersCaller_A,
             pPacketHead->CallersAddress_D,
             pPacketHead->CallersCaller_D
             );
}

VOID DumpMemoryUsageList() {

    PMEMORY_USAGE pMemoryUsage;
    KIRQL irql;
    BOOLEAN allocatedMemoryFound = FALSE;

    KeAcquireSpinLock(&MemoryUsageLock, &irql);
    for (pMemoryUsage = MemoryUsageList; pMemoryUsage; pMemoryUsage = pMemoryUsage->List) {
        if (pMemoryUsage->NonPagedPoolAllocated) {
            allocatedMemoryFound = TRUE;
            DbgPrint("DLC.DumpMemoryUsageList: %08x: %d bytes memory allocated\n",
                    pMemoryUsage,
                    pMemoryUsage->NonPagedPoolAllocated
                    );
            DumpMemoryUsage(pMemoryUsage, FALSE);
        }
    }
    KeReleaseSpinLock(&MemoryUsageLock, irql);
    if (!allocatedMemoryFound) {
        DbgPrint("DLC.DumpMemoryUsageList: No allocated memory found\n");
    }
}

VOID DumpMemoryUsage(PMEMORY_USAGE pMemoryUsage, BOOLEAN Override) {
    if (!DebugDump && !Override) {
        return;
    }
    DbgPrint("MEMORY_USAGE @ %08x:\n"
             "\tOwner. . . . . . . . . . . . . : %08x\n"
             "\tOwner Object ID. . . . . . . . : %08x [%s]\n"
             "\tOwner Instance . . . . . . . . : %x\n",
             pMemoryUsage,
             pMemoryUsage->Owner,
             pMemoryUsage->OwnerObjectId,
             MapObjectId(pMemoryUsage->OwnerObjectId),
             pMemoryUsage->OwnerInstance
             );
    DbgPrint("\tNon Paged Pool Allocated . . . : %d\n"
             "\tNumber Of Allocations. . . . . : %d\n"
             "\tNumber Of Frees. . . . . . . . : %d\n"
             "\tPrivate Allocation List Flink. : %08x\n"
             "\tPrivate Allocation List Blink. : %08x\n"
             "\n",
             pMemoryUsage->NonPagedPoolAllocated,
             pMemoryUsage->AllocateCount,
             pMemoryUsage->FreeCount,
             pMemoryUsage->PrivateList.Flink,
             pMemoryUsage->PrivateList.Blink
             );
}

VOID
CollectReturnAddresses(
    OUT PVOID* ReturnAddresses,
    IN ULONG AddressesToCollect,
    IN ULONG AddressesToSkip
    )
{
    PVOID* ebp = (PVOID*)*(PVOID**)&ReturnAddresses - 2;

    while (AddressesToSkip--) {
        GetLastReturnAddress(&ebp);
    }
    while (AddressesToCollect--) {
        *ReturnAddresses++ = GetLastReturnAddress(&ebp);
    }
}

PVOID* GetLastReturnAddress(PVOID** pEbp) {

    PVOID* returnAddress = *(*pEbp + 1);

    *pEbp = **pEbp;
    return returnAddress;
}

#ifdef i386
VOID x86SleazeCallersAddress(PVOID* pCaller, PVOID* pCallerCaller) {

    //
    // this only works on x86 and only if not fpo functions!
    //

    PVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallerCaller = *(ebp + 1);
}
#endif

BOOLEAN VerifyElementOnList(PSINGLE_LIST_ENTRY List, PSINGLE_LIST_ENTRY Element) {
    while (List) {
        if (List == Element) {
            return TRUE;
        }
        List = List->Next;
    }
    return FALSE;
}

VOID CheckList(PSINGLE_LIST_ENTRY List, ULONG NumberOfElements) {

    PSINGLE_LIST_ENTRY originalList = List;

    while (NumberOfElements--) {
        if (List->Next == NULL) {
            DbgPrint("DLC.CheckList: Error: too few entries on list %08x\n", originalList);
            DbgBreakPoint();
        } else {
            List = List->Next;
        }
    }
    if (List->Next != NULL) {
        DbgPrint("DLC.CheckList: Error: too many entries on list %08x\n", originalList);
        DbgBreakPoint();
    }
}

VOID CheckEntryOnList(PLIST_ENTRY Entry, PLIST_ENTRY List, BOOLEAN Sense) {

    BOOLEAN found = FALSE;
    PLIST_ENTRY p;

    if (!IsListEmpty(List)) {
        for (p = List->Flink; p != List; p = p->Flink) {
            if (p == Entry) {
                found = TRUE;
                break;
            }
        }
    }
    if (found != Sense) {
        if (found) {
            DbgPrint("DLC.CheckEntryOnList: Error: Entry %08x found on list %08x. Not supposed to be there\n",
                     Entry,
                     List
                     );
        } else {
            DbgPrint("DLC.CheckEntryOnList: Error: Entry %08x not found on list %08x\n",
                     Entry,
                     List
                     );
        }
        if (MemoryCheckStop) {
            DbgBreakPoint();
        }
    }
}

VOID DumpPrivateMemoryHeader(PPRIVATE_NON_PAGED_POOL_HEAD pHead) {
    DbgPrint("Private Non Paged Pool Header @ %08x:\n"
             "\tSize . . . . . . . : %d\n"
             "\tOriginal Size. . . : %d\n"
             "\tFlags. . . . . . . : %08x\n"
             "\tSignature. . . . . : %08x\n"
             "\tGlobalList.Flink . : %08x\n"
             "\tGlobalList.Blink . : %08x\n"
             "\tPrivateList.Flink. : %08x\n"
             "\tPrivateList.Blink. : %08x\n"
             "\tStack[0] . . . . . : %08x\n"
             "\tStack[1] . . . . . : %08x\n"
             "\tStack[2] . . . . . : %08x\n"
             "\tStack[3] . . . . . : %08x\n"
             "\n",
             pHead->Size,
             pHead->OriginalSize,
             pHead->Flags,
             pHead->Signature,
             pHead->GlobalList.Flink,
             pHead->GlobalList.Blink,
             pHead->PrivateList.Flink,
             pHead->PrivateList.Blink,
             pHead->Stack[0],
             pHead->Stack[1],
             pHead->Stack[2],
             pHead->Stack[3]
             );
}

VOID ReportSwitchSettings(PSTR str) {
    DbgPrint("%s: LLCMEM Switches:\n"
             "\tDebugDump . . . . . . : %s\n"
             "\tDeleteBusyListAnyway. : %s\n"
             "\tMemoryCheckNotify . . : %s\n"
             "\tMemoryCheckStop . . . : %s\n"
             "\tMaintainGlobalLists . : %s\n"
             "\tMaintainPrivateLists. : %s\n"
             "\tZapDeallocatedPackets : %s\n"
             "\tZapFreedMemory. . . . : %s\n"
             "\n",
             str,
             YES_NO(DebugDump),
             YES_NO(DeleteBusyListAnyway),
             YES_NO(MemoryCheckNotify),
             YES_NO(MemoryCheckStop),
             YES_NO(MaintainGlobalLists),
             YES_NO(MaintainPrivateLists),
             YES_NO(ZapDeallocatedPackets),
             YES_NO(ZapFreedMemory)
             );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\dlc\driver\llcmem.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    llcmem.h

Abstract:

    Contains type and structure definitions and routine prototypes and macros
    for llcmem.c. To aid in tracking memory resources, DLC/LLC now delineates
    the following memory categories:

        Memory
            - arbitrary sized blocks allocated out of non-paged pool using
              ExAllocatePool(NonPagedPool, ...)

        ZeroMemory
            - arbitrary sized blocks allocated out of non-paged pool using
              ExAllocatePool(NonPagedPool, ...) and initialized to zeroes

        Pool
            - small sets of (relatively) small packets are allocated in one
              block from Memory or ZeroMemory as a Pool and then subdivided
              into packets

        Object
            - structures which may be packets allocated from Pool which have
              a known size and initialization values. Pseudo-category mainly
              for debugging purposes

Author:

    Richard L Firth (rfirth) 10-Mar-1993

Environment:

    kernel mode only.

Revision History:

    09-Mar-1993 RFirth
        Created

--*/

#ifndef _LLCMEM_H_
#define _LLCMEM_H_

#define DLC_POOL_TAG    ' CLD'

//
// the following types and defines are for the debug version of the driver, but
// need to be defined for the non-debug version too (not used, just defined)
//

//
// In the DEBUG version of DLC, we treat various chunks of memory as 'objects'.
// This serves the following purposes:
//
//  1.  We use a signature DWORD, so that when looking at some DLC structure in
//      the debugger, we can quickly check if what we are looking at is what we
//      think it is. E.g., if you spot a block of memory with a "BIND" signature
//      where an "ADAPTER" signature should be, then there is a good chance a
//      list or pointer has gotten messed up. The idea is to try and reduce
//      the amount of time it can take to guess what you're looking at
//
//  2.  We use consistency checks: If a routine is handed a pointer to a structure
//      which is supposed to be a FILE_CONTEXT structure, we can check the
//      signature and quickly determine if something has gone wrong (like the
//      structure has already been freed and the signature contains 0xDAADF00D
//
//  3.  We maintain size, head and tail signature information to determine
//      whether we have overwritten any part of an object. This is part of the
//      consistency check
//
// The object definitions should occur in one place only, but DLC is such a mess
// that it would be a non-trivial amount of work to clean everything up. Do it
// if there's time... (he said, knowing full well there's never any 'time')
//

typedef enum {
    DlcDriverObject = 0xCC002001,   // start off with a relatively unique id
    FileContextObject,              // 0xCC002002
    AdapterContextObject,           // 0xCC002003
    BindingContextObject,           // 0xCC002004
    DlcSapObject,                   // 0xCC002005
    DlcGroupSapObject,              // 0xCC002006
    DlcLinkObject,                  // 0xCC002007
    DlcDixObject,                   // 0xCC002008
    LlcDataLinkObject,              // 0xCC002009
    LLcDirectObject,                // 0xCC00200A
    LlcSapObject,                   // 0xCC00200B
    LlcGroupSapObject,              // 0xCC00200C
    DlcBufferPoolObject,            // 0xCC00200D
    DlcLinkPoolObject,              // 0xCC00200E
    DlcPacketPoolObject,            // 0xCC00200F
    LlcLinkPoolObject,              // 0xCC002010
    LlcPacketPoolObject             // 0xCC002011
} DLC_OBJECT_TYPE;

typedef struct {
    ULONG Signature;                // human-sensible signature when DB'd
    DLC_OBJECT_TYPE Type;           // object identifier
    ULONG Size;                     // size of this object/structure in bytes
    ULONG Extra;                    // additional size over basic object size
} OBJECT_ID, *POBJECT_ID;

#define SIGNATURE_FILE      0x454C4946  // "FILE"
#define SIGNATURE_ADAPTER   0x50414441  // "ADAP"
#define SIGNATURE_BINDING   0x444E4942  // "BIND"
#define SIGNATURE_DLC_SAP   0x44504153  // "SAPD"
#define SIGNATURE_DLC_LINK  0x4B4E494C  // "LINK"
#define SIGNATURE_DIX       0x44584944  // "DIXD"
#define SIGNATURE_LLC_LINK  0x41544144  // "DATA"
#define SIGNATURE_LLC_SAP   0x4C504153  // "SAPL"

#define ZAP_DEALLOC_VALUE   0x5A        // "Z"
#define ZAP_EX_FREE_VALUE   0x58        // "X"

//
// we try to keep track of memory allocations by subdividing them into driver
// and handle categories. The first charges memory allocated to the driver -
// e.g. a file context 'object'. Once we have open file handles, then allocations
// are charged to them
//

typedef enum {
    ChargeToDriver,
    ChargeToHandle
} MEMORY_CHARGE;

//
// MEMORY_USAGE - collection of variables used for charging memory. Accessed
// within spinlock
//

typedef struct _MEMORY_USAGE {
    struct _MEMORY_USAGE* List;     // pointer to next MEMORY_USAGE structure
    KSPIN_LOCK SpinLock;            // stop alloc & free clashing?
    PVOID Owner;                    // pointer to owning structure/object
    DLC_OBJECT_TYPE OwnerObjectId;  // identifies who owns this charge
    ULONG OwnerInstance;            // instance of type of owner
    ULONG NonPagedPoolAllocated;    // actual amount of non-paged pool charged
    ULONG AllocateCount;            // number of calls to allocate non-paged pool
    ULONG FreeCount;                // number of calls to free non-paged pool
    LIST_ENTRY PrivateList;         // list of allocated blocks owned by this usage
    ULONG Unused[2];                // pad to 16-byte boundary
} MEMORY_USAGE, *PMEMORY_USAGE;

//
// PACKET_POOL - this structure describes a packet pool. A packet pool is a
// collection of same-sized packets. The pool starts off with an initial number
// of packets on the FreeList. As packets are allocated, they are put on the
// BusyList and the reverse happens when the packets are deallocated. If there
// are no packets on the FreeList when an allocation call is made, more memory
// is allocated
//

typedef struct {

    SINGLE_LIST_ENTRY FreeList; // list of available packets
    SINGLE_LIST_ENTRY BusyList; // list of in-use packets
    KSPIN_LOCK PoolLock;        // stops simultaneous accesses breaking list(s)
    ULONG PacketSize;           // size of individual packets

    //
    // the following 2 fields are here because DLC is a piece of garbage. It
    // keeps hold of allocated packets even after the pool as been deleted.
    // This leads to pool corruption. So if we determine packets are still
    // allocated when the pool is deleted, we remove the pool from whatever
    // 'object' it is currently stuck to, lamprey-like, and add it to the
    // ZombieList. When we next deallocate packets from this pool (assuming that
    // DLC at least bothers to do this), we check the zombie state. If ImAZombie
    // is TRUE (actually its true to say for the whole DLC device driver) AND
    // we are deallocating the last packet in the pool then we really delete
    // the pool
    //

//    SINGLE_LIST_ENTRY UndeadList;
//    BOOLEAN ImAZombie;

#if DBG

    //
    // keep some metrics in the debug version to let us know if the pool is
    // growing
    //

    ULONG Signature;            // 0x4C4F4F50 "POOL"
    ULONG Viable;               // !0 if this pool is valid
    ULONG OriginalPacketCount;  // number of packets requested
    ULONG CurrentPacketCount;   // total number in pool
    ULONG Allocations;          // number of calls to allocate from this pool
    ULONG Frees;                // number of calls to free to pool
    ULONG NoneFreeCount;        // number of times allocate call made when no packets free
    ULONG MaxInUse;             // maximum number allocated at any one time
    ULONG ClashCount;           // number of simultaneous accesses to pool
    ULONG Flags;                // type of pool etc.
    ULONG ObjectSignature;      // signature for checking contents if object pool
    PMEMORY_USAGE pMemoryUsage; // pointer to memory equivalent of Discover card
    MEMORY_USAGE MemoryUsage;   // pool's memory usage charge
    ULONG FreeCount;            // number of entries on FreeList
    ULONG BusyCount;            // number of entries on BusyList
    ULONG Pad1;
    ULONG Pad2;

#endif

} PACKET_POOL, *PPACKET_POOL;

//
// PACKET_POOL defines and flags
//

#define PACKET_POOL_SIGNATURE   0x4C4F4F50  // "POOL"

#define POOL_FLAGS_IN_USE       0x00000001
#define POOL_FLAGS_OBJECT       0x00000002

//
// OBJECT_POOL - synonym for PACKET_POOL. Used in debug version (named 'objects'
// in debug version have an object signature as an aide a debugoire and as
// consistency check)
//

#define OBJECT_POOL PACKET_POOL
#define POBJECT_POOL PPACKET_POOL

//
// PACKET_HEAD - each packet which exists in a PACKET_POOL has this header -
// it links the packet onto the Free or Busy lists and the Flags word contains
// the state of the packet
//

typedef struct {

    SINGLE_LIST_ENTRY List;     // standard single-linked list
    ULONG Flags;

#if DBG

    ULONG Signature;            // 0x44414548 "HEAD"
    PVOID pPacketPool;          // owning pool
    PVOID CallersAddress_A;     // caller - allocation
    PVOID CallersCaller_A;
    PVOID CallersAddress_D;     // caller - deallocation
    PVOID CallersCaller_D;

#endif

} PACKET_HEAD, *PPACKET_HEAD;

//
// PACKET_HEAD defines and flags
//

#define PACKET_HEAD_SIGNATURE   0x44414548  // "HEAD"

#define PACKET_FLAGS_BUSY       0x00000001  // packet should be on BusyList
#define PACKET_FLAGS_POST_ALLOC 0x00000002  // this packet was allocated because
                                            // the pool was full
#define PACKET_FLAGS_FREE       0x00000080  // packet should be on FreeList

//
// OBJECT_HEAD - synonym for PACKET_HEAD. Used in debug version (named 'objects'
// in debug version have an object signature as an aide a debugoire and as
// consistency check)
//

#define OBJECT_HEAD PACKET_HEAD
#define POBJECT_HEAD PPACKET_HEAD


#if DBG

//
// anything we allocate from non-paged pool gets the following header pre-pended
// to it
//

typedef struct {
    ULONG Size;                 // inclusive size of allocated block (inc head+tail)
    ULONG OriginalSize;         // requested size
    ULONG Flags;                // IN_USE flag
    ULONG Signature;            // for checking validity of header
    LIST_ENTRY GlobalList;      // all blocks allocated on one list
    LIST_ENTRY PrivateList;     // blocks owned by MemoryUsage
    PVOID Stack[4];             // stack of return addresses
} PRIVATE_NON_PAGED_POOL_HEAD, *PPRIVATE_NON_PAGED_POOL_HEAD;

#define MEM_FLAGS_IN_USE    0x00000001

#define SIGNATURE1  0x41434C44  // "DLCA" when viewed via db/dc
#define SIGNATURE2  0x434F4C4C  // "LLOC"  "      "    "  "

//
// anything we allocate from non-paged pool has the following tail appended to it
//

typedef struct {
    ULONG Size;                 // inclusive size; must be same as in header
    ULONG Signature;            // for checking validity of tail
    ULONG Pattern1;
    ULONG Pattern2;
} PRIVATE_NON_PAGED_POOL_TAIL, *PPRIVATE_NON_PAGED_POOL_TAIL;

#define PATTERN1    0x55AA6699
#define PATTERN2    0x11EECC33

//
// standard object identifier. Expands to nothing on free build
//

#define DBG_OBJECT_ID   OBJECT_ID ObjectId

//
// globally accessible memory
//

extern MEMORY_USAGE DriverMemoryUsage;
extern MEMORY_USAGE DriverStringUsage;

//
// debug prototypes
//

VOID
InitializeMemoryPackage(
    VOID
    );

PSINGLE_LIST_ENTRY
PullEntryList(
    IN PSINGLE_LIST_ENTRY List,
    IN PSINGLE_LIST_ENTRY Element
    );

VOID
LinkMemoryUsage(
    IN PMEMORY_USAGE pMemoryUsage
    );

VOID
UnlinkMemoryUsage(
    IN PMEMORY_USAGE pMemoryUsage
    );

//
// the following 2 functions expand to be ExAllocatePoolWithTag(NonPagedPool, ...)
// and ExFreePool(...) resp. in the retail/Free version of the driver
//

PVOID
AllocateMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size
    );

PVOID
AllocateZeroMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN ULONG Size
    );

VOID
DeallocateMemory(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID Pointer
    );

PPACKET_POOL
CreatePacketPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID pOwner,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG PacketSize,
    IN ULONG NumberOfPackets
    );

VOID
DeletePacketPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PPACKET_POOL* pPacketPool
    );

PVOID
AllocateObject(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG ObjectSize
    );

VOID
FreeObject(
    IN PMEMORY_USAGE pMemoryUsage,
    IN PVOID pObject,
    IN DLC_OBJECT_TYPE ObjectType
    );

VOID
ValidateObject(
    IN POBJECT_ID pObject,
    IN DLC_OBJECT_TYPE ObjectType
    );

POBJECT_POOL
CreateObjectPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN ULONG ObjectSize,
    IN ULONG NumberOfObjects
    );

VOID
DeleteObjectPool(
    IN PMEMORY_USAGE pMemoryUsage,
    IN DLC_OBJECT_TYPE ObjectType,
    IN POBJECT_POOL pObjectPool
    );

POBJECT_HEAD
AllocatePoolObject(
    IN POBJECT_POOL pObjectPool
    );

VOID
DeallocatePoolObject(
    IN POBJECT_POOL pObjectPool,
    IN POBJECT_HEAD pObjectHead
    );

VOID
CheckMemoryReturned(
    IN PMEMORY_USAGE pMemoryUsage
    );

VOID
CheckDriverMemoryUsage(
    IN BOOLEAN Break
    );

//
// CHECK_DRIVER_MEMORY_USAGE - if (b) breaks into debugger if there is still
// memory allocated to driver
//

#define CHECK_DRIVER_MEMORY_USAGE(b) \
    CheckDriverMemoryUsage(b)

//
// CHECK_MEMORY_RETURNED_DRIVER - checks if all charged memory allocation has been
// refunded to the driver
//

#define CHECK_MEMORY_RETURNED_DRIVER() \
    CheckMemoryReturned(&DriverMemoryUsage)

//
// CHECK_MEMORY_RETURNED_FILE - checks if all charged memory allocation has been
// refunded to the FILE_CONTEXT
//

#define CHECK_MEMORY_RETURNED_FILE() \
    CheckMemoryReturned(&pFileContext->MemoryUsage)

//
// CHECK_MEMORY_RETURNED_ADAPTER - checks if all charged memory allocation has been
// refunded to the ADAPTER_CONTEXT
//

#define CHECK_MEMORY_RETURNED_ADAPTER() \
    CheckMemoryReturned(&pAdapterContext->MemoryUsage)

//
// CHECK_STRING_RETURNED_DRIVER - checks if all charged string allocation has been
// refunded to the driver
//

#define CHECK_STRING_RETURNED_DRIVER() \
    CheckMemoryReturned(&DriverStringUsage)

//
// CHECK_STRING_RETURNED_ADAPTER - checks if all charged string allocation has been
// refunded to the ADAPTER_CONTEXT
//

#define CHECK_STRING_RETURNED_ADAPTER() \
    CheckMemoryReturned(&pAdapterContext->StringUsage)

//
// memory allocators which charge memory usage to the driver
//

//
// ALLOCATE_MEMORY_DRIVER - allocates (n) bytes of memory and charges it to the
// driver
//

#define ALLOCATE_MEMORY_DRIVER(n) \
    AllocateMemory(&DriverMemoryUsage, (ULONG)(n))

//
// ALLOCATE_ZEROMEMORY_DRIVER - allocates (n) bytes of ZeroMemory and charges
// it to the driver
//

#define ALLOCATE_ZEROMEMORY_DRIVER(n) \
    AllocateZeroMemory(&DriverMemoryUsage, (ULONG)(n))

//
// FREE_MEMORY_DRIVER - deallocates memory and refunds it to the driver
//

#define FREE_MEMORY_DRIVER(p) \
    DeallocateMemory(&DriverMemoryUsage, (PVOID)(p))

//
// ALLOCATE_STRING_DRIVER - allocate memory for string usage. Charge to
// DriverStringUsage
//

#define ALLOCATE_STRING_DRIVER(n) \
    AllocateZeroMemory(&DriverStringUsage, (ULONG)(n))

//
// FREE_STRING_DRIVER - deallocates memory and refunds it to driver string usage
//

#define FREE_STRING_DRIVER(p) \
    DeallocateMemory(&DriverStringUsage, (PVOID)(p))

//
// CREATE_PACKET_POOL_DRIVER - calls CreatePacketPool and charges the pool
// structure to the driver
//

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_DRIVER(t, s, n) \
    CreatePacketPool(&DriverMemoryUsage,\
                    NULL,\
                    (t),\
                    (ULONG)(s),\
                    (ULONG)(n))

//
// DELETE_PACKET_POOL_DRIVER - calls DeletePacketPool and refunds the pool
// structure to the driver
//

#define DELETE_PACKET_POOL_DRIVER(p) \
    DeletePacketPool(&DriverMemoryUsage, (PPACKET_POOL*)(p))

#endif  // NO_POOLS

//
// memory allocators which charge memory usage to an ADAPTER_CONTEXT
//

//
// ALLOCATE_MEMORY_ADAPTER - allocates (n) bytes of memory and charges it to the
// ADAPTER_CONTEXT
//

#define ALLOCATE_MEMORY_ADAPTER(n) \
    AllocateMemory(&pAdapterContext->MemoryUsage, (ULONG)(n))

//
// ALLOCATE_ZEROMEMORY_ADAPTER - allocates (n) bytes of ZeroMemory and charges
// it to the ADAPTER_CONTEXT
//

#define ALLOCATE_ZEROMEMORY_ADAPTER(n) \
    AllocateZeroMemory(&pAdapterContext->MemoryUsage, (ULONG)(n))

//
// FREE_MEMORY_ADAPTER - deallocates memory and refunds it to the ADAPTER_CONTEXT
//

#define FREE_MEMORY_ADAPTER(p) \
    DeallocateMemory(&pAdapterContext->MemoryUsage, (PVOID)(p))

//
// ALLOCATE_STRING_ADAPTER - allocate memory for string usage. Charge to
// pAdapterContext StringUsage
//

#define ALLOCATE_STRING_ADAPTER(n) \
    AllocateZeroMemory(&pAdapterContext->StringUsage, (ULONG)(n))

//
// CREATE_PACKET_POOL_ADAPTER - calls CreatePacketPool and charges the pool
// structure to the adapter structure
//

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_ADAPTER(t, s, n) \
    CreatePacketPool(&pAdapterContext->MemoryUsage,\
                    (PVOID)pAdapterContext,\
                    (t),\
                    (ULONG)(s),\
                    (ULONG)(n))

//
// DELETE_PACKET_POOL_ADAPTER - calls DeletePacketPool and refunds the pool
// structure to the adapter structure
//

#define DELETE_PACKET_POOL_ADAPTER(p) \
    DeletePacketPool(&pAdapterContext->MemoryUsage, (PPACKET_POOL*)(p))

#endif  // NO_POOLS

//
// memory allocators which charge memory usage to a FILE_CONTEXT
//

//
// ALLOCATE_MEMORY_FILE - allocates (n) bytes of memory and charges it to the file
// handle
//

#define ALLOCATE_MEMORY_FILE(n) \
    AllocateMemory(&pFileContext->MemoryUsage, (ULONG)(n))

//
// ALLOCATE_ZEROMEMORY_FILE - allocates (n) bytes ZeroMemory and charges it to the
// file handle
//

#define ALLOCATE_ZEROMEMORY_FILE(n) \
    AllocateZeroMemory(&pFileContext->MemoryUsage, (ULONG)(n))

//
// FREE_MEMORY_FILE - deallocates memory and refunds it to the file handle
//

#define FREE_MEMORY_FILE(p) \
    DeallocateMemory(&pFileContext->MemoryUsage, (PVOID)(p))

//
// CREATE_PACKET_POOL_FILE - calls CreatePacketPool and charges the pool structure
// to the file handle
//

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_FILE(t, s, n) \
    CreatePacketPool(&pFileContext->MemoryUsage,\
                    (PVOID)pFileContext,\
                    (t),\
                    (ULONG)(s),\
                    (ULONG)(n))

//
// DELETE_PACKET_POOL_FILE - calls DeletePacketPool and refunds the pool structure
// to the file handle
//

#define DELETE_PACKET_POOL_FILE(p) \
    DeletePacketPool(&pFileContext->MemoryUsage, (PPACKET_POOL*)(p))

#endif  // NO_POOLS

//
// VALIDATE_OBJECT - check that an 'object' is really what it supposed to be.
// Rudimentary check based on object signature and object type fields
//

#define VALIDATE_OBJECT(p, t)           ValidateObject(p, t)

#define LINK_MEMORY_USAGE(p)        LinkMemoryUsage(&(p)->MemoryUsage)
#define UNLINK_MEMORY_USAGE(p)      UnlinkMemoryUsage(&(p)->MemoryUsage)
#define UNLINK_STRING_USAGE(p)      UnlinkMemoryUsage(&(p)->StringUsage)

#else   // !DBG

//
// DBG_OBJECT_ID in retail version structures is non-existent
//

#define DBG_OBJECT_ID

//
// the non-zero-initialized memory allocator is just a call to ExAllocatePoolWithTag
//

#define AllocateMemory(n)           ExAllocatePoolWithTag(NonPagedPool, (n), DLC_POOL_TAG)

//
// AllocateZeroMemory doesn't count memory usage in non-debug version
//

PVOID
AllocateZeroMemory(
    IN ULONG Size
    );

//
// the memory deallocator is just a call to ExFreePool
//

#define DeallocateMemory(p)         ExFreePool(p)

//
// CreatePacketPool doesn't count memory usage in non-debug version
//

PPACKET_POOL
CreatePacketPool(
    IN ULONG PacketSize,
    IN ULONG NumberOfPackets
    );

VOID
DeletePacketPool(
    IN PPACKET_POOL* pPacketPool
    );

//
// solitary objects in debug version are non-paged pool in retail version
//

#define AllocateObject(n)           AllocateZeroMemory(n)
#define DeallocateObject(p)         DeallocateMemory(p)

//
// pooled objects in debug version are pooled packets in retail version
//

#define CreateObjectPool(o, s, n)   CreatePacketPool(s, n)
#define DeleteObjectPool(p)         DeletePacketPool(p)
#define AllocatePoolObject(p)       AllocatePacket(p)
#define DeallocatePoolObject(p, h)  DeallocatePacket(p)

//
// non-debug build no-op macros
//

#define CHECK_MEMORY_RETURNED_DRIVER()
#define CHECK_MEMORY_RETURNED_FILE()
#define CHECK_MEMORY_RETURNED_ADAPTER()
#define CHECK_STRING_RETURNED_DRIVER()
#define CHECK_STRING_RETURNED_ADAPTER()
#define CHECK_DRIVER_MEMORY_USAGE(b)

//
// non-memory-charging versions of allocation/free macros
//

#define ALLOCATE_MEMORY_DRIVER(n)           AllocateMemory((ULONG)(n))
#define ALLOCATE_ZEROMEMORY_DRIVER(n)       AllocateZeroMemory((ULONG)(n))
#define FREE_MEMORY_DRIVER(p)               DeallocateMemory((PVOID)(p))
#define ALLOCATE_STRING_DRIVER(n)           AllocateZeroMemory((ULONG)(n))
#define FREE_STRING_DRIVER(p)               DeallocateMemory((PVOID)(p))

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_DRIVER(t, s, n)  CreatePacketPool((ULONG)(s), (ULONG)(n))
#define DELETE_PACKET_POOL_DRIVER(p)        DeletePacketPool((PPACKET_POOL*)(p))

#endif  // NO_POOLS

#define ALLOCATE_MEMORY_ADAPTER(n)          AllocateMemory((ULONG)(n))
#define ALLOCATE_ZEROMEMORY_ADAPTER(n)      AllocateZeroMemory((ULONG)(n))
#define FREE_MEMORY_ADAPTER(p)              DeallocateMemory((PVOID)(p))
#define ALLOCATE_STRING_ADAPTER(n)          AllocateZeroMemory((ULONG)(n))

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_ADAPTER(t, s, n) CreatePacketPool((s), (n))
#define DELETE_PACKET_POOL_ADAPTER(p)       DeletePacketPool((PPACKET_POOL*)(p))

#endif  // NO_POOLS

#define ALLOCATE_MEMORY_FILE(n)             AllocateMemory((ULONG)(n))
#define ALLOCATE_ZEROMEMORY_FILE(n)         AllocateZeroMemory((ULONG)(n))
#define FREE_MEMORY_FILE(p)                 DeallocateMemory((PVOID)(p))

#if !defined(NO_POOLS)

#define CREATE_PACKET_POOL_FILE(t, s, n)    CreatePacketPool((ULONG)(s), (ULONG)(n))
#define DELETE_PACKET_POOL_FILE(p)    