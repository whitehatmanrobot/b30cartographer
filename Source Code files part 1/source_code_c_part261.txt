ernal override object FromString(string value, CultureInfo culture){
                 return Single.Parse(value, culture);
        }
        
        /// <include file='doc\SingleConverter.uex' path='docs/doc[@for="SingleConverter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((Single)value).ToString("R", formatInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\toolboxitemfiltertype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxItemFilterType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {

    using System;

    /// <include file='doc\ToolboxItemFilterType.uex' path='docs/doc[@for="ToolboxItemFilterType"]/*' />
    /// <devdoc>
    ///     Specifies the type of filter in a ToolboxItemFilterAttribute.
    /// </devdoc>
    public enum ToolboxItemFilterType {
    
        /// <include file='doc\ToolboxItemFilterType.uex' path='docs/doc[@for="ToolboxItemFilterType.Allow"]/*' />
        /// <devdoc>
        ///     Specifies that a toolbox item filter string may be allowed.  Allowed is typically used to
        ///     specify that you support the filter string, but don't care if it is accepted or rejected.
        /// </devdoc>
        Allow,
        
        /// <include file='doc\ToolboxItemFilterType.uex' path='docs/doc[@for="ToolboxItemFilterType.Custom"]/*' />
        /// <devdoc>
        ///     Specifies that a toolbox item filter string will require custom processing.  This is generally
        ///     specified on the root designer class to indicate that the designer wishes to accept or reject
        ///     a toolbox item through code.  The designer must implement IToolboxUser's IsSupported method.
        /// </devdoc>
        Custom,
        
        /// <include file='doc\ToolboxItemFilterType.uex' path='docs/doc[@for="ToolboxItemFilterType.Prevent"]/*' />
        /// <devdoc>
        ///     Specifies that a toolbox item filter string should be rejected.  If a designer and a component
        ///     class both have the filter string and one has a type of Prevent, the toolbox item will not
        ///     be available.
        /// </devdoc>
        Prevent,
        
        /// <include file='doc\ToolboxItemFilterType.uex' path='docs/doc[@for="ToolboxItemFilterType.Require"]/*' />
        /// <devdoc>
        ///     Specifies that a toolbox item filter string must be present for a toolbox item to be enabled.
        ///     A designer and component class must both have the filter string, and neither may have a filter
        ///     type of Prevent.
        /// </devdoc>
        Require
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\typeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="TypeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel.Design.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter"]/*' />
    /// <devdoc>
    ///    <para>Converts the value of an object into a different data type.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class TypeConverter {

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can convert an object in the
        ///       given source type to the native type of the converter.</para>
        /// </devdoc>
        public bool CanConvertFrom(Type sourceType) {
            return CanConvertFrom(null, sourceType);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.CanConvertFrom1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.</para>
        /// </devdoc>
        public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(InstanceDescriptor)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether this converter can convert an object to the given destination
        ///       type.
        ///    </para>
        /// </devdoc>
        public bool CanConvertTo(Type destinationType) {
            return CanConvertTo(null, destinationType);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.CanConvertTo1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            return (destinationType == typeof(string));
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Converts the given value
        ///       to the converter's native type.</para>
        /// </devdoc>
        public object ConvertFrom(object value) {
            return ConvertFrom(null, CultureInfo.CurrentCulture, value);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertFrom1"]/*' />
        /// <devdoc>
        ///    <para>Converts the given object to the converter's native type.</para>
        /// </devdoc>
        public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is InstanceDescriptor) {
                return ((InstanceDescriptor)value).Invoke();
            }
            throw GetConvertFromException(value);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertFromInvariantString"]/*' />
        /// <devdoc>
        ///    Converts the given string to the converter's native type using the invariant culture.
        /// </devdoc>
        public object ConvertFromInvariantString(string text) {
            return ConvertFromString(null, CultureInfo.InvariantCulture, text);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertFromInvariantString1"]/*' />
        /// <devdoc>
        ///    Converts the given string to the converter's native type using the invariant culture.
        /// </devdoc>
        public object ConvertFromInvariantString(ITypeDescriptorContext context, string text) {
            return ConvertFromString(context, CultureInfo.InvariantCulture, text);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertFromString"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified text into an object.</para>
        /// </devdoc>
        public object ConvertFromString(string text) {
            return ConvertFrom(null, null, text);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertFromString1"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified text into an object.</para>
        /// </devdoc>
        public object ConvertFromString(ITypeDescriptorContext context, string text) {
            return ConvertFrom(context, CultureInfo.CurrentCulture, text);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertFromString2"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified text into an object.</para>
        /// </devdoc>
        public object ConvertFromString(ITypeDescriptorContext context, CultureInfo culture, string text) {
            return ConvertFrom(context, culture, text);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Converts the given
        ///       value object to the specified destination type using the arguments.</para>
        /// </devdoc>
        public object ConvertTo(object value, Type destinationType) {
            return ConvertTo(null, null, value, destinationType);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertTo1"]/*' />
        /// <devdoc>
        ///    <para>Converts the given value object to
        ///       the specified destination type using the specified context and arguments.</para>
        /// </devdoc>
        public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value != null) {
                    return value.ToString();
                }
                else {
                    return String.Empty;
                }
            }
            throw GetConvertToException(value, destinationType);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertToInvariantString"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified value to a culture-invariant string representation.</para>
        /// </devdoc>
        public string ConvertToInvariantString(object value) {
            return ConvertToString(null, CultureInfo.InvariantCulture, value);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertToInvariantString1"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified value to a culture-invariant string representation.</para>
        /// </devdoc>
        public string ConvertToInvariantString(ITypeDescriptorContext context, object value) {
            return ConvertToString(context, CultureInfo.InvariantCulture, value);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertToString"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified value to a string representation.</para>
        /// </devdoc>
        public string ConvertToString(object value) {
            return (string)ConvertTo(null, CultureInfo.CurrentCulture, value, typeof(string));
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertToString1"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified value to a string representation.</para>
        /// </devdoc>
        public string ConvertToString(ITypeDescriptorContext context, object value) {
            return (string)ConvertTo(context, CultureInfo.CurrentCulture, value, typeof(string));
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.ConvertToString2"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified value to a string representation.</para>
        /// </devdoc>
        public string ConvertToString(ITypeDescriptorContext context, CultureInfo culture, object value) {
            return (string)ConvertTo(context, culture, value, typeof(string));
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.CreateInstance"]/*' />
        /// <devdoc>
        /// <para>Re-creates an <see cref='System.Object'/> given a set of property values for the object.</para>
        /// </devdoc>
        public object CreateInstance(IDictionary propertyValues) {
            return CreateInstance(null, propertyValues);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.CreateInstance1"]/*' />
        /// <devdoc>
        /// <para>Re-creates an <see cref='System.Object'/> given a set of property values for the
        ///    object.</para>
        /// </devdoc>
        public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            return null;
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetConvertFromException"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a suitable exception to throw when a conversion cannot
        ///       be performed.
        ///    </para>
        /// </devdoc>
        protected Exception GetConvertFromException(object value) {
            string valueTypeName;

            if (value == null) {
                valueTypeName = SR.GetString(SR.ToStringNull);
            }
            else {
                valueTypeName = value.GetType().FullName;
            }

            throw new NotSupportedException(SR.GetString(SR.ConvertFromException, GetType().Name, valueTypeName));
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetConvertToException"]/*' />
        /// <devdoc>
        ///    <para>Retrieves a suitable exception to throw when a conversion cannot
        ///       be performed.</para>
        /// </devdoc>
        protected Exception GetConvertToException(object value, Type destinationType) {
            string valueTypeName;

            if (value == null) {
                valueTypeName = SR.GetString(SR.ToStringNull);
            }
            else {
                valueTypeName = value.GetType().FullName;
            }

            throw new NotSupportedException(SR.GetString(SR.ConvertToException, GetType().Name, valueTypeName, destinationType.FullName));
        }
        
        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether changing a value on this 
        ///       object requires a call to <see cref='System.ComponentModel.TypeConverter.CreateInstance'/>
        ///       to create a new value.</para>
        /// </devdoc>
        public bool GetCreateInstanceSupported() {
            return GetCreateInstanceSupported(null);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetCreateInstanceSupported1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether changing a value on this object requires a 
        ///       call to <see cref='System.ComponentModel.TypeConverter.CreateInstance'/> to create a new value,
        ///       using the specified context.</para>
        /// </devdoc>
        public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of properties for the type of array specified by the value
        ///       parameter.</para>
        /// </devdoc>
        public PropertyDescriptorCollection GetProperties(object value) {
            return GetProperties(null, value);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetProperties1"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of
        ///       properties for the type of array specified by the value parameter using the specified
        ///       context.</para>
        /// </devdoc>
        public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value) {
            return GetProperties(context, value, new Attribute[] {BrowsableAttribute.Yes});
        }  
        
        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetProperties2"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of properties for
        ///       the type of array specified by the value parameter using the specified context and
        ///       attributes.</para>
        /// </devdoc>
        public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            return null;
        }
       
        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports properties.
        ///    </para>
        /// </devdoc>
        public bool GetPropertiesSupported() {
            return GetPropertiesSupported(null);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetPropertiesSupported1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object supports properties using the
        ///       specified context.</para>
        /// </devdoc>
        public virtual bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return false;
        }
        
        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para> Gets a collection of standard values for the data type this type
        ///       converter is designed for.</para>
        /// </devdoc>
        public ICollection GetStandardValues() {
            return GetStandardValues(null);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetStandardValues1"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the data type this type converter is
        ///       designed for.</para>
        /// </devdoc>
        public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            return null;
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the collection of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive list. </para>
        /// </devdoc>
        public bool GetStandardValuesExclusive() {
            return GetStandardValuesExclusive(null);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetStandardValuesExclusive1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the collection of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive 
        ///       list of possible values, using the specified context.</para>
        /// </devdoc>
        public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.
        ///    </para>
        /// </devdoc>
        public bool GetStandardValuesSupported() {
            return GetStandardValuesSupported(null);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.GetStandardValuesSupported1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object
        ///       supports a standard set of values that can be picked
        ///       from a list using the specified context.</para>
        /// </devdoc>
        public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return false;
        }
        
        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.IsValid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a value indicating whether the given value object is valid for this type.
        ///    </para>
        /// </devdoc>
        public bool IsValid(object value) {
            return IsValid(null, value);
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.IsValid1"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       a value indicating whether the given value object is valid for this type.</para>
        /// </devdoc>
        public virtual bool IsValid(ITypeDescriptorContext context, object value) {
            return true;
        }
        
        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SortProperties"]/*' />
        /// <devdoc>
        ///    <para>Sorts a collection of properties.</para>
        /// </devdoc>
        protected PropertyDescriptorCollection SortProperties(PropertyDescriptorCollection props, string[] names) {
            props.Sort(names);
            return props;
        }

        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SimplePropertyDescriptor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An <see langword='abstract '/>
        ///       class that provides
        ///       properties for objects that do not have
        ///       properties.
        ///    </para>
        /// </devdoc>
        protected abstract class SimplePropertyDescriptor : PropertyDescriptor {
            private Type   componentType;
            private Type   propertyType;
        
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SimplePropertyDescriptor.SimplePropertyDescriptor"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes a new instance of the <see cref='System.ComponentModel.TypeConverter.SimplePropertyDescriptor'/>
            ///       class.
            ///    </para>
            /// </devdoc>
            public SimplePropertyDescriptor(Type componentType, string name, Type propertyType) : this(componentType, name, propertyType, new Attribute[0]) {
            }
            
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SimplePropertyDescriptor.SimplePropertyDescriptor1"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes a new instance of the <see cref='System.ComponentModel.TypeConverter.SimplePropertyDescriptor'/> class.
            ///    </para>
            /// </devdoc>
            public SimplePropertyDescriptor(Type componentType, string name, Type propertyType, Attribute[] attributes) : base(name, attributes) {
                this.componentType = componentType;
                this.propertyType = propertyType;
            }
            
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SimplePropertyDescriptor.ComponentType"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets the type of the component this property description
            ///       is bound to.
            ///    </para>
            /// </devdoc>
            public override Type ComponentType {
                get {
                    return componentType;
                }
            }
                
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SimplePropertyDescriptor.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets a
            ///       value indicating whether this property is read-only.
            ///    </para>
            /// </devdoc>
            public override bool IsReadOnly {
                get {
                    return Attributes.Contains(ReadOnlyAttribute.Yes);
                }
            }
    
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SimplePropertyDescriptor.PropertyType"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets the type of the property.
            ///    </para>
            /// </devdoc>
            public override Type PropertyType {
                get {
                    return propertyType;
                }
            }
            
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SimplePropertyDescriptor.CanResetValue"]/*' />
            /// <devdoc>
            ///    <para>Gets a value indicating whether resetting the component 
            ///       will change the value of the component.</para>
            /// </devdoc>
            public override bool CanResetValue(object component) {
                DefaultValueAttribute attr = (DefaultValueAttribute)Attributes[typeof(DefaultValueAttribute)];
                if (attr == null) {
                    return false;
                }
                return (attr.Value.Equals(GetValue(component)));
            }
            
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SimplePropertyDescriptor.ResetValue"]/*' />
            /// <devdoc>
            ///    <para>Resets the value for this property
            ///       of the component.</para>
            /// </devdoc>
            public override void ResetValue(object component) {
                DefaultValueAttribute attr = (DefaultValueAttribute)Attributes[typeof(DefaultValueAttribute)];
                if (attr != null) {
                    SetValue(component, attr.Value);
                }
            }
    
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.SimplePropertyDescriptor.ShouldSerializeValue"]/*' />
            /// <devdoc>
            ///    <para>Gets a value
            ///       indicating whether the value of this property needs to be persisted.</para>
            /// </devdoc>
            public override bool ShouldSerializeValue(object component) {
                return false;
            }
        }
        
        /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection"]/*' />
        /// <devdoc>
        ///    <para>Represents a collection of values.</para>
        /// </devdoc>
        public class StandardValuesCollection : ICollection {
            private ICollection values;
            private Array       valueArray;
            
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.StandardValuesCollection"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes a new instance of the <see cref='System.ComponentModel.TypeConverter.StandardValuesCollection'/>
            ///       class.
            ///    </para>
            /// </devdoc>
            public StandardValuesCollection(ICollection values) {
                if (values == null) {
                    values = new object[0];
                }
                
                if (values is Array) {
                    valueArray = (Array)values;
                }
                
                this.values = values;
            }
            
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets the number of objects in the collection.
            ///    </para>
            /// </devdoc>
            public int Count {
                get {
                    if (valueArray != null) {
                        return valueArray.Length;
                    }
                    else {
                        return values.Count;
                    }
                }
            }
            
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.this"]/*' />
            /// <devdoc>
            ///    <para>Gets the object at the specified index number.</para>
            /// </devdoc>
            public object this[int index] {
                get {
                    if (valueArray != null) {
                        return valueArray.GetValue(index);
                    }
                    if (values is IList) {
                        return ((IList)values)[index];
                    }
                    // No other choice but to enumerate the collection.
                    //
                    valueArray = new object[values.Count];
                    values.CopyTo(valueArray, 0);
                    return valueArray.GetValue(index);
                }
            }

            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.CopyTo"]/*' />
            /// <devdoc>
            ///    <para>Copies the contents of this collection to an array.</para>
            /// </devdoc>
            public void CopyTo(Array array, int index) {
                values.CopyTo(array, index);
            }

            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets an enumerator for this collection.
            ///    </para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return values.GetEnumerator();
            }
            
            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.ICollection.Count"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// Retrieves the count of objects in the collection.
            /// </devdoc>
            int ICollection.Count {
                get {
                    return Count;
                }
            }

            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// Determines if this collection is synchronized.
            /// The ValidatorCollection is not synchronized for
            /// speed.  Also, since it is read-only, there is
            /// no need to synchronize it.
            /// </devdoc>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// Retrieves the synchronization root for this
            /// collection.  Because we are not synchronized,
            /// this returns null.
            /// </devdoc>
            object ICollection.SyncRoot {
                get {
                    return null;
                }
            }

            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// Copies the contents of this collection to an array.
            /// </devdoc>
            void ICollection.CopyTo(Array array, int index) {
                CopyTo(array, index);
            }

            /// <include file='doc\TypeConverter.uex' path='docs/doc[@for="TypeConverter.StandardValuesCollection.IEnumerable.GetEnumerator"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// Retrieves a new enumerator that can be used to
            /// iterate over the values in this collection.
            /// </devdoc>
            IEnumerator IEnumerable.GetEnumerator() {
                return GetEnumerator();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\typelistconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="TypeListConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel.Design.Serialization;
    

    using Microsoft.Win32;
    using System.Collections;
    
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type
    ///       converter that can be used to populate a list box with available types.</para>
    /// </devdoc>
    public abstract class TypeListConverter : TypeConverter {
        private Type[] types;
        private StandardValuesCollection values;
    
        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.TypeListConverter"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.TypeListConverter'/> class using
        ///    the type array as the available types.</para>
        /// </devdoc>
        protected TypeListConverter(Type[] types) {
            this.types = types;
        }
    
        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.CanConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter
        ///       can convert an object in the given source type to an enumeration object using
        ///       the specified context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.ConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Converts the specified value object to an enumeration object.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                foreach(Type t in types) {
                    if (value.Equals(t.FullName)) {
                        return t;
                    }
                }
            }
            
            return base.ConvertFrom(context, culture, value);
        }
    
        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.ConvertTo"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Converts the given value object to the specified destination type.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value == null) {
                    return SR.GetString(SR.toStringNone);
                }
                else {
                    return((Type)value).FullName;
                }
            }
            if (destinationType == typeof(InstanceDescriptor) && value is Type) {
                MethodInfo method = typeof(Type).GetMethod("GetType", new Type[] {typeof(string)});
                if (method != null) {
                    return new InstanceDescriptor(method, new object[] {((Type)value).AssemblyQualifiedName});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the data type this validator is
        ///       designed for.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                object[] objTypes;
                
                if (types != null) {
                    objTypes = new object[types.Length];
                    Array.Copy(types, objTypes, types.Length);
                }
                else {
                    objTypes = null;
                }
                
                values = new StandardValuesCollection(objTypes);
            }
            return values;
        }
    
        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.GetStandardValuesExclusive"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether the list of standard values returned from
        ///    <see cref='System.ComponentModel.TypeListConverter.GetStandardValues'/> is an exclusive list. </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether this object supports a
        ///       standard set of values that can be picked from a list using the specified
        ///       context.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\wfcinvalidenumexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="WFCInvalidEnumException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;

    /// <include file='doc\WFCInvalidEnumException.uex' path='docs/doc[@for="InvalidEnumArgumentException"]/*' />
    /// <devdoc>
    ///    <para>The exception that is thrown when using invalid arguments that are enumerators.</para>
    /// </devdoc>
    public class InvalidEnumArgumentException : ArgumentException {

        /// <include file='doc\WFCInvalidEnumException.uex' path='docs/doc[@for="InvalidEnumArgumentException.InvalidEnumArgumentException"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.InvalidEnumArgumentException'/> class without a message.</para>
        /// </devdoc>
        public InvalidEnumArgumentException() : this(null) {
        }

        /// <include file='doc\WFCInvalidEnumException.uex' path='docs/doc[@for="InvalidEnumArgumentException.InvalidEnumArgumentException1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.InvalidEnumArgumentException'/> class with 
        ///    the specified message.</para>
        /// </devdoc>
        public InvalidEnumArgumentException(string message)
            : base(message) {
        }

        /// <include file='doc\WFCInvalidEnumException.uex' path='docs/doc[@for="InvalidEnumArgumentException.InvalidEnumArgumentException2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.InvalidEnumArgumentException'/> class with a 
        ///    message generated from the argument, invalid value, and enumeration
        ///    class.</para>
        /// </devdoc>
        public InvalidEnumArgumentException(string argumentName, int invalidValue, Type enumClass)
            : base(SR.GetString(SR.InvalidEnumArgument,
                                argumentName,
                                invalidValue.ToString(),
                                enumClass.Name), argumentName) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\uint16converter.cs ===
//------------------------------------------------------------------------------
// <copyright file="UInt16Converter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\UInt16Converter.uex' path='docs/doc[@for="UInt16Converter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert 16-bit unsigned integer objects to and
    ///       from various other representations.</para>
    /// </devdoc>
    public class UInt16Converter : BaseNumberConverter {

        /// <include file='doc\UInt16Converter.uex' path='docs/doc[@for="UInt16Converter.TargetType"]/*' />
        /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(UInt16);
                }
        }

        /// <include file='doc\UInt16Converter.uex' path='docs/doc[@for="UInt16Converter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToUInt16(value, radix);
        }
        
        /// <include file='doc\UInt16Converter.uex' path='docs/doc[@for="UInt16Converter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return UInt16.Parse(value, NumberStyles.Integer, formatInfo);
        }
        
        
        /// <include file='doc\UInt16Converter.uex' path='docs/doc[@for="UInt16Converter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return UInt16.Parse(value, culture);
        }
        
        /// <include file='doc\UInt16Converter.uex' path='docs/doc[@for="UInt16Converter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((UInt16)value).ToString("G", formatInfo);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\typeconverterattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="TypeConverterAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Diagnostics;    
    using System.Globalization;

    /// <include file='doc\TypeConverterAttribute.uex' path='docs/doc[@for="TypeConverterAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies what type to use as
    ///       a converter for the object
    ///       this
    ///       attribute is bound to. This class cannot
    ///       be inherited.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class TypeConverterAttribute : Attribute {
        private string typeName;

        /// <include file='doc\TypeConverterAttribute.uex' path='docs/doc[@for="TypeConverterAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para> Specifies the type to use as
        ///       a converter for the object this attribute is bound to. This
        ///    <see langword='static '/>field is read-only. </para>
        /// </devdoc>
        public static readonly TypeConverterAttribute Default = new TypeConverterAttribute();

        /// <include file='doc\TypeConverterAttribute.uex' path='docs/doc[@for="TypeConverterAttribute.TypeConverterAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.TypeConverterAttribute'/> class with the
        ///       default type converter, which
        ///       is an
        ///       empty string ("").
        ///    </para>
        /// </devdoc>
        public TypeConverterAttribute() {
            this.typeName = string.Empty;
        }
        
        /// <include file='doc\TypeConverterAttribute.uex' path='docs/doc[@for="TypeConverterAttribute.TypeConverterAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.TypeConverterAttribute'/> class, using 
        ///    the specified type as the data converter for the object this attribute
        ///    is bound
        ///    to.</para>
        /// </devdoc>
        public TypeConverterAttribute(Type type) {
            this.typeName = type.AssemblyQualifiedName;
        }

        /// <include file='doc\TypeConverterAttribute.uex' path='docs/doc[@for="TypeConverterAttribute.TypeConverterAttribute2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.TypeConverterAttribute'/> class, using 
        ///    the specified type name as the data converter for the object this attribute is bound to.</para>
        /// </devdoc>
        public TypeConverterAttribute(string typeName) {
            string temp = typeName.ToUpper(CultureInfo.InvariantCulture);
            Debug.Assert(temp.IndexOf(".DLL") == -1, "Came across: " + typeName + " . Please remove the .dll extension");
            this.typeName = typeName;
        }

        /// <include file='doc\TypeConverterAttribute.uex' path='docs/doc[@for="TypeConverterAttribute.ConverterTypeName"]/*' />
        /// <devdoc>
        /// <para>Gets the fully qualified type name of the <see cref='System.Type'/>
        /// to use as a converter for the object this attribute
        /// is bound to.</para>
        /// </devdoc>
        public string ConverterTypeName {
            get {
                return typeName;
            }
        }

        /// <include file='doc\TypeConverterAttribute.uex' path='docs/doc[@for="TypeConverterAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            TypeConverterAttribute other = obj as TypeConverterAttribute; 
            return (other != null) && other.ConverterTypeName == typeName;
        }

        /// <include file='doc\TypeConverterAttribute.uex' path='docs/doc[@for="TypeConverterAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return typeName.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\uint32converter.cs ===
//------------------------------------------------------------------------------
// <copyright file="UInt32Converter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\UInt32Converter.uex' path='docs/doc[@for="UInt32Converter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert 32-bit unsigned integer objects to and
    ///       from various other representations.</para>
    /// </devdoc>
    public class UInt32Converter : BaseNumberConverter {

        /// <include file='doc\UInt32Converter.uex' path='docs/doc[@for="UInt32Converter.TargetType"]/*' />
        /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(UInt32);
                }
        }

        /// <include file='doc\UInt32Converter.uex' path='docs/doc[@for="UInt32Converter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToUInt32(value, radix);
        }
        
        /// <include file='doc\UInt32Converter.uex' path='docs/doc[@for="UInt32Converter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return UInt32.Parse(value, NumberStyles.Integer, formatInfo);
        }
        
        
        /// <include file='doc\UInt32Converter.uex' path='docs/doc[@for="UInt32Converter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return UInt32.Parse(value, culture);
        }
        
        /// <include file='doc\UInt32Converter.uex' path='docs/doc[@for="UInt32Converter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((UInt32)value).ToString("G", formatInfo);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\uint64converter.cs ===
//------------------------------------------------------------------------------
// <copyright file="UInt64Converter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\UInt64Converter.uex' path='docs/doc[@for="UInt64Converter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert 64-bit unsigned integer objects to and
    ///       from various other representations.</para>
    /// </devdoc>
    public class UInt64Converter : BaseNumberConverter {

        /// <include file='doc\UInt64Converter.uex' path='docs/doc[@for="UInt64Converter.TargetType"]/*' />
        /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt64, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(UInt64);
                }
        }

        /// <include file='doc\UInt64Converter.uex' path='docs/doc[@for="UInt64Converter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToUInt64(value, radix);
        }
        
        /// <include file='doc\UInt64Converter.uex' path='docs/doc[@for="UInt64Converter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return UInt64.Parse(value, NumberStyles.Integer, formatInfo);
        }
        
        
        /// <include file='doc\UInt64Converter.uex' path='docs/doc[@for="UInt64Converter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return UInt64.Parse(value);
        }
        
        /// <include file='doc\UInt64Converter.uex' path='docs/doc[@for="UInt64Converter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((UInt64)value).ToString("G", formatInfo);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\wfcswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="WFCSwitches.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Configuration.Assemblies;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    
    /// <internalonly/>    
    internal sealed class CompModSwitches {
        
        private static BooleanSwitch commonDesignerServices;
        private static TraceSwitch eventLog;
                
        public static BooleanSwitch CommonDesignerServices {
            get {
                if (commonDesignerServices == null) {
                    commonDesignerServices = new BooleanSwitch("CommonDesignerServices", "Assert if any common designer service is not found.");
                }
                return commonDesignerServices;
            }
        }   
        
        public static TraceSwitch EventLog {
            get {
                if (eventLog == null) {
                    eventLog = new TraceSwitch("EventLog", "Enable tracing for the EventLog component.");
                }
                return eventLog;
            }
        }
                                                                                                                                                                               
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\wfcwin32exception.cs ===
//------------------------------------------------------------------------------
// <copyright file="WFCWin32Exception.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Text;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;   
    using System.Diagnostics;
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.Serialization;
    using Microsoft.Win32;

    /// <include file='doc\WFCWin32Exception.uex' path='docs/doc[@for="Win32Exception"]/*' />
    /// <devdoc>
    ///    <para>The exception that is thrown for a Win32 error code.</para>
    /// </devdoc>
    [Serializable]
    [SuppressUnmanagedCodeSecurity]
    public class Win32Exception : ExternalException, ISerializable {
        /// <devdoc>
        ///    <para>Represents the Win32 error code associated with this exception. This 
        ///       field is read-only.</para>
        /// </devdoc>
        private readonly int nativeErrorCode;

        /// <include file='doc\WFCWin32Exception.uex' path='docs/doc[@for="Win32Exception.Win32Exception"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.Win32Exception'/> class with the last Win32 error 
        ///    that occured.</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public Win32Exception() : this(Marshal.GetLastWin32Error()) {
        }
        /// <include file='doc\WFCWin32Exception.uex' path='docs/doc[@for="Win32Exception.Win32Exception1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.Win32Exception'/> class with the specified error.</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public Win32Exception(int error) : this(error, GetErrorMessage(error)) {
        }
        /// <include file='doc\WFCWin32Exception.uex' path='docs/doc[@for="Win32Exception.Win32Exception2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.Win32Exception'/> class with the specified error and the 
        ///    specified detailed description.</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public Win32Exception(int error, string message)
        : base(message) {
            nativeErrorCode = error;
        }

        /// <include file='doc\WFCWin32Exception.uex' path='docs/doc[@for="Win32Exception.Win32Exception3"]/*' />
        protected Win32Exception(SerializationInfo info, StreamingContext context) : base (info, context) {
            IntSecurity.UnmanagedCode.Demand();
            nativeErrorCode = info.GetInt32("NativeErrorCode");
        }

        /// <include file='doc\WFCWin32Exception.uex' path='docs/doc[@for="Win32Exception.NativeErrorCode"]/*' />
        /// <devdoc>
        ///    <para>Represents the Win32 error code associated with this exception. This 
        ///       field is read-only.</para>
        /// </devdoc>
        public int NativeErrorCode {
            get {
                return nativeErrorCode;
            }
        }

        private static string GetErrorMessage(int error) {
            //get the system error message...
            string errorMsg = "";

            StringBuilder sb = new StringBuilder(256);
            int result = SafeNativeMethods.FormatMessage(
                                        SafeNativeMethods.FORMAT_MESSAGE_IGNORE_INSERTS |
                                        SafeNativeMethods.FORMAT_MESSAGE_FROM_SYSTEM |
                                        SafeNativeMethods.FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        NativeMethods.NullHandleRef, error, 0, sb, sb.Capacity + 1,
                                        IntPtr.Zero);
            if (result != 0) {
                int i = sb.Length;
                while (i > 0) {
                    char ch = sb[i - 1];
                    if (ch > 32 && ch != '.') break;
                    i--;
                }
                errorMsg = sb.ToString(0, i);
            }
            else {
                errorMsg ="Unknown error (0x" + Convert.ToString(error, 16) + ")";
            }

            return errorMsg;
        }

        /// <include file='doc\WFCWin32Exception.uex' path='docs/doc[@for="Win32Exception.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            info.AddValue("NativeErrorCode", nativeErrorCode);
            base.GetObjectData(info, context);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\activedocumentevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ActiveDocumentEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;

    /// <include file='doc\ActiveDocumentEvent.uex' path='docs/doc[@for="ActiveDesignerEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='System.ComponentModel.Design.IDesignerEventService.ActiveDesigner'/>
    /// event.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ActiveDesignerEventArgs : EventArgs {
        /// <include file='doc\ActiveDocumentEvent.uex' path='docs/doc[@for="ActiveDesignerEventArgs.oldDesigner"]/*' />
        /// <devdoc>
        ///     The document that is losing activation.
        /// </devdoc>
        private readonly IDesignerHost oldDesigner;

        /// <include file='doc\ActiveDocumentEvent.uex' path='docs/doc[@for="ActiveDesignerEventArgs.newDesigner"]/*' />
        /// <devdoc>
        ///     The document that is gaining activation.
        /// </devdoc>
        private readonly IDesignerHost newDesigner;

        /// <include file='doc\ActiveDocumentEvent.uex' path='docs/doc[@for="ActiveDesignerEventArgs.ActiveDesignerEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.Design.ActiveDesignerEventArgs'/>
        /// class.</para>
        /// </devdoc>
        public ActiveDesignerEventArgs(IDesignerHost oldDesigner, IDesignerHost newDesigner) {
            this.oldDesigner = oldDesigner;
            this.newDesigner = newDesigner;
        }

        /// <include file='doc\ActiveDocumentEvent.uex' path='docs/doc[@for="ActiveDesignerEventArgs.OldDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the document that is losing activation.
        ///    </para>
        /// </devdoc>
        public IDesignerHost OldDesigner {
            get {
                return oldDesigner;
            }
        }

        /// <include file='doc\ActiveDocumentEvent.uex' path='docs/doc[@for="ActiveDesignerEventArgs.NewDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the document that is gaining activation.
        ///    </para>
        /// </devdoc>
        public IDesignerHost NewDesigner {
            get {
                return newDesigner;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\checkoutexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="CheckoutException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;


    /// <include file='doc\CheckoutException.uex' path='docs/doc[@for="CheckoutException"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The exception thrown when an attempt is made to edit a file that is checked into
    ///       a source control program.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class CheckoutException : ExternalException{

        /// <include file='doc\CheckoutException.uex' path='docs/doc[@for="CheckoutException.Canceled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a <see cref='System.ComponentModel.Design.CheckoutException'/> that specifies that the checkout
        ///       was
        ///       canceled. This field is read-only.
        ///    </para>
        /// </devdoc>
        public readonly static CheckoutException   Canceled = new CheckoutException(SR.GetString(SR.CHECKOUTCanceled));

        /// <include file='doc\CheckoutException.uex' path='docs/doc[@for="CheckoutException.CheckoutException"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes
        ///       a new instance of the <see cref='System.ComponentModel.Design.CheckoutException'/> class with no
        ///       associated message or
        ///       error code.
        ///    </para>
        /// </devdoc>
        public CheckoutException() {
        }

        /// <include file='doc\CheckoutException.uex' path='docs/doc[@for="CheckoutException.CheckoutException1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.CheckoutException'/>
        ///       class with the specified message.
        ///    </para>
        /// </devdoc>
        public CheckoutException(string message)
            : base(message) {
        }

        /// <include file='doc\CheckoutException.uex' path='docs/doc[@for="CheckoutException.CheckoutException2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.CheckoutException'/>
        ///       class with the specified message and error code.
        ///    </para>
        /// </devdoc>
        public CheckoutException(string message, int errorCode)
            : base(message, errorCode) {
        }
               
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\activedocumenteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ActiveDocumentEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\ActiveDocumentEventHandler.uex' path='docs/doc[@for="ActiveDesignerEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.ComponentModel.Design.IDesignerEventService.ActiveDesignerChanged'/>
    /// event raised on changes to the currently active document.</para>
    /// </devdoc>
    public delegate void ActiveDesignerEventHandler(object sender, ActiveDesignerEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\wfcwarning.cs ===
//------------------------------------------------------------------------------
// <copyright file="WFCWarning.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {    
    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;

    /// <include file='doc\WFCWarning.uex' path='docs/doc[@for="WarningException"]/*' />
    /// <devdoc>
    ///    <para>Specifies an exception that is handled as a warning instead of an error.</para>
    /// </devdoc>
    public class WarningException : SystemException {
        private readonly string helpUrl;
        private readonly string helpTopic;

        /// <include file='doc\WFCWarning.uex' path='docs/doc[@for="WarningException.WarningException"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.WarningException'/> class with 
        ///    the specified message and no Help file.</para>
        /// </devdoc>
        public WarningException(string message) : this(message, null, null) {
        }

        /// <include file='doc\WFCWarning.uex' path='docs/doc[@for="WarningException.WarningException1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.WarningException'/> class with 
        ///    the specified message, and with access to the specified Help file.</para>
        /// </devdoc>
        public WarningException(string message, string helpUrl) : this(message, helpUrl, null) {
        }

        /// <include file='doc\WFCWarning.uex' path='docs/doc[@for="WarningException.WarningException2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.WarningException'/> class with the 
        ///    specified message, and with access to the specified Help file and topic.</para>
        /// </devdoc>
        public WarningException(string message, string helpUrl, string helpTopic)
            : base(message) {
            this.helpUrl = helpUrl;
            this.helpTopic = helpTopic;
        }

        /// <include file='doc\WFCWarning.uex' path='docs/doc[@for="WarningException.HelpUrl"]/*' />
        /// <devdoc>
        ///    <para> Specifies the Help file associated with the 
        ///       warning. This field is read-only.</para>
        /// </devdoc>
        public string HelpUrl {
            get {
                return helpUrl;
            }
        }

        /// <include file='doc\WFCWarning.uex' path='docs/doc[@for="WarningException.HelpTopic"]/*' />
        /// <devdoc>
        ///    <para> Specifies the 
        ///       Help topic associated with the warning. This field is read-only. </para>
        /// </devdoc>
        public string HelpTopic {
            get {
                return helpTopic;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\commandid.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandID.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\CommandID.uex' path='docs/doc[@for="CommandID"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a
    ///       numeric Command ID and globally unique
    ///       ID (GUID) menu identifier that together uniquely identify a command.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class CommandID {
        private readonly Guid menuGroup;
        private readonly int  commandID;

        /// <include file='doc\CommandID.uex' path='docs/doc[@for="CommandID.CommandID"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.CommandID'/>
        ///       class. Creates a new command
        ///       ID.
        ///    </para>
        /// </devdoc>
        public CommandID(Guid menuGroup, int commandID) {
            this.menuGroup = menuGroup;
            this.commandID = commandID;
        }

        /// <include file='doc\CommandID.uex' path='docs/doc[@for="CommandID.ID"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the numeric command ID.
        ///    </para>
        /// </devdoc>
        public virtual int ID {
            get {
                return commandID;
            }
        }

        /// <include file='doc\CommandID.uex' path='docs/doc[@for="CommandID.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Overrides Object's Equals method.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (!(obj is CommandID)) {
                return false;
            }
            CommandID cid = (CommandID)obj;
            return cid.menuGroup.Equals(menuGroup) && cid.commandID == commandID;
        }

        /// <include file='doc\CommandID.uex' path='docs/doc[@for="CommandID.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return menuGroup.GetHashCode() << 2 | commandID;
        }

        /// <include file='doc\CommandID.uex' path='docs/doc[@for="CommandID.Guid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the globally
        ///       unique ID
        ///       (GUID) of the menu group that the menu command this CommandID
        ///       represents belongs to.
        ///    </para>
        /// </devdoc>
        public virtual Guid Guid {
            get {
                return menuGroup;
            }
        }

        /// <include file='doc\CommandID.uex' path='docs/doc[@for="CommandID.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Overrides Object's ToString method.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return menuGroup.ToString() + " : " + commandID.ToString();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\componentchangedevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentChangedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\ComponentChangedEvent.uex' path='docs/doc[@for="ComponentChangedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentChanged'/> event.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public sealed class ComponentChangedEventArgs : EventArgs {

        private object component;
        private MemberDescriptor member;
        private object oldValue;
        private object newValue;

        /// <include file='doc\ComponentChangedEvent.uex' path='docs/doc[@for="ComponentChangedEventArgs.Component"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the component that is the cause of this event.      
        ///    </para>
        /// </devdoc>
        public object Component {
            get {
                return component;
            }
        }

        /// <include file='doc\ComponentChangedEvent.uex' path='docs/doc[@for="ComponentChangedEventArgs.Member"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the member that is about to change.      
        ///    </para>
        /// </devdoc>
        public MemberDescriptor Member {
            get {
                return member;
            }
        }

        /// <include file='doc\ComponentChangedEvent.uex' path='docs/doc[@for="ComponentChangedEventArgs.NewValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the new value of the changed member.
        ///    </para>
        /// </devdoc>
        public object NewValue {
            get {
                return newValue;
            }
        }

        /// <include file='doc\ComponentChangedEvent.uex' path='docs/doc[@for="ComponentChangedEventArgs.OldValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the old value of the changed member.      
        ///    </para>
        /// </devdoc>
        public object OldValue {
            get {
                return oldValue;
            }
        }

        /// <include file='doc\ComponentChangedEvent.uex' path='docs/doc[@for="ComponentChangedEventArgs.ComponentChangedEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.Design.ComponentChangedEventArgs'/> class.</para>
        /// </devdoc>
        public ComponentChangedEventArgs(object component, MemberDescriptor member, object oldValue, object newValue) {
            this.component = component;
            this.member = member;
            this.oldValue = oldValue;
            this.newValue = newValue;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\componentchangingeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentChangingEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\ComponentChangingEventHandler.uex' path='docs/doc[@for="ComponentChangingEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle a ComponentChangingEvent event.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public delegate void ComponentChangingEventHandler(object sender, ComponentChangingEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\componentchangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\ComponentChangedEventHandler.uex' path='docs/doc[@for="ComponentChangedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle a <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentChanged'/> event.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public delegate void ComponentChangedEventHandler(object sender, ComponentChangedEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\componentchangingevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentChangingEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\ComponentChangingEvent.uex' path='docs/doc[@for="ComponentChangingEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentChanging'/> event.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public sealed class ComponentChangingEventArgs : EventArgs {

        private object component;
        private MemberDescriptor member;

        /// <include file='doc\ComponentChangingEvent.uex' path='docs/doc[@for="ComponentChangingEventArgs.Component"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the component that is being changed or that is the parent container of the member being changed.      
        ///    </para>
        /// </devdoc>
        public object Component {
            get {
                return component;
            }
        }

        /// <include file='doc\ComponentChangingEvent.uex' path='docs/doc[@for="ComponentChangingEventArgs.Member"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the member of the component that is about to be changed.
        ///    </para>
        /// </devdoc>
        public MemberDescriptor Member {
            get {
                return member;
            }
        }

        /// <include file='doc\ComponentChangingEvent.uex' path='docs/doc[@for="ComponentChangingEventArgs.ComponentChangingEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.ComponentChangingEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public ComponentChangingEventArgs(object component, MemberDescriptor member) {
            this.component = component;
            this.member = member;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\componenteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\ComponentEventHandler.uex' path='docs/doc[@for="ComponentEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentAdding'/> , <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentAdded'/>, <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentRemoving'/>, and 
    /// <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentRemoved'/> event raised
    ///    for component-level events.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public delegate void ComponentEventHandler(object sender, ComponentEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\componentrenameeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentRenameEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\ComponentRenameEventHandler.uex' path='docs/doc[@for="ComponentRenameEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle a <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentRename'/> event.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public delegate void ComponentRenameEventHandler(object sender, ComponentRenameEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\componentevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\ComponentEvent.uex' path='docs/doc[@for="ComponentEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the System.ComponentModel.Design.IComponentChangeService.ComponentEvent
    /// event raised for component-level events.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ComponentEventArgs : EventArgs {

        private IComponent component;

        /// <include file='doc\ComponentEvent.uex' path='docs/doc[@for="ComponentEventArgs.Component"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the component associated with the event.
        ///    </para>
        /// </devdoc>
        public virtual IComponent Component {
            get {
                return component;
            }
        }

        /// <include file='doc\ComponentEvent.uex' path='docs/doc[@for="ComponentEventArgs.ComponentEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the System.ComponentModel.Design.ComponentEventArgs class.
        ///    </para>
        /// </devdoc>
        public ComponentEventArgs(IComponent component) {
            this.component = component;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\designertransactioncloseeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerTransactionCloseEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Reflection;

    /// <include file='doc\DesignerTransactionCloseEventHandler.uex' path='docs/doc[@for="DesignerTransactionCloseEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public delegate void DesignerTransactionCloseEventHandler(object sender, DesignerTransactionCloseEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\componentrenameevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentRenameEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;

    /// <include file='doc\ComponentRenameEvent.uex' path='docs/doc[@for="ComponentRenameEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentRename'/> event.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ComponentRenameEventArgs : EventArgs {
        private object component;
        private string oldName;
        private string newName;

        /// <include file='doc\ComponentRenameEvent.uex' path='docs/doc[@for="ComponentRenameEventArgs.Component"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the component that is being renamed.
        ///    </para>
        /// </devdoc>
        public object Component {
            get {
                return component;
            }
        }

        /// <include file='doc\ComponentRenameEvent.uex' path='docs/doc[@for="ComponentRenameEventArgs.OldName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the name of the component before the rename.
        ///    </para>
        /// </devdoc>
        public virtual string OldName {
            get {
                return oldName;
            }
        }

        /// <include file='doc\ComponentRenameEvent.uex' path='docs/doc[@for="ComponentRenameEventArgs.NewName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the current name of the component.
        ///    </para>
        /// </devdoc>
        public virtual string NewName {
            get {
                return newName;
            }
        }

        /// <include file='doc\ComponentRenameEvent.uex' path='docs/doc[@for="ComponentRenameEventArgs.ComponentRenameEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.ComponentRenameEventArgs'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public ComponentRenameEventArgs(object component, string oldName, string newName) {
            this.oldName = oldName;
            this.newName = newName;
            this.component = component;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\designertransactioncloseevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerTransactionCloseEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Reflection;

    /// <include file='doc\DesignerTransactionCloseEvent.uex' path='docs/doc[@for="DesignerTransactionCloseEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class DesignerTransactionCloseEventArgs : EventArgs {
        private bool commit;
        
        /// <include file='doc\DesignerTransactionCloseEvent.uex' path='docs/doc[@for="DesignerTransactionCloseEventArgs.DesignerTransactionCloseEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DesignerTransactionCloseEventArgs(bool commit) {
            this.commit = commit;
        }
        
        /// <include file='doc\DesignerTransactionCloseEvent.uex' path='docs/doc[@for="DesignerTransactionCloseEventArgs.TransactionCommitted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool TransactionCommitted {
            get {
                return commit;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\designertransaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerTransaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System;

    /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction"]/*' />
    /// <devdoc>
    ///     Identifies a transaction within a designer.  Transactions are
    ///     used to wrap serveral changes into one unit of work, which 
    ///     helps performance.
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class DesignerTransaction : IDisposable {
        private bool committed = false;
        private bool canceled = false;
        private bool suppressedFinalization = false;
        private string desc;
        
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.DesignerTransaction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DesignerTransaction() : this("") {
        }
        
        
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.DesignerTransaction1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DesignerTransaction(string description) {
            this.desc = description;
        }
        
        
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.Canceled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Canceled {
            get {
                return canceled;
            }
        }
        
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.Committed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Committed {
            get {
                return committed;
            }
        }
        
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.Description"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Description {
            get {
                return desc;
            }
        }
        
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.Cancel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Cancel() {
            if (!canceled && !committed) {
                canceled = true;
                GC.SuppressFinalize(this);
                suppressedFinalization = true;
                OnCancel();
            }
        }
    
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.Commit"]/*' />
        /// <devdoc>
        ///     Commits this transaction.  Once a transaction has
        ///     been committed, further calls to this method
        ///     will do nothing.  You should always call this
        ///     method after creating a transaction to ensure
        ///     that the transaction is closed properly.
        /// </devdoc>
        public void Commit() {
            if (!committed && !canceled) {
                committed = true;
                GC.SuppressFinalize(this);
                suppressedFinalization = true;
                OnCommit();
            }
        }
        
          /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.OnCancel"]/*' />
          /// <devdoc>
        ///     User code should implement this method to perform
        ///     the actual work of committing a transaction.
        /// </devdoc>
        protected abstract void OnCancel(); 
        
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.OnCommit"]/*' />
        /// <devdoc>
        ///     User code should implement this method to perform
        ///     the actual work of committing a transaction.
        /// </devdoc>
        protected abstract void OnCommit();
        
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.Finalize"]/*' />
        /// <devdoc>
        ///     Overrides Object to commit this transaction
        ///     in case the user forgot.
        /// </devdoc>
        ~DesignerTransaction() {
            Dispose(false);
        }
        
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Private implementation of IDisaposable.
        /// When a transaction is disposed it is
        /// committed.
        /// </devdoc>
        void IDisposable.Dispose() {
            Dispose(true);

            // note - Dispose calls Cancel which sets this bit, so
            //        this should never be hit.
            //
            if (!suppressedFinalization) {
                System.Diagnostics.Debug.Fail("Invalid state. Dispose(true) should have called cancel which does the SuppressFinalize");
                GC.SuppressFinalize(this);
            }
        }
        /// <include file='doc\DesignerTransaction.uex' path='docs/doc[@for="DesignerTransaction.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            System.Diagnostics.Debug.Assert(disposing, "Designer transaction garbage collected, unable to cancel, please Cancel, Close, or Dispose your transaction.");
            System.Diagnostics.Debug.Assert(disposing && (canceled || committed), "Disposing DesignerTransaction that has not been comitted or canceled; forcing Cancel" );
            Cancel();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\designerverb.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerVerb.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;

    /// <include file='doc\DesignerVerb.uex' path='docs/doc[@for="DesignerVerb"]/*' />
    /// <devdoc>
    ///    <para> Represents a verb that can be executed by a component's designer.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class DesignerVerb : MenuCommand {

        private string text;

        /// <include file='doc\DesignerVerb.uex' path='docs/doc[@for="DesignerVerb.DesignerVerb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.DesignerVerb'/> class.
        ///    </para>
        /// </devdoc>
        public DesignerVerb(string text, EventHandler handler)  : base(handler, StandardCommands.VerbFirst) {
            this.text = text;
        }

        /// <include file='doc\DesignerVerb.uex' path='docs/doc[@for="DesignerVerb.DesignerVerb1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.DesignerVerb'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public DesignerVerb(string text, EventHandler handler, CommandID startCommandID)  : base(handler, startCommandID) {
            this.text = text;
        }

        /// <include file='doc\DesignerVerb.uex' path='docs/doc[@for="DesignerVerb.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the text to show on the menu item for the verb.
        ///    </para>
        /// </devdoc>
        public string Text {
            get {
                if (text == null) {
                    return "";
                }
                return text;
            }
        }
   
        /// <include file='doc\DesignerVerb.uex' path='docs/doc[@for="DesignerVerb.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Overrides object's ToString().
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return Text + " : " + base.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\typedescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="TypeDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using CodeAccessPermission = System.Security.CodeAccessPermission;
    using System.Security.Permissions;
    using System.Collections;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using Microsoft.Win32;
    using System.ComponentModel.Design;

    /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor"]/*' />
    /// <devdoc>
    ///    <para>Provides information about the properties and events
    ///       for a component. This class cannot be inherited.</para>
    /// </devdoc>
    public sealed class TypeDescriptor {
    
        private static Hashtable cachedComponentEntries = new Hashtable();
        private static Hashtable editorTables = new Hashtable();
        private static Hashtable attributeCache = new Hashtable();
        private static RefreshEventHandler refreshHandler = null;
        private static IComNativeDescriptorHandler comNativeDescriptorHandler = null;

        private static TraceSwitch CompDescrSwitch = new TraceSwitch("CompDescr", "Debug TypeDescriptor.");
        
        private TypeDescriptor() {
        }
        
        private static ComponentEntry GetEntry(object component, Type componentType) {
            ComponentEntry entry = null;
            
            lock(cachedComponentEntries) {
                entry = (ComponentEntry)cachedComponentEntries[componentType];
                if (entry == null) {
                    entry = new ComponentEntry(componentType);
                    cachedComponentEntries[componentType] = entry;
                }
            }

            return entry;
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComNativeDescriptorHandler"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public static IComNativeDescriptorHandler ComNativeDescriptorHandler {
            [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
            get {
                return comNativeDescriptorHandler;
            }
            [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
            set {
                comNativeDescriptorHandler = value;
            }
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.Refreshed"]/*' />
        /// <devdoc>
        ///    <para>Occurs when Refreshed is raised for a component.</para>
        /// </devdoc>
        public static event RefreshEventHandler Refreshed {
            add {
                refreshHandler += value;
            }
            remove {
                refreshHandler -= value;
            }
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.AddEditorTable"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Adds an editor table for the given editor base type.
        ///       Typically, editors are specified as metadata on an object. If no metadata for a
        ///       requested editor base type can be found on an object, however, the
        ///       TypeDescriptor will search an editor
        ///       table for the editor type, if one can be found.</para>
        /// </devdoc>
        public static void AddEditorTable(Type editorBaseType, Hashtable table) {
            lock(editorTables) {
                if (!editorTables.ContainsKey(editorBaseType)) {
                    editorTables[editorBaseType] = table;
                }
            }
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.CreateDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an instance of the designer associated with the
        ///       specified <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static IDesigner CreateDesigner(IComponent component, Type designerBaseType) {
            Type designerType = null;
            IDesigner designer = null;

            Debug.WriteLineIf(CompDescrSwitch.TraceVerbose, "CreateDesigner(" + component.GetType().FullName + ")");
            
            // Get the set of attributes for this type
            //
            AttributeCollection attributes = GetAttributes(component);
            
            for (int i = 0; i < attributes.Count; i++) {
                if (attributes[i] is DesignerAttribute) {
                    DesignerAttribute da = (DesignerAttribute)attributes[i];
                    Type attributeBaseType = Type.GetType(da.DesignerBaseTypeName);
                    if (attributeBaseType != null && attributeBaseType == designerBaseType) {
                        ISite site = component.Site;
                        bool foundService = false;
                        
                        if (site != null) {
                            ITypeResolutionService tr = (ITypeResolutionService)site.GetService(typeof(ITypeResolutionService));
                            if (tr != null) {
                                foundService = true;
                                designerType = tr.GetType(da.DesignerTypeName);
                            }
                        }
                        
                        if (!foundService) {
                            designerType = Type.GetType(da.DesignerTypeName);
                        }
                        
                        Debug.Assert(designerType != null, "It may be okay for the designer not to load, but we failed to load designer for component of type '" + component.GetType().FullName + "' because designer of type '" + da.DesignerTypeName + "'");
                        if (designerType != null) {
                            break;
                        }
                    }
                }
            }
            
            if (designerType != null) {
                designer = (IDesigner)Activator.CreateInstance(designerType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);
            }
            else {
                Debug.WriteLineIf(CompDescrSwitch.TraceVerbose, "Could not find designer for: " + component.GetType().FullName);
            }
            return designer;
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.CreateEvent"]/*' />
        /// <devdoc>
        ///     This dynamically binds an EventDescriptor to a type.
        /// </devdoc>
        [ReflectionPermission(SecurityAction.LinkDemand, Flags=ReflectionPermissionFlag.MemberAccess | ReflectionPermissionFlag.TypeInformation)]
        public static EventDescriptor CreateEvent(Type componentType, string name, Type type, params Attribute[] attributes) {
            return new ReflectEventDescriptor(componentType, name, type, attributes);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.CreateEvent1"]/*' />
        /// <devdoc>
        ///     This creates a new event descriptor identical to an existing event descriptor.  The new event descriptor
        ///     has the specified metadata attributes merged with the existing metadata attributes.
        /// </devdoc>
        [ReflectionPermission(SecurityAction.LinkDemand, Flags=ReflectionPermissionFlag.MemberAccess | ReflectionPermissionFlag.TypeInformation)]
        public static EventDescriptor CreateEvent(Type componentType, EventDescriptor oldEventDescriptor, params Attribute[] attributes) {
            return new ReflectEventDescriptor(componentType, oldEventDescriptor, attributes);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.CreateProperty"]/*' />
        /// <devdoc>
        ///     This dynamically binds a PropertyDescriptor to a type.
        /// </devdoc>
        [ReflectionPermission(SecurityAction.LinkDemand, Flags=ReflectionPermissionFlag.MemberAccess | ReflectionPermissionFlag.TypeInformation)]
        public static PropertyDescriptor CreateProperty(Type componentType, string name, Type type, params Attribute[] attributes) {
            return new ReflectPropertyDescriptor(componentType, name, type, attributes);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.CreateProperty1"]/*' />
        /// <devdoc>
        ///     This creates a new property descriptor identical to an existing property descriptor.  The new property descriptor
        ///     has the specified metadata attributes merged with the existing metadata attributes.
        /// </devdoc>
        [ReflectionPermission(SecurityAction.LinkDemand, Flags=ReflectionPermissionFlag.MemberAccess | ReflectionPermissionFlag.TypeInformation)]
        public static PropertyDescriptor CreateProperty(Type componentType, PropertyDescriptor oldPropertyDescriptor, params Attribute[] attributes) {

            // We must do some special case work here for extended properties.  If the old property descriptor is really
            // an extender property that is being surfaced on a component as a normal property, then we must
            // do work here or else ReflectPropertyDescriptor will fail to resolve the get and set methods.  We check
            // for the necessary ExtenderProvidedPropertyAttribute and if we find it, we create an
            // ExtendedPropertyDescriptor instead.  We only do this if the component class is the same, since the user
            // may want to re-route the property to a different target.
            //
            if (componentType == oldPropertyDescriptor.ComponentType) {
                ExtenderProvidedPropertyAttribute attr = (ExtenderProvidedPropertyAttribute)
                                                         oldPropertyDescriptor.Attributes[
                                                         typeof(ExtenderProvidedPropertyAttribute)];

                if (attr.ExtenderProperty != null) {
                    return new ExtendedPropertyDescriptor((ReflectPropertyDescriptor)attr.ExtenderProperty, attr.ReceiverType, attr.Provider, attributes);
                }
            }

            // This is either a normal prop or the caller has changed target classes.
            //
            return new ReflectPropertyDescriptor(componentType, oldPropertyDescriptor, attributes);
        }
        
        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a
        ///       collection of attributes for the specified type of component.
        ///    </para>
        /// </devdoc>
        public static AttributeCollection GetAttributes(Type componentType) {
            return GetEntry(null, componentType).GetAttributes(null);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetAttributes1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of attributes for the specified
        ///    <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static AttributeCollection GetAttributes(object component) {
            return GetAttributes(component, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetAttributes2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of attributes for the specified
        ///    <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static AttributeCollection GetAttributes(object component, bool noCustomTypeDesc) {
            if (component == null) {
                return new AttributeCollection(null);
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
            
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetAttributes(component);
                }
                return new AttributeCollection(null);
            }

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                return((ICustomTypeDescriptor)component).GetAttributes();
            }

            return GetEntry(component, component.GetType()).GetAttributes(component);
        }


        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetClassName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the class for the specified
        ///    <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static string GetClassName(object component) {
            return GetClassName(component, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetClassName1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the class for the specified
        ///    <paramref name="component "/>using the custom type descriptor when <paramref name="noCustomTypeDesc 
        ///       "/>
        ///       is <see langword='false'/>.
        ///    </para>
        /// </devdoc>
        public static string GetClassName(object component, bool noCustomTypeDesc) {

            if (component == null) {
                throw new ArgumentNullException("component");
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
            
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetClassName(component);
                }
            }

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                string str = ((ICustomTypeDescriptor)component).GetClassName();
                if (str != null) {
                    return str;
                }
            }

            return component.GetType().FullName;
        }


        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetComponentName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The name of the class for the specified <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static string GetComponentName(object component) {
            return GetComponentName(component, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetComponentName1"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the class for the specified component.</para>
        /// </devdoc>
        public static string GetComponentName(object component, bool noCustomTypeDesc) {

            if (component == null) {
                throw new ArgumentNullException("component");
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
            
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetName(component);
                }
            }

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                string str = ((ICustomTypeDescriptor)component).GetComponentName();
                if (str != null) {
                    return str;
                }
            }

            if (component is IComponent) {
                ISite site = ((IComponent)component).Site;
                if (site != null) {
                    return site.Name;
                }
            }
            return component.GetType().Name;
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetConverter"]/*' />
        /// <devdoc>
        ///    <para>Gets a type converter for the type of the specified 
        ///       component.</para>
        /// </devdoc>
        public static TypeConverter GetConverter(object component) {
            return GetConverter(component, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetConverter1"]/*' />
        /// <devdoc>
        ///    <para>Gets a type converter for the type of the specified 
        ///       component.</para>
        /// </devdoc>
        public static TypeConverter GetConverter(object component, bool noCustomTypeDesc) {
            if (component == null) {
                throw new ArgumentNullException("component");
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
            
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetConverter(component);
                }
                return null;
            }

            TypeConverter converter = null;

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                converter = ((ICustomTypeDescriptor)component).GetConverter();
            }

            if (converter == null) {
                converter = GetEntry(component, component.GetType()).GetConverter(component);
            }

            return converter;
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetConverter2"]/*' />
        /// <devdoc>
        ///    <para>Gets a type converter for the specified type.</para>
        /// </devdoc>
        public static TypeConverter GetConverter(Type type) {
            return GetEntry(null, type).GetConverter();
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetCustomAttributes"]/*' />
        /// <devdoc>
        ///     Querying custom attributes is very expensive, so we cache them
        ///     here.
        /// </devdoc>
        internal static object[] GetCustomAttributes(Type type) {
            object[] attributes = (object[])attributeCache[type];
            if (attributes == null) {
                attributes = type.GetCustomAttributes(false);
            
                lock(attributeCache) {
                    attributeCache[type] = attributes;
                }
            }
            
            return attributes;
        }
        
        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetCustomAttributes1"]/*' />
        /// <devdoc>
        ///     Querying custom attributes is very expensive, so we cache them
        ///     here.
        /// </devdoc>
        internal static object[] GetCustomAttributes(MemberInfo info) {
            object[] attributes = (object[])attributeCache[info];
            if (attributes == null) {
                attributes = info.GetCustomAttributes(false);
            
                lock(attributeCache) {
                    attributeCache[info] = attributes;
                }
            }
            
            return attributes;
        }
                
        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetDefaultEvent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the default event for the specified
        ///       type of component.
        ///    </para>
        /// </devdoc>
        public static EventDescriptor GetDefaultEvent(Type componentType) {
            return GetEntry(null, componentType).GetDefaultEvent(null);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetDefaultEvent1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default event for the specified
        ///    <paramref name="component"/>.
        /// </para>
        /// </devdoc>
        public static EventDescriptor GetDefaultEvent(object component) {
            return GetDefaultEvent(component, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetDefaultEvent2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default event for a component.
        ///    </para>
        /// </devdoc>
        public static EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc) {
            if (component == null) {
                return null;
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
            
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetDefaultEvent(component);
                }
                return null;
            }

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                return((ICustomTypeDescriptor)component).GetDefaultEvent();
            }

            return GetEntry(component, component.GetType()).GetDefaultEvent(component);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default
        ///       property for the
        ///       specified type of component.
        ///    </para>
        /// </devdoc>
        public static PropertyDescriptor GetDefaultProperty(Type componentType) {
            return GetEntry(null, componentType).GetDefaultProperty(null);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetDefaultProperty1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default property for the specified
        ///    <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static PropertyDescriptor GetDefaultProperty(object component) {
            return GetDefaultProperty(component, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetDefaultProperty2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default property for the specified
        ///    <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc) {
            if (component == null) {
                return null;
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
            
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetDefaultProperty(component);
                }
                return null;
            }

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                return((ICustomTypeDescriptor)component).GetDefaultProperty();
            }

            return GetEntry(component, component.GetType()).GetDefaultProperty(component);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEditor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an editor with the specified base type for the
        ///       specified <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static object GetEditor(object component, Type editorBaseType) {
            return GetEditor(component, editorBaseType, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEditor1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an editor with the specified base type for the
        ///       specified <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static object GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc) {
            if (component == null) {
                throw new ArgumentNullException("component");
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
            
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetEditor(component, editorBaseType);
                }
                return null;
            }

            object editor = null;

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                editor = ((ICustomTypeDescriptor)component).GetEditor(editorBaseType);
            }

            if (editor == null) {
                editor = GetEntry(component, component.GetType()).GetEditor(component, editorBaseType);
            }

            return editor;
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEditor2"]/*' />
        /// <devdoc>
        ///    <para>Gets an editor with the specified base type for the specified type.</para>
        /// </devdoc>
        public static object GetEditor(Type type, Type editorBaseType) {
            Debug.Assert(type != null, "Can't get editor for null type");
            return GetEntry(null, type).GetEditor(editorBaseType);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEditorTable"]/*' />
        /// <devdoc> 
        ///      Retrieves a default editor table for the given editor base type. 
        /// </devdoc> 
        private static Hashtable GetEditorTable(Type editorBaseType) {
            object table = null;
            
            lock(editorTables) {
                table = editorTables[editorBaseType];
            }
            
            if (table == null) {
                // Before we give up, it is possible that the
                // class initializer for editorBaseType hasn't 
                // actually run.  Force it now.  We try/catch
                // here in case editorBaseType throws us a curve ball.
                //
                if (!editorBaseType.IsAbstract) {
                    try {
                        object o = Activator.CreateInstance(editorBaseType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);
                    }
                    catch(Exception) {
                    }
                }
                
                lock(editorTables) {
                    table = editorTables[editorBaseType];
                    
                    // If the table is still null, then throw a
                    // sentinel in there so we don't
                    // go through this again.
                    //
                    if (table == null) {
                        editorTables[editorBaseType] = editorTables;
                    }
                }
            }
            
            // Look for our sentinel value that indicates
            // we have already tried and failed to get
            // a table.
            //
            if (table == editorTables) {
                table = null;
            }
            
            return (Hashtable)table;
        }
        
        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEvents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of events for a specified type of component.
        ///    </para>
        /// </devdoc>
        public static EventDescriptorCollection GetEvents(Type componentType) {
            return GetEvents(componentType, null);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEvents1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of events for a
        ///       specified <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static EventDescriptorCollection GetEvents(object component) {
            return GetEvents(component, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEvents2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of events for a
        ///       specified <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc) {
            if (component == null) {
                return new EventDescriptorCollection(null, true);
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
                
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetEvents(component);
                }
                return new EventDescriptorCollection(null, true);
            }


            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                EventDescriptorCollection events = ((ICustomTypeDescriptor)component).GetEvents();
                return GetEntry(component, component.GetType()).FilterEvents(component, null, events);
            }

            return GetEvents(component, null);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEvents3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of events for a specified type of
        ///       component using a specified array of <paramref name="attributes "/>
        ///       as a filter.
        ///    </para>
        /// </devdoc>
        public static EventDescriptorCollection GetEvents(Type componentType, Attribute[] attributes) {
            return GetEntry(null, componentType).GetEvents(null, attributes);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEvents4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of events for a
        ///       specified <paramref name="component "/>using a specified array of <paramref name="attributes"/>
        ///       as a filter.
        ///    </para>
        /// </devdoc>
        public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes) {
            return GetEvents(component, attributes, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetEvents5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of events for a
        ///       specified <paramref name="component "/>using a specified array of <paramref name="attributes
        ///       "/>
        ///       as a filter.
        ///    </para>
        /// </devdoc>
        public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes, bool noCustomTypeDesc) {
            if (component == null) {
                return new EventDescriptorCollection(null, true);
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
                
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetEvents(component, attributes);
                }
                return new EventDescriptorCollection(null, true);
            }

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                EventDescriptorCollection events = ((ICustomTypeDescriptor)component).GetEvents(attributes);
                return GetEntry(component, component.GetType()).FilterEvents(component, attributes, events);
            }
            
            return GetEntry(component, component.GetType()).GetEvents(component, attributes, (component is ICustomTypeDescriptor));
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of properties for a specified type of
        ///       component.
        ///    </para>
        /// </devdoc>
        public static PropertyDescriptorCollection GetProperties(Type componentType) {
            return GetProperties(componentType, null);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetProperties1"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of properties for a specified 
        ///       component.</para>
        /// </devdoc>
        public static PropertyDescriptorCollection GetProperties(object component) {
            return GetProperties(component, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetProperties2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of properties for a
        ///       specified <paramref name="component"/>.
        ///    </para>
        /// </devdoc>
        public static PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc) {
            if (component == null) {
                throw new ArgumentNullException("component");
            }

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                PropertyDescriptorCollection properties = ((ICustomTypeDescriptor)component).GetProperties();
                return GetEntry(component, component.GetType()).FilterProperties(component, null, properties);
            }

            return GetProperties(component, null, (component is ICustomTypeDescriptor));
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetProperties3"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of properties for a specified type of 
        ///       component using a specified array of attributes as a filter.</para>
        /// </devdoc>
        public static PropertyDescriptorCollection GetProperties(Type componentType, Attribute[] attributes) {
            return GetEntry(null, componentType).GetProperties(null, attributes);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetProperties4"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of properties for a specified 
        ///       component using a specified array of attributes
        ///       as a filter.</para>
        /// </devdoc>
        public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes) {
            if (component == null) {
                throw new ArgumentNullException("component");
            }

            return GetProperties(component, attributes, false);
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.GetProperties5"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of properties for a specified 
        ///       component using a specified array of attributes
        ///       as a filter.</para>
        /// </devdoc>
        public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes, bool noCustomTypeDesc) {
            if (component == null) {
                return new PropertyDescriptorCollection(null, true);
            }

            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
                // Do not rip this varible -- it is here to make the get to 
                // this static variable thread-safe.
                //
                IComNativeDescriptorHandler handler = comNativeDescriptorHandler;
                
                if (handler != null) {
                    return handler.GetProperties(component, attributes);
                }
                return new PropertyDescriptorCollection(null, true);
            }

            if (!noCustomTypeDesc && component is ICustomTypeDescriptor) {
                PropertyDescriptorCollection properties = ((ICustomTypeDescriptor)component).GetProperties(attributes);
                return GetEntry(component, component.GetType()).FilterProperties(component, attributes, properties);
            }

            return GetEntry(component, component.GetType()).GetProperties(component, attributes,(component is ICustomTypeDescriptor));
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.Refresh"]/*' />
        /// <devdoc>
        ///    <para>Clears the properties and events for the specified 
        ///       component from the
        ///       cache.</para>
        /// </devdoc>
        public static void Refresh(object component) {

            if (component == null) {
                return;
            }

            // COM objects aren't cached since we don't
            // want to be holding references to them.
            if (System.Runtime.InteropServices.Marshal.IsComObject(component)) {
                return;
            }

            // We only fire the change event if we have cached the componet.
            // Since we will recreate the cache entry if anyone has asked for
            // this component... this prevents getting tons of duplicate
            // Refresh events.
            //
            ComponentEntry entry = null;
            
            lock(cachedComponentEntries) {
                entry = (ComponentEntry)cachedComponentEntries[component.GetType()];
            }
            
            if (entry != null) {

                // Clear the attribute cache.  It's not that expensive to build
                // this back up if we need to.
                //
                lock(attributeCache) {
                    attributeCache.Clear();
                }
                
                // Remove the item from the cache, it will get recreated
                // on demand.
                //
                lock(cachedComponentEntries) {
                    cachedComponentEntries.Remove(component.GetType());
                }

                // Allow the entry to dispose itself.
                //
                entry.Dispose(component);

                // Notify listeners of the change
                //
                RefreshEventHandler handler = refreshHandler;
                
                if (handler != null) {
                    handler(new RefreshEventArgs(component));
                }
            }
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.Refresh1"]/*' />
        /// <devdoc>
        ///    <para>Clears the properties and events for the specified type 
        ///       of component from the
        ///       cache.</para>
        /// </devdoc>
        public static void Refresh(Type type) {

            if (type == null) {
                return;
            }

            // We only fire the change event if we have cached the componet.
            // Since we will recreate the cache entry if anyone has asked for
            // this component... this prevents getting tons of duplicate
            // Refresh events.
            //
            bool found = false;
            
            lock (cachedComponentEntries) {
                
                ArrayList removeItems = null;

                // find all the instances of the requested type
                // and any types that derive from it,
                // and remove them.
                //
                foreach (Type cacheType in cachedComponentEntries.Keys) {
                    if (type.IsAssignableFrom(cacheType)) {
                        if (removeItems == null) {
                            removeItems = new ArrayList();
                        }
                        removeItems.Add(cacheType);
                    }
                }

                if (removeItems != null) {
                    foreach (Type t in removeItems) {
                        // Remove the item from the cache, it will get recreated
                        // on demand.
                        //
                        cachedComponentEntries.Remove(t);
                    }
                    found = true;
                }
            }

            if (found) {
            
                // Clear the attribute cache.  It's not that expensive to build
                // this back up if we need to.
                //
                lock(attributeCache) {
                    attributeCache.Clear();
                }
                
                RefreshEventHandler handler = refreshHandler;
            
                // Notify listeners of the change
                //
                if (handler != null) {
                    handler(new RefreshEventArgs(type));
                }
            }
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.Refresh2"]/*' />
        /// <devdoc>
        ///    <para>Clears the properties and events for the specified 
        ///       module from the
        ///       cache.</para>
        /// </devdoc>
        public static void Refresh(Module module) {

            if (module == null) {
                return;
            }

            ArrayList list = null;
            
            lock(cachedComponentEntries) {
                foreach (Type curType in cachedComponentEntries.Keys) {
                    if (curType.Module.Equals(module)) {
                        if (list == null) {
                            list = new ArrayList();
                        }
                        list.Add(curType);
                    }
                }

                // now remove all the ones we tagged -- can't do this
                // in the enumeration.
                //
                if (list != null) {
                    foreach(Type t in list) {
                        cachedComponentEntries.Remove(t);
                    }
                }
            }
            
            if (list != null) {
                // Clear the attribute cache.  It's not that expensive to build
                // this back up if we need to.
                //
                lock(attributeCache) {
                    attributeCache.Clear();
                }
                
                RefreshEventHandler handler = refreshHandler;
                if (handler != null) {
                    foreach(Type curType in list) {
                        handler(new RefreshEventArgs(curType));
                    }
                }
            }
        }
        
        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.Refresh3"]/*' />
        /// <devdoc>
        ///    <para>Clears the properties and events for the specified 
        ///       assembly from the
        ///       cache.</para>
        /// </devdoc>
        public static void Refresh(Assembly assembly) {

            if (assembly == null) {
                return;
            }
            
            foreach (Module mod in assembly.GetModules()) {
                Refresh(mod);
            }
        }

        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.SortDescriptorArray"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts descriptors by name of the descriptor.
        ///    </para>
        /// </devdoc>
        public static void SortDescriptorArray(IList infos) {
            ArrayList.Adapter(infos).Sort(MemberDescriptorComparer.Instance);
        }


        /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry"]/*' />
        /// <devdoc> 
        ///     ComponentEntry contains the properties, events, extenders, and attributes for 
        ///     a given type of component. 
        /// </devdoc> 
        private class ComponentEntry {
            private Type componentType;
            private PropertyDescriptorCollection properties;
            private EventDescriptorCollection events;
            private AttributeCollection attributes;
            private IList extenders;
            private Hashtable wrappedExtenderTable;
            private TypeConverter converter;
            private object[]      editors;
            private Type[]        editorTypes;
            private int           editorCount;
            
            // This is an index that we use to create a unique name for a property in the
            // event of a name collision.  The only time we should use this is when
            // a name collision happened on an extender property that has no site or
            // no name on its site.  Should be very rare.
            private static int collisionIndex = 0;
            
            // This is the signature we look for when creating types that are generic, but
            // want to know what type they are dealing with.  Enums are a good example of this;
            // there is one enum converter that can work with all enums, but it needs to know
            // the type of enum it is dealing with.
            //
            private static Type[] typeConstructor = new Type[] {typeof(Type)};

            // This is where we store the various converters, etc for the intrinsic types.
            //
            private static Hashtable intrinsicTypeConverters;

            // For converters, etc that are bound to class attribute data, rather than a class
            // type, we have special key sentinel values that we put into the hash table.
            //
            private static object intrinsicEnumKey = new object();
            private static object intrinsicReferenceKey = new object();

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.ComponentEntry"]/*' />
            /// <devdoc> 
            ///     Creates a new ComponentEntry.  The ComponentManager should be the 
            ///     only component that creates this. 
            /// </devdoc> 
            /// <internalonly/> 
            public ComponentEntry(Type componentType) {
                this.componentType = componentType;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.IntrinsicTypeConverters"]/*' />
            /// <devdoc> 
            ///      This is a table we create for intrinsic types. 
            ///      There should be entries here ONLY for intrinsic 
            ///      types, as all other types we should be able to 
            ///      add attributes directly as metadata. 
            /// </devdoc> 
            private static Hashtable IntrinsicTypeConverters {
                get {
                    // It is not worth taking a lock for this -- worst case of a collision
                    // would build two tables, one that garbage collects very quickly.
                    //
                    if (intrinsicTypeConverters == null) {
                        Hashtable temp = new Hashtable();

                        // Add the intrinsics
                        //
                        temp[typeof(bool)] = typeof(BooleanConverter);
                        temp[typeof(byte)] = typeof(ByteConverter);
                        temp[typeof(SByte)] = typeof(SByteConverter);
                        temp[typeof(char)] = typeof(CharConverter);
                        temp[typeof(double)] = typeof(DoubleConverter);
                        temp[typeof(string)] = typeof(StringConverter);
                        temp[typeof(int)] = typeof(Int32Converter);
                        temp[typeof(short)] = typeof(Int16Converter);
                        temp[typeof(long)] = typeof(Int64Converter);
                        temp[typeof(float)] = typeof(SingleConverter);
                        temp[typeof(UInt16)] = typeof(UInt16Converter);
                        temp[typeof(UInt32)] = typeof(UInt32Converter);
                        temp[typeof(UInt64)] = typeof(UInt64Converter);
                        temp[typeof(object)] = typeof(TypeConverter);
                        temp[typeof(void)] = typeof(TypeConverter);
                        temp[typeof(CultureInfo)] = typeof(CultureInfoConverter);
                        temp[typeof(DateTime)] = typeof(DateTimeConverter);
                        temp[typeof(Decimal)] = typeof(DecimalConverter);
                        temp[typeof(TimeSpan)] = typeof(TimeSpanConverter);
                        temp[typeof(Guid)] = typeof(GuidConverter);
                        temp[typeof(Array)] = typeof(ArrayConverter);
                        temp[typeof(ICollection)] = typeof(CollectionConverter);

                        // Special cases for things that are not bound to a specific type
                        //
                        temp[intrinsicEnumKey] = typeof(EnumConverter);
                        temp[intrinsicReferenceKey] = typeof(ReferenceConverter);
                        
                        intrinsicTypeConverters = temp;
                    }
                    return intrinsicTypeConverters;
                }
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.CreateInstance"]/*' />
            /// <devdoc> 
            ///      Creates an instance of the requested type.  This is used by converters 
            ///      and editors to create versions of those objects.  CreateInstance 
            ///      will look for a constructor that takes a type.  If one is found, the type of the 
            ///      component this entry is providing information for will be passed in.  This allows 
            ///      a single object to be re-used for more than one type. 
            /// </devdoc> 
            private object CreateInstance(Type type) {
                if ((!(type.IsPublic || type.IsNestedPublic)) && (type.Assembly == typeof(TypeDescriptor).Assembly)) {
                    IntSecurity.FullReflection.Demand();
                }

                ConstructorInfo ctor = type.GetConstructor(typeConstructor);
                if (ctor != null) {
                    return ctor.Invoke(new object[] {componentType});
                }
                
                return Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, null, null);
            }

            // <doc>
            // <desc>
            //      Disposes this entry.  The work we do here is to make sure that
            //      any cached information we saved on the given component has been
            //      cleared out.
            // </desc>
            // <param term='component'>
            //      The object to clear.
            // </param>
            // </doc>
            public void Dispose(object component) {
                if (component is IComponent) {
                    IDictionaryService ds = (IDictionaryService)GetService((IComponent)component, typeof(IDictionaryService));
                    if (ds != null) {
                        ds.SetValue(typeof(AttributeCollection), null);
                        ds.SetValue(typeof(EventDescriptorCollection), null);
                        ds.SetValue(typeof(PropertyStash), null);
                    }
                }
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.FilterMembers"]/*' />
            /// <devdoc> 
            ///     This function will pass through the set of members and select only those which match 
            ///     all of the given attributes. 
            /// </devdoc> 
            public virtual void FilterMembers(Type infoType, IList infos, Attribute[] attributes) {
                if (attributes != null && attributes.Length > 0 && infos.Count > 0) {
                    
                    switch (attributes.Length) {
                        case 1: {
                                Attribute filterAttribute = attributes[0];
                                for (int i=infos.Count - 1; i>=0; i--) {
                                    if (ShouldHideMember((MemberDescriptor)infos[i],filterAttribute)) {
                                        infos.RemoveAt(i);
                                    }
                                }
                                break;
                            }
                        case 2: {
                                Attribute filterAttribute1 = attributes[0];
                                Attribute filterAttribute2 = attributes[1];

                                for (int i=infos.Count - 1; i>=0; i--) {
                                    if (ShouldHideMember((MemberDescriptor)infos[i], filterAttribute1) ||
                                        ShouldHideMember((MemberDescriptor)infos[i], filterAttribute2)) {

                                        infos.RemoveAt(i);
                                    }
                                }
                                break;
                            }
                        default:
                            for (int i=infos.Count - 1; i>=0; i--) {
                                for (int j = 0; j < attributes.Length; j++) {
                                    if (ShouldHideMember((MemberDescriptor)infos[i], attributes[j])) {
                                        infos.RemoveAt(i);
                                        break;
                                    }
                                }
                            }
                            break;
                    }
                }
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetAttributes"]/*' />
            /// <devdoc> 
            ///     Retrieves the class level attributes for this type of componet that 
            ///     satisfy all of the passed-in attributes.  For a class attribute to 
            ///     satisfy a particular attribute, the attribute must be present in the 
            ///     class's attribute list, or the attribute must match it's own default. 
            /// </devdoc> 
            public AttributeCollection GetAttributes(object component) {

                // Another worst case collision scenario:  we don't want the perf hit
                // of taking a lock.
                //
                if (this.attributes == null) {
                    this.attributes = new AttributeCollection(new MemberList(this).GetAttributes());
                }
                
                AttributeCollection filteredAttributes = attributes;
                
                if (component is IComponent) {
                    ITypeDescriptorFilterService tf = (ITypeDescriptorFilterService)GetService(component, typeof(ITypeDescriptorFilterService));
                    if (tf != null) {
                    
                        // The component's site is interested in filtering attributes.  See if we
                        // have filtered them before.  If so, then we're done.  Otherwise we
                        // need to filter.
                        //
                        IDictionaryService ds = (IDictionaryService)GetService(component, typeof(IDictionaryService));
                        if (ds != null) {
                            AttributeCollection savedAttributes = null;
                            
                            lock(ds) {
                                savedAttributes = (AttributeCollection)ds.GetValue(typeof(AttributeCollection));
                            }
                            if (savedAttributes != null) {
                            
                                // Check that the filter that was used to create these attributes is the same
                                // filter we currently have.  People may replace the filter, and if we do 
                                // we must refresh the cache.
                                //
                                object savedFilter = ds.GetValue(typeof(ITypeDescriptorFilterService));
                                if (savedFilter == null || savedFilter == tf) {
                                    filteredAttributes = savedAttributes;
                                }
                            }
                        }
                        
                        if (filteredAttributes == attributes) {
                            Hashtable filterTable = new Hashtable(attributes.Count);
                            
                            if (attributes != null) {
                                foreach (Attribute attr in attributes) {
                                    filterTable[attr.TypeId] = attr;
                                }
                            }
                            
                            bool cache = tf.FilterAttributes((IComponent)component, filterTable);
                            Attribute[] temp = new Attribute[filterTable.Values.Count];
                            filterTable.Values.CopyTo(temp, 0);
                            filteredAttributes = new AttributeCollection(temp);
                            
                            if (ds != null && cache) {
                                lock(ds) {
                                    ds.SetValue(typeof(AttributeCollection), filteredAttributes);
                                    ds.SetValue(typeof(ITypeDescriptorFilterService), tf);
                                }
                            }
                        }
                    }
                }
                
                return filteredAttributes;
            }
            
            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetComponentDesigner"]/*' />
            /// <devdoc> 
            ///      Retrieves the designer for the given object, or null if there 
            ///      is no designer. 
            /// </devdoc> 
            /// <internalonly/> 
            private IDesigner GetComponentDesigner(object component) {
                IDesigner designer = null;

                if (component is IComponent) {
                    IComponent comp = (IComponent)component;
                    ISite site = comp.Site;
                    if (site != null) {
                        IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                        if (host != null) {
                            designer = host.GetDesigner(comp);
                        }
                    }
                }

                return designer;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetComponentType"]/*' />
            /// <devdoc> 
            ///     Retrieves the type of this kind of component. 
            /// </devdoc> 
            public Type GetComponentType() {
                return componentType;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetConverter"]/*' />
            /// <devdoc> 
            ///      Retrieves the type converter for this entry. 
            ///      Type converters are found by either looking for a 
            ///      TypeConverterAttribute on the component's class, or by 
            ///      traversing the base class heirarchy of the class until 
            ///      a primitive type is found. 
            /// </devdoc> 
            public TypeConverter GetConverter() {
                if (converter == null) {
                    TypeConverterAttribute attr = (TypeConverterAttribute)GetAttributes(null)[typeof(TypeConverterAttribute)];
                    if (attr != null) {
                        Type converterType = GetTypeFromName(attr.ConverterTypeName);
                        if (converterType != null && typeof(TypeConverter).IsAssignableFrom(converterType)) {
                            converter = (TypeConverter)CreateInstance(converterType);
                        }
                    }

                    if (converter == null) {

                        // We did not get a converter.  Traverse up the base class chain until
                        // we find one in the stock hashtable.
                        //
                        converter = (TypeConverter)SearchIntrinsicTable(IntrinsicTypeConverters);
                        Debug.Assert(converter != null, "There is no intrinsic setup in the hashtable for the Object type");
                    }
                }
                return converter;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetConverter1"]/*' />
            /// <devdoc> 
            ///      Retrieves the type converter for this entry. 
            ///      Type converters are found by either looking for a 
            ///      TypeConverterAttribute on the component's class, or by 
            ///      traversing the base class heirarchy of the class until 
            ///      a primitive type is found. 
            /// </devdoc> 
            public TypeConverter GetConverter(object component) {

                TypeConverter obj = null;

                // For components, the design time object for them may want to redefine the
                // attributes.  So, we search the attribute here based on the component.  If found,
                // we then search on the same attribute based on type.  If the two don't match, then
                // we cannot cache the value and must re-create every time.  It is rare for a designer
                // to override these attributes, so we want to be smart here.
                //
                TypeConverterAttribute attr = (TypeConverterAttribute)GetAttributes(component)[typeof(TypeConverterAttribute)];

                if (attr != null) {
                    TypeConverterAttribute baseAttr = (TypeConverterAttribute)GetAttributes(null)[typeof(TypeConverterAttribute)];
                    if (baseAttr != attr) {
                        Type converterType = GetTypeFromName(attr.ConverterTypeName);
                        if (converterType != null && typeof(TypeConverter).IsAssignableFrom(converterType)) {
                            obj = (TypeConverter)CreateInstance(converterType);
                        }
                    }
                }

                // No custom attribute, so we can just use the stock one.
                //
                if (obj == null) {
                    obj = GetConverter();
                }

                return obj;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetDefaultEvent"]/*' />
            /// <devdoc> 
            ///     Retrieves the default event. 
            /// </devdoc> 
            public EventDescriptor GetDefaultEvent(object component) {
                string name = ((DefaultEventAttribute)GetAttributes(component)[typeof(DefaultEventAttribute)]).Name;
                if (name != null) {
                    EventDescriptorCollection evts = GetEvents(component, null);
                    EventDescriptor evt = evts[name];
                    if (evt == null && evts.Count > 0) {
                        evt = evts[0];
                    }
                    return evt;
                }
                return null;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetDefaultProperty"]/*' />
            /// <devdoc> 
            ///     Retrieves the default property. 
            /// </devdoc> 
            public PropertyDescriptor GetDefaultProperty(object component) {
                string name = ((DefaultPropertyAttribute)GetAttributes(component)[typeof(DefaultPropertyAttribute)]).Name;
                if (name != null) {
                    return GetProperties(component, null)[name];
                }
                return null;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetEditor"]/*' />
            /// <devdoc> 
            ///      Retrieves an editor with the given base type.  You may define multiple editor 
            ///      attributes for a type or property.  This allows you to select the one you want. 
            /// </devdoc> 
            public object GetEditor(Type editorBaseType) {
                object editor = null;

                // Check the editors we've already created for this type.
                //
                lock(this) {
                    if (editorTypes != null) {
                        for (int i = 0; i < editorCount; i++) {
                            if (editorTypes[i] == editorBaseType) {
                                return editors[i];
                            }
                        }
                    }
                }

                // If one wasn't found, then we must go through the attributes.
                //
                if (editor == null) {
                    AttributeCollection attrs = GetAttributes(null);

                    for (int i = 0; i < attrs.Count; i++) {

                        if (attrs[i] is EditorAttribute) {
                            EditorAttribute attr = (EditorAttribute)attrs[i];
                            Type attrEditorBaseType = GetTypeFromName(attr.EditorBaseTypeName);
                            
                            if (attrEditorBaseType != null && attrEditorBaseType == editorBaseType) {
                                Type type = GetTypeFromName(attr.EditorTypeName);
    
                                if (type != null) {
                                    editor = CreateInstance(type);
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Check our set of intrinsic editors.  These are provided by an external party.
                    //
                    if (editor == null) {
                        Hashtable intrinsicEditors = TypeDescriptor.GetEditorTable(editorBaseType);
                        if (intrinsicEditors != null) {
                            editor  = SearchIntrinsicTable(intrinsicEditors);
                        }
                    }
                    
                    // As a quick sanity check, check to see that the editor we got back is of 
                    // the correct type.
                    //
                    if (editor != null && !editorBaseType.IsInstanceOfType(editor)) {
                        Debug.Fail("Editor " + editor.GetType().FullName + " is not an instance of " + editorBaseType.FullName + " but it is in that base types table.");
                        editor = null;
                    }
                        
                    // Now, another slot in our editor cache for next time
                    //
                    lock(this) {
                    
                        // we do a redundant check here for the editor, just in 
                        // case another thread added it.  We could have locked
                        // the entire method, but with all of the other
                        // callouts from this method deadlock becomes more probable.
                        //
                        // This is very safe, but I'm not sure there are any
                        // bad consequences of having duplicate editor types in the
                        // array.  Better to be safe, but we do take an ever so minor
                        // hit here...
                        //
                        bool redundantEditor = false;
                        
                        if (editorTypes != null) {
                            for (int i = 0; i < editorCount; i++) {
                                if (editorTypes[i] == editorBaseType) {
                                    redundantEditor = true;
                                    break;
                                }
                            }
                        }
                    
                        if (!redundantEditor) {
                            if (editorTypes == null) {
                                editorTypes = new Type[5];
                                editors = new object[5];
                            }
            
                            if (editorCount >= editorTypes.Length) {
                                Type[] newTypes = new Type[editorTypes.Length * 2];
                                object[] newEditors = new object[editors.Length * 2];
                                Array.Copy(editorTypes, newTypes, editorTypes.Length);
                                Array.Copy(editors, newEditors, editors.Length);
                                editorTypes = newTypes;
                                editors = newEditors;
                            }
            
                            editorTypes[editorCount] = editorBaseType;
                            editors[editorCount++] = editor;
                        }
                    }
                }

                return editor;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetEditor1"]/*' />
            /// <devdoc> 
            ///      Retrieves an editor with the given base type.  You may define multiple editor 
            ///      attributes for a type or property.  This allows you to select the one you want. 
            /// </devdoc> 
            public object GetEditor(object component, Type editorBaseType) {
                object editor = null;

                // For components, the design time object for them may want to redefine the
                // attributes.  So, we search the attribute here based on the component.  If found,
                // we then search on the same attribute based on type.  If the two don't match, then
                // we cannot cache the value and must re-create every time.  It is rare for a designer
                // to override these attributes, so we want to be smart here.
                //
                AttributeCollection attrs;

                EditorAttribute attr = null;

                attrs = GetAttributes(component);
                for (int i = 0; i < attrs.Count; i++) {

                    if (attrs[i] is EditorAttribute) {
                        EditorAttribute a = (EditorAttribute)attrs[i];
                        Type attrEditorBaseType = GetTypeFromName(a.EditorBaseTypeName);
    
                        if (attrEditorBaseType != null && attrEditorBaseType == editorBaseType) {
                            attr = a;
                            break;
                        }
                    }
                }

                if (attr != null) {
                    // Now, compare this attribute against the one provided by the normal attribute set for the
                    // type.  If it is the same, then we can resort to the normal GetEditor call.  Otherwise,
                    // we must create the editor anew.
                    //
                    EditorAttribute baseAttr = null;

                    attrs = GetAttributes(null);
                    for (int i = 0; i < attrs.Count; i++) {

                        if (attrs[i] is EditorAttribute) {
                            EditorAttribute a = (EditorAttribute)attrs[i];
                            Type attrEditorBaseType = GetTypeFromName(a.EditorBaseTypeName);
    
                            if (attrEditorBaseType != null && attrEditorBaseType == editorBaseType) {
                                baseAttr = a;
                                break;
                            }
                        }
                    }

                    if (attr != baseAttr) {
                        // The attribute we should use is a custom attribute provided by the
                        // designer of this object.  Create the editor directly.  This will
                        // be fairly rare (nothing in .NET uses this today, and we're pretty
                        // broad), so I'm not too concerned with caching this.
                        //
                        Type type = GetTypeFromName(attr.EditorTypeName);
                        if (type != null) {
                            editor = CreateInstance(type);
                        }
                    }
                }

                if (editor == null) {
                    editor = GetEditor(editorBaseType);
                }
                else {
                    // As a quick sanity check, check to see that the editor we got back is of 
                    // the correct type.
                    //
                    if (editor != null && !editorBaseType.IsInstanceOfType(editor)) {
                        Debug.Fail("Editor " + editor.GetType().FullName + " is not an instance of " + editorBaseType.FullName + " but it is in that base types table.");
                        editor = null;
                    }
                }

                return editor;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetEvents2"]/*' />
            /// <devdoc> 
            ///     Retrieves events that satisfy all of the passed-in attributes. 
            ///     For an event to satisfy a particular attribute, the attribute must be 
            ///     present in the event's attribute list, or the attribute must match it's 
            ///     own default.  The returned array is sorted based on the sort parameter. 
            /// </devdoc> 
            public EventDescriptorCollection GetEvents(object component, Attribute[] attributes) {
                return GetEvents(component, attributes, false);
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetEvents"]/*' />
            /// <devdoc> 
            ///     Retrieves events that satisfy all of the passed-in attributes. 
            ///     For an event to satisfy a particular attribute, the attribute must be 
            ///     present in the event's attribute list, or the attribute must match it's 
            ///     own default.  The returned array is sorted based on the sort parameter. 
            /// </devdoc> 
            public EventDescriptorCollection GetEvents(object component, Attribute[] attributes, bool noFilter) {
                // Worst case event collision scenario is two sets of events.  Much cheaper than
                // a constant lock.
                //
                if (this.events == null) {
                    this.events = new EventDescriptorCollection(new MemberList(this).GetEvents(), true);
                }

                EventDescriptorCollection filteredEvents = events;

                if (component is IComponent) {
                    ITypeDescriptorFilterService tf = (ITypeDescriptorFilterService)GetService(component, typeof(ITypeDescriptorFilterService));
                    
                    if (!noFilter && tf != null) {
                        // The component's site is interested in filtering events.  See if we
                        // have filtered them before.  If so, then we're done.  Otherwise we
                        // need to filter.
                        //
                        IDictionaryService ds = (IDictionaryService)GetService(component, typeof(IDictionaryService));
                        if (ds != null) {
                            EventDescriptorCollection savedEvents = null;
                             
                            lock(ds) {
                                savedEvents = (EventDescriptorCollection)ds.GetValue(typeof(EventDescriptorCollection));
                            }
                            
                            if (savedEvents != null) {
                            
                                // Check that the filter that was used to create these attributes is the same
                                // filter we currently have.  People may replace the filter, and if we do 
                                // we must refresh the cache.
                                //
                                object savedFilter = ds.GetValue(typeof(ITypeDescriptorFilterService));
                                if (savedFilter == null || savedFilter == tf) {
                                    filteredEvents = savedEvents;
                                }
                            }
                        }
                        
                        if (filteredEvents == events) {
                            Hashtable filterTable = new Hashtable(events.Count);
                            
                            if (events != null) {
                                foreach (EventDescriptor ev in events) {
                                    filterTable[ev.Name] = ev;
                                }
                            }
                            
                            bool cache = tf.FilterEvents((IComponent)component, filterTable);
                            EventDescriptor[] temp = new EventDescriptor[filterTable.Values.Count];
                            filterTable.Values.CopyTo(temp, 0);
                            filteredEvents = new EventDescriptorCollection(temp, true);
                            
                            if (ds != null && cache) {
                                lock(ds) {
                                    ds.SetValue(typeof(EventDescriptorCollection), filteredEvents);
                                    ds.SetValue(typeof(ITypeDescriptorFilterService), tf);
                                }
                            }
                        }
                    }
                }
                
                if (attributes != null && attributes.Length > 0) {
                    ArrayList list = new ArrayList(filteredEvents);
                    FilterMembers(typeof(EventDescriptor), list, attributes);
                    EventDescriptor[] temp = new EventDescriptor[list.Count];
                    list.CopyTo(temp, 0);
                    filteredEvents = new EventDescriptorCollection(temp, true);
                }
                
                return filteredEvents;
            }

            internal EventDescriptorCollection FilterEvents(object component, Attribute[] attributes, EventDescriptorCollection events) {
                EventDescriptorCollection filteredEvents = events;

                if (component is IComponent) {
                    ITypeDescriptorFilterService tf = (ITypeDescriptorFilterService)GetService(component, typeof(ITypeDescriptorFilterService));
                    if (tf != null) {
                        Hashtable filterTable = new Hashtable(events.Count);
                        
                        if (events != null) {
                            foreach (EventDescriptor ev in events) {
                                filterTable[ev.Name] = ev;
                            }
                        }
                        
                        bool cache = tf.FilterEvents((IComponent)component, filterTable);
                        EventDescriptor[] temp = new EventDescriptor[filterTable.Values.Count];
                        filterTable.Values.CopyTo(temp, 0);
                        filteredEvents = new EventDescriptorCollection(temp, true);
                    }
                }
                
                if (attributes != null && attributes.Length > 0) {
                    ArrayList list = new ArrayList(filteredEvents);
                    FilterMembers(typeof(EventDescriptor), list, attributes);
                    EventDescriptor[] temp = new EventDescriptor[list.Count];
                    list.CopyTo(temp, 0);
                    filteredEvents = new EventDescriptorCollection(temp, true);
                }
                
                return filteredEvents;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetExtendedProperties"]/*' />
            /// <devdoc> 
            ///     Retrieves the filtered set of extended properties that this specific component receives.  These 
            ///     extended properties wrap both the base extender info and the extender provider to make it appear as a 
            ///     regular property.  The filtering is based on the given attributes. 
            ///     For an extended property to satisfy a particular attribute, the attribute must be 
            ///     present in the extended property's attribute list, or the attribute must match it's 
            ///     own default. The array is sorted based on the sort property. 
            /// </devdoc> 
            private ICollection GetExtendedProperties(IComponent comp, IExtenderProvider[] providers) {
                Type componentType = comp.GetType();
                
                Debug.WriteLineIf(CompDescrSwitch.TraceVerbose, "\tFound " + providers.Length.ToString() + " providers");
                IList list = new ArrayList();

                for (int i = 0; i < providers.Length; i++) {

                    if (!providers[i].CanExtend(comp)) {
                        continue;
                    }

                    IExtenderProvider provider = providers[i];
                    Type providerType = provider.GetType();
                    ComponentEntry providerCompInfo = TypeDescriptor.GetEntry(comp, providerType);

                    IList providerWrappedExtenders = providerCompInfo.GetWrappedExtenders(provider);
                    Debug.WriteLineIf(CompDescrSwitch.TraceVerbose, "\twrapped extenders: " + providerWrappedExtenders.Count.ToString());

                    for (int j = 0; j < providerWrappedExtenders.Count; j++) {
                        PropertyDescriptor currentWrappedExtender = (PropertyDescriptor)providerWrappedExtenders[j];
                        Type receiverType = null;

                        ExtenderProvidedPropertyAttribute eppa = (ExtenderProvidedPropertyAttribute)currentWrappedExtender.Attributes[typeof(ExtenderProvidedPropertyAttribute)];
                        if (eppa.ReceiverType != null) {
                            receiverType = eppa.ReceiverType;
                        }

                        if (receiverType != null && receiverType.IsAssignableFrom(componentType)) {
                            list.Add(currentWrappedExtender);
                        }
                    }
                }
                return list;
            }
            
            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetExtenderCollisionSuffix"]/*' />
            /// <devdoc>
            ///     This method is invoked during property filtering when a name
            ///     collision is encountered between two properties.  This returns
            ///     a suffix that can be appended to the property name to make
            ///     it unique.  This will first attempt ot use the name of the
            ///     extender.  Failing that it will fall back to a static
            ///     index that is continually incremented.
            /// </devdoc>
            private string GetExtenderCollisionSuffix(PropertyDescriptor prop) {
                string suffix = null;
                
                ExtenderProvidedPropertyAttribute exAttr = (ExtenderProvidedPropertyAttribute)prop.Attributes[typeof(ExtenderProvidedPropertyAttribute)];
                if (exAttr != null) {
                    IExtenderProvider prov = exAttr.Provider;
                    
                    if (prov != null) {
                        string name = null;
                        
                        if (prov is IComponent) {
                            ISite site = ((IComponent)prov).Site;
                            if (site != null) {
                                name = site.Name;
                            }
                        }
                        
                        if (name == null) {
                            name = (collisionIndex++).ToString();
                        }
                        
                        suffix = "_" + name;
                    }
                }
                
                return suffix;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetExtenderProviders"]/*' />
            /// <devdoc> 
            ///      Retrieves the set of extender providers providing services for the given component. 
            /// </devdoc> 
            private IExtenderProvider[] GetExtenderProviders(ISite site) {
                // See if this component's site has an IExtenderListService.  If it
                // does, we get our list of extenders from that, not from the container.
                //
                IExtenderListService listService = (IExtenderListService)site.GetService(typeof(IExtenderListService));

                if (listService != null) {
                    return listService.GetExtenderProviders();
                }
                else {
                    ComponentCollection comps = site.Container.Components;
                    ArrayList exList = null;
                    foreach(IComponent comp in comps) {
                        if (comp is IExtenderProvider) {
                            if (exList == null) {
                                exList = new ArrayList(2);
                            }
                            exList.Add(comp);
                        }
                    }
                    if (exList == null) {
                        return null;
                    }
                    else {
                        IExtenderProvider[] temp = new IExtenderProvider[exList.Count];
                        exList.CopyTo(temp, 0);
                        return temp;
                    }
                }
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetExtenders"]/*' />
            /// <devdoc> 
            ///     Retrieves base extenders that this type of component provides that satisfy all of the 
            ///     passed-in attributes. For an extender to satisfy a particular attribute, the attribute 
            ///     must be present in the extender's attribute list, or the attribute must match it's 
            ///     own default.  The array is sorted based on the sort parameter. 
            /// </devdoc> 
            public IList GetExtenders() {
                if (this.extenders == null) {
                    this.extenders = new MemberList(this).GetExtenders();
                }
                
                return extenders;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetProperties2"]/*' />
            /// <devdoc> 
            ///     Retrieves properties that satisfy all of the passed-in attributes. 
            ///     For a property to satisfy a particular attribute, the attribute must be 
            ///     present in the property's attribute list, or the attribute must match it's 
            ///     own default.  The array is sorted based on the sort parameter. 
            /// </devdoc> 
            public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes) {
                return GetProperties(component, attributes, false);
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetProperties"]/*' />
            /// <devdoc> 
            ///     Retrieves properties that satisfy all of the passed-in attributes. 
            ///     For a property to satisfy a particular attribute, the attribute must be 
            ///     present in the property's attribute list, or the attribute must match it's 
            ///     own default.  The array is sorted based on the sort parameter. 
            /// </devdoc> 
            public PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes, bool noFilter) {
                if (this.properties == null) {
                    this.properties = new PropertyDescriptorCollection(new MemberList(this).GetProperties(), true);
                }
                
                // We will use this to reconstruct the set of properties in case we have extenders, etc.
                //
                ArrayList allProps = null;
                PropertyStash propStash = null;
                bool inDictionary = false;
                
                // This will be what we finally return.  we default to the current static set of 
                // properties.
                //
                PropertyDescriptorCollection filteredProperties = properties;
                
                if (component is IComponent) {
                    ISite site = ((IComponent)component).Site;
                    IExtenderProvider[] providers;
                    
                    if (site != null) {
                        providers = GetExtenderProviders(site);
                    }
                    else {
                        providers = null;
                    }
                
                    ITypeDescriptorFilterService tf = null;
                    if (!noFilter)
                        tf = (ITypeDescriptorFilterService)GetService(component, typeof(ITypeDescriptorFilterService));
                    
                    // First, check to see if we found the properties in the dictionary service.  If so, we
                    // can fall out immediately because we have already stashed them.
                    //
                    IDictionaryService ds = (IDictionaryService)GetService(component, typeof(IDictionaryService));
                    if (ds != null) {
                        object filterStash = null;
                        
                        lock(ds) {
                            propStash = (PropertyStash)ds.GetValue(typeof(PropertyStash));
                            filterStash = ds.GetValue(typeof(ITypeDescriptorFilterService));
                        }
                            
                        // Check that the filter that was used to create these attributes is the same
                        // filter we currently have.  People may replace the filter, and if we do 
                        // we must refresh the cache.
                        //
                        if ((filterStash == null || filterStash == tf) && propStash != null && propStash.ExtendersMatch(providers)) {
                            // Now check to see if the stashed array of attributes also matches.  If
                            // it does, then we can return a stashed pre-filtered set of props.
                            //
                            if (propStash.AttributesMatch(attributes)) {
                                filteredProperties = propStash.FilteredProperties;
                                attributes = null;
                            }
                            else {
                                allProps = propStash.Properties;
                            }
                            inDictionary = true;
                        }
                    }
                    
                    // Now check to see if the container wants to filter the set of properties.
                    //
                    if (!inDictionary) {
                        if (providers != null && providers.Length > 0) {
                            ICollection extendedProperties = GetExtendedProperties((IComponent)component, providers);
        
                            if (extendedProperties != null && extendedProperties.Count > 0) {
                                allProps = new ArrayList(properties.Count + extendedProperties.Count);
                                allProps.AddRange(properties);
                                allProps.AddRange(extendedProperties);
                            }
                        }
                    
                        if (tf != null) {
                            Hashtable filterTable = new Hashtable(properties.Count);
                            
                            if (allProps == null) {
                                allProps = new ArrayList(properties);
                            }
                            
                            foreach (PropertyDescriptor p in allProps) {
                                // We must handle the case of duplicate property names
                                // because extender providers can provide any arbitrary
                                // name.  Our rule for this is simple:  If we find a
                                // duplicate name, resolve it back to the extender
                                // provider that offered it and append "_" + the
                                // provider name.  If the provider has no name,
                                // then append the object hash code.
                                //
                                if (filterTable.Contains(p.Name)) {
                                    
                                    // First, handle the new property.  Because
                                    // of the order in which we added extended
                                    // properties above, we can be sure that
                                    // the new property is an extender.  We
                                    // cannot be sure that the existing property
                                    // in the table is an extender, so we will 
                                    // have to check.
                                    //
                                    string suffix = GetExtenderCollisionSuffix(p);
                                    Debug.Assert(suffix != null, "Name collision with non-extender property.");
                                    if (suffix != null) {
                                        filterTable[p.Name + suffix] = p;
                                    }
                                    
                                    // Now, handle the original property.
                                    //
                                    PropertyDescriptor origProp = (PropertyDescriptor)filterTable[p.Name];
                                    suffix = GetExtenderCollisionSuffix(origProp);
                                    if (suffix != null) {
                                        filterTable.Remove(p.Name);
                                        filterTable[origProp.Name + suffix] = origProp;
                                    }
                                }
                                else {
                                    filterTable[p.Name] = p;
                                }
                            }
                            
                            bool cache = tf.FilterProperties((IComponent)component, filterTable);
    
                            allProps = new ArrayList(filterTable.Values);
                            
                            if (ds != null && cache) {
                                propStash = new PropertyStash(allProps, providers);
                                lock(ds) {
                                    ds.SetValue(typeof(PropertyStash), propStash);
                                    ds.SetValue(typeof(ITypeDescriptorFilterService), tf);
                                }
                                inDictionary = true;
                            }
                        }
                    }
                }
    
                if (attributes != null && attributes.Length > 0) {
                    if (allProps == null) {
                        allProps = new ArrayList(properties);
                    }
                    else if (inDictionary) {
                        // If we just poked this into the dictionary, we must clone.  Otherwise
                        // we will disrupt the dictionary.
                        //
                        allProps = new ArrayList(allProps);
                        inDictionary = false;
                    }
                    FilterMembers(typeof(PropertyDescriptor), allProps, attributes);
                }
                
                if (allProps != null) {

                    PropertyDescriptor[] temp = new PropertyDescriptor[allProps.Count];
                    allProps.CopyTo(temp, 0);
                    filteredProperties = new PropertyDescriptorCollection(temp, true);
                    if (propStash != null) {
                        propStash.FilteredProperties = filteredProperties;
                        propStash.Attributes = attributes;
                    }
                }
                
                return filteredProperties;
            }

           internal PropertyDescriptorCollection FilterProperties(object component, Attribute[] attributes, PropertyDescriptorCollection properties) {
               PropertyDescriptorCollection filteredProperties = properties;
            
               ArrayList allProps = null;

                if (component is IComponent) {
                    ITypeDescriptorFilterService tf = (ITypeDescriptorFilterService)GetService(component, typeof(ITypeDescriptorFilterService));
                    
                    if (tf != null) {
                        Hashtable filterTable = new Hashtable(properties.Count);

                        foreach(PropertyDescriptor p in properties) {
                            string suffix = GetExtenderCollisionSuffix(p);
                            if (suffix == null)
                                suffix = "";

                            Debug.Assert(!filterTable.Contains(p.Name + suffix), "Overwriting PropertyDescriptor during filtering!!! " + p.Name + suffix);
                            filterTable[p.Name + suffix] = p;
                        }
                        
                        tf.FilterProperties((IComponent)component, filterTable);
                        allProps = new ArrayList(filterTable.Values);
                    }
                }
            
                if (attributes != null && attributes.Length > 0) {
                    if (allProps == null) {
                        allProps = new ArrayList(properties);
                    }
                    FilterMembers(typeof(PropertyDescriptor), allProps, attributes);
                }
                
                if (allProps != null) {
                    PropertyDescriptor[] temp = new PropertyDescriptor[allProps.Count];
                    allProps.CopyTo(temp, 0);
                    filteredProperties = new PropertyDescriptorCollection(temp, true);
                }
                
                return filteredProperties;
            }
            
            private object GetService(object component, Type type) {
                if (component == null) {
                    throw new ArgumentNullException("component");
                }

                if (component is IComponent) 
                {
                    ISite site = ((IComponent)component).Site;
                    if (site != null) {
                        return site.GetService(type);
                    }
                }
                return null;
            }
           
            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetTypeFromName"]/*' />
            /// <devdoc>
            ///       Retrieves a type from a name.  The Assembly of the type
            ///        that this PropertyDescriptor came from is first checked,
            ///        then a global Type.GetType is performed.
            /// </devdoc>
            protected Type GetTypeFromName(string typeName) {
                  
                if (typeName == null || typeName.Length == 0) {
                     return null;
                }
            
                int commaIndex = typeName.IndexOf(',');
                Type t = null;
                
                if (commaIndex == -1) {
                    t = componentType.Module.Assembly.GetType(typeName);
                }
                
                if (t == null) {
                    t = Type.GetType(typeName);
                }
                
                return t;
            }
            
            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.GetWrappedExtenders"]/*' />
            /// <devdoc> 
            ///     Retrieves filtered, wrapped extended properties based on the provider and the extenderInfos for this type of provider. 
            ///     These are the extended properties that will be handed out to components through 
            ///     getExtendedProperties and getMergedProperties.  These are wrapped versions of what is returned 
            ///     through getExtenders. They are filtered based on the attributes. They are sorted 
            ///     based on the sort property. 
            /// </devdoc> 
            private IList GetWrappedExtenders(IExtenderProvider provider) {
                Debug.WriteLineIf(CompDescrSwitch.TraceVerbose, "GetWrappedExtenders");
                if (wrappedExtenderTable == null) {
                    wrappedExtenderTable = new Hashtable();
                }

                if (provider == null) {
                    return null;
                }

                Type providerType = ((object)provider).GetType();
                if (!componentType.IsAssignableFrom(providerType)) {
                    throw new ArgumentException(SR.GetString(SR.ErrorBadExtenderType, providerType.Name, componentType.Name), "provider");
                }

                bool sitedProvider = false;

                if (provider is IComponent && ((IComponent)provider).Site != null) {
                    sitedProvider = true;
                }

                IList wrappedExtenders = null;
                
                lock(this) {
                    wrappedExtenders = (IList) wrappedExtenderTable[provider];
                    
                    if (wrappedExtenders == null) {
                        Debug.WriteLineIf(CompDescrSwitch.TraceVerbose, "\tentry not found in table... creating");
                        IList extenders = GetExtenders();
                        Debug.WriteLineIf(CompDescrSwitch.TraceVerbose, "\tfound " + extenders.Count.ToString() + " extenders");
                        wrappedExtenders = new ArrayList(extenders.Count);
                        for (int i = 0; i < extenders.Count; i++) {
                            ReflectPropertyDescriptor ex = (ReflectPropertyDescriptor)extenders[i];
                            Attribute[] attrs = null;
    
                            // If the extender provider is not a sited component, then mark all
                            // of its properties as design time only, since there is no way we
                            // can persist them.  We can assume this because this is only called if
                            // we could get the extender provider list from a component site.
                            //
                            if (!sitedProvider) {
                                attrs = new Attribute[] {DesignOnlyAttribute.Yes};
                            }
    
                            wrappedExtenders.Add(new ExtendedPropertyDescriptor(ex, ex.ExtenderGetReceiverType(), provider, attrs));
                        }
                        wrappedExtenderTable[provider] = wrappedExtenders;
                    }
                    else {
                        Debug.WriteLineIf(CompDescrSwitch.TraceVerbose, "\tentry found in table...");
                    }
                }

                return wrappedExtenders;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.SearchIntrinsicTable"]/*' />
            /// <devdoc> 
            ///      Searches the provided intrinsic hashtable for a match with the compnent type. 
            ///      At the beginning, the hashtable contains types for the various converters. 
            ///      As this table is searched, the types for these objects 
            ///      are replaced with instances, so we only create as needed.  This method 
            ///      does the search up the base class hierarchy and will create instances 
            ///      for types as needed.  These instances are stored back into the table 
            ///      for the base type, and for the original component type, for fast access. 
            /// </devdoc> 
            private object SearchIntrinsicTable(Hashtable table) {

                object hashEntry = null;
                Type baseType = componentType;
                
                // We take a lock on this table.  Nothing in this code calls out to
                // other methods that lock, so it should be fairly safe to grab this
                // lock.  Also, this allows multiple intrinsic tables to be searched
                // at once.
                //
                lock(table) {
                    // Here is where we put all special case logic for various intrinsics
                    // that cannot be directly mapped to a type.
                    //
                    if (componentType.IsCOMObject) {
                        // placeholder for COM converters, etc.
                    }
                    else {
                        if (componentType.IsEnum) {
                            hashEntry = table[intrinsicEnumKey];
                        }
                    }
    
                    // Normal path -- start traversing up the class hierarchy
                    // looking for matches.
                    //
                    if (hashEntry == null) {
                        while (baseType != null && baseType != typeof(object)) {
                            hashEntry = table[baseType];
                        
                            // If the entry is a late-bound type, then try to
                            // resolve it.
                            //
                            if (hashEntry is string) {
                                hashEntry = Type.GetType((string)hashEntry);
                                if (hashEntry != null) {
                                    table[baseType] = hashEntry;
                                }
                            }
                            
                            if (hashEntry != null) {
                                break;
                            }
                            
                            baseType = baseType.BaseType;
                        }
                    }
                    
                    // Now make a scan through each value in the table, looking for interfaces.
                    // If we find one, see if the object implements the interface.
                    //
                    if (hashEntry == null) {
                    
                        foreach (object current in table.Keys) {
                            if (current is Type) {
                                Type keyType = (Type)current;
                                if (keyType.IsInterface && keyType.IsAssignableFrom(componentType)) {
                                    hashEntry = table[keyType];
                                    
                                    if (hashEntry is string) {
                                        hashEntry = Type.GetType((string)hashEntry);
                                        if (hashEntry != null) {
                                            table[componentType] = hashEntry;
                                        }
                                    }
                                    
                                    if (hashEntry != null) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Finally, check to see if the component type is some unknown interface.
                    // We have a custom converter for that.
                    //
                    if (hashEntry == null && componentType.IsInterface) {
                        hashEntry = table[intrinsicReferenceKey];
                    }
                        
                    // Interfaces do not derive from object, so we
                    // must handle the case of no hash entry here.
                    //
                    if (hashEntry == null) {
                        hashEntry = table[typeof(object)];
                    }
                    
                    // If the entry is a type, create an instance of it and then
                    // replace the entry.  This way we only need to create once.
                    // We can only do this if the object doesn't want a type
                    // in its constructor.
                    //
                    if (hashEntry is Type) {
                        Type type = (Type)hashEntry;
                        hashEntry = CreateInstance(type);
                        
                        if (type.GetConstructor(typeConstructor) == null) {
                            table[componentType] = hashEntry;
                        }
                    }
                }

                return hashEntry;
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.ShouldHideMember"]/*' />
            /// <devdoc> 
            ///     This function takes an info and an attribute and determines whether 
            ///     the info satisfies the particular attribute.  This either means that the info 
            ///     contains the attribute or the info does not contain the attribute and the default 
            ///     for the attribute matches the passed in attribute. 
            /// </devdoc> 
            /// <internalonly/> 
            internal static bool ShouldHideMember(MemberDescriptor info, Attribute attribute) {
                if (info == null || attribute == null) {
                    return true;
                }
                Attribute infoAttribute = info.Attributes[attribute.GetType()];
                if (infoAttribute == null)
                    return !attribute.IsDefaultAttribute();
                else {
                    return !(attribute.Match(infoAttribute));
                }
            }

            /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.MemberList"]/*' />
            /// <devdoc> 
            /// </devdoc> 
            /// <internalonly/> 
            private sealed class MemberList {
                private Hashtable memberHash = new Hashtable();
                private ComponentEntry owner;

                public MemberList(ComponentEntry owner) {
                    this.owner = owner;
                }
                
                public void AddMember(object member) {
                    if (member is MemberDescriptor) {
                        memberHash[((MemberDescriptor)member).Name] = member;
                    }
                    else if (member is Attribute) {
                        object id = ((Attribute)member).TypeId;
                        memberHash[id] = member;
                    }
                    else {
                        memberHash[member.GetType()] = member;
                    }
                }

                internal Attribute[] GetAttributes() {
                    Attribute[] ret = null;
                    
                    memberHash.Clear();

                    Debug.WriteLineIf(CompDescrSwitch.TraceVerbose, "Getting attributes from " + owner.componentType.FullName);
                    
                    // Before we reflect on the type attributes, do the same for the type's interfaces, if it implements any.
                    // We add these in reflection order.
                    //
                    Type[] interfaces = owner.componentType.GetInterfaces();
                    foreach(Type iface in interfaces) {
                        // only do this for public interfaces
                        //
                        if ((iface.Attributes & (TypeAttributes.Public | TypeAttributes.NestedPublic)) != 0) {
                            ReflectGetCustomAttributes(iface, typeof(Attribute));
                        }
                    }
                    
                    // Now do the actual type.  Last one in wins.
                    //
                    ReflectGetCustomAttributes(owner.componentType, typeof(Attribute));

                    // NOTE : You cannot combine designer attributes with the base class attributes.
                    // To find the designer you must get the attributes on this class, thus causing
                    // an infinite recursion... don't do that!
                    //
                    ret = new Attribute[memberHash.Values.Count];
                    memberHash.Values.CopyTo(ret, 0);

                    return ret;
                }

                /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.MemberList.GetEvents"]/*' />
                /// <devdoc> 
                /// </devdoc> 
                /// <internalonly/> 
                internal EventDescriptor[] GetEvents() {
                    EventDescriptor[] ret = null;

                    memberHash.Clear();

                    ReflectGetEvents(owner.componentType);

                    ret = new EventDescriptor[memberHash.Values.Count];
                    memberHash.Values.CopyTo(ret, 0);
                    
                    return ret;
                }

                /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.MemberList.GetExtenders"]/*' />
                /// <devdoc> 
                /// </devdoc> 
                /// <internalonly/> 
                internal IList GetExtenders() {
                    ArrayList ret = null;

                    memberHash.Clear();

                    ReflectGetExtenders(owner.componentType);

                    ret = new ArrayList(memberHash.Values);

                    return ret;
                }

                internal PropertyDescriptor[] GetProperties() {
                    PropertyDescriptor[] ret = null;

                    memberHash.Clear();

                    ReflectGetProperties(owner.componentType);

                    ret = new PropertyDescriptor[memberHash.Values.Count];
                    memberHash.Values.CopyTo(ret, 0);
                    
                    return ret;
                }

                /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.MemberList.ReflectGetCustomAttributes"]/*' />
                /// <devdoc> 
                ///     Reflects on a class and it's base classes to find any custom 
                ///     attributes of the specified type. The comparison to the metadataType 
                ///     is a not strict comparison and will return derived instances. 
                /// </devdoc> 
                private void ReflectGetCustomAttributes(Type classToReflect, Type metadataType) {
                    AttributeCollection baseAttributes = null;
                    Hashtable           attrHash = new Hashtable();
                    #if DEBUG
                    if (CompDescrSwitch.TraceVerbose) {
                        Debug.WriteLine("  retrieving metadata for " + classToReflect.FullName);
                        Debug.WriteLine("  classToRefelct: " + classToReflect.FullName);
                        Debug.WriteLine("  metadataType: " + metadataType.FullName);
                    }
                    #endif

                    // We only want to reflect on one level at a time,
                    // so if we have a base class above object, we get the
                    // attributes for that first.
                    //
                    Type baseType = classToReflect.BaseType;
                    if (baseType != typeof(object) && baseType != null) {
                        baseAttributes = TypeDescriptor.GetAttributes(baseType);
                    }

                    if (baseAttributes != null && baseAttributes.Count > 0) {
                        foreach (Attribute attr in baseAttributes) {
                            Type attrType = attr.GetType();
                            if (metadataType.IsAssignableFrom(attrType)) {
                                attrHash[attr.TypeId] = attr;    
                            }
                        }
                    }

                    // now get our attributes
                    //
                    object[] attributes = TypeDescriptor.GetCustomAttributes(classToReflect);

                    foreach (Attribute attr in attributes) {
                        Type attrType = attr.GetType();
                        if (metadataType.IsAssignableFrom(attrType)) {
                            attrHash[attr.TypeId] = attr;    
                        }
                    }

                    // push the values up to the top level
                    //
                    foreach (Attribute attr in attrHash.Values) {
                        AddMember(attr);
                    }
                }

                /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.MemberList.ReflectGetEvents"]/*' />
                /// <devdoc> 
                ///      Reflects on a class to find the events for that class.  This 
                ///      calls AddMember for each new event that it finds. 
                /// </devdoc> 
                private void ReflectGetEvents(Type classToReflect) {
                    Type currentType = classToReflect;
                    Hashtable eventHash = null;
                    
                    EventDescriptorCollection baseTypeEvents = null;


                    // We only want to reflect on one level at a time,
                    // so if we have a base class above object, we get the
                    // properties for that first.
                    //
                    Type baseType = classToReflect.BaseType;
                    if (baseType != typeof(object) && baseType != null) {
                        baseTypeEvents = TypeDescriptor.GetEvents(baseType);
                    }

                    // for this particular type, we get _only_ the properties
                    // declared on that type
                    //
                    EventInfo[] events = classToReflect.GetEvents(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance);

                    // if we have properties from the base type, stick them into
                    // a hashtable because we'll want to override them with re-declared
                    // properties on this particular type.
                    //
                    if (baseTypeEvents != null && baseTypeEvents.Count > 0) {
                        eventHash = new Hashtable();
                        foreach(EventDescriptor ed in baseTypeEvents) {
                            eventHash[ed.Name] = ed;
                        }
                    }   

                    // now walk each event we got an make sure it's got an add and a remove
                    //
                    foreach(EventInfo eventInfo in events) {
                        if ((!(eventInfo.DeclaringType.IsPublic || eventInfo.DeclaringType.IsNestedPublic)) && (eventInfo.DeclaringType.Assembly == typeof(TypeDescriptor).Assembly)) {
                            continue;
                        }
                        
                        MethodInfo addMethod = eventInfo.GetAddMethod();
                        MethodInfo removeMethod = eventInfo.GetRemoveMethod();
                        bool allGood = addMethod != null && removeMethod != null;
                        
                        // if we have a base list, push the new descriptor
                        // into the hashtable, otherwise just add it directly.
                        //
                        if (eventHash != null) {
                            EventInfo currentEvent = eventInfo;

                            // okay, we have to get tricky here...
                            // if we got an event without an add and remove...which means one is defined on a base class
                            //
                            if (!allGood) {
                                if (eventHash.Contains(eventInfo.Name)) {

                                    // a base class has a property for this,
                                    // so we should just pick up it's
                                    // getter.
                                    //
                                    EventDescriptor basePd = (EventDescriptor)eventHash[eventInfo.Name];
                                    Type declaringType = basePd.ComponentType;
                                    if (declaringType != null) {
                                        EventInfo baseEvent = declaringType.GetEvent(eventInfo.Name);
                                        if (baseEvent != null && baseEvent.GetAddMethod() != null && baseEvent.GetRemoveMethod() != null) {
                                            currentEvent = baseEvent;
                                        }
                                    }
                                }
                            }

                            // push the new info into the hash table.
                            //
                            eventHash[eventInfo.Name] = new ReflectEventDescriptor(classToReflect, currentEvent);
                        }
                        else {
                            AddMember(new ReflectEventDescriptor(classToReflect, eventInfo));
                        }
                        
                    }

                    // now all the things in the hashtable are our "actual" list
                    // of events, so just set it directly.
                    //
                    if (eventHash != null) {
                        this.memberHash = eventHash;
                    }
                }

                /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.MemberList.ReflectGetExtenders"]/*' />
                /// <devdoc> 
                ///      Reflects on a class to find the extender properties for that class.  This 
                ///      calls AddMember for each new property that it finds. 
                /// </devdoc> 
                private void ReflectGetExtenders(Type classToReflect) {
                    foreach(Attribute attr in TypeDescriptor.GetAttributes(classToReflect)) {
                        if (attr is ProvidePropertyAttribute) {
                            ProvidePropertyAttribute provided = (ProvidePropertyAttribute)attr;
                            
                            Type receiverType = Type.GetType(provided.ReceiverTypeName);
                            
                            if (receiverType != null) {
                                MethodInfo getMethod = classToReflect.GetMethod("Get" + provided.PropertyName, new Type[] {receiverType});
                                if (getMethod != null && !getMethod.IsStatic && getMethod.IsPublic) {
                                    MethodInfo setMethod = classToReflect.GetMethod("Set" + provided.PropertyName, new Type[] {receiverType, getMethod.ReturnType});

                                    if (setMethod != null && (setMethod.IsStatic || !setMethod.IsPublic)) {
                                        setMethod = null;
                                    }
                                    AddMember(new ReflectPropertyDescriptor(classToReflect, provided.PropertyName, getMethod.ReturnType, receiverType, getMethod, setMethod, null));
                                }
                            }
                        }
                    }
                }

                /// <include file='doc\TypeDescriptor.uex' path='docs/doc[@for="TypeDescriptor.ComponentEntry.MemberList.ReflectGetProperties"]/*' />
                /// <devdoc> 
                ///      Reflects on a class to find the properties for that class.  This 
                ///      calls AddMember for each new property that it finds. 
                /// </devdoc> 
                private void ReflectGetProperties(Type classToReflect) {
                    // CLR gives us a full set of properties for all the base classes, which is what
                    // we want.  Unfortunately, it does not give us the accessor methods for properties
                    // that are only partially overridden.  So, for these, we have to traverse the base
                    // class list.
                    //
                    Type currentType = classToReflect;
                    Hashtable propertyHash = null;
                    
                    PropertyDescriptorCollection baseTypeProps = null;

                    // We only want to reflect on one level at a time,
                    // so if we have a base class above object, we get the
                    // properties for that first.
                    //
                    Type baseType = classToReflect.BaseType;
                    if (baseType != typeof(object) && baseType != null) {
                        baseTypeProps = TypeDescriptor.GetProperties(baseType);
                    }

                    // for this particular type, we get _only_ the properties
                    // declared on that type
                    //
                    PropertyInfo[] props = classToReflect.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Instance);

                    // if we have properties from the base type, stick them into
                    // a hashtable because we'll want to override them with re-declared
                    // properties on this particular type.
                    //
                    if (baseTypeProps != null && baseTypeProps.Count > 0) {
                        propertyHash = new Hashtable();
                        foreach(PropertyDescriptor pd in baseTypeProps) {
                            propertyHash[pd.Name] = pd;
                        }
                    }   

                    // now walk each property we got an make sure it's got a getter and a setter
                    //
                    foreach(PropertyInfo pi in props) {
                        if ((!(pi.DeclaringType.IsPublic || pi.DeclaringType.IsNestedPublic)) && (pi.DeclaringType.Assembly == typeof(TypeDescriptor).Assembly)) {
                            continue;
                        }
                        
                        bool addProp = true;
                        MethodInfo getMethod = pi.GetGetMethod();
                        MethodInfo setMethod = pi.GetSetMethod();
                        MethodInfo mi = getMethod;
                        
                        // first just look to see if we have a getter
                        //
                        if (mi != null) {
                            // Ensure the get method has no parameters.
                            //
                            ParameterInfo[] parameters = mi.GetParameters();
                            
                            if (parameters != null && parameters.Length != 0) {
                                addProp = false;
                            }
                        }
                        else {
                            addProp = false;
                        }
                         
                        // build the property descriptor
                        // for this property.
                        //
                        if (addProp && mi != null && !mi.IsStatic && mi.IsPublic) {
                            
                            // if we have a base list, push the new descriptor
                            // into the hashtable, otherwise just add it directly.
                            //
                            if (propertyHash != null) {
                                
                                // okay, we have to get tricky here...
                                // if we got a property without a GetMethod, see if there's one in here we can use
                                //
                                if (getMethod == null) {
                                    if (propertyHash.Contains(pi.Name)) {

                                        // a base class has a property for this,
                                        // so we should just pick up it's
                                        // getter.
                                        //
                                        PropertyDescriptor basePd = (PropertyDescriptor)propertyHash[pi.Name];
                                        Type declaringType = basePd.ComponentType;
                                        if (declaringType != null) {
                                            PropertyInfo baseProp = declaringType.GetProperty(pi.Name, pi.PropertyType);
                                            if (baseProp != null) {
                                                getMethod = baseProp.GetGetMethod();
                                            }
                                            else {
                                                Debug.Fail("Base prop list has '" + pi.Name + "' but reflection didn't find it.");
                                            }
                                        }
                                    }
                                }

                                // push the new info into the hash table.
                                //
                                propertyHash[pi.Name] = new ReflectPropertyDescriptor(classToReflect, pi.Name, pi.PropertyType, pi, getMethod, setMethod, null);;
                            }
                            else {
                                AddMember(new ReflectPropertyDescriptor(classToReflect, pi.Name, pi.PropertyType, pi, getMethod, setMethod, null));
                            }
                        }
                    }

                    // now all the things in the hashtable are our "actual" list
                    // of properties, so just set it directly.
                    //
                    if (propertyHash != null) {
                        this.memberHash = propertyHash;
                    }
                    
                }
            }

            // This is a private class used to contain events while we hash
            //
            private class EventHashHolder {
                public EventInfo RealEvent;
                public string Name;
                public Type ReflectedType;
                public MethodInfo AddMethod;
                public MethodInfo RemoveMethod;
                
                public EventHashHolder(EventInfo evt) {
                    RealEvent = evt;
                    Name = evt.Name;
                    AddMethod = evt.GetAddMethod();
                    RemoveMethod = evt.GetRemoveMethod();
                    if (AddMethod != null && RemoveMethod != null) {
                        ReflectedType = evt.EventHandlerType;
                    }
                }
                
                public EventHashHolder(string name, Type reflectedType, MethodInfo addMethod, MethodInfo removeMethod) {
                    Name = name;
                    ReflectedType = reflectedType;
                    AddMethod = addMethod;
                    RemoveMethod = removeMethod;
                }
            }
            
            // This is a private class used to contain properties while we hash
            //
            private class PropertyHashHolder {
                public string Name;
                public Type PropertyType;
                public MethodInfo GetMethod;
                public MethodInfo SetMethod;
                public PropertyInfo PropertyInfo;
                
                public PropertyHashHolder(PropertyInfo prop) {
                    Name = prop.Name;
                    PropertyType = prop.PropertyType;
                    GetMethod = prop.GetGetMethod();
                    SetMethod = prop.GetSetMethod();
                    PropertyInfo = prop;
                }
            }
            
            // This is a private class used to stash a set of properties on
            // a component's site so we can quickly recover them.
            //
            private class PropertyStash {
                private long extenderHash;
                public ArrayList Properties;
                public PropertyDescriptorCollection FilteredProperties;
                public Attribute[] Attributes;
                
                public PropertyStash(ArrayList props, IExtenderProvider[] providers) {
                    Properties = props;
                    extenderHash = HashExtenders(providers);
                }
                
                // This will return true if the current set of attributes match
                // the given set.
                //
                public bool AttributesMatch(Attribute[] attributes) {
                    int ourCount = (Attributes == null ? 0 : Attributes.Length);
                    int count = (attributes == null ? 0 : attributes.Length);
                    
                    if (ourCount != count) {
                        return false;
                    }
                    
                    bool match = true;
                    
                    for (int i = 0; i < ourCount; i++) {
                        for (int j = 0; j < count; j++) {
                            if (!Attributes[i].Match(attributes[j])) {
                                match = false;
                                break;
                            }
                        }
                    }
                    
                    return match;
                }
                
                // This will return true if the given array if extenders is the same
                // as the set that these stashed properties were created with.
                //
                public bool ExtendersMatch(IExtenderProvider[] providers) {
                    long hash = HashExtenders(providers);
                    return extenderHash == hash;
                }
                
                // This is a simple hashing algorithm that attempts to create
                // a unique number for a given set of extender providers.
                //
                private long HashExtenders(IExtenderProvider[] providers) {
                    long hash = 0;
                    int count = (providers == null ? 0 : providers.Length);
                    for (int i = 0; i < count; i++) {
                        hash += providers[i].GetHashCode();
                    }
                    return hash;
                }
            }
        }

        class MemberDescriptorComparer : IComparer {
            public static readonly MemberDescriptorComparer Instance = new MemberDescriptorComparer();

            public int Compare(object left, object right) {
                return string.Compare(((MemberDescriptor)left).Name, ((MemberDescriptor)right).Name, false, CultureInfo.InvariantCulture);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\documentcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocumentCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;

    /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a read-only collection of documents.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class DesignerCollection : ICollection {
        private IList designers;

        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.DesignerCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.DesignerCollection'/> class
        ///       that stores an array with a pointer to each <see cref='System.ComponentModel.Design.IDesignerHost'/>
        ///       for each document in the collection.
        ///    </para>
        /// </devdoc>
        public DesignerCollection(IDesignerHost[] designers) {
            if (designers != null) {
                this.designers = new ArrayList(designers);
            }
            else {
                this.designers = new ArrayList();
            }
        }

        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.DesignerCollection1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.DesignerCollection'/> class
        ///       that stores an array with a pointer to each <see cref='System.ComponentModel.Design.IDesignerHost'/>
        ///       for each document in the collection.
        ///    </para>
        /// </devdoc>
        public DesignerCollection(IList designers) {
            this.designers = designers;
        }

        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets the number
        ///       of documents in the collection.</para>
        /// </devdoc>
        public int Count {
            get {
                return designers.Count;
            }
        }

        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.this"]/*' />
        /// <devdoc>
        ///    <para> Gets
        ///       or sets the document at the specified index.</para>
        /// </devdoc>
        public virtual IDesignerHost this[int index] {
            get {
                return (IDesignerHost)designers[index];
            }
        }

        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Creates and retrieves a new enumerator for this collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return designers.GetEnumerator();
        }

        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get {
                return Count;
            }
        }
      
        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return null;
            }
        }

        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            designers.CopyTo(array, index);
        }

        /// <include file='doc\DocumentCollection.uex' path='docs/doc[@for="DesignerCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\designerverbcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerVerbCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {
    using System;
    using System.Collections;
    using System.Diagnostics;
    
    /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class DesignerVerbCollection : CollectionBase {

        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.DesignerVerbCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DesignerVerbCollection() {
        }

        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.DesignerVerbCollection1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DesignerVerbCollection(DesignerVerb[] value) {
            AddRange(value);
        }

        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DesignerVerb this[int index] {
            get {
                return (DesignerVerb)(List[index]);
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(DesignerVerb value) {
            return List.Add(value);
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(DesignerVerb[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.AddRange1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(DesignerVerbCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, DesignerVerb value) {
            List.Insert(index, value);
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(DesignerVerb value) {
            return List.IndexOf(value);
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(DesignerVerb value) {
            return List.Contains(value);
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(DesignerVerb value) {
            List.Remove(value);
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(DesignerVerb[] array, int index) {
            List.CopyTo(array, index);
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.OnSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnSet(int index, object oldValue, object newValue) {
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.OnInsert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnInsert(int index, object value) {
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.OnClear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnClear() {
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.OnRemove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnRemove(int index, object value) {
        }
        /// <include file='doc\DesignerVerbCollection.uex' path='docs/doc[@for="DesignerVerbCollection.OnValidate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnValidate(object value) {
            Debug.Assert(value != null, "Don't add null verbs!");
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\documenteventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocumentEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;

    /// <include file='doc\DocumentEventArgs.uex' path='docs/doc[@for="DesignerEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the System.ComponentModel.Design.IDesignerEventService.DesignerEvent
    /// event that is generated when a document is created or disposed.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class DesignerEventArgs : EventArgs {
        private readonly IDesignerHost host;

        /// <include file='doc\DocumentEventArgs.uex' path='docs/doc[@for="DesignerEventArgs.DesignerEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the System.ComponentModel.Design.DesignerEventArgs
        ///       class.
        ///    </para>
        /// </devdoc>
        public DesignerEventArgs(IDesignerHost host) {
            this.host = host;
        }

        /// <include file='doc\DocumentEventArgs.uex' path='docs/doc[@for="DesignerEventArgs.Designer"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the host of the document.
        ///    </para>
        /// </devdoc>
        public IDesignerHost Designer {
            get {
                return host;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\documenteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DocumentEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\DocumentEventHandler.uex' path='docs/doc[@for="DesignerEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the System.ComponentModel.Design.IDesignerEventService.DesignerEvent
    /// event raised when a document is created or disposed.</para>
    /// </devdoc>
    public delegate void DesignerEventHandler(object sender, DesignerEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\designtimelicensecontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesigntimeLicenseContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {
    using System.Runtime.Remoting;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Net;
    using System.IO;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\DesigntimeLicenseContext.uex' path='docs/doc[@for="DesigntimeLicenseContext"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for licensing.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class DesigntimeLicenseContext : LicenseContext {
        internal Hashtable savedLicenseKeys = new Hashtable();

        /// <include file='doc\DesigntimeLicenseContext.uex' path='docs/doc[@for="DesigntimeLicenseContext.UsageMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the license usage mode.
        ///    </para>
        /// </devdoc>
        public override LicenseUsageMode UsageMode { 
            get {
                return LicenseUsageMode.Designtime;
            }
        }
        /// <include file='doc\DesigntimeLicenseContext.uex' path='docs/doc[@for="DesigntimeLicenseContext.GetSavedLicenseKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a saved license key.
        ///    </para>
        /// </devdoc>
        public override string GetSavedLicenseKey(Type type, Assembly resourceAssembly) {
            return null;
        }
        /// <include file='doc\DesigntimeLicenseContext.uex' path='docs/doc[@for="DesigntimeLicenseContext.SetSavedLicenseKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets a saved license key.
        ///    </para>
        /// </devdoc>
        public override void SetSavedLicenseKey(Type type, string key) {
            savedLicenseKeys[type.AssemblyQualifiedName] = key;
        }
    }

    internal class RuntimeLicenseContext : LicenseContext {
        const int ReadBlock = 400;

        internal Hashtable savedLicenseKeys;

        /// <devdoc>
        ///     This method takes a file URL and converts it to a local path.  The trick here is that
        ///     if there is a '#' in the path, everything after this is treated as a fragment.  So
        ///     we need to append the fragment to the end of the path.
        /// </devdoc>
        private string GetLocalPath(string fileName) {
            System.Diagnostics.Debug.Assert(fileName != null && fileName.Length > 0, "Cannot get local path, fileName is not valid");

            Uri uri = new Uri(fileName, true);
            return uri.LocalPath + uri.Fragment;
        }

        public override string GetSavedLicenseKey(Type type, Assembly resourceAssembly) {

            if (savedLicenseKeys == null) {
                Uri licenseFile = null;

                if (resourceAssembly == null) {
                    string rawFile = (string)AppDomain.CurrentDomain.SetupInformation.LicenseFile;
                    string codeBase;
                    
                    // FileIOPermission is required for ApplicationBase in URL-hosted domains
                    // see ASURT 101244
                    FileIOPermission perm = new FileIOPermission(PermissionState.Unrestricted);
                    perm.Assert();
                    try {
                        codeBase = AppDomain.CurrentDomain.SetupInformation.ApplicationBase;
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                    if (rawFile != null && codeBase != null) {
                        licenseFile = new Uri(new Uri(codeBase), rawFile);
                    }
                }

                if (licenseFile == null && resourceAssembly == null) {
                    resourceAssembly = Assembly.GetEntryAssembly();

                    if (resourceAssembly == null) {
                        // If Assembly.EntryAssembly returns null, then we will 
                        // try everything!
                        // 
                        foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies()) {

                            // Bug# 78962: Though, I could not repro this, we seem to be hitting an AssemblyBuilder
                            // when walking through all the assemblies in the current app domain. This throws an 
                            // exception on Assembly.CodeBase and we bail out. Catching exceptions here is not a 
                            // bad thing.
                            if (asm is AssemblyBuilder)
                                continue;

                            // file://fullpath/foo.exe
                            //
                            string fileName = GetLocalPath(asm.EscapedCodeBase);
                            fileName = new FileInfo(fileName).Name;

                            Stream s = asm.GetManifestResourceStream(fileName + ".licenses");
                            if (s == null) {
                                //Since the casing may be different depending on how the assembly was loaded, 
                                //we'll do a case insensitive lookup for this manifest resource stream...
                                s = CaseInsensitiveManifestResourceStreamLookup(asm, fileName + ".licenses");
                            }
                            
                            if (s != null) {
                                DesigntimeLicenseContextSerializer.Deserialize(s, fileName.ToUpper(CultureInfo.InvariantCulture), this);
                                break;
                            }
                        }
                    }
                    else {
                        string fileName = GetLocalPath(resourceAssembly.EscapedCodeBase);
                        fileName = new FileInfo(fileName).Name;
                        string licResourceName = fileName + ".licenses";

                        Stream s = resourceAssembly.GetManifestResourceStream(licResourceName);
                        if (s == null) {
                            string resolvedName = null;
                            CompareInfo comparer = CultureInfo.InvariantCulture.CompareInfo;
                            foreach(String existingName in resourceAssembly.GetManifestResourceNames()) {
                                if (comparer.Compare(existingName, licResourceName, CompareOptions.IgnoreCase) == 0) {
                                    resolvedName = existingName;
                                    break;
                                }
                            }
                            if (resolvedName != null) {
                                s = resourceAssembly.GetManifestResourceStream(resolvedName);
                            }
                        }
                        if (s != null) {
                            DesigntimeLicenseContextSerializer.Deserialize(s, fileName.ToUpper(CultureInfo.InvariantCulture), this);
                        }
                    }
                }


                if (licenseFile != null && savedLicenseKeys == null) {
                    Stream s = OpenRead(licenseFile);
                    if (s != null) {
                        string[] segments = licenseFile.Segments;
                        string licFileName = segments[segments.Length - 1];
                        string key = licFileName.Substring(0, licFileName.LastIndexOf("."));
                        DesigntimeLicenseContextSerializer.Deserialize(s, key.ToUpper(CultureInfo.InvariantCulture), this);
                    }
                }

                if (savedLicenseKeys == null) {
                    savedLicenseKeys = new Hashtable();
                }
            }

            return(string)savedLicenseKeys[type.AssemblyQualifiedName];
        }

        /**
        * Looks up a .licenses file in the assembly manifest using 
        * case-insensitive lookup rules.  We do this because the name
        * we are attempting to locate could have different casing 
        * depending on how the assembly was loaded.
        **/
        private Stream CaseInsensitiveManifestResourceStreamLookup(Assembly satellite, string name)
        {
            CompareInfo comparer = CultureInfo.InvariantCulture.CompareInfo;
            
            //loop through the resource names in the assembly
            //
            foreach(string existingName in satellite.GetManifestResourceNames()) {
                if (comparer.Compare(existingName, name, CompareOptions.IgnoreCase) == 0) {
                    name = existingName;
                    break;
                }
            }

            //finally, attempt to return our stream based on the 
            //case insensitive match we found
            //
            return satellite.GetManifestResourceStream(name);
        }

        static Stream OpenRead(Uri resourceUri) {
            Stream result = null;

            PermissionSet perms = new PermissionSet(PermissionState.Unrestricted);

            perms.Assert();
            try {
                result = new WebClient().OpenRead(resourceUri.ToString());
            }
            catch (Exception e) {
                Debug.Fail(e.ToString());
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\designtimelicensecontextserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesigntimeLicenseContextSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {
    using System.Runtime.Remoting;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.IO;
    
    /// <include file='doc\DesigntimeLicenseContextSerializer.uex' path='docs/doc[@for="DesigntimeLicenseContextSerializer"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides support for design-time license context serialization.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class DesigntimeLicenseContextSerializer {

        // not creatable...
        //
        private DesigntimeLicenseContextSerializer() {
        }

        /// <include file='doc\DesigntimeLicenseContextSerializer.uex' path='docs/doc[@for="DesigntimeLicenseContextSerializer.Serialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Serializes the licenses within the specified design-time license context
        ///       using the specified key and output stream.
        ///    </para>
        /// </devdoc>
        public static void Serialize(Stream o, string cryptoKey, DesigntimeLicenseContext context) {
            IFormatter formatter = new BinaryFormatter();
            formatter.Serialize(o, new object[] {cryptoKey, context.savedLicenseKeys});
        }
        
        internal static void Deserialize(Stream o, string cryptoKey, RuntimeLicenseContext context) {
            IFormatter formatter = new BinaryFormatter();

            object obj;

            new SecurityPermission(SecurityPermissionFlag.SerializationFormatter).PermitOnly();
            new SecurityPermission(SecurityPermissionFlag.SerializationFormatter).Assert();
            try {
                obj = formatter.Deserialize(o);
            }
            finally {
                CodeAccessPermission.RevertAssert();
                CodeAccessPermission.RevertPermitOnly();
            }

            if (obj is object[]) {
                object[] value = (object[])obj;
                if (value[0] is string && (string)value[0] == cryptoKey) {
                    context.savedLicenseKeys = (Hashtable)value[1];
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\icomponentchangeservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IComponentChangeService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;

    /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService"]/*' />
    /// <devdoc>
    /// <para>Provides an interface to add and remove the event handlers for System.ComponentModel.Design.IComponentChangeService.ComponentAdded, System.ComponentModel.Design.IComponentChangeService.ComponentAdding, System.ComponentModel.Design.IComponentChangeService.ComponentChanged, System.ComponentModel.Design.IComponentChangeService.ComponentChanging, System.ComponentModel.Design.IComponentChangeService.ComponentRemoved, System.ComponentModel.Design.IComponentChangeService.ComponentRemoving, and System.ComponentModel.Design.IComponentChangeService.ComponentRename events.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IComponentChangeService {

        /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService.ComponentAdded"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the System.ComponentModel.Design.IComponentChangeService.ComponentAdded event.</para>
        /// </devdoc>
        event ComponentEventHandler ComponentAdded;

        /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService.ComponentAdding"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the System.ComponentModel.Design.IComponentChangeService.ComponentAdding event.</para>
        /// </devdoc>
        event ComponentEventHandler ComponentAdding;

        /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService.ComponentChanged"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the System.ComponentModel.Design.IComponentChangeService.ComponentChanged event.</para>
        /// </devdoc>
        event ComponentChangedEventHandler ComponentChanged;

        /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService.ComponentChanging"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the System.ComponentModel.Design.IComponentChangeService.ComponentChanging event.</para>
        /// </devdoc>
        event ComponentChangingEventHandler ComponentChanging;

        /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService.ComponentRemoved"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the System.ComponentModel.Design.IComponentChangeService.OnComponentRemoved event.</para>
        /// </devdoc>
        event ComponentEventHandler ComponentRemoved;

        /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService.ComponentRemoving"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the System.ComponentModel.Design.IComponentChangeService.OnComponentRemoving event.</para>
        /// </devdoc>
        event ComponentEventHandler ComponentRemoving;

        /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService.ComponentRename"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the System.ComponentModel.Design.IComponentChangeService.OnComponentRename event.</para>
        /// </devdoc>
        event ComponentRenameEventHandler ComponentRename;

        /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService.OnComponentChanged"]/*' />
        /// <devdoc>
        ///    <para>Announces to the component change service that a particular component has changed.</para>
        /// </devdoc>
        void OnComponentChanged(object component, MemberDescriptor member, object oldValue, object newValue);

        /// <include file='doc\IComponentChangeService.uex' path='docs/doc[@for="IComponentChangeService.OnComponentChanging"]/*' />
        /// <devdoc>
        ///    <para>Announces to the component change service that a particular component is changing.</para>
        /// </devdoc>
        void OnComponentChanging(object component, MemberDescriptor member);
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\idesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\IDesigner.uex' path='docs/doc[@for="IDesigner"]/*' />
    /// <devdoc>
    ///    <para> Provides the basic framework for building a custom designer.
    ///       This interface stores the verbs available to the designer, as well as basic
    ///       services for the designer.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IDesigner : IDisposable {

        /// <include file='doc\IDesigner.uex' path='docs/doc[@for="IDesigner.Component"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the base component this designer is designing.</para>
        /// </devdoc>
        IComponent Component {get;}
        
        /// <include file='doc\IDesigner.uex' path='docs/doc[@for="IDesigner.Verbs"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the design-time verbs supported by the designer.</para>
        /// </devdoc>
        DesignerVerbCollection Verbs {get;}

        /// <include file='doc\IDesigner.uex' path='docs/doc[@for="IDesigner.DoDefaultAction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs the default action for this designer.
        ///    </para>
        /// </devdoc>
        void DoDefaultAction();
        
        /// <include file='doc\IDesigner.uex' path='docs/doc[@for="IDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes the designer with the given component.
        ///    </para>
        /// </devdoc>
        void Initialize(IComponent component);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\idesignerfilter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerFilter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\IDesignerFilter.uex' path='docs/doc[@for="IDesignerFilter"]/*' />
    /// <devdoc>
    ///    <para>Provides access to, and
    ///       an interface for filtering, the dictionaries that store the properties, attributes, or events of a component.</para>
    /// </devdoc>
    public interface IDesignerFilter {

        /// <include file='doc\IDesignerFilter.uex' path='docs/doc[@for="IDesignerFilter.PostFilterAttributes"]/*' />
        /// <devdoc>
        ///    <para> Allows a designer to filter the set of
        ///       attributes the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/> object.</para>
        /// </devdoc>
        void PostFilterAttributes(IDictionary attributes);

        /// <include file='doc\IDesignerFilter.uex' path='docs/doc[@for="IDesignerFilter.PostFilterEvents"]/*' />
        /// <devdoc>
        ///    <para> Allows a designer to filter the set of events
        ///       the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        ///       object.</para>
        /// </devdoc>
        void PostFilterEvents(IDictionary events);

        /// <include file='doc\IDesignerFilter.uex' path='docs/doc[@for="IDesignerFilter.PostFilterProperties"]/*' />
        /// <devdoc>
        ///    <para> Allows a designer to filter the set of properties
        ///       the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        ///       object.</para>
        /// </devdoc>
        void PostFilterProperties(IDictionary properties);

        /// <include file='doc\IDesignerFilter.uex' path='docs/doc[@for="IDesignerFilter.PreFilterAttributes"]/*' />
        /// <devdoc>
        ///    <para> Allows a designer to filter the set of
        ///       attributes the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        ///       object.</para>
        /// </devdoc>
        void PreFilterAttributes(IDictionary attributes);

        /// <include file='doc\IDesignerFilter.uex' path='docs/doc[@for="IDesignerFilter.PreFilterEvents"]/*' />
        /// <devdoc>
        ///    <para> Allows a designer to filter the set of events
        ///       the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        ///       object.</para>
        /// </devdoc>
        void PreFilterEvents(IDictionary events);

        /// <include file='doc\IDesignerFilter.uex' path='docs/doc[@for="IDesignerFilter.PreFilterProperties"]/*' />
        /// <devdoc>
        ///    <para> Allows a designer to filter the set of properties
        ///       the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        ///       object.</para>
        /// </devdoc>
        void PreFilterProperties(IDictionary properties);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\idesigneroptionservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerOptionService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;
        
        /// <include file='doc\IDesignerOptionService.uex' path='docs/doc[@for="IDesignerOptionService"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides access
        ///       to get and set option values for a designer.
        ///    </para>
        /// </devdoc>
        public interface IDesignerOptionService{
        
            /// <include file='doc\IDesignerOptionService.uex' path='docs/doc[@for="IDesignerOptionService.GetOptionValue"]/*' />
            /// <devdoc>
            ///    <para>Gets the value of an option defined in this package.</para>
            /// </devdoc>
            object GetOptionValue(string pageName, string valueName);
            
            /// <include file='doc\IDesignerOptionService.uex' path='docs/doc[@for="IDesignerOptionService.SetOptionValue"]/*' />
            /// <devdoc>
            ///    <para>Sets the value of an option defined in this package.</para>
            /// </devdoc>
            void SetOptionValue(string pageName, string valueName, object value);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\helpcontexttype.cs ===
//------------------------------------------------------------------------------
// <copyright file="HelpContextType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   HelpContextType.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.ComponentModel.Design {

   /// <include file='doc\HelpContextType.uex' path='docs/doc[@for="HelpContextType"]/*' />
   /// <devdoc>
   ///    <para>[To be supplied.]</para>
   /// </devdoc>
   public enum HelpContextType {
      /// <include file='doc\HelpContextType.uex' path='docs/doc[@for="HelpContextType.Ambient"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      Ambient,
      /// <include file='doc\HelpContextType.uex' path='docs/doc[@for="HelpContextType.Window"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      Window,
      /// <include file='doc\HelpContextType.uex' path='docs/doc[@for="HelpContextType.Selection"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      Selection,
      /// <include file='doc\HelpContextType.uex' path='docs/doc[@for="HelpContextType.ToolWindowSelection"]/*' />
      /// <devdoc>
      ///    <para>[To be supplied.]</para>
      /// </devdoc>
      ToolWindowSelection,
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\helpkeywordtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="HelpKeywordType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Runtime.Remoting;
    using System.ComponentModel;

    using System.Diagnostics;
    using System;

    /// <include file='doc\HelpKeywordType.uex' path='docs/doc[@for="HelpKeywordType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies identifiers that can be
    ///       used to indicate the type of a help keyword.
    ///    </para>
    /// </devdoc>
    public enum HelpKeywordType {
        /// <include file='doc\HelpKeywordType.uex' path='docs/doc[@for="HelpKeywordType.F1Keyword"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the keyword is a word F1 was pressed to request help regarding.
        ///    </para>
        /// </devdoc>
        F1Keyword,
        /// <include file='doc\HelpKeywordType.uex' path='docs/doc[@for="HelpKeywordType.GeneralKeyword"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the keyword is a general keyword.
        ///    </para>
        /// </devdoc>
        GeneralKeyword,
        /// <include file='doc\HelpKeywordType.uex' path='docs/doc[@for="HelpKeywordType.FilterKeyword"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the keyword is a filter keyword.
        ///    </para>
        /// </devdoc>
        FilterKeyword
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\idesignerhost.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerHost.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Reflection;

    /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides methods to adjust the configuration of and retrieve
    ///       information about the services and behavior of a designer.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IDesignerHost : IServiceContainer {

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.Loading"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the designer host
        ///       is currently loading the document.
        ///    </para>
        /// </devdoc>
        bool Loading { get; }

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.InTransaction"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the designer host is currently in a transaction.</para>
        /// </devdoc>
        bool InTransaction { get; }
        
        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.Container"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the container for this designer host.
        ///    </para>
        /// </devdoc>
        IContainer Container { get; }

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.RootComponent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the instance of the base class used as the base class for the current design.
        ///    </para>
        /// </devdoc>
        IComponent RootComponent { get; }

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.RootComponentClassName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the fully qualified name of the class that is being designed.
        ///    </para>
        /// </devdoc>
        string RootComponentClassName { get; }

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.TransactionDescription"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the description of the current transaction.
        ///    </para>
        /// </devdoc>
        string TransactionDescription { get; }

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.Activated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.Activated'/> event.
        ///    </para>
        /// </devdoc>
        event EventHandler Activated;

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.Deactivated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.Deactivated'/> event.
        ///    </para>
        /// </devdoc>
        event EventHandler Deactivated;

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.LoadComplete"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.LoadComplete'/> event.
        ///    </para>
        /// </devdoc>
        event EventHandler LoadComplete;

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.TransactionClosed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.TransactionClosed'/> event.
        ///    </para>
        /// </devdoc>
        event DesignerTransactionCloseEventHandler TransactionClosed;
        
        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.TransactionClosing"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.TransactionClosing'/> event.</para>
        /// </devdoc>
        event DesignerTransactionCloseEventHandler TransactionClosing;

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.TransactionOpened"]/*' />
        /// <devdoc>
        /// <para>Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.TransactionOpened'/> event.</para>
        /// </devdoc>
        event EventHandler TransactionOpened;

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.TransactionOpening"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event handler for the <see cref='System.ComponentModel.Design.IDesignerHost.TransactionOpening'/> event.
        ///    </para>
        /// </devdoc>
        event EventHandler TransactionOpening;
        
        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.Activate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Activates the designer that this host is hosting.
        ///    </para>
        /// </devdoc>
        void Activate();

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.CreateComponent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a component of the specified class type.
        ///    </para>
        /// </devdoc>
        IComponent CreateComponent(Type componentClass);

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.CreateComponent1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a component of the given class type and name and places it into the designer container.
        ///    </para>
        /// </devdoc>
        IComponent CreateComponent(Type componentClass, string name);

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.CreateTransaction"]/*' />
        /// <devdoc>
        /// <para>
        ///     Lengthy operations that involve multiple components may raise many events.  These events
        ///     may cause other side-effects, such as flicker or performance degradation.  When operating
        ///     on multiple components at one time, or setting multiple properties on a single component,
        ///     you should encompass these changes inside a transaction.  Transactions are used
        ///     to improve performance and reduce flicker.  Slow operations can listen to 
        ///     transaction events and only do work when the transaction completes.
        /// </para>
        /// </devdoc>
        DesignerTransaction CreateTransaction();

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.CreateTransaction1"]/*' />
        /// <devdoc>
        /// <para>
        ///     Lengthy operations that involve multiple components may raise many events.  These events
        ///     may cause other side-effects, such as flicker or performance degradation.  When operating
        ///     on multiple components at one time, or setting multiple properties on a single component,
        ///     you should encompass these changes inside a transaction.  Transactions are used
        ///     to improve performance and reduce flicker.  Slow operations can listen to 
        ///     transaction events and only do work when the transaction completes.
        /// </para>
        /// </devdoc>
        DesignerTransaction CreateTransaction(string description);

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.DestroyComponent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Destroys the given component, removing it from the design container.
        ///    </para>
        /// </devdoc>
        void DestroyComponent(IComponent component);

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.GetDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the designer instance for the specified component.
        ///    </para>
        /// </devdoc>
        IDesigner GetDesigner(IComponent component);

        /// <include file='doc\IDesignerHost.uex' path='docs/doc[@for="IDesignerHost.GetType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type instance for the specified fully qualified type name <paramref name="TypeName"/>.
        ///    </para>
        /// </devdoc>
        Type GetType(string typeName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\idesignereventservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerEventService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\IDesignerEventService.uex' path='docs/doc[@for="IDesignerEventService"]/*' />
    /// <devdoc>
    ///    <para>Provides global
    ///       event notifications and the ability to create designers.</para>
    /// </devdoc>
    public interface IDesignerEventService {

        /// <include file='doc\IDesignerEventService.uex' path='docs/doc[@for="IDesignerEventService.ActiveDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the currently active designer.
        ///    </para>
        /// </devdoc>
        IDesignerHost ActiveDesigner { get; }

        /// <include file='doc\IDesignerEventService.uex' path='docs/doc[@for="IDesignerEventService.Designers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets a collection of running design documents in the development environment.
        ///    </para>
        /// </devdoc>
        DesignerCollection Designers { get; }
        
        /// <include file='doc\IDesignerEventService.uex' path='docs/doc[@for="IDesignerEventService.ActiveDesignerChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event that will be raised when the currently active designer
        ///       changes.
        ///    </para>
        /// </devdoc>
        event ActiveDesignerEventHandler ActiveDesignerChanged;

        /// <include file='doc\IDesignerEventService.uex' path='docs/doc[@for="IDesignerEventService.DesignerCreated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event that will be raised when a designer is created.
        ///    </para>
        /// </devdoc>
        event DesignerEventHandler DesignerCreated;
        
        /// <include file='doc\IDesignerEventService.uex' path='docs/doc[@for="IDesignerEventService.DesignerDisposed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event that will be raised when a designer is disposed.
        ///    </para>
        /// </devdoc>
        event DesignerEventHandler DesignerDisposed;
        
        /// <include file='doc\IDesignerEventService.uex' path='docs/doc[@for="IDesignerEventService.SelectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event that will be raised when the global selection changes.
        ///    </para>
        /// </devdoc>
        event EventHandler SelectionChanged;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\iextenderproviderservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IExtenderProviderService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {  
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\IExtenderProviderService.uex' path='docs/doc[@for="IExtenderProviderService"]/*' />
    /// <devdoc>
    ///    <para>Provides an interface to add and remove extender providers.</para>
    /// </devdoc>
    public interface IExtenderProviderService {

        /// <include file='doc\IExtenderProviderService.uex' path='docs/doc[@for="IExtenderProviderService.AddExtenderProvider"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an extender provider.
        ///    </para>
        /// </devdoc>
        void AddExtenderProvider(IExtenderProvider provider);

        /// <include file='doc\IExtenderProviderService.uex' path='docs/doc[@for="IExtenderProviderService.RemoveExtenderProvider"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes
        ///       an extender provider.
        ///    </para>
        /// </devdoc>
        void RemoveExtenderProvider(IExtenderProvider provider);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\idictionaryservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDictionaryService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;
    
    using System;

    /// <include file='doc\IDictionaryService.uex' path='docs/doc[@for="IDictionaryService"]/*' />
    /// <devdoc>
    ///    <para>Provides a generic dictionary service that a designer can use
    ///       to store user-defined data on the site.</para>
    /// </devdoc>
    public interface IDictionaryService {
    
        /// <include file='doc\IDictionaryService.uex' path='docs/doc[@for="IDictionaryService.GetKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the key corresponding to the specified value.
        ///    </para>
        /// </devdoc>
        object GetKey(object value);
        
        /// <include file='doc\IDictionaryService.uex' path='docs/doc[@for="IDictionaryService.GetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the value corresponding to the specified key.
        ///    </para>
        /// </devdoc>
        object GetValue(object key);
    
        /// <include file='doc\IDictionaryService.uex' path='docs/doc[@for="IDictionaryService.SetValue"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Sets the specified key-value pair.</para>
        /// </devdoc>
        void SetValue(object key, object value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\ihelpservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IHelpService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Runtime.Remoting;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\IHelpService.uex' path='docs/doc[@for="IHelpService"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides the Integrated Development Environment (IDE) help
    ///       system with contextual information for the current task.</para>
    /// </devdoc>
    public interface IHelpService {
        /// <include file='doc\IHelpService.uex' path='docs/doc[@for="IHelpService.AddContextAttribute"]/*' />
        /// <devdoc>
        ///    <para>Adds a context attribute to the document.</para>
        /// </devdoc>
        void AddContextAttribute(string name, string value, HelpKeywordType keywordType);
        
        /// <include file='doc\IHelpService.uex' path='docs/doc[@for="IHelpService.ClearContextAttributes"]/*' />
        /// <devdoc>
        ///     Clears all existing context attributes from the document.
        /// </devdoc>
        void ClearContextAttributes();
        
        /// <include file='doc\IHelpService.uex' path='docs/doc[@for="IHelpService.CreateLocalContext"]/*' />
        /// <devdoc>
        ///     Creates a Local IHelpService to manage subcontexts.
        /// </devdoc>
        IHelpService CreateLocalContext(HelpContextType contextType);

        /// <include file='doc\IHelpService.uex' path='docs/doc[@for="IHelpService.RemoveContextAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes a previously added context attribute.
        ///    </para>
        /// </devdoc>
        void RemoveContextAttribute(string name, string value);
        
        /// <include file='doc\IHelpService.uex' path='docs/doc[@for="IHelpService.RemoveLocalContext"]/*' />
        /// <devdoc>
        ///     Removes a context that was created with CreateLocalContext
        /// </devdoc>
        void RemoveLocalContext(IHelpService localContext);

        /// <include file='doc\IHelpService.uex' path='docs/doc[@for="IHelpService.ShowHelpFromKeyword"]/*' />
        /// <devdoc>
        ///    <para>Shows the help topic that corresponds to the specified keyword.</para>
        /// </devdoc>
        void ShowHelpFromKeyword(string helpKeyword);

        /// <include file='doc\IHelpService.uex' path='docs/doc[@for="IHelpService.ShowHelpFromUrl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Shows the help topic that corresponds with the specified Url and topic navigation ID.
        ///    </para>
        /// </devdoc>
        void ShowHelpFromUrl(string helpUrl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\iextenderlistservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IExtenderListService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\IExtenderListService.uex' path='docs/doc[@for="IExtenderListService"]/*' />
    /// <devdoc>
    ///    <para>Provides an interface to list extender providers.</para>
    /// </devdoc>
    public interface IExtenderListService {

        /// <include file='doc\IExtenderListService.uex' path='docs/doc[@for="IExtenderListService.GetExtenderProviders"]/*' />
        /// <devdoc>
        ///    <para>Gets the set of extender providers for the component.</para>
        /// </devdoc>
        IExtenderProvider[] GetExtenderProviders();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\ieventpropertyservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IEventPropertyService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\IEventPropertyService.uex' path='docs/doc[@for="IEventBindingService"]/*' />
    /// <devdoc>
    /// <para>Provides a set of useful methods for binding <see cref='System.ComponentModel.EventDescriptor'/> objects to user code.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IEventBindingService {

        /// <include file='doc\IEventPropertyService.uex' path='docs/doc[@for="IEventBindingService.CreateUniqueMethodName"]/*' />
        /// <devdoc>
        ///     This creates a name for an event handling method for the given component
        ///     and event.  The name that is created is guaranteed to be unique in the user's source
        ///     code.
        /// </devdoc>
        string CreateUniqueMethodName(IComponent component, EventDescriptor e);
        
        /// <include file='doc\IEventPropertyService.uex' path='docs/doc[@for="IEventBindingService.GetCompatibleMethods"]/*' />
        /// <devdoc>
        ///     Retrieves a collection of strings.  Each string is the name of a method
        ///     in user code that has a signature that is compatible with the given event.
        /// </devdoc>
        ICollection GetCompatibleMethods(EventDescriptor e);
        
        /// <include file='doc\IEventPropertyService.uex' path='docs/doc[@for="IEventBindingService.GetEvent"]/*' />
        /// <devdoc>
        ///     For properties that are representing events, this will return the event
        ///     that the property represents.
        /// </devdoc>
        EventDescriptor GetEvent(PropertyDescriptor property);

        /// <include file='doc\IEventPropertyService.uex' path='docs/doc[@for="IEventBindingService.GetEventProperties"]/*' />
        /// <devdoc>
        ///    <para>Converts a set of event descriptors to a set of property descriptors.</para>
        /// </devdoc>
        PropertyDescriptorCollection GetEventProperties(EventDescriptorCollection events);

        /// <include file='doc\IEventPropertyService.uex' path='docs/doc[@for="IEventBindingService.GetEventProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts a single event to a property.
        ///    </para>
        /// </devdoc>
        PropertyDescriptor GetEventProperty(EventDescriptor e);
        
        /// <include file='doc\IEventPropertyService.uex' path='docs/doc[@for="IEventBindingService.ShowCode"]/*' />
        /// <devdoc>
        ///     Displays the user code for the designer.  This will return true if the user
        ///     code could be displayed, or false otherwise.
        /// </devdoc>
        bool ShowCode();
        
        /// <include file='doc\IEventPropertyService.uex' path='docs/doc[@for="IEventBindingService.ShowCode1"]/*' />
        /// <devdoc>
        ///     Displays the user code for the designer.  This will return true if the user
        ///     code could be displayed, or false otherwise.
        /// </devdoc>
        bool ShowCode(int lineNumber);
        
        /// <include file='doc\IEventPropertyService.uex' path='docs/doc[@for="IEventBindingService.ShowCode2"]/*' />
        /// <devdoc>
        ///     Displays the user code for the given event.  This will return true if the user
        ///     code could be displayed, or false otherwise.
        /// </devdoc>
        bool ShowCode(IComponent component, EventDescriptor e);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\iinheritanceservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IInheritanceService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\IInheritanceService.uex' path='docs/doc[@for="IInheritanceService"]/*' />
    /// <devdoc>
    ///    <para>Provides a set of utilities
    ///       for analyzing and identifying inherited components.</para>
    /// </devdoc>
    public interface IInheritanceService {
    
        /// <include file='doc\IInheritanceService.uex' path='docs/doc[@for="IInheritanceService.AddInheritedComponents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds inherited components from the specified component to the specified container.
        ///    </para>
        /// </devdoc>
        void AddInheritedComponents(IComponent component, IContainer container);
        
        /// <include file='doc\IInheritanceService.uex' path='docs/doc[@for="IInheritanceService.GetInheritanceAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the inheritance attribute of the specified
        ///       component. If the component is not being inherited, this method will return the
        ///       value <see cref='System.ComponentModel.InheritanceAttribute.NotInherited'/>. 
        ///       Otherwise it will return the inheritance attribute for this component.      
        ///    </para>
        /// </devdoc>
        InheritanceAttribute GetInheritanceAttribute(IComponent component);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\inheritancelevel.cs ===
//------------------------------------------------------------------------------
// <copyright file="InheritanceLevel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    
    /// <include file='doc\InheritanceLevel.uex' path='docs/doc[@for="InheritanceLevel"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       numeric IDs for different inheritance levels.
    ///    </para>
    /// </devdoc>
    public enum InheritanceLevel {
    
        /// <include file='doc\InheritanceLevel.uex' path='docs/doc[@for="InheritanceLevel.Inherited"]/*' />
        /// <devdoc>
        ///      Indicates that the object is inherited.
        /// </devdoc>
        Inherited = 1,
        
        /// <include file='doc\InheritanceLevel.uex' path='docs/doc[@for="InheritanceLevel.InheritedReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates that the object is inherited, but has read-only access.
        ///    </para>
        /// </devdoc>
        InheritedReadOnly = 2,
        
        /// <include file='doc\InheritanceLevel.uex' path='docs/doc[@for="InheritanceLevel.NotInherited"]/*' />
        /// <devdoc>
        ///      Indicates that the object is not inherited.
        /// </devdoc>
        NotInherited = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\imenucommandservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IMenuCommandService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Runtime.Remoting;
    using System.ComponentModel;

    using System.Diagnostics;
    
    using System;

    /// <include file='doc\IMenuCommandService.uex' path='docs/doc[@for="IMenuCommandService"]/*' />
    /// <devdoc>
    ///    <para>Provides an interface for a designer to add menu items to the Visual Studio
    ///       7.0 menu.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IMenuCommandService {
    
        /// <include file='doc\IMenuCommandService.uex' path='docs/doc[@for="IMenuCommandService.Verbs"]/*' />
        /// <devdoc>
        /// <para>Gets or sets an array of type <see cref='System.ComponentModel.Design.DesignerVerb'/> 
        /// that indicates the verbs that are currently available.</para>
        /// </devdoc>
        DesignerVerbCollection Verbs { get; }
    
        /// <include file='doc\IMenuCommandService.uex' path='docs/doc[@for="IMenuCommandService.AddCommand"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a menu command to the document.
        ///    </para>
        /// </devdoc>
        void AddCommand(MenuCommand command);
        
        /// <include file='doc\IMenuCommandService.uex' path='docs/doc[@for="IMenuCommandService.AddVerb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a verb to the set of global verbs.
        ///    </para>
        /// </devdoc>
        void AddVerb(DesignerVerb verb);
    
        /// <include file='doc\IMenuCommandService.uex' path='docs/doc[@for="IMenuCommandService.FindCommand"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Searches for the given command ID and returns
        ///       the <see cref='System.ComponentModel.Design.MenuCommand'/>
        ///       associated with it.
        ///    </para>
        /// </devdoc>
        MenuCommand FindCommand(CommandID commandID);
        
        /// <include file='doc\IMenuCommandService.uex' path='docs/doc[@for="IMenuCommandService.GlobalInvoke"]/*' />
        /// <devdoc>
        ///    <para>Invokes a command on the local form or in the global environment.</para>
        /// </devdoc>
        bool GlobalInvoke(CommandID commandID);
    
        /// <include file='doc\IMenuCommandService.uex' path='docs/doc[@for="IMenuCommandService.RemoveCommand"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the specified <see cref='System.ComponentModel.Design.MenuCommand'/> from the document.
        ///    </para>
        /// </devdoc>
        void RemoveCommand(MenuCommand command);
    
        /// <include file='doc\IMenuCommandService.uex' path='docs/doc[@for="IMenuCommandService.RemoveVerb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the specified verb from the document.
        ///    </para>
        /// </devdoc>
        void RemoveVerb(DesignerVerb verb);
    
        /// <include file='doc\IMenuCommandService.uex' path='docs/doc[@for="IMenuCommandService.ShowContextMenu"]/*' />
        /// <devdoc>
        ///    <para>Shows the context menu with the specified command ID at the specified
        ///       location.</para>
        /// </devdoc>
        void ShowContextMenu(CommandID menuID, int x, int y);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\ireferenceservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IReferenceService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;
    using System;

    /// <include file='doc\IReferenceService.uex' path='docs/doc[@for="IReferenceService"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides an interface to get names and references to objects. These
    ///       methods can search using the specified name or reference.
    ///    </para>
    /// </devdoc>
    public interface IReferenceService {
        
        /// <include file='doc\IReferenceService.uex' path='docs/doc[@for="IReferenceService.GetComponent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the base component that anchors this reference.
        ///    </para>
        /// </devdoc>
        IComponent GetComponent(object reference);

        /// <include file='doc\IReferenceService.uex' path='docs/doc[@for="IReferenceService.GetReference"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a reference for the specified name.
        ///    </para>
        /// </devdoc>
        object GetReference(string name);
    
        /// <include file='doc\IReferenceService.uex' path='docs/doc[@for="IReferenceService.GetName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name for this reference.
        ///    </para>
        /// </devdoc>
        string GetName(object reference);
    
        /// <include file='doc\IReferenceService.uex' path='docs/doc[@for="IReferenceService.GetReferences"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets all available references.
        ///    </para>
        /// </devdoc>
        object[] GetReferences();
    
        /// <include file='doc\IReferenceService.uex' path='docs/doc[@for="IReferenceService.GetReferences1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets all available references of this type.
        ///    </para>
        /// </devdoc>
        object[] GetReferences(Type baseType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\iresourceservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IResourceService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {

    using System.Globalization;
    using System.Resources;

    /// <include file='doc\IResourceService.uex' path='docs/doc[@for="IResourceService"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides designers a way to
    ///       access a resource for the current design-time
    ///       object.</para>
    /// </devdoc>
    public interface IResourceService {
    
        /// <include file='doc\IResourceService.uex' path='docs/doc[@for="IResourceService.GetResourceReader"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Locates the resource reader for the specified culture and
        ///       returns it.</para>
        /// </devdoc>
        IResourceReader GetResourceReader(CultureInfo info);
    
        /// <include file='doc\IResourceService.uex' path='docs/doc[@for="IResourceService.GetResourceWriter"]/*' />
        /// <devdoc>
        ///    <para>Locates the resource writer for the specified culture
        ///       and returns it. This will create a new resource for
        ///       the specified culture and destroy any existing resource,
        ///       should it exist.</para>
        /// </devdoc>
        IResourceWriter GetResourceWriter(CultureInfo info);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\iselectionservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISelectionService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\ISelectionService.uex' path='docs/doc[@for="ISelectionService"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides an interface for a designer to select components.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface ISelectionService {

        /// <include file='doc\ISelectionService.uex' path='docs/doc[@for="ISelectionService.PrimarySelection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the object that is currently the primary selection.
        ///    </para>
        /// </devdoc>
        object PrimarySelection { get; }
        
        /// <include file='doc\ISelectionService.uex' path='docs/doc[@for="ISelectionService.SelectionCount"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the count of selected objects.
        ///    </para>
        /// </devdoc>
        int SelectionCount { get; }

        /// <include file='doc\ISelectionService.uex' path='docs/doc[@for="ISelectionService.SelectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a <see cref='System.ComponentModel.Design.ISelectionService.SelectionChanged'/> event handler to the selection service.
        ///    </para>
        /// </devdoc>
        event EventHandler SelectionChanged;

        /// <include file='doc\ISelectionService.uex' path='docs/doc[@for="ISelectionService.SelectionChanging"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds an event handler to the selection service.
        ///    </para>
        /// </devdoc>
        event EventHandler SelectionChanging;

        /// <include file='doc\ISelectionService.uex' path='docs/doc[@for="ISelectionService.GetComponentSelected"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the component is currently selected.</para>
        /// </devdoc>

        bool GetComponentSelected(object component);

        /// <include file='doc\ISelectionService.uex' path='docs/doc[@for="ISelectionService.GetSelectedComponents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of components that are currently part of the user's selection.
        ///    </para>
        /// </devdoc>
        ICollection GetSelectedComponents();

        /// <include file='doc\ISelectionService.uex' path='docs/doc[@for="ISelectionService.SetSelectedComponents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the currently selected set of components.
        ///    </para>
        /// </devdoc>
        void SetSelectedComponents(ICollection components);

        /// <include file='doc\ISelectionService.uex' path='docs/doc[@for="ISelectionService.SetSelectedComponents1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the currently selected set of components to those with the specified selection type within the specified array of components.
        ///    </para>
        /// </devdoc>
        void SetSelectedComponents(ICollection components, SelectionTypes selectionType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\irootdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="IRootDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\IRootDesigner.uex' path='docs/doc[@for="IRootDesigner"]/*' />
    /// <devdoc>
    ///     Defines the root designer.  A root designer is the designer that sits
    ///     at the top, or root, of the object hierarchy.  The root designer's job
    ///     is to provide the design-time user interface for the design surface.
    ///     It does this through the View property.
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IRootDesigner : IDesigner {
    
        /// <include file='doc\IRootDesigner.uex' path='docs/doc[@for="IRootDesigner.SupportedTechnologies"]/*' />
        /// <devdoc>
        ///     The list of technologies that this designer can support
        ///     for its view.  Examples of different technologies are
        ///     Windows Forms and Web Forms.  Other object models can be
        ///     supported at design time, but they most be able to
        ///     provide a view in one of the supported technologies.
        /// </devdoc>
        ViewTechnology[] SupportedTechnologies { get; }

        /// <include file='doc\IRootDesigner.uex' path='docs/doc[@for="IRootDesigner.GetView"]/*' />
        /// <devdoc>
        ///     The user interface to present to the user.  The returning
        ///     data type is an object because there can be a variety
        ///     of different user interface technologies.  Development
        ///     environments typically support more than one technology.
        /// </devdoc>
        object GetView(ViewTechnology technology);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\inheritanceattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="InheritanceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    
    /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute"]/*' />
    /// <devdoc>
    ///    <para>Marks instances of objects that are inherited from their base class. This
    ///       class cannot be inherited.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event)]
    public sealed class InheritanceAttribute : Attribute {
    
        private readonly InheritanceLevel inheritanceLevel;

        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.Inherited"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the component is inherited. This field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly InheritanceAttribute Inherited = new InheritanceAttribute(InheritanceLevel.Inherited);

        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.InheritedReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that
        ///       the component is inherited and is read-only. This field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly InheritanceAttribute InheritedReadOnly = new InheritanceAttribute(InheritanceLevel.InheritedReadOnly);

        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.NotInherited"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the component is not inherited. This field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly InheritanceAttribute NotInherited = new InheritanceAttribute(InheritanceLevel.NotInherited);

        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value for
        ///       the InheritanceAttribute as NotInherited.
        ///    </para>
        /// </devdoc>
        public static readonly InheritanceAttribute Default = NotInherited;

        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.InheritanceAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.ComponentModel.Design.InheritanceAttribute 
        /// class.</para>
        /// </devdoc>
        public InheritanceAttribute() {
            inheritanceLevel = Default.inheritanceLevel;
        }
        
        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.InheritanceAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.ComponentModel.Design.InheritanceAttribute class 
        ///    with the specified inheritance
        ///    level.</para>
        /// </devdoc>
        public InheritanceAttribute(InheritanceLevel inheritanceLevel) {
            this.inheritanceLevel = inheritanceLevel;
        }
        
        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.InheritanceLevel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the current inheritance level stored in this attribute.
        ///    </para>
        /// </devdoc>
        public InheritanceLevel InheritanceLevel {
            get {
                return inheritanceLevel;
            }
        }
        
        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Override to test for equality.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object value) {
            if (value == this) {
                return true;
            }
            
            if (!(value is InheritanceAttribute)) {
                return false;
            }
            
            InheritanceLevel valueLevel = ((InheritanceAttribute)value).InheritanceLevel;
            return (valueLevel == inheritanceLevel);
        }

        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether this attribute is the default.
        ///    </para>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return (this.Equals(Default));
        }
        
        /// <include file='doc\InheritanceAttribute.uex' path='docs/doc[@for="InheritanceAttribute.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts this attribute to a string.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return TypeDescriptor.GetConverter(typeof(InheritanceLevel)).ConvertToString(InheritanceLevel);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\ityperesolutionservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITypeResolutionService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System;
    using System.Reflection;

    /// <include file='doc\ITypeResolutionService.uex' path='docs/doc[@for="ITypeResolutionService"]/*' />
    /// <devdoc>
    ///    <para>
    ///         The type resolution service is used to load types at design time.
    ///    </para>
    /// </devdoc>
    public interface ITypeResolutionService {

        /// <include file='doc\ITypeResolutionService.uex' path='docs/doc[@for="ITypeResolutionService.GetAssembly"]/*' />
        /// <devdoc>
        ///     Retrieves the requested assembly.
        /// </devdoc>    
        Assembly GetAssembly(AssemblyName name);
    
        /// <include file='doc\ITypeResolutionService.uex' path='docs/doc[@for="ITypeResolutionService.GetAssembly1"]/*' />
        /// <devdoc>
        ///     Retrieves the requested assembly.
        /// </devdoc>    
        Assembly GetAssembly(AssemblyName name, bool throwOnError);
    
        /// <include file='doc\ITypeResolutionService.uex' path='docs/doc[@for="ITypeResolutionService.GetType"]/*' />
        /// <devdoc>
        ///     Loads a type with the given name.
        /// </devdoc>
        Type GetType(string name);
    
        /// <include file='doc\ITypeResolutionService.uex' path='docs/doc[@for="ITypeResolutionService.GetType1"]/*' />
        /// <devdoc>
        ///     Loads a type with the given name.
        /// </devdoc>
        Type GetType(string name, bool throwOnError);
    
        /// <include file='doc\ITypeResolutionService.uex' path='docs/doc[@for="ITypeResolutionService.GetType2"]/*' />
        /// <devdoc>
        ///     Loads a type with the given name.
        /// </devdoc>
        Type GetType(string name, bool throwOnError, bool ignoreCase);
    
        /// <include file='doc\ITypeResolutionService.uex' path='docs/doc[@for="ITypeResolutionService.ReferenceAssembly"]/*' />
        /// <devdoc>
        ///     References the given assembly name.  Once an assembly has
        ///     been referenced types may be loaded from it without
        ///     qualifying them with the assembly.
        /// </devdoc>
        void ReferenceAssembly(AssemblyName name);

        /// <include file='doc\ITypeResolutionService.uex' path='docs/doc[@for="ITypeResolutionService.GetPathOfAssembly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the path to the file name from which the assembly was loaded.
        ///    </para>
        /// </devdoc>
        string GetPathOfAssembly(AssemblyName name);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\iserviceobjectcontainer.cs ===
//------------------------------------------------------------------------------
// <copyright file="IServiceObjectContainer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System;

    /// <include file='doc\IServiceObjectContainer.uex' path='docs/doc[@for="IServiceContainer"]/*' />
    /// <devdoc>
    ///     This interface provides a container for services.  A service container
    ///     is, by definition, a service provider.  In addition to providing services
    ///     it also provides a mechanism for adding and removing services.
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IServiceContainer : IServiceProvider {

        /// <include file='doc\IServiceObjectContainer.uex' path='docs/doc[@for="IServiceContainer.AddService"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        void AddService(Type serviceType, object serviceInstance);

        /// <include file='doc\IServiceObjectContainer.uex' path='docs/doc[@for="IServiceContainer.AddService1"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        void AddService(Type serviceType, object serviceInstance, bool promote);

        /// <include file='doc\IServiceObjectContainer.uex' path='docs/doc[@for="IServiceContainer.AddService2"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        void AddService(Type serviceType, ServiceCreatorCallback callback);

        /// <include file='doc\IServiceObjectContainer.uex' path='docs/doc[@for="IServiceContainer.AddService3"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote);

        /// <include file='doc\IServiceObjectContainer.uex' path='docs/doc[@for="IServiceContainer.RemoveService"]/*' />
        /// <devdoc>
        ///     Removes the given service type from the service container.
        /// </devdoc>
        void RemoveService(Type serviceType);

        /// <include file='doc\IServiceObjectContainer.uex' path='docs/doc[@for="IServiceContainer.RemoveService1"]/*' />
        /// <devdoc>
        ///     Removes the given service type from the service container.
        /// </devdoc>
        void RemoveService(Type serviceType, bool promote);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\menucommand.cs ===
//------------------------------------------------------------------------------
// <copyright file="MenuCommand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a Windows
    ///       menu or toolbar item.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class MenuCommand {

        // Events that we suface or call on
        //
        private EventHandler execHandler;
        private EventHandler statusHandler;

        private CommandID    commandID;
        private int          status;

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.ENABLED"]/*' />
        /// <devdoc>
        ///     Indicates that the given command is enabled.  An enabled command may
        ///     be selected by the user (it's not greyed out).
        /// </devdoc>
        private const int ENABLED   =  0x02;  //tagOLECMDF.OLECMDF_ENABLED;

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.INVISIBLE"]/*' />
        /// <devdoc>
        ///     Indicates that the given command is not visible on the command bar.
        /// </devdoc>
        private const int INVISIBLE = 0x10;

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.CHECKED"]/*' />
        /// <devdoc>
        ///     Indicates that the given command is checked in the "on" state.
        /// </devdoc>
        private const int CHECKED   = 0x04; // tagOLECMDF.OLECMDF_LATCHED;

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.SUPPORTED"]/*' />
        /// <devdoc>
        ///     Indicates that the given command is supported.  Marking a command
        ///     as supported indicates that the shell will not look any further up
        ///     the command target chain.
        /// </devdoc>
        private const int SUPPORTED = 0x01; // tagOLECMDF.OLECMDF_SUPPORTED


        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.MenuCommand"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.ComponentModel.Design.MenuCommand'/>.
        ///    </para>
        /// </devdoc>
        public MenuCommand(EventHandler handler, CommandID command) {
            this.execHandler = handler;
            this.commandID = command;
            this.status = SUPPORTED | ENABLED;
        }

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.Checked"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets a value indicating whether this menu item is checked.</para>
        /// </devdoc>
        public virtual bool Checked {
            get {
                return (status & CHECKED) != 0;
            }

            set {
                SetStatus(CHECKED, value);
            }
        }

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.Enabled"]/*' />
        /// <devdoc>
        ///    <para> Gets or
        ///       sets a value indicating whether this menu item is available.</para>
        /// </devdoc>
        public virtual bool Enabled {
            get{
                return (status & ENABLED) != 0;
            }

            set {
                SetStatus(ENABLED, value);
            }
        }

        private void SetStatus(int mask, bool value){
            int newStatus = status;

            if (value) {
                newStatus |= mask;
            }
            else {
                newStatus &= ~mask;
            }

            if (newStatus != status) {
                status = newStatus;
                OnCommandChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.Supported"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets a value
        ///       indicating whether this menu item is supported.</para>
        /// </devdoc>
        public virtual bool Supported {
            get{
                return (status & SUPPORTED) != 0;
            }
            set{
                SetStatus(SUPPORTED, value);
            }
        }

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.Visible"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets a value
        ///       indicating if this menu item is visible.</para>
        /// </devdoc>
        public virtual bool Visible {
            get {
                return (status & INVISIBLE) == 0;
            }
            set {
                SetStatus(INVISIBLE, !value);
            }
        }

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.CommandChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the menu command changes.
        ///    </para>
        /// </devdoc>
        public event EventHandler CommandChanged {
            add {
                statusHandler += value;
            }
            remove {
                statusHandler -= value;
            }
        }

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.CommandID"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.ComponentModel.Design.CommandID'/> associated with this menu command.</para>
        /// </devdoc>
        public virtual CommandID CommandID {
            get {
                return commandID;
            }
        }
        
        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.Invoke"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Invokes a menu item.
        ///    </para>
        /// </devdoc>
        public virtual void Invoke() {
            if (execHandler != null){
                try {
                    execHandler.Invoke(this, EventArgs.Empty);
                }
                catch (CheckoutException cxe) {
                    if (cxe == CheckoutException.Canceled)
                        return;
                    
                    throw;
                }
            }
        }

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.OleStatus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the OLE command status code for this menu item.
        ///    </para>
        /// </devdoc>
        public virtual int OleStatus {
            get {
                return status;
            }
        }

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.OnCommandChanged"]/*' />
        /// <devdoc>
        ///    <para>Provides notification and is called in response to 
        ///       a <see cref='System.ComponentModel.Design.MenuCommand.CommandChanged'/> event.</para>
        /// </devdoc>
        protected virtual void OnCommandChanged(EventArgs e) {
            if (statusHandler != null) {
                statusHandler.Invoke(this, e);
            }
        }

        /// <include file='doc\MenuCommand.uex' path='docs/doc[@for="MenuCommand.ToString"]/*' />
        /// <devdoc>
        ///    Overrides object's ToString().
        /// </devdoc>
        public override string ToString() {
            string str = commandID.ToString() + " : ";
            if ((status & SUPPORTED) != 0) {
                str += "Supported";
            }
            if ((status & ENABLED) != 0) {
                str += "|Enabled";
            }
            if ((status & INVISIBLE) == 0) {
                str += "|Visible";
            }
            if ((status & CHECKED) != 0) {
                str += "|Checked";
            }
            return str;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\parenthesizepropertynameattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ParenthesizePropertyNameAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    
    using System;

    /// <include file='doc\ParenthesizePropertyNameAttribute.uex' path='docs/doc[@for="ParenthesizePropertyNameAttribute"]/*' />
    /// <devdoc>
    ///    <para>Provides a value indicating whether the name of the associated property is parenthesized in the
    ///       properties window.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class ParenthesizePropertyNameAttribute : Attribute {
        /// <include file='doc\ParenthesizePropertyNameAttribute.uex' path='docs/doc[@for="ParenthesizePropertyNameAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the System.ComponentModel.Design.ParenthesizePropertyName
        ///       attribute by default to
        ///    <see langword='false'/>.
        ///    </para>
        /// </devdoc>
        public static readonly ParenthesizePropertyNameAttribute Default = new ParenthesizePropertyNameAttribute();

        private bool needParenthesis;
        
        /// <include file='doc\ParenthesizePropertyNameAttribute.uex' path='docs/doc[@for="ParenthesizePropertyNameAttribute.ParenthesizePropertyNameAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ParenthesizePropertyNameAttribute() : this(false) {
        }
        
        /// <include file='doc\ParenthesizePropertyNameAttribute.uex' path='docs/doc[@for="ParenthesizePropertyNameAttribute.ParenthesizePropertyNameAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.ComponentModel.Design.ParenthesizePropertyNameAttribute 
        /// class, using the specified value to indicate whether the attribute is
        /// marked for display with parentheses.</para>
        /// </devdoc>
        public ParenthesizePropertyNameAttribute(bool needParenthesis) {
            this.needParenthesis = needParenthesis;
        }

        /// <include file='doc\ParenthesizePropertyNameAttribute.uex' path='docs/doc[@for="ParenthesizePropertyNameAttribute.NeedParenthesis"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating
        ///       whether the
        ///       attribute is placed in parentheses when listed in
        ///       the properties window.
        ///    </para>
        /// </devdoc>
        public bool NeedParenthesis {
            get {
                return needParenthesis;
            }
        }

        /// <include file='doc\ParenthesizePropertyNameAttribute.uex' path='docs/doc[@for="ParenthesizePropertyNameAttribute.Equals"]/*' />
        /// <devdoc>
        ///    <para>Compares the specified object
        ///       to this object and tests for equality.</para>
        /// </devdoc>
        public override bool Equals(object o) {
            if (o is ParenthesizePropertyNameAttribute) {
                return ((ParenthesizePropertyNameAttribute)o).NeedParenthesis == needParenthesis;
            }
            return false;
        }
        
        /// <include file='doc\ParenthesizePropertyNameAttribute.uex' path='docs/doc[@for="ParenthesizePropertyNameAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\ParenthesizePropertyNameAttribute.uex' path='docs/doc[@for="ParenthesizePropertyNameAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether this attribute is set to <see langword='true'/> by default.</para>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return this.Equals(Default);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\notifyparentpropertyattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="NotifyParentPropertyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.ComponentModel {
    
    using System;

    /// <include file='doc\NotifyParentPropertyAttribute.uex' path='docs/doc[@for="NotifyParentPropertyAttribute"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Indicates whether the parent property is notified
    ///       if a child namespace property is modified.
    ///    </para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Property)]
    public sealed class NotifyParentPropertyAttribute : Attribute {

        /// <include file='doc\NotifyParentPropertyAttribute.uex' path='docs/doc[@for="NotifyParentPropertyAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the parent property should be notified on changes to the child class property. This field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly NotifyParentPropertyAttribute Yes = new NotifyParentPropertyAttribute(true);

        /// <include file='doc\NotifyParentPropertyAttribute.uex' path='docs/doc[@for="NotifyParentPropertyAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the parent property should not be notified of changes to the child class property. This field is read-only.</para>
        /// </devdoc>
        public static readonly NotifyParentPropertyAttribute No = new NotifyParentPropertyAttribute(false);

        /// <include file='doc\NotifyParentPropertyAttribute.uex' path='docs/doc[@for="NotifyParentPropertyAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>Specifies the default attribute state, that the parent property should not be notified of changes to the child class property.
        ///       This field is read-only.</para>
        /// </devdoc>
        public static readonly NotifyParentPropertyAttribute Default = No;

        private bool notifyParent = false;


        /// <include file='doc\NotifyParentPropertyAttribute.uex' path='docs/doc[@for="NotifyParentPropertyAttribute.NotifyParentPropertyAttribute"]/*' />
        /// <devdoc>
        /// <para>Initiailzes a new instance of the NotifyPropertyAttribute class 
        ///    that uses the specified value
        ///    to indicate whether the parent property should be notified when a child namespace property is modified.</para>
        /// </devdoc>
        public NotifyParentPropertyAttribute(bool notifyParent) {
            this.notifyParent = notifyParent;
        }


        /// <include file='doc\NotifyParentPropertyAttribute.uex' path='docs/doc[@for="NotifyParentPropertyAttribute.NotifyParent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether the parent property should be notified
        ///       on changes to a child namespace property.
        ///    </para>
        /// </devdoc>
        public bool NotifyParent {
            get {
                return notifyParent;
            }
        }


        /// <include file='doc\NotifyParentPropertyAttribute.uex' path='docs/doc[@for="NotifyParentPropertyAttribute.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests whether the specified object is the same as the current object.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }
            if ((obj != null) && (obj is NotifyParentPropertyAttribute)) {
                return ((NotifyParentPropertyAttribute)obj).NotifyParent == notifyParent;
            }

            return false;
        }

        /// <include file='doc\NotifyParentPropertyAttribute.uex' path='docs/doc[@for="NotifyParentPropertyAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\NotifyParentPropertyAttribute.uex' path='docs/doc[@for="NotifyParentPropertyAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether this attribute is <see langword='true'/> by default.
        ///    </para>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return this.Equals(Default);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\itypedescriptorfilterservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITypeDescriptorFilterService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\ITypeDescriptorFilterService.uex' path='docs/doc[@for="ITypeDescriptorFilterService"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Modifies the set of type descriptors that a component
    ///       provides.
    ///    </para>
    /// </devdoc>
    public interface ITypeDescriptorFilterService {

        /// <include file='doc\ITypeDescriptorFilterService.uex' path='docs/doc[@for="ITypeDescriptorFilterService.FilterAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a way to filter the attributes from a component that are displayed to the user.
        ///    </para>
        /// </devdoc>
        bool FilterAttributes(IComponent component, IDictionary attributes);

        /// <include file='doc\ITypeDescriptorFilterService.uex' path='docs/doc[@for="ITypeDescriptorFilterService.FilterEvents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a way to filter the events from a component that are displayed to the user.
        ///    </para>
        /// </devdoc>
        bool FilterEvents(IComponent component, IDictionary events);

        /// <include file='doc\ITypeDescriptorFilterService.uex' path='docs/doc[@for="ITypeDescriptorFilterService.FilterProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a way to filter the properties from a component that are displayed to the user.
        ///    </para>
        /// </devdoc>
        bool FilterProperties(IComponent component, IDictionary properties);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\refreshproperties.cs ===
//------------------------------------------------------------------------------
// <copyright file="RefreshProperties.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {

    /// <include file='doc\RefreshProperties.uex' path='docs/doc[@for="RefreshProperties"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies identifiers that indicate the nature of
    ///       the refresh, for use in refreshing the design time view.
    ///    </para>
    /// </devdoc>
    public enum RefreshProperties {
        /// <include file='doc\RefreshProperties.uex' path='docs/doc[@for="RefreshProperties.None"]/*' />
        /// <devdoc>
        ///    <para>Indicates to use the no refresh mode.</para>
        /// </devdoc>
        None,
        /// <include file='doc\RefreshProperties.uex' path='docs/doc[@for="RefreshProperties.All"]/*' />
        /// <devdoc>
        ///    <para>Indicates to use the refresh all refresh mode.</para>
        /// </devdoc>
        All,
        /// <include file='doc\RefreshProperties.uex' path='docs/doc[@for="RefreshProperties.Repaint"]/*' />
        /// <devdoc>
        ///    <para>Indicates to use the repaint refresh mode.</para>
        /// </devdoc>
        Repaint,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\propertytabscope.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyTabScope.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    /// <include file='doc\PropertyTabScope.uex' path='docs/doc[@for="PropertyTabScope"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the function scope of
    ///       a tab in the properties window.
    ///    </para>
    /// </devdoc>
    public enum PropertyTabScope{
            /// <include file='doc\PropertyTabScope.uex' path='docs/doc[@for="PropertyTabScope.Static"]/*' />
            /// <devdoc>
            ///    <para>
            ///       This tab will be added to the properties window and can never be
            ///       removed.
            ///    </para>
            /// </devdoc>
            Static = 0,
            
            /// <include file='doc\PropertyTabScope.uex' path='docs/doc[@for="PropertyTabScope.Global"]/*' />
            /// <devdoc>
            ///    <para>
            ///       This tab will be added to the properties window and can
            ///       only be explictly removed by a component outside the properties window.
            ///    </para>
            /// </devdoc>
            Global = 1,
            
            /// <include file='doc\PropertyTabScope.uex' path='docs/doc[@for="PropertyTabScope.Document"]/*' />
            /// <devdoc>
            ///    <para>
            ///       This tab will be added to the properties window
            ///       and will be removed when the currently selected document changes. This tab is relevant to
            ///       items on the current document.
            ///    </para>
            /// </devdoc>
            Document = 2,
            
            /// <include file='doc\PropertyTabScope.uex' path='docs/doc[@for="PropertyTabScope.Component"]/*' />
            /// <devdoc>
            ///    <para>
            ///       This tab will be added to the properties window for the current component only, and is
            ///       removed when the component is no longer selected.
            ///    </para>
            /// </devdoc>
            Component = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\refreshpropertiesattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RefreshPropertiesAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    
    /// <include file='doc\RefreshPropertiesAttribute.uex' path='docs/doc[@for="RefreshPropertiesAttribute"]/*' />
    /// <devdoc>
    ///    <para> Specifies how a designer refreshes when the property value is changed.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class RefreshPropertiesAttribute : Attribute {

        /// <include file='doc\RefreshPropertiesAttribute.uex' path='docs/doc[@for="RefreshPropertiesAttribute.All"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates all properties should
        ///       be refreshed if the property value is changed. This field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly RefreshPropertiesAttribute All = new RefreshPropertiesAttribute(RefreshProperties.All);

        /// <include file='doc\RefreshPropertiesAttribute.uex' path='docs/doc[@for="RefreshPropertiesAttribute.Repaint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates all properties should
        ///       be invalidated and repainted if the
        ///       property value is changed. This field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly RefreshPropertiesAttribute Repaint = new RefreshPropertiesAttribute(RefreshProperties.Repaint);

        /// <include file='doc\RefreshPropertiesAttribute.uex' path='docs/doc[@for="RefreshPropertiesAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates that by default
        ///       no
        ///       properties should be refreshed if the property value
        ///       is changed. This field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly RefreshPropertiesAttribute Default = new RefreshPropertiesAttribute(RefreshProperties.None);

        private RefreshProperties refresh;

        /// <include file='doc\RefreshPropertiesAttribute.uex' path='docs/doc[@for="RefreshPropertiesAttribute.RefreshPropertiesAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public RefreshPropertiesAttribute(RefreshProperties refresh) {
            this.refresh = refresh;
        }

        /// <include file='doc\RefreshPropertiesAttribute.uex' path='docs/doc[@for="RefreshPropertiesAttribute.RefreshProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the refresh properties for the member.
        ///    </para>
        /// </devdoc>
        public RefreshProperties RefreshProperties {
            get {
                return refresh;
            }
        }

        /// <include file='doc\RefreshPropertiesAttribute.uex' path='docs/doc[@for="RefreshPropertiesAttribute.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Overrides object's Equals method.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object value) {
            if (value is RefreshPropertiesAttribute) {
                return(((RefreshPropertiesAttribute)value).RefreshProperties == refresh);
            }
            return false;
        }

        /// <include file='doc\RefreshPropertiesAttribute.uex' path='docs/doc[@for="RefreshPropertiesAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\RefreshPropertiesAttribute.uex' path='docs/doc[@for="RefreshPropertiesAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the current attribute is the default.</para>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return this.Equals(Default);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\selectiontypes.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionTypes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\SelectionTypes.uex' path='docs/doc[@for="SelectionTypes"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies identifiers
    ///       that indicate the type
    ///       of selection for a component or group of components that are selected.
    ///    </para>
    /// </devdoc>
    [
        Flags,
        System.Runtime.InteropServices.ComVisible(true)
    ]
    public enum SelectionTypes {

        /// <include file='doc\SelectionTypes.uex' path='docs/doc[@for="SelectionTypes.Normal"]/*' />
        /// <devdoc>
        ///    <para>A Normal selection. With this type of selection, the selection service responds
        ///       to the control and shift keys to support appending or toggling components into the
        ///       selection as needed.</para>
        /// </devdoc>
        Normal    = 0x0001,

        /// <include file='doc\SelectionTypes.uex' path='docs/doc[@for="SelectionTypes.Replace"]/*' />
        /// <devdoc>
        ///    <para>A Replace selection. This causes the selection service to always replace the
        ///       current selection with the replacement.</para>
        /// </devdoc>
        Replace   = 0x0002,

        /// <include file='doc\SelectionTypes.uex' path='docs/doc[@for="SelectionTypes.MouseDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A
        ///       MouseDown selection. Happens when the user presses down on
        ///       the mouse button when the pointer is over a control (or component). If a
        ///       component in the selection list is already selected, it does not remove the
        ///       existing selection, but promotes that component to be the primary selection.
        ///    </para>
        /// </devdoc>
        MouseDown = 0x0004,

        /// <include file='doc\SelectionTypes.uex' path='docs/doc[@for="SelectionTypes.MouseUp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A MouseUp selection. Happens when the user releases the
        ///       mouse button when a control (or component) has been selected. If a component
        ///       in the selection list is already selected, it does not remove the
        ///       existing selection, but promotes that component to be the primary selection.
        ///    </para>
        /// </devdoc>
        MouseUp  = 0x0008,

        /// <include file='doc\SelectionTypes.uex' path='docs/doc[@for="SelectionTypes.Click"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A Click selection.
        ///       Happens when a user clicks on a component. If a component in the selection list is already
        ///       selected, it does not remove the existing selection, but promotes that component to be the
        ///       primary selection.
        ///    </para>
        /// </devdoc>
        Click   = 0x0010,

        /// <include file='doc\SelectionTypes.uex' path='docs/doc[@for="SelectionTypes.Valid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Limits valid selection types to Normal, Replace, MouseDown, MouseUp or
        ///       Click.
        ///       
        ///    </para>
        /// </devdoc>
        Valid   = Normal | Replace | MouseDown | MouseUp | Click,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\servicecreatorcallback.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceCreatorCallback.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System;

    /// <include file='doc\ServiceCreatorCallback.uex' path='docs/doc[@for="ServiceCreatorCallback"]/*' />
    /// <devdoc>
    ///     Declares a callback function to create an instance of a service on demand.
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public delegate object ServiceCreatorCallback(IServiceContainer container, Type serviceType);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\propertytabattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyTabAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    
    using System;
    using System.ComponentModel;
    using System.Reflection;

    /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute"]/*' />
    /// <devdoc>
    ///    <para> Identifies the property tab or tabs that should be displayed for the
    ///       specified class or classes.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class PropertyTabAttribute : Attribute {
        private PropertyTabScope[]  tabScopes;
        private Type[] tabClasses;
        private string[] tabClassNames;
        
        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.PropertyTabAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Basic constructor that creates a PropertyTabAttribute.  Use this ctor to derive from this
        ///       attribute and specify multiple tab types by calling InitializeArrays.
        ///    </para>
        /// </devdoc>
        public PropertyTabAttribute() {
            tabScopes = new PropertyTabScope[0];
            tabClassNames = new string[0];
        }

        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.PropertyTabAttribute1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Basic constructor that creates a property tab attribute that will create a tab
        ///       of the specified type.
        ///    </para>
        /// </devdoc>
        public PropertyTabAttribute(Type tabClass) : this(tabClass, PropertyTabScope.Component) {
        }

        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.PropertyTabAttribute2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Basic constructor that creates a property tab attribute that will create a tab
        ///       of the specified type.
        ///    </para>
        /// </devdoc>
        public PropertyTabAttribute(string tabClassName) : this(tabClassName, PropertyTabScope.Component) {
        }

        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.PropertyTabAttribute3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Basic constructor that creates a property tab attribute that will create a tab
        ///       of the specified type.
        ///    </para>
        /// </devdoc>
        public PropertyTabAttribute(Type tabClass, PropertyTabScope tabScope) {
        
            this.tabClasses = new Type[]{ tabClass};
            if (tabScope < PropertyTabScope.Document) {
                throw new ArgumentException("Scope must be PropertyTabScope.Document or PropertyTabScope.Component");
            }
            this.tabScopes  = new PropertyTabScope[]{tabScope};

        }

        
        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.PropertyTabAttribute4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Basic constructor that creates a property tab attribute that will create a tab
        ///       of the specified type.
        ///    </para>
        /// </devdoc>
        public PropertyTabAttribute(string tabClassName, PropertyTabScope tabScope) {
            this.tabClassNames = new string[]{ tabClassName};
            if (tabScope < PropertyTabScope.Document) {
                throw new ArgumentException("Scope must be PropertyTabScope.Document or PropertyTabScope.Component");
            }
            this.tabScopes  = new PropertyTabScope[]{tabScope};
        }

        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.TabClasses"]/*' />
        /// <devdoc>
        ///    <para>Gets the types of tab that this attribute specifies.</para>
        /// </devdoc>
        public Type[] TabClasses {
            get {
                if (tabClasses == null && tabClassNames != null) {
                    tabClasses = new Type[tabClassNames.Length];
                    for (int i=0; i<tabClassNames.Length; i++) {
                    
                        int commaIndex = tabClassNames[i].IndexOf(',');
                        string className = null;
                        string assemblyName = null;
                        
                        if (commaIndex != -1) {
                            className = tabClassNames[i].Substring(0, commaIndex).Trim();
                            assemblyName = tabClassNames[i].Substring(commaIndex + 1).Trim();
                        }
                        else {
                            className = tabClassNames[i];
                        }
                        
                        tabClasses[i] = Type.GetType(className, false);
                        
                        if (tabClasses[i] == null) {
                            if (assemblyName != null) {
                                Assembly a = Assembly.Load(assemblyName);
                                if (a != null) {
                                    tabClasses[i] = a.GetType(className, true);
                                }
                            }
                            else {
                                throw new TypeLoadException("Couldn't find type '" + className + "'");
                            }
                        }
                    }
                }
                return tabClasses;
            }
        }
        
        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.TabClassNames"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string[] TabClassNames{
            get {
                if (tabClassNames != null) {
                    return (string[])tabClassNames.Clone();
                }
                else {
                    return null;
                }
            }
        }

        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.TabScopes"]/*' />
        /// <devdoc>
        /// <para>Gets the scopes of tabs for this System.ComponentModel.Design.PropertyTabAttribute, from System.ComponentModel.Design.PropertyTabScope.</para>
        /// </devdoc>
        public PropertyTabScope[] TabScopes {
            get {
                return tabScopes;
            }
        }
              /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.Equals"]/*' />
              /// <internalonly/>
        public override bool Equals(object other) {
            if (other is PropertyTabAttribute) {
                return Equals((PropertyTabAttribute)other);
            }
            return false;
        }

        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.Equals1"]/*' />
        /// <internalonly/>
        public bool Equals(PropertyTabAttribute other) {
            if (other == (object)this) {
                return true;
            }
            if (other.TabClasses.Length != TabClasses.Length ||
                other.TabScopes.Length != TabScopes.Length) {
                return false;
            }

            for (int i = 0; i < TabClasses.Length; i++) {
                if (TabClasses[i] != other.TabClasses[i] ||
                    TabScopes[i] != other.TabScopes[i]) {
                    return false;
                }
            }
            return true;
        }
        

        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }
        
        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.InitializeArrays"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Utiliity function to set the types of tab classes this PropertyTabAttribute specifies.
        ///    </para>
        /// </devdoc>
        protected void InitializeArrays(string[] tabClassNames, PropertyTabScope[] tabScopes) {
            InitializeArrays(tabClassNames, null, tabScopes);
        }
        
        /// <include file='doc\PropertyTabAttribute.uex' path='docs/doc[@for="PropertyTabAttribute.InitializeArrays1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Utiliity function to set the types of tab classes this PropertyTabAttribute specifies.
        ///    </para>
        /// </devdoc>
        protected void InitializeArrays(Type[] tabClasses, PropertyTabScope[] tabScopes) {
            InitializeArrays(null, tabClasses, tabScopes);
        }
        
        
        private void InitializeArrays(string[] tabClassNames, Type[] tabClasses, PropertyTabScope[] tabScopes) {
        
            if (tabClasses != null) {
                if (tabScopes != null && tabClasses.Length != tabScopes.Length) {
                    throw new ArgumentException("tabClasses must have the same number of items as tabScopes");
                }
                this.tabClasses = (Type[])tabClasses.Clone();
            }
            else if (tabClassNames != null) {
                if (tabScopes != null && tabClasses.Length != tabScopes.Length) {
                    throw new ArgumentException("tabClasses must have the same number of items as tabScopes");
                }
                this.tabClassNames = (string[])tabClassNames.Clone();
                this.tabClasses = null;
            }
            else if (this.tabClasses == null && this.tabClassNames == null) {
                throw new ArgumentException("An array of tab type names or tab types must be specified");
            }
            
            if (tabScopes != null) {
                for (int i = 0; i < tabScopes.Length; i++) {
                    if (tabScopes[i] < PropertyTabScope.Document) {
                        throw new ArgumentException("Scope must be PropertyTabScope.Document or PropertyTabScope.Component");
                    }
                }
                this.tabScopes = (PropertyTabScope[])tabScopes.Clone();
            }
            else {
                this.tabScopes = new PropertyTabScope[tabClasses.Length];

                for (int i = 0; i < TabScopes.Length; i++) {
                    this.tabScopes[i] = PropertyTabScope.Component;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serviceobjectcontainer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceObjectContainer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System;
    using System.Collections;
    using Microsoft.Win32;
    using System.Diagnostics;

    /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer"]/*' />
    /// <devdoc>
    ///     This is a simple implementation of IServiceContainer.
    /// </devdoc>
    public sealed class ServiceContainer : IServiceContainer {
        private Hashtable services;
        private IServiceProvider parentProvider;
        
        private static TraceSwitch TRACESERVICE = new TraceSwitch("TRACESERVICE", "ServiceProvider: Trace service provider requests.");
        
        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.ServiceContainer"]/*' />
        /// <devdoc>
        ///     Creates a new service object container.  
        /// </devdoc>
        public ServiceContainer() {
        }
        
        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.ServiceContainer1"]/*' />
        /// <devdoc>
        ///     Creates a new service object container.  
        /// </devdoc>
        public ServiceContainer(IServiceProvider parentProvider) {
            this.parentProvider = parentProvider;
        }
        
        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.Container"]/*' />
        /// <devdoc>
        ///     Retrieves the parent service container, or null
        ///     if there is no parent container.
        /// </devdoc>
        private IServiceContainer Container { 
            get {
                IServiceContainer container = null;
                if (parentProvider != null) {
                    container = (IServiceContainer)parentProvider.GetService(typeof(IServiceContainer));
                }
                return container;
            }
        }
        
        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.Services"]/*' />
        /// <devdoc>
        ///     Our hashtable of services.  The hashtable is demand
        ///     created here.
        /// </devdoc>
        private Hashtable Services {
            get {
                if (services == null) {
                    services = new Hashtable();
                }
                return services;
            }
        }
        
        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.AddService"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        public void AddService(Type serviceType, object serviceInstance) {
            AddService(serviceType, serviceInstance, false);
        }

        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.AddService1"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        public void AddService(Type serviceType, object serviceInstance, bool promote) {
            Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Adding service (instance) " + serviceType.Name + ".  Promoting: " + promote.ToString());
            if (promote) {
                IServiceContainer container = Container;
                if (container != null) {
                    Debug.Indent();
                    Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Promoting to container");
                    Debug.Unindent();
                    container.AddService(serviceType, serviceInstance, promote);
                    return;
                }
            }
            
            // We're going to add this locally.  Ensure that the service instance
            // is correct.
            //
            if (serviceType == null) throw new ArgumentNullException("serviceType");
            if (serviceInstance == null) throw new ArgumentNullException("serviceInstance");
            if (!(serviceInstance is ServiceCreatorCallback) && !serviceInstance.GetType().IsCOMObject && !serviceType.IsAssignableFrom(serviceInstance.GetType())) {
                throw new ArgumentException(SR.GetString(SR.ErrorInvalidServiceInstance, serviceType.FullName));
            }
            
            if (Services.ContainsKey(serviceType)) {
                throw new ArgumentException(SR.GetString(SR.ErrorServiceExists, serviceType.FullName), "serviceType");
            }
            
            Services[serviceType] = serviceInstance;
        }

        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.AddService2"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        public void AddService(Type serviceType, ServiceCreatorCallback callback) {
            AddService(serviceType, callback, false);
        }

        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.AddService3"]/*' />
        /// <devdoc>
        ///     Adds the given service to the service container.
        /// </devdoc>
        public void AddService(Type serviceType, ServiceCreatorCallback callback, bool promote) {
            Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Adding service (callback) " + serviceType.Name + ".  Promoting: " + promote.ToString());
            if (promote) {
                IServiceContainer container = Container;
                if (container != null) {
                    Debug.Indent();
                    Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Promoting to container");
                    Debug.Unindent();
                    container.AddService(serviceType, callback, promote);
                    return;
                }
            }
            
            // We're going to add this locally.  Ensure that the service instance
            // is correct.
            //
            if (serviceType == null) throw new ArgumentNullException("serviceType");
            if (callback == null) throw new ArgumentNullException("callback");
            
            if (Services.ContainsKey(serviceType)) {
                throw new ArgumentException(SR.GetString(SR.ErrorServiceExists, serviceType.FullName), "serviceType");
            }
            
            Services[serviceType] = callback;
        }

        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.GetService"]/*' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public object GetService(Type serviceType) {
            object service = null;
            
            Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Searching for service " + serviceType.Name);
            Debug.Indent();
            
            // Try locally.  We first test for services we
            // implement and then look in our hashtable.
            //
            if (serviceType == typeof(IServiceContainer)) {
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Returning ourselves as a container");
                service = this;
            }
            else {
                service = Services[serviceType];
            }
            
            // Is the service a creator delegate?
            //
            if (service is ServiceCreatorCallback) {
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Encountered a callback. Invoking it");
                service = ((ServiceCreatorCallback)service)(this, serviceType);
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Callback return object: " + (service == null ? "(null)" : service.ToString()));
                if (service != null && !service.GetType().IsCOMObject && !serviceType.IsAssignableFrom(service.GetType())) {
                    // Callback passed us a bad service.  NULL it, rather than throwing an exception.
                    // Callers here do not need to be prepared to handle bad callback implemetations.
                    Debug.Fail("Object " + service.GetType().Name + " was returned from a service creator callback but it does not implement the registered type of " + serviceType.Name);
                    Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "**** Object does not implement service interface");
                    service = null;
                }
                
                // And replace the callback with our new service.
                //
                Services[serviceType] = service;
            }
            
            if (service == null && parentProvider != null) {
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Service unresolved.  Trying parent");
                service = parentProvider.GetService(serviceType);
            }
            
            #if DEBUG
            if (TRACESERVICE.TraceVerbose && service == null) {
                Debug.WriteLine("******************************************");
                Debug.WriteLine("FAILED to resolve service " + serviceType.Name);
                Debug.WriteLine("AT: " + Environment.StackTrace);
                Debug.WriteLine("******************************************");
            }
            #endif
            Debug.Unindent();
            
            return service;
        }
        
        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.RemoveService"]/*' />
        /// <devdoc>
        ///     Removes the given service type from the service container.
        /// </devdoc>
        public void RemoveService(Type serviceType) {
            RemoveService(serviceType, false);
        }

        /// <include file='doc\ServiceObjectContainer.uex' path='docs/doc[@for="ServiceContainer.RemoveService1"]/*' />
        /// <devdoc>
        ///     Removes the given service type from the service container.
        /// </devdoc>
        public void RemoveService(Type serviceType, bool promote) {
            Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Removing service: " + serviceType.Name + ", Promote: " + promote.ToString());
            if (promote) {
                IServiceContainer container = Container;
                if (container != null) {
                    Debug.Indent();
                    Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Invoking parent container");
                    Debug.Unindent();
                    container.RemoveService(serviceType, promote);
                    return;
                }
            }
            
            // We're going to remove this from our local list.
            //
            if (serviceType == null) throw new ArgumentNullException("serviceType");
            Services.Remove(serviceType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\contextstack.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContextStack.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Collections;

    /// <include file='doc\ContextStack.uex' path='docs/doc[@for="ContextStack"]/*' />
    /// <devdoc>
    ///     A context stack is an object that can be used by serializers
    ///     to push various context objects.  Serialization is often
    ///     a deeply nested operation, involving many different 
    ///     serialization classes.  These classes often need additional
    ///     context information when performing serialization.  As
    ///     an example, an object with a property named "Enabled" may have
    ///     a data type of System.Boolean.  If a serializer is writing
    ///     this value to a data stream it may want to know what property
    ///     it is writing.  It won't have this information, however, because
    ///     it is only instructed to write the boolean value.  In this 
    ///     case the parent serializer may push a PropertyDescriptor
    ///     pointing to the "Enabled" property on the context stack.
    ///     What objects get pushed on this stack are up to the
    ///     individual serializer objects.
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public sealed class ContextStack {
        private ArrayList contextStack;
    
        /// <include file='doc\ContextStack.uex' path='docs/doc[@for="ContextStack.Current"]/*' />
        /// <devdoc>
        ///     Retrieves the current object on the stack, or null
        ///     if no objects have been pushed.
        /// </devdoc>
        public object Current {
            get {
                if (contextStack != null && contextStack.Count > 0) {
                    return contextStack[contextStack.Count - 1];
                }
                return null;
            }
        }
        
        /// <include file='doc\ContextStack.uex' path='docs/doc[@for="ContextStack.this"]/*' />
        /// <devdoc>
        ///     Retrieves the object on the stack at the given
        ///     level, or null if no object exists at that level.
        /// </devdoc>
        public object this[int level] {
            get {
                if (level < 0) {
                    throw new ArgumentOutOfRangeException("level");
                }
                if (contextStack != null && level < contextStack.Count) {
                    return contextStack[contextStack.Count - 1 - level];
                }
                return null;
            }
        }
        
        /// <include file='doc\ContextStack.uex' path='docs/doc[@for="ContextStack.this1"]/*' />
        /// <devdoc>
        ///     Retrieves the first object on the stack that 
        ///     inherits from or implements the given type, or
        ///     null if no object on the stack implements the type.
        /// </devdoc>
        public object this[Type type] {
            get {
                if (type == null) {
                    throw new ArgumentNullException("type");
                }
                
                if (contextStack != null) {
                    int level = contextStack.Count;
                    while(level > 0) {
                        object value = contextStack[--level];
                        if (type.IsInstanceOfType(value)) {
                            return value;
                        }
                    }
                }
                
                return null;
            }
        }
        
        /// <include file='doc\ContextStack.uex' path='docs/doc[@for="ContextStack.Pop"]/*' />
        /// <devdoc>
        ///     Pops the current object off of the stack, returning
        ///     its value.
        /// </devdoc>
        public object Pop() {
            object context = null;
            
            if (contextStack != null && contextStack.Count > 0) {
                int idx = contextStack.Count - 1;
                context = contextStack[idx];
                contextStack.RemoveAt(idx);
            }
            
            return context;
        }
        
        /// <include file='doc\ContextStack.uex' path='docs/doc[@for="ContextStack.Push"]/*' />
        /// <devdoc>
        ///     Pushes the given object onto the stack.
        /// </devdoc>
        public void Push(object context) {
            if (context == null) {
                throw new ArgumentNullException("context");
            }
            
            if (contextStack == null) {
                contextStack = new ArrayList();
            }
            contextStack.Add(context);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\standardtoolwindows.cs ===
//------------------------------------------------------------------------------
// <copyright file="StandardToolWindows.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    
    /// <include file='doc\StandardToolWindows.uex' path='docs/doc[@for="StandardToolWindows"]/*' />
    /// <devdoc>
    ///    <para> Defines GUID specifiers that contain GUIDs which reference the standard set of tool windows that are available in
    ///       the design environment.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class StandardToolWindows {
        /// <include file='doc\StandardToolWindows.uex' path='docs/doc[@for="StandardToolWindows.ObjectBrowser"]/*' />
        /// <devdoc>
        ///    <para>Gets the GUID for the object browser.</para>
        /// </devdoc>
        public static readonly Guid ObjectBrowser   = new Guid("{970d9861-ee83-11d0-a778-00a0c91110c3}");
        /// <include file='doc\StandardToolWindows.uex' path='docs/doc[@for="StandardToolWindows.OutputWindow"]/*' />
        /// <devdoc>
        ///    <para>Gets the GUID for the output window.</para>
        /// </devdoc>
        public static readonly Guid OutputWindow    = new Guid("{34e76e81-ee4a-11d0-ae2e-00a0c90fffc3}");
        /// <include file='doc\StandardToolWindows.uex' path='docs/doc[@for="StandardToolWindows.ProjectExplorer"]/*' />
        /// <devdoc>
        ///    <para>Gets the GUID for the project explorer.</para>
        /// </devdoc>
        public static readonly Guid ProjectExplorer = new Guid("{3ae79031-e1bc-11d0-8f78-00a0c9110057}");
        /// <include file='doc\StandardToolWindows.uex' path='docs/doc[@for="StandardToolWindows.PropertyBrowser"]/*' />
        /// <devdoc>
        ///    <para>Gets the GUID for the properties window.</para>
        /// </devdoc>
        public static readonly Guid PropertyBrowser = new Guid("{eefa5220-e298-11d0-8f78-00a0c9110057}");
        /// <include file='doc\StandardToolWindows.uex' path='docs/doc[@for="StandardToolWindows.RelatedLinks"]/*' />
        /// <devdoc>
        ///    <para>Gets the GUID for the related links frame.</para>
        /// </devdoc>
        public static readonly Guid RelatedLinks    = new Guid("{66dba47c-61df-11d2-aa79-00c04f990343}");
        /// <include file='doc\StandardToolWindows.uex' path='docs/doc[@for="StandardToolWindows.ServerExplorer"]/*' />
        /// <devdoc>
        ///    <para>Gets the GUID for the server explorer.</para>
        /// </devdoc>
        public static readonly Guid ServerExplorer  = new Guid("{74946827-37a0-11d2-a273-00c04f8ef4ff}");
        /// <include file='doc\StandardToolWindows.uex' path='docs/doc[@for="StandardToolWindows.TaskList"]/*' />
        /// <devdoc>
        ///    <para>Gets the GUID for the task list.</para>
        /// </devdoc>
        public static readonly Guid TaskList        = new Guid("{4a9b7e51-aa16-11d0-a8c5-00a0c921a4d2}");
        /// <include file='doc\StandardToolWindows.uex' path='docs/doc[@for="StandardToolWindows.Toolbox"]/*' />
        /// <devdoc>
        ///    <para>Gets the GUID for the toolbox.</para>
        /// </devdoc>
        public static readonly Guid Toolbox         = new Guid("{b1e99781-ab81-11d0-b683-00aa00a3ee26}");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\viewtechnology.cs ===
//------------------------------------------------------------------------------
// <copyright file="ViewTechnology.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System;

    /// <include file='doc\ViewTechnology.uex' path='docs/doc[@for="ViewTechnology"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies a set of technologies designer hosts should support.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum ViewTechnology {
    
        /// <include file='doc\ViewTechnology.uex' path='docs/doc[@for="ViewTechnology.Passthrough"]/*' />
        /// <devdoc>
        ///     Specifies that the view for a root designer is defined by some
        ///     private interface contract between the designer and the
        ///     development environment.  This implies a tight coupling
        ///     between the development environment and the designer, and should
        ///     be avoided.  This does allow older COM2 technologies to
        ///     be shown in development environments that support
        ///     COM2 interface technologies such as doc objects and ActiveX
        ///     controls.
        /// </devdoc>
        Passthrough,
        
        /// <include file='doc\ViewTechnology.uex' path='docs/doc[@for="ViewTechnology.WindowsForms"]/*' />
        /// <devdoc>
        ///     Specifies that the view for a root designer is supplied through
        ///     a Windows Forms control object.  The designer host will fill the
        ///     development environment's document window with this control.
        /// </devdoc>
        WindowsForms
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\toolboxitemattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxItemAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    
    using System;
    using System.Diagnostics;
    using System.Globalization;
 
    /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies attributes for a toolbox item.
    ///    </para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class ToolboxItemAttribute : Attribute {

        private Type toolboxItemType;
        private string toolboxItemTypeName;

        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Initializes a new instance of ToolboxItemAttribute and sets the type to
        ///    IComponent.
        ///    </para>
        /// </devdoc>
        public static readonly ToolboxItemAttribute Default = new ToolboxItemAttribute("System.Drawing.Design.ToolboxItem, " + AssemblyRef.SystemDrawing);

        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of ToolboxItemAttribute and sets the type to
        ///    <see langword='null'/>.
        ///    </para>
        /// </devdoc>
        public static readonly ToolboxItemAttribute None = new ToolboxItemAttribute(false);

        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether the attribute is the default attribute.
        ///    </para>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return this.Equals(Default);
        }
        
        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.ToolboxItemAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of ToolboxItemAttribute and
        ///       specifies if default values should be used.
        ///    </para>
        /// </devdoc>
        public ToolboxItemAttribute(bool defaultType) {
            if (defaultType) {
                toolboxItemTypeName = "System.Drawing.Design.ToolboxItem, " + AssemblyRef.SystemDrawing;
            }
        }

        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.ToolboxItemAttribute1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of ToolboxItemAttribute and
        ///       specifies the name of the type.
        ///    </para>
        /// </devdoc>
        public ToolboxItemAttribute(string toolboxItemTypeName) {
            string temp = toolboxItemTypeName.ToUpper(CultureInfo.InvariantCulture);
            Debug.Assert(temp.IndexOf(".DLL") == -1, "Came across: " + toolboxItemTypeName + " . Please remove the .dll extension");
            this.toolboxItemTypeName = toolboxItemTypeName;
        }

        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.ToolboxItemAttribute2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of ToolboxItemAttribute and
        ///       specifies the type of the toolbox item.
        ///    </para>
        /// </devdoc>
        public ToolboxItemAttribute(Type toolboxItemType) {
            this.toolboxItemType = toolboxItemType;
            this.toolboxItemTypeName = toolboxItemType.AssemblyQualifiedName;
        }

        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.ToolboxItemType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the toolbox item's type.
        ///    </para>
        /// </devdoc>
        public Type ToolboxItemType {
            get{
                if (toolboxItemType == null) {
                    if (toolboxItemTypeName != null) {
                        try {
                            toolboxItemType = Type.GetType(toolboxItemTypeName, true);
                        }
                        catch (Exception ex) {
                            throw new ArgumentException("Failed to create ToolboxItem of type: " + toolboxItemTypeName, ex);
                        }
                    }
                }
                return toolboxItemType;
            }
        }

        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.ToolboxItemTypeName"]/*' />
        public string ToolboxItemTypeName {
            get {
                if (toolboxItemTypeName == null) {
                    return String.Empty;
                }
                return toolboxItemTypeName;
            }
        }

        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            ToolboxItemAttribute other = obj as ToolboxItemAttribute;
            return (other != null) && (other.ToolboxItemTypeName == ToolboxItemTypeName);
        }

        /// <include file='doc\ToolboxItemAttribute.uex' path='docs/doc[@for="ToolboxItemAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            if (toolboxItemTypeName != null) {
                return toolboxItemTypeName.GetHashCode();
            }
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\idesignerloaderhost.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerLoaderHost.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Collections;
    using System.ComponentModel.Design;

    /// <include file='doc\IDesignerLoaderHost.uex' path='docs/doc[@for="IDesignerLoaderHost"]/*' />
    /// <devdoc>
    ///     IDesignerLoaderHost.  This is an extension of IDesignerHost that is passed
    ///     to the designer loader in the BeginLoad method.  It is isolated from
    ///     IDesignerHost to emphasize that all loading and reloading of the design
    ///     document actually should be initiated by the designer loader, and not by
    ///     the designer host.  However, the loader must inform the designer host that
    ///     it wishes to invoke a load or reload.
    /// </devdoc>
    public interface IDesignerLoaderHost : IDesignerHost {
    
        /// <include file='doc\IDesignerLoaderHost.uex' path='docs/doc[@for="IDesignerLoaderHost.EndLoad"]/*' />
        /// <devdoc>
        ///     This is called by the designer loader to indicate that the load has 
        ///     terminated.  If there were errors, they should be passed in the errorCollection
        ///     as a collection of exceptions (if they are not exceptions the designer
        ///     loader host may just call ToString on them).  If the load was successful then
        ///     errorCollection should either be null or contain an empty collection.
        /// </devdoc>
        void EndLoad(string baseClassName, bool successful, ICollection errorCollection);
    
        /// <include file='doc\IDesignerLoaderHost.uex' path='docs/doc[@for="IDesignerLoaderHost.Reload"]/*' />
        /// <devdoc>
        ///     This is called by the designer loader when it wishes to reload the
        ///     design document.  The reload will happen immediately so the caller
        ///     should ensure that it is in a state where BeginLoad may be called again.
        /// </devdoc>
        void Reload();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\designerloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Reflection;

    /// <include file='doc\DesignerLoader.uex' path='docs/doc[@for="DesignerLoader"]/*' />
    /// <devdoc>
    ///     DesignerLoader.  This class is responsible for loading a designer document.  
    ///     Where and how this load occurs is a private matter for the designer loader.
    ///     The designer loader will be handed to an IDesignerHost instance.  This instance, 
    ///     when it is ready to load the document, will call BeginLoad, passing an instance
    ///     of IDesignerLoaderHost.  The designer loader will load up the design surface
    ///     using the host interface, and call EndLoad on the interface when it is done.
    ///     The error collection passed into EndLoad should be empty or null to indicate a
    ///     successful load, or it should contain a collection of exceptions that 
    ///     describe the error.
    ///
    ///     Once a document is loaded, the designer loader is also responsible for
    ///     writing any changes made to the document back whatever storage the
    ///     loader used when loading the document.  
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class DesignerLoader {

        /// <include file='doc\DesignerLoader.uex' path='docs/doc[@for="DesignerLoader.Loading"]/*' />
        /// <devdoc>
        ///     Returns true when the designer is in the process of loading.  Clients that are
        ///     sinking notifications from the designer often want to ignore them while the desingner is loading
        ///     and only respond to them if they result from user interatcions.
        /// </devdoc>
        public virtual bool Loading {
            get {
                return false;
            }
        }
    
        /// <include file='doc\DesignerLoader.uex' path='docs/doc[@for="DesignerLoader.BeginLoad"]/*' />
        /// <devdoc>
        ///     Called by the designer host to begin the loading process.  The designer
        ///     host passes in an instance of a designer loader host (which is typically
        ///     the same object as the designer host.  This loader host allows
        ///     the designer loader to reload the design document and also allows
        ///     the designer loader to indicate that it has finished loading the
        ///     design document.
        /// </devdoc>
        public abstract void BeginLoad(IDesignerLoaderHost host);
        
        /// <include file='doc\DesignerLoader.uex' path='docs/doc[@for="DesignerLoader.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes this designer loader.  The designer host will call this method
        ///     when the design document itself is being destroyed.  Once called, the
        ///     designer loader will never be called again.
        /// </devdoc>
        public abstract void Dispose();
        
        /// <include file='doc\DesignerLoader.uex' path='docs/doc[@for="DesignerLoader.Flush"]/*' />
        /// <devdoc>
        ///     The designer host will call this periodically when it wants to
        ///     ensure that any changes that have been made to the document
        ///     have been saved by the designer loader.  This method allows
        ///     designer loaders to implement a lazy-write scheme to improve
        ///     performance.  The default implementation does nothing.
        /// </devdoc>
        public virtual void Flush() {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\designerserializerattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerSerializerAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    /// <include file='doc\DesignerSerializerAttribute.uex' path='docs/doc[@for="DesignerSerializerAttribute"]/*' />
    /// <devdoc>
    ///     This attribute can be placed on a class to indicate what serialization
    ///     object should be used to serialize the class at design time.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple=true, Inherited=true)]
    public sealed class DesignerSerializerAttribute : Attribute {
        private string serializerTypeName;
        private string serializerBaseTypeName;
        private string typeId;
    
        /// <include file='doc\DesignerSerializerAttribute.uex' path='docs/doc[@for="DesignerSerializerAttribute.DesignerSerializerAttribute"]/*' />
        /// <devdoc>
        ///     Creates a new designer serialization attribute.
        /// </devdoc>
        public DesignerSerializerAttribute(Type serializerType, Type baseSerializerType) {
            this.serializerTypeName = serializerType.AssemblyQualifiedName;
            this.serializerBaseTypeName = baseSerializerType.AssemblyQualifiedName;
        }
    
        /// <include file='doc\DesignerSerializerAttribute.uex' path='docs/doc[@for="DesignerSerializerAttribute.DesignerSerializerAttribute1"]/*' />
        /// <devdoc>
        ///     Creates a new designer serialization attribute.
        /// </devdoc>
        public DesignerSerializerAttribute(string serializerTypeName, Type baseSerializerType) {
            this.serializerTypeName = serializerTypeName;
            this.serializerBaseTypeName = baseSerializerType.AssemblyQualifiedName;
        }
    
        /// <include file='doc\DesignerSerializerAttribute.uex' path='docs/doc[@for="DesignerSerializerAttribute.DesignerSerializerAttribute2"]/*' />
        /// <devdoc>
        ///     Creates a new designer serialization attribute.
        /// </devdoc>
        public DesignerSerializerAttribute(string serializerTypeName, string baseSerializerTypeName) {
            this.serializerTypeName = serializerTypeName;
            this.serializerBaseTypeName = baseSerializerTypeName;
        }
    
        /// <include file='doc\DesignerSerializerAttribute.uex' path='docs/doc[@for="DesignerSerializerAttribute.SerializerTypeName"]/*' />
        /// <devdoc>
        ///     Retrieves the fully qualified type name of the serializer.
        /// </devdoc>
        public string SerializerTypeName {
            get {
                return serializerTypeName;
            }
        }
    
        /// <include file='doc\DesignerSerializerAttribute.uex' path='docs/doc[@for="DesignerSerializerAttribute.SerializerBaseTypeName"]/*' />
        /// <devdoc>
        ///     Retrieves the fully qualified type name of the serializer base type.
        /// </devdoc>
        public string SerializerBaseTypeName {
            get {
                return serializerBaseTypeName;
            }
        }
        
        /// <include file='doc\DesignerSerializerAttribute.uex' path='docs/doc[@for="DesignerSerializerAttribute.TypeId"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       This defines a unique ID for this attribute type. It is used
        ///       by filtering algorithms to identify two attributes that are
        ///       the same type. For most attributes, this just returns the
        ///       Type instance for the attribute. EditorAttribute overrides
        ///       this to include the type of the editor base type.
        ///    </para>
        /// </devdoc>
        public override object TypeId {
            get {
                if (typeId == null) {
                    string baseType = serializerBaseTypeName;
                    int comma = baseType.IndexOf(',');
                    if (comma != -1) {
                        baseType = baseType.Substring(0, comma);
                    }
                    typeId = GetType().FullName + baseType;
                }
                return typeId;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\standardcommands.cs ===
//------------------------------------------------------------------------------
// <copyright file="StandardCommands.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Threading;
    using System.Runtime.Remoting;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands"]/*' />
    /// <devdoc>
    ///    <para>Specifies indentifiers for the standard set of commands that are available to
    ///       most applications.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class StandardCommands {

        // Note:
        //
        // This class contains command ID's and GUIDS that correspond to the 
        // Visual Studio Command Bar menu layout.  The data in this file is 
        // DEPENDENT upon constants in the following files:
        //
        //     %VSROOT%\src\common\inc\stdidcmd.h  - for standard shell defined icmds
        //     %VSROOT%\src\common\inc\vsshlids.h  - for standard shell defined guids
        //

        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.standardCommandSet"]/*' />
        /// <devdoc>
        ///     This guid corresponds to the standard set of commands for the shell and office.
        /// </devdoc>
        private static readonly Guid standardCommandSet = ShellGuids.VSStandardCommandSet97;

        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.wfcCommandSet"]/*' />
        /// <devdoc>
        ///     This guid corresponds to the Microsoft .NET Framework command set.  This is used for Verbs.  While these are not
        ///     "standard" to VS and Office, they are to the Microsoft .NET Framework.
        /// </devdoc>
        private static readonly Guid ndpCommandSet = new Guid("{74D21313-2AEE-11d1-8BFB-00A0C90F26F7}");

        private const int cmdidDesignerVerbFirst               = 0x2000;
        private const int cmdidDesignerVerbLast                = 0x2100;

        // Component Tray Menu commands...
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.cmdidArrangeIcons"]/*' />
        /// <devdoc>
        ///    <para>Gets the integer value of the arrange icons command. Read only.</para>
        /// </devdoc>
        private const int cmdidArrangeIcons                = 0x300a;
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.cmdidLineupIcons"]/*' />
        /// <devdoc>
        ///    <para>Gets the integer value of the line up icons command. Read only.</para>
        /// </devdoc>
        private const int cmdidLineupIcons                 = 0x300b;
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.cmdidShowLargeIcons"]/*' />
        /// <devdoc>
        ///    <para>Gets the integer value of the show large icons command. Read only.</para>
        /// </devdoc>
        private const int cmdidShowLargeIcons              = 0x300c;

        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.AlignBottom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the AlignBottom command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID AlignBottom               = new CommandID(standardCommandSet, VSStandardCommands.cmdidAlignBottom);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.AlignHorizontalCenters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the AlignHorizontalCenters command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID AlignHorizontalCenters    = new CommandID(standardCommandSet, VSStandardCommands.cmdidAlignHorizontalCenters);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.AlignLeft"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the AlignLeft command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID AlignLeft                 = new CommandID(standardCommandSet, VSStandardCommands.cmdidAlignLeft);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.AlignRight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the AlignRight command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID AlignRight                = new CommandID(standardCommandSet, VSStandardCommands.cmdidAlignRight);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.AlignToGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the AlignToGrid command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID AlignToGrid               = new CommandID(standardCommandSet, VSStandardCommands.cmdidAlignToGrid);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.AlignTop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the AlignTop command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID AlignTop                  = new CommandID(standardCommandSet, VSStandardCommands.cmdidAlignTop);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.AlignVerticalCenters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the AlignVerticalCenters command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID AlignVerticalCenters      = new CommandID(standardCommandSet, VSStandardCommands.cmdidAlignVerticalCenters);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.ArrangeBottom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the ArrangeBottom command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID ArrangeBottom             = new CommandID(standardCommandSet, VSStandardCommands.cmdidArrangeBottom);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.ArrangeRight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the ArrangeRight command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID ArrangeRight              = new CommandID(standardCommandSet, VSStandardCommands.cmdidArrangeRight);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.BringForward"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the BringForward command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID BringForward              = new CommandID(standardCommandSet, VSStandardCommands.cmdidBringForward);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.BringToFront"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the BringToFront command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID BringToFront              = new CommandID(standardCommandSet, VSStandardCommands.cmdidBringToFront);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.CenterHorizontally"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the CenterHorizontally command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID CenterHorizontally        = new CommandID(standardCommandSet, VSStandardCommands.cmdidCenterHorizontally);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.CenterVertically"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the CenterVertically command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID CenterVertically          = new CommandID(standardCommandSet, VSStandardCommands.cmdidCenterVertically);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Copy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Copy command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Copy                      = new CommandID(standardCommandSet, VSStandardCommands.cmdidCopy);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Cut"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Cut command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Cut                       = new CommandID(standardCommandSet, VSStandardCommands.cmdidCut);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Delete"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Delete command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Delete                    = new CommandID(standardCommandSet, VSStandardCommands.cmdidDelete);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Group"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Group command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Group                     = new CommandID(standardCommandSet, VSStandardCommands.cmdidGroup);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.HorizSpaceConcatenate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the HorizSpaceConcatenate command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID HorizSpaceConcatenate     = new CommandID(standardCommandSet, VSStandardCommands.cmdidHorizSpaceConcatenate);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.HorizSpaceDecrease"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the HorizSpaceDecrease command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID HorizSpaceDecrease        = new CommandID(standardCommandSet, VSStandardCommands.cmdidHorizSpaceDecrease);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.HorizSpaceIncrease"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the HorizSpaceIncrease command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID HorizSpaceIncrease        = new CommandID(standardCommandSet, VSStandardCommands.cmdidHorizSpaceIncrease);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.HorizSpaceMakeEqual"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the HorizSpaceMakeEqual command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID HorizSpaceMakeEqual       = new CommandID(standardCommandSet, VSStandardCommands.cmdidHorizSpaceMakeEqual);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Paste"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Paste command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Paste                     = new CommandID(standardCommandSet, VSStandardCommands.cmdidPaste);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Properties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Properties command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Properties                = new CommandID(standardCommandSet, VSStandardCommands.cmdidProperties);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Redo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Redo command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Redo                      = new CommandID(standardCommandSet, VSStandardCommands.cmdidRedo);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.MultiLevelRedo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the MultiLevelRedo command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID MultiLevelRedo            = new CommandID(standardCommandSet, VSStandardCommands.cmdidMultiLevelRedo);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.SelectAll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the SelectAll command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID SelectAll                 = new CommandID(standardCommandSet, VSStandardCommands.cmdidSelectAll);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.SendBackward"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the SendBackward command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID SendBackward              = new CommandID(standardCommandSet, VSStandardCommands.cmdidSendBackward);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.SendToBack"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the SendToBack command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID SendToBack                = new CommandID(standardCommandSet, VSStandardCommands.cmdidSendToBack);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.SizeToControl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the SizeToControl command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID SizeToControl             = new CommandID(standardCommandSet, VSStandardCommands.cmdidSizeToControl);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.SizeToControlHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the SizeToControlHeight command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID SizeToControlHeight       = new CommandID(standardCommandSet, VSStandardCommands.cmdidSizeToControlHeight);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.SizeToControlWidth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the SizeToControlWidth command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID SizeToControlWidth        = new CommandID(standardCommandSet, VSStandardCommands.cmdidSizeToControlWidth);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.SizeToFit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the SizeToFit command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID SizeToFit                 = new CommandID(standardCommandSet, VSStandardCommands.cmdidSizeToFit);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.SizeToGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the SizeToGrid command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID SizeToGrid                = new CommandID(standardCommandSet, VSStandardCommands.cmdidSizeToGrid);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.SnapToGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the SnapToGrid command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID SnapToGrid                = new CommandID(standardCommandSet, VSStandardCommands.cmdidSnapToGrid);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.TabOrder"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the TabOrder command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID TabOrder                  = new CommandID(standardCommandSet, VSStandardCommands.cmdidTabOrder);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Undo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Undo command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Undo                      = new CommandID(standardCommandSet, VSStandardCommands.cmdidUndo);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.MultiLevelUndo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the MultiLevelUndo command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID MultiLevelUndo            = new CommandID(standardCommandSet, VSStandardCommands.cmdidMultiLevelUndo);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Ungroup"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Ungroup command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Ungroup                   = new CommandID(standardCommandSet, VSStandardCommands.cmdidUngroup);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.VertSpaceConcatenate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the VertSpaceConcatenate command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID VertSpaceConcatenate      = new CommandID(standardCommandSet, VSStandardCommands.cmdidVertSpaceConcatenate);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.VertSpaceDecrease"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the VertSpaceDecrease command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID VertSpaceDecrease         = new CommandID(standardCommandSet, VSStandardCommands.cmdidVertSpaceDecrease);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.VertSpaceIncrease"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the VertSpaceIncrease command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID VertSpaceIncrease         = new CommandID(standardCommandSet, VSStandardCommands.cmdidVertSpaceIncrease);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.VertSpaceMakeEqual"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the VertSpaceMakeEqual command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID VertSpaceMakeEqual        = new CommandID(standardCommandSet, VSStandardCommands.cmdidVertSpaceMakeEqual);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.ShowGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the ShowGrid command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID ShowGrid                  = new CommandID(standardCommandSet, VSStandardCommands.cmdidShowGrid);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.ViewGrid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the ViewGrid command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID ViewGrid                  = new CommandID(standardCommandSet, VSStandardCommands.cmdidViewGrid);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.Replace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the Replace command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID Replace                   = new CommandID(standardCommandSet, VSStandardCommands.cmdidReplace);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.PropertiesWindow"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the PropertiesWindow command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID PropertiesWindow          = new CommandID(standardCommandSet, VSStandardCommands.cmdidPropertiesWindow);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.LockControls"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the LockControls command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID LockControls              = new CommandID(standardCommandSet, VSStandardCommands.cmdidLockControls);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.F1Help"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the F1Help command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID F1Help                    = new CommandID(standardCommandSet, VSStandardCommands.cmdidF1Help);

        // Component Tray Menu commands...
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.ArrangeIcons"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the ArrangeIcons command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID ArrangeIcons    = new CommandID(ndpCommandSet, cmdidArrangeIcons);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.LineupIcons"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the LineupIcons command. Read only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID LineupIcons     = new CommandID(ndpCommandSet, cmdidLineupIcons);
        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.ShowLargeIcons"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the GUID/integer value pair for the ShowLargeIcons command. Read
        ///       only.
        ///    </para>
        /// </devdoc>
        public static readonly CommandID ShowLargeIcons  = new CommandID(ndpCommandSet, cmdidShowLargeIcons);

        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.VerbFirst"]/*' />
        /// <devdoc>
        ///    <para> Gets the first of a set of verbs.
        ///       Read only.</para>
        /// </devdoc>
        public static readonly CommandID VerbFirst                 = new CommandID(ndpCommandSet, cmdidDesignerVerbFirst);

        /// <include file='doc\StandardCommands.uex' path='docs/doc[@for="StandardCommands.VerbLast"]/*' />
        /// <devdoc>
        ///    <para> Gets the last of a set of verbs.
        ///       Read only.</para>
        /// </devdoc>
        public static readonly CommandID VerbLast                  = new CommandID(ndpCommandSet, cmdidDesignerVerbLast);


        private class VSStandardCommands {
            public const int cmdidAlignBottom    = 1;
            public const int cmdidAlignHorizontalCenters    = 2;
            public const int cmdidAlignLeft    = 3;
            public const int cmdidAlignRight    = 4;
            public const int cmdidAlignToGrid    = 5;
            public const int cmdidAlignTop    = 6;
            public const int cmdidAlignVerticalCenters    = 7;
            public const int cmdidArrangeBottom    = 8;
            public const int cmdidArrangeRight    = 9;
            public const int cmdidBringForward    = 10;
            public const int cmdidBringToFront    = 11;
            public const int cmdidCenterHorizontally    = 12;
            public const int cmdidCenterVertically    = 13;
            public const int cmdidCode    = 14;
            public const int cmdidCopy    = 15;
            public const int cmdidCut    = 16;
            public const int cmdidDelete    = 17;
            public const int cmdidFontName    = 18;
            public const int cmdidFontSize    = 19;
            public const int cmdidGroup    = 20;
            public const int cmdidHorizSpaceConcatenate    = 21;
            public const int cmdidHorizSpaceDecrease    = 22;
            public const int cmdidHorizSpaceIncrease    = 23;
            public const int cmdidHorizSpaceMakeEqual    = 24;
            public const int cmdidLockControls    = 369;
            public const int cmdidInsertObject    = 25;
            public const int cmdidPaste    = 26;
            public const int cmdidPrint    = 27;
            public const int cmdidProperties    = 28;
            public const int cmdidRedo    = 29;
            public const int cmdidMultiLevelRedo    = 30;
            public const int cmdidSelectAll    = 31;
            public const int cmdidSendBackward    = 32;
            public const int cmdidSendToBack    = 33;
            public const int cmdidShowTable    = 34;
            public const int cmdidSizeToControl    = 35;
            public const int cmdidSizeToControlHeight    = 36;
            public const int cmdidSizeToControlWidth    = 37;
            public const int cmdidSizeToFit    = 38;
            public const int cmdidSizeToGrid    = 39;
            public const int cmdidSnapToGrid    = 40;
            public const int cmdidTabOrder    = 41;
            public const int cmdidToolbox    = 42;
            public const int cmdidUndo    = 43;
            public const int cmdidMultiLevelUndo    = 44;
            public const int cmdidUngroup    = 45;
            public const int cmdidVertSpaceConcatenate    = 46;
            public const int cmdidVertSpaceDecrease    = 47;
            public const int cmdidVertSpaceIncrease    = 48;
            public const int cmdidVertSpaceMakeEqual    = 49;
            public const int cmdidZoomPercent    = 50;
            public const int cmdidBackColor    = 51;
            public const int cmdidBold    = 52;
            public const int cmdidBorderColor    = 53;
            public const int cmdidBorderDashDot    = 54;
            public const int cmdidBorderDashDotDot    = 55;
            public const int cmdidBorderDashes    = 56;
            public const int cmdidBorderDots    = 57;
            public const int cmdidBorderShortDashes    = 58;
            public const int cmdidBorderSolid    = 59;
            public const int cmdidBorderSparseDots    = 60;
            public const int cmdidBorderWidth1    = 61;
            public const int cmdidBorderWidth2    = 62;
            public const int cmdidBorderWidth3    = 63;
            public const int cmdidBorderWidth4    = 64;
            public const int cmdidBorderWidth5    = 65;
            public const int cmdidBorderWidth6    = 66;
            public const int cmdidBorderWidthHairline    = 67;
            public const int cmdidFlat    = 68;
            public const int cmdidForeColor    = 69;
            public const int cmdidItalic    = 70;
            public const int cmdidJustifyCenter    = 71;
            public const int cmdidJustifyGeneral    = 72;
            public const int cmdidJustifyLeft    = 73;
            public const int cmdidJustifyRight    = 74;
            public const int cmdidRaised    = 75;
            public const int cmdidSunken    = 76;
            public const int cmdidUnderline    = 77;
            public const int cmdidChiseled    = 78;
            public const int cmdidEtched    = 79;
            public const int cmdidShadowed    = 80;
            public const int cmdidCompDebug1    = 81;
            public const int cmdidCompDebug2    = 82;
            public const int cmdidCompDebug3    = 83;
            public const int cmdidCompDebug4    = 84;
            public const int cmdidCompDebug5    = 85;
            public const int cmdidCompDebug6    = 86;
            public const int cmdidCompDebug7    = 87;
            public const int cmdidCompDebug8    = 88;
            public const int cmdidCompDebug9    = 89;
            public const int cmdidCompDebug10    = 90;
            public const int cmdidCompDebug11    = 91;
            public const int cmdidCompDebug12    = 92;
            public const int cmdidCompDebug13    = 93;
            public const int cmdidCompDebug14    = 94;
            public const int cmdidCompDebug15    = 95;
            public const int cmdidExistingSchemaEdit    = 96;
            public const int cmdidFind    = 97;
            public const int cmdidGetZoom    = 98;
            public const int cmdidQueryOpenDesign    = 99;
            public const int cmdidQueryOpenNew    = 100;
            public const int cmdidSingleTableDesign    = 101;
            public const int cmdidSingleTableNew    = 102;
            public const int cmdidShowGrid    = 103;
            public const int cmdidNewTable    = 104;
            public const int cmdidCollapsedView    = 105;
            public const int cmdidFieldView    = 106;
            public const int cmdidVerifySQL    = 107;
            public const int cmdidHideTable    = 108;

            public const int cmdidPrimaryKey    = 109;
            public const int cmdidSave    = 110;
            public const int cmdidSaveAs    = 111;
            public const int cmdidSortAscending    = 112;

            public const int cmdidSortDescending    = 113;
            public const int cmdidAppendQuery    = 114;
            public const int cmdidCrosstabQuery    = 115;
            public const int cmdidDeleteQuery    = 116;
            public const int cmdidMakeTableQuery    = 117;

            public const int cmdidSelectQuery    = 118;
            public const int cmdidUpdateQuery    = 119;
            public const int cmdidParameters    = 120;
            public const int cmdidTotals    = 121;
            public const int cmdidViewCollapsed    = 122;

            public const int cmdidViewFieldList    = 123;


            public const int cmdidViewKeys    = 124;
            public const int cmdidViewGrid    = 125;
            public const int cmdidInnerJoin    = 126;

            public const int cmdidRightOuterJoin    = 127;
            public const int cmdidLeftOuterJoin    = 128;
            public const int cmdidFullOuterJoin    = 129;
            public const int cmdidUnionJoin    = 130;
            public const int cmdidShowSQLPane    = 131;

            public const int cmdidShowGraphicalPane    = 132;
            public const int cmdidShowDataPane    = 133;
            public const int cmdidShowQBEPane    = 134;
            public const int cmdidSelectAllFields    = 135;

            public const int cmdidOLEObjectMenuButton    = 136;

            // ids on the ole verbs menu - these must be sequential ie verblist0-verblist9
            public const int cmdidObjectVerbList0    = 137;
            public const int cmdidObjectVerbList1    = 138;
            public const int cmdidObjectVerbList2    = 139;
            public const int cmdidObjectVerbList3    = 140;
            public const int cmdidObjectVerbList4    = 141;
            public const int cmdidObjectVerbList5    = 142;
            public const int cmdidObjectVerbList6    = 143;
            public const int cmdidObjectVerbList7    = 144;
            public const int cmdidObjectVerbList8    = 145;
            public const int cmdidObjectVerbList9    = 146;// Unused on purpose!

            public const int cmdidConvertObject    = 147;
            public const int cmdidCustomControl    = 148;
            public const int cmdidCustomizeItem    = 149;
            public const int cmdidRename    = 150;

            public const int cmdidImport    = 151;
            public const int cmdidNewPage    = 152;
            public const int cmdidMove    = 153;
            public const int cmdidCancel    = 154;

            public const int cmdidFont    = 155;

            public const int cmdidExpandLinks    = 156;
            public const int cmdidExpandImages    = 157;
            public const int cmdidExpandPages    = 158;
            public const int cmdidRefocusDiagram    = 159;
            public const int cmdidTransitiveClosure    = 160;
            public const int cmdidCenterDiagram    = 161;
            public const int cmdidZoomIn    = 162;
            public const int cmdidZoomOut    = 163;
            public const int cmdidRemoveFilter    = 164;
            public const int cmdidHidePane    = 165;
            public const int cmdidDeleteTable    = 166;
            public const int cmdidDeleteRelationship    = 167;
            public const int cmdidRemove    = 168;
            public const int cmdidJoinLeftAll    = 169;
            public const int cmdidJoinRightAll    = 170;
            public const int cmdidAddToOutput    = 171;// Add selected fields to query output
            public const int cmdidOtherQuery    = 172;// change query type to 'other'
            public const int cmdidGenerateChangeScript    = 173;
            public const int cmdidSaveSelection    = 174;// Save current selection
            public const int cmdidAutojoinCurrent    = 175;// Autojoin current tables
            public const int cmdidAutojoinAlways    = 176;// Toggle Autojoin state
            public const int cmdidEditPage    = 177;// Launch editor for url
            public const int cmdidViewLinks    = 178;// Launch new webscope for url
            public const int cmdidStop    = 179;// Stope webscope rendering
            public const int cmdidPause    = 180;// Pause webscope rendering
            public const int cmdidResume    = 181;// Resume webscope rendering
            public const int cmdidFilterDiagram    = 182;// Filter webscope diagram
            public const int cmdidShowAllObjects    = 183;// Show All objects in webscope diagram
            public const int cmdidShowApplications    = 184;// Show Application objects in webscope diagram
            public const int cmdidShowOtherObjects    = 185;// Show other objects in webscope diagram
            public const int cmdidShowPrimRelationships    = 186;// Show primary relationships
            public const int cmdidExpand    = 187;// Expand links
            public const int cmdidCollapse    = 188;// Collapse links
            public const int cmdidRefresh    = 189;// Refresh Webscope diagram
            public const int cmdidLayout    = 190;// Layout websope diagram
            public const int cmdidShowResources    = 191;// Show resouce objects in webscope diagram
            public const int cmdidInsertHTMLWizard    = 192;// Insert HTML using a Wizard
            public const int cmdidShowDownloads    = 193;// Show download objects in webscope diagram
            public const int cmdidShowExternals    = 194;// Show external objects in webscope diagram
            public const int cmdidShowInBoundLinks    = 195;// Show inbound links in webscope diagram
            public const int cmdidShowOutBoundLinks    = 196;// Show out bound links in webscope diagram
            public const int cmdidShowInAndOutBoundLinks    = 197;// Show in and out bound links in webscope diagram
            public const int cmdidPreview    = 198;// Preview page
            public const int cmdidOpen    = 261;// Open
            public const int cmdidOpenWith    = 199;// Open with
            public const int cmdidShowPages    = 200;// Show HTML pages
            public const int cmdidRunQuery    = 201;// Runs a query
            public const int cmdidClearQuery    = 202;// Clears the query's associated cursor
            public const int cmdidRecordFirst    = 203;// Go to first record in set
            public const int cmdidRecordLast    = 204;// Go to last record in set
            public const int cmdidRecordNext    = 205;// Go to next record in set
            public const int cmdidRecordPrevious    = 206;// Go to previous record in set
            public const int cmdidRecordGoto    = 207;// Go to record via dialog
            public const int cmdidRecordNew    = 208;// Add a record to set

            public const int cmdidInsertNewMenu    = 209;// menu designer
            public const int cmdidInsertSeparator    = 210;// menu designer
            public const int cmdidEditMenuNames    = 211;// menu designer

            public const int cmdidDebugExplorer    = 212;
            public const int cmdidDebugProcesses    = 213;
            public const int cmdidViewThreadsWindow    = 214;
            public const int cmdidWindowUIList    = 215;

            // ids on the file menu
            public const int cmdidNewProject    = 216;
            public const int cmdidOpenProject    = 217;
            public const int cmdidOpenSolution    = 218;
            public const int cmdidCloseSolution    = 219;
            public const int cmdidFileNew    = 221;
            public const int cmdidFileOpen    = 222;
            public const int cmdidFileClose    = 223;
            public const int cmdidSaveSolution    = 224;
            public const int cmdidSaveSolutionAs    = 225;
            public const int cmdidSaveProjectItemAs    = 226;
            public const int cmdidPageSetup    = 227;
            public const int cmdidPrintPreview    = 228;
            public const int cmdidExit    = 229;

            // ids on the edit menu
            public const int cmdidReplace    = 230;
            public const int cmdidGoto    = 231;

            // ids on the view menu
            public const int cmdidPropertyPages    = 232;
            public const int cmdidFullScreen    = 233;
            public const int cmdidProjectExplorer    = 234;
            public const int cmdidPropertiesWindow    = 235;
            public const int cmdidTaskListWindow    = 236;
            public const int cmdidOutputWindow    = 237;
            public const int cmdidObjectBrowser    = 238;
            public const int cmdidDocOutlineWindow    = 239;
            public const int cmdidImmediateWindow    = 240;
            public const int cmdidWatchWindow    = 241;
            public const int cmdidLocalsWindow    = 242;
            public const int cmdidCallStack    = 243;
            public const int cmdidAutosWindow   =   cmdidDebugReserved1;
            public const int cmdidThisWindow     =      cmdidDebugReserved2;

            // ids on project menu
            public const int cmdidAddNewItem    = 220;
            public const int cmdidAddExistingItem    = 244;
            public const int cmdidNewFolder    = 245;
            public const int cmdidSetStartupProject    = 246;
            public const int cmdidProjectSettings    = 247;
            public const int cmdidProjectReferences    = 367;

            // ids on the debug menu
            public const int cmdidStepInto    = 248;
            public const int cmdidStepOver    = 249;
            public const int cmdidStepOut    = 250;
            public const int cmdidRunToCursor    = 251;
            public const int cmdidAddWatch    = 252;
            public const int cmdidEditWatch    = 253;
            public const int cmdidQuickWatch    = 254;

            public const int cmdidToggleBreakpoint    = 255;
            public const int cmdidClearBreakpoints    = 256;
            public const int cmdidShowBreakpoints    = 257;
            public const int cmdidSetNextStatement    = 258;
            public const int cmdidShowNextStatement    = 259;
            public const int cmdidEditBreakpoint    = 260;
            public const int cmdidDetachDebugger    = 262;

            // ids on the tools menu
            public const int cmdidCustomizeKeyboard    = 263;
            public const int cmdidToolsOptions    = 264;

            // ids on the windows menu
            public const int cmdidNewWindow    = 265;
            public const int cmdidSplit    = 266;
            public const int cmdidCascade    = 267;
            public const int cmdidTileHorz    = 268;
            public const int cmdidTileVert    = 269;

            // ids on the help menu
            public const int cmdidTechSupport    = 270;

            // NOTE cmdidAbout and cmdidDebugOptions must be consecutive
            //      cmd after cmdidDebugOptions (ie 273) must not be used
            public const int cmdidAbout    = 271;
            public const int cmdidDebugOptions    = 272;

            // ids on the watch context menu
            // CollapseWatch appears as 'Collapse Parent', on any
            // non-top-level item
            public const int cmdidDeleteWatch    = 274;
            public const int cmdidCollapseWatch    = 275;

            // ids on the properties window context menu
            public const int cmdidPbrsToggleStatus    = 282;
            public const int cmdidPropbrsHide    = 283;

            // ids on the docking context menu
            public const int cmdidDockingView    = 284;
            public const int cmdidHideActivePane    = 285;
            // ids for window selection via keyboard
            //public const int cmdidPaneNextPane    = 316;(listed below in order)
            //public const int cmdidPanePrevPane    = 317;(listed below in order)
            public const int cmdidPaneNextTab    = 286;
            public const int cmdidPanePrevTab    = 287;
            public const int cmdidPaneCloseToolWindow    = 288;
            public const int cmdidPaneActivateDocWindow    = 289;
#if DCR27419
            public const int cmdidDockingViewMDI    = 290;
#endif
            public const int cmdidDockingViewFloater    = 291;
            public const int cmdidAutoHideWindow    = 292;
            public const int cmdidMoveToDropdownBar    = 293;
            public const int cmdidFindCmd    = 294;// internal Find commands
            public const int cmdidStart    = 295;
            public const int cmdidRestart    = 296;

            public const int cmdidAddinManager    = 297;

            public const int cmdidMultiLevelUndoList    = 298;
            public const int cmdidMultiLevelRedoList    = 299;

            public const int cmdidToolboxAddTab    = 300;
            public const int cmdidToolboxDeleteTab    = 301;
            public const int cmdidToolboxRenameTab    = 302;
            public const int cmdidToolboxTabMoveUp    = 303;
            public const int cmdidToolboxTabMoveDown    = 304;
            public const int cmdidToolboxRenameItem    = 305;
            public const int cmdidToolboxListView    = 306;
            //(below) cmdidSearchSetCombo    = 307;

            public const int cmdidWindowUIGetList    = 308;
            public const int cmdidInsertValuesQuery    = 309;

            public const int cmdidShowProperties    = 310;

            public const int cmdidThreadSuspend    = 311;
            public const int cmdidThreadResume    = 312;
            public const int cmdidThreadSetFocus    = 313;
            public const int cmdidDisplayRadix    = 314;

            public const int cmdidOpenProjectItem    = 315;

            public const int cmdidPaneNextPane    = 316;
            public const int cmdidPanePrevPane    = 317;

            public const int cmdidClearPane    = 318;
            public const int cmdidGotoErrorTag    = 319;

            public const int cmdidTaskListSortByCategory    = 320;
            public const int cmdidTaskListSortByFileLine    = 321;
            public const int cmdidTaskListSortByPriority    = 322;
            public const int cmdidTaskListSortByDefaultSort    = 323;

            public const int cmdidTaskListFilterByNothing    = 325;
            public const int cmdidTaskListFilterByCategoryCodeSense    = 326;
            public const int cmdidTaskListFilterByCategoryCompiler    = 327;
            public const int cmdidTaskListFilterByCategoryComment    = 328;

            public const int cmdidToolboxAddItem    = 329;
            public const int cmdidToolboxReset    = 330;

            public const int cmdidSaveProjectItem    = 331;
            public const int cmdidViewForm    = 332;
            public const int cmdidViewCode    = 333;
            public const int cmdidPreviewInBrowser    = 334;
            public const int cmdidBrowseWith    = 336;
            public const int cmdidSearchSetCombo    = 307;
            public const int cmdidSearchCombo    = 337;
            public const int cmdidEditLabel    = 338;

            public const int cmdidExceptions    = 339;
            public const int cmdidDefineViews    = 340;

            public const int cmdidToggleSelMode    = 341;
            public const int cmdidToggleInsMode    = 342;

            public const int cmdidLoadUnloadedProject    = 343;
            public const int cmdidUnloadLoadedProject    = 344;

            // ids on the treegrids (watch/local/threads/stack)
            public const int cmdidElasticColumn    = 345;
            public const int cmdidHideColumn    = 346;

            public const int cmdidTaskListPreviousView    = 347;
            public const int cmdidZoomDialog    = 348;

            // find/replace options
            public const int cmdidFindNew    = 349;
            public const int cmdidFindMatchCase    = 350;
            public const int cmdidFindWholeWord    = 351;
            public const int cmdidFindSimplePattern    = 276;
            public const int cmdidFindRegularExpression    = 352;
            public const int cmdidFindBackwards    = 353;
            public const int cmdidFindInSelection    = 354;
            public const int cmdidFindStop    = 355;
            public const int cmdidFindHelp    = 356;
            public const int cmdidFindInFiles    = 277;
            public const int cmdidReplaceInFiles    = 278;
            public const int cmdidNextLocation    = 279;// next item in task list, find in files results, etc.
            public const int cmdidPreviousLocation    = 280;// prev item "

            public const int cmdidTaskListNextError    = 357;
            public const int cmdidTaskListPrevError    = 358;
            public const int cmdidTaskListFilterByCategoryUser    = 359;
            public const int cmdidTaskListFilterByCategoryShortcut    = 360;
            public const int cmdidTaskListFilterByCategoryHTML    = 361;
            public const int cmdidTaskListFilterByCurrentFile    = 362;
            public const int cmdidTaskListFilterByChecked    = 363;
            public const int cmdidTaskListFilterByUnchecked    = 364;
            public const int cmdidTaskListSortByDescription    = 365;
            public const int cmdidTaskListSortByChecked    = 366;

            //    = 367;is used above in cmdidProjectReferences
            public const int cmdidStartNoDebug    = 368;
            //    = 369;is used above in cmdidLockControls

            public const int cmdidFindNext    = 370;
            public const int cmdidFindPrev    = 371;
            public const int cmdidFindSelectedNext    = 372;
            public const int cmdidFindSelectedPrev    = 373;
            public const int cmdidSearchGetList    = 374;
            public const int cmdidInsertBreakpoint    = 375;
            public const int cmdidEnableBreakpoint    = 376;
            public const int cmdidF1Help    = 377;

            public const int cmdidPropSheetOrProperties    = 397;

            // NOTE - the next items are debug only !!
            public const int cmdidTshellStep    = 398;
            public const int cmdidTshellRun    = 399;

            // marker commands on the codewin menu
            public const int cmdidMarkerCmd0    = 400;
            public const int cmdidMarkerCmd1    = 401;
            public const int cmdidMarkerCmd2    = 402;
            public const int cmdidMarkerCmd3    = 403;
            public const int cmdidMarkerCmd4    = 404;
            public const int cmdidMarkerCmd5    = 405;
            public const int cmdidMarkerCmd6    = 406;
            public const int cmdidMarkerCmd7    = 407;
            public const int cmdidMarkerCmd8    = 408;
            public const int cmdidMarkerCmd9    = 409;
            public const int cmdidMarkerLast    = 409;
            public const int cmdidMarkerEnd    = 410;// list terminator reserved

            // user-invoked project reload and unload
            public const int cmdidReloadProject    = 412;
            public const int cmdidUnloadProject    = 413;

            // document outline commands
            public const int cmdidDetachAttachOutline    = 420;
            public const int cmdidShowHideOutline    = 421;
            public const int cmdidSyncOutline    = 422;

            public const int cmdidRunToCallstCursor    = 423;
            public const int cmdidNoCmdsAvailable    = 424;

            public const int cmdidContextWindow    = 427;
            public const int cmdidAlias    = 428;
            public const int cmdidGotoCommandLine    = 429;
            public const int cmdidEvaluateExpression    = 430;
            public const int cmdidImmediateMode    = 431;
            public const int cmdidEvaluateStatement    = 432;

            public const int cmdidFindResultWindow1    = 433;
            public const int cmdidFindResultWindow2    = 434;

            // ids on the window menu - these must be sequential ie window1-morewind
            public const int cmdidWindow1    = 570;
            public const int cmdidWindow2    = 571;
            public const int cmdidWindow3    = 572;
            public const int cmdidWindow4    = 573;
            public const int cmdidWindow5    = 574;
            public const int cmdidWindow6    = 575;
            public const int cmdidWindow7    = 576;
            public const int cmdidWindow8    = 577;
            public const int cmdidWindow9    = 578;
            public const int cmdidWindow10    = 579;
            public const int cmdidWindow11    = 580;
            public const int cmdidWindow12    = 581;
            public const int cmdidWindow13    = 582;
            public const int cmdidWindow14    = 583;
            public const int cmdidWindow15    = 584;
            public const int cmdidWindow16    = 585;
            public const int cmdidWindow17    = 586;
            public const int cmdidWindow18    = 587;
            public const int cmdidWindow19    = 588;
            public const int cmdidWindow20    = 589;
            public const int cmdidWindow21    = 590;
            public const int cmdidWindow22    = 591;
            public const int cmdidWindow23    = 592;
            public const int cmdidWindow24    = 593;
            public const int cmdidWindow25    = 594;// note cmdidWindow25 is unused on purpose!
            public const int cmdidMoreWindows    = 595;

            //public const int    = 597;//UNUSED
            public const int cmdidTaskListTaskHelp    = 598;

            public const int cmdidClassView    = 599;

            public const int cmdidMRUProj1    = 600;
            public const int cmdidMRUProj2    = 601;
            public const int cmdidMRUProj3    = 602;
            public const int cmdidMRUProj4    = 603;
            public const int cmdidMRUProj5    = 604;
            public const int cmdidMRUProj6    = 605;
            public const int cmdidMRUProj7    = 606;
            public const int cmdidMRUProj8    = 607;
            public const int cmdidMRUProj9    = 608;
            public const int cmdidMRUProj10    = 609;
            public const int cmdidMRUProj11    = 610;
            public const int cmdidMRUProj12    = 611;
            public const int cmdidMRUProj13    = 612;
            public const int cmdidMRUProj14    = 613;
            public const int cmdidMRUProj15    = 614;
            public const int cmdidMRUProj16    = 615;
            public const int cmdidMRUProj17    = 616;
            public const int cmdidMRUProj18    = 617;
            public const int cmdidMRUProj19    = 618;
            public const int cmdidMRUProj20    = 619;
            public const int cmdidMRUProj21    = 620;
            public const int cmdidMRUProj22    = 621;
            public const int cmdidMRUProj23    = 622;
            public const int cmdidMRUProj24    = 623;
            public const int cmdidMRUProj25    = 624;// note cmdidMRUProj25 is unused on purpose!

            public const int cmdidSplitNext    = 625;
            public const int cmdidSplitPrev    = 626;

            public const int cmdidCloseAllDocuments    = 627;
            public const int cmdidNextDocument    = 628;
            public const int cmdidPrevDocument    = 629;

            public const int cmdidTool1    = 630;// note cmdidTool1 - cmdidTool24 must be
            public const int cmdidTool2    = 631;// consecutive
            public const int cmdidTool3    = 632;
            public const int cmdidTool4    = 633;
            public const int cmdidTool5    = 634;
            public const int cmdidTool6    = 635;
            public const int cmdidTool7    = 636;
            public const int cmdidTool8    = 637;
            public const int cmdidTool9    = 638;
            public const int cmdidTool10    = 639;
            public const int cmdidTool11    = 640;
            public const int cmdidTool12    = 641;
            public const int cmdidTool13    = 642;
            public const int cmdidTool14    = 643;
            public const int cmdidTool15    = 644;
            public const int cmdidTool16    = 645;
            public const int cmdidTool17    = 646;
            public const int cmdidTool18    = 647;
            public const int cmdidTool19    = 648;
            public const int cmdidTool20    = 649;
            public const int cmdidTool21    = 650;
            public const int cmdidTool22    = 651;
            public const int cmdidTool23    = 652;
            public const int cmdidTool24    = 653;
            public const int cmdidExternalCommands    = 654;

            public const int cmdidPasteNextTBXCBItem    = 655;
            public const int cmdidToolboxShowAllTabs    = 656;
            public const int cmdidProjectDependencies    = 657;
            public const int cmdidCloseDocument    = 658;
            public const int cmdidToolboxSortItems    = 659;

            public const int cmdidViewBarView1    = 660;//UNUSED
            public const int cmdidViewBarView2    = 661;//UNUSED
            public const int cmdidViewBarView3    = 662;//UNUSED
            public const int cmdidViewBarView4    = 663;//UNUSED
            public const int cmdidViewBarView5    = 664;//UNUSED
            public const int cmdidViewBarView6    = 665;//UNUSED
            public const int cmdidViewBarView7    = 666;//UNUSED
            public const int cmdidViewBarView8    = 667;//UNUSED
            public const int cmdidViewBarView9    = 668;//UNUSED
            public const int cmdidViewBarView10    = 669;//UNUSED
            public const int cmdidViewBarView11    = 670;//UNUSED
            public const int cmdidViewBarView12    = 671;//UNUSED
            public const int cmdidViewBarView13    = 672;//UNUSED
            public const int cmdidViewBarView14    = 673;//UNUSED
            public const int cmdidViewBarView15    = 674;//UNUSED
            public const int cmdidViewBarView16    = 675;//UNUSED
            public const int cmdidViewBarView17    = 676;//UNUSED
            public const int cmdidViewBarView18    = 677;//UNUSED
            public const int cmdidViewBarView19    = 678;//UNUSED
            public const int cmdidViewBarView20    = 679;//UNUSED
            public const int cmdidViewBarView21    = 680;//UNUSED
            public const int cmdidViewBarView22    = 681;//UNUSED
            public const int cmdidViewBarView23    = 682;//UNUSED
            public const int cmdidViewBarView24    = 683;//UNUSED

            public const int cmdidSolutionCfg    = 684;
            public const int cmdidSolutionCfgGetList    = 685;

            //
            // Schema table commands:
            // All invoke table property dialog and select appropriate page.
            //
            public const int cmdidManageIndexes    = 675;
            public const int cmdidManageRelationships    = 676;
            public const int cmdidManageConstraints    = 677;

            public const int cmdidTaskListCustomView1    = 678;
            public const int cmdidTaskListCustomView2    = 679;
            public const int cmdidTaskListCustomView3    = 680;
            public const int cmdidTaskListCustomView4    = 681;
            public const int cmdidTaskListCustomView5    = 682;
            public const int cmdidTaskListCustomView6    = 683;
            public const int cmdidTaskListCustomView7    = 684;
            public const int cmdidTaskListCustomView8    = 685;
            public const int cmdidTaskListCustomView9    = 686;
            public const int cmdidTaskListCustomView10    = 687;
            public const int cmdidTaskListCustomView11    = 688;
            public const int cmdidTaskListCustomView12    = 689;
            public const int cmdidTaskListCustomView13    = 690;
            public const int cmdidTaskListCustomView14    = 691;
            public const int cmdidTaskListCustomView15    = 692;
            public const int cmdidTaskListCustomView16    = 693;
            public const int cmdidTaskListCustomView17    = 694;
            public const int cmdidTaskListCustomView18    = 695;
            public const int cmdidTaskListCustomView19    = 696;
            public const int cmdidTaskListCustomView20    = 697;
            public const int cmdidTaskListCustomView21    = 698;
            public const int cmdidTaskListCustomView22    = 699;
            public const int cmdidTaskListCustomView23    = 700;
            public const int cmdidTaskListCustomView24    = 701;
            public const int cmdidTaskListCustomView25    = 702;
            public const int cmdidTaskListCustomView26    = 703;
            public const int cmdidTaskListCustomView27    = 704;
            public const int cmdidTaskListCustomView28    = 705;
            public const int cmdidTaskListCustomView29    = 706;
            public const int cmdidTaskListCustomView30    = 707;
            public const int cmdidTaskListCustomView31    = 708;
            public const int cmdidTaskListCustomView32    = 709;
            public const int cmdidTaskListCustomView33    = 710;
            public const int cmdidTaskListCustomView34    = 711;
            public const int cmdidTaskListCustomView35    = 712;
            public const int cmdidTaskListCustomView36    = 713;
            public const int cmdidTaskListCustomView37    = 714;
            public const int cmdidTaskListCustomView38    = 715;
            public const int cmdidTaskListCustomView39    = 716;
            public const int cmdidTaskListCustomView40    = 717;
            public const int cmdidTaskListCustomView41    = 718;
            public const int cmdidTaskListCustomView42    = 719;
            public const int cmdidTaskListCustomView43    = 720;
            public const int cmdidTaskListCustomView44    = 721;
            public const int cmdidTaskListCustomView45    = 722;
            public const int cmdidTaskListCustomView46    = 723;
            public const int cmdidTaskListCustomView47    = 724;
            public const int cmdidTaskListCustomView48    = 725;
            public const int cmdidTaskListCustomView49    = 726;
            public const int cmdidTaskListCustomView50    = 727;//not used on purpose, ends the list

            public const int cmdidObjectSearch    = 728;

            public const int cmdidCommandWindow    = 729;
            public const int cmdidCommandWindowMarkMode    = 730;
            public const int cmdidLogCommandWindow    = 731;

            public const int cmdidShell    = 732;

            public const int cmdidSingleChar    = 733;
            public const int cmdidZeroOrMore    = 734;
            public const int cmdidOneOrMore    = 735;
            public const int cmdidBeginLine    = 736;
            public const int cmdidEndLine    = 737;
            public const int cmdidBeginWord    = 738;
            public const int cmdidEndWord    = 739;
            public const int cmdidCharInSet    = 740;
            public const int cmdidCharNotInSet    = 741;
            public const int cmdidOr    = 742;
            public const int cmdidEscape    = 743;
            public const int cmdidTagExp    = 744;

            // Regex builder context help menu commands
            public const int cmdidPatternMatchHelp    = 745;
            public const int cmdidRegExList    = 746;

            public const int cmdidDebugReserved1    = 747;
            public const int cmdidDebugReserved2    = 748;
            public const int cmdidDebugReserved3    = 749;
            //USED ABOVE    = 750;
            //USED ABOVE    = 751;
            //USED ABOVE    = 752;
            //USED ABOVE    = 753;

            //Regex builder wildcard menu commands
            public const int cmdidWildZeroOrMore    = 754;
            public const int cmdidWildSingleChar    = 755;
            public const int cmdidWildSingleDigit    = 756;
            public const int cmdidWildCharInSet    = 757;
            public const int cmdidWildCharNotInSet    = 758;

            public const int cmdidFindWhatText    = 759;
            public const int cmdidTaggedExp1    = 760;
            public const int cmdidTaggedExp2    = 761;
            public const int cmdidTaggedExp3    = 762;
            public const int cmdidTaggedExp4    = 763;
            public const int cmdidTaggedExp5    = 764;
            public const int cmdidTaggedExp6    = 765;
            public const int cmdidTaggedExp7    = 766;
            public const int cmdidTaggedExp8    = 767;
            public const int cmdidTaggedExp9    = 768;

            public const int cmdidEditorWidgetClick    = 769;// param    = 0;is the moniker as VT_BSTR, param    = 1;is the buffer line as VT_I4, and param    = 2;is the buffer index as VT_I4
            public const int cmdidCmdWinUpdateAC    = 770;

            public const int cmdidSlnCfgMgr    = 771;

            public const int cmdidAddNewProject    = 772;
            public const int cmdidAddExistingProject    = 773;
            public const int cmdidAddNewSolutionItem    = 774;
            public const int cmdidAddExistingSolutionItem    = 775;

            public const int cmdidAutoHideContext1    = 776;
            public const int cmdidAutoHideContext2    = 777;
            public const int cmdidAutoHideContext3    = 778;
            public const int cmdidAutoHideContext4    = 779;
            public const int cmdidAutoHideContext5    = 780;
            public const int cmdidAutoHideContext6    = 781;
            public const int cmdidAutoHideContext7    = 782;
            public const int cmdidAutoHideContext8    = 783;
            public const int cmdidAutoHideContext9    = 784;
            public const int cmdidAutoHideContext10    = 785;
            public const int cmdidAutoHideContext11    = 786;
            public const int cmdidAutoHideContext12    = 787;
            public const int cmdidAutoHideContext13    = 788;
            public const int cmdidAutoHideContext14    = 789;
            public const int cmdidAutoHideContext15    = 790;
            public const int cmdidAutoHideContext16    = 791;
            public const int cmdidAutoHideContext17    = 792;
            public const int cmdidAutoHideContext18    = 793;
            public const int cmdidAutoHideContext19    = 794;
            public const int cmdidAutoHideContext20    = 795;
            public const int cmdidAutoHideContext21    = 796;
            public const int cmdidAutoHideContext22    = 797;
            public const int cmdidAutoHideContext23    = 798;
            public const int cmdidAutoHideContext24    = 799;
            public const int cmdidAutoHideContext25    = 800;
            public const int cmdidAutoHideContext26    = 801;
            public const int cmdidAutoHideContext27    = 802;
            public const int cmdidAutoHideContext28    = 803;
            public const int cmdidAutoHideContext29    = 804;
            public const int cmdidAutoHideContext30    = 805;
            public const int cmdidAutoHideContext31    = 806;
            public const int cmdidAutoHideContext32    = 807;
            public const int cmdidAutoHideContext33    = 808;// must remain unused

            public const int cmdidShellNavBackward    = 809;
            public const int cmdidShellNavForward    = 810;

            public const int cmdidShellNavigate1    = 811;
            public const int cmdidShellNavigate2    = 812;
            public const int cmdidShellNavigate3    = 813;
            public const int cmdidShellNavigate4    = 814;
            public const int cmdidShellNavigate5    = 815;
            public const int cmdidShellNavigate6    = 816;
            public const int cmdidShellNavigate7    = 817;
            public const int cmdidShellNavigate8    = 818;
            public const int cmdidShellNavigate9    = 819;
            public const int cmdidShellNavigate10    = 820;
            public const int cmdidShellNavigate11    = 821;
            public const int cmdidShellNavigate12    = 822;
            public const int cmdidShellNavigate13    = 823;
            public const int cmdidShellNavigate14    = 824;
            public const int cmdidShellNavigate15    = 825;
            public const int cmdidShellNavigate16    = 826;
            public const int cmdidShellNavigate17    = 827;
            public const int cmdidShellNavigate18    = 828;
            public const int cmdidShellNavigate19    = 829;
            public const int cmdidShellNavigate20    = 830;
            public const int cmdidShellNavigate21    = 831;
            public const int cmdidShellNavigate22    = 832;
            public const int cmdidShellNavigate23    = 833;
            public const int cmdidShellNavigate24    = 834;
            public const int cmdidShellNavigate25    = 835;
            public const int cmdidShellNavigate26    = 836;
            public const int cmdidShellNavigate27    = 837;
            public const int cmdidShellNavigate28    = 838;
            public const int cmdidShellNavigate29    = 839;
            public const int cmdidShellNavigate30    = 840;
            public const int cmdidShellNavigate31    = 841;
            public const int cmdidShellNavigate32    = 842;
            public const int cmdidShellNavigate33    = 843;// must remain unused

            public const int cmdidShellWindowNavigate1    = 844;
            public const int cmdidShellWindowNavigate2    = 845;
            public const int cmdidShellWindowNavigate3    = 846;
            public const int cmdidShellWindowNavigate4    = 847;
            public const int cmdidShellWindowNavigate5    = 848;
            public const int cmdidShellWindowNavigate6    = 849;
            public const int cmdidShellWindowNavigate7    = 850;
            public const int cmdidShellWindowNavigate8    = 851;
            public const int cmdidShellWindowNavigate9    = 852;
            public const int cmdidShellWindowNavigate10    = 853;
            public const int cmdidShellWindowNavigate11    = 854;
            public const int cmdidShellWindowNavigate12    = 855;
            public const int cmdidShellWindowNavigate13    = 856;
            public const int cmdidShellWindowNavigate14    = 857;
            public const int cmdidShellWindowNavigate15    = 858;
            public const int cmdidShellWindowNavigate16    = 859;
            public const int cmdidShellWindowNavigate17    = 860;
            public const int cmdidShellWindowNavigate18    = 861;
            public const int cmdidShellWindowNavigate19    = 862;
            public const int cmdidShellWindowNavigate20    = 863;
            public const int cmdidShellWindowNavigate21    = 864;
            public const int cmdidShellWindowNavigate22    = 865;
            public const int cmdidShellWindowNavigate23    = 866;
            public const int cmdidShellWindowNavigate24    = 867;
            public const int cmdidShellWindowNavigate25    = 868;
            public const int cmdidShellWindowNavigate26    = 869;
            public const int cmdidShellWindowNavigate27    = 870;
            public const int cmdidShellWindowNavigate28    = 871;
            public const int cmdidShellWindowNavigate29    = 872;
            public const int cmdidShellWindowNavigate30    = 873;
            public const int cmdidShellWindowNavigate31    = 874;
            public const int cmdidShellWindowNavigate32    = 875;
            public const int cmdidShellWindowNavigate33    = 876;// must remain unused

            // ObjectSearch cmds
            public const int cmdidOBSDoFind    = 877;
            public const int cmdidOBSMatchCase    = 878;
            public const int cmdidOBSMatchSubString    = 879;
            public const int cmdidOBSMatchWholeWord    = 880;
            public const int cmdidOBSMatchPrefix    = 881;

            // build cmds
            public const int cmdidBuildSln    = 882;
            public const int cmdidRebuildSln    = 883;
            public const int cmdidDeploySln    = 884;
            public const int cmdidCleanSln    = 885;

            public const int cmdidBuildSel    = 886;
            public const int cmdidRebuildSel    = 887;
            public const int cmdidDeploySel    = 888;
            public const int cmdidCleanSel    = 889;

            public const int cmdidCancelBuild    = 890;
            public const int cmdidBatchBuildDlg    = 891;

            public const int cmdidBuildCtx    = 892;
            public const int cmdidRebuildCtx    = 893;
            public const int cmdidDeployCtx    = 894;
            public const int cmdidCleanCtx    = 895;

            // cmdid range 896-899 empty

            public const int cmdidMRUFile1    = 900;
            public const int cmdidMRUFile2    = 901;
            public const int cmdidMRUFile3    = 902;
            public const int cmdidMRUFile4    = 903;
            public const int cmdidMRUFile5    = 904;
            public const int cmdidMRUFile6    = 905;
            public const int cmdidMRUFile7    = 906;
            public const int cmdidMRUFile8    = 907;
            public const int cmdidMRUFile9    = 908;
            public const int cmdidMRUFile10    = 909;
            public const int cmdidMRUFile11    = 910;
            public const int cmdidMRUFile12    = 911;
            public const int cmdidMRUFile13    = 912;
            public const int cmdidMRUFile14    = 913;
            public const int cmdidMRUFile15    = 914;
            public const int cmdidMRUFile16    = 915;
            public const int cmdidMRUFile17    = 916;
            public const int cmdidMRUFile18    = 917;
            public const int cmdidMRUFile19    = 918;
            public const int cmdidMRUFile20    = 919;
            public const int cmdidMRUFile21    = 920;
            public const int cmdidMRUFile22    = 921;
            public const int cmdidMRUFile23    = 922;
            public const int cmdidMRUFile24    = 923;
            public const int cmdidMRUFile25    = 924;// note cmdidMRUFile25 is unused on purpose!

            // Object Browsing & ClassView cmds
            // Shared shell cmds (for accessing Object Browsing functionality)
            public const int cmdidGotoDefn    = 925;
            public const int cmdidGotoDecl    = 926;
            public const int cmdidBrowseDefn    = 927;
            public const int cmdidShowMembers    = 928;
            public const int cmdidShowBases    = 929;
            public const int cmdidShowDerived    = 930;
            public const int cmdidShowDefns    = 931;
            public const int cmdidShowRefs    = 932;
            public const int cmdidShowCallers    = 933;
            public const int cmdidShowCallees    = 934;
            public const int cmdidDefineSubset    = 935;
            public const int cmdidSetSubset    = 936;

            // ClassView Tool Specific cmds
            public const int cmdidCVGroupingNone    = 950;
            public const int cmdidCVGroupingSortOnly    = 951;
            public const int cmdidCVGroupingGrouped    = 952;
            public const int cmdidCVShowPackages    = 953;
            public const int cmdidQryManageIndexes    = 954;
            public const int cmdidBrowseComponent    = 955;
            public const int cmdidPrintDefault    = 956;// quick print

            public const int cmdidBrowseDoc    = 957;

            public const int cmdidStandardMax    = 1000;

            ///////////////////////////////////////////
            // DON'T go beyond the cmdidStandardMax
            // if you are adding shell commands.
            //
            // If you are not adding shell commands,
            // you shouldn't be doing it in this file! 
            //
            ///////////////////////////////////////////


            public const int cmdidFormsFirst    = 0x00006000;

            public const int cmdidFormsLast         =  0x00006FFF;

            public const int cmdidVBEFirst    = 0x00008000;

            public const int msotcidBookmarkWellMenu    = 0x00008001;

            public const int cmdidZoom200    = 0x00008002;
            public const int cmdidZoom150    = 0x00008003;
            public const int cmdidZoom100    = 0x00008004;
            public const int cmdidZoom75    = 0x00008005;
            public const int cmdidZoom50    = 0x00008006;
            public const int cmdidZoom25    = 0x00008007;
            public const int cmdidZoom10    = 0x00008010;

            public const int msotcidZoomWellMenu    = 0x00008011;
            public const int msotcidDebugPopWellMenu    = 0x00008012;
            public const int msotcidAlignWellMenu    = 0x00008013;
            public const int msotcidArrangeWellMenu    = 0x00008014;
            public const int msotcidCenterWellMenu    = 0x00008015;
            public const int msotcidSizeWellMenu    = 0x00008016;
            public const int msotcidHorizontalSpaceWellMenu    = 0x00008017;
            public const int msotcidVerticalSpaceWellMenu    = 0x00008020;

            public const int msotcidDebugWellMenu    = 0x00008021;
            public const int msotcidDebugMenuVB    = 0x00008022;

            public const int msotcidStatementBuilderWellMenu    = 0x00008023;
            public const int msotcidProjWinInsertMenu    = 0x00008024;
            public const int msotcidToggleMenu    = 0x00008025;
            public const int msotcidNewObjInsertWellMenu    = 0x00008026;
            public const int msotcidSizeToWellMenu    = 0x00008027;
            public const int msotcidCommandBars    = 0x00008028;
            public const int msotcidVBOrderMenu    = 0x00008029;
            public const int msotcidMSOnTheWeb      =0x0000802A;
            public const int msotcidVBDesignerMenu    = 0x00008030;
            public const int msotcidNewProjectWellMenu    = 0x00008031;
            public const int msotcidProjectWellMenu    = 0x00008032;

            public const int msotcidVBCode1ContextMenu    = 0x00008033;
            public const int msotcidVBCode2ContextMenu    = 0x00008034;
            public const int msotcidVBWatchContextMenu    = 0x00008035;
            public const int msotcidVBImmediateContextMenu    = 0x00008036;
            public const int msotcidVBLocalsContextMenu    = 0x00008037;
            public const int msotcidVBFormContextMenu    = 0x00008038;
            public const int msotcidVBControlContextMenu    = 0x00008039;
            public const int msotcidVBProjWinContextMenu      =0x0000803A;
            public const int msotcidVBProjWinContextBreakMenu = 0x0000803B;
            public const int msotcidVBPreviewWinContextMenu   =0x0000803C  ;
            public const int msotcidVBOBContextMenu      = 0x0000803D ;
            public const int msotcidVBForms3ContextMenu  = 0x0000803E ;
            public const int msotcidVBForms3ControlCMenu  =    0x0000803F;
            public const int msotcidVBForms3ControlCMenuGroup    = 0x00008040;
            public const int msotcidVBForms3ControlPalette    = 0x00008041;
            public const int msotcidVBForms3ToolboxCMenu    = 0x00008042;
            public const int msotcidVBForms3MPCCMenu    = 0x00008043;
            public const int msotcidVBForms3DragDropCMenu    = 0x00008044;
            public const int msotcidVBToolBoxContextMenu    = 0x00008045;
            public const int msotcidVBToolBoxGroupContextMenu    = 0x00008046;
            public const int msotcidVBPropBrsHostContextMenu    = 0x00008047;
            public const int msotcidVBPropBrsContextMenu    = 0x00008048;
            public const int msotcidVBPalContextMenu    = 0x00008049;
            public const int msotcidVBProjWinProjectContextMenu  =0x0000804A    ;
            public const int msotcidVBProjWinFormContextMenu     =   0x0000804B;
            public const int msotcidVBProjWinModClassContextMenu =0x0000804C ;
            public const int msotcidVBProjWinRelDocContextMenu  = 0x0000804D;
            public const int msotcidVBDockedWindowContextMenu   = 0x0000804E;

            public const int msotcidVBShortCutForms       =0x0000804F;
            public const int msotcidVBShortCutCodeWindows    = 0x00008050;
            public const int msotcidVBShortCutMisc    = 0x00008051;
            public const int msotcidVBBuiltInMenus    = 0x00008052;
            public const int msotcidPreviewWinFormPos    = 0x00008053;

            public const int msotcidVBAddinFirst    = 0x00008200;

        }

        private class ShellGuids {
            public static readonly Guid VSStandardCommandSet97 = new Guid("{5efc7975-14bc-11cf-9b2b-00aa00573819}");
            public static readonly Guid guidDsdCmdId = new Guid("{1F0FD094-8e53-11d2-8f9c-0060089fc486}");
            public static readonly Guid SID_SOleComponentUIManager = new Guid("{5efc7974-14bc-11cf-9b2b-00aa00573819}");
            public static readonly Guid GUID_VSTASKCATEGORY_DATADESIGNER = new Guid("{6B32EAED-13BB-11d3-A64F-00C04F683820}");
            public static readonly Guid GUID_PropertyBrowserToolWindow = new Guid(unchecked((int)0xeefa5220), unchecked((short)0xe298), unchecked((short)0x11d0), new byte[]{ 0x8f, 0x78, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x57});
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\idesignerloaderservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerLoaderService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System.Collections;

    /// <include file='doc\IDesignerLoaderService.uex' path='docs/doc[@for="IDesignerLoaderService"]/*' />
    /// <devdoc>
    ///     This interface may be optionally implemented by the designer loader to provide
    ///     load services to outside components.  It provides support for asynchronous loading
    ///     of the designer and allows other objects to initiate a reload of othe
    ///     design surface.  Designer loaders do not need to implement this but it is 
    ///     recommended.  We do not directly put this on DesignerLoader so we can prevent
    ///     outside objects from interacting with the main methods of a designer loader.
    ///     These should only be called by the designer host.
    /// </devdoc>
    public interface IDesignerLoaderService {
    
        /// <include file='doc\IDesignerLoaderService.uex' path='docs/doc[@for="IDesignerLoaderService.AddLoadDependency"]/*' />
        /// <devdoc>
        ///     Adds a load dependency to this loader.  This indicates that some other
        ///     object is also participating in the load, and that the designer loader
        ///     should not call EndLoad on the loader host until all load dependencies
        ///     have called DependentLoadComplete on the designer loader.
        /// </devdoc>
        void AddLoadDependency();
    
        /// <include file='doc\IDesignerLoaderService.uex' path='docs/doc[@for="IDesignerLoaderService.DependentLoadComplete"]/*' />
        /// <devdoc>
        ///     This is called by any object that has previously called
        ///     AddLoadDependency to signal that the dependent load has completed.
        ///     The caller should pass either an empty collection or null to indicate
        ///     a successful load, or a collection of exceptions that indicate the
        ///     reason(s) for failure.
        /// </devdoc>
        void DependentLoadComplete(bool successful, ICollection errorCollection);
    
        /// <include file='doc\IDesignerLoaderService.uex' path='docs/doc[@for="IDesignerLoaderService.Reload"]/*' />
        /// <devdoc>
        ///     This can be called by an outside object to request that the loader
        ///     reload the design document.  If it supports reloading and wants to
        ///     comply with the reload, the designer loader should return true.  Otherwise
        ///     it should return false, indicating that the reload will not occur.
        ///     Callers should not rely on the reload happening immediately; the
        ///     designer loader may schedule this for some other time, or it may
        ///     try to reload at once.
        /// </devdoc>
        bool Reload();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\inamecreationservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="INameCreationService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Collections;
    using System.ComponentModel.Design;

    /// <include file='doc\INameCreationService.uex' path='docs/doc[@for="INameCreationService"]/*' />
    /// <devdoc>
    ///     This service may be provided by a designer loader to provide
    ///     a way for the designer to fabricate new names for objects.
    ///     If this service isn't available the designer will choose a 
    ///     default implementation.
    /// </devdoc>
    public interface INameCreationService {
    
        /// <include file='doc\INameCreationService.uex' path='docs/doc[@for="INameCreationService.CreateName"]/*' />
        /// <devdoc>
        ///     Creates a new name that is unique to all the components
        ///     in the given container.  The name will be used to create
        ///     an object of the given data type, so the service may
        ///     derive a name from the data type's name.  The container
        ///     parameter can be null if no container search is needed.
        /// </devdoc>
        string CreateName(IContainer container, Type dataType);
        
        /// <include file='doc\INameCreationService.uex' path='docs/doc[@for="INameCreationService.IsValidName"]/*' />
        /// <devdoc>
        ///     Determines if the given name is valid.  A name 
        ///     creation service may have rules defining a valid
        ///     name, and this method allows the sevice to enforce
        ///     those rules.
        /// </devdoc>
        bool IsValidName(string name);
    
        /// <include file='doc\INameCreationService.uex' path='docs/doc[@for="INameCreationService.ValidateName"]/*' />
        /// <devdoc>
        ///     Determines if the given name is valid.  A name 
        ///     creation service may have rules defining a valid
        ///     name, and this method allows the sevice to enforce
        ///     those rules.  It is similar to IsValidName, except
        ///     that this method will throw an exception if the
        ///     name is invalid.  This allows implementors to provide
        ///     rich information in the exception message.
        /// </devdoc>
        void ValidateName(string name);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\idesignerserializationprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerSerializationProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System;

    /// <include file='doc\IDesignerSerializationProvider.uex' path='docs/doc[@for="IDesignerSerializationProvider"]/*' />
    /// <devdoc>
    ///     This interface defines a custom serialization provider.  This
    ///     allows outside objects to control serialization by providing
    ///     their own serializer objects.
    /// </devdoc>
    public interface IDesignerSerializationProvider {
    
        /// <include file='doc\IDesignerSerializationProvider.uex' path='docs/doc[@for="IDesignerSerializationProvider.GetSerializer"]/*' />
        /// <devdoc>
        ///     This will be called by the serialization manager when it 
        ///     is trying to locate a serialzer for an object type.
        ///     If this serialization provider can provide a serializer
        ///     that is of the correct type, it should return it.
        ///     Otherwise, it should return null.
        ///
        ///     In order to break order dependencies between multiple
        ///     serialization providers the serialization manager will
        ///     loop through all serilaization provideres until the 
        ///     serilaizer returned reaches steady state.  Because
        ///     of this you should always check currentSerializer
        ///     before returning a new serializer.  If currentSerializer
        ///     is an instance of your serializer, then you should
        ///     either return it or return null to prevent an infinite
        ///     loop.
        /// </devdoc>
        object GetSerializer(IDesignerSerializationManager manager, object currentSerializer, Type objectType, Type serializerType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\idesignerserializationmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerSerializationManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager"]/*' />
    /// <devdoc>
    ///     This interface is passed to a designer serializer to provide
    ///     assistance in the serialization process.
    /// </devdoc>
    public interface IDesignerSerializationManager : IServiceProvider {
    
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.Context"]/*' />
        /// <devdoc>
        ///     The Context property provides a user-defined storage area
        ///     implemented as a stack.  This storage area is a useful way
        ///     to provide communication across serializers, as serialization
        ///     is a generally hierarchial process.
        /// </devdoc>
        ContextStack Context {get;}
        
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.Properties"]/*' />
        /// <devdoc>
        ///     The Properties property provides a set of custom properties
        ///     the serialization manager may surface.  The set of properties
        ///     exposed here is defined by the implementor of 
        ///     IDesignerSerializationManager.  
        /// </devdoc>
        PropertyDescriptorCollection Properties {get;}
        
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.ResolveName"]/*' />
        /// <devdoc>
        ///     ResolveName event.  This event
        ///     is raised when GetName is called, but the name is not found
        ///     in the serialization manager's name table.  It provides a 
        ///     way for a serializer to demand-create an object so the serializer
        ///     does not have to order object creation by dependency.  This
        ///     delegate is cleared immediately after serialization or deserialization
        ///     is complete.
        /// </devdoc>
        event ResolveNameEventHandler ResolveName;
    
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.SerializationComplete"]/*' />
        /// <devdoc>
        ///     This event is raised when serialization or deserialization
        ///     has been completed.  Generally, serialization code should
        ///     be written to be stateless.  Should some sort of state
        ///     be necessary to maintain, a serializer can listen to
        ///     this event to know when that state should be cleared.
        ///     An example of this is if a serializer needs to write
        ///     to another file, such as a resource file.  In this case
        ///     it would be inefficient to design the serializer
        ///     to close the file when finished because serialization of
        ///     an object graph generally requires several serializers.
        ///     The resource file would be opened and closed many times.
        ///     Instead, the resource file could be accessed through
        ///     an object that listened to the SerializationComplete
        ///     event, and that object could close the resource file
        ///     at the end of serialization.
        /// </devdoc>
        event EventHandler SerializationComplete;
    
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.AddSerializationProvider"]/*' />
        /// <devdoc>
        ///     This method adds a custom serialization provider to the 
        ///     serialization manager.  A custom serialization provider will
        ///     get the opportunity to return a serializer for a data type
        ///     before the serialization manager looks in the type's
        ///     metadata.  
        /// </devdoc>
        void AddSerializationProvider(IDesignerSerializationProvider provider);
        
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.CreateInstance"]/*' />
        /// <devdoc>                
        ///     Creates an instance of the given type and adds it to a collection
        ///     of named instances.  Objects that implement IComponent will be
        ///     added to the design time container if addToContainer is true.
        /// </devdoc>
        object CreateInstance(Type type, ICollection arguments, string name, bool addToContainer);
    
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.GetInstance"]/*' />
        /// <devdoc>
        ///     Retrieves an instance of a created object of the given name, or
        ///     null if that object does not exist.
        /// </devdoc>
        object GetInstance(string name);
    
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.GetName"]/*' />
        /// <devdoc>
        ///     Retrieves a name for the specified object, or null if the object
        ///     has no name.
        /// </devdoc>
        string GetName(object value);
    
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.GetSerializer"]/*' />
        /// <devdoc>
        ///     Retrieves a serializer of the requested type for the given
        ///     object type.
        /// </devdoc>
        object GetSerializer(Type objectType, Type serializerType);
    
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.GetType"]/*' />
        /// <devdoc>
        ///     Retrieves a type of the given name.
        /// </devdoc>
        Type GetType(string typeName);
    
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.RemoveSerializationProvider"]/*' />
        /// <devdoc>
        ///     Removes a previously added serialization provider.
        /// </devdoc>
        void RemoveSerializationProvider(IDesignerSerializationProvider provider);
        
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.ReportError"]/*' />
        /// <devdoc>
        ///     Reports a non-fatal error in serialization.  The serialization
        ///     manager may implement a logging scheme to alert the caller
        ///     to all non-fatal errors at once.  If it doesn't, it should
        ///     immediately throw in this method, which should abort
        ///     serialization.  
        ///     Serialization may continue after calling this function.
        /// </devdoc>
        void ReportError(object errorInformation);
        
        /// <include file='doc\IDesignerSerializationManager.uex' path='docs/doc[@for="IDesignerSerializationManager.SetName"]/*' />
        /// <devdoc>
        ///     Provides a way to set the name of an existing object.
        ///     This is useful when it is necessary to create an 
        ///     instance of an object without going through CreateInstance.
        ///     An exception will be thrown if you try to rename an existing
        ///     object or if you try to give a new object a name that
        ///     is already taken.
        /// </devdoc>
        void SetName(object instance, string name);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\resolvenameeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResolveNameEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System;

    /// <include file='doc\ResolveNameEventArgs.uex' path='docs/doc[@for="ResolveNameEventArgs"]/*' />
    /// <devdoc>
    ///     EventArgs for the ResolveNameEventHandler.  This event is used
    ///     by the serialization process to match a name to an object
    ///     instance.
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ResolveNameEventArgs : EventArgs {
        private string name;
        private object value;
        
        /// <include file='doc\ResolveNameEventArgs.uex' path='docs/doc[@for="ResolveNameEventArgs.ResolveNameEventArgs"]/*' />
        /// <devdoc>
        ///     Creates a new resolve name event args object.
        /// </devdoc>
        public ResolveNameEventArgs(string name) {
            this.name = name;
            this.value = null;
        }
    
        /// <include file='doc\ResolveNameEventArgs.uex' path='docs/doc[@for="ResolveNameEventArgs.Name"]/*' />
        /// <devdoc>
        ///     The name of the object that needs to be resolved.
        /// </devdoc>
        public string Name {
            get {
                return name;
            }
        }
        
        /// <include file='doc\ResolveNameEventArgs.uex' path='docs/doc[@for="ResolveNameEventArgs.Value"]/*' />
        /// <devdoc>
        ///     The object that matches the name.
        /// </devdoc>
        public object Value {
            get {
                return value;
            }
            set {
                this.value = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\instancedescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstanceDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Reflection;

    /// <include file='doc\InstanceDescriptor.uex' path='docs/doc[@for="InstanceDescriptor"]/*' />
    /// <devdoc>
    ///     EventArgs for the ResolveNameEventHandler.  This event is used
    ///     by the serialization process to match a name to an object
    ///     instance.
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public sealed class InstanceDescriptor {
        private MemberInfo  member;
        private ICollection arguments;
        private bool isComplete;
        
        /// <include file='doc\InstanceDescriptor.uex' path='docs/doc[@for="InstanceDescriptor.InstanceDescriptor"]/*' />
        /// <devdoc>
        ///     Creates a new InstanceDescriptor.
        /// </devdoc>
        public InstanceDescriptor(MemberInfo member, ICollection arguments) : this(member, arguments, true) {
        }
        
        /// <include file='doc\InstanceDescriptor.uex' path='docs/doc[@for="InstanceDescriptor.InstanceDescriptor1"]/*' />
        /// <devdoc>
        ///     Creates a new InstanceDescriptor.
        /// </devdoc>
        public InstanceDescriptor(MemberInfo member, ICollection arguments, bool isComplete) {
            this.member = member;
            this.isComplete = isComplete;
            
            if (arguments == null) {
                this.arguments = new object[0];
            }
            else {
                object[] args = new object[arguments.Count];
                arguments.CopyTo(args, 0);
                this.arguments = args;
            }
            
            if (member is FieldInfo) {
                FieldInfo fi = (FieldInfo)member;
                if (!fi.IsStatic) {
                    throw new ArgumentException("member");
                }
                if (this.arguments.Count != 0) {
                    throw new ArgumentException("arguments");
                }
            }
            else if (member is ConstructorInfo) {
                ConstructorInfo ci = (ConstructorInfo)member;
                if (ci.IsStatic) {
                    throw new ArgumentException("member");
                }
                if (this.arguments.Count != ci.GetParameters().Length) {
                    throw new ArgumentException("arguments");
                }
            }
            else if (member is MethodInfo) {
                MethodInfo mi = (MethodInfo)member;
                if (!mi.IsStatic) {
                    throw new ArgumentException("member");
                }
                if (this.arguments.Count != mi.GetParameters().Length) {
                    throw new ArgumentException("arguments");
                }
            }
            else if (member is PropertyInfo) {
                PropertyInfo pi = (PropertyInfo)member;
                if (!pi.CanRead) {
                    throw new ArgumentException("member");
                }
                MethodInfo mi = pi.GetGetMethod();
                if (mi != null && !mi.IsStatic) {
                    throw new ArgumentException("arguments");
                }
            }
        }
    
        /// <include file='doc\InstanceDescriptor.uex' path='docs/doc[@for="InstanceDescriptor.Arguments"]/*' />
        /// <devdoc>
        ///     The collection of arguments that should be passed to
        ///     MemberInfo in order to create an instance.
        /// </devdoc>
        public ICollection Arguments {
            get {
                return arguments;
            }
        }
        
        /// <include file='doc\InstanceDescriptor.uex' path='docs/doc[@for="InstanceDescriptor.IsComplete"]/*' />
        /// <devdoc>
        ///     Determines if the contents of this instance descriptor completely identify the instance.
        ///     This will normally be the case, but some objects may be too complex for a single method
        ///     or constructor to represent.  IsComplete can be used to identify these objects and take
        ///     additional steps to further describe their state.
        /// </devdoc>
        public bool IsComplete {
            get {
                return isComplete;
            }
        }
        
        /// <include file='doc\InstanceDescriptor.uex' path='docs/doc[@for="InstanceDescriptor.MemberInfo"]/*' />
        /// <devdoc>
        ///     The MemberInfo object that was passed into the constructor
        ///     of this InstanceDescriptor.
        /// </devdoc>
        public MemberInfo MemberInfo {
            get {
                return member;
            }
        }
        
        /// <include file='doc\InstanceDescriptor.uex' path='docs/doc[@for="InstanceDescriptor.Invoke"]/*' />
        /// <devdoc>
        ///     Invokes this instance descriptor, returning the object
        ///     the descriptor describes.
        /// </devdoc>
        public object Invoke() {
            object[] translatedArguments = new object[arguments.Count];
            arguments.CopyTo(translatedArguments, 0);
            
            // Instance descriptors can contain other instance
            // descriptors.  Translate them if necessary.
            //
            for(int i = 0; i < translatedArguments.Length; i++) {
                if (translatedArguments[i] is InstanceDescriptor) {
                    translatedArguments[i] = ((InstanceDescriptor)translatedArguments[i]).Invoke();
                }
            }
            
            if (member is ConstructorInfo) {
                return ((ConstructorInfo)member).Invoke(translatedArguments);
            }
            else if (member is MethodInfo) {
                return ((MethodInfo)member).Invoke(null, translatedArguments);
            }
            else if (member is PropertyInfo) {
                return ((PropertyInfo)member).GetValue(null, translatedArguments);
            }
            else if (member is FieldInfo) {
                return ((FieldInfo)member).GetValue(null);
            }
            else {
                Debug.Fail("Unrecognized reflection type in instance descriptor: " + member.GetType().Name);
            }
            
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\idesignerserializationservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDesignerSerializationService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\IDesignerSerializationService.uex' path='docs/doc[@for="IDesignerSerializationService"]/*' />
    /// <devdoc>
    ///     This service provides a way to exchange a collection of objects
    ///     for a serializable object that represents them.  The returned
    ///     object contains live references to objects in the collection.
    ///     This returned object can then be passed to any runtime
    ///     serialization mechanism.  The object itself serializes
    ///     components the same way designers write source for them; by picking
    ///     them apart property by property.  Many objects do not support
    ///     runtime serialization because their internal state cannot be
    ///     adequately duplicated.  All components that support a designer,
    ///     however, must support serialization by walking their public
    ///     properties, methods and events.  This interface uses this
    ///     technique to convert a collection of components into a single
    ///     opaque object that does support runtime serialization.
    /// </devdoc>
    public interface IDesignerSerializationService {
    
        /// <include file='doc\IDesignerSerializationService.uex' path='docs/doc[@for="IDesignerSerializationService.Deserialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///     Deserializes the provided serialization data object and
        ///     returns a collection of objects contained within that
        ///     data.
        ///    </para>
        /// </devdoc>
        ICollection Deserialize(object serializationData);
        
        /// <include file='doc\IDesignerSerializationService.uex' path='docs/doc[@for="IDesignerSerializationService.Serialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///     Serializes the given collection of objects and 
        ///     stores them in an opaque serialization data object.
        ///     The returning object fully supports runtime serialization.
        ///    </para>
        /// </devdoc>
        object Serialize(ICollection objects);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\rootdesignerserializerattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RootDesignerSerializerAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    /// <include file='doc\RootDesignerSerializerAttribute.uex' path='docs/doc[@for="RootDesignerSerializerAttribute"]/*' />
    /// <devdoc>
    ///     This attribute can be placed on a class to indicate what serialization
    ///     object should be used to serialize the class at design time if it is
    ///     being used as a root object.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple=true, Inherited=true)]
    public sealed class RootDesignerSerializerAttribute : Attribute {
        private bool reloadable;
        private string serializerTypeName;
        private string serializerBaseTypeName;
        private string typeId;
    
        /// <include file='doc\RootDesignerSerializerAttribute.uex' path='docs/doc[@for="RootDesignerSerializerAttribute.RootDesignerSerializerAttribute"]/*' />
        /// <devdoc>
        ///     Creates a new designer serialization attribute.
        /// </devdoc>
        public RootDesignerSerializerAttribute(Type serializerType, Type baseSerializerType, bool reloadable) {
            this.serializerTypeName = serializerType.AssemblyQualifiedName;
            this.serializerBaseTypeName = baseSerializerType.AssemblyQualifiedName;
            this.reloadable = reloadable;
        }
    
        /// <include file='doc\RootDesignerSerializerAttribute.uex' path='docs/doc[@for="RootDesignerSerializerAttribute.RootDesignerSerializerAttribute1"]/*' />
        /// <devdoc>
        ///     Creates a new designer serialization attribute.
        /// </devdoc>
        public RootDesignerSerializerAttribute(string serializerTypeName, Type baseSerializerType, bool reloadable) {
            this.serializerTypeName = serializerTypeName;
            this.serializerBaseTypeName = baseSerializerType.AssemblyQualifiedName;
            this.reloadable = reloadable;
        }
        
        /// <include file='doc\RootDesignerSerializerAttribute.uex' path='docs/doc[@for="RootDesignerSerializerAttribute.RootDesignerSerializerAttribute2"]/*' />
        /// <devdoc>
        ///     Creates a new designer serialization attribute.
        /// </devdoc>
        public RootDesignerSerializerAttribute(string serializerTypeName, string baseSerializerTypeName, bool reloadable) {
            this.serializerTypeName = serializerTypeName;
            this.serializerBaseTypeName = baseSerializerTypeName;
            this.reloadable = reloadable;
        }
        
        /// <include file='doc\RootDesignerSerializerAttribute.uex' path='docs/doc[@for="RootDesignerSerializerAttribute.Reloadable"]/*' />
        /// <devdoc>
        ///     Indicates that this root serializer supports reloading.  If false, the design document
        ///     will not automatically perform a reload on behalf of the user.  It will be the user's
        ///     responsibility to reload the document themselves.
        /// </devdoc>
        public bool Reloadable {
            get {
                return reloadable;
            }
        }
    
        /// <include file='doc\RootDesignerSerializerAttribute.uex' path='docs/doc[@for="RootDesignerSerializerAttribute.SerializerTypeName"]/*' />
        /// <devdoc>
        ///     Retrieves the fully qualified type name of the serializer.
        /// </devdoc>
        public string SerializerTypeName {
            get {
                return serializerTypeName;
            }
        }
    
        /// <include file='doc\RootDesignerSerializerAttribute.uex' path='docs/doc[@for="RootDesignerSerializerAttribute.SerializerBaseTypeName"]/*' />
        /// <devdoc>
        ///     Retrieves the fully qualified type name of the serializer base type.
        /// </devdoc>
        public string SerializerBaseTypeName {
            get {
                return serializerBaseTypeName;
            }
        }
        
        /// <include file='doc\RootDesignerSerializerAttribute.uex' path='docs/doc[@for="RootDesignerSerializerAttribute.TypeId"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       This defines a unique ID for this attribute type. It is used
        ///       by filtering algorithms to identify two attributes that are
        ///       the same type. For most attributes, this just returns the
        ///       Type instance for the attribute. EditorAttribute overrides
        ///       this to include the type of the editor base type.
        ///    </para>
        /// </devdoc>
        public override object TypeId {
            get {
                if (typeId == null) {
                    string baseType = serializerBaseTypeName;
                    int comma = baseType.IndexOf(',');
                    if (comma != -1) {
                        baseType = baseType.Substring(0, comma);
                    }
                    typeId = GetType().FullName + baseType;
                }
                return typeId;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\assertwrapper.cs ===
//------------------------------------------------------------------------------
// <copyright file="assertwrapper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   assertwrapper.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using System.Security.Permissions;
using System.Security;

namespace System.Diagnostics {
    internal class AssertWrapper {

#if DEBUG
        static BooleanSwitch DisableVsAssert = new BooleanSwitch("DisableVsAssert", "Switch to disable usage of VSASSERT for DefaultTraceListener.");
        static bool vsassertPresent = true;
        static bool vsassertDisabled;

        private static void ShowVsAssert(string stackTrace, StackFrame frame, string message, string detailMessage) {
            int[] disable = new int[1];
            try {
                string detailMessage2;
                
                if (detailMessage == null)
                    detailMessage2 = stackTrace; 
                else
                    detailMessage2 = detailMessage + "\r\n" + stackTrace;                
                string fileName = (frame == null) ? string.Empty : frame.GetFileName();
                int lineNumber = (frame == null) ? 0 : frame.GetFileLineNumber();
                int returnCode = VsAssert(detailMessage2, message, fileName, lineNumber, disable);
                if (returnCode != 0) {
                    if (!System.Diagnostics.Debugger.IsAttached) {
                        bool succeeded = System.Diagnostics.Debugger.Launch();
                        if (!succeeded)
                            DebuggerLaunchFailedMessageBox();
                    }
                    System.Diagnostics.Debugger.Break();
                }
                vsassertDisabled = (disable[0] != 0);
            }
            catch (Exception) {
                vsassertPresent = false;
            }
        }

        [DllImport(ExternDll.Vsassert, CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern int VsAssert(string message, string assert, string file, int line, [In, Out]int[] pfDisable);

        public static void ShowAssert(string stackTrace, StackFrame frame, string message, string detailMessage) {
            if (vsassertPresent && !vsassertDisabled && !DisableVsAssert.Enabled)
                ShowVsAssert(stackTrace, frame, message, detailMessage);

            // the following is not in an 'else' because vsassertPresent might
            // have gone from true to false.

            if (!vsassertPresent || vsassertDisabled || DisableVsAssert.Enabled)
                ShowMessageBoxAssert(stackTrace, message, detailMessage);            
                      
        }

#else
        
        public static void ShowAssert(string stackTrace, StackFrame frame, string message, string detailMessage) {
            ShowMessageBoxAssert(stackTrace, message, detailMessage);                                  
        }

#endif // DEBUG

        private static void DebuggerLaunchFailedMessageBox() {
            //Nothing needs to be done here because the debugger already 
            //brings up a dialog.
            /*
            int flags = 0x00000000 | 0x00000010; // OK | IconHand
            NativeMethods.MessageBox(0, SR.GetString(SR.DebugLaunchFailedSR.), GetString("DebugLaunchFailedTitle"), flags);        
            */
            
            return;
        }

        private static void ShowMessageBoxAssert(string stackTrace, string message, string detailMessage) {
            string fullMessage = message + "\r\n" + detailMessage + "\r\n" + stackTrace;
            fullMessage = TruncateMessageToFitScreen(fullMessage);

            //Consider, V2: using MB_SERVICE_NOTIFICATION for services.
            int flags = 0x00000002 /*AbortRetryIgnore*/ | 0x00000200 /*DefaultButton3*/ | 0x00000010 /*IconHand*/;
            int rval = SafeNativeMethods.MessageBox(NativeMethods.NullHandleRef, fullMessage, SR.GetString(SR.DebugAssertTitle), flags);
            switch (rval) {
                case 3: // abort
                    new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
                    try {
                        Environment.Exit(1);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();    
                    }
                    break;
                case 4: // retry
                    if (!System.Diagnostics.Debugger.IsAttached) {
                        bool succeeded = System.Diagnostics.Debugger.Launch();
                        if (!succeeded)
                            DebuggerLaunchFailedMessageBox();
                    }
                    System.Diagnostics.Debugger.Break();
                    break;
            }
        }



        // Since MessageBox will grow taller than the screen if there are too many lines do
        // a rough calculation to make it fit.  
        private static string TruncateMessageToFitScreen(string message) {            
            const int MaxCharsPerLine = 80;

            IntPtr hFont = SafeNativeMethods.GetStockObject(NativeMethods.DEFAULT_GUI_FONT);
            IntPtr hdc = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
            NativeMethods.TEXTMETRIC tm = new NativeMethods.TEXTMETRIC();
            hFont = UnsafeNativeMethods.SelectObject(new HandleRef(null, hdc), new HandleRef(null, hFont));
            SafeNativeMethods.GetTextMetrics(new HandleRef(null, hdc), tm);
            UnsafeNativeMethods.SelectObject(new HandleRef(null, hdc), new HandleRef(null, hFont));
            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, hdc));
            hdc = IntPtr.Zero;
            int cy = UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYSCREEN);
            int maxLines = cy / tm.tmHeight - 15;
    
            int lineCount = 0;
            int lineCharCount = 0;
            int i = 0;
            while (lineCount < maxLines && i < message.Length - 1) { 
                char ch = message[i];
                lineCharCount++;
                if (ch == '\n' || ch == '\r' || lineCharCount > MaxCharsPerLine) {
                    lineCount++;
                    lineCharCount = 0;
                }

                // treat \r\n or \n\r as a single line break
                if (ch == '\r' && message[i + 1] == '\n')  
                    i+=2;
                else if (ch == '\n' && message[i + 1] == '\r') 
                    i+=2;
                else
                    i++;
            }
            if (i < message.Length - 1)
                message = message.Substring(0, i) + "...\r\n<truncated>";
            return message;          
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\design\serialization\resolvenameeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResolveNameEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    /// <include file='doc\ResolveNameEventHandler.uex' path='docs/doc[@for="ResolveNameEventHandler"]/*' />
    /// <devdoc>
    ///     This delegate is used to resolve object names when performing
    ///     serialization and deserialization.
    /// </devdoc>
    public delegate void ResolveNameEventHandler(object sender, ResolveNameEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\debug.cs ===
//------------------------------------------------------------------------------
// <copyright file="Debug.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
#define DEBUG
namespace System.Diagnostics {
    using System;
    using System.Collections;

    /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug"]/*' />
    /// <devdoc>
    ///    <para>Provides a set of properties and
    ///       methods
    ///       for debugging code.</para>
    /// </devdoc>
    public sealed class Debug { 

        // not creatable...
        //
        private Debug() {
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Listeners"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the collection of listeners that is monitoring the debug
        ///       output.</para>
        /// </devdoc>
        public static TraceListenerCollection Listeners { 
            get {
                return TraceInternal.Listeners;
            }
        }          

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.AutoFlush"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating whether <see cref='System.Diagnostics.Debug.Flush'/> should be called on the
        /// <see cref='System.Diagnostics.Debug.Listeners'/>
        /// after every write.</para>
        /// </devdoc>
        public static bool AutoFlush { 
            get {
                return TraceInternal.AutoFlush;
            }

            set {
                TraceInternal.AutoFlush = value;
            }
        }
        
        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.IndentLevel"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the indent level.</para>
        /// </devdoc>
        public static int IndentLevel {
            get { return TraceInternal.IndentLevel; }

            set { TraceInternal.IndentLevel = value; }
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.IndentSize"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the number of spaces in an indent.</para>
        /// </devdoc>
        public static int IndentSize {
            get { return TraceInternal.IndentSize; }
            
            set { TraceInternal.IndentSize = value; }
        }        
        
        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Flush"]/*' />
        /// <devdoc>
        ///    <para>Clears the output buffer, and causes buffered data to
        ///       be written to the <see cref='System.Diagnostics.Debug.Listeners'/>.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]          
        public static void Flush() {
            TraceInternal.Flush();
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Close"]/*' />
        /// <devdoc>
        ///    <para>Clears the output buffer, and then closes the <see cref='System.Diagnostics.Debug.Listeners'/> so that they no longer receive
        ///       debugging output.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void Close() {
            TraceInternal.Close();
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Assert"]/*' />
        /// <devdoc>
        /// <para>Checks for a condition, and outputs the callstack if the condition is <see langword='false'/>.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]  
        public static void Assert(bool condition) {
            TraceInternal.Assert(condition);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Assert1"]/*' />
        /// <devdoc>
        ///    <para>Checks for a condition, and displays a message if the condition is
        ///    <see langword='false'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]  
        public static void Assert(bool condition, string message) {
            TraceInternal.Assert(condition, message);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Assert2"]/*' />
        /// <devdoc>
        ///    <para>Checks for a condition, and displays both the specified messages if the condition
        ///       is <see langword='false'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]  
        public static void Assert(bool condition, string message, string detailMessage) {
            TraceInternal.Assert(condition, message, detailMessage);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Fail"]/*' />
        /// <devdoc>
        ///    <para>Emits or displays a message for an assertion that always fails.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]        
        public static void Fail(string message) {
            TraceInternal.Fail(message);
        }        

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Fail1"]/*' />
        /// <devdoc>
        ///    <para>Emits or displays both messages for an assertion that always fails.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]        
        public static void Fail(string message, string detailMessage) {
            TraceInternal.Fail(message, detailMessage);
        }        

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Write"]/*' />
        /// <devdoc>
        ///    <para>Writes a message to the trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]        
        public static void Write(string message) {
            TraceInternal.Write(message);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Write1"]/*' />
        /// <devdoc>
        ///    <para>Writes the name of the value 
        ///       parameter to the trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void Write(object value) {
            TraceInternal.Write(value);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Write2"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and message 
        ///       to the trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void Write(string message, string category) {
            TraceInternal.Write(message, category);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Write3"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and the name of the value parameter to the trace
        ///       listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void Write(object value, string category) {
            TraceInternal.Write(value, category);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteLine"]/*' />
        /// <devdoc>
        ///    <para>Writes a message followed by a line terminator to the trace listeners in the
        ///    <see cref='System.Diagnostics.Debug.Listeners'/> collection. The default line terminator 
        ///       is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]        
        public static void WriteLine(string message) {
            TraceInternal.WriteLine(message);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteLine1"]/*' />
        /// <devdoc>
        ///    <para>Writes the name of the value 
        ///       parameter followed by a line terminator to the
        ///       trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection. The default line
        ///       terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void WriteLine(object value) {
            TraceInternal.WriteLine(value);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteLine2"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and message followed by a line terminator to the trace
        ///       listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection. The default line
        ///       terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void WriteLine(string message, string category) {
            TraceInternal.WriteLine(message, category);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteLine3"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and the name of the value 
        ///       parameter followed by a line
        ///       terminator to the trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection. The
        ///       default line terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void WriteLine(object value, string category) {
            TraceInternal.WriteLine(value, category);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteIf"]/*' />
        /// <devdoc>
        /// <para>Writes a message to the trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection 
        ///    if a condition is
        /// <see langword='true'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]        
        public static void WriteIf(bool condition, string message) {
            TraceInternal.WriteIf(condition, message);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteIf1"]/*' />
        /// <devdoc>
        ///    <para>Writes the name of the value 
        ///       parameter to the trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/>
        ///       collection if a condition is
        ///    <see langword='true'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void WriteIf(bool condition, object value) {
            TraceInternal.WriteIf(condition, value);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteIf2"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and message 
        ///       to the trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/>
        ///       collection if a condition is
        ///    <see langword='true'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void WriteIf(bool condition, string message, string category) {
            TraceInternal.WriteIf(condition, message, category);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteIf3"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and the name of the value 
        ///       parameter to the trace
        ///       listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection if a condition is
        ///    <see langword='true'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void WriteIf(bool condition, object value, string category) {
            TraceInternal.WriteIf(condition, value, category);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteLineIf"]/*' />
        /// <devdoc>
        ///    <para>Writes a message followed by a line terminator to the trace listeners in the
        ///    <see cref='System.Diagnostics.Debug.Listeners'/> collection if a condition is 
        ///    <see langword='true'/>. The default line terminator is a carriage return followed 
        ///       by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]        
        public static void WriteLineIf(bool condition, string message) {
            TraceInternal.WriteLineIf(condition, message);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteLineIf1"]/*' />
        /// <devdoc>
        ///    <para>Writes the name of the value 
        ///       parameter followed by a line terminator to the
        ///       trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection if a condition is
        ///    <see langword='true'/>. The default line terminator is a carriage return followed 
        ///       by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void WriteLineIf(bool condition, object value) {
            TraceInternal.WriteLineIf(condition, value);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteLineIf2"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and message
        ///       followed by a line terminator to the trace
        ///       listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection if a condition is
        ///    <see langword='true'/>. The default line terminator is a carriage return followed 
        ///       by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void WriteLineIf(bool condition, string message, string category) {
            TraceInternal.WriteLineIf(condition, message, category);
        }
        
        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.WriteLineIf3"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and the name of the value parameter followed by a line
        ///       terminator to the trace listeners in the <see cref='System.Diagnostics.Debug.Listeners'/> collection
        ///       if a condition is <see langword='true'/>. The default line terminator is a carriage
        ///       return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void WriteLineIf(bool condition, object value, string category) {
            TraceInternal.WriteLineIf(condition, value, category);
        }

        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Indent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void Indent() {
            TraceInternal.Indent();
        }
        
        /// <include file='doc\Debug.uex' path='docs/doc[@for="Debug.Unindent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public static void Unindent() {
            TraceInternal.Unindent();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\booleanswitch.cs ===
//------------------------------------------------------------------------------
// <copyright file="BooleanSwitch.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Diagnostics {
    using System.Diagnostics;
    using System;

    /// <include file='doc\BooleanSwitch.uex' path='docs/doc[@for="BooleanSwitch"]/*' />
    /// <devdoc>
    ///    <para>Provides a simple on/off switch that can be used to control debugging and tracing
    ///       output.</para>
    /// </devdoc>
    public class BooleanSwitch : Switch {
        /// <include file='doc\BooleanSwitch.uex' path='docs/doc[@for="BooleanSwitch.BooleanSwitch"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.BooleanSwitch'/>
        /// class.</para>
        /// </devdoc>
        public BooleanSwitch(string displayName, string description)
            : base(displayName, description) {
        }

        /// <include file='doc\BooleanSwitch.uex' path='docs/doc[@for="BooleanSwitch.Enabled"]/*' />
        /// <devdoc>
        ///    <para>Specifies whether the switch is enabled
        ///       (<see langword='true'/>) or disabled (<see langword='false'/>).</para>
        /// </devdoc>
        public bool Enabled {
            get {
                return (SwitchSetting == 0) ? false : true;
            }
            set {
                SwitchSetting = value ? 1 : 0;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\configuration\appsettingsreader.cs ===
//------------------------------------------------------------------------------
// <copyright file="AppSettingsReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   AppSettingsReader.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Reflection;
using System.Configuration;
using System.Collections.Specialized;
using System.Globalization;

namespace System.Configuration {

    /// <include file='doc\AppSettingsReader.uex' path='docs/doc[@for="AppSettingsReader"]/*' />
    /// <devdoc>
    ///     The AppSettingsReader class provides a wrapper for System.Configuration.ConfigurationSettings.AppSettings
    ///     which provides a single method for reading values from the config file of a particular type.
    /// </devdoc>
    public class AppSettingsReader {
        private NameValueCollection map;
        static Type stringType = typeof(string);
        static Type[] paramsArray = new Type[] { stringType };
        static string NullString = "None";

        /// <include file='doc\AppSettingsReader.uex' path='docs/doc[@for="AppSettingsReader.AppSettingsReader"]/*' />
        /// <devdoc>
        ///     Constructor
        /// </devdoc>
        public AppSettingsReader() {
            map = System.Configuration.ConfigurationSettings.AppSettings;
        }

        /// <include file='doc\AppSettingsReader.uex' path='docs/doc[@for="AppSettingsReader.GetValue"]/*' />
        /// <devdoc>
        ///     Gets the value for specified key from ConfigurationSettings.AppSettings, and returns
        ///     an object of the specified type containing the value from the config file.  If the key
        ///     isn't in the config file, or if it is not a valid value for the given type, it will 
        ///     throw an exception with a descriptive message so the user can make the appropriate
        ///     change
        /// </devdoc>
        public object GetValue(string key, Type type) {
            if (key == null) throw new ArgumentNullException("key");
            if (type == null) throw new ArgumentNullException("type");

            string val = map[key];

            if (val == null) throw new InvalidOperationException(SR.GetString(SR.AppSettingsReaderNoKey, key));

            if (type == stringType) {
                // It's a string, so we can ALMOST just return the value.  The only
                // tricky point is that if it's the string "(None)", then we want to
                // return null.  And of course we need a way to represent the string
                // (None), so we use ((None)), and so on... so it's a little complicated.
                int NoneNesting = GetNoneNesting(val);
                if (NoneNesting == 0) {
                    // val is not of the form ((..((None))..))
                    return val;
                }
                else if (NoneNesting == 1) {
                    // val is (None)
                    return null;
                }
                else {
                    // val is of the form ((..((None))..))
                    return val.Substring(1, val.Length - 2);
                }
            }
            else {
                try {
                    return Convert.ChangeType(val, type);
                } catch (Exception) {
                    string displayString = (val.Length == 0) ? SR.AppSettingsReaderEmptyString : val;
                    throw new InvalidOperationException(SR.GetString(SR.AppSettingsReaderCantParse, displayString, key, type.ToString()));
                }               
            }  
        }

        private int GetNoneNesting(string val) {
            int count = 0;
            int len = val.Length;
            if (len > 1) {
                while (val[count] == '(' && val[len - count - 1] == ')') {
                    count++;
                }
                if (count > 0 && string.Compare(NullString, 0, val, count, len - 2 * count, false, CultureInfo.InvariantCulture) != 0) {
                    // the stuff between the parens is not "None"
                    count = 0;
                }
            }
            return count;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\defaulttracelistener.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultTraceListener.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
#define DEBUG
#define TRACE
namespace System.Diagnostics {
    using System;
    using System.IO;
    using System.Text;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Security;
    using Microsoft.Win32;       

    /// <include file='doc\DefaultTraceListener.uex' path='docs/doc[@for="DefaultTraceListener"]/*' />
    /// <devdoc>
    ///    <para>Provides
    ///       the default output methods and behavior for tracing.</para>
    /// </devdoc>
    [ComVisible(false)]
    public class DefaultTraceListener : TraceListener {    

        bool assertUIEnabled;        
        string logFileName;
        bool settingsInitialized;
        const int internalWriteSize = 16384;


        /// <include file='doc\DefaultTraceListener.uex' path='docs/doc[@for="DefaultTraceListener.DefaultTraceListener"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.DefaultTraceListener'/> class with 
        ///    Default as its <see cref='System.Diagnostics.TraceListener.Name'/>.</para>
        /// </devdoc>
        public DefaultTraceListener()
            : base("Default") {
        }

        /// <include file='doc\DefaultTraceListener.uex' path='docs/doc[@for="DefaultTraceListener.AssertUiEnabled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool AssertUiEnabled {
            get { 
                if (!settingsInitialized) InitializeSettings();
                return assertUIEnabled; 
            }
            set { 
                if (!settingsInitialized) InitializeSettings();
                assertUIEnabled = value; 
            }
        }

        /// <include file='doc\DefaultTraceListener.uex' path='docs/doc[@for="DefaultTraceListener.LogFileName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string LogFileName {
            get { 
                if (!settingsInitialized) InitializeSettings();
                return logFileName; 
            }
            set { 
                if (!settingsInitialized) InitializeSettings();
                logFileName = value; 
            }
        }
        
        /// <include file='doc\DefaultTraceListener.uex' path='docs/doc[@for="DefaultTraceListener.Fail"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Emits or displays a message
        ///       and a stack trace for an assertion that
        ///       always fails.
        ///    </para>
        /// </devdoc>
        public override void Fail(string message) {
            Fail(message, null);
        }

        /// <include file='doc\DefaultTraceListener.uex' path='docs/doc[@for="DefaultTraceListener.Fail1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Emits or displays messages and a stack trace for an assertion that
        ///       always fails.
        ///    </para>
        /// </devdoc>
        public override void Fail(string message, string detailMessage) {            
            StackTrace stack = new StackTrace(true);
            int userStackFrameIndex = 0;
            string stackTrace;
            bool userInteractive = UserInteractive;       
            bool uiPermission = UiPermission;

            try {
                stackTrace = StackTraceToString(stack, userStackFrameIndex, stack.FrameCount - 1);
            }
            catch {
                stackTrace = "";
            }
            
            WriteAssert(stackTrace, message, detailMessage);
            if (AssertUiEnabled && userInteractive && uiPermission) {
                AssertWrapper.ShowAssert(stackTrace, stack.GetFrame(userStackFrameIndex), message, detailMessage);
            }
        }    

        private void InitializeSettings() {
            // don't use the property setters here to avoid infinite recursion.
            assertUIEnabled = DiagnosticsConfiguration.AssertUIEnabled;
            logFileName = DiagnosticsConfiguration.LogFileName;
            settingsInitialized = true;
        }

        private void WriteAssert(string stackTrace, string message, string detailMessage) {
            string assertMessage = SR.GetString(SR.DebugAssertBanner) + "\r\n"
                                            + SR.GetString(SR.DebugAssertShortMessage) + "\r\n"
                                            + message + "\r\n"
                                            + SR.GetString(SR.DebugAssertLongMessage) + "\r\n" + 
                                            detailMessage + "\r\n" 
                                            + stackTrace;
            WriteLine(assertMessage);
        }

        private void WriteToLogFile(string message, bool useWriteLine) {
            try {
                FileInfo file = new FileInfo(LogFileName);
                Stream stream = file.Open(FileMode.OpenOrCreate);
                stream.Position = stream.Length;
                StreamWriter writer = new StreamWriter(stream);
                if (useWriteLine)
                    writer.WriteLine(message);
                else
                    writer.Write(message);
                writer.Close();
            }
            catch (Exception e) {                        
                WriteLine(SR.GetString(SR.ExceptionOccurred, LogFileName, e.ToString()), false);

            }
        }


        // Given a stack trace and start and end frame indexes, construct a
        // callstack that contains method, file and line number information.        
        private string StackTraceToString(StackTrace trace, int startFrameIndex, int endFrameIndex) {
            StringBuilder sb = new StringBuilder(512);
            
            for (int i = startFrameIndex; i <= endFrameIndex; i++) {
                StackFrame frame = trace.GetFrame(i);
                MethodBase method = frame.GetMethod();
                sb.Append("\r\n    at ");
                sb.Append(method.ReflectedType.Name);
                sb.Append(".");
                sb.Append(method.Name);
                sb.Append("(");
                ParameterInfo[] parameters = method.GetParameters();
                for (int j = 0; j < parameters.Length; j++) {
                    ParameterInfo parameter = parameters[j];
                    if (j > 0)
                        sb.Append(", ");
                    sb.Append(parameter.ParameterType.Name);
                    sb.Append(" ");
                    sb.Append(parameter.Name);
                }
                sb.Append(")  ");
                sb.Append(frame.GetFileName());
                int line = frame.GetFileLineNumber();
                if (line > 0) {
                    sb.Append("(");
                    sb.Append(line.ToString());
                    sb.Append(")");
                }
            }
            sb.Append("\r\n");

            return sb.ToString();
        }

        /// <include file='doc\DefaultTraceListener.uex' path='docs/doc[@for="DefaultTraceListener.Write"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the output to the OutputDebugString
        ///       API and
        ///       to System.Diagnostics.Debugger.Log.
        ///    </para>
        /// </devdoc>
        public override void Write(string message) {
            Write(message, true);
        }
         
        private void Write(string message, bool useLogFile) {    
            if (NeedIndent) WriteIndent();

            // really huge messages mess up both VS and dbmon, so we chop it up into 
            // reasonable chunks if it's too big
            if (message == null || message.Length <= internalWriteSize) {
                internalWrite(message);
            }
            else {
                int offset;
                for (offset = 0; offset < message.Length - internalWriteSize; offset += internalWriteSize) {
                    internalWrite(message.Substring(offset, internalWriteSize));
                }
                internalWrite(message.Substring(offset));
            }

            if (useLogFile && LogFileName.Length != 0)
                WriteToLogFile(message, false);
        }

        void internalWrite(string message) {
            if (Debugger.IsLogging()) {
                Debugger.Log(0, null, message);
            } else {
                if (message == null) 
                    SafeNativeMethods.OutputDebugString(String.Empty);            
                else
                    SafeNativeMethods.OutputDebugString(message); 
            }
        }

        /// <include file='doc\DefaultTraceListener.uex' path='docs/doc[@for="DefaultTraceListener.WriteLine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the output to the OutputDebugString
        ///       API and to System.Diagnostics.Debugger.Log
        ///       followed by a line terminator. The default line terminator is a carriage return
        ///       followed by a line feed (\r\n).
        ///    </para>
        /// </devdoc>
        public override void WriteLine(string message) {
            WriteLine(message, true);
        }
        
        private void WriteLine(string message, bool useLogFile) {
            if (NeedIndent) WriteIndent();
            // I do the concat here to make sure it goes as one call to the output.
            // we would save a stringbuilder operation by calling Write twice.
            Write(message + "\r\n", useLogFile); 
            NeedIndent = true;
        }

        /// <devdoc>
        ///     This is usually used along with UserInteractive.  It returns true if
        ///     the current permission set allows an assert dialog to be displayed.
        /// </devdoc>
        private static bool UiPermission {
            get {
                bool uiPermission = false;

                try {
                    new UIPermission(UIPermissionWindow.SafeSubWindows).Demand();
                    uiPermission = true;
                }
                catch {
                }
                return uiPermission;
            }
        }

        /// <include file='doc\DefaultTraceListener.uex' path='docs/doc[@for="DefaultTraceListener.UserInteractive"]/*' />
        /// <devdoc>
        ///     Determines if the current process is running in user interactive
        ///     mode. This will only ever be false when running as a 
        ///     ServiceProcess or from inside a Web application. When 
        ///     UserInteractive is false, no modal dialogs or message boxes
        ///     should be displayed, as there is no GUI for the user
        ///     to interact with.
        /// </devdoc>
        internal static bool UserInteractive {
            get {
                bool userInteractive = true;
                
                // SECREVIEW: we assert unrestricted Environment to get the platform,
                // but we don't reveal the platform to the caller.
                new EnvironmentPermission(PermissionState.Unrestricted).Assert();

                try {
                    if (Environment.OSVersion.Platform == System.PlatformID.Win32NT) {
                        IntPtr hwinsta = (IntPtr)0;
    
                        hwinsta = UnsafeNativeMethods.GetProcessWindowStation();
                        if (hwinsta != (IntPtr)0) {
                            userInteractive = true;
    
                            int lengthNeeded = 0;
                            NativeMethods.USEROBJECTFLAGS flags = new NativeMethods.USEROBJECTFLAGS();
    
                            if (UnsafeNativeMethods.GetUserObjectInformation(new HandleRef(null, hwinsta), NativeMethods.UOI_FLAGS, flags, Marshal.SizeOf(flags), ref lengthNeeded)) {
                                if ((flags.dwFlags & NativeMethods.WSF_VISIBLE) == 0) {
                                    userInteractive = false;
                                }
                            }
                        }
                    }
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }

                return userInteractive;
            }
        }       
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\diagnosticsconfiguration.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiagnosticsConfiguration.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   DiagnosticsConfiguration.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Diagnostics {
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Configuration;

    internal enum InitState {
        NotInitialized,
        Initializing,
        Initialized
    }

    internal class DiagnosticsConfiguration {
        private static Hashtable configTable;
        private static InitState initState = InitState.NotInitialized;        
        private const int DefaultCountersFileMappingSize = 524288;
        private const int MaxCountersFileMappingSize = 33554432;
        private const int MinCountersFileMappingSize = 32768;

        // setting for Switch.switchSetting
        internal static IDictionary SwitchSettings {
            get { 
                Initialize();
                if (configTable != null && configTable.ContainsKey("switches"))
                    return (IDictionary)configTable["switches"];
                else
                    return null;
            }
        }

        // setting for DefaultTraceListener.AssertUIEnabled
        internal static bool AssertUIEnabled {
            get { 
                Initialize();
                if (configTable != null && configTable.ContainsKey("assertuienabled"))
                    return (bool)configTable["assertuienabled"];
                else
                    return true; // the default
            }
        }

        // setting for DefaultTraceListener.LogFileName
        internal static string LogFileName {
            get { 
                Initialize();
                if (configTable != null && configTable.ContainsKey("logfilename"))
                    return (string)configTable["logfilename"];
                else
                    return string.Empty; // the default
            }
        }

        // setting for TraceInternal.AutoFlush
        internal static bool AutoFlush {
            get { 
                Initialize();
                if (configTable != null && configTable.ContainsKey("autoflush"))
                    return (bool)configTable["autoflush"];
                else
                    return false; // the default
            }
        }

        // setting for TraceInternal.IndentSize
        internal static int IndentSize {
            get { 
                Initialize();
                if (configTable != null && configTable.ContainsKey("indentsize"))
                    return (int)configTable["indentsize"];
                else
                    return 4; // the default
            }
        }

        internal static int PerfomanceCountersFileMappingSize {
            get {                                                 
                for (int retryCount = 0; !CanInitialize() && retryCount <= 5; ++retryCount) {
                    if (retryCount == 5)
                        return DefaultCountersFileMappingSize;
                        
                    System.Threading.Thread.Sleep(200);
                }                    
                    
                Initialize();                                   
                if (configTable == null || !configTable.ContainsKey("filemappingsize")) 
                    return DefaultCountersFileMappingSize;
                else {
                    int size = (int)configTable["filemappingsize"];
                    if (size < MinCountersFileMappingSize)
                        size = MinCountersFileMappingSize;
                                            
                    if (size > MaxCountersFileMappingSize)
                        size = MaxCountersFileMappingSize; 
                                            
                    return size;
              	}                    
            }                
        }
        
        private static Hashtable GetConfigTable() {
            Hashtable configTable = (Hashtable) ConfigurationSettings.GetConfig("system.diagnostics");
            return configTable;
        }

        internal static bool IsInitializing() {
            return initState == InitState.Initializing;
        }

        internal static bool IsInitialized() {
            return initState == InitState.Initialized;
        }
            

        internal static bool CanInitialize() {
            return (initState != InitState.Initializing) && !(ConfigurationSettings.SetConfigurationSystemInProgress);
        }
        
        internal static void Initialize() {
            // because some of the code used to load config also uses diagnostics
            // we can't block them while we initialize from config. Therefore we just
            // return immediately and they just use the default values.
            lock (typeof(DiagnosticsConfiguration)) {

                if (initState != InitState.NotInitialized || ConfigurationSettings.SetConfigurationSystemInProgress)
                    return;

                initState = InitState.Initializing; // used for preventing recursion
                try {
                    configTable = GetConfigTable();
                }
                finally {
                    initState = InitState.Initialized;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\switch.cs ===
//------------------------------------------------------------------------------
// <copyright file="Switch.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Diagnostics {
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.Collections;
    using System.Globalization;
    
    /// <include file='doc\Switch.uex' path='docs/doc[@for="Switch"]/*' />
    /// <devdoc>
    /// <para>Provides an <see langword='abstract '/>base class to
    ///    create new debugging and tracing switches.</para>
    /// </devdoc>
    public abstract class Switch {
        static int initCount;
        private static Hashtable switchSettings;
        private string description;
        private string displayName;
        private int    switchSetting = 0;
        private bool   initialized = false;

        /// <include file='doc\Switch.uex' path='docs/doc[@for="Switch.Switch"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.Switch'/>
        /// class.</para>
        /// </devdoc>
        protected Switch(string displayName, string description) {
        
            // displayName is used as a hashtable key, so it can never
            // be null.
            if (displayName == null) displayName = string.Empty;
            
            this.displayName = displayName;
            this.description = description;
        }

        /// <include file='doc\Switch.uex' path='docs/doc[@for="Switch.DisplayName"]/*' />
        /// <devdoc>
        ///    <para>Gets a name used to identify the switch.</para>
        /// </devdoc>
        public string DisplayName {
            get {
                return displayName;
            }
        }

        /// <include file='doc\Switch.uex' path='docs/doc[@for="Switch.Description"]/*' />
        /// <devdoc>
        ///    <para>Gets a description of the switch.</para>
        /// </devdoc>
        public string Description {
            get {
                return (description == null) ? string.Empty : description;
            }
        }

        /// <include file='doc\Switch.uex' path='docs/doc[@for="Switch.SwitchSetting"]/*' />
        /// <devdoc>
        ///    <para>
        ///     Indicates the current setting for this switch.
        ///    </para>
        /// </devdoc>
        protected int SwitchSetting {
            get {
                if (!initialized) {
                    if (switchSettings == null) {
                        if (!Switch.Initialize())
                            return 0;
                    }
                    
                    object value = switchSettings[displayName];
                    if (value != null) {
                        switchSetting = (int)value;
                    }
                    else {
                        switchSetting = 0;
                    }
                    initialized = true;
                    OnSwitchSettingChanged();
                }
                return switchSetting;
            }
            set {
                switchSetting = value;
                initialized = true;
                OnSwitchSettingChanged();
            }
        }

        private static bool Initialize() {
            if (Interlocked.CompareExchange(ref initCount, 1, 0) == 0) {
                try {
                    if (switchSettings != null)
                        return true;

                    if (!DiagnosticsConfiguration.CanInitialize())
                        return false;

                    // This hashtable is case-insensitive.
                    Hashtable switchSettingsLocal = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));                                    
                    
                    IDictionary configSwitchesTable = (IDictionary)DiagnosticsConfiguration.SwitchSettings;
                    if (configSwitchesTable != null) {
                        switchSettingsLocal = new Hashtable(configSwitchesTable.Count, new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));                
                        foreach (DictionaryEntry entry in configSwitchesTable) {
                            try {
                                switchSettingsLocal[entry.Key] = Int32.Parse((string)entry.Value);
                            }
                            catch (Exception) {
                                // eat parsing problems
                            }
                        }
                    }
                    else
                        switchSettingsLocal = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));

                    switchSettings = switchSettingsLocal;
                }
                finally {
                    initCount = 0;
                }
                return true;
            }
            else {
                return false;
            }
        }
    
        /// <include file='doc\Switch.uex' path='docs/doc[@for="Switch.OnSwitchSettingChanged"]/*' />
        /// <devdoc>
        ///     This method is invoked when a switch setting has been changed.  It will
        ///     be invoked the first time a switch reads its value from the registry
        ///     or environment, and then it will be invoked each time the switch's
        ///     value is changed.
        /// </devdoc>
        protected virtual void OnSwitchSettingChanged() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\textwritertracelistener.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextWriterTraceListener.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics {
    using System;
    using System.IO;
    using Microsoft.Win32;

    /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener"]/*' />
    /// <devdoc>
    ///    <para>Directs tracing or debugging output to
    ///       a <see cref='T:System.IO.TextWriter'/> or to a <see cref='T:System.IO.Stream'/>,
    ///       such as <see cref='F:System.Console.Out'/> or <see cref='T:System.IO.FileStream'/>.</para>
    /// </devdoc>
    public class TextWriterTraceListener : TraceListener {
        TextWriter writer;

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.TextWriterTraceListener"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener'/> class with
        /// <see cref='System.IO.TextWriter'/> 
        /// as the output recipient.</para>
        /// </devdoc>
        public TextWriterTraceListener() 
            : base("TextWriter") {
        }
        
        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.TextWriterTraceListener1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener'/> class, using the 
        ///    stream as the recipient of the debugging and tracing output.</para>
        /// </devdoc>
        public TextWriterTraceListener(Stream stream) 
            : this(stream, string.Empty) {
        }

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.TextWriterTraceListener2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener'/> class with the 
        ///    specified name and using the stream as the recipient of the debugging and tracing output.</para>
        /// </devdoc>
        public TextWriterTraceListener(Stream stream, string name) 
            : base(name) {
            if (stream == null) throw new ArgumentNullException("stream");
            this.writer = new StreamWriter(stream);                        
        }

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.TextWriterTraceListener3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener'/> class using the 
        ///    specified writer as recipient of the tracing or debugging output.</para>
        /// </devdoc>
        public TextWriterTraceListener(TextWriter writer) 
            : this(writer, string.Empty) {
        }

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.TextWriterTraceListener4"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.TextWriterTraceListener'/> class with the 
        ///    specified name and using the specified writer as recipient of the tracing or
        ///    debugging
        ///    output.</para>
        /// </devdoc>
        public TextWriterTraceListener(TextWriter writer, string name) 
            : base(name) {
            if (writer == null) throw new ArgumentNullException("writer");
            this.writer = writer;
        }

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.TextWriterTraceListener5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TextWriterTraceListener(string fileName) 
            : this(new StreamWriter(fileName, true)) {
        }

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.TextWriterTraceListener6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TextWriterTraceListener(string fileName, string name) 
            : this(new StreamWriter(fileName, true), name) {
        }
        
        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.Writer"]/*' />
        /// <devdoc>
        ///    <para> Indicates the text writer that receives the tracing
        ///       or debugging output.</para>
        /// </devdoc>
        public TextWriter Writer {
            get {
                return writer;
            }

            set {
                writer = value;
            }
        }
        
        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.Close"]/*' />
        /// <devdoc>
        /// <para>Closes the <see cref='System.Diagnostics.TextWriterTraceListener.Writer'/> so that it no longer
        ///    receives tracing or debugging output.</para>
        /// </devdoc>
        public override void Close() {
            if (writer != null) 
                writer.Close();
        }

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.Dispose"]/*' />
        /// <internalonly/>
        /// <devdoc>        
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) 
                this.Close();
        }                

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.Flush"]/*' />
        /// <devdoc>
        /// <para>Flushes the output buffer for the <see cref='System.Diagnostics.TextWriterTraceListener.Writer'/>.</para>
        /// </devdoc>
        public override void Flush() {
            if (writer == null) return;
            writer.Flush();
        }

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.Write"]/*' />
        /// <devdoc>
        ///    <para>Writes a message 
        ///       to this instance's <see cref='System.Diagnostics.TextWriterTraceListener.Writer'/>.</para>
        /// </devdoc>
        public override void Write(string message) {
            if (writer == null) return;   
            if (NeedIndent) WriteIndent();
            writer.Write(message);
        }

        /// <include file='doc\TextWriterTraceListener.uex' path='docs/doc[@for="TextWriterTraceListener.WriteLine"]/*' />
        /// <devdoc>
        ///    <para>Writes a message 
        ///       to this instance's <see cref='System.Diagnostics.TextWriterTraceListener.Writer'/> followed by a line terminator. The
        ///       default line terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        public override void WriteLine(string message) {
            if (writer == null) return;   
            if (NeedIndent) WriteIndent();
            writer.WriteLine(message);
            NeedIndent = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\tracelevel.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceLevel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Diagnostics;

    using System;

    /// <include file='doc\TraceLevel.uex' path='docs/doc[@for="TraceLevel"]/*' />
    /// <devdoc>
    ///    <para>Specifies what messages to output for debugging
    ///       and tracing.</para>
    /// </devdoc>
    public enum TraceLevel {
        /// <include file='doc\TraceLevel.uex' path='docs/doc[@for="TraceLevel.Off"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Output no tracing and debugging
        ///       messages.
        ///    </para>
        /// </devdoc>
        Off     = 0,
        /// <include file='doc\TraceLevel.uex' path='docs/doc[@for="TraceLevel.Error"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Output error-handling messages.
        ///    </para>
        /// </devdoc>
        Error   = 1,
        /// <include file='doc\TraceLevel.uex' path='docs/doc[@for="TraceLevel.Warning"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Output warnings and error-handling
        ///       messages.
        ///    </para>
        /// </devdoc>
        Warning = 2,
        /// <include file='doc\TraceLevel.uex' path='docs/doc[@for="TraceLevel.Info"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Output informational messages, warnings, and error-handling messages.
        ///    </para>
        /// </devdoc>
        Info    = 3,
        /// <include file='doc\TraceLevel.uex' path='docs/doc[@for="TraceLevel.Verbose"]/*' />
        /// <devdoc>
        ///    Output all debugging and tracing messages.
        /// </devdoc>
        Verbose = 4,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\trace.cs ===
//------------------------------------------------------------------------------
// <copyright file="Trace.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
#define TRACE
namespace System.Diagnostics {
    using System;
    using System.Collections;

    /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace"]/*' />
    /// <devdoc>
    ///    <para>Provides a set of properties and methods to trace the execution of your code.</para>
    /// </devdoc>
    public sealed class Trace {

        // not creatble...
        //
        private Trace() {
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Listeners"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of listeners that is monitoring the trace output.</para>
        /// </devdoc>
        public static TraceListenerCollection Listeners { 
            get {
                return TraceInternal.Listeners;
            }
        }          

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.AutoFlush"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether <see cref='System.Diagnostics.Trace.Flush'/> should be called on the <see cref='System.Diagnostics.Trace.Listeners'/> after every write.
        ///    </para>
        /// </devdoc>
        public static bool AutoFlush { 
            get {
                return TraceInternal.AutoFlush;
            }

            set {
                TraceInternal.AutoFlush = value;
            }
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.IndentLevel"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the indent level.</para>
        /// </devdoc>
        public static int IndentLevel {
            get { return TraceInternal.IndentLevel; }

            set { TraceInternal.IndentLevel = value; }
        }


        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.IndentSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of spaces in an indent.
        ///    </para>
        /// </devdoc>
        public static int IndentSize {
            get { return TraceInternal.IndentSize; }
            
            set { TraceInternal.IndentSize = value; }
        }        
        
        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Flush"]/*' />
        /// <devdoc>
        ///    <para>Clears the output buffer, and causes buffered data to
        ///       be written to the <see cref='System.Diagnostics.Trace.Listeners'/>.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]          
        public static void Flush() {
            TraceInternal.Flush();
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Close"]/*' />
        /// <devdoc>
        /// <para>Clears the output buffer, and then closes the <see cref='System.Diagnostics.Trace.Listeners'/> so that they no
        ///    longer receive debugging output.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void Close() {
            TraceInternal.Close();
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Assert"]/*' />
        /// <devdoc>
        ///    <para>Checks for a condition, and outputs the callstack if the 
        ///       condition
        ///       is <see langword='false'/>.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]  
        public static void Assert(bool condition) {
            TraceInternal.Assert(condition);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Assert1"]/*' />
        /// <devdoc>
        ///    <para>Checks for a condition, and displays a message if the condition is
        ///    <see langword='false'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]  
        public static void Assert(bool condition, string message) {
            TraceInternal.Assert(condition, message);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Assert2"]/*' />
        /// <devdoc>
        ///    <para>Checks for a condition, and displays both messages if the condition
        ///       is <see langword='false'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]  
        public static void Assert(bool condition, string message, string detailMessage) {
            TraceInternal.Assert(condition, message, detailMessage);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Fail"]/*' />
        /// <devdoc>
        ///    <para>Emits or displays a message for an assertion that always fails.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]        
        public static void Fail(string message) {
            TraceInternal.Fail(message);
        }        

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Fail1"]/*' />
        /// <devdoc>
        ///    <para>Emits or displays both messages for an assertion that always fails.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]        
        public static void Fail(string message, string detailMessage) {
            TraceInternal.Fail(message, detailMessage);
        }        

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Write"]/*' />
        /// <devdoc>
        /// <para>Writes a message to the trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/>
        /// collection.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]        
        public static void Write(string message) {
            TraceInternal.Write(message);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Write1"]/*' />
        /// <devdoc>
        /// <para>Writes the name of the <paramref name="value "/>
        /// parameter to the trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void Write(object value) {
            TraceInternal.Write(value);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Write2"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and message to the trace listeners
        ///       in the <see cref='System.Diagnostics.Trace.Listeners'/> collection.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void Write(string message, string category) {
            TraceInternal.Write(message, category);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Write3"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and the name of the value parameter to the trace listeners
        ///       in the <see cref='System.Diagnostics.Trace.Listeners'/> collection.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void Write(object value, string category) {
            TraceInternal.Write(value, category);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteLine"]/*' />
        /// <devdoc>
        ///    <para>Writes a message followed by a line terminator to the
        ///       trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection.
        ///       The default line terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]        
        public static void WriteLine(string message) {
            TraceInternal.WriteLine(message);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteLine1"]/*' />
        /// <devdoc>
        /// <para>Writes the name of the <paramref name="value "/> parameter followed by a line terminator to the trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection. The default line
        ///    terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void WriteLine(object value) {
            TraceInternal.WriteLine(value);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteLine2"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and message followed by a line terminator to the trace
        ///       listeners in the <see cref='System.Diagnostics.Trace.Listeners'/>
        ///       collection. The default line terminator is a carriage return followed by a line
        ///       feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void WriteLine(string message, string category) {
            TraceInternal.WriteLine(message, category);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteLine3"]/*' />
        /// <devdoc>
        /// <para>Writes a <paramref name="category "/>name and the name of the <paramref name="value "/> parameter followed by a line
        ///    terminator to the trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection. The default line
        ///    terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void WriteLine(object value, string category) {
            TraceInternal.WriteLine(value, category);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteIf"]/*' />
        /// <devdoc>
        /// <para>Writes a message to the trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection 
        ///    if a condition is <see langword='true'/>.</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]        
        public static void WriteIf(bool condition, string message) {
            TraceInternal.WriteIf(condition, message);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteIf1"]/*' />
        /// <devdoc>
        /// <para>Writes the name of the <paramref name="value "/>
        /// parameter to the trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection if a condition is
        /// <see langword='true'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void WriteIf(bool condition, object value) {
            TraceInternal.WriteIf(condition, value);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteIf2"]/*' />
        /// <devdoc>
        /// <para>Writes a category name and message to the trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/>
        /// collection if a condition is <see langword='true'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void WriteIf(bool condition, string message, string category) {
            TraceInternal.WriteIf(condition, message, category);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteIf3"]/*' />
        /// <devdoc>
        /// <para>Writes a category name and the name of the <paramref name="value"/> parameter to the trace
        ///    listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection
        ///    if a condition is <see langword='true'/>. </para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void WriteIf(bool condition, object value, string category) {
            TraceInternal.WriteIf(condition, value, category);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteLineIf"]/*' />
        /// <devdoc>
        ///    <para>Writes a message followed by a line terminator to the trace listeners in the
        ///    <see cref='System.Diagnostics.Trace.Listeners'/> collection if a condition is 
        ///    <see langword='true'/>. The default line terminator is a carriage return followed 
        ///       by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]        
        public static void WriteLineIf(bool condition, string message) {
            TraceInternal.WriteLineIf(condition, message);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteLineIf1"]/*' />
        /// <devdoc>
        /// <para>Writes the name of the <paramref name="value"/> parameter followed by a line terminator to the
        ///    trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection
        ///    if a condition is
        /// <see langword='true'/>. The default line
        ///    terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void WriteLineIf(bool condition, object value) {
            TraceInternal.WriteLineIf(condition, value);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteLineIf2"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and message followed by a line terminator to the trace
        ///       listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection if a condition is
        ///    <see langword='true'/>. The default line terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void WriteLineIf(bool condition, string message, string category) {
            TraceInternal.WriteLineIf(condition, message, category);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.WriteLineIf3"]/*' />
        /// <devdoc>
        /// <para>Writes a category name and the name of the <paramref name="value "/> parameter followed by a line
        ///    terminator to the trace listeners in the <see cref='System.Diagnostics.Trace.Listeners'/> collection
        ///    if a <paramref name="condition"/> is <see langword='true'/>. The
        ///    default line terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void WriteLineIf(bool condition, object value, string category) {
            TraceInternal.WriteLineIf(condition, value, category);
        }

        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Indent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void Indent() {
            TraceInternal.Indent();
        }
    
        /// <include file='doc\Trace.uex' path='docs/doc[@for="Trace.Unindent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("TRACE")]
        public static void Unindent() {
            TraceInternal.Unindent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\tracelistener.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceListener.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics {
    using System;
    using System.Text;

    /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener"]/*' />
    /// <devdoc>
    /// <para>Provides the <see langword='abstract '/>base class for the listeners who
    ///    monitor trace and debug output.</para>
    /// </devdoc>
    public abstract class TraceListener : MarshalByRefObject, IDisposable {

        int indentLevel;
        int indentSize = 4;
        bool needIndent = true;
        string listenerName;

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.TraceListener"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.TraceListener'/> class.</para>
        /// </devdoc>
        protected TraceListener () {
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.TraceListener1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.TraceListener'/> class using the specified name as the
        ///    listener.</para>
        /// </devdoc>
        protected TraceListener(string name) {
            this.listenerName = name;
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Name"]/*' />
        /// <devdoc>
        /// <para> Gets or sets a name for this <see cref='System.Diagnostics.TraceListener'/>.</para>
        /// </devdoc>
        public virtual string Name {
            get { return (listenerName == null) ? "" : listenerName; }

            set { listenerName = value; }
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Dispose1"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected virtual void Dispose(bool disposing) {
            return;
        }


        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Close"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, closes the output stream
        ///       so that it no longer receives tracing or debugging output.</para>
        /// </devdoc>
        public virtual void Close() {
            return;
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Flush"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, flushes the output buffer.</para>
        /// </devdoc>
        public virtual void Flush() {
            return;
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.IndentLevel"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the indent level.</para>
        /// </devdoc>
        public int IndentLevel {
            get {
                return indentLevel;
            }

            set {
                indentLevel = (value < 0) ? 0 : value;
            }
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.IndentSize"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the number of spaces in an indent.</para>
        /// </devdoc>
        public int IndentSize {
            get {
                return indentSize;
            }

            set {
                if (value < 0)
                    throw new ArgumentOutOfRangeException("IndentSize", value, SR.GetString(SR.TraceListenerIndentSize));
                indentSize = value;
            }
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.NeedIndent"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether an indent is needed.</para>
        /// </devdoc>
        protected bool NeedIndent {
            get {
                return needIndent;
            }

            set {
                needIndent = value;
            }
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Fail"]/*' />
        /// <devdoc>
        ///    <para>Emits or displays a message for an assertion that always fails.</para>
        /// </devdoc>
        public virtual void Fail(string message) {
            Fail(message, null);
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Fail1"]/*' />
        /// <devdoc>
        ///    <para>Emits or displays messages for an assertion that always fails.</para>
        /// </devdoc>
        public virtual void Fail(string message, string detailMessage) {
            StringBuilder failMessage = new StringBuilder();
            failMessage.Append(SR.GetString(SR.TraceListenerFail));
            failMessage.Append(" ");
            failMessage.Append(message);            
            if (detailMessage != null) {
                failMessage.Append(" ");
                failMessage.Append(detailMessage);                
            }

            WriteLine(failMessage.ToString());
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Write"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, writes the specified
        ///       message to the listener you specify in the derived class.</para>
        /// </devdoc>
        public abstract void Write(string message);

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Write1"]/*' />
        /// <devdoc>
        /// <para>Writes the name of the <paramref name="o"/> parameter to the listener you specify when you inherit from the <see cref='System.Diagnostics.TraceListener'/>
        /// class.</para>
        /// </devdoc>
        public virtual void Write(object o) {
            if (o == null) return;
            Write(o.ToString());
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Write2"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and a message to the listener you specify when you
        ///       inherit from the <see cref='System.Diagnostics.TraceListener'/>
        ///       class.</para>
        /// </devdoc>
        public virtual void Write(string message, string category) {
            if (category == null)
                Write(message);
            else
                Write(category + ": " + ((message == null) ? string.Empty : message));
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.Write3"]/*' />
        /// <devdoc>
        /// <para>Writes a category name and the name of the <paramref name="o"/> parameter to the listener you
        ///    specify when you inherit from the <see cref='System.Diagnostics.TraceListener'/>
        ///    class.</para>
        /// </devdoc>
        public virtual void Write(object o, string category) {
            if (category == null)
                Write(o);
            else
                Write(o == null ? "" : o.ToString(), category);
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.WriteIndent"]/*' />
        /// <devdoc>
        ///    <para>Writes the indent to the listener you specify when you
        ///       inherit from the <see cref='System.Diagnostics.TraceListener'/>
        ///       class, and resets the <see cref='TraceListener.NeedIndent'/> property to <see langword='false'/>.</para>
        /// </devdoc>
        protected virtual void WriteIndent() {
            NeedIndent = false;
            for (int i = 0; i < indentLevel; i++) {
                if (indentSize == 4)
                    Write("    ");
                else {
                    for (int j = 0; j < indentSize; j++) {
                        Write(" ");
                    }
                }
           }
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.WriteLine"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, writes a message to the listener you specify in
        ///       the derived class, followed by a line terminator. The default line terminator is a carriage return followed
        ///       by a line feed (\r\n).</para>
        /// </devdoc>
        public abstract void WriteLine(string message);

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.WriteLine1"]/*' />
        /// <devdoc>
        /// <para>Writes the name of the <paramref name="o"/> parameter to the listener you specify when you inherit from the <see cref='System.Diagnostics.TraceListener'/> class, followed by a line terminator. The default line terminator is a
        ///    carriage return followed by a line feed
        ///    (\r\n).</para>
        /// </devdoc>
        public virtual void WriteLine(object o) {
            WriteLine(o == null ? "" : o.ToString());
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.WriteLine2"]/*' />
        /// <devdoc>
        ///    <para>Writes a category name and a message to the listener you specify when you
        ///       inherit from the <see cref='System.Diagnostics.TraceListener'/> class,
        ///       followed by a line terminator. The default line terminator is a carriage return followed by a line feed (\r\n).</para>
        /// </devdoc>
        public virtual void WriteLine(string message, string category) {
            if (category == null)
                WriteLine(message);
            else
                WriteLine(category + ": " + ((message == null) ? string.Empty : message));
        }

        /// <include file='doc\TraceListener.uex' path='docs/doc[@for="TraceListener.WriteLine3"]/*' />
        /// <devdoc>
        ///    <para>Writes a category
        ///       name and the name of the <paramref name="o"/>parameter to the listener you
        ///       specify when you inherit from the <see cref='System.Diagnostics.TraceListener'/>
        ///       class, followed by a line terminator. The default line terminator is a carriage
        ///       return followed by a line feed (\r\n).</para>
        /// </devdoc>
        public virtual void WriteLine(object o, string category) {
            WriteLine(o == null ? "" : o.ToString(), category);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\traceswitch.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceSwitch.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Diagnostics {
    using System;
    using System.ComponentModel;

    /// <include file='doc\TraceSwitch.uex' path='docs/doc[@for="TraceSwitch"]/*' />
    /// <devdoc>
    ///    <para>Provides a multi-level switch to enable or disable tracing
    ///       and debug output for a compiled application or framework.</para>
    /// </devdoc>
    public class TraceSwitch : Switch {

        /// <include file='doc\TraceSwitch.uex' path='docs/doc[@for="TraceSwitch.TraceSwitch"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.TraceSwitch'/> class.</para>
        /// </devdoc>
        public TraceSwitch(string displayName, string description)
            : base(displayName, description) {
        }

        /// <include file='doc\TraceSwitch.uex' path='docs/doc[@for="TraceSwitch.Level"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the trace
        ///       level that specifies what messages to output for tracing and debugging.</para>
        /// </devdoc>
        public TraceLevel Level {
            get {
                return (TraceLevel)SwitchSetting;
            }

            set {
                if (value < TraceLevel.Off || value > TraceLevel.Verbose)
                    throw new ArgumentException(SR.GetString(SR.TraceSwitchInvalidLevel));
                SwitchSetting = (int)value;
            }
        }

        /// <include file='doc\TraceSwitch.uex' path='docs/doc[@for="TraceSwitch.TraceError"]/*' />
        /// <devdoc>
        ///    <para>Gets a value
        ///       indicating whether the <see cref='System.Diagnostics.TraceSwitch.Level'/> is set to
        ///    <see langword='Error'/>, <see langword='Warning'/>, <see langword='Info'/>, or 
        ///    <see langword='Verbose'/>.</para>
        /// </devdoc>
        public bool TraceError {
            get {
                return (Level >= TraceLevel.Error);
            }
        }

        /// <include file='doc\TraceSwitch.uex' path='docs/doc[@for="TraceSwitch.TraceWarning"]/*' />
        /// <devdoc>
        ///    <para>Gets a value
        ///       indicating whether the <see cref='System.Diagnostics.TraceSwitch.Level'/> is set to
        ///    <see langword='Warning'/>, <see langword='Info'/>, or <see langword='Verbose'/>.</para>
        /// </devdoc>
        public bool TraceWarning {
            get {
                return (Level >= TraceLevel.Warning);
            }
        }

        /// <include file='doc\TraceSwitch.uex' path='docs/doc[@for="TraceSwitch.TraceInfo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value
        ///       indicating whether the <see cref='System.Diagnostics.TraceSwitch.Level'/> is set to
        ///    <see langword='Info'/> or <see langword='Verbose'/>.</para>
        /// </devdoc>
        public bool TraceInfo {
            get {
                return (Level >= TraceLevel.Info);
            }
        }

        /// <include file='doc\TraceSwitch.uex' path='docs/doc[@for="TraceSwitch.TraceVerbose"]/*' />
        /// <devdoc>
        ///    <para>Gets a value
        ///       indicating whether the <see cref='System.Diagnostics.TraceSwitch.Level'/> is set to
        ///    <see langword='Verbose'/>.</para>
        /// </devdoc>
        public bool TraceVerbose {
            get {
                return (Level == TraceLevel.Verbose);
            }
        }
        
        /// <include file='doc\TraceSwitch.uex' path='docs/doc[@for="TraceSwitch.OnSwitchSettingChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Update the level for this switch.
        ///    </para>
        /// </devdoc>
        protected override void OnSwitchSettingChanged() {
            int level = SwitchSetting;
            if (level < (int)TraceLevel.Off) {
                Trace.WriteLine(SR.GetString(SR.TraceSwitchLevelTooLow, DisplayName));
                SwitchSetting = (int)TraceLevel.Off;
            }
            else if (level > (int)TraceLevel.Verbose) {
                Trace.WriteLine(SR.GetString(SR.TraceSwitchLevelTooHigh, DisplayName));
                SwitchSetting = (int)TraceLevel.Verbose;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\traceinternal.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceInternal.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    internal class TraceInternal {
        static TraceListenerCollection listeners;
        static bool autoFlush;
        static int indentLevel;
        static int indentSize;
        static bool settingsInitialized;
        static bool wasInitialized;
        static object critSec = new object();

        public static TraceListenerCollection Listeners { 
            get {
                InitializeSettings();
                if (listeners == null) {
                    lock (typeof(Trace)) {
                        if (listeners == null) {
                            listeners = new TraceListenerCollection();
                            TraceListener defaultListener = new DefaultTraceListener();
                            defaultListener.IndentLevel = indentLevel;
                            defaultListener.IndentSize = indentSize;
                            listeners.Add(defaultListener);
                        }
                    }
                }
                return listeners;
            }
        }          

        public static bool AutoFlush { 
            get { 
                InitializeSettings();
                return autoFlush; 
            }

            set {
                InitializeSettings();    
                autoFlush = value;
            }
        }

        public static int IndentLevel {
            get { return indentLevel; }

            set {
                lock (critSec) {
                    // We don't want to throw here -- it is very bad form to have debug or trace
                    // code throw exceptions!
                    if (value < 0) {
                        value = 0;
                    }
                    indentLevel = value;
                    
                    if (listeners != null) {
                        foreach (TraceListener listener in Listeners) {
                            listener.IndentLevel = indentLevel;
                        }
                    }
                }
            }
        }

        public static int IndentSize {
            get { 
                InitializeSettings();
                return indentSize; 
            }
            
            set {
                InitializeSettings();    
                SetIndentSize(value);
            }
        }        

        static void SetIndentSize(int value) {
            lock (critSec) {                
                // We don't want to throw here -- it is very bad form to have debug or trace
                // code throw exceptions!            
                if (value < 0) {
                    value = 0;
                }

                indentSize = value;
                
                if (listeners != null) {
                    foreach (TraceListener listener in Listeners) {
                        listener.IndentSize = indentSize;
                    }
                } 
            }
        }

        public static void Indent() {
            lock (critSec) {
                InitializeSettings();
                indentLevel++;
                foreach (TraceListener listener in Listeners) {
                    listener.IndentLevel = indentLevel;
                }
            }
        }

        public static void Unindent() {
            lock (critSec) {
                InitializeSettings();
                if (indentLevel > 0) {
                    indentLevel--;
                }
                foreach (TraceListener listener in Listeners) {
                    listener.IndentLevel = indentLevel;
                }
            }
        }

        public static void Flush() {
            if (listeners != null) {
                lock (critSec) {
                    foreach (TraceListener listener in Listeners) {
                        listener.Flush();
                    }
                }
            }
        }

        public static void Close() {
            if (listeners != null) {
                lock (critSec) {
                    foreach (TraceListener listener in Listeners) {
                        listener.Close();
                    }
                }
            }
        }

        public static void Assert(bool condition) {
            if (condition) return;
            Fail(string.Empty);
        }

        public static void Assert(bool condition, string message) {
            if (condition) return;
            Fail(message);
        }

        public static void Assert(bool condition, string message, string detailMessage) {
            if (condition) return;
            Fail(message, detailMessage);
        }

        public static void Fail(string message) {
            Fail(message, null);        
        }        

        public static void Fail(string message, string detailMessage) {
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.Fail(message, detailMessage);
                    if (AutoFlush) listener.Flush();
                }            
            }
        }        

        private static void InitializeSettings() {
            // we want to redo this logic exactly once if the last time we entered the config
            // system was still initializing.  (ASURT 111941)
            if (!settingsInitialized || (!wasInitialized && DiagnosticsConfiguration.IsInitialized())) {
                wasInitialized  = DiagnosticsConfiguration.IsInitialized();

                // Getting IndentSize and AutoFlush will load config on demand.
                // If we load config and there are trace listeners added, we'll
                // end up recursing, but that recursion will be stopped in
                // DiagnosticsConfiguration.Initialize()           
                SetIndentSize(DiagnosticsConfiguration.IndentSize);
                autoFlush = DiagnosticsConfiguration.AutoFlush;
                settingsInitialized = true;
            }
        }

        public static void Write(string message) {
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.Write(message);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void Write(object value) {
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.Write(value);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void Write(string message, string category) {
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.Write(message, category);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void Write(object value, string category) {
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.Write(value, category);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteLine(string message) {
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.WriteLine(message);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteLine(object value) {
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.WriteLine(value);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteLine(string message, string category) {
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.WriteLine(message, category);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteLine(object value, string category) {
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.WriteLine(value, category);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteIf(bool condition, string message) {
            if (!condition) return;
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.Write(message);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteIf(bool condition, object value) {
            if (!condition) return;
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.Write(value);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteIf(bool condition, string message, string category) {
            if (!condition) return;
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.Write(message, category);
                    if (AutoFlush) listener.Flush();
                }
            }                        
        }

        public static void WriteIf(bool condition, object value, string category) {
            if (!condition) return;
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.Write(value, category);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteLineIf(bool condition, string message) {
            if (!condition) return;
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.WriteLine(message);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteLineIf(bool condition, object value) {
            if (!condition) return;
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.WriteLine(value);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteLineIf(bool condition, string message, string category) {
            if (!condition) return;
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.WriteLine(message, category);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }

        public static void WriteLineIf(bool condition, object value, string category) {
            if (!condition) return;
            lock (critSec) {
                foreach (TraceListener listener in Listeners) {
                    listener.WriteLine(value, category);
                    if (AutoFlush) listener.Flush();
                }                        
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\diagnostics\tracelisteners.cs ===
//------------------------------------------------------------------------------
// <copyright file="TraceListeners.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics {
    using System;
    using System.Collections;
    using Microsoft.Win32;
    
    /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection"]/*' />
    /// <devdoc>
    /// <para>Provides a thread-safe list of <see cref='System.Diagnostics.TraceListenerCollection'/>. A thread-safe list is synchronized.</para>
    /// </devdoc>
    public class TraceListenerCollection : IList {
        ArrayList list;

        internal TraceListenerCollection() {
            list = new ArrayList(1);
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the <see cref='TraceListener'/> at
        ///    the specified index.</para>
        /// </devdoc>
        public TraceListener this[int i] {
            get {
                return (TraceListener)list[i];
            }

            set {
                InitializeListener(value);
                list[i] = value;
            }            
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.this1"]/*' />
        /// <devdoc>
        /// <para>Gets the first <see cref='System.Diagnostics.TraceListener'/> in the list with the specified name.</para>
        /// </devdoc>
        public TraceListener this[string name] {
            get {
                foreach (TraceListener listener in this) {
                    if (listener.Name == name)
                        return listener;
                }
                return null;
            }
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of listeners in the list.
        ///    </para>
        /// </devdoc>
        public int Count { 
            get {
                return list.Count;
            }
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.Add"]/*' />
        /// <devdoc>
        /// <para>Adds a <see cref='System.Diagnostics.TraceListener'/> to the list.</para>
        /// </devdoc>
        public int Add(TraceListener listener) {                
            InitializeListener(listener);
            return ((IList)this).Add(listener);
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(TraceListener[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }        
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.AddRange1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(TraceListenerCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears all the listeners from the
        ///       list.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            list = new ArrayList();
        }        

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>Checks whether the list contains the specified 
        ///       listener.</para>
        /// </devdoc>
        public bool Contains(TraceListener listener) {
            return ((IList)this).Contains(listener);
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies a section of the current <see cref='System.Diagnostics.TraceListenerCollection'/> list to the specified array at the specified 
        ///    index.</para>
        /// </devdoc>
        public void CopyTo(TraceListener[] listeners, int index) {
            ((ICollection)this).CopyTo((Array) listeners, index);                   
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an enumerator for this list.
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return list.GetEnumerator();
        }

        internal void InitializeListener(TraceListener listener) {
            listener.IndentSize = TraceInternal.IndentSize;
            listener.IndentLevel = TraceInternal.IndentLevel;
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Gets the index of the specified listener.</para>
        /// </devdoc>
        public int IndexOf(TraceListener listener) {
            return ((IList)this).IndexOf(listener);
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>Inserts the listener at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, TraceListener listener) {
            InitializeListener(listener);
            ((IList)this).Insert(index, listener);
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the specified instance of the <see cref='System.Diagnostics.TraceListener'/> class from the list.
        ///    </para>
        /// </devdoc>
        public void Remove(TraceListener listener) {
            ((IList)this).Remove(listener);
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.Remove1"]/*' />
        /// <devdoc>
        ///    <para>Removes the first listener in the list that has the 
        ///       specified name.</para>
        /// </devdoc>
        public void Remove(string name) {
            TraceListener listener = this[name];
            if (listener != null)
                ((IList)this).Remove(listener);
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.RemoveAt"]/*' />
        /// <devdoc>
        /// <para>Removes the <see cref='System.Diagnostics.TraceListener'/> at the specified index.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            ArrayList newList = new ArrayList(list.Count);
            lock (this) {
                newList.AddRange(list);
                newList.RemoveAt(index);
                list = newList;
            }
        }

       /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.IList.this"]/*' />
       /// <internalonly/>
       object IList.this[int index] {
            get {
                return list[index];
            }

            set {
                list[index] = value;
            }
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.IList.IsReadOnly"]/*' />
        /// <internalonly/>
        bool IList.IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return false;
            }
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object value) {
            int i;            
            ArrayList newList = new ArrayList(list.Count + 1);
            lock (this) {
                newList.AddRange(list);
                i = newList.Add(value);
                list = newList;
            }        
            return i;
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object value) {
            return list.Contains(value);
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object value) {
            return list.IndexOf(value);
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object value) {
            ArrayList newList = new ArrayList(list.Count + 1);
            lock (this) {
                newList.AddRange(list);        
                newList.Insert(index, value);
                list = newList;
            }            
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object value) {
            ArrayList newList = new ArrayList(list.Count);
            lock (this) {
                newList.AddRange(list);
                newList.Remove(value);
                list = newList;
            }
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }
                                                  
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return true;
            }
        }
        
        /// <include file='doc\TraceListeners.uex' path='docs/doc[@for="TraceListenerCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            ArrayList newList = new ArrayList(list.Count + array.Length);
            lock (this) {
                newList.AddRange(list);
                newList.CopyTo(array, index);
                list = newList;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\threading\threadexceptionevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ThreadExceptionEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Threading {
    using System.Threading;
    using System.Diagnostics;
    using System;

    
    /// <include file='doc\ThreadExceptionEvent.uex' path='docs/doc[@for="ThreadExceptionEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the System.Windows.Forms.Application.ThreadException event.
    ///    </para>
    /// </devdoc>
    public class ThreadExceptionEventArgs : EventArgs {
    
        private Exception exception;
    
        /// <include file='doc\ThreadExceptionEvent.uex' path='docs/doc[@for="ThreadExceptionEventArgs.ThreadExceptionEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Threading.ThreadExceptionEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public ThreadExceptionEventArgs(Exception t) {
            exception = t;
        }

        /// <include file='doc\ThreadExceptionEvent.uex' path='docs/doc[@for="ThreadExceptionEventArgs.Exception"]/*' />
        /// <devdoc>
        /// <para>Specifies the <see cref='System.Exception'/> that occurred.</para>
        /// </devdoc>
        public Exception Exception {
            get {
                return exception;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\security\permissions\aspnethostingpermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="AspNetHostingPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Web {

    using System.Security;
    using System.Security.Permissions;
    using System.Globalization;
    
    //NOTE: While AspNetHostingPermissionAttribute resides in System.DLL,
    //      no classes from that DLL are able to make declarative usage of AspNetHostingPermission.

    [Serializable]
    public enum AspNetHostingPermissionLevel
    {
        None            = 100,
        Minimal         = 200,
        Low             = 300,
        Medium          = 400,
        High            = 500,
        Unrestricted    = 600
    }

     /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.All, AllowMultiple=true, Inherited=false )]
    [Serializable] 
    sealed public class AspNetHostingPermissionAttribute : CodeAccessSecurityAttribute
    {
        AspNetHostingPermissionLevel    _level;

        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermissionAttribute.AspNetHostingPermissionAttribute"]/*' />
        public AspNetHostingPermissionAttribute ( SecurityAction action ) : base( action ) {
            _level = AspNetHostingPermissionLevel.None;                                                            
        }

        public AspNetHostingPermissionLevel Level {
            get { 
                return _level;
            }

            set { 
                AspNetHostingPermission.VerifyAspNetHostingPermissionLevel(value, "Level");
                _level = value; 
            }
        }

        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission() {
            if (Unrestricted) {
                return new AspNetHostingPermission(PermissionState.Unrestricted);
            }
            else {
                return new AspNetHostingPermission(_level);
            }
        }
    }


    /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermission"]/*' />
    /// <devdoc>
    ///    <para>
    ///    </para>
    /// </devdoc>
    [Serializable]
    public sealed class AspNetHostingPermission :  CodeAccessPermission, IUnrestrictedPermission {
        AspNetHostingPermissionLevel    _level;

        static internal void VerifyAspNetHostingPermissionLevel(AspNetHostingPermissionLevel level, string arg) {
            switch (level) {
            case AspNetHostingPermissionLevel.Unrestricted:
            case AspNetHostingPermissionLevel.High:
            case AspNetHostingPermissionLevel.Medium:
            case AspNetHostingPermissionLevel.Low:
            case AspNetHostingPermissionLevel.Minimal:
            case AspNetHostingPermissionLevel.None:
                break;

            default:
                throw new ArgumentException(arg);
            }
        }

        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermission.AspNetHostingPermission"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the System.Net.AspNetHostingPermission
        ///       class that passes all demands or that fails all demands.
        ///    </para>
        /// </devdoc>
        public AspNetHostingPermission(PermissionState state) {
            switch (state) {
            case PermissionState.Unrestricted:
                _level = AspNetHostingPermissionLevel.Unrestricted;
                break;

            case PermissionState.None:
                _level = AspNetHostingPermissionLevel.None;
                break;

            default:
                throw new ArgumentException("state");
            }
        }

        public AspNetHostingPermission(AspNetHostingPermissionLevel level) {
            VerifyAspNetHostingPermissionLevel(level, "level");
            _level = level;
        }

        public AspNetHostingPermissionLevel Level {
            get { 
                return _level;
            }

            set { 
                VerifyAspNetHostingPermissionLevel(value, "Level");
                _level = value; 
            }
        }

        // IUnrestrictedPermission interface methods
        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermission.IsUnrestricted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Checks the overall permission state of the object.
        ///    </para>
        /// </devdoc>
        public bool IsUnrestricted() {
            return _level == AspNetHostingPermissionLevel.Unrestricted;
        }

        // IPermission interface methods
        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermission.Copy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a copy of a System.Net.AspNetHostingPermission
        ///    </para>
        /// </devdoc>
        public override IPermission Copy () {
            return new AspNetHostingPermission(_level);
        }

        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermission.Union"]/*' />
        /// <devdoc>
        /// <para>Returns the logical union between two System.Net.AspNetHostingPermission instances.</para>
        /// </devdoc>
        public override IPermission Union(IPermission target) {
            if (target == null) {
                return Copy();
            }

            if (target.GetType() !=  typeof(AspNetHostingPermission)) {
                throw new ArgumentException("target");
            }

            AspNetHostingPermission other = (AspNetHostingPermission) target;
            if (Level >= other.Level) {
                return new AspNetHostingPermission(Level);
            }
            else {
                return new AspNetHostingPermission(other.Level);
            }
        }

        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermission.Intersect"]/*' />
        /// <devdoc>
        /// <para>Returns the logical intersection between two System.Net.AspNetHostingPermission instances.</para>
        /// </devdoc>
        public override IPermission Intersect(IPermission target) {
            if (target == null) {
                return Copy();
            }

            if (target.GetType() !=  typeof(AspNetHostingPermission)) {
                throw new ArgumentException("target");
            }

            AspNetHostingPermission other = (AspNetHostingPermission) target;
            if (Level <= other.Level) {
                return new AspNetHostingPermission(Level);
            }
            else {
                return new AspNetHostingPermission(other.Level);
            }
        }


        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermission.IsSubsetOf"]/*' />
        /// <devdoc>
        /// <para>Compares two System.Net.AspNetHostingPermission instances.</para>
        /// </devdoc>
        public override bool IsSubsetOf(IPermission target) {
            if (target == null) {
                return _level == AspNetHostingPermissionLevel.None;
            }

            if (target.GetType() != typeof(AspNetHostingPermission)) {
                throw new ArgumentException("target");
            }

            AspNetHostingPermission other = (AspNetHostingPermission) target;
            return Level <= other.Level;
        }

        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermission.FromXml"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override void FromXml(SecurityElement securityElement) {
            if (securityElement == null) {
                throw new ArgumentNullException("securityElement");
            }

            if (!securityElement.Tag.Equals("IPermission")) {
                throw new ArgumentException("securityElement");
            }

            string className = securityElement.Attribute("class");
            if (className == null) {
                throw new ArgumentException("securityElement");
            }

            if (className.IndexOf(this.GetType().FullName ) < 0) {
                throw new ArgumentException("securityElement");
            }

            string version = securityElement.Attribute("version");
            if (string.Compare(version, "1", true, CultureInfo.InvariantCulture) != 0) {
                throw new ArgumentException("version");
            }

            string level = securityElement.Attribute("Level");
            if (level == null) {
                _level = AspNetHostingPermissionLevel.None;
            }
            else {
                _level = (AspNetHostingPermissionLevel) Enum.Parse(typeof(AspNetHostingPermissionLevel), level);
            }
        }

        /// <include file='doc\AspNetHostingPermission.uex' path='docs/doc[@for="AspNetHostingPermission.ToXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override SecurityElement ToXml() {
            SecurityElement securityElement = new SecurityElement("IPermission");
            securityElement.AddAttribute("class", this.GetType().FullName + ", " + this.GetType().Module.Assembly.FullName.Replace( '\"', '\'' ));
            securityElement.AddAttribute("version", "1" );
            securityElement.AddAttribute("Level", Enum.GetName(typeof(AspNetHostingPermissionLevel), _level));

            return securityElement;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\security\permissions\resourcepermissionbaseentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResourcePermissionBaseEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Security.Permissions {
    
    /// <include file='doc\ResourcePermissionBaseEntry.uex' path='docs/doc[@for="ResourcePermissionBaseEntry"]/*' />
    [
    Serializable()
    ]
    public class ResourcePermissionBaseEntry { 
        private string[] accessPath;
        private int permissionAccess;

        /// <include file='doc\ResourcePermissionBaseEntry.uex' path='docs/doc[@for="ResourcePermissionBaseEntry.ResourcePermissionBaseEntry"]/*' />                       
        public ResourcePermissionBaseEntry() {
           this.permissionAccess = 0;
           this.accessPath = new string[0]; 
        }

        /// <include file='doc\ResourcePermissionBaseEntry.uex' path='docs/doc[@for="ResourcePermissionBaseEntry.ResourcePermissionBaseEntry1"]/*' />                       
        public ResourcePermissionBaseEntry(int permissionAccess, string[] permissionAccessPath) {
            if (permissionAccessPath == null)  
                throw new ArgumentNullException("permissionAccessPath");
                    
            this.permissionAccess = permissionAccess;
            this.accessPath = permissionAccessPath;
        }

        /// <include file='doc\ResourcePermissionBaseEntry.uex' path='docs/doc[@for="ResourcePermissionBaseEntry.PermissionAccess"]/*' />                                        
        public int PermissionAccess {
            get {
                return this.permissionAccess;
            }                       
        }
        
        /// <include file='doc\ResourcePermissionBaseEntry.uex' path='docs/doc[@for="ResourcePermissionBaseEntry.PermissionAccessPath"]/*' />                       
        public string[] PermissionAccessPath {
            get {
                return this.accessPath;
            }            
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\security\permissions\resourcepermissionbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResourcePermissionBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Security.Permissions {
    using System;    
    using System.Text;
    using System.Reflection;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;    
    using System.Collections.Specialized;  
    using System.Runtime.InteropServices;
    using System.Globalization;
    
    /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Serializable(),
    SecurityPermissionAttribute(SecurityAction.InheritanceDemand, ControlEvidence = true, ControlPolicy = true)
    ]
    public abstract class ResourcePermissionBase :  CodeAccessPermission, IUnrestrictedPermission {    
        private static string computerName;
        private string[] tagNames;
        private Type permissionAccessType;                        
        private bool isUnrestricted;                  
        private Hashtable rootTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));

        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.Any"]/*' />
        public const string Any = "*";        
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.Local"]/*' />
        public const string Local = ".";      
        
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.ResourcePermissionBase2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected ResourcePermissionBase() {
        }
                                    
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.ResourcePermissionBase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected ResourcePermissionBase(PermissionState state) {
            if (state == PermissionState.Unrestricted)
                this.isUnrestricted = true;
            else if (state == PermissionState.None)     
                this.isUnrestricted = false;         
        }                                                                                                                                                                                                                                      

        private string ComputerName {
            get {                
                if (computerName == null) {
                    lock (typeof(ResourcePermissionBase)) {
                        if (computerName == null) {
                            StringBuilder sb = new StringBuilder(256);
                            UnsafeNativeMethods.GetComputerName(sb, new int[] {sb.Capacity});
                            computerName = sb.ToString();
                        }                            
                    }                        
                }                    
                
                return computerName;
            }
        }
                                                                                                                                                                                                   
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.PermissionAccessType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected Type PermissionAccessType {
            get {
                return this.permissionAccessType;
            }
            
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                    
                if (!value.IsEnum)
                    throw new ArgumentException("value");
                    
                this.permissionAccessType = value;                    
            }             
        }  
        
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.TagNames"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected string[] TagNames {
            get {
                return this.tagNames;
            }
            
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                    
                if (value.Length == 0)
                    throw new ArgumentException("value");
                                        
                this.tagNames = value;
            }
        }                                                                                                                            
                                               
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.AddAccess"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void AddPermissionAccess(ResourcePermissionBaseEntry entry) {                        
            if (entry == null)
                throw new ArgumentNullException("entry");
                
            if (entry.PermissionAccessPath.Length != this.TagNames.Length)
                throw new InvalidOperationException(SR.GetString(SR.PermissionNumberOfElements));
                                                                                                                                                                                   
            Hashtable currentTable = this.rootTable;    
            string[] accessPath = entry.PermissionAccessPath;
            for (int index = 0; index < accessPath.Length - 1; ++ index) {                                
                if (currentTable.ContainsKey(accessPath[index])) 
                    currentTable = (Hashtable)currentTable[accessPath[index]];                                                                                  
                else {
                    Hashtable newHashTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                    currentTable[accessPath[index]] = newHashTable;   
                    currentTable = newHashTable;
                }                                  
            }
                                    
            if (currentTable.ContainsKey(accessPath[accessPath.Length - 1]))
                throw new InvalidOperationException(SR.GetString(SR.PermissionItemExists));
                                                                                                           
            currentTable[accessPath[accessPath.Length - 1]] = entry.PermissionAccess; 
        }         
        
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.Clear"]/*' />
        protected void Clear() {            
            this.rootTable.Clear();
        }
                                                                                    
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.Copy"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override IPermission Copy() {
            ResourcePermissionBase permission = CreateInstance();
            permission.tagNames = this.tagNames;
            permission.permissionAccessType = this.permissionAccessType;                        
            permission.isUnrestricted = this.isUnrestricted;
            permission.rootTable = CopyChildren(this.rootTable, 0);                            
            return permission;            
        }
                                                                    
        private Hashtable CopyChildren(object currentContent, int tagIndex) {
            IDictionaryEnumerator contentEnumerator = ((Hashtable)currentContent).GetEnumerator();  
            Hashtable newTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            while(contentEnumerator.MoveNext()) {                
                if (tagIndex < (this.TagNames.Length -1)) 
                    newTable[contentEnumerator.Key] = CopyChildren(contentEnumerator.Value, tagIndex + 1);                                                        
                else 
                    newTable[contentEnumerator.Key] = contentEnumerator.Value;
            }                
            
            return newTable;
        }           

        private ResourcePermissionBase CreateInstance() {
            // SECREVIEW: Here we are using reflection to create an instance of the current
            // type (which is a subclass of ResourcePermissionBase).
            new PermissionSet(PermissionState.Unrestricted).Assert();
            return (ResourcePermissionBase)Activator.CreateInstance(this.GetType(), BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);
        }
            
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.GetAccess"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        protected ResourcePermissionBaseEntry[] GetPermissionEntries() {
            return GetChildrenAccess(this.rootTable, 0);
        }   
                                                                 
        private ResourcePermissionBaseEntry[] GetChildrenAccess(object currentContent, int tagIndex) {
            IDictionaryEnumerator contentEnumerator = ((Hashtable)currentContent).GetEnumerator();  
            ArrayList list = new ArrayList();                          
            while(contentEnumerator.MoveNext()) {                
                if (tagIndex < (this.TagNames.Length -1)) {
                    ResourcePermissionBaseEntry[] currentEntries = GetChildrenAccess(contentEnumerator.Value, tagIndex + 1);
                    for (int index = 0; index < currentEntries.Length; ++index) 
                        currentEntries[index].PermissionAccessPath[tagIndex] = (string)contentEnumerator.Key;                        
                    
                     list.AddRange(currentEntries);
                }                    
                else {
                    ResourcePermissionBaseEntry entry = new ResourcePermissionBaseEntry((int)contentEnumerator.Value, new string[this.TagNames.Length]);                    
                    entry.PermissionAccessPath[tagIndex] = (string)contentEnumerator.Key;
                            
                    list.Add(entry);                                                        
                }
            }                
            
            return (ResourcePermissionBaseEntry[])list.ToArray(typeof(ResourcePermissionBaseEntry));
        }
                                             
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.FromXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void FromXml(SecurityElement securityElement) {                        
            string unrestrictedValue = securityElement.Attribute("Unrestricted");            
            if (unrestrictedValue != null && (string.Compare(unrestrictedValue, "true", true, CultureInfo.InvariantCulture) == 0)) {
                this.isUnrestricted = true;
                return;
            }                                                                                              
            
            this.rootTable = (Hashtable)ReadChildren(securityElement, 0);            
        }
                                         
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.Intersect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override IPermission Intersect(IPermission target) {            
            if (target == null)
                return null;
                
            if (target.GetType() != this.GetType())
                throw new ArgumentException("target");
                       
            ResourcePermissionBase targetPermission = (ResourcePermissionBase)target;            
            if (this.IsUnrestricted())
                return targetPermission.Copy();
                
            if (targetPermission.IsUnrestricted())
                return this.Copy();
                            
            ResourcePermissionBase newPermission = null;
            Hashtable newPermissionRootTable = (Hashtable)IntersectContents(this.rootTable, targetPermission.rootTable);
            if (newPermissionRootTable != null) {
                newPermission = CreateInstance();
                newPermission.rootTable = newPermissionRootTable;
            }
            return newPermission;                                                                                                                      
        }                
        
        private object IntersectContents(object currentContent, object targetContent) {        
            if (currentContent is int) {
                int currentAccess = (int)currentContent;
                int targetAccess = (int)targetContent;
                return  (currentAccess & targetAccess);
            }
            else {            
                Hashtable newContents = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                
                //Before executing the intersect operation, need to
                //resolve the "." entries
                object currentLocalContent = ((Hashtable)currentContent)[Local];                
                object currentComputerNameContent = ((Hashtable)currentContent)[ComputerName];                
                if (currentLocalContent != null || currentComputerNameContent != null) {                      
                    object targetLocalContent = ((Hashtable)targetContent)[Local];                
                    object targetComputerNameContent = ((Hashtable)targetContent)[ComputerName];                
                    if (targetLocalContent != null || targetComputerNameContent != null) {                      
                        object currentLocalMergedContent = currentLocalContent;
                        if (currentLocalContent != null && currentComputerNameContent != null)
                            currentLocalMergedContent = UnionOfContents(currentLocalContent, currentComputerNameContent);
                        else if (currentComputerNameContent != null)  
                            currentLocalMergedContent = currentComputerNameContent; 
                            
                        object targetLocalMergedContent = targetLocalContent;
                        if (targetLocalContent != null && targetComputerNameContent != null)
                            targetLocalMergedContent = UnionOfContents(targetLocalContent, targetComputerNameContent);
                        else if (targetComputerNameContent != null)  
                            targetLocalMergedContent = targetComputerNameContent;   
                            
                        object computerNameValue = IntersectContents(currentLocalMergedContent, targetLocalMergedContent);
                        if (computerNameValue != null) {
                            // There should be no computer name key added if the information
                            // was not specified in one of the targets
                            if (currentComputerNameContent != null || targetComputerNameContent != null) {
                                newContents[ComputerName] = computerNameValue;
                            }
                            else {
                                newContents[Local] = computerNameValue;
                            }
                        }
                    }                                                                              
                }                                        
                                                 
                IDictionaryEnumerator contentEnumerator;
                Hashtable contentsTable;
                if (((Hashtable)currentContent).Count <  ((Hashtable)targetContent).Count) {
                    contentEnumerator = ((Hashtable)currentContent).GetEnumerator();
                    contentsTable = ((Hashtable)targetContent);
                }
                else{
                    contentEnumerator = ((Hashtable)targetContent).GetEnumerator();
                    contentsTable = ((Hashtable)currentContent);
                }
                
                //The wildcard entries intersection should be treated 
                //as any other entry.                            
                while(contentEnumerator.MoveNext()) {                    
                    string currentKey = (string)contentEnumerator.Key;
                    if (contentsTable.ContainsKey(currentKey) && 
                          currentKey != Local && 
                          currentKey != ComputerName)  {                        
                          
                        object currentValue = contentEnumerator.Value;
                        object targetValue = contentsTable[currentKey];
                        object newValue = IntersectContents(currentValue, targetValue);
                        if (newValue != null) {
                            newContents[currentKey] = newValue;                            
                        }
                    }                    
                }                                 
                
                return (newContents.Count > 0) ? newContents : null;
            }                                                                   
        }
        
        private bool IsContentSubset(object currentContent, object targetContent) {
            if (currentContent is int) {
                int currentAccess = (int)currentContent;
                int targetAccess = (int)targetContent;
                if ((currentAccess & targetAccess) != currentAccess)
                    return false;
                    
                return true;                    
            }
            else {
                
                //Before executing the intersect operation, need to
                //resolve the "." entries
                object currentLocalContent = ((Hashtable)currentContent)[Local];                
                object currentComputerNameContent = ((Hashtable)currentContent)[ComputerName];                
                if (currentLocalContent != null || currentComputerNameContent != null) {                      
                    object targetLocalContent = ((Hashtable)targetContent)[Local];                
                    object targetComputerNameContent = ((Hashtable)targetContent)[ComputerName];                
                    if (targetLocalContent != null || targetComputerNameContent != null) {                      
                        object currentLocalMergedContent = currentLocalContent;
                        if (currentLocalContent != null && currentComputerNameContent != null)
                            currentLocalMergedContent = UnionOfContents(currentLocalContent, currentComputerNameContent);
                        else if (currentComputerNameContent != null)  
                            currentLocalMergedContent = currentComputerNameContent; 
                            
                        object targetLocalMergedContent = targetLocalContent;
                        if (targetLocalContent != null && targetComputerNameContent != null)
                            targetLocalMergedContent = UnionOfContents(targetLocalContent, targetComputerNameContent);
                        else if (targetComputerNameContent != null)  
                            targetLocalMergedContent = targetComputerNameContent;   
                            
                        if (!IsContentSubset(currentLocalMergedContent, targetLocalMergedContent))   
                            return false;
                    }                                                                              
                }            
            
                //If the target table contains a wild card, all the current entries need to be
                //a subset of the target.                      
                IDictionaryEnumerator contentEnumerator;                                                                   
                object targetAnyContent = ((Hashtable)targetContent)[Any];
                if (targetAnyContent != null) {
                    contentEnumerator = ((Hashtable)currentContent).GetEnumerator();                            
                    while(contentEnumerator.MoveNext()) {
                        object currentContentValue = contentEnumerator.Value;
                        if (!IsContentSubset(currentContentValue, targetAnyContent))   
                            return false;
                    }
                    
                    return true;
                }
                
                //If the current table contains a wild card it can be treated as any other entry.
                contentEnumerator = ((Hashtable)currentContent).GetEnumerator();            
                while(contentEnumerator.MoveNext()) {
                    string currentContentKey = (string)contentEnumerator.Key;      
                    if (currentContentKey != Local && 
                          currentContentKey != ComputerName) {          
                          
                        if (!((Hashtable)targetContent).ContainsKey(currentContentKey)) 
                            return false;
                        else {
                            object currentContentValue = contentEnumerator.Value;
                            object targetContentValue = ((Hashtable)targetContent)[currentContentKey];
                            if (!IsContentSubset(currentContentValue, targetContentValue))   
                                return false;
                        }                    
                    }                        
                }
                                 
                return true;                                        
            }
        }
                
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.IsSubsetOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsSubsetOf(IPermission target) {
            if (target == null) 
                return false;

            if (target.GetType() != this.GetType())
                return false;
                                        
            ResourcePermissionBase targetPermission = (ResourcePermissionBase)target;            
            if (targetPermission.IsUnrestricted())
                return true;
            else if (this.IsUnrestricted())
                return false;
            
            return IsContentSubset(this.rootTable, targetPermission.rootTable);                                                 
            
        }    
                                      
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.IsUnrestricted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsUnrestricted() {
            return this.isUnrestricted;
        }

        private object ReadChildren(SecurityElement securityElement, int tagIndex) {
            Hashtable newTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            if (securityElement.Children != null) {            
                for (int index = 0; index < securityElement.Children.Count; ++ index) {
                    SecurityElement currentElement =  (SecurityElement)securityElement.Children[index];
                    if (currentElement.Tag == this.TagNames[tagIndex]) {
                        string contentName = currentElement.Attribute("name");
                        
                        if (tagIndex < (this.TagNames.Length -1))
                            newTable[contentName] = ReadChildren(currentElement, tagIndex +1);
                        else {
                            string accessString = currentElement.Attribute("access");                                             
                            int permissionAccess = 0;                                                  
                            if (accessString != null) { 
                                string[] accessArray = accessString.Split(new char[]{'|'});
                                for (int index2 = 0; index2 < accessArray.Length; ++ index2) {
                                    string currentAccess =  accessArray[index2].Trim();
                                    if (Enum.IsDefined(this.PermissionAccessType, currentAccess)) 
                                        permissionAccess = permissionAccess | (int)Enum.Parse(this.PermissionAccessType, currentAccess);                                         
                                }                                
                            }  
                            
                            newTable[contentName] = permissionAccess;
                        }                            
                    }                                                                       
                }                                           
            }
            return newTable;                                                   
        }   
        
         /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.RemoveAccess"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        protected void RemovePermissionAccess(ResourcePermissionBaseEntry entry) {
            if (entry == null)
                throw new ArgumentNullException("entry");
                
            if (entry.PermissionAccessPath.Length != this.TagNames.Length)
                throw new InvalidOperationException(SR.GetString(SR.PermissionNumberOfElements));
        
            Hashtable currentTable = this.rootTable;    
            string[] accessPath = entry.PermissionAccessPath;
            for (int index = 0; index < accessPath.Length; ++ index) { 
                if (currentTable == null || !currentTable.ContainsKey(accessPath[index])) 
                    throw new InvalidOperationException(SR.GetString(SR.PermissionItemDoesntExist));
                else {                    
                    Hashtable oldTable = currentTable;
                    if (index < accessPath.Length - 1) {
                        currentTable = (Hashtable)currentTable[accessPath[index]];                                                                                  
                        if (currentTable.Count == 1)
                            oldTable.Remove(accessPath[index]);
                    }                        
                    else {                         
                        currentTable = null;
                        oldTable.Remove(accessPath[index]);
                    }                                                                                            
                }                                                                                                
            }
        }
                                                                                                                                           
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.ToXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override SecurityElement ToXml() {
            SecurityElement root = new SecurityElement("IPermission");
            Type type = this.GetType();
            root.AddAttribute("class", type.FullName + ", " + type.Module.Assembly.FullName.Replace('\"', '\''));            
            root.AddAttribute("version", "1");            
            
            if (this.isUnrestricted) {
                root.AddAttribute("Unrestricted", "true");
                return root;                    
            }                        
                                
            WriteChildren(root, this.rootTable, 0);                        
            return root;        
        }                    
                                                                       
        /// <include file='doc\ResourcePermissionBase.uex' path='docs/doc[@for="ResourcePermissionBase.Union"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override IPermission Union(IPermission target) {            
            if (target == null)
                return this.Copy();
        
            if (target.GetType() != this.GetType())                                                 
                throw new ArgumentException("target");
                        
            ResourcePermissionBase targetPermission = (ResourcePermissionBase)target;                                        
            ResourcePermissionBase newPermission = null;
            if (this.IsUnrestricted() || targetPermission.IsUnrestricted()) {
                newPermission = CreateInstance();
                newPermission.isUnrestricted = true;
            }                                       
            else {           
                Hashtable newPermissionRootTable = (Hashtable)UnionOfContents(this.rootTable, targetPermission.rootTable);
                if (newPermissionRootTable != null) {
                    newPermission = CreateInstance();
                    newPermission.rootTable = newPermissionRootTable;
                }
            }
            return newPermission;                                                                                                   
        }                                       

        private object UnionOfContents(object currentContent, object targetContent) {
            if (currentContent is int) {
                int currentAccess = (int)currentContent;
                int targetAccess = (int)targetContent;
                return (currentAccess | targetAccess);
            }
            else {
                //The wildcard and "." entries can be merged as
                //any other entry.
                Hashtable newContents = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                IDictionaryEnumerator contentEnumerator = ((Hashtable)currentContent).GetEnumerator();
                IDictionaryEnumerator targetContentEnumerator = ((Hashtable)targetContent).GetEnumerator();                            
                while(contentEnumerator.MoveNext())
                    newContents[(string)contentEnumerator.Key] = contentEnumerator.Value;                            
                                
                while(targetContentEnumerator.MoveNext()) {
                    if (!newContents.ContainsKey(targetContentEnumerator.Key)) 
                        newContents[targetContentEnumerator.Key] = targetContentEnumerator.Value;
                    else {
                        object currentValue = newContents[targetContentEnumerator.Key];
                        object targetValue =targetContentEnumerator.Value;
                        newContents[targetContentEnumerator.Key] = UnionOfContents(currentValue, targetValue);                     
                    }                    
                }                                                                                                                                                                                
                
                return (newContents.Count > 0) ? newContents : null;
            }
        }

        private void WriteChildren(SecurityElement currentElement, object currentContent, int tagIndex) {
            IDictionaryEnumerator contentEnumerator = ((Hashtable)currentContent).GetEnumerator();            
            while(contentEnumerator.MoveNext()) {
                SecurityElement contentElement = new SecurityElement(this.TagNames[tagIndex]);
                currentElement.AddChild(contentElement);
                contentElement.AddAttribute("name", (string)contentEnumerator.Key); 
                
                if (tagIndex < (this.TagNames.Length -1))
                    WriteChildren(contentElement, contentEnumerator.Value, tagIndex + 1);
                else {
                    StringBuilder accessStringBuilder = null;                     
                    int currentAccess = (int)contentEnumerator.Value;
                    if (this.PermissionAccessType != null && currentAccess != 0) {                                                             
                        int[] enumValues =  (int[])Enum.GetValues(this.PermissionAccessType);                    
                        Array.Sort(enumValues);
                        for (int index = (enumValues.Length -1); index >= 0; -- index) {
                            if (enumValues[index] != 0 && ((currentAccess & enumValues[index]) == enumValues[index])) {
                                if (accessStringBuilder == null)
                                    accessStringBuilder = new StringBuilder();
                                else
                                    accessStringBuilder.Append("|");
                                                                            
                                accessStringBuilder.Append(Enum.GetName(this.PermissionAccessType, enumValues[index]));
                                currentAccess = currentAccess & (enumValues[index] ^ enumValues[index]);                                
                            }
                        }
                    }
                    
                    if (accessStringBuilder != null)
                        contentElement.AddAttribute("access", accessStringBuilder.ToString());
                }                                                                                    
            }
        }
                                                                         
        [SuppressUnmanagedCodeSecurity()]                                                                                                                   
        private class UnsafeNativeMethods {         
            [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
            public static extern bool GetComputerName(StringBuilder lpBuffer, int[] nSize);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\threading\threadexceptioneventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ThreadExceptionEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Threading {
    using System.Threading;
    using System.Diagnostics;

    using System;

    /// <include file='doc\ThreadExceptionEventHandler.uex' path='docs/doc[@for="ThreadExceptionEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the System.Windows.Forms.Application.OnThreadException
    /// event of a Thread.OnThreadException.</para>
    /// </devdoc>
    public delegate void ThreadExceptionEventHandler(object sender, ThreadExceptionEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\configurationexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConfigurationException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Configuration {
    using System.Globalization;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;
    using System.Xml;

    /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException"]/*' />
    /// <devdoc>
    /// A config exception can contain a filename (of a config file)
    /// and a line number (of the location in the file in which a problem was
    /// encountered).
    /// 
    /// Section handlers should throw this exception (or subclasses)
    /// together with filename and line nubmer information where possible.
    /// </devdoc>
    [Serializable]
    public class ConfigurationException : SystemException {

        private String _filename;
        private int _line;


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.ConfigurationException"]/*' />
        /// <devdoc>
        ///    <para>Default ctor is required for serialization.</para>
        /// </devdoc>
        public ConfigurationException()
        : base() {
            HResult = HResults.Configuration;
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.ConfigurationException7"]/*' />
        /// <devdoc>
        ///    <para>Default ctor is required for serialization.</para>
        /// </devdoc>
        protected ConfigurationException(SerializationInfo info, StreamingContext context) 
        : base(info, context) { 
            HResult = HResults.Configuration;
            _filename = info.GetString("filename");
            _line = info.GetInt32("line");
        }

        
        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.ConfigurationException1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ConfigurationException(String message)
        : base(message) {
            HResult = HResults.Configuration;
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.ConfigurationException2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ConfigurationException(String message, Exception inner)
        : base(message, inner) {
            HResult = HResults.Configuration;
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.ConfigurationException3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ConfigurationException(String message, XmlNode node) 
        : this(message, InternalGetXmlNodeFilename(node), GetXmlNodeLineNumber(node)) {
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.ConfigurationException4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ConfigurationException(String message, Exception inner, XmlNode node)
        : this(message, inner, InternalGetXmlNodeFilename(node), GetXmlNodeLineNumber(node)) {
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.ConfigurationException5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ConfigurationException(String message, String filename, int line)
        : base(message) {
            _filename = filename;
            _line = line;
            HResult = HResults.Configuration;
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.ConfigurationException6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ConfigurationException(String message, Exception inner, String filename, int line)
        : base(message, inner) {
            _filename = filename;
            _line = line;
            HResult = HResults.Configuration;
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            base.GetObjectData(info, context);
            info.AddValue("filename", _filename);
            info.AddValue("line", _line);
        }

        
        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.Message"]/*' />
        /// <devdoc>
        ///    <para>The message includes the file/line number information.  
        ///       To get the message without the extra information, use BareMessage.
        ///    </para>
        /// </devdoc>
        public override String Message {
            get {
                string file = Filename;
                if (file != null && file.Length > 0) {
                    if (Line != 0)
                        return base.Message + " (" + file + " line " + Line.ToString() + ")";
                    else
                        return base.Message + " (" + file + ")";
                }
                else if (Line != 0) {
                    return base.Message + " (line " + Line.ToString("G") + ")";
                }
                return base.Message;
            }
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.BareMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String BareMessage {
            get {
                return base.Message;
            }
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.Filename"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public String Filename {
            get {
                return SafeFilename(_filename);
            }
        }


        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.Line"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Line {
            get {
                return _line;
            }
        }


        // 
        // Internal XML Error Info Helpers
        //
        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.GetXmlNodeLineNumber"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int GetXmlNodeLineNumber(XmlNode node) {
            
            IConfigXmlNode configNode = node as IConfigXmlNode;

            if (configNode != null) {
                return configNode.LineNumber;
            }
            return 0;
        }

        // 
        // Internal Helper to strip a full path to just filename.ext when caller 
        // does not have path discovery to the path (used for sane error handling).
        //
        internal static string SafeFilename(string fullFilenamePath) {
            if (fullFilenamePath == null || fullFilenamePath.Length == 0) {
                return fullFilenamePath;
            }

            // configuration file can be an http URL in IE
            if (String.Compare(fullFilenamePath, 0, "http", 0, 4, true, CultureInfo.InvariantCulture ) == 0) {
                return fullFilenamePath;
            }

            // System.Web.Configuration and others might give us non-rooted paths
            // If not rooted FileIOPermission will blow
            if (!Path.IsPathRooted(fullFilenamePath)) {
                return fullFilenamePath;
            }

            // secure path discovery pattern reused from FileStream
            bool canGiveFullPath = false;
            try {
                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, fullFilenamePath).Demand();
                canGiveFullPath = true;
            }
            catch(SecurityException) {}

            if (canGiveFullPath) {
                return fullFilenamePath;
            }
            
            // if in secure context return just filename.ext
            return Path.GetFileName(fullFilenamePath);
        }

        /// <include file='doc\ConfigurationException.uex' path='docs/doc[@for="ConfigurationException.GetXmlNodeFilename"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static string GetXmlNodeFilename(XmlNode node) {
            
            return SafeFilename(InternalGetXmlNodeFilename(node));
        }

        internal static string InternalGetXmlNodeFilename(XmlNode node) {
            IConfigXmlNode configNode = node as IConfigXmlNode;

            if (configNode != null) {
                return configNode.Filename;
            }
            return "";
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\configxmldocument.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConfigXmlDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Configuration
{
    using System.Diagnostics;
    using System.IO;
    using System.Xml;
    using System.Security.Permissions;


    internal interface IConfigXmlNode {
        string Filename { get; }
        int LineNumber { get; }
    }

    /// <include file='doc\ConfigXmlDocument.uex' path='docs/doc[@for="ConfigXmlDocument"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// <para>
    /// ConfigXmlDocument - the default Xml Document doesn't track line numbers, and line
    /// numbers are necessary to display source on config errors.
    /// These classes wrap corresponding System.Xml types and also carry 
    /// the necessary information for reporting filename / line numbers.
    /// Note: these classes will go away if webdata ever decides to incorporate line numbers
    /// into the default XML classes.  This class could also go away if webdata brings back
    /// the UserData property to hang any info off of any node.
    /// </para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    public sealed class ConfigXmlDocument : XmlDocument, IConfigXmlNode {
        XmlTextReader _reader;
        int _lineOffset;
        string _filename;

        /// <internalonly/>
        int IConfigXmlNode.LineNumber {
            get { 
                if (_reader == null) {
                    return 0;
                }
                
                if (_lineOffset > 0) {
                    return _reader.LineNumber + _lineOffset - 1;
                }
                
                return _reader.LineNumber;
            }
        }

        /// <internalonly/>
        public int LineNumber { get { return ((IConfigXmlNode)this).LineNumber; } }

        /// <internalonly/>
        public string Filename {
            get { return ConfigurationException.SafeFilename(_filename); }
        }

        /// <internalonly/>
        string IConfigXmlNode.Filename { 
            get { return _filename; } 
        }

        /// <internalonly/>
        public override void Load(string filename) {
            _filename = filename;
            try {
                _reader = new XmlTextReader(filename);
                base.Load(_reader);
            }
            finally {
                if (_reader != null) {
                    _reader.Close();
                    _reader = null;
                }
            }
        }

        internal XmlNode ReadConfigNode(string filename, XmlTextReader sourceReader) {
            _filename = filename;
            _reader = sourceReader; // pull line numbers from original reader
            try {
                return base.ReadNode(sourceReader);
            }
            finally {
                _reader = null;
            }    
        }    

        /// <internalonly/>
        public void LoadSingleElement(string filename, XmlTextReader sourceReader) {
            _filename = filename;
            _lineOffset = sourceReader.LineNumber;
            string outerXml = sourceReader.ReadOuterXml();
            
            try {
                _reader = new XmlTextReader(new StringReader(outerXml), sourceReader.NameTable);
                base.Load(_reader);
            }
            finally {
                if (_reader != null) {
                    _reader.Close();
                    _reader = null;
                }
            }
        }

        /// <internalonly/>
        public override XmlAttribute CreateAttribute( string prefix, string localName, string namespaceUri ) {
            return new ConfigXmlAttribute( _filename, LineNumber, prefix, localName, namespaceUri, this );
        }
        /// <internalonly/>
        public override XmlElement CreateElement( string prefix, string localName, string namespaceUri) {
            return new ConfigXmlElement( _filename, LineNumber, prefix, localName, namespaceUri, this );
        }
        /// <internalonly/>
        public override XmlText CreateTextNode(String text) {
            return new ConfigXmlText( _filename, LineNumber, text, this );
        }
        /// <internalonly/>
        public override XmlCDataSection CreateCDataSection(String data) {
            return new ConfigXmlCDataSection( _filename, LineNumber, data, this );
        }
        /// <internalonly/>
        public override XmlComment CreateComment(String data) {
            return new ConfigXmlComment( _filename, LineNumber, data, this );
        }
        /// <internalonly/>
        public override XmlSignificantWhitespace CreateSignificantWhitespace(String data) {
            return new ConfigXmlSignificantWhitespace( _filename, LineNumber, data, this );
        }
        /// <internalonly/>
        public override XmlWhitespace CreateWhitespace(String data) {
            return new ConfigXmlWhitespace( _filename, LineNumber, data, this );
        }
    }


    internal sealed class ConfigXmlElement : XmlElement, IConfigXmlNode {
        int _line;
        string _filename;

        public ConfigXmlElement( string filename, int line, string prefix, string localName, string namespaceUri, XmlDocument doc )
            : base( prefix, localName, namespaceUri, doc) {
            _line = line;
            _filename = filename;
        }
        int IConfigXmlNode.LineNumber {
            get { return _line; }
        }
        string IConfigXmlNode.Filename {
            get { return _filename; }
        }
        public override XmlNode CloneNode(bool deep) {
            XmlNode cloneNode = base.CloneNode(deep);
            ConfigXmlElement clone = cloneNode as ConfigXmlElement;
            if (clone != null) {
                clone._line = _line;
                clone._filename = _filename;
            }
            return cloneNode;
        }
    }

    internal sealed class ConfigXmlAttribute : XmlAttribute, IConfigXmlNode {
        int _line;
        string _filename;                

        public ConfigXmlAttribute( string filename, int line, string prefix, string localName, string namespaceUri, XmlDocument doc )
            : base( prefix, localName, namespaceUri, doc ) {
            _line = line;
            _filename = filename;
        }
        int IConfigXmlNode.LineNumber {
            get { return _line; }
        }
        string IConfigXmlNode.Filename {
            get { return _filename; }
        }
        public override XmlNode CloneNode(bool deep) {
            XmlNode cloneNode = base.CloneNode(deep);
            ConfigXmlAttribute clone = cloneNode as ConfigXmlAttribute;
            if (clone != null) {
                clone._line = _line;
                clone._filename = _filename;
            }
            return cloneNode;
        }
    }

    internal sealed class ConfigXmlText : XmlText, IConfigXmlNode {
        int _line;
        string _filename;

        public ConfigXmlText( string filename, int line, string strData, XmlDocument doc )
            : base( strData, doc ) {
            _line = line;
            _filename = filename;
        }
        int IConfigXmlNode.LineNumber {
            get { return _line; }
        }
        string IConfigXmlNode.Filename {
            get { return _filename; }
        }
        public override XmlNode CloneNode(bool deep) {
            XmlNode cloneNode = base.CloneNode(deep);
            ConfigXmlText clone = cloneNode as ConfigXmlText;
            if (clone != null) {
                clone._line = _line;
                clone._filename = _filename;
            }
            return cloneNode;
        }
    }
    internal sealed class ConfigXmlCDataSection : XmlCDataSection, IConfigXmlNode {
        int _line;
        string _filename;

        public ConfigXmlCDataSection( string filename, int line, string data, XmlDocument doc )
            : base( data, doc) {
            _line = line;
            _filename = filename;
        }
        int IConfigXmlNode.LineNumber {
            get { return _line; }
        }
        string IConfigXmlNode.Filename {
            get { return _filename; }
        }
        public override XmlNode CloneNode(bool deep) {
            XmlNode cloneNode = base.CloneNode(deep);
            ConfigXmlCDataSection clone = cloneNode as ConfigXmlCDataSection;
            if (clone != null) {
                clone._line = _line;
                clone._filename = _filename;
            }
            return cloneNode;
        }
    }
    internal sealed class ConfigXmlSignificantWhitespace : XmlSignificantWhitespace, IConfigXmlNode {
        public ConfigXmlSignificantWhitespace(string filename, int line, string strData, XmlDocument doc)
            : base(strData, doc) {
            _line = line;
            _filename = filename;
        }
        int _line;
        string _filename;

        int IConfigXmlNode.LineNumber {
            get { return _line; }
        }
        string IConfigXmlNode.Filename {
            get { return _filename; }
        }
        public override XmlNode CloneNode(bool deep) {
            XmlNode cloneNode = base.CloneNode(deep);
            ConfigXmlSignificantWhitespace clone = cloneNode as ConfigXmlSignificantWhitespace;
            if (clone != null) {
                clone._line = _line;
                clone._filename = _filename;
            }
            return cloneNode;
        }
    }
    internal sealed class ConfigXmlComment : XmlComment, IConfigXmlNode {
        int _line;
        string _filename;

        public ConfigXmlComment( string filename, int line, string comment, XmlDocument doc )
            : base( comment, doc ) {
            _line = line;
            _filename = filename;
        }
        int IConfigXmlNode.LineNumber {
            get { return _line; }
        }
        string IConfigXmlNode.Filename {
            get { return _filename; }
        } 
        public override XmlNode CloneNode(bool deep) {
            XmlNode cloneNode = base.CloneNode(deep);
            ConfigXmlComment clone = cloneNode as ConfigXmlComment;
            if (clone != null) {
                clone._line = _line;
                clone._filename = _filename;
            }
            return cloneNode;
        }
    }
    internal sealed class ConfigXmlWhitespace : XmlWhitespace, IConfigXmlNode {
        public ConfigXmlWhitespace( string filename, int line, string comment, XmlDocument doc )
            : base( comment, doc ) {
            _line = line;
            _filename = filename;
        }
        int _line;
        string _filename;

        int IConfigXmlNode.LineNumber {
            get { return _line; }
        }
        string IConfigXmlNode.Filename {
            get { return _filename; }
        }
        public override XmlNode CloneNode(bool deep) {
            XmlNode cloneNode = base.CloneNode(deep);
            ConfigXmlWhitespace clone = cloneNode as ConfigXmlWhitespace;
            if (clone != null) {
                clone._line = _line;
                clone._filename = _filename;
            }
            return cloneNode;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\defaultconfigurationsystem.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultConfigurationSystem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//
// config system: finds config files, loads config
// factories, filters out relevant config file sections, and
// feeds them to the factories to create config objects.
//

#if !LIB

namespace System.Configuration {

    using System.Collections;
    using System.IO;
    using System.Xml;
    using System.Diagnostics;
    using System.Security;
    using System.Security.Permissions;
    using Assembly = System.Reflection.Assembly;
    using StringBuilder = System.Text.StringBuilder;

    internal class DefaultConfigurationSystem : IConfigurationSystem {

        // string constants
        private const string ConfigExtension = "config";
        private const string MachineConfigFilename = "machine.config";
        private const string MachineConfigSubdirectory = "Config";
        private const int MaxPathSize = 1024;
        //private ConfigurationRecord _machine;
        private ConfigurationRecord _application;

        internal DefaultConfigurationSystem() {
        }


        object IConfigurationSystem.GetConfig(string configKey) {
            if (_application != null) {
                return _application.GetConfig(configKey);
            }

            throw new InvalidOperationException(SR.GetString(SR.Client_config_init_error));
        }


        void IConfigurationSystem.Init() {
            lock (this) {
                if (_application == null) {
                    ConfigurationRecord machine = null;
                    
                    string machineFilename = MachineConfigurationFilePath;
                    Uri appFilename = AppConfigPath;

                    ConfigurationRecord.TraceVerbose("opening Machine config file     \"" + machineFilename + "\"");
                    _application = machine = new ConfigurationRecord();
                    bool machineFileExists = machine.Load(machineFilename);
                    
                    // only load application config if machine.config exists
                    if (machineFileExists && appFilename != null) {
                        ConfigurationRecord.TraceVerbose("opening Application config file \"" + appFilename + "\"");
                        _application = new ConfigurationRecord(machine);
                        _application.Load(appFilename.ToString());
                    }
                }
            }
        }


        internal static String MsCorLibDirectory {
            get {
                // location of mscorlib.dll
                string filename;
                FileIOPermission perm = new FileIOPermission(PermissionState.None);
                perm.AllFiles = FileIOPermissionAccess.PathDiscovery;
                perm.Assert();
                try {
                    filename = Assembly.GetAssembly(typeof(object)).Location.Replace('/', '\\');
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                return Path.GetDirectoryName(filename);
            }
        }

        internal static string MachineConfigurationFilePath {
            get {
                return Path.Combine(Path.Combine(MsCorLibDirectory, MachineConfigSubdirectory), MachineConfigFilename);
            }
        }


        internal static Uri AppConfigPath {
            get {
                string appBase;

                // FileIOPermission is required for ApplicationBase in URL-hosted domains
                // see ASURT 101244
                FileIOPermission perm = new FileIOPermission(PermissionState.Unrestricted);
                perm.Assert();
                try {
                    appBase = AppDomain.CurrentDomain.SetupInformation.ApplicationBase;
                
                    // we need to ensure AppBase ends in an '/'.  see ASURT 99116
                    if (appBase.Length > 0) {
                        char lastChar = appBase[appBase.Length - 1];
                        if (lastChar != '/' && lastChar != '\\') {
                            appBase += '/';
                        }
                    }
                    Uri uri = new Uri(appBase);
                    string config = AppDomain.CurrentDomain.SetupInformation.ConfigurationFile;
                    if (config != null && config.Length > 0) {
                        uri = new Uri(uri, AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);
                        return uri;
                    }
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                return null;
            }
        }
    }



}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\dictionarysectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DictionarySectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Configuration {
    using System.Collections;
    using System.Collections.Specialized;
    using System.Xml;
    using System.Globalization;
    
    /// <include file='doc\DictionarySectionHandler.uex' path='docs/doc[@for="DictionarySectionHandler"]/*' />
    /// <devdoc>
    /// Simple dictionary config factory
    /// config is a dictionary mapping key-&gt;value
    /// 
    ///     &lt;add key="name" value="text"&gt;  sets key=text 
    ///     &lt;remove key="name"&gt;            removes the definition of key
    ///     &lt;clear&gt;                        removes all definitions
    /// 
    /// </devdoc>
    public class DictionarySectionHandler : IConfigurationSectionHandler {

        /// <include file='doc\DictionarySectionHandler.uex' path='docs/doc[@for="DictionarySectionHandler.Create"]/*' />
        /// <devdoc>
        /// Given a partially composed config object (possibly null)
        /// and some input from the config system, return a
        /// further partially composed config object
        /// </devdoc>
        public virtual object Create(Object parent, Object context, XmlNode section) {
            Hashtable res;

            // start res off as a shallow clone of the parent

            if (parent == null)
                res = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            else
                res = (Hashtable)((Hashtable)parent).Clone();

            // process XML

            HandlerBase.CheckForUnrecognizedAttributes(section);

            foreach (XmlNode child in section.ChildNodes) {

                // skip whitespace and comments, throws if non-element
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                // handle <add>, <remove>, <clear> tags
                if (child.Name == "add") {
                    HandlerBase.CheckForChildNodes(child);
                    String key = HandlerBase.RemoveRequiredAttribute(child, KeyAttributeName);
                    String value;
                    if (ValueRequired)
                        value = HandlerBase.RemoveRequiredAttribute(child, ValueAttributeName);
                    else
                        value = HandlerBase.RemoveAttribute(child, ValueAttributeName);
                    HandlerBase.CheckForUnrecognizedAttributes(child);

                    if (value == null)
                        value = "";

                    res[key] = value;
                }
                else if (child.Name == "remove") {
                    HandlerBase.CheckForChildNodes(child);
                    String key = HandlerBase.RemoveRequiredAttribute(child, KeyAttributeName);
                    HandlerBase.CheckForUnrecognizedAttributes(child);

                    res.Remove(key);
                }
                else if (child.Name.Equals("clear")) {
                    HandlerBase.CheckForChildNodes(child);
                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    res.Clear();
                }
                else {
                    HandlerBase.ThrowUnrecognizedElement(child);
                }
            }

            return res;
        }

        /// <include file='doc\DictionarySectionHandler.uex' path='docs/doc[@for="DictionarySectionHandler.KeyAttributeName"]/*' />
        /// <devdoc>
        ///    Make the name of the key attribute configurable by derived classes.
        /// </devdoc>
        protected virtual string KeyAttributeName {
            get { return "key";}
        }

        /// <include file='doc\DictionarySectionHandler.uex' path='docs/doc[@for="DictionarySectionHandler.ValueAttributeName"]/*' />
        /// <devdoc>
        ///    Make the name of the value attribute configurable by derived classes.
        /// </devdoc>
        protected virtual string ValueAttributeName {
            get { return "value";}
        }

        // REVIEW: (davidgut) maybe we should make this public in the future?
        internal virtual bool ValueRequired {
            get { return false; }
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\configurationsettings.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConfigurationSettings.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//
// config system: finds config files, loads config
// factories, filters out relevant config file sections, and
// feeds them to the factories to create config objects.
//

namespace System.Configuration {

	using System.Collections;
	using System.Collections.Specialized;
    using System.IO;
    using System.Diagnostics;
    using System.Globalization;
    
    /// <include file='doc\ConfigurationSettings.uex' path='docs/doc[@for="ConfigurationSettings"]/*' />
    /// <devdoc>The client-side capable config system.
    /// </devdoc>
    public sealed class ConfigurationSettings {


        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        private ConfigurationSettings() {
        }

        // The Configuration System
        private static IConfigurationSystem _configSystem;  // = null
        private static bool _configurationInitialized;      // = false

#if !LIB // avoid "not-used" warning in lib pass build
        private static Exception _initError;                // = null
#endif


        // to be used by System.Diagnostics to avoid false config results during config init
        internal static bool SetConfigurationSystemInProgress {
            get {
                return _configSystem != null && _configurationInitialized == false;
            }
        }


        /// <include file='doc\ConfigurationSettings.uex' path='docs/doc[@for="ConfigurationSettings.SetConfigurationSystem"]/*' />
        /// <devdoc>
        ///     Called by ASP.NET to allow hierarchical configuration settings and ASP.NET specific extenstions.
        /// </devdoc>
        internal static void SetConfigurationSystem(IConfigurationSystem configSystem) {
#if LIB
            _configSystem = configSystem; // avoid warning in LIB build pass
#else
            lock(typeof(ConfigurationSettings)) {
                if (_configSystem == null) {
                    try {
                        _configSystem = configSystem;
                        configSystem.Init();
                    }
                    catch (Exception e) {
                        _initError = e;
                        throw;
                    }
                }
                else {
                    throw new InvalidOperationException(SR.GetString(SR.Config_system_already_set));
                }

                _configurationInitialized = true;
            }
#endif
        }


        /// <include file='doc\ConfigurationSettings.uex' path='docs/doc[@for="ConfigurationSettings.GetConfig"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static object GetConfig(string sectionName) {
#if LIB
            return null;
#else
#if CONFIG_NODIAG
#warning System.Diagnostics disabled via ConfigurationSettings.GetConfig()
            if (sectionName == "system.diagnostics")
                return null;
#endif
            if (_configurationInitialized == false) {
                lock(typeof(ConfigurationSettings)) {
                    if (_configSystem == null && !SetConfigurationSystemInProgress) {
                        SetConfigurationSystem(new DefaultConfigurationSystem());
                    }
                }
            }

            if (_initError != null) {
                throw _initError;
            }

            Debug.Assert(_configSystem != null);
            return _configSystem.GetConfig(sectionName);
#endif
        }


        //
        // Helper functions
        //

        //
        // AppSettings - strongly-typed wrapper for <appsettings>
        //
        /// <include file='doc\ConfigurationSettings.uex' path='docs/doc[@for="ConfigurationSettings.AppSettings"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static NameValueCollection AppSettings {
            get {
                ReadOnlyNameValueCollection appSettings = (ReadOnlyNameValueCollection)GetConfig("appSettings");

                if (appSettings == null) {
                    appSettings = new ReadOnlyNameValueCollection(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                    appSettings.SetReadOnly();
                }
                
                return appSettings;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\configurationrecord.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConfigurationRecord.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB
namespace System.Configuration {

    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Policy;
    using System.Xml;
    using System.Net;
    using Assembly = System.Reflection.Assembly;

    internal class ConfigurationRecord {
        private Hashtable _results;
        private Hashtable _factories;              // default null
        private Hashtable _unevaluatedSections;    // default null
        private bool      _factoriesNoInherit;     // default false
        private string    _filename;               // default null
        private Exception _error;

        private readonly ConfigurationRecord _parent;

        private static object RemovedFactorySingleton = new object();
        private static object GroupSingleton = new object();


        public ConfigurationRecord() :  this(null) {
        }

        public ConfigurationRecord(ConfigurationRecord parent) {
            _results = new Hashtable();
            _parent = parent;
        }


        public bool Load(string filename) {
                Uri uri = new Uri(filename);
                if (uri.Scheme == "file") {
                    _filename = uri.LocalPath;
                }
                else {
                    _filename = filename;
                }

                XmlTextReader reader = null;
                try {
                    reader = OpenXmlTextReader(filename);

                    if (reader != null) {
                        ScanFactoriesRecursive(reader);

                        if (reader.Depth == 1) {
                            ScanSectionsRecursive(reader, null);
                        }

                        return true;
                    }
                }
                catch (ConfigurationException) {
                    throw;
                }
                catch (Exception e) {
                    _error = TranslateXmlParseOrEvaluateErrors(e);
                    throw _error;
                }
                finally {
                    if (reader != null) {
                        reader.Close();
                    }
                }

            return false;
        }


        public object GetConfig(string configKey) {
            if (_error != null) {
                throw _error;
            }

            TraceVerbose("GetConfig(\"" + configKey + "\")");

            if (!_results.Contains(configKey)) {
                object objConfig = ResolveConfig(configKey);
                lock (_results.SyncRoot) {
                    _results[configKey] = objConfig;
                }
                return objConfig;
            }

            // else
            return _results[configKey];
        }


        public object ResolveConfig(string configKey) {
            // get local copy of reference for thread safety 
            // Instance reference could be set to null 
            // between !=null and .Contains().
            Hashtable unevaluatedSections = _unevaluatedSections;
            if (unevaluatedSections != null && unevaluatedSections.Contains(configKey)) {
                return Evaluate(configKey);
            }
            if (_parent != null) {
                return _parent.GetConfig(configKey);
            }
            return null;
        }


        private object Evaluate(string configKey) {

            // 
            // Step 1: Get the config factory
            //
            IConfigurationSectionHandler factory = GetFactory(configKey);
            Debug.Assert(factory != null);


            //
            // Step 2: Get the parent result to be passed to the section handler
            //
            object objParentResult =  _parent != null ? _parent.GetConfig(configKey) : null;


            //
            // Step 3: Evaluate the config section
            //
            string [] keys = configKey.Split(new char[] {'/'});
            XmlTextReader reader = null;
            object objResult = null;
            try {
                reader = OpenXmlTextReader(_filename);
                objResult = EvaluateRecursive(factory, objParentResult, keys, 0, reader);
            }
            catch (ConfigurationException) {
                throw;
            }
            catch (Exception e) {
                throw TranslateXmlParseOrEvaluateErrors(e);
            }
            finally {
                if (reader != null) {
                    reader.Close();
                }
            }
            //
            // Step 4: Remove the configKey from _unevaluatedSections.  
            //      When all sections are removed throw it away
            //
            // for thread safety operate on local reference
            Hashtable unevaluatedSections = _unevaluatedSections;
            // instance reference could have gone away by now
            if (unevaluatedSections != null) { 
                // only one writer to Hashtable at a time
                lock(unevaluatedSections.SyncRoot) {
                    unevaluatedSections.Remove(configKey);
                    if (unevaluatedSections.Count == 0) {
                        // set instance reference to null when done
                        _unevaluatedSections = null;
                    }
                }    
            }    

            return objResult;
        }


        private enum HaveFactoryEnum {
            NotFound,
            Group,
            Section
        };


        private HaveFactoryEnum HaveFactory(string configKey) {

            if (_factories != null) {
                if (_factories.Contains(configKey)) {
                    object obj = _factories[configKey];

                    if (obj == RemovedFactorySingleton) {
                        return HaveFactoryEnum.NotFound;
                    }

                    if (obj == GroupSingleton) {
                        return HaveFactoryEnum.Group;
                    }

                    return HaveFactoryEnum.Section;
                }
            }

            if (!_factoriesNoInherit && _parent != null) { 
                return _parent.HaveFactory(configKey);
            }
            // else
            return HaveFactoryEnum.NotFound;
        }


        private IConfigurationSectionHandler GetFactory(string configKey) {

            TraceVerbose("  GetFactory " + configKey);

            if (_factories != null) {
                if (_factories.Contains(configKey)) {
                    object obj = _factories[configKey];

                    if (obj == RemovedFactorySingleton) {
                        return null;
                    }

                    IConfigurationSectionHandler factory = obj as IConfigurationSectionHandler;
                    if (factory != null) {
                        return factory;
                    }

                    // if we still have a type string get the type and create the IConfigurationSectionHandler
                    Debug.Assert(obj is string);
                    string strFactoryType = (string)obj;
                    obj = null;

                    new ReflectionPermission(PermissionState.Unrestricted).Assert();
                    try {
                        // Pub s Type GetType (String typeName, Boolean throwOnError) 
                        Type t = Type.GetType(strFactoryType /*, false */); // catch the errors and report them
                            
                        if (t != null) {

                            bool implementsICSH = typeof(IConfigurationSectionHandler).IsAssignableFrom(t);
                            if (!implementsICSH) {
                                throw new ConfigurationException(SR.GetString(SR.Type_doesnt_implement_IConfigSectionHandler, strFactoryType));
                            }    
                            
                            // throws MissingMethodException if no valid ctor
                            // Binding flags insulate code from ASURT 88771
                            obj = Activator.CreateInstance(t, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null ,null);
                        }
                    }
                    catch (Exception e) {
                        throw new ConfigurationException(e.Message, e);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
        
                    if (obj == null) {
                        throw new ConfigurationException(SR.GetString(SR.Could_not_create_type_instance, strFactoryType));
                    }
        
                    factory = obj as IConfigurationSectionHandler;
                    if (factory == null) {
                        throw new ConfigurationException(SR.GetString(SR.Type_doesnt_implement_IConfigSectionHandler, strFactoryType));
                    }
        
                    TraceVerbose("   adding factory: " + strFactoryType);

                    lock (_factories.SyncRoot) {
                        _factories[configKey] = factory;
                    }
                    return factory;
                }
            }

            if (!_factoriesNoInherit && _parent != null) {
                return _parent.GetFactory(configKey);
            }
            // else
            return null;
        }


        private object EvaluateRecursive(IConfigurationSectionHandler factory, object config, string [] keys, int iKey, XmlTextReader reader) {
            string name = keys[iKey];
            TraceVerbose("  EvaluateRecursive " + iKey + " " + name);

            int depth = reader.Depth;

            while (reader.Read() && reader.NodeType != XmlNodeType.Element);

            while (reader.Depth == depth + 1) {
                TraceVerbose("  EvaluateRecursive " + iKey + " " + name + " Name:" + reader.Name);
                if (reader.Name == name) {
                    if (iKey < keys.Length - 1) {
                        config = EvaluateRecursive(factory, config, keys, iKey + 1, reader);
                    }
                    else {
                        TraceVerbose("  EvaluateRecursive " + iKey + " calling Create()");
                        Debug.Assert(iKey == keys.Length - 1);

                        PermissionSet permissionSet = CreatePermissionSetFromLocation(_filename);
                        permissionSet.PermitOnly();
                        try {
                            // 
                            // Call configuration section handler
                            // 
                            // - try-catch is necessary to insulate config system from exceptions in user config handlers.
                            //   - bubble ConfigurationExceptions & XmlException
                            //   - wrap all others in ConfigurationException
                            //
                            int line = reader.LineNumber;
                            try {
                                ConfigXmlDocument doc = new ConfigXmlDocument();
                                XmlNode section = doc.ReadConfigNode(_filename, reader);
                                config = factory.Create(config, null, section);
                            }
                            catch (ConfigurationException) {
                                throw;
                            }
                            catch (XmlException) {
                                throw;
                            }
                            catch (Exception ex) {
                                throw new ConfigurationException(
                                            SR.GetString(SR.Exception_in_config_section_handler),
                                            ex, _filename, line);
                            }
                        }
                        finally {
                            CodeAccessPermission.RevertPermitOnly();
                        }
                    }
                    continue;
                }
                StrictSkipToNextElement(reader);
            }
            return config;
        }

        private static PermissionSet CreatePermissionSetFromLocation(string configurationFile) {
            // Readability note:
            //  Uri is System.Uri
            //  Url is System.Security.Policy.Url
            
            Uri configUri = new Uri(configurationFile);
            
            // Build evidence for location of current configuration file
            Evidence evidence = new Evidence();
            evidence.AddHost(new Url(configUri.ToString()));
            if (!configUri.IsFile) {
                evidence.AddHost(Site.CreateFromUrl(configUri.ToString()));
            }
            evidence.AddHost(Zone.CreateFromUrl(configUri.ToString()));

            
            PermissionSet permissionSet = SecurityManager.ResolvePolicy(evidence);
            return permissionSet;
        }


        private void ScanFactoriesRecursive(XmlTextReader reader) {

            // skip <?xml... PI and comments
            reader.MoveToContent(); // StrictReadToNextElement(reader);

            if (reader.NodeType != XmlNodeType.Element || reader.Name != "configuration") {
                throw BuildConfigError(SR.GetString(SR.Config_file_doesnt_have_root_configuration, _filename), reader);
            }
            CheckForUnrecognizedAttributes(reader);

            // move to first child of <configuration>
            StrictReadToNextElement(reader);
            if (reader.Depth == 1) {
                if (reader.Name == "configSections") {
                    CheckForUnrecognizedAttributes(reader);
                    ScanFactoriesRecursive(reader, null);
                }
            }
        }

        private Hashtable EnsureFactories {
            get {
                if (_factories == null) {
                    _factories = new Hashtable();
                }
                return _factories;
            }
        }


        private void ScanFactoriesRecursive(XmlTextReader reader, string configKey) {
            int depth = reader.Depth;
            StrictReadToNextElement(reader);
            while (reader.Depth == depth + 1) {
                switch (reader.Name) {
                case "sectionGroup": 
                    {
                        string tagName = null;
                        if (reader.HasAttributes) {
                            while (reader.MoveToNextAttribute()) {
                                if (reader.Name != "name") {
                                    ThrowUnrecognizedAttribute(reader);
                                }
                                tagName = reader.Value;
                            }
                            reader.MoveToElement();
                        }
                        CheckRequiredAttribute(tagName, "name", reader);
                        VerifySectionName(tagName, reader);

                        string tagKey = TagKey(configKey, tagName);

                        if (HaveFactoryEnum.Section == HaveFactory(tagKey)) {
                            throw BuildConfigError(
                                    SR.GetString(SR.Tag_name_already_defined),
                                    reader);
                        }

                        EnsureFactories[tagKey] = GroupSingleton;
                        ScanFactoriesRecursive(reader, tagKey);
                        continue;
                    } 
                case "section":
                    {
                        string tagName = null;
                        string typeName = null;
                        if (reader.HasAttributes) {
                            while (reader.MoveToNextAttribute()) {
                                switch (reader.Name) {
                                case "name":
                                    tagName = reader.Value;
                                    break;
                                case "type":
                                    typeName = reader.Value;
                                    break;
                                case "allowLocation":
                                case "allowDefinition":
                                    break;
                                default:
                                    ThrowUnrecognizedAttribute(reader);
                                    break;
                                }
                            }
                            reader.MoveToElement();
                        }
                        CheckRequiredAttribute(tagName, "name", reader);
                        CheckRequiredAttribute(typeName, "type", reader);
                        VerifySectionName(tagName, reader);
                        string tagKey = TagKey(configKey, tagName);

                        if (HaveFactory(tagKey) != HaveFactoryEnum.NotFound) {
                            throw BuildConfigError(
                                        SR.GetString(SR.Tag_name_already_defined, tagName),
                                        reader);
                        }

                        TraceVerbose("Adding factory: " + tagKey);
                        EnsureFactories[tagKey] = typeName;
                        break;
                    }
                case "remove": 
                    {
                        string tagName = null;
                        if (reader.HasAttributes) {
                            while (reader.MoveToNextAttribute()) {
                                if (reader.Name != "name") {
                                    ThrowUnrecognizedAttribute(reader);
                                }
                                tagName = reader.Value;
                            }
                            reader.MoveToElement();
                        }
                        if (tagName == null) {
                            ThrowRequiredAttribute(reader, "name");
                        }
                        VerifySectionName(tagName, reader);
                        string tagKey = TagKey(configKey, tagName);

                        if (HaveFactory(tagKey) != HaveFactoryEnum.Section) {
                            throw BuildConfigError(SR.GetString(SR.Could_not_remove_section_handler, tagName), reader);
                        }

                        EnsureFactories[tagName] = RemovedFactorySingleton;
                    } 
                    break;

                case "clear":
                    CheckForUnrecognizedAttributes(reader);
                    _factories = null;
                    _factoriesNoInherit = true;
                    break;

                default: 
                    ThrowUnrecognizedElement(reader);
                    break;
                }

                StrictReadToNextElement(reader);
                // unrecognized children are not allowed
                if (reader.Depth > depth + 1) {
                    ThrowUnrecognizedElement(reader);
                }
            }
        }


        private static string TagKey(string configKey, string tagName) {
            string tagKey = (configKey == null) ? tagName : configKey + "/" + tagName;
            //TraceVerbose("    scanning " + tagKey);
            return tagKey;
        }


        private void VerifySectionName(string tagName, XmlTextReader reader) {
            if (tagName.StartsWith("config"))
                throw BuildConfigError(SR.GetString(SR.Tag_name_cannot_begin_with_config), reader);
            if (tagName == "location")
                throw BuildConfigError(SR.GetString(SR.Tag_name_cannot_be_location), reader);
        }


        void ScanSectionsRecursive(XmlTextReader reader, string configKey) {
            int depth = reader.Depth;

            // only move to child nodes of not on first level (we've already passed the first <configsections>)
            if (configKey == null) {
                Debug.Assert(depth == 1);
                depth = 0;
            }
            else {
                StrictReadToNextElement(reader);
            }

            while (reader.Depth == depth + 1) {
                string tagName = reader.Name;
                string tagKey = TagKey(configKey, tagName);

                HaveFactoryEnum haveFactory = HaveFactory(tagKey);

                if (haveFactory == HaveFactoryEnum.Group) {
                    ScanSectionsRecursive(reader, tagKey);
                    continue;
                }
                else if (haveFactory == HaveFactoryEnum.NotFound) {
                    if (tagKey == "location") {
                    }
                    else if (tagKey == "configSections") {
                        throw BuildConfigError(
                                 SR.GetString(SR.Client_config_too_many_configsections_elements),
                                 reader);
                    }
                    else {
                        throw BuildConfigError(
                                     SR.GetString(SR.Unrecognized_configuration_section, tagName),
                                     reader);
                    }
                }
                else {
                    TraceVerbose("Adding section: " + tagKey);
                    if (_unevaluatedSections == null)
                        _unevaluatedSections = new Hashtable();

                    _unevaluatedSections[tagKey] = null;
                }
                StrictSkipToNextElement(reader);
            }
        }


        private static XmlTextReader OpenXmlTextReader(string configFileName) {
            Uri file = new Uri(configFileName);
            string localFileName;
            TraceVerbose("Reading config file \"" + file + "\"");

            bool isFile = file.Scheme == "file";
            if (isFile) {
                localFileName = file.LocalPath;
            }
            else {
                localFileName = file.ToString();
            }

            XmlTextReader reader = null; 
            
            try {
                if (isFile) {
                    FileIOPermission fp = null;
                    fp = new FileIOPermission(FileIOPermissionAccess.Read | FileIOPermissionAccess.PathDiscovery, 
                                    Path.GetDirectoryName(file.LocalPath));
                    fp.Assert();
                    if (!File.Exists(file.LocalPath)) {
                        TraceVerbose("Not reading config file \"" + file + "\", because it doesn't exist");
                        return null;
                    }
                    reader = new XmlTextReader(localFileName);
                }
                else {
                    try {
                        Stream s = new WebClient().OpenRead(configFileName);
                        reader = new XmlTextReader(s);
                    }
#if !CONFIG_TRACE
                    catch { // ignore errors loading config file over the network for downloaded assemblies
                        return null;
                    }
#else
                    catch (Exception e) {
                        TraceVerbose("Not reading config file \"" + file + "\", because the web request failed.");
                        TraceVerbose(e.ToString());
                        return null;
                    }
#endif
                }
                // actually create the stream -- force access to the file while the Assert is on the stack
                //      if this line is removed, the XmlTextReader delay-creates the stream,
                //      and a security exception is thrown in ScanFactories()
                reader.MoveToContent(); 
                
            }
            catch (Exception e) {
                throw new ConfigurationException(
                                SR.GetString(SR.Error_loading_XML_file, configFileName, e.Message),
                                localFileName,
                                0); // no line# info
            }
            
            return reader;
        }


        [Conditional("CONFIG_TRACE")]
        internal static void TraceVerbose(string msg) {
#if CONFIG_TRACE
#warning System.Configuration tracing enabled
            Trace.WriteLine(msg, "System.Configuration");
#endif
        }


        //
        // XmlTextReader Helpers...
        //
        ConfigurationException BuildConfigError(string message, XmlTextReader reader) {
            return new ConfigurationException(message, _filename, reader.LineNumber);
        }
        ConfigurationException BuildConfigError(string message, Exception inner, XmlTextReader reader) {
            return new ConfigurationException(message, inner, _filename, reader.LineNumber);
        }

        void StrictReadToNextElement(XmlTextReader reader) {
            while (reader.Read()) {
                // optimize for the common case
                if (reader.NodeType == XmlNodeType.Element) {
                    return;
                }

                CheckIgnorableNodeType(reader);
            }
        }

        void StrictSkipToNextElement(XmlTextReader reader) {
            reader.Skip();

            while (!reader.EOF && reader.NodeType != XmlNodeType.Element) {
                CheckIgnorableNodeType(reader);
                reader.Read();
            }
        }

        void CheckIgnorableNodeType(XmlTextReader reader) {
            if (reader.NodeType != XmlNodeType.Comment 
                && reader.NodeType != XmlNodeType.EndElement 
                && reader.NodeType != XmlNodeType.Whitespace 
                && reader.NodeType != XmlNodeType.SignificantWhitespace) {
                ThrowUnrecognizedElement(reader);
            }
        }

        void ThrowUnrecognizedAttribute(XmlTextReader reader) {
            throw BuildConfigError(
                        SR.GetString(SR.Config_base_unrecognized_attribute, reader.Name),
                        reader);                
        }

        void CheckForUnrecognizedAttributes(XmlTextReader reader) {
            if (reader.HasAttributes) {
                reader.MoveToNextAttribute();
                ThrowUnrecognizedAttribute(reader);
            }
        }

        void ThrowRequiredAttribute(XmlTextReader reader, string attrib) {
            throw BuildConfigError(
                SR.GetString(SR.Missing_required_attribute, attrib, reader.Name),
                reader);
        }

        void ThrowUnrecognizedElement(XmlTextReader reader) {
            Debug.Assert(false, "This assert was added to help diagnose CLR Stress failure ASURT 113446");
            
            throw BuildConfigError(
                        SR.GetString(SR.Config_base_unrecognized_element),
                        reader);                
        }

        void CheckRequiredAttribute(object o, string attrName, XmlTextReader reader) {
            if (o == null) {
                ThrowRequiredAttribute(reader, "name");
            }
        }

        /// <devdoc><para>
        ///     Reuse.  Used in Load() and Evaluate()
        /// </para></devdoc>
        ConfigurationException TranslateXmlParseOrEvaluateErrors(Exception e) {
            Debug.Assert((e is ConfigurationException) == false, "use catch (ConfigurationException e) { throw; } instead");
            XmlException xe = e as XmlException;
            if (xe != null) {
                return new ConfigurationException( // other errors: wrap in ConfigurationException and give as much info as possible
                                xe.Message, 
                                e,
                                _filename, 
                                xe.LineNumber);
            }
            
            return new ConfigurationException( // other errors: wrap in ConfigurationException and give as much info as possible
                            SR.GetString(SR.Error_loading_XML_file, _filename, e.Message),
                            e,
                            _filename,
                            0); // no line# info
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\iconfigurationsystem.cs ===
//------------------------------------------------------------------------------
// <copyright file="IConfigurationSystem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Configuration {

    /// <include file='doc\IConfigurationSystem.uex' path='docs/doc[@for="IConfigurationSystem"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// <para>
    /// The IConfigurationSystem interface defines the contract that a configuration
    /// system must implement.
    /// </para>
    /// </devdoc>
    public interface IConfigurationSystem {

        /// <include file='doc\IConfigurationSystem.uex' path='docs/doc[@for="IConfigurationSystem.GetConfig"]/*' />
        /// <devdoc>
        /// <para>
        /// Returns the config object for the specified key.
        /// </para>
        /// </devdoc>
        object GetConfig(string configKey);

        /// <include file='doc\IConfigurationSystem.uex' path='docs/doc[@for="IConfigurationSystem.Init"]/*' />
        /// <devdoc>
        /// <para>
        /// Initializes the configuration system.
        /// </para>
        /// </devdoc>
        void Init();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\iconfigurationsectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="IConfigurationSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB
namespace System.Configuration {

    /// <include file='doc\IConfigurationSectionHandler.uex' path='docs/doc[@for="IConfigurationSectionHandler"]/*' />
    /// <devdoc>
    ///     The IConfigSectionHandler interface defines the contract that all configuration
    ///     section handlers must implement in order to participate in the resolution of
    ///     configuration settings.
    ///
    ///     Composes and creates config objects.
    ///
    ///     This interface is implemented by config providers.
    ///     Classes implementing IConfigSectionHandler define the rules for cooking
    ///     XML config into usable objects. The cooked objects
    ///     can be of arbitrary type.
    ///
    ///     Configuration is composable (e.g., config in a child
    ///     directory is layered over config in a parent directory),
    ///     so, IConfigSectionHandler is supplied with the parent config
    ///     as well as any number of XML fragments.
    /// </devdoc>
    public interface IConfigurationSectionHandler {
        /// <include file='doc\IConfigurationSectionHandler.uex' path='docs/doc[@for="IConfigurationSectionHandler.Create"]/*' />
        /// <devdoc>
        ///     Create
        ///
        ///     @param parent the object inherited from parent path
        ///     @param context reserved, in ASP.NET used to convey virtual path of config being evaluated
        ///     @param section the xml node rooted at the section to handle
        ///     @returns a new config object
        ///
        ///     The function is responsible for inspecting "section", "context",
        ///     and "parent", and creating a config object.
        ///
        ///     Note that "parent" is guaranteed to be an object that
        ///     was returned from a Create call on the same IConfigSectionHandler
        ///     implementation. (E.g., if Create returns a Hashtable,
        ///     then "parent" is always a Hashtable if it's non-null.)
        ///
        ///     Returned objects must be immutable. In particular,
        ///     it's important that the "parent" object being passed
        ///     in is not altered: if a modification must be made,
        ///     then it must be cloned before it is modified.
        /// </devdoc>
        object Create(Object parent, Object configContext, System.Xml.XmlNode section);

    }
}
#else
namespace System.Configuration {
    /// <include file='doc\IConfigurationSectionHandler.uex' path='docs/doc[@for="IConfigurationSectionHandler1"]/*' />
    public interface IConfigurationSectionHandler {
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\ignoresectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="IgnoreSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Configuration {

    /// <include file='doc\IgnoreSectionHandler.uex' path='docs/doc[@for="IgnoreSectionHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    public class IgnoreSectionHandler : IConfigurationSectionHandler {
        /**
         * Create
         *
         * Given a partially composed config object (possibly null)
         * and some input from the config system, return a
         * further partially composed config object
         */
        /// <include file='doc\IgnoreSectionHandler.uex' path='docs/doc[@for="IgnoreSectionHandler.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual object Create(Object parent, Object configContext, System.Xml.XmlNode section) {
            return null;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\handlerbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="HandlerBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//
// HandlerBase contains static helper functions for consistent XML parsing 
// behavior and error messages.
// 
// Copyright (c) 1998 Microsoft Corporation
//


#if !LIB

namespace System.Configuration {

    using System.Globalization;
    using System.Xml;


    internal class HandlerBase {


        //
        // XML Attribute Helpers
        //

        private static XmlNode GetAndRemoveAttribute(XmlNode node, string attrib, bool fRequired) {
            XmlNode a = node.Attributes.RemoveNamedItem(attrib);

            // If the attribute is required and was not present, throw
            if (fRequired && a == null) {
                throw new ConfigurationException(
                    SR.GetString(SR.Missing_required_attribute, attrib, node.Name),
                    node);
            }

            return a;
        }

        private static XmlNode GetAndRemoveStringAttributeInternal(XmlNode node, string attrib, bool fRequired, ref string val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);
            if (a != null)
                val = a.Value;

            return a;
        }

        internal static XmlNode GetAndRemoveStringAttribute(XmlNode node, string attrib, ref string val) {
            return GetAndRemoveStringAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredStringAttribute(XmlNode node, string attrib, ref string val) {
            return GetAndRemoveStringAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        // input.Xml cursor must be at a true/false XML attribute
        private static XmlNode GetAndRemoveBooleanAttributeInternal(XmlNode node, string attrib, bool fRequired, ref bool val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);
            if (a != null) {
                try {
                    val = bool.Parse(a.Value);
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                                    SR.GetString(SR.Invalid_boolean_attribute, a.Name),
                                    e, a);
                }
            }

            return a;
        }

        internal static XmlNode GetAndRemoveBooleanAttribute(XmlNode node, string attrib, ref bool val) {
            return GetAndRemoveBooleanAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredBooleanAttribute(XmlNode node, string attrib, ref bool val) {
            return GetAndRemoveBooleanAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        // input.Xml cursor must be an integer XML attribute
        private static XmlNode GetAndRemoveIntegerAttributeInternal(XmlNode node, string attrib, bool fRequired, ref int val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);
            if (a != null) {
                try {
                    val = int.Parse(a.Value, CultureInfo.InvariantCulture);
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                        SR.GetString(SR.Invalid_integer_attribute, a.Name),
                        e, a);
                }
            }

            return a;
        }

        internal static XmlNode GetAndRemoveIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemoveIntegerAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemoveIntegerAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        private static XmlNode GetAndRemovePositiveIntegerAttributeInternal(XmlNode node, string attrib, bool fRequired, ref int val) {
            XmlNode a = GetAndRemoveIntegerAttributeInternal(node, attrib, fRequired, ref val);

            if (a != null && val < 0) {
                throw new ConfigurationException(
                    SR.GetString(SR.Invalid_positive_integer_attribute, attrib),
                    node);
            }

            return a;
        }

        internal static XmlNode GetAndRemovePositiveIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemovePositiveIntegerAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredPositiveIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemovePositiveIntegerAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        private static XmlNode GetAndRemoveTypeAttributeInternal(XmlNode node, string attrib, bool fRequired, ref Type val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);

            if (a != null) {
                try {
                    val = Type.GetType(a.Value, true /*throwOnError*/);
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                        SR.GetString(SR.Invalid_type_attribute, a.Name),
                        e, a);
                }
            }

            return a;
        }

        internal static XmlNode GetAndRemoveTypeAttribute(XmlNode node, string attrib, ref Type val) {
            return GetAndRemoveTypeAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredTypeAttribute(XmlNode node, string attrib, ref Type val) {
            return GetAndRemoveTypeAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        internal static void CheckForUnrecognizedAttributes(XmlNode node) {
            if (node.Attributes.Count != 0) {
                throw new ConfigurationException(
                                SR.GetString(SR.Config_base_unrecognized_attribute, node.Attributes[0].Name),
                                node);                
            }
        }



        //
        // Obsolete XML Attribute Helpers
        //

        // if attribute not found return null
        internal static string RemoveAttribute(XmlNode node, string name) {

            XmlNode attribute = node.Attributes.RemoveNamedItem(name);

            if (attribute != null) {
                return attribute.Value;
            }

            return null;
        }

        // if attr not found throw standard message - "attribute x required"
        internal static string RemoveRequiredAttribute(XmlNode node, string name) {
            return RemoveRequiredAttribute(node, name, false/*allowEmpty*/);
        }

        internal static string RemoveRequiredAttribute(XmlNode node, string name, bool allowEmpty) {
            XmlNode attribute = node.Attributes.RemoveNamedItem(name);

            if (attribute == null) {
                throw new ConfigurationException(
                                SR.GetString(SR.Config_base_required_attribute_missing, name),
                                node);                
            }

            if (attribute.Value == string.Empty && allowEmpty == false) {
                throw new ConfigurationException(
                                SR.GetString(SR.Config_base_required_attribute_empty, name),
                                node);                
            }

            return attribute.Value;
        }



        //
        // XML Element Helpers
        //

        internal static void CheckForNonElement(XmlNode node) {
            if (node.NodeType != XmlNodeType.Element) {
                throw new ConfigurationException(
                                SR.GetString(SR.Config_base_elements_only),
                                node);                
            }
        }


        internal static bool IsIgnorableAlsoCheckForNonElement(XmlNode node) {
            if (node.NodeType == XmlNodeType.Comment || node.NodeType == XmlNodeType.Whitespace) {
                return true;
            }

			CheckForNonElement(node);

			return false;
        }


        internal static void CheckForChildNodes(XmlNode node) {
            if (node.HasChildNodes) {
                throw new ConfigurationException(
                                SR.GetString(SR.Config_base_no_child_nodes),
                                node.FirstChild);                
            }
        }

        internal static void ThrowUnrecognizedElement(XmlNode node) {
            throw new ConfigurationException(
                            SR.GetString(SR.Config_base_unrecognized_element),
                            node);
        }

        // 
        // Parse Helpers
        // 

        // TODO: ParseBool
        // TODO: ParseInt
        // CONSIDER: more
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\resources\system\data\sqlclient\_dataperfcounters.h ===
//------------------------------------------------------------------------------
// <copyright file="_dataperfcounters.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   _dataperfcounters.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
#define DEVICE_COUNTER_6 12;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\namevaluefilesectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameValueFileSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB
namespace System.Configuration {
    using System.IO;
    using System.Xml;

    /// <include file='doc\NameValueFileSectionHandler.uex' path='docs/doc[@for="NameValueFileSectionHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// <para>
    /// This section handler allows &lt;appSettings file="user.config" /&gt;
    /// The file pointed to by the file= attribute is read as if it is
    /// an appSettings section in the config file.
    /// Note: the user.config file must have its root element match the 
    /// section referring to it.  So if appSettings has a file="user.config" 
    /// attribute the root element in user.config must also be named appSettings.
    /// </para>
    /// </devdoc>
    public class NameValueFileSectionHandler : IConfigurationSectionHandler {

        /// <include file='doc\NameValueFileSectionHandler.uex' path='docs/doc[@for="NameValueFileSectionHandler.Create"]/*' />
        public object Create(object parent, object configContext, XmlNode section) {
            object result = parent;

            // parse XML
            XmlNode fileAttribute = section.Attributes.RemoveNamedItem("file");

            result = NameValueSectionHandler.CreateStatic(result, section);

            if (fileAttribute != null && fileAttribute.Value.Length != 0) {
                string filename = null;
                filename = fileAttribute.Value;
                IConfigXmlNode configXmlNode = fileAttribute as IConfigXmlNode;
                if (configXmlNode == null) {
                    return null;
                }

                string configFile = configXmlNode.Filename;
                string directory = Path.GetDirectoryName(configFile);
                string sourceFileFullPath = Path.Combine(directory, filename);

                if (File.Exists(sourceFileFullPath)) {

                    ConfigXmlDocument doc = new ConfigXmlDocument();
                    try {
                        doc.Load(sourceFileFullPath);
                    }
                    catch (XmlException e) {
                        throw new ConfigurationException(e.Message, e, sourceFileFullPath, e.LineNumber);
                    }

                    if (section.Name != doc.DocumentElement.Name) {
                        throw new ConfigurationException(
                                        SR.GetString(SR.Config_name_value_file_section_file_invalid_root, section.Name),
                                        doc.DocumentElement);
                    }
                
                    result = NameValueSectionHandler.CreateStatic(result, doc.DocumentElement);
                }
            }

            return result;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\readonlynamevaluecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameValueSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Configuration {
    using System.Collections;
    using System.Collections.Specialized;

    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class ReadOnlyNameValueCollection : NameValueCollection {

        public ReadOnlyNameValueCollection(IHashCodeProvider hcp, IComparer comp) : base(hcp, comp) {
        }
        public ReadOnlyNameValueCollection(ReadOnlyNameValueCollection value) : base(value) {
        }

        public void SetReadOnly() {
            IsReadOnly = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\singletagsectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SingleTagSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB

namespace System.Configuration {
    using System.Collections;
    using System.Xml;

    /**
     * Single-tag dictionary config factory
     *
     * Use for tags of the form: <MySingleTag key1="value1" ... keyN="valueN"/> 
     */
    /// <include file='doc\SingleTagSectionHandler.uex' path='docs/doc[@for="SingleTagSectionHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    public class SingleTagSectionHandler : IConfigurationSectionHandler {
        /**
         * Create
         *
         * Given a partially composed config object (possibly null)
         * and some input from the config system, return a
         * further partially composed config object
         */
        /// <include file='doc\SingleTagSectionHandler.uex' path='docs/doc[@for="SingleTagSectionHandler.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual object Create(Object parent, Object context, XmlNode section) {
            Hashtable result;

            // start result off as a shallow clone of the parent

            if (parent == null)
                result = new Hashtable();
            else
                result = new Hashtable((Hashtable)parent);

            // verify that there are no children

            HandlerBase.CheckForChildNodes(section);
            
            // iterate through each XML section in order and apply the directives

            foreach (XmlAttribute attribute in section.Attributes) {
                // handle name-value pairs
                result[attribute.Name] = attribute.Value;
            }

            return result;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\aggregatetype.cs ===
//------------------------------------------------------------------------------
// <copyright file="AggregateType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType"]/*' />
    /// <devdoc>
    ///    <para>Specifies the aggregate function type.</para>
    /// </devdoc>

    internal enum AggregateType { 
        /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType.None"]/*' />
        /// <devdoc>
        ///    <para>None.</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType.Sum"]/*' />
        /// <devdoc>
        ///    <para>Sum.</para>
        /// </devdoc>
        Sum = 4,
        /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType.Mean"]/*' />
        /// <devdoc>
        ///    <para>Average value of the aggregate set.</para>
        /// </devdoc>
        Mean = 5,
        /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType.Min"]/*' />
        /// <devdoc>
        ///    <para>The minimum value of the set.</para>
        /// </devdoc>
        Min = 6,
        /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType.Max"]/*' />
        /// <devdoc>
        ///    <para>The maximum value of the set.</para>
        /// </devdoc>
        Max = 7,
        /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType.First"]/*' />
        /// <devdoc>
        ///    <para>First element of the set.</para>
        /// </devdoc>
        First = 8,
        /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType.Count"]/*' />
        /// <devdoc>
        ///    <para>The count of the set.</para>
        /// </devdoc>
        Count = 9,
        /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType.Var"]/*' />
        /// <devdoc>
        ///    <para>Variance.</para>
        /// </devdoc>
        Var = 10,
        /// <include file='doc\AggregateType.uex' path='docs/doc[@for="AggregateType.StDev"]/*' />
        /// <devdoc>
        ///    <para>Standard deviation.</para>
        /// </devdoc>
        StDev = 11
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Configuration {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNativeMethods {
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public extern static int GetModuleFileName(int module, StringBuilder filename, int size);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public extern static int GetModuleHandle(String moduleName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\acceptrejectrule.cs ===
//------------------------------------------------------------------------------
// <copyright file="AcceptRejectRule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    /// <include file='doc\AcceptRejectRule.uex' path='docs/doc[@for="AcceptRejectRule"]/*' />
    /// <devdoc>
    /// <para>Determines the action that occurs when the <see cref='System.Data.DataSet.AcceptChanges'/> method is invoked on a <see cref='System.Data.DataTable'/> with a <see cref='System.Data.ForeignKeyConstraint'/>
    /// .</para>
    /// </devdoc>
    public enum AcceptRejectRule {    
        /// <include file='doc\AcceptRejectRule.uex' path='docs/doc[@for="AcceptRejectRule.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No action occurs.
        ///    </para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\AcceptRejectRule.uex' path='docs/doc[@for="AcceptRejectRule.Cascade"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Changes are cascaded across the relationship.
        ///    </para>
        /// </devdoc>
        Cascade = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\config\system\configuration\namevaluesectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameValueSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB
namespace System.Configuration {
    using System.Collections;
    using System.Collections.Specialized;
    using System.Xml;
    using System.Globalization;
    
    /// <include file='doc\NameValueSectionHandler.uex' path='docs/doc[@for="NameValueSectionHandler"]/*' />
    /// <devdoc>
    ///    Simple dictionary config factory
    /// </devdoc>
    public class NameValueSectionHandler : IConfigurationSectionHandler {
        const string defaultKeyAttribute = "key";
        const string defaultValueAttribute = "value";

        /// <include file='doc\NameValueSectionHandler.uex' path='docs/doc[@for="NameValueSectionHandler.Create"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object Create(object parent, object context, XmlNode section) {
            return CreateStatic(parent, section, KeyAttributeName, ValueAttributeName);
        }

        /// <include file='doc\NameValueSectionHandler.uex' path='docs/doc[@for="NameValueSectionHandler.CreateStatic"]/*' />
        internal static object CreateStatic(object parent, XmlNode section) {
            return CreateStatic(parent, section, defaultKeyAttribute, defaultValueAttribute);
        }

        /// <include file='doc\NameValueSectionHandler.uex' path='docs/doc[@for="NameValueSectionHandler.CreateStatic1"]/*' />
        internal static object CreateStatic(object parent, XmlNode section, string keyAttriuteName, string valueAttributeName) {
            ReadOnlyNameValueCollection result;

            // start result off as a shallow clone of the parent

            if (parent == null)
                result = new ReadOnlyNameValueCollection(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            else {
                ReadOnlyNameValueCollection parentCollection = (ReadOnlyNameValueCollection)parent;
                result = new ReadOnlyNameValueCollection(parentCollection);
            }

            // process XML

            HandlerBase.CheckForUnrecognizedAttributes(section);

            foreach (XmlNode child in section.ChildNodes) {

                // skip whitespace and comments
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                // handle <set>, <remove>, <clear> tags
                if (child.Name == "add") {
                    String key = HandlerBase.RemoveRequiredAttribute(child, keyAttriuteName);
                    String value = HandlerBase.RemoveRequiredAttribute(child, valueAttributeName, true/*allowEmptyString*/);
                    HandlerBase.CheckForUnrecognizedAttributes(child);

                    result[key] = value;
                }
                else if (child.Name == "remove") {
                    String key = HandlerBase.RemoveRequiredAttribute(child, keyAttriuteName);
                    HandlerBase.CheckForUnrecognizedAttributes(child);

                    result.Remove(key);
                }
                else if (child.Name.Equals("clear")) {
                    HandlerBase.CheckForUnrecognizedAttributes(child);
                    result.Clear();
                }
                else {
                    HandlerBase.ThrowUnrecognizedElement(child);
                }
            }

            result.SetReadOnly();

            return result;
        }

        /// <include file='doc\NameValueSectionHandler.uex' path='docs/doc[@for="NameValueSectionHandler.KeyAttributeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string KeyAttributeName {
            get { return defaultKeyAttribute;}
        }

        /// <include file='doc\NameValueSectionHandler.uex' path='docs/doc[@for="NameValueSectionHandler.ValueAttributeName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string ValueAttributeName {
            get { return defaultValueAttribute;}
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\componentmodel\compmodswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="Component.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Diagnostics;

    /// <internalonly/>
    internal sealed class CompModSwitches {
        private static TraceSwitch data_Sorts;        
        private static TraceSwitch data_ColumnChange;
        private static TraceSwitch dataView;
        private static TraceSwitch data_Constraints;
        private static TraceSwitch xmlWriter;
        private static TraceSwitch aggregateNode;
        private static TraceSwitch binaryNode;
        private static TraceSwitch constNode;
        private static TraceSwitch dataExpression;
        private static TraceSwitch exprParser;
        private static TraceSwitch functionNode;
        private static TraceSwitch lookupNode;
        private static TraceSwitch nameNode;
        
        public static TraceSwitch Data_ColumnChange {
            get {
                if (data_ColumnChange == null) {
                    data_ColumnChange = new TraceSwitch("Data_ColumnChange", "Uhh... debugs column change");
                }
                return data_ColumnChange;
            }
        }
        
        public static TraceSwitch Data_Sorts {
            get {
                if (data_Sorts == null) {
                    data_Sorts = new TraceSwitch("Data_Sorts", "Prints information on sort strings.");
                }
                return data_Sorts;
            }
        }                
        
        public static TraceSwitch DataView {
            get {
                if (dataView == null) {
                    dataView = new TraceSwitch("DataView", "DataView");
                }
                return dataView;
            }
        }
        
        public static TraceSwitch Data_Constraints {
            get {
                if (data_Constraints == null) {
                    data_Constraints = new TraceSwitch("Data_Constraints", "Prints information if constaint violations are attempted");
                }
                return data_Constraints;
            }
        }                                    
        
        public static TraceSwitch XmlWriter {
            get {
                if (xmlWriter == null) {
                    xmlWriter = new TraceSwitch("XmlWriter", "Enable tracing for the XmlWriter class.");
                }
                return xmlWriter;
            }
        }                
                        
        public static TraceSwitch AggregateNode {
            get {
                if (aggregateNode == null) {
                    aggregateNode = new TraceSwitch("AggregateNode", "Enable tracing for the Expression Language (AggregateNode).");
                }
                return aggregateNode;
            }
        }
                                                                        
        public static TraceSwitch BinaryNode {
            get {
                if (binaryNode == null) {
                    binaryNode = new TraceSwitch("BinaryNode", "Enable tracing for the Expression Language (BinaryNode).");
                }
                return binaryNode;
            }
        }
                                                                        
        public static TraceSwitch ConstNode {
            get {
                if (constNode == null) {
                    constNode = new TraceSwitch("ConstNode", "Enable tracing for the Expression Language (ConstNode).");
                }
                return constNode;
            }
        }
                                                                
        public static TraceSwitch DataExpression {
            get {
                if (dataExpression == null) {
                    dataExpression = new TraceSwitch("DataExpression", "Enable tracing for the Expression Language (DataExpression).");
                }
                return dataExpression;
            }
        }
                                                                        
        public static TraceSwitch ExprParser {
            get {
                if (exprParser == null) {
                    exprParser = new TraceSwitch("ExprParser", "Enable tracing for the Expression Language (ExprParser).");
                }
                return exprParser;
            }
        }
                                                                
        public static TraceSwitch FunctionNode {
            get {
                if (functionNode == null) {
                    functionNode = new TraceSwitch("FunctionNode", "Enable tracing for the Expression Language (FunctionNode).");
                }
                return functionNode;
            }
        }
                                                                
        public static TraceSwitch LookupNode {
            get {
                if (lookupNode == null) {
                    lookupNode = new TraceSwitch("LookupNode", "Enable tracing for the Expression Language (LookupNode).");
                }
                return lookupNode;
            }
        }
                                                                
        public static TraceSwitch NameNode {
            get {
                if (nameNode == null) {
                    nameNode = new TraceSwitch("NameNode", "Enable tracing for the Expression Language (NameNode).");
                }
                return nameNode;
            }
        }                                                                                                                                                

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\basecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;

    /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection"]/*' />
    /// <devdoc>
    ///    <para>Provides the base functionality for creating collections.</para>
    /// </devdoc>
    public class InternalDataCollectionBase : ICollection {
        internal static CollectionChangeEventArgs RefreshEventArgs = new CollectionChangeEventArgs(CollectionChangeAction.Refresh, null);

        //==================================================
        // the ICollection methods
        //==================================================
        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the total number of elements in a collection.</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public virtual int Count {
            get {
                return List.Count;
            }
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.CopyTo"]/*' />
        public void CopyTo(Array ar, int index) {
            List.CopyTo(ar, index);
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() {
            return List.GetEnumerator();
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.IsReadOnly"]/*' />
        [
        Browsable(false)
        ]
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.IsSynchronized"]/*' />
        [Browsable(false)]
        public bool IsSynchronized {
            get {
                // so the user will know that it has to lock this object
                return false;
            }
        }

        // Return value: 
        // > 0 (1)  : CaseSensitve equal      
        // < 0 (-1) : Case-Insensitive Equal
        // = 0      : Not Equal
        internal int NamesEqual(string s1, string s2, bool fCaseSensitive, CultureInfo locale) {
            if (fCaseSensitive) {
                if (String.Compare(s1, s2, false, locale) == 0)
                    return 1;
                else
                    return 0;
            }
            
            // Case, kana and width -Insensitive compare
            if (locale.CompareInfo.Compare(s1, s2, 
                CompareOptions.IgnoreCase | CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth) == 0) {
                if (String.Compare(s1, s2, false, locale) == 0)
                    return 1;
                else
                    return -1;
            }
            return 0;
        }


        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.SyncRoot"]/*' />
        [Browsable(false)]
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\BaseCollection.uex' path='docs/doc[@for="BaseCollection.List"]/*' />
        protected virtual ArrayList List {
            get {
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\connectionstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConnectionState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\ConnectionState.uex' path='docs/doc[@for="ConnectionState"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies what the object is currently doing.
    ///    </para>
    /// </devdoc>
    [
    Flags()
    ]
    public enum ConnectionState {

        /// <include file='doc\ConnectionState.uex' path='docs/doc[@for="ConnectionState.Closed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object is closed.
        ///    </para>
        /// </devdoc>
        Closed = 0,

        /// <include file='doc\ConnectionState.uex' path='docs/doc[@for="ConnectionState.Open"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object is open.
        ///    </para>
        /// </devdoc>
        Open = 1,

        /// <include file='doc\ConnectionState.uex' path='docs/doc[@for="ConnectionState.Connecting"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object is connecting.
        ///    </para>
        /// </devdoc>
        Connecting = 2,

        /// <include file='doc\ConnectionState.uex' path='docs/doc[@for="ConnectionState.Executing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object is executing a command.
        ///    </para>
        /// </devdoc>
        Executing = 4,

        /// <include file='doc\ConnectionState.uex' path='docs/doc[@for="ConnectionState.Fetching"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Data is being retrieved.
        ///    </para>
        /// </devdoc>
        Fetching = 8,

        /// <include file='doc\ConnectionState.uex' path='docs/doc[@for="ConnectionState.Broken"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The object is broken. This can occur only after the
        ///       connection has been opened. A connection in this state may be
        ///       closed and then re-opened.
        ///    </para>
        /// </devdoc>
        Broken = 16,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\commandtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\CommandType.uex' path='docs/doc[@for="CommandType"]/*' />
    public enum CommandType {

        /// <include file='doc\CommandType.uex' path='docs/doc[@for="CommandType.Text"]/*' />
        Text            = 0x1,

      //Table           = 0x2,

        /// <include file='doc\CommandType.uex' path='docs/doc[@for="CommandType.StoredProcedure"]/*' />
        StoredProcedure = 0x4,

      //File            = 0x100,

        /// <include file='doc\CommandType.uex' path='docs/doc[@for="CommandType.TableDirect"]/*' />
        TableDirect     = 0x200,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\columntypeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColumnTypeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Data {
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type
    ///       converter that can be used to populate a list box with available types.</para>
    /// </devdoc>
    internal class ColumnTypeConverter : TypeConverter {
        private static Type[] types = new Type[] {
            typeof(Boolean),
            typeof(Byte),
            typeof(Byte[]),
            typeof(Char),
            typeof(DateTime),
            typeof(Decimal),
            typeof(Double),
            typeof(Guid),
            typeof(Int16),
            typeof(Int32),
            typeof(Int64),
            typeof(object),
            typeof(SByte),
            typeof(Single),
            typeof(string),
            typeof(TimeSpan),
            typeof(UInt16),
            typeof(UInt32),
            typeof(UInt64)
        };
        private StandardValuesCollection values;
        
        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.ConvertTo"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Converts the given value object to the specified destination type.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value == null) {
                    return String.Empty;
                }
                else {
                    value.ToString();
                }
            }
            if (value != null && destinationType == typeof(InstanceDescriptor)) {
                Object newValue = value;
                if (value is string) {
                    for (int i = 0; i < types.Length; i++) {
                        if (types[i].ToString().Equals(value))
                            newValue = types[i];
                    }
                }
                
                if (value is Type || value is string) {
                    MethodInfo method = typeof(Type).GetMethod("GetType", new Type[] {typeof(string)});
                    if (method != null) {
                        return new InstanceDescriptor(method, new object[] {((Type)newValue).AssemblyQualifiedName});
                    }
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertTo(context, sourceType);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value != null && value.GetType() == typeof(string)) {
                for (int i = 0; i < types.Length; i++) {
                    if (types[i].ToString().Equals(value))
                        return types[i];
                }

                return typeof(string);
            }
            
            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the data type this validator is
        ///       designed for.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                object[] objTypes;
                
                if (types != null) {
                    objTypes = new object[types.Length];
                    Array.Copy(types, objTypes, types.Length);
                }
                else {
                    objTypes = null;
                }
                
                values = new StandardValuesCollection(objTypes);
            }
            return values;
        }
    
        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.GetStandardValuesExclusive"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether the list of standard values returned from
        ///    <see cref='System.ComponentModel.TypeListConverter.GetStandardValues'/> is an exclusive list. </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether this object supports a
        ///       standard set of values that can be picked from a list using the specified
        ///       context.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\constraintcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConstraintCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing.Design;

    /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection"]/*' />
    /// <devdoc>
    /// <para>Represents a collection of constraints for a <see cref='System.Data.DataTable'/> 
    /// .</para>
    /// </devdoc>
    [
    DefaultEvent("CollectionChanged"),
    Editor("Microsoft.VSDesigner.Data.Design.ConstraintsCollectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    Serializable
    ]
    public class ConstraintCollection : InternalDataCollectionBase {

        private DataTable table      = null;
        // private Constraint[] constraints = new Constraint[2];
        private ArrayList list = new ArrayList();
        private int defaultNameIndex = 1;

        private CollectionChangeEventHandler onCollectionChanged;
        private Constraint[] delayLoadingConstraints;
        private bool fLoadForeignKeyConstraintsOnly = false;

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.ConstraintCollection"]/*' />
        /// <devdoc>
        /// ConstraintCollection constructor.  Used only by DataTable.
        /// </devdoc>
        internal ConstraintCollection(DataTable table) {
            this.table = table;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.List"]/*' />
        /// <devdoc>
        ///    <para>Gets the list of objects contained by the collection.</para>
        /// </devdoc>
        protected override ArrayList List {
            get {
                return list;
            }
        }
        
        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.this"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Data.Constraint'/> 
        /// from the collection at the specified index.</para>
        /// </devdoc>
        public virtual Constraint this[int index] {
            get {
                if (index >= 0 && index < List.Count) {
                    return(Constraint) List[index];
                }
                throw ExceptionBuilder.ConstraintOutOfRange(index);
            }
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Table"]/*' />
        /// <devdoc>
        /// The DataTable with which this ConstraintCollection is associated
        /// </devdoc>
        internal DataTable Table {
            get {
                return table;
            }
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.this1"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Data.Constraint'/> from the collection with the specified name.</para>
        /// </devdoc>
        public virtual Constraint this[string name] {
            get {
                int index = InternalIndexOf(name);
                if (index == -2) {
                    throw ExceptionBuilder.CaseInsensitiveNameConflict(name);
                }
                return (index < 0) ? null : (Constraint)List[index];
            }
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Add"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Adds the constraint to the collection.</para>
        /// </devdoc>
        public void Add(Constraint constraint) {

            if (constraint == null)
                throw ExceptionBuilder.ArgumentNull("constraint");

            // It is an error if we find an equivalent constraint already in collection
            if (FindConstraint(constraint) != null) {
                throw ExceptionBuilder.DuplicateConstraint(FindConstraint(constraint).ConstraintName);
            }

            if (constraint is UniqueConstraint) {
                if (((UniqueConstraint)constraint).bPrimaryKey) {
                    if (Table.primaryKey != null) {
                        throw ExceptionBuilder.AddPrimaryKeyConstraint();
                    }
                }
                AddUniqueConstraint((UniqueConstraint)constraint);
            }
            else if (constraint is ForeignKeyConstraint) {
                ForeignKeyConstraint fk = (ForeignKeyConstraint)constraint;
                UniqueConstraint key = fk.RelatedTable.Constraints.FindKeyConstraint(fk.RelatedColumns);
                if (key == null) {
                    if (constraint.ConstraintName.Length == 0)
                        constraint.ConstraintName = AssignName();
                    else
                        RegisterName(constraint.ConstraintName);

                    key = new UniqueConstraint(fk.RelatedColumns);
                    fk.RelatedTable.Constraints.Add(key);
                }
                AddForeignKeyConstraint((ForeignKeyConstraint)constraint);
            }

            BaseAdd(constraint);
            ArrayAdd(constraint);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, constraint));


            if (constraint is UniqueConstraint) {
                if (((UniqueConstraint)constraint).bPrimaryKey) {
                    Table.PrimaryKey = ((UniqueConstraint)constraint).Columns;
                }
            }
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Add1"]/*' />
        /// <devdoc>
        /// <para>Constructs a new <see cref='System.Data.UniqueConstraint'/> using the 
        ///    specified array of <see cref='System.Data.DataColumn'/>
        ///    objects and adds it to the collection.</para>
        /// </devdoc>
        public virtual Constraint Add(string name, DataColumn[] columns, bool primaryKey) {
            UniqueConstraint constraint = new UniqueConstraint(name, columns);
            Add(constraint);
            if (primaryKey)
                Table.PrimaryKey = columns;
            return constraint;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Add2"]/*' />
        /// <devdoc>
        /// <para>Constructs a new <see cref='System.Data.UniqueConstraint'/> using the 
        ///    specified <see cref='System.Data.DataColumn'/> and adds it to the collection.</para>
        /// </devdoc>
        public virtual Constraint Add(string name, DataColumn column, bool primaryKey) {
            UniqueConstraint constraint = new UniqueConstraint(name, column);
            Add(constraint);
            if (primaryKey)
                Table.PrimaryKey = constraint.Columns;
            return constraint;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Add3"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Constructs a new <see cref='System.Data.ForeignKeyConstraint'/>
        ///       with the
        ///       specified parent and child
        ///       columns and adds the constraint to the collection.</para>
        /// </devdoc>
        public virtual Constraint Add(string name, DataColumn primaryKeyColumn, DataColumn foreignKeyColumn) {
            ForeignKeyConstraint constraint = new ForeignKeyConstraint(name, primaryKeyColumn, foreignKeyColumn);
            Add(constraint);
            return constraint;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Add4"]/*' />
        /// <devdoc>
        /// <para>Constructs a new <see cref='System.Data.ForeignKeyConstraint'/> with the specified parent columns and 
        ///    child columns and adds the constraint to the collection.</para>
        /// </devdoc>
        public virtual Constraint Add(string name, DataColumn[] primaryKeyColumns, DataColumn[] foreignKeyColumns) {
            ForeignKeyConstraint constraint = new ForeignKeyConstraint(name, primaryKeyColumns, foreignKeyColumns);
            Add(constraint);
            return constraint;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.AddRange"]/*' />
        public void AddRange(Constraint[] constraints ) {
            if (table.fInitInProgress) {
                delayLoadingConstraints = constraints;
                fLoadForeignKeyConstraintsOnly = false;
                return;
            }
            
            if (constraints != null) {
                foreach(Constraint constr in constraints) {
                    if (constr != null) {
                        Add(constr);
                    }
                }
            }
        }


        private void AddUniqueConstraint(UniqueConstraint constraint) {
            DataColumn[] columns = constraint.Columns;

            for (int i = 0; i < columns.Length; i++) {
                if (columns[i].Table != this.table) {
                    throw ExceptionBuilder.ConstraintForeignTable();
                }
            }

            constraint.Key.GetSortIndex().AddRef();

            if (!constraint.CanEnableConstraint()) {
                constraint.Key.GetSortIndex().RemoveRef();
                throw ExceptionBuilder.UniqueConstraintViolation();
            }
        }

        private void AddForeignKeyConstraint(ForeignKeyConstraint constraint) {
            if (!constraint.CanEnableConstraint()) {
                throw ExceptionBuilder.ConstraintParentValues();
            }
            constraint.CheckCanAddToCollection(this);
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.CollectionChanged"]/*' />
        /// <devdoc>
        /// <para>Occurs when the <see cref='System.Data.ConstraintCollection'/> is changed through additions or 
        ///    removals.</para>
        /// </devdoc>
        public event CollectionChangeEventHandler CollectionChanged {
            add {
                onCollectionChanged += value;
            }
            remove {
                onCollectionChanged -= value;
            }
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.ArrayAdd"]/*' />
        /// <devdoc>
        ///  Adds the constraint to the constraints array.
        /// </devdoc>
        private void ArrayAdd(Constraint constraint) {
            Debug.Assert(constraint != null, "Attempt to add null constraint to constraint array");
            List.Add(constraint);
        }

        private void ArrayRemove(Constraint constraint) {
            List.Remove(constraint);
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.AssignName"]/*' />
        /// <devdoc>
        /// Creates a new default name.
        /// </devdoc>
        internal string AssignName() {
            string newName = MakeName(defaultNameIndex);
            defaultNameIndex++;
            return newName;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.BaseAdd"]/*' />
        /// <devdoc>
        /// Does verification on the constraint and it's name.
        /// An ArgumentNullException is thrown if this constraint is null.  An ArgumentException is thrown if this constraint
        /// already belongs to this collection, belongs to another collection.
        /// A DuplicateNameException is thrown if this collection already has a constraint with the same
        /// name (case insensitive).
        /// </devdoc>
        private void BaseAdd(Constraint constraint) {
            if (constraint == null)
                throw ExceptionBuilder.ArgumentNull("constraint");

            if (constraint.ConstraintName.Length == 0)
                constraint.ConstraintName = AssignName();
            else
                RegisterName(constraint.ConstraintName);

            constraint.InCollection = true;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.BaseGroupSwitch"]/*' />
        /// <devdoc>
        /// BaseGroupSwitch will intelligently remove and add tables from the collection.
        /// </devdoc>
        private void BaseGroupSwitch(Constraint[] oldArray, int oldLength, Constraint[] newArray, int newLength) {
            // We're doing a smart diff of oldArray and newArray to find out what
            // should be removed.  We'll pass through oldArray and see if it exists
            // in newArray, and if not, do remove work.  newBase is an opt. in case
            // the arrays have similar prefixes.
            int newBase = 0;
            for (int oldCur = 0; oldCur < oldLength; oldCur++) {
                bool found = false;
                for (int newCur = newBase; newCur < newLength; newCur++) {
                    if (oldArray[oldCur] == newArray[newCur]) {
                        if (newBase == newCur) {
                            newBase++;
                        }
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    // This means it's in oldArray and not newArray.  Remove it.
                    BaseRemove(oldArray[oldCur]);
                    List.Remove(oldArray[oldCur]);

                }
            }

            // Now, let's pass through news and those that don't belong, add them.
            for (int newCur = 0; newCur < newLength; newCur++) {
                if (!newArray[newCur].InCollection)
                    BaseAdd(newArray[newCur]);
                List.Add(newArray[newCur]);
            }
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.BaseRemove"]/*' />
        /// <devdoc>
        /// Does verification on the constraint and it's name.
        /// An ArgumentNullException is thrown if this constraint is null.  An ArgumentException is thrown
        /// if this constraint doesn't belong to this collection or if this constraint is part of a relationship.
        /// </devdoc>
        private void BaseRemove(Constraint constraint) {
            if (constraint == null) {
                throw ExceptionBuilder.ArgumentNull("constraint");
            }
            if (constraint.Table != table) {
                throw ExceptionBuilder.ConstraintRemoveFailed();
            }

            UnregisterName(constraint.ConstraintName);
            constraint.InCollection = false;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.CanRemove"]/*' />
        /// <devdoc>
        /// <para>Indicates if a <see cref='System.Data.Constraint'/> can be removed.</para>
        /// </devdoc>
        // PUBLIC because called by design-time... need to consider this.
        public bool CanRemove(Constraint constraint) {
            return CanRemove(constraint, /*fThrowException:*/false);
        }
        
        internal bool CanRemove(Constraint constraint, bool fThrowException) {
            return constraint.CanBeRemovedFromCollection(this, fThrowException);
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Clear"]/*' />
        /// <devdoc>
        /// <para>Clears the collection of any <see cref='System.Data.Constraint'/> 
        /// objects.</para>
        /// </devdoc>
        public void Clear() {
            if (table != null) {
                table.PrimaryKey = null;

                for (int i = 0; i < table.ParentRelations.Count; i++) {
                    table.ParentRelations[i].SetChildKeyConstraint(null);
                }
                for (int i = 0; i < table.ChildRelations.Count; i++) {
                    table.ChildRelations[i].SetParentKeyConstraint(null);
                }
            }
            
            if (table.fInitInProgress && delayLoadingConstraints != null) {
                delayLoadingConstraints = null;
                fLoadForeignKeyConstraintsOnly = false;
            }
                    
            int oldLength = List.Count;
            
            Constraint[] constraints = new Constraint[List.Count];
            List.CopyTo(constraints, 0);
            try {
                // this will smartly add and remove the appropriate tables.
                BaseGroupSwitch(constraints, oldLength, null, 0);
            }
            catch (Exception e) {
                // something messed up.  restore to original state.
                BaseGroupSwitch(null, 0, constraints, oldLength);
                List.Clear();
                for (int i = 0; i < oldLength; i++)
                    List.Add(constraints[i]);

                throw e;
            }

            List.Clear();
            OnCollectionChanged(RefreshEventArgs);            
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Indicates whether the <see cref='System.Data.Constraint'/>, specified by name, exists in the collection.</para>
        /// </devdoc>
        public bool Contains(string name) {
            return (InternalIndexOf(name) >= 0);
        }

        internal bool Contains(string name, bool caseSensitive) {
            if (!caseSensitive)
                return Contains(name);
            int index = InternalIndexOf(name);
            if (index<0)
                return false;
            return (name == ((Constraint) List[index]).ConstraintName);
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.FindConstraint"]/*' />
        /// <devdoc>
        /// Returns a matching constriant object.
        /// </devdoc>
        internal Constraint FindConstraint(Constraint constraint) {
            int constraintCount = List.Count;
            for (int i = 0; i < constraintCount; i++) {
                if (((Constraint)List[i]).Equals(constraint))
                    return(Constraint)List[i];
            }
            return null;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.FindKeyConstraint"]/*' />
        /// <devdoc>
        /// Returns a matching constriant object.
        /// </devdoc>
        internal UniqueConstraint FindKeyConstraint(DataColumn[] columns) {
            int constraintCount = List.Count;
            for (int i = 0; i < constraintCount; i++) {
                if (List[i] is UniqueConstraint && CompareArrays(((UniqueConstraint)List[i]).Key.Columns, columns))
                    return(UniqueConstraint)List[i];
            }
            return null;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.FindKeyConstraint1"]/*' />
        /// <devdoc>
        /// Returns a matching constriant object.
        /// </devdoc>
        internal UniqueConstraint FindKeyConstraint(DataColumn column) {
            int constraintCount = List.Count;
            for (int i = 0; i < constraintCount; i++) {
                if ((List[i] is UniqueConstraint) && (((UniqueConstraint)List[i]).Key.Columns.Length == 1) && (((UniqueConstraint)List[i]).Key.Columns[0] == column))
                    return(UniqueConstraint)List[i];
            }
            return null;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.FindForeignKeyConstraint"]/*' />
        /// <devdoc>
        /// Returns a matching constriant object.
        /// </devdoc>
        internal ForeignKeyConstraint FindForeignKeyConstraint(DataColumn[] parentColumns, DataColumn[] childColumns) {
            int constraintCount = List.Count;
            for (int i = 0; i < constraintCount; i++) {
                if ((List[i] is ForeignKeyConstraint) &&
                    CompareArrays(((ForeignKeyConstraint)List[i]).ParentKey.Columns, parentColumns) &&
                    CompareArrays(((ForeignKeyConstraint)List[i]).ChildKey.Columns, childColumns))
                    return(ForeignKeyConstraint)List[i];
            }
            return null;
        }

        private static bool CompareArrays(DataColumn[] a1, DataColumn[] a2) {
            Debug.Assert(a1 != null && a2 != null, "Invalid Arguments");
            if (a1.Length != a2.Length)
                return false;
            for (int i = 0; i < a1.Length; i++) {
                if (a1[i] != a2[i])
                    return false;
            }
            return true;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.IndexOf1"]/*' />
        /// <devdoc>
        /// <para>Returns the index of the specified <see cref='System.Data.Constraint'/> .</para>
        /// </devdoc>
        public int IndexOf(Constraint constraint) {
            if (null != constraint) {
                int count = Count;
                for (int i = 0; i < count; ++i) {
                    if (constraint == (Constraint) List[i])
                        return i;
                }
                // didnt find the constraint
            }
            return -1;
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.IndexOf"]/*' />
        /// <devdoc>
        /// <para>Returns the index of the <see cref='System.Data.Constraint'/>, specified by name.</para>
        /// </devdoc>
        public virtual int IndexOf(string constraintName) {
            int index = InternalIndexOf(constraintName);
            return (index < 0) ? -1 : index;
        }

        // Return value:
        //      >= 0: find the match
        //        -1: No match
        //        -2: At least two matches with different cases
        internal int InternalIndexOf(string constraintName) {
            int cachedI = -1;
            if ((null != constraintName) && (0 < constraintName.Length)) {
                int constraintCount = List.Count;
                int result = 0;
                for (int i = 0; i < constraintCount; i++) {
                    Constraint constraint = (Constraint) List[i];
                    result = NamesEqual(constraint.ConstraintName, constraintName, false, table.Locale);
                    if (result == 1)
                        return i;

                    if (result == -1)
                        cachedI = (cachedI == -1) ? i : -2;
                }
            }
            return cachedI;                    
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.MakeName"]/*' />
        /// <devdoc>
        /// Makes a default name with the given index.  e.g. Constraint1, Constraint2, ... Constrainti
        /// </devdoc>
        private string MakeName(int index) {
            return "Constraint" + (index).ToString();
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.OnCollectionChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Data.ConstraintCollection.CollectionChanged'/> event.</para>
        /// </devdoc>
        protected virtual void OnCollectionChanged(CollectionChangeEventArgs ccevent) {
            if (onCollectionChanged != null) {
                onCollectionChanged(this, ccevent);
            }
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.RegisterName"]/*' />
        /// <devdoc>
        /// Registers this name as being used in the collection.  Will throw an ArgumentException
        /// if the name is already being used.  Called by Add, All property, and Constraint.ConstraintName property.
        /// if the name is equivalent to the next default name to hand out, we increment our defaultNameIndex.
        /// </devdoc>
        internal void RegisterName(string name) {
            Debug.Assert (name != null);

            int constraintCount = List.Count;
            for (int i = 0; i < constraintCount; i++) {
                if (NamesEqual(name, ((Constraint)List[i]).ConstraintName, true, table.Locale) != 0) {
                    throw ExceptionBuilder.DuplicateConstraintName(((Constraint)List[i]).ConstraintName);
                }
            }
            if (NamesEqual(name, MakeName(defaultNameIndex), true, table.Locale) != 0) {
                defaultNameIndex++;
            }
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Removes the specified <see cref='System.Data.Constraint'/>
        ///       from the collection.</para>
        /// </devdoc>
        public void Remove(Constraint constraint) {
            if (constraint == null)
                throw ExceptionBuilder.ArgumentNull("constraint");

            // this will throw an exception if it can't be removed, otherwise indicates
            // whether we need to remove it from the collection.
            if (CanRemove(constraint, true)) {
                // constraint can be removed
                BaseRemove(constraint);
                ArrayRemove(constraint);
                if (constraint is UniqueConstraint && ((UniqueConstraint)constraint).IsPrimaryKey) {
                    Table.PrimaryKey = null;
                }

                if (constraint is UniqueConstraint) {
                    for (int i = 0; i < Table.ChildRelations.Count; i++) {
                        DataRelation rel = Table.ChildRelations[i];
                        if (rel.ParentKeyConstraint == constraint)
                            rel.SetParentKeyConstraint(null);
                    }
                    DataKey key = ((UniqueConstraint)constraint).Key;
                    key.GetSortIndex().RemoveRef();
                }
                else if (constraint is ForeignKeyConstraint) {
                    for (int i = 0; i < Table.ParentRelations.Count; i++) {
                        DataRelation rel = Table.ParentRelations[i];
                        if (rel.ChildKeyConstraint == constraint)
                            rel.SetChildKeyConstraint(null);
                    }
                }

                OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, constraint));
            }
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>Removes the constraint at the specified index from the
        ///       collection.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            Constraint c = this[index];
            if (c == null)
                throw ExceptionBuilder.ConstraintOutOfRange(index);
            Remove(c);
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Remove1"]/*' />
        /// <devdoc>
        ///    <para>Removes the constraint, specified by name, from the collection.</para>
        /// </devdoc>
        public void Remove(string name) {
            Constraint c = this[name];
            if (c == null)
                throw ExceptionBuilder.ConstraintNotInTheTable(name);
            Remove(c);
        }

        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.UnregisterName"]/*' />
        /// <devdoc>
        /// Unregisters this name as no longer being used in the collection.  Called by Remove, All property, and
        /// Constraint.ConstraintName property.  If the name is equivalent to the last proposed default namem, we walk backwards
        /// to find the next proper default name to hang out.
        /// </devdoc>
        internal void UnregisterName(string name) {
            if (NamesEqual(name, MakeName(defaultNameIndex - 1), true, table.Locale) != 0) {
                do {
                    defaultNameIndex--;
                } while (defaultNameIndex > 1 &&
                         !Contains(MakeName(defaultNameIndex - 1)));
            }
        }

        internal void FinishInitConstraints() {
            if (delayLoadingConstraints == null)
                return;
                
            int colCount;
            DataColumn[] parents, childs;
            for (int i = 0; i < delayLoadingConstraints.Length; i++) {
                if (delayLoadingConstraints[i] is UniqueConstraint) {
                    if (fLoadForeignKeyConstraintsOnly)
                        continue;
                    
                    UniqueConstraint constr = (UniqueConstraint) delayLoadingConstraints[i];
                    if (constr.columnNames == null) {
                        this.Add(constr);
                        continue;
                    }
                    colCount = constr.columnNames.Length;
                    parents = new DataColumn[colCount]; 
                    for (int j = 0; j < colCount; j++)
                        parents[j] = table.Columns[constr.columnNames[j]];
                    if (constr.bPrimaryKey) {
                        if (table.primaryKey != null) {
                            throw ExceptionBuilder.AddPrimaryKeyConstraint();
                        }
                        else {
                            Add(constr.ConstraintName,parents,true);
                        }
                        continue;
                    }
                    UniqueConstraint newConstraint = new UniqueConstraint(constr.constraintName, parents);
                    if (FindConstraint(newConstraint) == null)
                        this.Add(newConstraint);
                }
                else {
                    ForeignKeyConstraint constr = (ForeignKeyConstraint) delayLoadingConstraints[i];
                    if (constr.parentColumnNames == null ||constr.childColumnNames == null) {
                        this.Add(constr);
                        continue;
                    }

                    if (table.DataSet == null) {
                        fLoadForeignKeyConstraintsOnly = true;
                        continue;
                    }
                        
                    colCount = constr.parentColumnNames.Length;
                    parents = new DataColumn[colCount];
                    childs = new DataColumn[colCount];
                    for (int j = 0; j < colCount; j++) {
                        parents[j] = table.DataSet.Tables[constr.parentTableName].Columns[constr.parentColumnNames[j]];
                        childs[j] =  table.Columns[constr.childColumnNames[j]];
                    }
                    ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constr.constraintName, parents, childs);
                    newConstraint.AcceptRejectRule = constr.acceptRejectRule;
                    newConstraint.DeleteRule = constr.deleteRule;
                    newConstraint.UpdateRule = constr.updateRule;
                    this.Add(newConstraint);
                }
            }

            if (!fLoadForeignKeyConstraintsOnly)
                delayLoadingConstraints = null;
        }

#if DEBUG
        /// <include file='doc\ConstraintCollection.uex' path='docs/doc[@for="ConstraintCollection.Dump"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public void Dump(string header, bool deep) {
            Debug.WriteLine(header + "ConstraintCollection");
            header += "  ";
            Debug.WriteLine(header + "Count:  " + this.Count.ToString());
            if (deep) {
                Debug.WriteLine(header + "Constraints present:");
                header += "  ";
                for (int i = 0; i < this.Count; i++) {
                    this[i].Dump(header, true);
                }
            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\commandbehavior.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandBehavior.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\CommandBehavior.uex' path='docs/doc[@for="CommandBehavior"]/*' />
    [
    Flags()
    ]
    public enum CommandBehavior {
        /// <include file='doc\CommandBehavior.uex' path='docs/doc[@for="CommandBehavior.Default"]/*' />
        Default         = 0,  // with data, multiple results, may affect database, MDAC 68240

        /// <include file='doc\CommandBehavior.uex' path='docs/doc[@for="CommandBehavior.SingleResult"]/*' />
        SingleResult    = 1,  // with data, force single result, may affect database

        /// <include file='doc\CommandBehavior.uex' path='docs/doc[@for="CommandBehavior.SchemaOnly"]/*' />
        SchemaOnly      = 2,  // column info, no data, no effect on database

        /// <include file='doc\CommandBehavior.uex' path='docs/doc[@for="CommandBehavior.KeyInfo"]/*' />
        KeyInfo         = 4,  // column info + primary key information (if available)

        // UNDONE: SingleRow = 8 | SingleResult,
        /// <include file='doc\CommandBehavior.uex' path='docs/doc[@for="CommandBehavior.SingleRow"]/*' />
        SingleRow       = 8, // data, hint single row and single result, may affect database - doesn't apply to child(chapter) results

        /// <include file='doc\CommandBehavior.uex' path='docs/doc[@for="CommandBehavior.SequentialAccess"]/*' />
        SequentialAccess = 0x10,
        
        /// <include file='doc\CommandBehavior.uex' path='docs/doc[@for="CommandBehavior.CloseConnection"]/*' />
        CloseConnection = 0x20
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\constraint.cs ===
//------------------------------------------------------------------------------
// <copyright file="Constraint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;
        using System.Globalization;

    /// <include file='doc\Constraint.uex' path='docs/doc[@for="Constraint"]/*' />
    /// <devdoc>
    ///    <para>Represents a constraint that can be enforced on one or
    ///       more <see cref='System.Data.DataColumn'/> objects.</para>
    /// </devdoc>
    [
    DefaultProperty("ConstraintName"),
    TypeConverter(typeof(ConstraintConverter))
    ]
    [Serializable]
    public abstract class Constraint {
        internal String name = "";
        private String _schemaName = "";
        private bool inCollection = false;
        private DataSet dataSet = null;

        internal PropertyCollection extendedProperties = null;

        /// <include file='doc\Constraint.uex' path='docs/doc[@for="Constraint.ConstraintName"]/*' />
        /// <devdoc>
        /// <para>The name of this constraint within the <see cref='System.Data.ConstraintCollection'/> 
        /// .</para>
        /// </devdoc>
        [
        DefaultValue(""), 
        DataSysDescription(Res.ConstraintNameDescr),
        DataCategory(Res.DataCategory_Data)
        ]
        public virtual string ConstraintName {
            get {
                return name;
            }
            set {
                if (value == null)
                    value = "";

                if (value == "" && (Table != null) && InCollection)
                    throw ExceptionBuilder.NoConstraintName();

                CultureInfo locale = (Table != null ? Table.Locale : CultureInfo.CurrentCulture);
                if (String.Compare(name, value, true, locale) != 0) {
                    if ((Table != null) && InCollection) {
                        Table.Constraints.RegisterName(value);
                        if (name.Length != 0)
                            Table.Constraints.UnregisterName(name);
                    }
                    name = value;
                }
                else if (String.Compare(name, value, false, locale) != 0) {
                    name = value;
                }
            }
        }

        internal String SchemaName {
            get {
                if (_schemaName == "")
                    return ConstraintName;
                else
                    return _schemaName;
            }

            set {
                if (value != "")
                    _schemaName = value;
            }
        }


        internal virtual bool InCollection {
            get {		// ACCESSOR: virtual was missing from this get
                return inCollection;
            }
            set {
                inCollection = value;
                if (value)
                    dataSet = Table.DataSet;
                else
                    dataSet = null;
            }
        }

        /// <include file='doc\Constraint.uex' path='docs/doc[@for="Constraint.Table"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Data.DataTable'/> to which the constraint applies.</para>
        /// </devdoc>
        [DataSysDescription(Res.ConstraintTableDescr)]
        public abstract DataTable Table {
            get;
        }

        /// <include file='doc\Constraint.uex' path='docs/doc[@for="DataTable.ExtendedProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of customized user information.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data), 
        Browsable(false),
        DataSysDescription(Res.ExtendedPropertiesDescr)
        ]
        public PropertyCollection ExtendedProperties {
            get {
                if (extendedProperties == null) {
                    extendedProperties = new PropertyCollection();
                }
                return extendedProperties;
            }
        }

        internal abstract bool ContainsColumn(DataColumn column);

        internal abstract bool CanEnableConstraint();

        internal abstract Constraint Clone(DataSet destination);

        internal void CheckConstraint() {
            if (!CanEnableConstraint()) {
                throw ExceptionBuilder.ConstraintViolation(ConstraintName);
            }
        }

        internal abstract void CheckCanAddToCollection(ConstraintCollection constraint);
        internal abstract bool CanBeRemovedFromCollection(ConstraintCollection constraint, bool fThrowException);

        internal abstract void CheckConstraint(DataRow row, DataRowAction action);
        internal abstract void CheckState();

        /// <include file='doc\Constraint.uex' path='docs/doc[@for="Constraint.CheckStateForProperty"]/*' />
         protected void CheckStateForProperty() {
            try {
                CheckState();
            }
            catch (Exception e) {
                throw ExceptionBuilder.BadObjectPropertyAccess(e.Message);            
            }
        }

        /// <include file='doc\Constraint.uex' path='docs/doc[@for="Constraint._DataSet"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Data.DataSet'/> to which this constraint belongs.</para>
        /// </devdoc>
        [CLSCompliant(false)]
        internal protected virtual DataSet _DataSet {
            get {
                return dataSet;
            }
        }
        
        /// <include file='doc\Constraint.uex' path='docs/doc[@for="Constraint.SetDataSet"]/*' />
        /// <devdoc>
        /// <para>Sets the constraint's <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        protected internal void SetDataSet(DataSet dataSet) {
            this.dataSet = dataSet;
        }
        internal abstract bool IsConstraintViolated();

        /// <include file='doc\Constraint.uex' path='docs/doc[@for="Constraint.ToString"]/*' />
         public override string ToString() {
            return ConstraintName;
        }
        
#if DEBUG
        /// <include file='doc\Constraint.uex' path='docs/doc[@for="Constraint.Dump"]/*' />
        /// <internalonly/>
         [System.Diagnostics.Conditional("DEBUG")]
        public abstract void Dump(string header, bool deep);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\constraintconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConstraintConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\ConstraintConverter.uex' path='docs/doc[@for="ConstraintConverter"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    sealed internal class ConstraintConverter : ExpandableObjectConverter {

        /// <include file='doc\ConstraintConverter.uex' path='docs/doc[@for="ConstraintConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\ConstraintConverter.uex' path='docs/doc[@for="ConstraintConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is Constraint) {
                if (value is UniqueConstraint) {
                    UniqueConstraint constr = (UniqueConstraint)value;
                    ConstructorInfo ctor = typeof(UniqueConstraint).GetConstructor(new Type[] { typeof(string), typeof(string[]), typeof(bool) } );
                    if (ctor != null)
                        return new InstanceDescriptor(ctor, new object[] { constr.ConstraintName, constr.ColumnNames, constr.IsPrimaryKey });
                }
                else {
                    ForeignKeyConstraint constr = (ForeignKeyConstraint)value;
                    ConstructorInfo ctor = typeof(ForeignKeyConstraint).GetConstructor(new Type[] { typeof(string), typeof(string), typeof(string[]), 
                        typeof(string[]), typeof(AcceptRejectRule), typeof(Rule), typeof(Rule) } );
                    if (ctor != null)
                        return new InstanceDescriptor(ctor, new object[] { constr.ConstraintName, constr.ParentKey.Table.TableName, constr.ParentColumnNames,
                        constr.ChildColumnNames, constr.AcceptRejectRule, constr.DeleteRule, constr.UpdateRule });
                }                                        
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datacolumnchangeevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataColumnChangeEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\DataColumnChangeEvent.uex' path='docs/doc[@for="DataColumnChangeEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Data.DataTable.ColumnChanging'/> event.
    ///    </para>
    /// </devdoc>
    public class DataColumnChangeEventArgs : EventArgs {

        private DataColumn column;
        private object proposedValue;
        private DataRow row;

        internal DataColumnChangeEventArgs() {
        }

        /// <include file='doc\DataColumnChangeEvent.uex' path='docs/doc[@for="DataColumnChangeEventArgs.DataColumnChangeEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.DataColumnChangeEventArgs'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public DataColumnChangeEventArgs(DataRow row, DataColumn column, object value) {
            this.row = row;
            this.column = column;
            this.proposedValue = value;
        }

        /// <include file='doc\DataColumnChangeEvent.uex' path='docs/doc[@for="DataColumnChangeEventArgs.Column"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the column whose value is changing.
        ///    </para>
        /// </devdoc>
        public DataColumn Column {
            get {
                return column;
            }
        }

        /// <include file='doc\DataColumnChangeEvent.uex' path='docs/doc[@for="DataColumnChangeEventArgs.Row"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataRow Row {
            get {
                return row;
            }
        }

        /// <include file='doc\DataColumnChangeEvent.uex' path='docs/doc[@for="DataColumnChangeEventArgs.ProposedValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the proposed value.
        ///    </para>
        /// </devdoc>
        public object ProposedValue {
            get {
                return proposedValue;
            }
            set {
                this.proposedValue = value;
            }
        }

        internal void Initialize(DataRow row, DataColumn column, object value) {
            this.row = row;
            this.column = column;
            this.proposedValue = value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\constraintenumerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConstraintEnumerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\ConstraintEnumerator.uex' path='docs/doc[@for="ConstraintEnumerator"]/*' />
    /// <devdoc>
    /// ConstraintEnumerator is an object for enumerating all constraints in a DataSet
    /// </devdoc>
    internal class ConstraintEnumerator {

        System.Collections.IEnumerator tables;
        System.Collections.IEnumerator constraints;
        Constraint currentObject; 

        public ConstraintEnumerator(DataSet dataSet) {
            tables = (dataSet != null) ? dataSet.Tables.GetEnumerator() : null;
            currentObject = null;
        }

        public bool GetNext() {
            Constraint candidate;
            currentObject = null;
            while (tables != null) {
                if (constraints == null) {
                    if (!tables.MoveNext()) {
                        tables = null;
                        return false;
                    }
                    constraints = ((DataTable)tables.Current).Constraints.GetEnumerator();
                }

                if (!constraints.MoveNext()) {
                    constraints = null;
                    continue;
                }

                Debug.Assert(constraints.Current is Constraint, "ConstraintEnumerator, contains object which is not constraint");
                candidate = (Constraint)constraints.Current;
                if (IsValidCandidate(candidate)) {
                    currentObject = candidate;
                    return true;
                }

            }
            return false;
        }

        public Constraint GetConstraint() {
            // If currentObject is null we are before first GetNext or after last GetNext--consumer is bad
            Debug.Assert (currentObject != null, "GetObject should never be called w/ null currentObject.");
            return currentObject;   
        }

        protected virtual bool IsValidCandidate(Constraint constraint) {
            return true;
        }

        protected Constraint CurrentObject {
            get {
                return currentObject;
            }
        }

    }

    internal class ForeignKeyConstraintEnumerator : ConstraintEnumerator {

        public ForeignKeyConstraintEnumerator(DataSet dataSet) : base(dataSet) {

        }

        protected override bool IsValidCandidate(Constraint constraint) {
            return(constraint is ForeignKeyConstraint);
        }

        public ForeignKeyConstraint GetForeignKeyConstraint() {
            // If CurrentObject is null we are before first GetNext or after last GetNext--consumer is bad
            Debug.Assert (CurrentObject != null, "GetObject should never be called w/ null currentObject.");
            return(ForeignKeyConstraint)CurrentObject;   
        }
    }

    internal class ChildForeignKeyConstraintEnumerator : ForeignKeyConstraintEnumerator {

        // this is the table to do comparisons against
        DataTable table;
        public ChildForeignKeyConstraintEnumerator(DataSet dataSet, DataTable inTable) : base(dataSet) {
            this.table = inTable;
        }

        protected override bool IsValidCandidate(Constraint constraint) {
            return((constraint is ForeignKeyConstraint) && (((ForeignKeyConstraint)constraint).Table == table));
        }
    }

    internal class ParentForeignKeyConstraintEnumerator : ForeignKeyConstraintEnumerator {

        // this is the table to do comparisons against
        DataTable table;
        public ParentForeignKeyConstraintEnumerator(DataSet dataSet, DataTable inTable) : base(dataSet) {
            this.table = inTable;
        }

        protected override bool IsValidCandidate(Constraint constraint) {
            return((constraint is ForeignKeyConstraint) && (((ForeignKeyConstraint)constraint).RelatedTable == table));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datacolumn.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataColumn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Xml;
    using System.Data.Common;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Collections;    
    using System.Drawing.Design;
    using System.Globalization;

    /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents one column of data in a <see cref='System.Data.DataTable'/>.
    ///    </para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    DefaultProperty("ColumnName"),
    Editor("Microsoft.VSDesigner.Data.Design.DataColumnEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    ]
    public class DataColumn : MarshalByValueComponent {

        // properties
        private bool allowNull              = true;
        private bool autoIncrement          = false;
        private Int64 autoIncrementStep       = 1;
        private Int64 autoIncrementSeed       = 0;
        private string caption              = null;
        private string _columnName          = null;
        private Type dataType               = null;
        internal object defaultValue        = DBNull.Value;             // DefaultValue Converter
        private DataExpression expression   = null;
        private int maxLength             = -1;
        internal int ordinal                = -1;
        private bool readOnly               = false;
        private Index sortIndex             = null;
        internal DataTable table            = null;
        private bool unique                 = false;
        internal MappingType columnMapping  = MappingType.Element;
        internal int hashCode               = 0;

        internal int errors;

        // collections
        internal PropertyCollection extendedProperties = null;

        // events
        private PropertyChangedEventHandler onPropertyChangingDelegate = null;

        // state
        private DataStorage storage      = null;
        internal Int64 autoIncrementCurrent = 0;

        //
        // The _columnClass member is the class for the unfoliated virtual nodes in the XML.
        //
        internal string _columnUri        = null;
        private string _columnPrefix     = "";
        internal string encodedColumnName  = null;     

        // XML-specific Column Properties
        internal string description = "";

        // UNDONE: change to enum
        internal string dttype = "";        // The type specified in dt:type attribute
        internal SimpleType simpleType = null; 


        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.DataColumn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of a <see cref='System.Data.DataColumn'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public DataColumn() : this(null, typeof(string), null, MappingType.Element) {
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.DataColumn1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Inititalizes a new instance of the <see cref='System.Data.DataColumn'/> class
        ///       using the specified column name.
        ///    </para>
        /// </devdoc>
        public DataColumn(string columnName) : this(columnName, typeof(string), null, MappingType.Element) {
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.DataColumn2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Inititalizes a new instance of the <see cref='System.Data.DataColumn'/> class
        ///       using the specified column name and data type.
        ///    </para>
        /// </devdoc>
        public DataColumn(string columnName, Type dataType) : this(columnName, dataType, null, MappingType.Element) {
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.DataColumn3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance
        ///       of the <see cref='System.Data.DataColumn'/> class
        ///       using the specified name, data type, and expression.
        ///    </para>
        /// </devdoc>
        public DataColumn(string columnName, Type dataType, string expr) : this(columnName, dataType, expr, MappingType.Element) {
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.DataColumn4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.DataColumn'/> class
        ///       using
        ///       the specified name, data type, expression, and value that determines whether the
        ///       column is an attribute.
        ///    </para>
        /// </devdoc>
        public DataColumn(string columnName, Type dataType, string expr, MappingType type) {
            GC.SuppressFinalize(this);
            this._columnName = (columnName == null ? "" : columnName);
            if (dataType == null) {
                throw ExceptionBuilder.ArgumentNull("dataType");
            }
            this.SimpleType = SimpleType.CreateSimpleType(dataType);
            this.dataType = dataType;

            if ((null != expr) && (0 < expr.Length)) {
                // @perfnote: its a performance hit to set Expression to the empty str when we know it will come out null
                this.Expression = expr;
            }
            this.columnMapping = type;

            this.errors = 0;
        }


        // PUBLIC PROPERTIES

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.AllowDBNull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether null
        ///       values are
        ///       allowed in this column for rows belonging to the table.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(true),
        DataSysDescription(Res.DataColumnAllowNullDescr)
        ]
        public bool AllowDBNull {
            get {
                return allowNull;
            }
            set {
                if (allowNull != value) {
                    if (table != null) {
                        if (!value && table.EnforceConstraints)
                            CheckNotAllowNull();
                    }
                    this.allowNull = value;
                }
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.AutoIncrement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets a value indicating whether the column automatically increments the value of the column for new
        ///       rows added to the table.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        RefreshProperties(RefreshProperties.All),
        DefaultValue(false),
        DataSysDescription(Res.DataColumnAutoIncrementDescr)
        ]
        public bool AutoIncrement {
            get {
                return autoIncrement;
            }
            set {
                if (autoIncrement != value) {
                    if (value) {
                        if (expression != null) {
                            throw ExceptionBuilder.AutoIncrementAndExpression();
                        }
                        if (defaultValue != null && defaultValue != DBNull.Value) {
                            throw ExceptionBuilder.AutoIncrementAndDefaultValue();
                        }
                        if (!IsAutoIncrementType(DataType)) {
                            DataType = typeof(int);
                        }
                    }
                    autoIncrement = value;
                }
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.AutoIncrementSeed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the starting value for a column that has its
        ///    <see cref='System.Data.DataColumn.AutoIncrement'/> property 
        ///       set to <see langword='true'/>
        ///       .
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue((Int64)0),
        DataSysDescription(Res.DataColumnAutoIncrementSeedDescr)
        ]
        public Int64 AutoIncrementSeed {
            get {
                return autoIncrementSeed;
            }
            set {
                if (autoIncrementSeed != value) {
                    if (autoIncrementCurrent == autoIncrementSeed) {
                        autoIncrementCurrent = value;
                    }

                    if (AutoIncrementStep > 0) {
                        if (autoIncrementCurrent < value) {
                            autoIncrementCurrent = value;
                        }
                    }
                    else {
                        if (autoIncrementCurrent > value) {
                            autoIncrementCurrent = value;
                        }
                    }

                    autoIncrementSeed = value;
                }
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.AutoIncrementStep"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the increment used by a column with its <see cref='System.Data.DataColumn.AutoIncrement'/>
        ///       property set to <see langword='true'/>
        ///       .
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue((Int64)1),
        DataSysDescription(Res.DataColumnAutoIncrementStepDescr)
        ]
        public Int64 AutoIncrementStep {
            get {
                return autoIncrementStep;
            }
            set {
                if (autoIncrementStep != value) {
                    if (value == 0)
                        throw ExceptionBuilder.AutoIncrementSeed();
		    if (autoIncrementCurrent != autoIncrementSeed)
			autoIncrementCurrent += (value - autoIncrementStep);
                    autoIncrementStep = value;
                }
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.Caption"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the caption for this column.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataColumnCaptionDescr)
        ]
        public string Caption {
            get {
                return(caption != null) ? caption : _columnName;
            }
            set {
                if (value == null)
                    value = "";

                CultureInfo locale = (table != null ? table.Locale : CultureInfo.CurrentCulture);
                if (caption == null || String.Compare(caption, value, true, locale) != 0) {
                    caption = value;
                }
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataColumn.Caption'/> property to its previous value, or
        ///       to <see langword='null'/> .
        ///    </para>
        /// </devdoc>
        private void ResetCaption() {
            if (caption != null) {
                caption = null;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the <see cref='System.Data.DataColumn.Caption'/> has been explicitly set.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeCaption() {
            return(caption != null);
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.ColumnName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the column within the <see cref='System.Data.DataColumnCollection'/>.
        ///    </para>
        /// </devdoc>
        [
        RefreshProperties(RefreshProperties.All),
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        DataSysDescription(Res.DataColumnColumnNameDescr)
        ]
        public string ColumnName {
            get {
                return _columnName;
            }
            set {
                if (value == null)
                    value = "";
                CultureInfo locale = (table != null ? table.Locale : CultureInfo.CurrentCulture);
                if (String.Compare(_columnName, value, true, locale) != 0) {
                    if (table != null) {
                        if (value.Length == 0)
                            throw ExceptionBuilder.ColumnNameRequired();

			table.Columns.RegisterName(value, this);
                        if (_columnName.Length != 0)
                            table.Columns.UnregisterName(_columnName);
                    }

                    RaisePropertyChanging("ColumnName");
                    _columnName = value;
                    encodedColumnName = null;
                    if (table != null) {
                        table.Columns.OnColumnPropertyChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, this));
                    }
                }
                else if (String.Compare(_columnName, value, false, locale) != 0) {
                    RaisePropertyChanging("ColumnName");
                    _columnName = value;
                    encodedColumnName = null;
                    if (table != null) {
                        table.Columns.OnColumnPropertyChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, this));
                    }
                }
            }
        }

        internal string EncodedColumnName {
            get {
                if ( this.encodedColumnName == null ) {
                    this.encodedColumnName = XmlConvert.EncodeLocalName( this.ColumnName );
                }
                Debug.Assert( this.encodedColumnName != null && this.encodedColumnName != String.Empty );
                return this.encodedColumnName;
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.Prefix"]/*' />
        [
        DataCategory(Res.DataCategory_Data), 
        DefaultValue(""), 
        DataSysDescription(Res.DataColumnPrefixDescr)
        ]
        public string Prefix {
            get { return _columnPrefix;}
            set {
                if (value == null)
                    value = "";

		        if ((XmlConvert.DecodeName(value) == value) &&
                    (XmlConvert.EncodeName(value) != value))
                    throw ExceptionBuilder.InvalidPrefix(value);

                _columnPrefix = value;
                
            }
        }

        // Return the field value as a string. If the field value is NULL, then NULL is return.
        // If the column type is string and it's value is empty, then the empty string is returned.
        // If the column type is not string, or the column type is string and the value is not empty string, then a non-empty string is returned
        // This method does not throw any formatting exceptions, since we can always format the field value to a string.
        internal string GetColumnValueAsString( DataRow row, DataRowVersion version ) {
            object objValue = row[this, version];

            if (objValue == null || (objValue == DBNull.Value)) {
                return null;
            }

            string value = ConvertObjectToXml(objValue);
            Debug.Assert(value != null);

            return value;
        }

        /// <devdoc>
        /// Whether this column computes values.
        /// </devdoc>
        internal bool Computed {
            get {
                return(this.expression == null ? false : true);
            }
        }

        /// <devdoc>
        /// The internal expression object that computes the values.
        /// </devdoc>
        internal DataExpression DataExpression {
            get {
                return this.expression;
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.DataType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The type
        ///       of data stored in thecolumn.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(typeof(string)),
        RefreshProperties(RefreshProperties.All),
        TypeConverter(typeof(ColumnTypeConverter)),
        DataSysDescription(Res.DataColumnDataTypeDescr)
        ]
        public Type DataType {
            get {
                return dataType;
            }
            set {
                if (dataType != value) {
                    if (HasData) {
                        throw ExceptionBuilder.CantChangeDataType();
                    }
                    if (value == null) {
                        throw ExceptionBuilder.NullDataType();
                    }
                    // TODO: Need a generic mechanism to handle design changes
                    if (table != null && IsInRelation()) {
                        throw ExceptionBuilder.ColumnsTypeMismatch();
                    }

                    // If the DefualtValue is different from the Column DataType, we will coerce the value to the DataType

                    if (DefaultValue != DBNull.Value) {
                        try {
                            if (typeof(string) == value) {
                                defaultValue = Convert.ToString(DefaultValue);
                            }
                            else if (typeof(object) != value) {
                                DefaultValue = Convert.ChangeType(DefaultValue, value);
                            }
                        }
                        catch (InvalidCastException) {
                            throw ExceptionBuilder.DefaultValueDataType(ColumnName, DefaultValue.GetType(), value);
                        }
                        catch (FormatException) {
                            throw ExceptionBuilder.DefaultValueDataType(ColumnName, DefaultValue.GetType(), value);
                        }
                    }
                    
                    if (this.ColumnMapping == MappingType.SimpleContent)
                        if (value == typeof(Char)) 
                            throw ExceptionBuilder.CannotSetSimpleContentType(ColumnName, value);

                    SimpleType = SimpleType.CreateSimpleType(value);
                    
                    if (dataType == typeof(string))
                        maxLength = -1;
                    dataType = value;

                    if (AutoIncrement && !IsAutoIncrementType(value)) {
                        AutoIncrement = false;
                    }
                }
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.DefaultValue"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the default value for the
        ///       column when creating new rows.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataColumnDefaultValueDescr),
        TypeConverter(typeof(DefaultValueTypeConverter))
        ]
        public object DefaultValue {
            get {
                Debug.Assert(defaultValue != null, "It should not have been set to null.");
                return defaultValue;
            }
            set {
                if (defaultValue == null || ! DefaultValue.Equals(value)) {
                    if (AutoIncrement) {
                        throw ExceptionBuilder.DefaultValueAndAutoIncrement();
                    }
                    
                    object newDefaultValue = (value == null) ? DBNull.Value : value;

                    if (newDefaultValue != DBNull.Value && DataType != typeof(Object)) {
                        // If the DefualtValue is different from the Column DataType, we will coerce the value to the DataType
                        try {
                            newDefaultValue = Convert.ChangeType(newDefaultValue, DataType);
                        }
                        catch (InvalidCastException) {
                            throw ExceptionBuilder.DefaultValueColumnDataType(ColumnName, DefaultValue.GetType(), DataType);
                        }
                    }
                    defaultValue = newDefaultValue;
                }
            }
        }

        internal void BindExpression() {
            this.DataExpression.Bind(this.table);
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.Expression"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets the expresssion used to either filter rows, calculate the column's
        ///       value, or create an aggregate column.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        RefreshProperties(RefreshProperties.All),
        DefaultValue(""),
        DataSysDescription(Res.DataColumnExpressionDescr)
        ]
        public string Expression {
            get {
                return(this.expression == null ? "" : this.expression.Expression);
            }
            set {
                DataExpression newExpression = null;
                if (value == null) {
                    value = "";
                }
                if (value.Length > 0) {
                    DataExpression testExpression = new DataExpression(value, this.table, this.dataType);
                    newExpression = (testExpression.expr == null ? null : testExpression);
                }

                if (expression == null && newExpression != null) {
                    if (AutoIncrement || Unique) {
                        throw ExceptionBuilder.ExpressionAndUnique();
                    }

                    // We need to make sure the column is not involved in any Constriants
                    if (table != null) {
                        for (int i = 0; i < table.Constraints.Count; i++) {
                            if (table.Constraints[i].ContainsColumn(this)) {
                                throw ExceptionBuilder.ExpressionAndConstraint(this, table.Constraints[i]);
                            }
                        }
                    }

                    bool oldReadOnly = ReadOnly;
                    try {
                        ReadOnly = true;
                    }
                    catch (Exception) {
                        ReadOnly = oldReadOnly;
                        throw ExceptionBuilder.ExpressionAndReadOnly();
                    }
                }

                // re-calculate the evaluation queue
                if (this.table != null) {
                    // UNDONE : perf
                    table.Columns.columnQueue = new ColumnQueue(table, table.Columns.columnQueue);

                    // if the column attached to a table we need to re-calc values..
                    if (newExpression != null) {
                        if (newExpression.DependsOn(this)) {
                            throw ExceptionBuilder.ExpressionCircular();
                        }
                        
                        // UNDONE : if this is a "new" computed column we can just add it to the ColumnQueue
                        // wee need to set the expression first, so we can add the column to our computed columns queue
                        DataExpression oldExpression = this.expression;
                        this.expression = newExpression;

                        try {
                            table.Columns.RefreshComputedColumns(this);
                        }
                        catch (Exception e) {
                            ExceptionBuilder.Trace(e);

                            // in the case of error we need to set the column expression to the old value
                            this.expression = oldExpression;
                            table.Columns.RefreshComputedColumns(this);
                            throw e;
                        }

                    }
                    else {
                        // we setting the Expression to "",
                        // fill column with default value.
                        for (int i = 0; i < table.RecordCapacity; i++) {
                            this[i] = DefaultValue;
                        }
                    }
                }
                this.expression = newExpression;
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.ExtendedProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of custom user information.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data), 
        Browsable(false),
        DataSysDescription(Res.ExtendedPropertiesDescr)
        ]
        public PropertyCollection ExtendedProperties {
            get {
                if (extendedProperties == null) {
                    extendedProperties = new PropertyCollection();
                }
                return extendedProperties;
            }
        }

        /// <devdoc>
        /// Indicates whether this column is now storing data.
        /// </devdoc>
        internal bool HasData {
            get {
                // TODO: more stuff.
                return(storage != null);
            }
        }
        
        private void SetMaxLengthSimpleType() {
           if (this.simpleType != null) {
              Debug.Assert (this.simpleType.BaseType == "string", "expected simpleType to be string");
              this.simpleType.MaxLength = maxLength;
              // check if we reset the simpleType back to plain string
              if (this.simpleType.IsPlainString())
                 this.simpleType = null;
           } else {
              if (maxLength > -1)
                 this.SimpleType = SimpleType.CreateLimitedStringType(maxLength);
            }
        }
        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.MaxLength"]/*' />
        [
        DataCategory(Res.DataCategory_Data), 
        DataSysDescription(Res.DataColumnMaxLengthDescr),
        DefaultValue(-1)
        ]
        public int MaxLength
        {
            get 
            {
                return maxLength;
            }
            set 
            { 
                if (value >= 0) {
                    if (this.ColumnMapping == MappingType.SimpleContent)
                       throw ExceptionBuilder.CannotSetMaxLength2(this);
                    if (DataType != typeof(string))
                       throw ExceptionBuilder.HasToBeStringType(this);

                    if (table == null || !table.EnforceConstraints) {
                        maxLength = value;
                        SetMaxLengthSimpleType();
                        return;
                    }

                    int oldValue = maxLength;
                    if (value < maxLength || maxLength < 0) {
                        maxLength = value;
                        if (!CheckMaxLength()) {
                            maxLength = oldValue;
                            throw ExceptionBuilder.CannotSetMaxLength(this, value.ToString());
                        }
                    }

                    if( oldValue != maxLength) {
                        SetMaxLengthSimpleType();
                    }  
                }
                else {
                    maxLength = value;
                    SetMaxLengthSimpleType();
                }
              }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.Namespace"]/*' />
        [
        DataCategory(Res.DataCategory_Data), 
        DataSysDescription(Res.DataColumnNamespaceDescr)
        ]
        public string Namespace
        {
            get 
            {


                if (_columnUri == null ) {
                    if (Table != null && columnMapping != MappingType.Attribute) {
                        return Table.Namespace;
                    }
                    return "";
                }
                return _columnUri;
            }
            set 
            {
                if (_columnUri != value) {
                    if (columnMapping != MappingType.SimpleContent) {
                        RaisePropertyChanging("Namespace");
                        _columnUri = value;
                    }
                    else if (value != this.Namespace) {
                        throw ExceptionBuilder.CannotChangeNamespace(this.ColumnName);
                    }
                }
            }
        }

        private bool ShouldSerializeNamespace() {
            return (this._columnUri != null);
        }
        
        private void ResetNamespace() {
            this.Namespace = null;
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.Ordinal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the position of the column in the <see cref='System.Data.DataColumnCollection'/>
        ///       collection.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataColumnOrdinalDescr)
        ]
        public int Ordinal {
            get {
                return ordinal;
            }
        }

        internal void SetOrdinal(int ordinal) {
            // UNDONE - moving columns around will break the indexes.
            if (this.ordinal != ordinal) {
                if (Unique && this.ordinal != -1 && ordinal == -1) {
                    UniqueConstraint key =  table.Constraints.FindKeyConstraint(this);
                    if (key != null)
                        table.Constraints.Remove(key);
                }
                int originalOrdinal = this.ordinal;
                this.ordinal = ordinal;
                if (originalOrdinal == -1 && this.ordinal != -1) {
                    if (Unique) {
                        UniqueConstraint key = new UniqueConstraint(this);
                        table.Constraints.Add(key);
                    }
                    if (Computed) {
                        Table.Columns.CalculateExpressions(this);
                    }
                }
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the column allows changes once a row has been added to the table.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(false),
        DataSysDescription(Res.DataColumnReadOnlyDescr)
        ]
        public bool ReadOnly {
            get {
                return readOnly;
            }
            set {
                if (readOnly != value) {
                    if (!value && expression != null) {
                        throw ExceptionBuilder.ReadOnlyAndExpression();
                    }
                    this.readOnly = value;
                }
            }
        }

        // TODO: Remove this.
        private Index SortIndex {
            get {
                if (sortIndex == null) {
                    sortIndex = table.GetIndex(new int[] { this.Ordinal}, DataViewRowState.CurrentRows, (IFilter) null);
                    sortIndex.AddRef();
                }
                return sortIndex;
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.Table"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Data.DataTable'/> to which the column belongs to.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        Browsable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DataSysDescription(Res.DataColumnDataTableDescr)
        ]
        public DataTable Table {
            get {
                return table;
            }
        }

        /// <devdoc>
        /// Internal mechanism for changing the table pointer.
        /// </devdoc>
        internal void SetTable(DataTable table) {
            if (this.table != table) {
                if (this.Computed)
                    if ((table == null) ||
                        (!table.fInitInProgress && ((table.DataSet == null) || (!table.DataSet.fIsSchemaLoading && !table.DataSet.fInitInProgress)))) {
                    // We need to re-bind all expression columns.
                    this.DataExpression.Bind(table);
                }

                if (Unique && this.table != null) {
                    UniqueConstraint constraint = table.Constraints.FindKeyConstraint(this);
                    if (constraint != null)
                        table.Constraints.CanRemove(constraint, true);
                }
                this.table = table;
                storage = null; // empty out storage for reuse.
            }
        }

        /// <devdoc>
        /// This is how data is pushed in and out of the column.
        /// </devdoc>
        internal virtual object this[int record] {
            get {
                object value = storage.Get(record);
                return (value == null) ? DBNull.Value : value;
            }

            set {
                try {
                    Storage.Set(record, (value == null) ? DBNull.Value : value);
                }
                catch (Exception e) {
                    ExceptionBuilder.Trace(e);
                    throw ExceptionBuilder.SetFailed(value, this, DataType, e.ToString());
                }
                if (value != null && value != DBNull.Value && autoIncrement) {
                    Int64 val64 = Convert.ToInt64(value);
                    if (autoIncrementStep > 0) {
                        if (val64 >= autoIncrementCurrent)
                            autoIncrementCurrent = val64 + autoIncrementStep;
                    }
                    else {
                        if (val64 <= autoIncrementCurrent)
                            autoIncrementCurrent = val64 + autoIncrementStep;
                    }
                }
            }
        }

        /// <devdoc>
        /// This is how data is pushed in and out of the column.
        /// </devdoc>
        internal virtual object this[int record, bool fConvertNull] {
            get {
                object value = storage.Get(record);
                return (fConvertNull && value == null) ? DBNull.Value : value;
            }

            set {
                try {
                    Storage.Set(record, (fConvertNull && value == null) ? DBNull.Value : value);
                }
                catch (Exception e) {
                    ExceptionBuilder.Trace(e);
                    throw ExceptionBuilder.SetFailed(value, this, DataType, e.ToString());
                }
                if (value != null && value != DBNull.Value && autoIncrement) {
                    Int64 val64 = Convert.ToInt64(value);
                    if (autoIncrementStep > 0) {
                        if (val64 >= autoIncrementCurrent)
                            autoIncrementCurrent = val64 + autoIncrementStep;
                    }
                    else {
                        if (val64 <= autoIncrementCurrent)
                            autoIncrementCurrent = val64 + autoIncrementStep;
                    }
                }

            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.Unique"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the values in each row of the column must be unique.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(false),
        DataSysDescription(Res.DataColumnUniqueDescr),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool Unique {
            get {
                return unique;
            }
            set {
                if (unique != value) {
                    if (value && expression != null) {
                        throw ExceptionBuilder.UniqueAndExpression();
                    }
                    UniqueConstraint oldConstraint = null;
                    if (table != null) {
                        if (value)
                            CheckUnique();
                        else {
                            for (System.Collections.IEnumerator e = Table.Constraints.GetEnumerator(); e.MoveNext();) {
                                Object o;
                                if ((( o = e.Current) is UniqueConstraint) && (((UniqueConstraint)o).Columns.Length == 1) && (((UniqueConstraint)o).Columns[0] == this))
                                    oldConstraint = (UniqueConstraint) o;
                            }
                            Debug.Assert(oldConstraint != null, "Should have found a column to remove from the collection.");
                            // TODO: hide CanRemove() from DataColumns
                            table.Constraints.CanRemove(oldConstraint, true);
                        }
                    }

                    this.unique = value;

                    if (table != null) {
                        if (value) {
                            // This should not fail due to a duplicate constraint. unique would have
                            // already been true if there was an existed UniqueConstraint for this column

                            UniqueConstraint constraint = new UniqueConstraint(this);
                            Debug.Assert(table.Constraints.FindKeyConstraint(this) == null, "Should not be a duplication constraint in collection");
                            table.Constraints.Add(constraint);
                        }
                        else
                            table.Constraints.Remove(oldConstraint);
                    }

                }
            }
        }

        internal bool InternalUnique {
            get {
                return this.unique;
            }
            set {
                this.unique = value;
            }
        }

        internal virtual string XmlDataType {
            get {
                return dttype;
            }
            set {
                dttype = value;
            }
        }

        internal virtual SimpleType SimpleType {
            get {
                return simpleType;
            }
            set {
                Debug.Assert((maxLength == -1) || (value !=null), "assigning a null simpletype");
                simpleType = value;
                if (maxLength != -1) {
                    Debug.Assert(value!=null && value.BaseType == "string");
                }
                if (value!=null && value.BaseType == "string")
                    maxLength = simpleType.MaxLength;

            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.ColumnMapping"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Data.MappingType'/> of the column.</para>
        /// </devdoc>
        [
        DefaultValue(MappingType.Element),
        DataSysDescription(Res.DataColumnMappingDescr)
        ]
        public virtual MappingType ColumnMapping {
            get {
                return columnMapping;
            }
            set {
                if(value != columnMapping) {
                    if (value == MappingType.SimpleContent && table != null) {
                        int threshold = 0;
                        if (columnMapping == MappingType.Element)
                            threshold = 1;
                        if (this.dataType == typeof(Char)) 
                            throw ExceptionBuilder.CannotSetSimpleContent(ColumnName, this.dataType);

                        if (table.XmlText != null && table.XmlText != this) 
                            throw ExceptionBuilder.CannotAddColumn3();
                        if (table.ElementColumnCount > threshold)
                            throw ExceptionBuilder.CannotAddColumn4(this.ColumnName);
                    }

                    RaisePropertyChanging("ColumnMapping");
                        
                    if (table!=null) {
                        if (columnMapping == MappingType.SimpleContent)
                            table.xmlText = null;

                        if (value == MappingType.Element)            
                            table.ElementColumnCount ++;
                        else if(columnMapping == MappingType.Element)            
                            table.ElementColumnCount --;
                    } 

                    columnMapping = value;
                    if (value == MappingType.SimpleContent){
                        _columnUri = null;
                        if ( table != null) {
                            table.XmlText = this;
                        }
                        this.SimpleType = null;
                    }
                }
            }
        }

        internal string Description {
            get {
                return description;
            }
            set {
                if (value == null)
                    value = "";
                description = value;
            }
        }

        internal event PropertyChangedEventHandler PropertyChanging {
            add {
                onPropertyChangingDelegate += value;
            }
            remove {
                onPropertyChangingDelegate -= value;
            }
        }

        internal void CheckColumnConstraint(DataRow row, DataRowAction action) {
            if (table.UpdatingCurrent(row, action)) {
                CheckNullable(row);
                CheckMaxLength(row);
            }
        }

        internal bool CheckMaxLength() {
            if (Table == null || Table.Rows.Count == 0)
                return true;
                
            if (maxLength >= 0) {
                Debug.Assert(DataType == typeof(string), "Non-string datatypes should always have maxLength equal to -1.");  

                int count = Table.Rows.Count;
                for (int i = 0; i < Table.Rows.Count; i++) {
                    DataRow row = Table.Rows[i];
                    object value;
                    if (row.HasVersion(DataRowVersion.Current)) {
                        value = this[row.GetRecordFromVersion(DataRowVersion.Current), false];
                        if (value != null && value != DBNull.Value) {
                            if (((string)value).Length > maxLength)
                                return false;
                        }
                    }
                }
            }
            return true;
        }

        internal void CheckMaxLength(DataRow row) {
            if (maxLength >= 0) {
                Debug.Assert(DataType == typeof(string), "Non-string datatypes should always have maxLength equal to -1.");    
                object value = this[row.GetRecordFromVersion(DataRowVersion.Default), false];
                if (value != null && value != DBNull.Value) {
                    if (((string)value).Length > maxLength)
                        throw ExceptionBuilder.LongerThanMaxLength(this, value.ToString());
                }
            }
        }

       /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.CheckNotAllowNull"]/*' />
       /// <internalonly/>
       internal protected void CheckNotAllowNull() {
            if (sortIndex != null) {
                if (sortIndex.IsKeyInIndex(DBNull.Value)) {
                    throw ExceptionBuilder.NullKeyValues(ColumnName);
                }
            }
            else {
                foreach (DataRow dr in this.table.Rows) {
                    if (dr[this] == DBNull.Value) {
                        throw ExceptionBuilder.NullKeyValues(ColumnName);
                    }
                }
            }
        }

        internal void CheckNullable(DataRow row) {
            if (!AllowDBNull) {
               object value = this[row.GetRecordFromVersion(DataRowVersion.Default), false];
               if (value == DBNull.Value)
                    throw ExceptionBuilder.NullValues(ColumnName);
            }
        }

        internal void CheckReadOnly(DataRow row) {
            if (ReadOnly) {
                throw ExceptionBuilder.ReadOnly(ColumnName);
            }
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.CheckUnique"]/*' />
        /// <internalonly/>
        protected void CheckUnique() {
            if (!SortIndex.CheckUnique()) {
                // Throws an exception and the name of any column if its Unique property set to
                // True and non-unique values are found in the column.
                throw ExceptionBuilder.NonUniqueValues(ColumnName);
            }
        }

        // TODO: make protected
        internal virtual int Compare(int record1, int record2) {
            return storage.Compare(record1, record2);
        }

        internal virtual int CompareToValue(int record1, object value) {
            return storage.CompareToValue(record1, value);
        }

        internal virtual void Copy(int srcRecordNo, int dstRecordNo) {
            storage.Copy(srcRecordNo, dstRecordNo);
        }

        internal DataColumn Clone() {
            DataColumn clone = (DataColumn) Activator.CreateInstance(this.GetType());
            // set All properties
            clone.columnMapping = columnMapping;
            clone.allowNull = allowNull;
            clone.autoIncrement = autoIncrement;
            clone.autoIncrementStep = autoIncrementStep;
            clone.autoIncrementSeed = autoIncrementSeed;
            clone.autoIncrementCurrent = autoIncrementCurrent;
            clone.caption = caption;
            clone.ColumnName = ColumnName;
            clone._columnUri = _columnUri;
            clone._columnPrefix = _columnPrefix;
            clone.DataType = DataType;
            clone.defaultValue = defaultValue;
            // UNDONE expression
            clone.readOnly = readOnly;
            clone.MaxLength = MaxLength;
            clone.dttype = dttype;

            // ...Extended Properties
            if (this.extendedProperties != null) {
                foreach(Object key in this.extendedProperties.Keys) {
                    clone.ExtendedProperties[key]=this.extendedProperties[key];
                }
            }

            return clone;
        }

        /// <devdoc>
        ///    <para>Finds a relation that this column is the sole child of or null.</para>
        /// </devdoc>
        internal DataRelation FindParentRelation() {
            DataRelation[] parentRelations = new DataRelation[Table.ParentRelations.Count];
            Table.ParentRelations.CopyTo(parentRelations, 0);
            
            for (int i = 0; i < parentRelations.Length; i++) {
                DataRelation relation = parentRelations[i];
                DataKey key = relation.ChildKey;
                if (key.Columns.Length == 1 && key.Columns[0] == this) {
                    return relation;
                }
            }
            // should we throw an exception?
            return null;
        }

        /*TODO: make protected*/internal virtual object GetAggregateValue(int[] records, AggregateType kind) {
            if (storage == null)
                return DBNull.Value;
            return storage.Aggregate(records, kind);
        }

        internal virtual void Init(int record, bool fConvertNull) {
            if (AutoIncrement) {
                object value = autoIncrementCurrent;
                autoIncrementCurrent += autoIncrementStep;
                    Storage.Set(record, value);
                }
            else
                this[record, fConvertNull] = defaultValue;
        }

        internal virtual void Init(int record) {
            Init(record, false);
        }

        private bool IsAutoIncrementType(Type dataType) {
            return((dataType == typeof(Int32)) || (dataType == typeof(Int64)) || (dataType == typeof(Int16)) || (dataType == typeof(Decimal)));
        }

        internal bool IsNull(int record) {
            return storage.IsNull(record);
        }

        /// <devdoc>
        ///      Returns true if this column is a part of a Parent or Child key for a relation.
        ///      TODO: this should go away
        /// </devdoc>
        internal bool IsInRelation() {
            DataKey key;
            DataRelationCollection rels = table.ParentRelations;

            Debug.Assert(rels != null, "Invalid ParentRelations");
            for (int i = 0; i < rels.Count; i++) {
                key = rels[i].ChildKey;
                Debug.Assert(key != null, "Invalid child key (null)");
                for (int j = 0; j < key.Columns.Length; j++) {
                    if (key.Columns[j] == this) {
                        return true;
                    }
                }
            }
            rels = table.ChildRelations;
            Debug.Assert(rels != null, "Invalid ChildRelations");
            for (int i = 0; i < rels.Count; i++) {
                key = rels[i].ParentKey;
                Debug.Assert(key != null, "Invalid parent key (null)");
                for (int j = 0; j < key.Columns.Length; j++) {
                    if (key.Columns[j] == this) {
                        return true;
                    }
                }
            }
            return false;
        }

        internal bool IsMaxLengthViolated() {
        	if (MaxLength < 0)
        		return true;

        	bool error = false;
        	int count = Table.Rows.Count;
        	object value;
        	for (int i = 0; i < count; i++) {
        	    if (Table.Rows[i].HasVersion(DataRowVersion.Current)) {
            		value = Table.Rows[i][this];
            		if (value != null && value != DBNull.Value && ((string)value).Length > MaxLength) {
        				Table.Rows[i].RowError = ExceptionBuilder.MaxLengthViolationText(this.ColumnName);
        				error = true;
            		}
        		}
        	}
        	return error;
        }
        
        internal bool IsNotAllowDBNullViolated() {
            Index index = this.SortIndex;
            DataRow[] rows = index.GetRows(index.FindRecords(DBNull.Value));
            for (int i = 0; i < rows.Length; i++) {
            	rows[i].RowError = ExceptionBuilder.NotAllowDBNullViolationText(this.ColumnName);
            }
            return (rows.Length > 0);
        }

        internal void FinishInitInProgress () {
            if (this.Computed)
                BindExpression();
        }
        
        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.OnPropertyChanging"]/*' />
        /// <internalonly/>
        protected internal virtual void OnPropertyChanging(PropertyChangedEventArgs pcevent) {
            if (onPropertyChangingDelegate != null)
                onPropertyChangingDelegate(this, pcevent);
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.RaisePropertyChanging"]/*' />
        /// <internalonly/>
        protected internal void RaisePropertyChanging(string name) {
            OnPropertyChanging(new PropertyChangedEventArgs(name));
        }

        internal virtual void  SetCapacity(int capacity) {
            if (storage == null) {
                storage = DataStorage.CreateStorage(dataType);
                storage.Table = this.Table;
            }

            storage.SetCapacity(capacity);
        }

        private bool ShouldSerializeDefaultValue() {
            return (DefaultValue != DBNull.Value);
        }


        // bind the the storage to the column and the column's table to the storage
        internal DataStorage Storage {
            get {
                return this.storage;
            }
            set {
                if (this.storage != null)
                    throw ExceptionBuilder.StorageChange();

                Debug.Assert(this.Table != null, "storage already is associated with a table!");

                if (value != null) {
                    if (value.Table != null)
                        throw ExceptionBuilder.SetForeignStorage();

                    value.Table = this.Table;
                }

                this.storage = value;
            }
        }

        internal void OnSetDataSet() {
        }

        /// <include file='doc\DataColumn.uex' path='docs/doc[@for="DataColumn.ToString"]/*' />
        // Returns the <see cref='System.Data.DataColumn.Expression'/> of the column, if one exists.
        public override string ToString() {
            if (this.expression == null)
                return this.ColumnName;
            else
                return this.ColumnName + " + " + this.Expression;

        }


        internal object ConvertXmlToObject(string s) {
            if (storage == null) {
                storage = DataStorage.CreateStorage(dataType);
                storage.Table = this.Table;
            }
            Debug.Assert(s != null, "Caller is resposible for missing element/attribure case");
            return storage.ConvertXmlToObject(s);
        }

        internal string ConvertObjectToXml(object value) {
            if (storage == null) {
                storage = DataStorage.CreateStorage(dataType);
                storage.Table = this.Table;
            }
            Debug.Assert(value != null && (value != DBNull.Value), "Caller is resposible for checking on DBNull");
            return storage.ConvertObjectToXml(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datacolumnchangeeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataColumnChangeEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\DataColumnChangeEventHandler.uex' path='docs/doc[@for="DataColumnChangeEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the the <see cref='System.Data.DataTable.ColumnChanging'/> event.</para>
    /// </devdoc>
    public delegate void DataColumnChangeEventHandler(object sender, DataColumnChangeEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datacategoryattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataCategoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    using System;
    using System.ComponentModel;   
    using System.Diagnostics;

    /// <include file='doc\DataCategoryAttribute.uex' path='docs/doc[@for="DataCategoryAttribute"]/*' />
    [AttributeUsage(AttributeTargets.All)]
    internal sealed class DataCategoryAttribute : CategoryAttribute {

        /// <include file='doc\DataCategoryAttribute.uex' path='docs/doc[@for="DataCategoryAttribute.DataCategoryAttribute"]/*' />
        public DataCategoryAttribute(string category) : base(category) {
        }

        /// <include file='doc\DataCategoryAttribute.uex' path='docs/doc[@for="DataCategoryAttribute.GetLocalizedString"]/*' />
        protected override string GetLocalizedString(string value) {
            string localizedValue = Res.GetString(value);
            Debug.Assert(localizedValue != null, "All data category attributes should have localized strings.  Category '" + value + "' not found.");
            return localizedValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datacolumnpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataColumnPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System.Diagnostics;
    using System.ComponentModel;

    /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class DataColumnPropertyDescriptor : PropertyDescriptor {

        DataColumn column;

        internal DataColumnPropertyDescriptor(DataColumn dataColumn) : base(dataColumn.ColumnName, null) {
            this.column = dataColumn;    
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.Column"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataColumn Column {
            get {
                return column;
            }
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type ComponentType {
            get {
                return typeof(DataRowView);
            }
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return column.ReadOnly;
            }
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type PropertyType {
            get {
                return column.DataType;
            }
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object other) {
            if (other is DataColumnPropertyDescriptor) {
                DataColumnPropertyDescriptor descriptor = (DataColumnPropertyDescriptor) other;
                return(descriptor.Column == Column);
            }
            return false;
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Int32 GetHashCode() {
            return Column.GetHashCode();
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool CanResetValue(object component) {
            DataRowView dataRowView = (DataRowView) component;
            return (dataRowView.GetColumnValue(column) != DBNull.Value);
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object GetValue(object component) {
            DataRowView dataRowView = (DataRowView) component;
            return dataRowView.GetColumnValue(column);
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void ResetValue(object component) {
            DataRowView dataRowView = (DataRowView) component;
            dataRowView.SetColumnValue(column, DBNull.Value);
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SetValue(object component, object value) {
            DataRowView dataRowView = (DataRowView) component;
            dataRowView.SetColumnValue(column, value);
            OnValueChanged(component, EventArgs.Empty);
        }

        /// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool ShouldSerializeValue(object component) {
            return false;
        }

		/// <include file='doc\DataRowViewColumnDescriptor.uex' path='docs/doc[@for="DataRowViewColumnDescriptor.IsBrowsable"]/*' />
		/// <devdoc>
		///    <para>[To be supplied.]</para>
		/// </devdoc>
		public override bool IsBrowsable {
			get {
				return (column.ColumnMapping == System.Data.MappingType.Hidden ? false : base.IsBrowsable);
			}
		}
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datacolumncollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataColumnCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Xml;
    using System.Collections;
    using System.ComponentModel;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Drawing.Design;

    /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection"]/*' />
    /// <devdoc>
    /// <para>Represents a collection of <see cref='System.Data.DataColumn'/>
    /// objects for a <see cref='System.Data.DataTable'/>.</para>
    /// </devdoc>
    [
    DefaultEvent("CollectionChanged"),
    Editor("Microsoft.VSDesigner.Data.Design.ColumnsCollectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    Serializable
    ]
    public class DataColumnCollection : InternalDataCollectionBase {

        private DataTable table      = null;
        private ArrayList list = new ArrayList();
        private int defaultNameIndex = 1;
        private DataColumn[] delayedAddRangeColumns = null;
        
        // the order in which we need to calculate computed columns
        internal ColumnQueue columnQueue = null;
        private Hashtable columnFromName = null;
        private CaseInsensitiveHashCodeProvider hashCodeProvider = null;
        private CollectionChangeEventHandler onCollectionChangedDelegate;
        private CollectionChangeEventHandler onCollectionChangingDelegate;

        private CollectionChangeEventHandler onColumnPropertyChangedDelegate;

        private bool fInClear;

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.DataColumnCollection"]/*' />
        /// <devdoc>
        /// DataColumnCollection constructor.  Used only by DataTable.
        /// </devdoc>
        internal DataColumnCollection(DataTable table) {
            this.table = table;
            columnFromName = new Hashtable();
            hashCodeProvider = new CaseInsensitiveHashCodeProvider(table.Locale);
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.List"]/*' />
        /// <devdoc>
        ///    <para>Gets the list of the collection items.</para>
        /// </devdoc>
        protected override ArrayList List {
            get {
                return list;
            }
        }

        internal ColumnQueue ColumnQueue {
            get {
                return columnQueue;
            }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Data.DataColumn'/>
        ///       from the collection at the specified index.
        ///    </para>
        /// </devdoc>
        public virtual DataColumn this[int index] {
            get {
                // PROFILE: leave the lists as variable access because they generate lots of calls
                // in profiler.
                if (index >= 0 && index < list.Count) {
                    return(DataColumn) list[index];
                }
                throw ExceptionBuilder.ColumnOutOfRange(index);
                }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.this1"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Data.DataColumn'/> from the collection with the specified name.</para>
        /// </devdoc>
        public virtual DataColumn this[string name] {
            get {
                DataColumn column = (DataColumn) columnFromName[name];
                if (column != null)
                    return column;

                // Case-Insensitive compares
                int index = IndexOfCaseInsensitive(name);
                if (index == -2) {
                    throw ExceptionBuilder.CaseInsensitiveNameConflict(name);
                }                 
                return (index < 0) ? null : (DataColumn)List[index];
            }
        }

        internal virtual DataColumn this[string name, string ns] 
        {
            get 
            {
                DataColumn column = (DataColumn) columnFromName[name];
                if (column != null && column.Namespace == ns)
                    return column;

                return null;
            }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.Add"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.Data.DataColumn'/>
        /// to the columns collection.</para>
        /// </devdoc>
        public void Add(DataColumn column) {
			AddAt(-1, column);
        }
        
        internal void AddAt(int index, DataColumn column) {
            if (column != null && column.ColumnMapping == MappingType.SimpleContent) {
                if (table.XmlText != null && table.XmlText != column)
                    throw ExceptionBuilder.CannotAddColumn3();
                if (table.ElementColumnCount > 0)
                    throw ExceptionBuilder.CannotAddColumn4(column.ColumnName);
                OnCollectionChanging(new CollectionChangeEventArgs(CollectionChangeAction.Add, column));
                BaseAdd(column, null);
                if (index != -1)
					ArrayAdd(index, column);
				else
					ArrayAdd(column);

                table.XmlText = column;
            }
            else {    
                OnCollectionChanging(new CollectionChangeEventArgs(CollectionChangeAction.Add, column));
                BaseAdd(column, null);
                if (index != -1)
					ArrayAdd(index, column);
				else
	                ArrayAdd(column);
                // if the column is an element increase the internal dataTable counter
                if (column.ColumnMapping == MappingType.Element)            
                    table.ElementColumnCount ++;
            }
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, column));
        }
        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(DataColumn[] columns) {
            if (table.fInitInProgress) {
                delayedAddRangeColumns = columns;
                return;
            }
            
            if (columns != null) {
                foreach(DataColumn column in columns) {
                    if (column != null) {
                        Add(column);
                    }
                }
            }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.Add1"]/*' />
        /// <devdoc>
        /// <para>Creates and adds a <see cref='System.Data.DataColumn'/>
        /// with
        /// the specified name, type, and compute expression to the columns collection.</para>
        /// </devdoc>
        public virtual DataColumn Add(string columnName, Type type, string expression) {
            DataColumn column = new DataColumn(columnName, type, expression);
            Add(column);
            return column;
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.Add2"]/*' />
        /// <devdoc>
        /// <para>Creates and adds a <see cref='System.Data.DataColumn'/>
        /// with the
        /// specified name and type to the columns collection.</para>
        /// </devdoc>
        public virtual DataColumn Add(string columnName, Type type) {
            DataColumn column = new DataColumn(columnName, type);
            Add(column);
            return column;
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.Add4"]/*' />
        /// <devdoc>
        /// <para>Creates and adds a <see cref='System.Data.DataColumn'/>
        /// with the specified name to the columns collection.</para>
        /// </devdoc>
        public virtual DataColumn Add(string columnName) {
            DataColumn column = new DataColumn(columnName);
            Add(column);
            return column;
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.Add5"]/*' />
        /// <devdoc>
        /// <para>Creates and adds a <see cref='System.Data.DataColumn'/> to a columns collection.</para>
        /// </devdoc>
        public virtual DataColumn Add() {
            DataColumn column = new DataColumn();
            Add(column);
            return column;
        }


        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.CollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the columns collection changes, either by adding or removing a column.</para>
        /// </devdoc>
        [ResDescription(Res.collectionChangedEventDescr)]
        public event CollectionChangeEventHandler CollectionChanged {
            add {
                onCollectionChangedDelegate += value;
            }
            remove {
                onCollectionChangedDelegate -= value;
            }
        }

        internal event CollectionChangeEventHandler CollectionChanging {
            add {
                onCollectionChangingDelegate += value;
            }
            remove {
                onCollectionChangingDelegate -= value;
            }
        }

        internal event CollectionChangeEventHandler ColumnPropertyChanged {
            add {
                onColumnPropertyChangedDelegate += value;
            }
            remove {
                onColumnPropertyChangedDelegate -= value;
            }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.ArrayAdd"]/*' />
        /// <devdoc>
        ///  Adds the column to the columns array.
        /// </devdoc>
        private void ArrayAdd(DataColumn column) {
            List.Add(column);
            column.SetOrdinal(List.Count - 1);
        }

        private void ArrayAdd(int index, DataColumn column) {
			List.Insert(index, column);
        }

        private void ArrayRemove(DataColumn column) {
            column.SetOrdinal(-1);
            List.Remove(column); 

            int count = List.Count;
            for (int i =0; i < count; i++) {
                ((DataColumn) List[i]).SetOrdinal(i);
            }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.AssignName"]/*' />
        /// <devdoc>
        /// Creates a new default name.
        /// </devdoc>
        internal string AssignName() {
            string newName = MakeName(defaultNameIndex++);

            while (columnFromName[newName] != null)
                newName = MakeName(defaultNameIndex++);

            return newName;
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.BaseAdd"]/*' />
        /// <devdoc>
        /// Does verification on the column and it's name, and points the column at the dataSet that owns this collection.
        /// An ArgumentNullException is thrown if this column is null.  An ArgumentException is thrown if this column
        /// already belongs to this collection, belongs to another collection.
        /// A DuplicateNameException is thrown if this collection already has a column with the same
        /// name (case insensitive).
        /// </devdoc>
        private void BaseAdd(DataColumn column, DataStorage storage) {
            if (column == null)
                throw ExceptionBuilder.ArgumentNull("column");
            if (column.table == table)
                throw ExceptionBuilder.CannotAddColumn1(column.ColumnName);
            if (column.table != null)
                throw ExceptionBuilder.CannotAddColumn2(column.ColumnName);

            // this will bind the expression.
            column.SetTable(table);
            // bind the storage here (SetTable above will set it to null)
            column.Storage = storage;

            if (column.ColumnName.Length == 0)
                column.ColumnName = AssignName();
            else
                RegisterName(column.ColumnName, column);
            column.hashCode = GetSpecialHashCode(column.ColumnName);

            if (table.RecordCapacity > 0) column.SetCapacity(table.RecordCapacity);

            // fill column with default value.
            for (int i = 0; i < table.RecordCapacity; i++) {
                column[i] = column.DefaultValue;
            }

            if (table.DataSet != null) {
                column.OnSetDataSet();
            }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.BaseGroupSwitch"]/*' />
        /// <devdoc>
        /// BaseGroupSwitch will intelligently remove and add tables from the collection.
        /// </devdoc>
        private void BaseGroupSwitch(DataColumn[] oldArray, int oldLength, DataColumn[] newArray, int newLength) {
            // We're doing a smart diff of oldArray and newArray to find out what
            // should be removed.  We'll pass through oldArray and see if it exists
            // in newArray, and if not, do remove work.  newBase is an opt. in case
            // the arrays have similar prefixes.
            int newBase = 0;
            for (int oldCur = 0; oldCur < oldLength; oldCur++) {
                bool found = false;
                for (int newCur = newBase; newCur < newLength; newCur++) {
                    if (oldArray[oldCur] == newArray[newCur]) {
                        if (newBase == newCur) {
                            newBase++;
                        }
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    // This means it's in oldArray and not newArray.  Remove it.
                    if (oldArray[oldCur].Table == table) {
                        BaseRemove(oldArray[oldCur]);
                        List.Remove(oldArray[oldCur]);
                        oldArray[oldCur].SetOrdinal(-1);
                    }
                }
            }

            // Now, let's pass through news and those that don't belong, add them.
            for (int newCur = 0; newCur < newLength; newCur++) {
                if (newArray[newCur].Table != table) {
                    BaseAdd(newArray[newCur], null);
                    List.Add(newArray[newCur]);
                }
                newArray[newCur].SetOrdinal(newCur);
            }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.BaseRemove"]/*' />
        /// <devdoc>
        /// Does verification on the column and it's name, and clears the column's dataSet pointer.
        /// An ArgumentNullException is thrown if this column is null.  An ArgumentException is thrown
        /// if this column doesn't belong to this collection or if this column is part of a relationship.
        /// An ArgumentException is thrown if another column's compute expression depends on this column.
        /// </devdoc>
        private void BaseRemove(DataColumn column) {
            if (CanRemove(column, true)) {
                // remove
                if (column.errors > 0) {
                    for (int i = 0; i < table.Rows.Count; i++) {
                        table.Rows[i].ClearError(column);
                    }
                }
                UnregisterName(column.ColumnName);
                column.SetTable(null);
            }
        }

        internal void CalculateExpressions(DataRow row, DataRowAction action) {
            if (action == DataRowAction.Add ||
                action == DataRowAction.Change) {
                if (ColumnQueue != null) {
                    this.ColumnQueue.Evaluate(row);
                }
            }
        }

        internal void CalculateExpressions(DataColumn column) {
            Debug.Assert(column.Computed, "Only computed columns should be re-evaluated.");
            if (column.table.Rows.Count <=0)
                return;

            if (column.DataExpression.IsTableAggregate()) {
                // this value is a constant across the table.

                object aggCurrent = column.DataExpression.Evaluate();

                for (int j = 0; j < column.table.Rows.Count; j++) {
                    DataRow row = column.table.Rows[j];
                    if (row.oldRecord != -1) {
                        column[row.oldRecord] = aggCurrent;
                    }
                    if (row.newRecord != -1) {
                        column[row.newRecord] = aggCurrent;
                    }
                    if (row.tempRecord != -1) {
                        column[row.tempRecord] = aggCurrent;
                    }
                }
            }
            else {
                for (int j = 0; j < column.table.Rows.Count; j++) {
                    DataRow row = column.table.Rows[j];

                    if (row.oldRecord != -1) {
                        column[row.oldRecord] = column.DataExpression.Evaluate(row, DataRowVersion.Original);
                    }
                    if (row.newRecord != -1) {
                        if (row.oldRecord == row.newRecord) {
                            column[row.newRecord] = column[row.oldRecord];
                        }
                        else {
                            column[row.newRecord] = column.DataExpression.Evaluate(row, DataRowVersion.Current);
                        }
                    }
                    if (row.tempRecord != -1) {
                        column[row.tempRecord] = column.DataExpression.Evaluate(row, DataRowVersion.Proposed);
                    }
                }
            }
        }

        internal void CalculateExpressions(DataColumn[] list, int count, DataColumn start) {
            if (!start.Computed)
                return;

            // first find the given (start) column in the list
            int i;
            for (i = 0; i < count; i++) {
                if (list[i] == start)
                    break;
            }
            Debug.Assert(i < count, "Can not find column [" + start.ColumnName + "] in the columnQueue");
            while (i < count) {
                CalculateExpressions(list[i++]);
            }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.CanRemove"]/*' />
        /// <devdoc>
        ///    <para>Checks
        ///       if
        ///       a given column can be removed from the collection.</para>
        /// </devdoc>
        public bool CanRemove(DataColumn column) {
            return CanRemove(column, false);
        }
        
        internal bool CanRemove(DataColumn column, bool fThrowException) {
            if (column == null) {
                if (!fThrowException)
                    return false;
                else
                throw ExceptionBuilder.ArgumentNull("column");
            }
            if (column.table != table) {
                if (!fThrowException)
                    return false;
                else
                throw ExceptionBuilder.CannotRemoveColumn();
            }

            // allow subclasses to complain first.
            table.OnRemoveColumn(column);

            // We need to make sure the column is not involved in any Relations or Constriants
            if (table.primaryKey != null && table.primaryKey.Key.ContainsColumn(column)) {
                if (!fThrowException)
                    return false;
                else
                throw ExceptionBuilder.CannotRemovePrimaryKey();
            }
            for (int i = 0; i < table.ParentRelations.Count; i++) {
                if (table.ParentRelations[i].ChildKey.ContainsColumn(column)) {
                    if (!fThrowException)
                        return false;
                    else
                    throw ExceptionBuilder.CannotRemoveChildKey(table.ParentRelations[i].RelationName);
                }
            }
            for (int i = 0; i < table.ChildRelations.Count; i++) {
                if (table.ChildRelations[i].ParentKey.ContainsColumn(column)) {
                    if (!fThrowException)
                        return false;
                    else
                    throw ExceptionBuilder.CannotRemoveChildKey(table.ChildRelations[i].RelationName);
                }
            }
            for (int i = 0; i < table.Constraints.Count; i++) {
                if (table.Constraints[i].ContainsColumn(column))
                    if (!fThrowException)
                        return false;
                    else
                    throw ExceptionBuilder.CannotRemoveConstraint(table.Constraints[i].ConstraintName, table.Constraints[i].Table.TableName);
            }
            if (table.DataSet != null) {
                for (ParentForeignKeyConstraintEnumerator en = new ParentForeignKeyConstraintEnumerator(table.DataSet, table); en.GetNext();) {
                    Constraint constraint = en.GetConstraint();
                    if (((ForeignKeyConstraint)constraint).ParentKey.ContainsColumn(column))
                        if (!fThrowException)
                            return false;
                        else
                            throw ExceptionBuilder.CannotRemoveConstraint(constraint.ConstraintName, constraint.Table.TableName);
                }
            }

            for (int i = 0; i < ColumnQueue.columnCount; i++) {
                DataColumn col = ColumnQueue.columns[i];
                if (fInClear && (col.Table == table || col.Table == null))
                    continue;
                Debug.Assert(col.Computed, "invalid (non an expression) column in the expression column queue");
                DataExpression expr = col.DataExpression;
                if (expr.DependsOn(column)) {
                    if (!fThrowException)
                        return false;
                    else
                    throw ExceptionBuilder.CannotRemoveExpression(col.ColumnName, col.Expression);
                }
            }

            return true;
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears the collection of any columns.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            int oldLength = List.Count;
            
            DataColumn[] columns = new DataColumn[List.Count];
            List.CopyTo(columns, 0);

            OnCollectionChanging(RefreshEventArgs);
            
            if (table.fInitInProgress && delayedAddRangeColumns != null) {
                delayedAddRangeColumns = null;
            }

            try {
                // this will smartly add and remove the appropriate tables.
                fInClear = true;
                BaseGroupSwitch(columns, oldLength, null, 0);
                fInClear = false;
            }
            catch (Exception e) {
                // something messed up: restore to old values and throw
                fInClear = false;
                BaseGroupSwitch(null, 0, columns, oldLength);
                List.Clear();
                for (int i = 0; i < oldLength; i++)
                    List.Add(columns[i]);
                throw e;
            }
            List.Clear();
            OnCollectionChanged(RefreshEventArgs);
        }
 
        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>Checks whether the collection contains a column with the specified name.</para>
        /// </devdoc>
        public bool Contains(string name) {
            if (columnFromName[name] != null)
                return true;

            return (IndexOfCaseInsensitive(name) >= 0);
        }

        internal bool Contains(string name, bool caseSensitive) {
            if (columnFromName[name] != null)
                return true;
            
            if (caseSensitive)
                return false;
            else
                return (IndexOfCaseInsensitive(name) >= 0);
        }

        // We need a HashCodeProvider for Case, Kana and Width insensitive
        internal Int32 GetSpecialHashCode(string name) {
            int i = 0;
            for (i = 0; i < name.Length; i++) {
                if (name[i] >= 0x3000)
                    break;
            }

            if (i >= name.Length) 
                return hashCodeProvider.GetHashCode(name);
            else
                return 0;
        }
        
        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the index of a specified <see cref='System.Data.DataColumn'/>.
        ///    </para>
        /// </devdoc>
        public virtual int IndexOf(DataColumn column) {
            int columnCount = List.Count;
            for (int i = 0; i < columnCount; ++i) {
                if (column == (DataColumn) List[i]) {
                    return i;
                }
            }
            return -1;
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.IndexOf1"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of
        ///       a column specified by name.</para>
        /// </devdoc>
        public int IndexOf(string columnName) {

            if ((null != columnName) && (0 < columnName.Length)) {
                int count = Count;
                DataColumn column = (DataColumn) columnFromName[columnName];
                
                if (column != null) {
                    for (int j = 0; j < count; j++) 
                        if (column == list[j]) {
                            return j;
                        }
                }
                else {
                    int res = IndexOfCaseInsensitive(columnName);
                    return (res < 0) ? -1 : res;
                }
            }
            return -1;
        }

        internal int IndexOfCaseInsensitive (string name) {
            int hashcode = GetSpecialHashCode(name);
            int cachedI = -1;
            DataColumn column = null;
            for (int i = 0; i < Count; i++) {
                column = (DataColumn) List[i];
                if ( (hashcode == 0 || column.hashCode == 0 || column.hashCode == hashcode) && 
                   NamesEqual(column.ColumnName, name, false, table.Locale) != 0 ) {
                    if (cachedI == -1)
                        cachedI = i;
                    else
                        return -2;
                }
            }
            return cachedI;
        }

        internal void FinishInitCollection() {
            if (delayedAddRangeColumns != null) {
                foreach(DataColumn column in delayedAddRangeColumns) {
                    if (column != null) {
                        Add(column);
                    }
                }

                foreach(DataColumn column in delayedAddRangeColumns) {
                    if (column != null) {
                        column.FinishInitInProgress();
                    }
                }

                delayedAddRangeColumns = null;
            }
        }
        
        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.MakeName"]/*' />
        /// <devdoc>
        /// Makes a default name with the given index.  e.g. Column1, Column2, ... Columni
        /// </devdoc>
        private string MakeName(int index) {
            return "Column" + index.ToString();
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.OnCollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Data.DataColumnCollection.OnCollectionChanged'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnCollectionChanged(CollectionChangeEventArgs ccevent) {
            table.UpdatePropertyDescriptorCollectionCache();
            if (!table.SchemaLoading && !table.fInitInProgress) {
                columnQueue = new ColumnQueue(table, columnQueue);
            }
            if (onCollectionChangedDelegate != null) {
                onCollectionChangedDelegate(this, ccevent);
            }
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.OnCollectionChanging"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal virtual void OnCollectionChanging(CollectionChangeEventArgs ccevent) {
            if (onCollectionChangingDelegate != null) {
                onCollectionChangingDelegate(this, ccevent);
            }
        }

        internal void OnColumnPropertyChanged(CollectionChangeEventArgs ccevent) {
            table.UpdatePropertyDescriptorCollectionCache();
            if (onColumnPropertyChangedDelegate != null) {
                onColumnPropertyChangedDelegate(this, ccevent);
            }
        }

        internal void RefreshComputedColumns(DataColumn start) {
            columnQueue = new ColumnQueue(table, columnQueue);
            CalculateExpressions(columnQueue.columns, columnQueue.columnCount, start);
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.RegisterName"]/*' />
        /// <devdoc>
        /// Registers this name as being used in the collection.  Will throw an ArgumentException
        /// if the name is already being used.  Called by Add, All property, and Column.ColumnName property.
        /// if the name is equivalent to the next default name to hand out, we increment our defaultNameIndex.
        /// </devdoc>
        internal void RegisterName(string name, Object obj) {
            Debug.Assert (name != null);
            Debug.Assert (obj is DataTable || obj is DataColumn);
            Object _exObject = columnFromName[name];
            DataColumn _column = _exObject as DataColumn;
            
            if (_column != null) {
              if (obj is DataColumn)
                throw ExceptionBuilder.CannotAddDuplicate(name);
              else
                throw ExceptionBuilder.CannotAddDuplicate2(name);
                
            }
            
            if (_exObject != null) {
              throw ExceptionBuilder.CannotAddDuplicate3(name);
            }

            //we need to check wether the tableName is the same of the
            //next generable columnName and update defaultNameIndex accordingly
            if (obj is DataTable && NamesEqual(name, MakeName(defaultNameIndex), true, table.Locale) != 0) {
                do {
                    defaultNameIndex++;
                } while (!Contains(MakeName(defaultNameIndex)));
            }


            columnFromName.Add(name, obj);
        }

        internal bool CanRegisterName(string name) {
            Debug.Assert (name != null);
            if(columnFromName[name] != null)
              return false;
            return true;
        }
        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes the specified <see cref='System.Data.DataColumn'/>
        /// from the collection.</para>
        /// </devdoc>
        public void Remove(DataColumn column) {
            OnCollectionChanging(new CollectionChangeEventArgs(CollectionChangeAction.Remove, column));
            BaseRemove(column);
            ArrayRemove(column);
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, column));
            // if the column is an element decrease the internal dataTable counter
            if (column.ColumnMapping == MappingType.Element)            
                table.ElementColumnCount --;
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>Removes the
        ///       column at the specified index from the collection.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
			DataColumn dc = this[index];
			if (dc == null)
				throw ExceptionBuilder.ColumnOutOfRange(index);
			Remove(dc);
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.Remove1"]/*' />
        /// <devdoc>
        ///    <para>Removes the
        ///       column with the specified name from the collection.</para>
        /// </devdoc>
        public void Remove(string name) {
			DataColumn dc = this[name];
			if (dc == null)
				throw ExceptionBuilder.ColumnNotInTheTable(name, table.TableName);
            Remove(dc);
        }

        /// <include file='doc\DataColumnCollection.uex' path='docs/doc[@for="DataColumnCollection.UnregisterName"]/*' />
        /// <devdoc>
        /// Unregisters this name as no longer being used in the collection.  Called by Remove, All property, and
        /// Column.ColumnName property.  If the name is equivalent to the last proposed default namem, we walk backwards
        /// to find the next proper default name to hang out.
        /// </devdoc>
        internal void UnregisterName(string name) {
            Object obj = columnFromName[name];
            if (obj != null)                 // sinc the HashTable is case-sensitive
                columnFromName.Remove(name); // this is totally equivalent
                                      
                
            if (NamesEqual(name, MakeName(defaultNameIndex - 1), true, table.Locale) != 0) {
                do {
                    defaultNameIndex--;
                } while (defaultNameIndex > 1 &&
                         !Contains(MakeName(defaultNameIndex - 1)));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataerror.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataError.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;

    /// <include file='doc\DataError.uex' path='docs/doc[@for="DataError"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// <para>Represents an custom error that can be associated with a <see cref='System.Data.DataRow'/>.</para>
    /// </devdoc>
   [Serializable]
   internal class DataError {
        private string rowError = String.Empty;

        // column-level errors
        private int count;
        private ColumnError[] errorList;
        internal const int initialCapacity = 1;

        /// <include file='doc\DataError.uex' path='docs/doc[@for="DataError.DataError"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.DataError'/> class.</para>
        /// </devdoc>
        public DataError() {
        }

        /// <include file='doc\DataError.uex' path='docs/doc[@for="DataError.DataError1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.DataError'/> class using the specified error
        ///    text.</para>
        /// </devdoc>
        public DataError(string rowError) {
            SetText(rowError);
        }

        internal virtual string Text {
            get {
                return rowError;
            }
            set {
                SetText(value);
            }
        }

        internal virtual bool HasErrors {
            get {
                return(rowError.Length != 0 || count != 0);
            }
        }

        //
        // this method resets the error to the new value.
        //
        internal void SetColumnError(DataColumn column, string error) {
            Debug.Assert(column != null, "Invalid (null) argument");
            Debug.Assert(column.Table != null, "Invalid (loose) column");
            if (error == null || error.Length == 0) {
                // remove error from the collection
                Clear(column);
            }
            else {
                if (errorList == null) {
                    errorList = new ColumnError[initialCapacity];
                }
                int i = IndexOf(column);
                errorList[i].column = column;
                errorList[i].error = error;
                column.errors++;
                if (i == count)
                    count++;
            }
        }

        internal string GetColumnError(DataColumn column) {
            for (int i = 0; i < count; i++) {
                if (errorList[i].column == column) {
                    return errorList[i].error;
                }
            }
            return String.Empty;
        }

        internal void Clear(DataColumn column) {
            if (count == 0)
                return;

            for (int i = 0; i < count; i++) {
                if (errorList[i].column == column) {
                    System.Array.Copy(errorList, i+1, errorList, i, count-i-1);
                    count--;
                    column.errors--;
                    Debug.Assert(column.errors >= 0, "missing error counts");
                }
            }
        }

        internal void Clear() {
            for (int i = 0; i < count; i++) {
                errorList[i].column.errors--;
                Debug.Assert(errorList[i].column.errors >= 0, "missing error counts");
            }
            count = 0;
            rowError = String.Empty;
        }

        internal DataColumn[] GetColumnsInError() {
            DataColumn[] cols = new DataColumn[count];

            for (int i = 0; i < count; i++) {
                cols[i] = errorList[i].column;
            }
            return cols;
        }

        /// <include file='doc\DataError.uex' path='docs/doc[@for="DataError.SetText"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>Sets the error message for the <see cref='System.Data.DataError'/>.</para>
        /// </devdoc>
        protected void SetText(string errorText) {
            if (null == errorText) {
                errorText = String.Empty;
            }
            rowError = errorText;
        }

        internal int IndexOf (DataColumn column) {
            // try to find the column
            for (int i = 0; i < count; i++) {
                if (errorList[i].column == column) {
                    return i;
                }
            }

            if (count >= errorList.Length) {
                int newCapacity = Math.Min(count*2, column.Table.Columns.Count);
                ColumnError[] biggerList = new ColumnError[newCapacity];
                System.Array.Copy(errorList, 0, biggerList, 0, count);
                errorList = biggerList;
            }
            return count;
        }

        internal struct ColumnError {
            internal DataColumn column;
            internal string error;
        };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datakey.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataKey.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.ComponentModel;

    /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable]
    internal class DataKey {
        internal const Int32 COLUMN     = unchecked((int)0x0000FFFF);
        internal const Int32 DESCENDING = unchecked((int)0x80000000);
        internal static int ColumnOrder(Int32 indexDesc) {
            return indexDesc & COLUMN;
        }
        internal static bool SortDecending(Int32 indexDesc) { 
            return (indexDesc & DESCENDING) != 0;
        }

        internal const int maxColumns = 32;
        internal DataColumn[] columns;
        internal int sortOrder;
        internal bool explicitKey; // this is for constraints explicitly added.

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.DataKey2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataKey(DataColumn[] columns) {
            Create(columns, null);
        }

        internal void CheckState() {
            DataTable table = columns[0].Table;

            if (table == null) {
                throw ExceptionBuilder.ColumnNotInAnyTable();
            }

            for (int i = 1; i < columns.Length; i++) {
                if (columns[i].Table == null) {
                    throw ExceptionBuilder.ColumnNotInAnyTable();
                }
                if (columns[i].Table != table) {
                    throw ExceptionBuilder.KeyTableMismatch();
                }
            }
        }

        private void Create(DataColumn[] columns, int[] sortOrders) {
            this.explicitKey = false;

            if (columns == null)
                throw ExceptionBuilder.ArgumentNull("columns");

            if (columns.Length == 0)
                throw ExceptionBuilder.KeyNoColumns();

            if (columns.Length > maxColumns)
                throw ExceptionBuilder.KeyTooManyColumns(maxColumns);

            for (int i = 0; i < columns.Length; i++) {
                if (columns[i] == null)
                    throw ExceptionBuilder.ArgumentNull("column");
            }

            for (int i = 0; i < columns.Length; i++) {
                for (int j = 0; j < i; j++) {
                    if (columns[i] == columns[j]) {
                        throw ExceptionBuilder.KeyDuplicateColumns(columns[i].ColumnName);
                    }
                }
            }

            if (sortOrders != null && sortOrders.Length != columns.Length)
                throw ExceptionBuilder.KeySortLength();

            sortOrder = 0;

            if (sortOrders != null) {
                for (int i = 0; i < sortOrders.Length; i++) {
                    sortOrder |= (sortOrders[i] & 1) << i;
                }
            }

            // Need to make a copy of all columns
            this.columns = new DataColumn [columns.Length];
            for (int i = 0; i < columns.Length; i++)
                this.columns[i] = columns[i];

            CheckState();
        }

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object key2) {
            if (!(key2 is DataKey))
                return false;

            //check to see if this.columns && key2's columns are equal...
            bool arraysEqual=false;
            DataColumn[] column1=this.Columns;
            DataColumn[] column2=((DataKey)key2).Columns;

            if (column1 == column2) {
                arraysEqual = true;
            } else if (column1 == null || column2 == null) {
                arraysEqual = false;
            } else if (column1.Length != column2.Length) {
                arraysEqual = false;
            } else {
                arraysEqual = true;
                for (int i = 0; i <column1.Length; i++) {
                    if (! column1[i].Equals(column2[i])) {
                        arraysEqual = false;
                        break;
                    }
                }
            }
            return arraysEqual;
        }

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Int32 GetHashCode() {
            Int32 hashCode = 0;
            DataColumn[] column = this.Columns;
            if(column != null) {
                // SDUB: Optimisation: As usial 2 cols is enouph to distinct keys.
                int colsNum = (column.Length <= 2) ? column.Length : 2;
                for (int i = 0; i < colsNum; i++) {
                    hashCode += column[i].GetHashCode();
                }
            }
            return hashCode;
        }

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.Columns"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual DataColumn[] Columns {
            get {
                return columns;
            }
        }

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.SortOrder"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual int[] SortOrder {
            get {
                int localSortOrder = sortOrder;
                int[] sortOrders = new int[columns.Length];
                for (int i = 0; i < columns.Length; i++) {
                    sortOrders[i] = localSortOrder & 1;
                    localSortOrder >>= 1;
                }
                return sortOrders;
            }
        }

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.Table"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual DataTable Table {
            get {
                return columns[0].Table;
            }
        }

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.ColumnsEqual"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool ColumnsEqual(DataKey key) {
            DataColumn[] column1=this.Columns;
            DataColumn[] column2=((DataKey)key).Columns;

            if (column1 == column2) {
                return true;
            } else if (column1 == null || column2 == null) {
                return false;
            } else if (column1.Length != column2.Length) {
                return false;
            } else {
                int i, j;
                for (i=0; i<column1.Length; i++) {
                    for (j=0; j<column2.Length; j++) {
                        if (column1[i].Equals(column2[j]))
                            break;
                    }
                    if (j == column2.Length)
                        return false;
                }
            }
            return true;
        }

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.RecordsEqual"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool RecordsEqual(int record1, int record2) {
            for (int i = 0; i < columns.Length; i++) {
                if (columns[i].Compare(record1, record2) != 0) {
                    return false;
                }
            }
            return true;
        }

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.ContainsColumn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual bool ContainsColumn(DataColumn column) {
            for (int i = 0; i < columns.Length; i++) {
                if (column == columns[i]) {
                    return true;
                }
            }
            return false;
        }

        internal virtual Int32[] GetIndexDesc() {
            Int32[] indexDesc = new Int32[columns.Length];
            int localSortOrders = sortOrder;
            for (int i = 0; i < columns.Length; i++) {
                indexDesc[i] = columns[i].Ordinal | localSortOrders << 31;
                localSortOrders >>= 1;
            }
            return indexDesc;
        }

        internal virtual Index GetSortIndex() {
            return GetSortIndex(DataViewRowState.CurrentRows);
        }

        internal virtual Index GetSortIndex(DataViewRowState recordStates) {
            return columns[0].Table.GetIndex(GetIndexDesc(), recordStates, (IFilter)null);
        }

        /// <include file='doc\DataKey.uex' path='docs/doc[@for="DataKey.GetDebugString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string GetDebugString() {
            int[] sortOrder = SortOrder;
            string result = "{key: ";
            for (int i = 0; i < columns.Length; i++) {
                result += columns[i].ColumnName + (sortOrder[i] == 1 ? " DESC" : "") + (i < columns.Length - 1 ? ", " : String.Empty);
            }
            result += "}";
            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarelation.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRelation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Globalization;

    /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a parent/child relationship between two tables.
    ///    </para>
    /// </devdoc>
    [
    DefaultProperty("RelationName"),
    Editor("Microsoft.VSDesigner.Data.Design.DataRelationEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    TypeConverter(typeof(RelationshipConverter)),
    Serializable
    ]
    public class DataRelation {

        // properties
        private DataSet dataSet    = null;
        internal PropertyCollection extendedProperties = null;
        internal string relationName   = "";

        // events
        private PropertyChangedEventHandler onPropertyChangingDelegate = null;

        // state
        private DataKey childKey  = null;
        private DataKey parentKey = null;
        private UniqueConstraint parentKeyConstraint = null;
        private ForeignKeyConstraint childKeyConstraint = null;

        // Design time serialization
        internal string[] parentColumnNames = null;
        internal string[] childColumnNames = null;
        internal string parentTableName = null;
        internal string childTableName = null;
        
        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.nested"]/*' />
        /// <devdoc>
        /// this stores whether the  child element appears beneath the parent in the XML persised files.
        /// </devdoc>
        internal bool nested = false;

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.createConstraints"]/*' />
        /// <devdoc>
        /// this stores whether the the relationship should make sure that KeyConstraints and ForeignKeyConstraints
        /// exist when added to the ConstraintsCollections of the table.
        /// </devdoc>
        internal bool createConstraints;

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.DataRelation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.DataRelation'/> class using the specified name,
        ///       parent, and child columns.
        ///    </para>
        /// </devdoc>
        public DataRelation(string relationName, DataColumn parentColumn, DataColumn childColumn)
        : this(relationName, parentColumn, childColumn, true) {
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.DataRelation1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.DataRelation'/> class using the specified name, parent, and child columns, and
        ///       value to create constraints.
        ///    </para>
        /// </devdoc>
        public DataRelation(string relationName, DataColumn parentColumn, DataColumn childColumn, bool createConstraints) {
            DataColumn[] parentColumns = new DataColumn[1];
            parentColumns[0] = parentColumn;
            DataColumn[] childColumns = new DataColumn[1];
            childColumns[0] = childColumn;
            Create(relationName, parentColumns, childColumns, createConstraints);
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.DataRelation2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.DataRelation'/> class using the specified name
        ///       and matched arrays of parent and child columns.
        ///    </para>
        /// </devdoc>
        public DataRelation(string relationName, DataColumn[] parentColumns, DataColumn[] childColumns)
        : this(relationName, parentColumns, childColumns, true) {
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.DataRelation3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.DataRelation'/> class using the specified name, matched arrays of parent
        ///       and child columns, and value to create constraints.
        ///    </para>
        /// </devdoc>
        public DataRelation(string relationName, DataColumn[] parentColumns, DataColumn[] childColumns, bool createConstraints) {
            Create(relationName, parentColumns, childColumns, createConstraints);
        }

        // Design time constructor
        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.DataRelation4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public DataRelation(string relationName, string parentTableName, string childTableName, string[] parentColumnNames, string[] childColumnNames, bool nested) {
            this.relationName = relationName;            
            this.parentColumnNames = parentColumnNames;
            this.childColumnNames = childColumnNames;
            this.parentTableName = parentTableName;
            this.childTableName = childTableName;
            this.nested = nested;
        }
        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ChildColumns"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the child columns of this relation.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataRelationChildColumnsDescr)
        ]
        public virtual DataColumn[] ChildColumns {
            get {
                CheckStateForProperty();
                return childKey.Columns;
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ChildKey"]/*' />
        /// <devdoc>
        /// The internal Key object for the child table.
        /// </devdoc>
        internal virtual DataKey ChildKey {
            get {
                CheckStateForProperty();
                return childKey;
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ChildTable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the child table of this relation.
        ///    </para>
        /// </devdoc>
        public virtual DataTable ChildTable {
            get {
                CheckStateForProperty();
                return childKey.Table;
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.DataSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Data.DataSet'/> to which the relations' collection belongs to.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), Browsable(false)]
        public virtual DataSet DataSet {
            get {
                CheckStateForProperty();
                return dataSet;
            }
        }

        internal string[] ParentColumnNames {
            get {
                int count = parentKey.Columns.Length;
                string[] parentNames = new string[count];
                for (int i = 0; i < count; i++)
                    parentNames[i] = parentKey.Columns[i].ColumnName;
                    
                return parentNames;
            }
        }

        internal string[] ChildColumnNames {
            get {
                int count = childKey.Columns.Length;
                string[] childNames = new string[count];
                for (int i = 0; i < count; i++)
                    childNames[i] = childKey.Columns[i].ColumnName;
                    
                return childNames;
            }
        }

        private static bool IsKeyNull(object[] values) {
            for (int i = 0; i < values.Length; i++) {
                if (!(values[i] == null || values[i] is System.DBNull))
                    return false;
            }

            return true;
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.GetChildRows"]/*' />
        /// <devdoc>
        /// Gets the child rows for the parent row across the relation using the version given
        /// </devdoc>
        internal static DataRow[] GetChildRows(DataKey parentKey, DataKey childKey, DataRow parentRow, DataRowVersion version) {
            object[] values = parentRow.GetKeyValues(parentKey, version);
            if (IsKeyNull(values)) {
                return childKey.Table.NewRowArray(0);
            }

            Index index = childKey.GetSortIndex();
            return index.GetRows(values);
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.GetParentRows"]/*' />
        /// <devdoc>
        /// Gets the parent rows for the given child row across the relation using the version given
        /// </devdoc>
        internal static DataRow[] GetParentRows(DataKey parentKey, DataKey childKey, DataRow childRow, DataRowVersion version) {
            object[] values = childRow.GetKeyValues(childKey, version);
            if (IsKeyNull(values)) {
                return parentKey.Table.NewRowArray(0);
            }

            Index index = parentKey.GetSortIndex();
            return index.GetRows(values);
        }

        internal static DataRow GetParentRow(DataKey parentKey, DataKey childKey, DataRow childRow, DataRowVersion version) {
            if (!childRow.HasVersion((version == DataRowVersion.Original) ? DataRowVersion.Original : DataRowVersion.Current))
                if (childRow.tempRecord == -1)
                    return null;

            object[] values = childRow.GetKeyValues(childKey, version);
            if (IsKeyNull(values)) {
                return null;
            }

            Index index = parentKey.GetSortIndex((version == DataRowVersion.Original) ? DataViewRowState.OriginalRows : DataViewRowState.CurrentRows);
            Range range = index.FindRecords(values);
            if (range.IsNull) {
                return null;
            }

            if (range.Count > 1) {
                throw ExceptionBuilder.MultipleParents();
            }
            return parentKey.Table.recordManager[index.GetRecord(range.Min)];
        }


        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.SetDataSet"]/*' />
        /// <devdoc>
        /// Internally sets the DataSet pointer.
        /// </devdoc>
        internal void SetDataSet(DataSet dataSet) {
            if (this.dataSet != dataSet) {
                this.dataSet = dataSet;
            }
        }

        internal void SetParentRowRecords(DataRow childRow, DataRow parentRow) {
            object[] parentKeyValues = parentRow.GetKeyValues(ParentKey);
            if (childRow.tempRecord != -1) {
                ChildTable.recordManager.SetKeyValues(childRow.tempRecord, ChildKey, parentKeyValues);
            }
            if (childRow.newRecord != -1) {
                ChildTable.recordManager.SetKeyValues(childRow.newRecord, ChildKey, parentKeyValues);
            }
            if (childRow.oldRecord != -1) {
                ChildTable.recordManager.SetKeyValues(childRow.oldRecord, ChildKey, parentKeyValues);
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ParentColumns"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the parent columns of this relation.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataRelationParentColumnsDescr)
        ]
        public virtual DataColumn[] ParentColumns {
            get {
                CheckStateForProperty();
                return parentKey.Columns;
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ParentKey"]/*' />
        /// <devdoc>
        /// The internal constraint object for the parent table.
        /// </devdoc>
        internal virtual DataKey ParentKey {
            get {
                CheckStateForProperty();
                return parentKey;
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ParentTable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the parent table of this relation.
        ///    </para>
        /// </devdoc>
        public virtual DataTable ParentTable {
            get {
                CheckStateForProperty();
                return parentKey.Table;
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.RelationName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the name used to look up this relation in the parent
        ///       data set's <see cref='System.Data.DataRelationCollection'/>.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        DataSysDescription(Res.DataRelationRelationNameDescr)
        ]
        public virtual string RelationName {
            get {
                CheckStateForProperty();
                return relationName;
            }
            set {
                if (value == null)
                    value = "";

                CultureInfo locale = (dataSet != null ? dataSet.Locale : CultureInfo.CurrentCulture);
                if (String.Compare(relationName, value, true, locale) != 0) {
                    if (dataSet != null) {
                        if (value.Length == 0)
                            throw ExceptionBuilder.NoRelationName();
                        dataSet.Relations.RegisterName(value);
                        if (relationName.Length != 0)
                            dataSet.Relations.UnregisterName(relationName);
                    }
                    this.relationName = value;
                    ((DataRelationCollection.DataTableRelationCollection)(ParentTable.ChildRelations)).OnRelationPropertyChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, this));
                    ((DataRelationCollection.DataTableRelationCollection)(ChildTable.ParentRelations)).OnRelationPropertyChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, this));
                }
                else if (String.Compare(relationName, value, false, locale) != 0) {
                    relationName = value;
                    ((DataRelationCollection.DataTableRelationCollection)(ParentTable.ChildRelations)).OnRelationPropertyChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, this));
                    ((DataRelationCollection.DataTableRelationCollection)(ChildTable.ParentRelations)).OnRelationPropertyChanged(new CollectionChangeEventArgs(CollectionChangeAction.Refresh, this));
                }
            }
        }

        internal void CheckNestedRelations() {
            Debug.Assert(DataSet == null || ! nested, "this relation supposed to be not in dataset or not nested");
            // 1. There is no other relation (R) that has this.ChildTable as R.ChildTable
            if(ChildTable.FindNestedParent() != null) {
                throw ExceptionBuilder.TableCantBeNestedInTwoTables(ChildTable.TableName);
            }
            // 2. There is no loop in nested relations
#if DEBUG
            int numTables = ParentTable.DataSet.Tables.Count;
#endif
            DataTable dt = ParentTable;
            
            if (ChildTable == ParentTable){
                if (ChildTable.TableName == ChildTable.DataSet.DataSetName)  
                   throw ExceptionBuilder.SelfnestedDatasetConflictingName(ChildTable.TableName);
                return; //allow self join tables.
            }

            while (true) {
#if DEBUG
                Debug.Assert(0 < (numTables--), "We already have a loop in nested relations");
#endif
                if (dt == ChildTable)  {
                    throw ExceptionBuilder.LoopInNestedRelations(ChildTable.TableName);
                }

                if (dt.nestedParentRelation != null && dt != dt.nestedParentRelation.ParentTable)
                    dt = dt.nestedParentRelation.ParentTable;
                else
                    break;
            }
        }// CheckNestedRelationss

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.Nested"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether relations are nested.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(false),
        DataSysDescription(Res.DataRelationNested)
        ]
        public virtual bool Nested {
            get {
                CheckStateForProperty();
                return nested;
            }
            set {
                if (nested != value) {
                    if (dataSet != null) {
                        if (value) {
                            Debug.Assert(ChildTable != null, "On a DataSet, but not on Table. Bad state");
                            ForeignKeyConstraint constraint = ChildTable.Constraints.FindForeignKeyConstraint(ChildKey.Columns, ParentKey.Columns);
                            if (constraint != null)
                                constraint.CheckConstraint();
                        }
                    }
                    if (!value && (parentKey.Columns[0].ColumnMapping == MappingType.Hidden))
                        throw ExceptionBuilder.RelationNestedReadOnly();

                    if (value) {
                      this.ParentTable.Columns.RegisterName(this.ChildTable.TableName, this.ChildTable);
                    } else {
                      this.ParentTable.Columns.UnregisterName(this.ChildTable.TableName);
                    }
                    RaisePropertyChanging("Nested");

                    if(value) {
                        CheckNestedRelations();
                        if (this.DataSet != null)
                            if (ParentTable == ChildTable) {
                                foreach(DataRow row in ChildTable.Rows)
                                    row.CheckForLoops(this);

                                if (ChildTable.DataSet != null && ( String.Compare(ChildTable.TableName, ChildTable.DataSet.DataSetName, true, ChildTable.DataSet.Locale) == 0) )
                                    throw ExceptionBuilder.DatasetConflictingName(dataSet.DataSetName);                                    
                                ChildTable.fNestedInDataset = false;
                            }
                            else {
                                    foreach(DataRow row in ChildTable.Rows)
                                        row.GetParentRow(this);
                            }
                        
                        ChildTable.CacheNestedParent(this);
                        this.ParentTable.ElementColumnCount++;
                    }
                    else {
                        ChildTable.CacheNestedParent(null);
                        this.ParentTable.ElementColumnCount--;
                    }

                    this.nested = value;
                }
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ParentKeyConstraint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the constraint which ensures values in a column are unique.
        ///    </para>
        /// </devdoc>
        public virtual UniqueConstraint ParentKeyConstraint {
            get {
                CheckStateForProperty();
                return parentKeyConstraint;
            }
        }

        internal void SetParentKeyConstraint(UniqueConstraint value) {
            Debug.Assert(parentKeyConstraint == null || value == null, "ParentKeyConstraint should not have been set already.");
            parentKeyConstraint = value;
        }


        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ChildKeyConstraint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Data.ForeignKeyConstraint'/> for the relation.
        ///    </para>
        /// </devdoc>
        public virtual ForeignKeyConstraint ChildKeyConstraint {
            get {
                CheckStateForProperty();
                return childKeyConstraint;
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ExtendedProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of custom user information.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data), 
        Browsable(false),
        DataSysDescription(Res.ExtendedPropertiesDescr)
        ]
        public PropertyCollection ExtendedProperties {
            get {
                if (extendedProperties == null) {
                    extendedProperties = new PropertyCollection();
                }
                return extendedProperties;
            }
        }

        internal void SetChildKeyConstraint(ForeignKeyConstraint value) {
            Debug.Assert(childKeyConstraint == null || value == null, "ChildKeyConstraint should not have been set already.");
            childKeyConstraint = value;
        }

        internal event PropertyChangedEventHandler PropertyChanging {
            add {
                onPropertyChangingDelegate += value; 
            }
            remove {
                onPropertyChangingDelegate -= value;
            }
        }
        // If we're not in a dataSet relations collection, we need to verify on every property get that we're
        // still a good relation object.
        internal void CheckState() {
            if (dataSet == null) {
                parentKey.CheckState();
                childKey.CheckState();

                if (parentKey.Table.DataSet != childKey.Table.DataSet) {
                    throw ExceptionBuilder.RelationDataSetMismatch();
                }

                if (childKey.ColumnsEqual(parentKey)) {
                    throw ExceptionBuilder.KeyColumnsIdentical();
                }

                for (int i = 0; i < parentKey.Columns.Length; i++) {
                    if (parentKey.Columns[i].DataType != childKey.Columns[i].DataType)
                        throw ExceptionBuilder.ColumnsTypeMismatch();
                }
            }
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.CheckStateForProperty"]/*' />
        /// <devdoc>
        ///    <para>Checks to ensure the DataRelation is a valid object, even if it doesn't
        ///       belong to a <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        protected void CheckStateForProperty() {
            try {
                CheckState();
            }
            catch (Exception e) {
                throw ExceptionBuilder.BadObjectPropertyAccess(e.Message);            
            }
        }

        private void Create(string relationName, DataColumn[] parentColumns, DataColumn[] childColumns, bool createConstraints) {
            this.parentKey = new DataKey(parentColumns);
            this.childKey = new DataKey(childColumns);

            if (parentColumns.Length != childColumns.Length)
                throw ExceptionBuilder.KeyLengthMismatch();

            CheckState();

            this.relationName = (relationName == null ? "" : relationName);
            this.createConstraints = createConstraints;
        }


        internal DataRelation Clone(DataSet destination) {
            DataTable parent = destination.Tables[ParentTable.TableName];
            DataTable child = destination.Tables[ChildTable.TableName];
            int keyLength = parentKey.Columns.Length;

            DataColumn[] parentColumns = new DataColumn[keyLength];
            DataColumn[] childColumns = new DataColumn[keyLength];

            for (int i = 0; i < keyLength; i++) {
                parentColumns[i] = parent.Columns[ParentKey.Columns[i].ColumnName];
                childColumns[i] = child.Columns[ChildKey.Columns[i].ColumnName];
            }

            DataRelation clone = new DataRelation(relationName, parentColumns, childColumns, false);
            clone.Nested = this.Nested;

            // ...Extended Properties
            if (this.extendedProperties != null) {
                foreach(Object key in this.extendedProperties.Keys) {
                    clone.ExtendedProperties[key]=this.extendedProperties[key];
                }
            }

            return clone;
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.OnPropertyChanging"]/*' />
        protected internal void OnPropertyChanging(PropertyChangedEventArgs pcevent) {
            if (onPropertyChangingDelegate != null)
                onPropertyChangingDelegate(this, pcevent);
        }
        
        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.RaisePropertyChanging"]/*' />
        protected internal void RaisePropertyChanging(string name) {
            OnPropertyChanging(new PropertyChangedEventArgs(name));
        }

        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.ToString"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override string ToString() {
            return RelationName;
        }
        
#if DEBUG
        /// <include file='doc\DataRelation.uex' path='docs/doc[@for="DataRelation.Dump"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public void Dump(string header, bool deep) {
            DataColumn[] cols;
            DataColumn   col;
            int i;
            Debug.WriteLine(header + "DataRelation");
            header += "  ";
            Debug.WriteLine(header + "Relation name: " + this.RelationName);
            Debug.WriteLine(header + "Nested:        " + (this.Nested ? "true" : "false"));
            Debug.WriteLine(header + "Parent table:  " + this.ParentTable.TableName);
            Debug.Write(    header + "Parent cols:   ");
            cols = this.ParentColumns;
            if (cols.Length == 0)
                Debug.WriteLine("none");
            else {
                Debug.Write(cols[0].Table.TableName + "." + cols[0].ColumnName);
                for (i = 1; i < cols.Length; i++) {
                    col = cols[i];
                    Debug.Write(" + " + col.Table.TableName + "." + col.ColumnName);
                }
                Debug.WriteLine("");
            }

            Debug.WriteLine(header + "Child table:   " + this.ChildTable.TableName);
            Debug.Write(    header + "Child cols:    ");
            cols = this.ChildColumns;
            if (cols.Length == 0)
                Debug.WriteLine("none");
            else {
                Debug.Write(cols[0].Table.TableName + "." + cols[0].ColumnName);
                for (i = 1; i < cols.Length; i++) {
                    col = cols[i];
                    Debug.Write(" + " + col.Table.TableName + "." + col.ColumnName);
                }
                Debug.WriteLine("");
            }

            Debug.Write(    header + "Constraints:   " + (this.createConstraints ? "yes" : "no"));
            Debug.Write(this.ParentKeyConstraint == null ? " parent(null)" : " parent(UNIQUE - table: '" + this.ParentKeyConstraint.Table.TableName + "' name: '" + this.ParentKeyConstraint.ConstraintName + "')");
            Debug.Write(this.ChildKeyConstraint  == null ? " child(null)" : " child(FK - table: '" + this.ChildKeyConstraint.Table.TableName + "' name: '" + this.ChildKeyConstraint.ConstraintName + "')");
            Debug.WriteLine("");
        }
#endif

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarowaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRowAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\DataRowAction.uex' path='docs/doc[@for="DataRowAction"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Describes the action taken on a <see cref='System.Data.DataRow'/>.
    ///    </para>
    /// </devdoc>
    [Flags] public enum DataRowAction { 
    
        /// <include file='doc\DataRowAction.uex' path='docs/doc[@for="DataRowAction.Nothing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No change.
        ///    </para>
        /// </devdoc>
        Nothing = 0x00000000,
        /// <include file='doc\DataRowAction.uex' path='docs/doc[@for="DataRowAction.Delete"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The row was
        ///       deleted from the table.
        ///       
        ///    </para>
        /// </devdoc>
        Delete = 0x00000001,
        /// <include file='doc\DataRowAction.uex' path='docs/doc[@for="DataRowAction.Change"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The row was changed.
        ///       
        ///    </para>
        /// </devdoc>
        Change = 0x00000002,
        /// <include file='doc\DataRowAction.uex' path='docs/doc[@for="DataRowAction.Rollback"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The change has been rolled back.
        ///    </para>
        /// </devdoc>
        Rollback = 0x0000004,
        /// <include file='doc\DataRowAction.uex' path='docs/doc[@for="DataRowAction.Commit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The row has been committed.
        ///    </para>
        /// </devdoc>
        Commit = 0x00000008,
        /// <include file='doc\DataRowAction.uex' path='docs/doc[@for="DataRowAction.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The row has been added to the table.
        ///       
        ///    </para>
        /// </devdoc>
        Add = 0x000000010    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarelationpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRelationPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System.ComponentModel;

    /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>    
    internal class DataRelationPropertyDescriptor : PropertyDescriptor {

        DataRelation relation;

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.Relation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataRelation Relation {
            get {
                return relation;
            }
        }

        internal DataRelationPropertyDescriptor(DataRelation dataRelation) : base(dataRelation.RelationName, null) {
            this.relation = dataRelation; 
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type ComponentType {
            get {
                return typeof(DataRowView);
            }
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type PropertyType {
            get {
                return typeof(IBindingList);
            }
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object other) {
            if (other is DataRelationPropertyDescriptor) {
                DataRelationPropertyDescriptor descriptor = (DataRelationPropertyDescriptor) other;
                return(descriptor.Relation == Relation);
            }
            return false;
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Int32 GetHashCode() {
            return Relation.GetHashCode();
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool CanResetValue(object component) {
            return false;
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object GetValue(object component) {
            DataRowView dataRowView = (DataRowView) component;
            return dataRowView.CreateChildView(relation);
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void ResetValue(object component) {
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SetValue(object component, object value) {
        }

        /// <include file='doc\DataRowViewRelationDescriptor.uex' path='docs/doc[@for="DataRowViewRelationDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool ShouldSerializeValue(object component) {
            return false;
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarelationcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRelationCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;
    using System.Drawing.Design;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;

    /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the collection of relations,
    ///       each of which allows navigation between related parent/child tables.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("CollectionChanged"),
    Editor("Microsoft.VSDesigner.Data.Design.DataRelationCollectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)), 
    DefaultProperty("Table"),  
    Serializable
    ]
    public abstract class DataRelationCollection : InternalDataCollectionBase {

        private DataRelation inTransition = null;

        private int defaultNameIndex = 1;

        private CollectionChangeEventHandler onCollectionChangedDelegate;
        private CollectionChangeEventHandler onCollectionChangingDelegate;

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the relation specified by index.</para>
        /// </devdoc>
        public abstract DataRelation this[int index] {
            get;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets the relation specified by name.</para>
        /// </devdoc>
        public abstract DataRelation this[string name] {
            get;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Add"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Adds the relation to the collection.</para>
        /// </devdoc>
        public void Add(DataRelation relation) {
            if (inTransition == relation)
                return;
            inTransition = relation;
            try {
                OnCollectionChanging(new CollectionChangeEventArgs(CollectionChangeAction.Add, relation));
                AddCore(relation);
                OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, relation));
            }
            catch (Exception e) {
                inTransition = null;
                throw e;
            }
            inTransition = null;
        }
        
        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddRange(DataRelation[] relations) {
            if (relations != null) {
                foreach(DataRelation relation in relations) {
                    if (relation != null) {
                        Add(relation);
                    }
                }
            }
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Creates a <see cref='System.Data.DataRelation'/> with the
        ///       specified name, parent columns,
        ///       child columns, and adds it to the collection.</para>
        /// </devdoc>
        public virtual DataRelation Add(string name, DataColumn[] parentColumns, DataColumn[] childColumns) {
            DataRelation relation = new DataRelation(name, parentColumns, childColumns);
            Add(relation);
            return relation;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Add2"]/*' />
        /// <devdoc>
        /// Creates a relation given the parameters and adds it to the collection.  An ArgumentNullException is
        /// thrown if this relation is null.  An ArgumentException is thrown if this relation already belongs to
        /// this collection, belongs to another collection, or if this collection already has a relation with the
        /// same name (case insensitive).
        /// An InvalidRelationException is thrown if the relation can't be created based on the parameters.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public virtual DataRelation Add(string name, DataColumn[] parentColumns, DataColumn[] childColumns, bool createConstraints) {
            DataRelation relation = new DataRelation(name, parentColumns, childColumns, createConstraints);
            Add(relation);
            return relation;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Add3"]/*' />
        /// <devdoc>
        /// Creates a relation given the parameters and adds it to the collection.  The name is defaulted.
        /// An ArgumentException is thrown if
        /// this relation already belongs to this collection or belongs to another collection.
        /// An InvalidConstraintException is thrown if the relation can't be created based on the parameters.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public virtual DataRelation Add(DataColumn[] parentColumns, DataColumn[] childColumns) {
            DataRelation relation = new DataRelation(null, parentColumns, childColumns);
            Add(relation);
            return relation;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Add4"]/*' />
        /// <devdoc>
        /// Creates a relation given the parameters and adds it to the collection.
        /// An ArgumentException is thrown if this relation already belongs to
        /// this collection or belongs to another collection.
        /// A DuplicateNameException is thrown if this collection already has a relation with the same
        /// name (case insensitive).
        /// An InvalidConstraintException is thrown if the relation can't be created based on the parameters.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public virtual DataRelation Add(string name, DataColumn parentColumn, DataColumn childColumn) {
            DataRelation relation = new DataRelation(name, parentColumn, childColumn);
            Add(relation);
            return relation;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Add5"]/*' />
        /// <devdoc>
        /// Creates a relation given the parameters and adds it to the collection.
        /// An ArgumentException is thrown if this relation already belongs to
        /// this collection or belongs to another collection.
        /// A DuplicateNameException is thrown if this collection already has a relation with the same
        /// name (case insensitive).
        /// An InvalidConstraintException is thrown if the relation can't be created based on the parameters.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public virtual DataRelation Add(string name, DataColumn parentColumn, DataColumn childColumn, bool createConstraints) {
            DataRelation relation = new DataRelation(name, parentColumn, childColumn, createConstraints);
            Add(relation);
            return relation;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Add6"]/*' />
        /// <devdoc>
        /// Creates a relation given the parameters and adds it to the collection.  The name is defaulted.
        /// An ArgumentException is thrown if
        /// this relation already belongs to this collection or belongs to another collection.
        /// An InvalidConstraintException is thrown if the relation can't be created based on the parameters.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public virtual DataRelation Add(DataColumn parentColumn, DataColumn childColumn) {
            DataRelation relation = new DataRelation(null, parentColumn, childColumn);
            Add(relation);
            return relation;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.AddCore"]/*' />
        /// <devdoc>
        /// Does verification on the table.
        /// An ArgumentNullException is thrown if this relation is null.  An ArgumentException is thrown if this relation
        ///  already belongs to this collection, belongs to another collection.
        /// A DuplicateNameException is thrown if this collection already has a relation with the same
        /// name (case insensitive).
        /// </devdoc>
        protected virtual void AddCore(DataRelation relation) {
            if (relation == null)
                throw ExceptionBuilder.ArgumentNull("relation");
            relation.CheckState();
            DataSet dataSet = GetDataSet();
            if (relation.DataSet == dataSet)
                throw ExceptionBuilder.RelationAlreadyInTheDataSet();
            if (relation.DataSet != null)
                throw ExceptionBuilder.RelationAlreadyInOtherDataSet();
            if (relation.ChildTable.Locale.LCID != relation.ParentTable.Locale.LCID || 
                relation.ChildTable.CaseSensitive != relation.ParentTable.CaseSensitive)
                throw ExceptionBuilder.CaseLocaleMismatch();
            if (relation.Nested)
                relation.ParentTable.ElementColumnCount++;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.CollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [ResDescription(Res.collectionChangedEventDescr)]
        public event CollectionChangeEventHandler CollectionChanged {
            add {
                onCollectionChangedDelegate += value;
            }
            remove {
                onCollectionChangedDelegate -= value;
            }
        }

        internal event CollectionChangeEventHandler CollectionChanging {
            add {
                onCollectionChangingDelegate += value;
            }
            remove {
                onCollectionChangingDelegate -= value;
            }
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.AssignName"]/*' />
        /// <devdoc>
        /// Creates a new default name.
        /// </devdoc>
        internal string AssignName() {
            string newName = MakeName(defaultNameIndex);
            defaultNameIndex++;
            return newName;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Clear"]/*' />
        /// <devdoc>
        /// Clears the collection of any relations.
        /// </devdoc>
        public virtual void Clear() {
            int count = Count;
            OnCollectionChanging(RefreshEventArgs);
            for (int i = count - 1; i >= 0; i--) {
                inTransition = this[i];
                RemoveCore(inTransition); // haroona : No need to go for try catch here and this will surely not throw any exception
            }
            OnCollectionChanged(RefreshEventArgs);
            inTransition = null;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Contains"]/*' />
        /// <devdoc>
        ///  Returns true if this collection has a relation with the given name (case insensitive), false otherwise.
        /// </devdoc>
        public virtual bool Contains(string name) {
            return(InternalIndexOf(name) >= 0);
        }

        internal bool Contains(string name, bool caseSensitive) {
            if (!caseSensitive)
                return Contains(name);
            int index = InternalIndexOf(name);
            if (index<0)
                return false;
            return (name == ((DataRelation) List[index]).RelationName);
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the index of a specified <see cref='System.Data.DataRelation'/>.
        ///    </para>
        /// </devdoc>
        public virtual int IndexOf(DataRelation relation) {
            int relationCount = List.Count;
            for (int i = 0; i < relationCount; ++i) {
                if (relation == (DataRelation) List[i]) {
                    return i;
                }
            }
            return -1;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.IndexOf1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the index of the
        ///       relation with the given name (case insensitive), or -1 if the relation
        ///       doesn't exist in the collection.
        ///    </para>
        /// </devdoc>
        public virtual int IndexOf(string relationName) {
            int index = InternalIndexOf(relationName);
            return (index < 0) ? -1 : index;
        }

        internal int InternalIndexOf(string name) {
            int cachedI = -1;
            if ((null != name) && (0 < name.Length)) {
                int count = List.Count;
                int result = 0;
                for (int i = 0; i < count; i++) {
                    DataRelation relation = (DataRelation) List[i];
                    result = NamesEqual(relation.RelationName, name, false, GetDataSet().Locale);
                    if (result == 1)
                        return i;

                    if (result == -1)
                        cachedI = (cachedI == -1) ? i : -2;
                }
            }
            return cachedI;                    
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.GetDataSet"]/*' />
        /// <devdoc>
        /// Gets the dataSet for this collection.
        /// </devdoc>
        protected abstract DataSet GetDataSet();


        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.MakeName"]/*' />
        /// <devdoc>
        /// Makes a default name with the given index.  e.g. Relation1, Relation2, ... Relationi
        /// </devdoc>
        private string MakeName(int index) {
            return "Relation" + index.ToString();
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.OnCollectionChanged"]/*' />
        /// <devdoc>
        /// This method is called whenever the collection changes.  Overriders
        /// of this method should call the base implementation of this method.
        /// </devdoc>
        protected virtual void OnCollectionChanged(CollectionChangeEventArgs ccevent) {
            if (onCollectionChangedDelegate != null) {
                onCollectionChangedDelegate(this, ccevent);
            }
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.OnCollectionChanging"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal virtual void OnCollectionChanging(CollectionChangeEventArgs ccevent) {
            if (onCollectionChangingDelegate != null) {
                onCollectionChangingDelegate(this, ccevent);
            }
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.RegisterName"]/*' />
        /// <devdoc>
        /// Registers this name as being used in the collection.  Will throw an ArgumentException
        /// if the name is already being used.  Called by Add, All property, and Relation.RelationName property.
        /// if the name is equivalent to the next default name to hand out, we increment our defaultNameIndex.
        /// </devdoc>
        internal void RegisterName(string name) {
            Debug.Assert (name != null);

            CultureInfo locale = GetDataSet().Locale;
            int relationCount = Count;
            for (int i = 0; i < relationCount; i++) {
                if (NamesEqual(name, this[i].RelationName, true, locale) != 0) {
                    throw ExceptionBuilder.DuplicateRelation(this[i].RelationName);
                }
            }
            if (NamesEqual(name, MakeName(defaultNameIndex), true, locale) != 0) {
                defaultNameIndex++;
            }
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.CanRemove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Verifies if a given relation can be removed from the collection.
        ///    </para>
        /// </devdoc>
        public virtual bool CanRemove(DataRelation relation) {
            if (relation == null)
                return false;

            if (relation.DataSet != GetDataSet())
                return false;

            return true;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Remove"]/*' />
        /// <devdoc>
        /// Removes the given relation from the collection.
        /// An ArgumentNullException is thrown if this relation is null.  An ArgumentException is thrown
        /// if this relation doesn't belong to this collection.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public void Remove(DataRelation relation) {
            if (inTransition == relation)
                return;
            inTransition = relation;
            try {
                OnCollectionChanging(new CollectionChangeEventArgs(CollectionChangeAction.Remove, relation));
                RemoveCore(relation);
                OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, relation));
            }
            catch (Exception e) {
                inTransition = null;
                throw e;
            }
            inTransition = null;
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.RemoveAt"]/*' />
        /// <devdoc>
        /// Removes the relation at the given index from the collection.  An IndexOutOfRangeException is
        /// thrown if this collection doesn't have a relation at this index.
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public void RemoveAt(int index) {
            DataRelation dr = this[index];
            if (dr == null) {
                throw ExceptionBuilder.RelationOutOfRange(index);
            } 
            else {
                Remove(dr);
            }
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Remove1"]/*' />
        /// <devdoc>
        /// Removes the relation with the given name from the collection.  An IndexOutOfRangeException is
        /// thrown if this collection doesn't have a relation with that name
        /// The CollectionChanged event is fired if it succeeds.
        /// </devdoc>
        public void Remove(string name) {
            DataRelation dr = this[name];
            if (dr == null) {
                throw ExceptionBuilder.RelationNotInTheDataSet(name);
            } else {
                Remove(dr);
            }
        }

        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.RemoveCore"]/*' />
        /// <devdoc>
        /// Does verification on the relation.
        /// An ArgumentNullException is thrown if this relation is null.  An ArgumentException is thrown
        /// if this relation doesn't belong to this collection.
        /// </devdoc>
        protected virtual void RemoveCore(DataRelation relation) {
            if (relation == null)
                throw ExceptionBuilder.ArgumentNull("relation");
            DataSet dataSet = GetDataSet();
            if (relation.DataSet != dataSet)
                throw ExceptionBuilder.RelationNotInTheDataSet(relation.RelationName);
            if (relation.Nested)
                relation.ParentTable.ElementColumnCount--;
        }
        
        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.UnregisterName"]/*' />
        /// <devdoc>
        /// Unregisters this name as no longer being used in the collection.  Called by Remove, All property, and
        /// Relation.RelationName property.  If the name is equivalent to the last proposed default namem, we walk backwards
        /// to find the next proper default name to hang out.
        /// </devdoc>
        internal void UnregisterName(string name) {
            if (NamesEqual(name, MakeName(defaultNameIndex - 1), true, GetDataSet().Locale) != 0) {
                do {
                    defaultNameIndex--;
                } while (defaultNameIndex > 1 &&
                         !Contains(MakeName(defaultNameIndex - 1)));
            }
        }

        internal class DataTableRelationCollection : DataRelationCollection {

            private DataTable table;
            private ArrayList relations; // For caching purpose only to improve performance
            bool fParentCollection;

            private CollectionChangeEventHandler onRelationPropertyChangedDelegate;

            internal DataTableRelationCollection(DataTable table, bool fParentCollection) {
                if (table == null)
                    throw ExceptionBuilder.RelationTableNull();
                this.table = table;
                this.fParentCollection = fParentCollection;
                relations = new ArrayList();
            }

            protected override ArrayList List {
                get {
                    if (table == null)
                        throw ExceptionBuilder.ArgumentNull("table");
                    return relations;
                }
            }

            private void EnsureDataSet() {
                if (table.DataSet == null) {
                    throw ExceptionBuilder.RelationTableWasRemoved();
                }
            }

            protected override DataSet GetDataSet() {
                EnsureDataSet();
                return table.DataSet;
            }

            public override DataRelation this[int index] {
                get {
                    if (index >= 0 && index < relations.Count)
                        return (DataRelation)relations[index];
                    else
                        throw ExceptionBuilder.RelationOutOfRange(index);
                }
            }

            public override DataRelation this[string name] {
                get {
                    int index = InternalIndexOf(name);
                    if (index == -2) {
                        throw ExceptionBuilder.CaseInsensitiveNameConflict(name);
                    }
                    return (index < 0) ? null : (DataRelation)List[index];
                }
            }

            internal event CollectionChangeEventHandler RelationPropertyChanged {
                add {
                    onRelationPropertyChangedDelegate += value;
                }
                remove {
                    onRelationPropertyChangedDelegate -= value;
                }
            }

            internal void OnRelationPropertyChanged(CollectionChangeEventArgs ccevent) {
                if (!fParentCollection) {
                    table.UpdatePropertyDescriptorCollectionCache();
                }
                if (onRelationPropertyChangedDelegate != null) {
                    onRelationPropertyChangedDelegate(this, ccevent);
                }
            }

            private void AddCache(DataRelation relation) {
                relations.Add(relation);
                if (!fParentCollection) {
                    table.UpdatePropertyDescriptorCollectionCache();
                }
            }

            protected override void AddCore(DataRelation relation) {
                if (fParentCollection) {
                    if (relation.ChildTable != table)
                        throw ExceptionBuilder.ChildTableMismatch();
                }
                else {
                    if (relation.ParentTable != table)
                        throw ExceptionBuilder.ParentTableMismatch();
                }

//                base.AddCore(relation); // Will be called from DataSet.Relations.AddCore
                table.DataSet.Relations.Add(relation);
                AddCache(relation);
            }

            public override bool CanRemove(DataRelation relation) {
                if (!base.CanRemove(relation))
                    return false;

                if (fParentCollection) {
                    if (relation.ChildTable != table)
                        return false;
                }
                else {
                    if (relation.ParentTable != table)
                        return false;
                }

                return true;
            }

            private void RemoveCache(DataRelation relation) {
                for (int i = 0; i < relations.Count; i++) {
                    if (relation == relations[i]) {
                        relations.RemoveAt(i);
                        if (!fParentCollection) {
                            table.UpdatePropertyDescriptorCollectionCache();
                        }
                        return;
                    }
                }
                throw ExceptionBuilder.RelationDoesNotExist();
            }

            protected override void RemoveCore(DataRelation relation) {
                if (fParentCollection) {
                    if (relation.ChildTable != table)
                        throw ExceptionBuilder.ChildTableMismatch();
                }
                else {
                    if (relation.ParentTable != table)
                        throw ExceptionBuilder.ParentTableMismatch();
                }

//                base.RemoveCore(relation); // Will be called from DataSet.Relations.RemoveCore
                table.DataSet.Relations.Remove(relation);
                RemoveCache(relation);
            }
        }

        internal class DataSetRelationCollection : DataRelationCollection {

            private DataSet dataSet;
            private ArrayList relations;
            private DataRelation[] delayLoadingRelations = null;

            internal DataSetRelationCollection(DataSet dataSet) {
                if (dataSet == null)
                    throw ExceptionBuilder.RelationDataSetNull();
                this.dataSet = dataSet;
                relations = new ArrayList();
            }

            public override void AddRange(DataRelation[] relations) {
                if (dataSet.fInitInProgress) {
                    delayLoadingRelations = relations;
                    return;
                }

                if (relations != null) {
                    foreach(DataRelation relation in relations) {
                        if (relation != null) {
                            Add(relation);
                        }
                    }
                }
            }

            public override void Clear() {
                base.Clear();
                if (dataSet.fInitInProgress && delayLoadingRelations != null) {
                    delayLoadingRelations = null;
                }
            }

            protected override ArrayList List {
                get {
                    if (dataSet == null)
                        throw ExceptionBuilder.ArgumentNull("dataSet");
                    return relations;
                }
            }

            protected override DataSet GetDataSet() {
                return dataSet;
            }

            public override DataRelation this[int index] {
                get {
                    if (index >= 0 && index < relations.Count)
                        return (DataRelation)relations[index];
                    else
                        throw ExceptionBuilder.RelationOutOfRange(index);
                }
            }

            public override DataRelation this[string name] {
                get {
                    int index = InternalIndexOf(name);
                    if (index == -2) {
                        throw ExceptionBuilder.CaseInsensitiveNameConflict(name);
                    }
                    return (index < 0) ? null : (DataRelation)List[index];
                }
            }

            protected override void AddCore(DataRelation relation) {
                base.AddCore(relation);
                if (relation.ChildTable.DataSet != dataSet || relation.ParentTable.DataSet != dataSet)
                    throw ExceptionBuilder.ForeignRelation();

                relation.CheckState();
                if(relation.Nested) {
                    relation.CheckNestedRelations();
                }

                if (relation.relationName.Length == 0)
                    relation.relationName = AssignName();
                else
                    RegisterName(relation.relationName);

                DataKey childKey = relation.ChildKey;

                for (int i = 0; i < relations.Count; i++) {
                    if (childKey.ColumnsEqual(((DataRelation)relations[i]).ChildKey)) {
                        if (relation.ParentKey.ColumnsEqual(((DataRelation)relations[i]).ParentKey))
                            throw ExceptionBuilder.RelationAlreadyExists();
                    }
                }

                relations.Add(relation);
                ((DataRelationCollection.DataTableRelationCollection)(relation.ParentTable.ChildRelations)).Add(relation); // Caching in ParentTable -> ChildRelations
                ((DataRelationCollection.DataTableRelationCollection)(relation.ChildTable.ParentRelations)).Add(relation); // Caching in ChildTable -> ParentRelations

                relation.SetDataSet(dataSet);
                relation.ChildKey.GetSortIndex().AddRef();
                if (relation.Nested) {
                    relation.ChildTable.CacheNestedParent(relation);
                }

                ForeignKeyConstraint foreignKey = relation.ChildTable.Constraints.FindForeignKeyConstraint(relation.ParentColumns, relation.ChildColumns);
                if (relation.createConstraints) {
                    if (foreignKey == null) {
                        relation.ChildTable.Constraints.Add(foreignKey = new ForeignKeyConstraint(relation.ParentColumns, relation.ChildColumns));

                        // try to name the fk constraint the same as the parent relation:
                        try {
                            foreignKey.ConstraintName = relation.RelationName;
                        } catch {
                            // ignore the exception
                        }
                    }
                }
                UniqueConstraint key = relation.ParentTable.Constraints.FindKeyConstraint(relation.ParentColumns);
                relation.SetParentKeyConstraint(key);
                relation.SetChildKeyConstraint(foreignKey);
            }

            protected override void RemoveCore(DataRelation relation) {
                base.RemoveCore(relation);

                dataSet.OnRemoveRelationHack(relation);

                relation.SetDataSet(null);
                relation.ChildKey.GetSortIndex().RemoveRef();
                if (relation.Nested) {
                    relation.ChildTable.CacheNestedParent(null);
                }

                for (int i = 0; i < relations.Count; i++) {
                    if (relation == relations[i]) {
                        relations.RemoveAt(i);
                        ((DataRelationCollection.DataTableRelationCollection)(relation.ParentTable.ChildRelations)).Remove(relation); // Remove Cache from ParentTable -> ChildRelations
                        ((DataRelationCollection.DataTableRelationCollection)(relation.ChildTable.ParentRelations)).Remove(relation); // Removing Cache from ChildTable -> ParentRelations

                        UnregisterName(relation.RelationName);

                        relation.SetParentKeyConstraint(null);
                        relation.SetChildKeyConstraint(null);

                        return;
                    }
                }
                throw ExceptionBuilder.RelationDoesNotExist();
            }

            internal void FinishInitRelations() {
                if (delayLoadingRelations == null)
                    return;
                    
                DataRelation rel;
                int colCount;
                DataColumn[] parents, childs;
                for (int i = 0; i < delayLoadingRelations.Length; i++) {
                    rel = delayLoadingRelations[i];
                    if (rel.parentColumnNames == null || rel.childColumnNames == null) {
                        this.Add(rel);
                        continue;
                    }
                        
                    colCount = rel.parentColumnNames.Length;
                    parents = new DataColumn[colCount];
                    childs = new DataColumn[colCount];
                    for (int j = 0; j < colCount; j++) {
                        parents[j] = dataSet.Tables[rel.parentTableName].Columns[rel.parentColumnNames[j]];
                        childs[j] = dataSet.Tables[rel.childTableName].Columns[rel.childColumnNames[j]];
                    }
                    DataRelation newRelation = new DataRelation(rel.relationName, parents, childs, false);
                    newRelation.Nested = rel.nested;
                    this.Add(newRelation);
                }

                delayLoadingRelations = null;
            }
        }

#if DEBUG
        /// <include file='doc\DataRelationCollection.uex' path='docs/doc[@for="DataRelationCollection.Dump"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Diagnostics.Conditional("DEBUG")]
        public void Dump(string header, bool deep) {
            Debug.WriteLine(header + "DataRelationCollection");
            header += "  ";
            Debug.WriteLine(header + "Count:  " + this.Count.ToString());
            if (deep) {
                Debug.WriteLine(header + "Relations present:");
                header += "  ";
                for (int i = 0; i < this.Count; i++) {
                    this[i].Dump(header, true);
                }
            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Runtime.Serialization;
    
    // SDUB: This functions are major point of localization.
    // We need to have a rules to enforce consistency there.
    // The dangerous point there are the string arguments of the exported (internal) methods.
    // This string can be argument, table or constraint name but never text of exception itself.
    // Make an invariant that all texts of exceptions coming from resources only.

    /// <include file='doc\DataException.uex' path='docs/doc[@for="DataException"]/*' />
    [Serializable]
    public class DataException : SystemException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="DataException.DataException3"]/*' />
        protected DataException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="DataException.DataException"]/*' />
        public DataException()
        : base() {
            HResult = HResults.Data;
        }

        /// <include file='doc\DataException.uex' path='docs/doc[@for="DataException.DataException1"]/*' />
        public DataException(string s)
        : base(s) {
            HResult = HResults.Data;
        }

        /// <include file='doc\DataException.uex' path='docs/doc[@for="DataException.DataException2"]/*' />
        public DataException(string s, Exception innerException)
        : base(s, innerException) {
        }

    };

    /// <include file='doc\DataException.uex' path='docs/doc[@for="ConstraintException"]/*' />
    [Serializable]
    public class ConstraintException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="ConstraintException.ConstraintException2"]/*' />
        protected ConstraintException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="ConstraintException.ConstraintException"]/*' />
        public ConstraintException()         : base() {
            HResult = HResults.DataConstraint;
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="ConstraintException.ConstraintException1"]/*' />
        public ConstraintException(string s) : base(s) {
            HResult = HResults.DataConstraint;
        }
    }

    /// <include file='doc\DataException.uex' path='docs/doc[@for="DeletedRowInaccessibleException"]/*' />
    [Serializable]
    public class DeletedRowInaccessibleException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="DeletedRowInaccessibleException.DeletedRowInaccessibleException2"]/*' />
        protected DeletedRowInaccessibleException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="DeletedRowInaccessibleException.DeletedRowInaccessibleException"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.DeletedRowInaccessibleException'/> class.
        ///    </para>
        /// </devdoc>
        public DeletedRowInaccessibleException() : base() {
            HResult = HResults.DataDeletedRowInaccessible;
        }

        /// <include file='doc\DataException.uex' path='docs/doc[@for="DeletedRowInaccessibleException.DeletedRowInaccessibleException1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.DeletedRowInaccessibleException'/> class with the specified string.
        ///    </para>
        /// </devdoc>
        public DeletedRowInaccessibleException(string s) : base(s) {
            HResult = HResults.DataDeletedRowInaccessible;
        }
    }

    /// <include file='doc\DataException.uex' path='docs/doc[@for="DuplicateNameException"]/*' />
    [Serializable]
    public class DuplicateNameException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="DuplicateNameException.DuplicateNameException2"]/*' />
        protected DuplicateNameException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="DuplicateNameException.DuplicateNameException"]/*' />
        public DuplicateNameException() : base() {
            HResult = HResults.DataDuplicateName;
        }
        
        /// <include file='doc\DataException.uex' path='docs/doc[@for="DuplicateNameException.DuplicateNameException1"]/*' />
        public DuplicateNameException(string s) : base(s) {
            HResult = HResults.DataDuplicateName;
        }
    }

    /// <include file='doc\DataException.uex' path='docs/doc[@for="InRowChangingEventException"]/*' />
    [Serializable]
    public class InRowChangingEventException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="InRowChangingEventException.InRowChangingEventException2"]/*' />
        protected InRowChangingEventException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="InRowChangingEventException.InRowChangingEventException"]/*' />
        public InRowChangingEventException() : base() {
            HResult = HResults.DataInRowChangingEvent;
        }
        
        /// <include file='doc\DataException.uex' path='docs/doc[@for="InRowChangingEventException.InRowChangingEventException1"]/*' />
        public InRowChangingEventException(string s) : base(s) {
            HResult = HResults.DataInRowChangingEvent;
        }
    }

    /// <include file='doc\DataException.uex' path='docs/doc[@for="InvalidConstraintException"]/*' />
    [Serializable]
    public class InvalidConstraintException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="InvalidConstraintException.InvalidConstraintException2"]/*' />
        protected InvalidConstraintException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="InvalidConstraintException.InvalidConstraintException"]/*' />
        public InvalidConstraintException() : base() {
            HResult = HResults.DataInvalidConstraint;
        }
        
        /// <include file='doc\DataException.uex' path='docs/doc[@for="InvalidConstraintException.InvalidConstraintException1"]/*' />
        public InvalidConstraintException(string s) : base(s) {
            HResult = HResults.DataInvalidConstraint;
        }
    }

    /// <include file='doc\DataException.uex' path='docs/doc[@for="MissingPrimaryKeyException"]/*' />
    [Serializable]
    public class MissingPrimaryKeyException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="MissingPrimaryKeyException.MissingPrimaryKeyException2"]/*' />
        protected MissingPrimaryKeyException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="MissingPrimaryKeyException.MissingPrimaryKeyException"]/*' />
        public MissingPrimaryKeyException() : base() {
            HResult = HResults.DataMissingPrimaryKey;
        }
        
        /// <include file='doc\DataException.uex' path='docs/doc[@for="MissingPrimaryKeyException.MissingPrimaryKeyException1"]/*' />
        public MissingPrimaryKeyException(string s) : base(s) {
            HResult = HResults.DataMissingPrimaryKey;
        }
    }

    /// <include file='doc\DataException.uex' path='docs/doc[@for="NoNullAllowedException"]/*' />
    [Serializable]
    public class NoNullAllowedException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="NoNullAllowedException.NoNullAllowedException2"]/*' />
        protected NoNullAllowedException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="NoNullAllowedException.NoNullAllowedException"]/*' />
        public NoNullAllowedException() : base() {
            HResult = HResults.DataNoNullAllowed;
        }
        
        /// <include file='doc\DataException.uex' path='docs/doc[@for="NoNullAllowedException.NoNullAllowedException1"]/*' />
        public NoNullAllowedException(string s) : base(s) {
            HResult = HResults.DataNoNullAllowed;
        }
    }

    /// <include file='doc\DataException.uex' path='docs/doc[@for="ReadOnlyException"]/*' />
    [Serializable]
    public class ReadOnlyException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="ReadOnlyException.ReadOnlyException2"]/*' />
        protected ReadOnlyException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="ReadOnlyException.ReadOnlyException"]/*' />
        public ReadOnlyException() : base() {
            HResult = HResults.DataReadOnly;
        }
        
        /// <include file='doc\DataException.uex' path='docs/doc[@for="ReadOnlyException.ReadOnlyException1"]/*' />
        public ReadOnlyException(string s) : base(s) {
            HResult = HResults.DataReadOnly;
        }
    }

    /// <include file='doc\DataException.uex' path='docs/doc[@for="RowNotInTableException"]/*' />
    [Serializable]
    public class RowNotInTableException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="RowNotInTableException.RowNotInTableException2"]/*' />
        protected RowNotInTableException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="RowNotInTableException.RowNotInTableException"]/*' />
        public RowNotInTableException() : base() { 
            HResult = HResults.DataRowNotInTable;
        }
        
        /// <include file='doc\DataException.uex' path='docs/doc[@for="RowNotInTableException.RowNotInTableException1"]/*' />
        public RowNotInTableException(string s) : base(s) {
            HResult = HResults.DataRowNotInTable;
        }
    }

    /// <include file='doc\DataException.uex' path='docs/doc[@for="VersionNotFoundException"]/*' />
    [Serializable]
    public class VersionNotFoundException : DataException {
        /// <include file='doc\DataException.uex' path='docs/doc[@for="VersionNotFoundException.VersionNotFoundException2"]/*' />
        protected VersionNotFoundException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\DataException.uex' path='docs/doc[@for="VersionNotFoundException.VersionNotFoundException"]/*' />
        public VersionNotFoundException() : base() {
            HResult = HResults.DataVersionNotFound;
        }
        
        /// <include file='doc\DataException.uex' path='docs/doc[@for="VersionNotFoundException.VersionNotFoundException1"]/*' />
        public VersionNotFoundException(string s) : base(s) {
            HResult = HResults.DataVersionNotFound;
        }
    }

    internal class ExceptionBuilder {
        // The class defines the exceptions that are specific to the DataSet.
        // The class contains functions that take the proper informational variables and then construct
        // the appropriate exception with an error string obtained from the resource Data.txt.
        // The exception is then returned to the caller, so that the caller may then throw from its
        // location so that the catcher of the exception will have the appropriate call stack.
        // This class is used so that there will be compile time checking of error messages.
        // The resource Data.txt will ensure proper string text based on the appropriate
        // locale.

        static internal Exception Trace(Exception e) {
#if DEBUG
            if (System.Data.Common.AdapterSwitches.DataError.TraceError) {
                Debug.WriteLine(e.ToString());

                if (System.Data.Common.AdapterSwitches.DataError.TraceVerbose) {
                    Debug.WriteLine(Environment.StackTrace);
                }
            }
#endif
            return e;
        }

        //
        // COM+ exceptions
        //
        static protected Exception _Argument(string error) {
            return Trace(new ArgumentException(error));
        }
        static protected Exception _ArgumentNull(string arg, string msg) {
            return Trace(new ArgumentNullException(arg, msg));
        }
        static protected Exception _ArgumentOutOfRange(string arg, string msg) {
            return Trace(new ArgumentOutOfRangeException(arg, msg));
        }
        static protected Exception _IndexOutOfRange(string error) {
            return Trace(new IndexOutOfRangeException(error));
        }
        static protected Exception _InvalidOperation(string error) {
            return Trace(new InvalidOperationException(error));
        }

        //
        // System.Data exceptions
        //
        static protected Exception _Data(string error) {
            return Trace(new DataException(error));
        }
        static protected Exception _Constraint(string error) {
            return Trace(new ConstraintException(error));
        }
        static protected Exception _InvalidConstraint(string error) {
            return Trace(new InvalidConstraintException(error));
        }
        static protected Exception _DeletedRowInaccessible(string error) {
            return Trace(new DeletedRowInaccessibleException(error));
        }
        static protected Exception _DuplicateName(string error) {
            return Trace(new DuplicateNameException(error));
        }
        static protected Exception _InRowChangingEvent(string error) {
            return Trace(new InRowChangingEventException(error));
        }
        static protected Exception _MissingPrimaryKey(string error) {
            return Trace(new MissingPrimaryKeyException(error));
        }
        static protected Exception _NoNullAllowed(string error) {
            return Trace(new NoNullAllowedException(error));
        }
        static protected Exception _ReadOnly(string error) {
            return Trace(new ReadOnlyException(error));
        }
        static protected Exception _RowNotInTable(string error) {
            return Trace(new RowNotInTableException(error));
        }
        static protected Exception _VersionNotFound(string error) {
            return Trace(new VersionNotFoundException(error));
        }

           
        // Consider: whether we need to keep our own texts from Data_ArgumentNull and Data_ArgumentOutOfRange?
        // Unfortunately ours and the system ones are not consisten between each other. Try to raise this isue in "URT user comunity"
        static public Exception ArgumentNull(string arg) {
            return _ArgumentNull(arg, Res.GetString(Res.Data_ArgumentNull, arg));
        }
        static public Exception ArgumentOutOfRange(string arg) {
            return _ArgumentOutOfRange(arg, Res.GetString(Res.Data_ArgumentOutOfRange, arg));
        }
        static public Exception BadObjectPropertyAccess(string error) {
            return _InvalidOperation(Res.GetString(Res.DataConstraint_BadObjectPropertyAccess, error));
        }

        //
        // Collections
        //

        static public Exception CannotModifyCollection() {
            return _Argument(Res.GetString(Res.Data_CannotModifyCollection));
        }
        static public Exception CaseInsensitiveNameConflict(string name) {
            return _Argument(Res.GetString(Res.Data_CaseInsensitiveNameConflict, name));
        }

        //
        // DataColumnCollection
        //

        static public Exception ColumnNotInTheTable(string column, string table) {
            return _Argument(Res.GetString(Res.DataColumn_NotInTheTable, column, table));
        }

        static public Exception ColumnNotInAnyTable() {
            return _Argument(Res.GetString(Res.DataColumn_NotInAnyTable));
        }

        static public Exception ColumnOutOfRange(int index) {
            return _IndexOutOfRange(Res.GetString(Res.DataColumns_OutOfRange, (index).ToString()));
        }
        static public Exception ColumnOutOfRange(string column) {
            return _IndexOutOfRange(Res.GetString(Res.DataColumns_OutOfRange, column));
        }

        static public Exception CannotAddColumn1(string column) {
            return _Argument(Res.GetString(Res.DataColumns_Add1, column));
        }

        static public Exception CannotAddColumn2(string column) {
            return _Argument(Res.GetString(Res.DataColumns_Add2, column));
        }
        
        static public Exception CannotAddColumn3() {
            return _Argument(Res.GetString(Res.DataColumns_Add3));
        }

        static public Exception CannotAddColumn4(string column) {
            return _Argument(Res.GetString(Res.DataColumns_Add4, column));
        }

        static public Exception CannotAddDuplicate(string column) {
            return _DuplicateName(Res.GetString(Res.DataColumns_AddDuplicate, column));
        }

        static public Exception CannotAddDuplicate2(string table) {
            return _DuplicateName(Res.GetString(Res.DataColumns_AddDuplicate2, table));
        }

        static public Exception CannotAddDuplicate3(string table) {
            return _DuplicateName(Res.GetString(Res.DataColumns_AddDuplicate3, table));
        }

        static public Exception CannotRemoveColumn() {
            return _Argument(Res.GetString(Res.DataColumns_Remove));
        }

        static public Exception CannotRemovePrimaryKey() {
            return _Argument(Res.GetString(Res.DataColumns_RemovePrimaryKey));
        }

        static public Exception CannotRemoveChildKey(string relation) {
            return _Argument(Res.GetString(Res.DataColumns_RemoveChildKey, relation));
        }

        static public Exception CannotRemoveConstraint(string constraint, string table) {
            return _Argument(Res.GetString(Res.DataColumns_RemoveConstraint, constraint, table));
        }

        static public Exception CannotRemoveExpression(string column, string expression) {
            return _Argument(Res.GetString(Res.DataColumns_RemoveExpression, column, expression));
        }

        //
        // _Constraint and ConstrainsCollection
        //

        static public Exception AddPrimaryKeyConstraint() {
            return _Argument(Res.GetString(Res.DataConstraint_AddPrimaryKeyConstraint));
        }

        static public Exception NoConstraintName() {
            return _Argument(Res.GetString(Res.DataConstraint_NoName));
        }

        static public Exception ConstraintViolation(string constraint) {
            return _Constraint(Res.GetString(Res.DataConstraint_Violation, constraint));
        }

        static public Exception ConstraintNotInTheTable(string constraint) {
            return _Argument(Res.GetString(Res.DataConstraint_NotInTheTable,constraint));
        }

        static public string KeysToString(object[] keys) {
            string values = String.Empty;
            for (int i = 0; i < keys.Length; i++) {
                values += Convert.ToString(keys[i]) + (i < keys.Length - 1 ? ", " : String.Empty);
            }
            return values;
        }
        static public string UniqueConstraintViolationText(DataColumn[] columns, object[] values) {
            if (columns.Length > 1) {
                string columnNames = String.Empty;
                for (int i = 0; i < columns.Length; i++) {
                    columnNames += columns[i].ColumnName + (i < columns.Length - 1 ? ", " : "");
                }
                return Res.GetString(Res.DataConstraint_ViolationValue, columnNames, KeysToString(values));
            }
            else {
                return Res.GetString(Res.DataConstraint_ViolationValue, columns[0].ColumnName, Convert.ToString(values[0]));
            }
        }
        static public Exception ConstraintViolation(DataColumn[] columns, object[] values) {
            return _Constraint(UniqueConstraintViolationText(columns, values));
        }

        static public Exception ConstraintOutOfRange(int index) {
            return _IndexOutOfRange(Res.GetString(Res.DataConstraint_OutOfRange, (index).ToString()));
        }

        static public Exception ConstraintOutOfRange(string constraint) {
            return _IndexOutOfRange(Res.GetString(Res.DataConstraint_OutOfRange, constraint));
        }

        static public Exception DuplicateConstraint(string constraint) {
            return _Data(Res.GetString(Res.DataConstraint_Duplicate, constraint));
        }

        static public Exception DuplicateConstraintName(string constraint) {
            return _DuplicateName(Res.GetString(Res.DataConstraint_DuplicateName, constraint));
        }

        static public Exception NeededForForeignKeyConstraint(UniqueConstraint key, ForeignKeyConstraint fk) {
            return _Argument(Res.GetString(Res.DataConstraint_NeededForForeignKeyConstraint, key.ConstraintName, fk.ConstraintName));
        }

        static public Exception UniqueConstraintViolation() {
            return _Argument(Res.GetString(Res.DataConstraint_UniqueViolation));
        }

        static public Exception ConstraintForeignTable() {
            return _Argument(Res.GetString(Res.DataConstraint_ForeignTable));
        }

        static public Exception ConstraintParentValues() {
            return _Argument(Res.GetString(Res.DataConstraint_ParentValues));
        }

        static public Exception ConstraintAddFailed(DataTable table) {
            return _InvalidConstraint(Res.GetString(Res.DataConstraint_AddFailed, table.TableName));
        }

        static public Exception ConstraintRemoveFailed() {
            return _Argument(Res.GetString(Res.DataConstraint_RemoveFailed));
        }

        static public Exception FailedCascadeDelete(string constraint) {
            return _InvalidConstraint(Res.GetString(Res.DataConstraint_CascadeDelete, constraint));
        }

        static public Exception FailedCascadeUpdate(string constraint) {
            return _InvalidConstraint(Res.GetString(Res.DataConstraint_CascadeUpdate, constraint));
        }

        static public Exception FailedClearParentTable(string table, string constraint, string childTable) {
            return _InvalidConstraint(Res.GetString(Res.DataConstraint_ClearParentTable, table, constraint, childTable));
        }

        static public Exception ForeignKeyViolation(string constraint, object[] keys) {
            return _InvalidConstraint(Res.GetString(Res.DataConstraint_ForeignKeyViolation, constraint, KeysToString(keys)));
        }

        static public Exception RemoveParentRow(ForeignKeyConstraint constraint) {
            return _InvalidConstraint(Res.GetString(Res.DataConstraint_RemoveParentRow, constraint.ConstraintName));
        }
        
        static public string MaxLengthViolationText(string  columnName) {
            return Res.GetString(Res.DataColumn_ExceedMaxLength, columnName);
        }
        static public string NotAllowDBNullViolationText(string  columnName) {
            return Res.GetString(Res.DataColumn_NotAllowDBNull, columnName);
        }


        //
        // DataColumn Set Properties conflicts
        //

        static public Exception AutoIncrementAndExpression() {
            return _Argument(Res.GetString(Res.DataColumn_AutoIncrementAndExpression));
        }
        static public Exception AutoIncrementAndDefaultValue() {
            return _Argument(Res.GetString(Res.DataColumn_AutoIncrementAndDefaultValue));
        }
        static public Exception AutoIncrementDataType() {
            return _Argument(Res.GetString(Res.DataColumn_AutoIncrementDataType));
        }
        static public Exception AutoIncrementSeed() {
            return _Argument(Res.GetString(Res.DataColumn_AutoIncrementSeed));
        }
        static public Exception CantChangeDataType() {
            return _Argument(Res.GetString(Res.DataColumn_ChangeDataType));
        }
        static public Exception NullDataType() {
            return _Argument(Res.GetString(Res.DataColumn_NullDataType));
        }
        static public Exception ColumnNameRequired() {
            return _Argument(Res.GetString(Res.DataColumn_NameRequired));
        }
        static public Exception DefaultValueAndAutoIncrement() {
            return _Argument(Res.GetString(Res.DataColumn_DefaultValueAndAutoIncrement));
        }
        static public Exception DefaultValueDataType(string column, Type defaultType, Type columnType) {
            if (column.Length == 0) {
                return _Argument(Res.GetString(Res.DataColumn_DefaultValueDataType1, defaultType.FullName, columnType.FullName));
            }
            else {
                return _Argument(Res.GetString(Res.DataColumn_DefaultValueDataType, column, defaultType.FullName, columnType.FullName));
            }
        }
        static public Exception DefaultValueColumnDataType(string column, Type defaultType, Type columnType) {
            return _Argument(Res.GetString(Res.DataColumn_DefaultValueColumnDataType, column, defaultType.FullName, columnType.FullName));
        }

        static public Exception ExpressionAndUnique() {
            return _Argument(Res.GetString(Res.DataColumn_ExpressionAndUnique));
        }
        static public Exception ExpressionAndReadOnly() {
            return _Argument(Res.GetString(Res.DataColumn_ExpressionAndReadOnly));
        }

        static public Exception ExpressionAndConstraint(DataColumn column, Constraint constraint) {
            return _Argument(Res.GetString(Res.DataColumn_ExpressionAndConstraint, column.ColumnName, constraint.ConstraintName));
        }

        static public Exception ExpressionInConstraint(DataColumn column) {
            return _Argument(Res.GetString(Res.DataColumn_ExpressionInConstraint, column.ColumnName));
        }

        static public Exception ExpressionCircular() {
            return _Argument(Res.GetString(Res.DataColumn_ExpressionCircular));
        }

        static public Exception NonUniqueValues(string column) {
            return _InvalidConstraint(Res.GetString(Res.DataColumn_NonUniqueValues, column));
        }

        static public Exception NullKeyValues(string column) {
            return _Data(Res.GetString(Res.DataColumn_NullKeyValues, column));
        }
        static public Exception NullValues(string column) {
            return _NoNullAllowed(Res.GetString(Res.DataColumn_NullValues, column));
        }

        static public Exception ReadOnlyAndExpression() {
            return _ReadOnly(Res.GetString(Res.DataColumn_ReadOnlyAndExpression));
        }

        static public Exception ReadOnly(string column) {
            return _ReadOnly(Res.GetString(Res.DataColumn_ReadOnly, column));
        }

        static public Exception StorageChange() {
            return _Argument(Res.GetString(Res.DataColumn_StorageChange));
        }
        static public Exception SetForeignStorage() {
            return _Argument(Res.GetString(Res.DataColumn_SetForeignStorage));
        }

        static public Exception UniqueAndExpression() {
            return _Argument(Res.GetString(Res.DataColumn_UniqueAndExpression));
        }

        static public Exception SetFailed(object value, DataColumn column, Type type, string errorString) {
            return _Argument(errorString + Res.GetString(Res.DataColumn_SetFailed, value.ToString(), column.ColumnName, type.Name));
        }
        
        static public Exception CannotSetToNull(DataColumn column) {
            return _Argument(Res.GetString(Res.DataColumn_CannotSetToNull, column.ColumnName));
        }

        static public Exception LongerThanMaxLength(DataColumn column, string value) {
            return _Argument(Res.GetString(Res.DataColumn_LongerThanMaxLength, column.ColumnName, value));
        }
        
        static public Exception CannotSetMaxLength(DataColumn column, string value) {
            return _Argument(Res.GetString(Res.DataColumn_CannotSetMaxLength, column.ColumnName, value));
        }
        
        static public Exception CannotSetMaxLength2(DataColumn column) {
            return _Argument(Res.GetString(Res.DataColumn_CannotSetMaxLength2, column.ColumnName));
        }
        
        static public Exception CannotSetSimpleContentType(String columnName, Type type) {
            return _Argument(Res.GetString(Res.DataColumn_CannotSimpleContentType, columnName, type));
        }

        static public Exception CannotSetSimpleContent(String columnName, Type type) {
            return _Argument(Res.GetString(Res.DataColumn_CannotSimpleContent, columnName, type));
        }

        static public Exception CannotChangeNamespace(String columnName) {
            return _Argument(Res.GetString(Res.DataColumn_CannotChangeNamespace, columnName));
        }

        static public Exception HasToBeStringType(DataColumn column) {
            return _Argument(Res.GetString(Res.DataColumn_HasToBeStringType, column.ColumnName));
        }

        //
        // DataView
        //

        static public Exception SetFailed(string name) {
            return _Data(Res.GetString(Res.DataView_SetFailed, name));
        }

        static public Exception SetDataSetFailed() {
            return _Data(Res.GetString(Res.DataView_SetDataSetFailed));
        }

        static public Exception SetRowStateFilter() {
            return _Data(Res.GetString(Res.DataView_SetRowStateFilter));
        }

        static public Exception CanNotSetDataSet() {
            return _Data(Res.GetString(Res.DataView_CanNotSetDataSet));
        }

        static public Exception CanNotUseDataViewManager() {
            return _Data(Res.GetString(Res.DataView_CanNotUseDataViewManager));
        }

        static public Exception CanNotSetTable() {
            return _Data(Res.GetString(Res.DataView_CanNotSetTable));
        }

        static public Exception CanNotUse() {
            return _Data(Res.GetString(Res.DataView_CanNotUse));
        }

        static public Exception CanNotBindTable() {
            return _Data(Res.GetString(Res.DataView_CanNotBindTable));
        }

        static public Exception SetTable() {
            return _Data(Res.GetString(Res.DataView_SetTable));
        }

        static public Exception SetIListObject() {
            return _Argument(Res.GetString(Res.DataView_SetIListObject));
        }

        static public Exception AddNewNotAllowNull() {
            return _Data(Res.GetString(Res.DataView_AddNewNotAllowNull));
        }

        static public Exception AddNewAddNew() {
            return _Data(Res.GetString(Res.DataView_AddNewAddNew));
        }

        static public Exception NotOpen() {
            return _Data(Res.GetString(Res.DataView_NotOpen));
        }

        static public Exception CreateChildView() {
            return _Argument(Res.GetString(Res.DataView_CreateChildView));
        }

        static public Exception CanNotDelete() {
            return _Data(Res.GetString(Res.DataView_CanNotDelete));
        }

        static public Exception CanNotEdit() {
            return _Data(Res.GetString(Res.DataView_CanNotEdit));
        }

        static public Exception GetElementIndex(Int32 index) {
            return _IndexOutOfRange(Res.GetString(Res.DataView_GetElementIndex, (index).ToString()));
        }

        static public Exception AddExternalObject() {
            return _Argument(Res.GetString(Res.DataView_AddExternalObject));
        }

        static public Exception CanNotClear() {
            return _Argument(Res.GetString(Res.DataView_CanNotClear));
        }

        static public Exception InsertExternalObject() {
            return _Argument(Res.GetString(Res.DataView_InsertExternalObject));
        }

        static public Exception RemoveExternalObject() {
            return _Argument(Res.GetString(Res.DataView_RemoveExternalObject));
        }

        static public Exception PropertyNotFound(string property, string table) {
            return _Argument(Res.GetString(Res.DataROWView_PropertyNotFound, property, table));
        }

        //
        // Keys
        //

        static public Exception KeyTableMismatch() {
            return _InvalidConstraint(Res.GetString(Res.DataKey_TableMismatch));
        }

        static public Exception KeyNoColumns() {
            return _InvalidConstraint(Res.GetString(Res.DataKey_NoColumns));
        }

        static public Exception KeyTooManyColumns(int cols) {
            return _InvalidConstraint(Res.GetString(Res.DataKey_TooManyColumns, (cols).ToString()));
        }

        static public Exception KeyDuplicateColumns(string columnName) {
            return _InvalidConstraint(Res.GetString(Res.DataKey_DuplicateColumns, columnName));
        }

        static public Exception KeySortLength() {
            return _InvalidConstraint(Res.GetString(Res.DataKey_SortLength));
        }

        //
        // Relations, constraints
        //

        static public Exception RelationDataSetMismatch() {
            return _InvalidConstraint(Res.GetString(Res.DataRelation_DataSetMismatch));
        }

        static public Exception NoRelationName() {
            return _Argument(Res.GetString(Res.DataRelation_NoName));
        }

        static public Exception ColumnsTypeMismatch() {
            return _InvalidConstraint(Res.GetString(Res.DataRelation_ColumnsTypeMismatch));
        }

        static public Exception KeyLengthMismatch() {
            return _Argument(Res.GetString(Res.DataRelation_KeyLengthMismatch));
        }

        static public Exception KeyLengthZero() {
            return _Argument(Res.GetString(Res.DataRelation_KeyZeroLength));
        }

        static public Exception ForeignRelation() {
            return _Argument(Res.GetString(Res.DataRelation_ForeignDataSet));
        }

        static public Exception KeyColumnsIdentical() {
            return _InvalidConstraint(Res.GetString(Res.DataRelation_KeyColumnsIdentical));
        }

        static public Exception ForeignRelation(string relation) {
            return _Argument(Res.GetString(Res.DataRelation_Foreign, relation));
        }

        static public Exception RelationForeignTable(string t1, string t2) {
            return _InvalidConstraint(Res.GetString(Res.DataRelation_ForeignTable, t1, t2));
        }

        static public Exception GetParentRowTableMismatch(string t1, string t2) {
            return _InvalidConstraint(Res.GetString(Res.DataRelation_GetParentRowTableMismatch, t1, t2));
        }

        static public Exception SetParentRowTableMismatch(string t1, string t2) {
            return _InvalidConstraint(Res.GetString(Res.DataRelation_SetParentRowTableMismatch, t1, t2));
        }

        static public Exception RelationForeignRow() {
            return _Argument(Res.GetString(Res.DataRelation_ForeignRow));
        }

        static public Exception RelationNestedReadOnly() {
            return _Argument(Res.GetString(Res.DataRelation_RelationNestedReadOnly));
        }

        static public Exception TableCantBeNestedInTwoTables(string tableName) {
            return _Argument(Res.GetString(Res.DataRelation_TableCantBeNestedInTwoTables, tableName));
        }

        static public Exception LoopInNestedRelations(string tableName) {
            return _Argument(Res.GetString(Res.DataRelation_LoopInNestedRelations, tableName));
        }

        static public Exception RelationDoesNotExist() {
            return _Argument(Res.GetString(Res.DataRelation_DoesNotExist));
        }

        static public Exception ParentRowNotInTheDataSet() {
            return _Argument(Res.GetString(Res.DataRow_ParentRowNotInTheDataSet));
        }

        //
        // Rows
        //

        static public Exception RowNotInTheDataSet() {
            return _Argument(Res.GetString(Res.DataRow_NotInTheDataSet));
        }

        static public Exception RowNotInTheTable() {
            return _RowNotInTable(Res.GetString(Res.DataRow_NotInTheTable));
        }
        static public Exception ParentRowNotInTheTable() {
            return _RowNotInTable(Res.GetString(Res.DataRow_ParentNotInTheTable));
        }
        static public Exception ChildRowNotInTheTable() {
            return _RowNotInTable(Res.GetString(Res.DataRow_ChildNotInTheTable));
        }

        static public Exception EditInRowChanging() {
            return _InRowChangingEvent(Res.GetString(Res.DataRow_EditInRowChanging));
        }

        static public Exception EndEditInRowChanging() {
            return _InRowChangingEvent(Res.GetString(Res.DataRow_EndEditInRowChanging));
        }

        static public Exception BeginEditInRowChanging() {
            return _InRowChangingEvent(Res.GetString(Res.DataRow_BeginEditInRowChanging));
        }

        static public Exception CancelEditInRowChanging() {
            return _InRowChangingEvent(Res.GetString(Res.DataRow_CancelEditInRowChanging));
        }

        static public Exception DeleteInRowDeleting() {
            return _InRowChangingEvent(Res.GetString(Res.DataRow_DeleteInRowDeleting));
        }

        static public Exception ValueArrayLength() {
            return _Argument(Res.GetString(Res.DataRow_ValuesArrayLength));
        }

        static public Exception NoCurrentData() {
            return _VersionNotFound(Res.GetString(Res.DataRow_NoCurrentData));
        }

        static public Exception NoOriginalData() {
            return _VersionNotFound(Res.GetString(Res.DataRow_NoOriginalData));
        }

        static public Exception NoProposedData() {
            return _VersionNotFound(Res.GetString(Res.DataRow_NoProposedData));
        }

        static public Exception RowRemovedFromTheTable() {
            return _RowNotInTable(Res.GetString(Res.DataRow_RemovedFromTheTable));
        }

        static public Exception DeletedRowInaccessible() {
            return _DeletedRowInaccessible(Res.GetString(Res.DataRow_DeletedRowInaccessible));
        }

        static public Exception RowAlreadyDeleted() {
            return _DeletedRowInaccessible(Res.GetString(Res.DataRow_AlreadyDeleted));
        }

        static public Exception RowEmpty() {
            return _Argument(Res.GetString(Res.DataRow_Empty));
        }

        static public Exception InvalidRowVersion() {
            return _Data(Res.GetString(Res.DataRow_InvalidVersion));
        }

        static public Exception RowOutOfRange() {
            return _IndexOutOfRange(Res.GetString(Res.DataRow_RowOutOfRange));
        }
        static public Exception RowOutOfRange(int index) {
            return _IndexOutOfRange(Res.GetString(Res.DataRow_OutOfRange, (index).ToString()));
        }
        static public Exception RowInsertOutOfRange(int index) {
            return _IndexOutOfRange(Res.GetString(Res.DataRow_RowInsertOutOfRange, (index).ToString()));
        }

        static public Exception RowInsertTwice(int index, string tableName) {
            return _IndexOutOfRange(Res.GetString(Res.DataRow_RowInsertTwice, (index).ToString(), tableName));
        }

        static public Exception RowInsertMissing( string tableName) {
            return _IndexOutOfRange(Res.GetString(Res.DataRow_RowInsertMissing, tableName));
        }
        
        static public Exception RowOutOfRange(object key) {
            return _IndexOutOfRange(Res.GetString(Res.DataRow_KeyOutOfRange, Convert.ToString(key)));
        }

        static public Exception RowOutOfRange(object[] keys) {
            return _IndexOutOfRange(Res.GetString(Res.DataRow_KeysOutOfRange, KeysToString(keys)));
        }

        static public Exception RowAlreadyRemoved() {
            return _Data(Res.GetString(Res.DataRow_AlreadyRemoved));
        }

        static public Exception MultipleParents() {
            return _Data(Res.GetString(Res.DataRow_MultipleParents));
        }

        //
        // DataSet
        //
        
        static internal Exception SetDataSetNameToEmpty() {
            return _Argument(Res.GetString(Res.DataSet_SetNameToEmpty));
        }        
        static internal Exception SetDataSetNameConflicting(string name) {
            return _Argument(Res.GetString(Res.DataSet_SetDataSetNameConflicting, name));
        }
        static public Exception DataSetHasData() {
            return _Argument(Res.GetString(Res.DataSet_HasData));
        }
        static public Exception DataSetHasSchema() {
            return _Argument(Res.GetString(Res.DataSet_HasSchema));
        }
        static public Exception DataSetUnsupportedSchema(string ns) {
            return _Argument(Res.GetString(Res.DataSet_UnsupportedSchema, ns));
        }
        static public Exception MergeMissingDefinition(string obj) {
            return _Argument(Res.GetString(Res.DataMerge_MissingDefinition, obj));
        }
        static public Exception TablesInDifferentSets() {
            return _Argument(Res.GetString(Res.DataRelation_TablesInDifferentSets));
        }
        static public Exception RelationAlreadyExists() {
            return _Argument(Res.GetString(Res.DataRelation_AlreadyExists));
        }
        static public Exception RowAlreadyInOtherCollection() {
            return _Argument(Res.GetString(Res.DataRow_AlreadyInOtherCollection));
        }
        static public Exception RowAlreadyInTheCollection() {
            return _Argument(Res.GetString(Res.DataRow_AlreadyInTheCollection));
        }
        static public Exception ModifyingRow() {
            return _Argument(Res.GetString(Res.DataRow_Modifying));
        }
        static public Exception TableMissingPrimaryKey() {
            return _MissingPrimaryKey(Res.GetString(Res.DataTable_MissingPrimaryKey));
        }
        static public Exception RecordStateRange() {
            return _Argument(Res.GetString(Res.DataIndex_RecordStateRange));
        }
        static public Exception IndexKeyLength(int length, int keyLength) {
            if(length == 0) {
                return _Argument(Res.GetString(Res.DataIndex_FindWithoutSortOrder));
            }
            else {
                return _Argument(Res.GetString(Res.DataIndex_KeyLength, (length).ToString(), (keyLength).ToString()));
            }
        }

        static public Exception RemovePrimaryKey(DataTable table) {
            if (table.TableName.Length == 0) {
                return _Argument(Res.GetString(Res.DataKey_RemovePrimaryKey));
            }
            else {
                return _Argument(Res.GetString(Res.DataKey_RemovePrimaryKey1, table.TableName));
            }
        }
        static public Exception RelationAlreadyInOtherDataSet() {
            return _Argument(Res.GetString(Res.DataRelation_AlreadyInOtherDataSet));
        }
        static public Exception RelationAlreadyInTheDataSet() {
            return _Argument(Res.GetString(Res.DataRelation_AlreadyInTheDataSet));
        }
        static public Exception RelationNotInTheDataSet(string relation) {
            return _Argument(Res.GetString(Res.DataRelation_NotInTheDataSet,relation));
        }
        static public Exception RelationOutOfRange(object index) {
            return _IndexOutOfRange(Res.GetString(Res.DataRelation_OutOfRange, Convert.ToString(index)));
        }
        static public Exception DuplicateRelation(string relation) {
            return _DuplicateName(Res.GetString(Res.DataRelation_DuplicateName, relation));
        }
        static public Exception RelationTableNull() {
            return _Argument(Res.GetString(Res.DataRelation_TableNull));
        }
        static public Exception RelationDataSetNull() {
            return _Argument(Res.GetString(Res.DataRelation_TableNull));
        }
        static public Exception RelationTableWasRemoved() {
            return _Argument(Res.GetString(Res.DataRelation_TableWasRemoved));
        }
        static public Exception ParentTableMismatch() {
            return _Argument(Res.GetString(Res.DataRelation_ParentTableMismatch));
        }
        static public Exception ChildTableMismatch() {
            return _Argument(Res.GetString(Res.DataRelation_ChildTableMismatch));
        }
        static public Exception EnforceConstraint() {
            return _Constraint(Res.GetString(Res.Data_EnforceConstraints));
        }
        static public Exception CaseLocaleMismatch() {
            return _Argument(Res.GetString(Res.DataRelation_CaseLocaleMismatch));
        }
        static public Exception CannotChangeCaseLocale() {
            return _Argument(Res.GetString(Res.DataSet_CannotChangeCaseLocale));
        }

        //
        // DataTable and DataTableCollection
        //
        static public Exception TableForeignPrimaryKey() {
            return _Argument(Res.GetString(Res.DataTable_ForeignPrimaryKey));
        }
        static public Exception TableCannotAddToSimpleContent() {
            return _Argument(Res.GetString(Res.DataTable_CannotAddToSimpleContent));
        }
        static public Exception NoTableName() {
            return _Argument(Res.GetString(Res.DataTable_NoName));
        }
        static public Exception MultipleTextOnlyColumns() {
            return _Argument(Res.GetString(Res.DataTable_MultipleSimpleContentColumns));
        }
        static public Exception InvalidSortString(string sort) {
            return _Argument(Res.GetString(Res.DataTable_InvalidSortString, sort));
        }
        static public Exception DuplicateTableName(string table) {
            return _DuplicateName(Res.GetString(Res.DataTable_DuplicateName, table));
        }
        static public Exception SelfnestedDatasetConflictingName(string table) {
            return _DuplicateName(Res.GetString(Res.DataTable_SelfnestedDatasetConflictingName, table));
        }
        static public Exception DatasetConflictingName(string table) {
            return _DuplicateName(Res.GetString(Res.DataTable_DatasetConflictingName, table));
        }
        static public Exception TableAlreadyInOtherDataSet() {
            return _Argument(Res.GetString(Res.DataTable_AlreadyInOtherDataSet));
        }
        static public Exception TableAlreadyInTheDataSet() {
            return _Argument(Res.GetString(Res.DataTable_AlreadyInTheDataSet));
        }
        static public Exception TableOutOfRange(int index) {
            return _IndexOutOfRange(Res.GetString(Res.DataTable_OutOfRange, (index).ToString()));
        }
        static public Exception TableOutOfRange(string name) {
            return _IndexOutOfRange(Res.GetString(Res.DataTable_OutOfRange, name));
        }
        static public Exception TableNotInTheDataSet(string table) {
            return _Argument(Res.GetString(Res.DataTable_NotInTheDataSet, table));
        }
        static public Exception TableInRelation() {
            return _Argument(Res.GetString(Res.DataTable_InRelation));
        }
        static public Exception TableInConstraint(DataTable table, Constraint constraint) {
            return _Argument(Res.GetString(Res.DataTable_InConstraint, table.TableName, constraint.ConstraintName));
        }
        static public Exception CaseHasToBeTheSame() {
            return _Argument(Res.GetString(Res.DataTable_CaseHasToBeTheSame));
        }
        static public Exception LocaleHasToBeTheSame() {
            return _Argument(Res.GetString(Res.DataTable_LocaleHasToBeTheSame));
        }

        //
        // Storage
        //
        static public Exception AggregateException(string aggregateType, Type type) {
            return _Data(Res.GetString(Res.DataStorage_AggregateException, aggregateType, type.Name));
        }
        static public Exception InvalidStorageType(TypeCode typecode) {
            return _Data(Res.GetString(Res.DataStorage_InvalidStorageType, ((Enum) typecode).ToString()));
        }

        static public Exception NewRecord(Type type) {
            return _Data(Res.GetString(Res.ObjectStoreTable_NewRecord, type.Name));
        }

        static public Exception RangeArgument(Int32 min, Int32 max) {
            return _Argument(Res.GetString(Res.Range_Argument, (min).ToString(), (max).ToString()));
        }
        static public Exception NullRange() {
            return _Data(Res.GetString(Res.Range_NullRange));
        }
        static public Exception NegativeMinimumCapacity() {
            return _Argument(Res.GetString(Res.RecordManager_MinimumCapacity));
        }
        static public Exception ProblematicChars(string charValue) {
            return _Argument(Res.GetString(Res.DataStorage_ProblematicChars, charValue));
        }

        //
        // XML schema
        //
        static public Exception SimpleTypeNotSupported() {
            return _Data(Res.GetString(Res.Xml_SimpleTypeNotSupported));
        }

        static public Exception MissingSchema() {
            return _Data(Res.GetString(Res.Xml_MissingSchema));
        }

        static public Exception MissingRestriction(String nodeName) {
            return _Data(Res.GetString("Xml_MissingRestriction", nodeName));
        }

        static public Exception MissingAttribute(string attribute) {
            return MissingAttribute(String.Empty, attribute);
        }

        static public Exception MissingAttribute(string element, string attribute) {
            return _Data(Res.GetString(Res.Xml_MissingAttribute, element, attribute));
        }

        static public Exception MissingAttributeValue(string name) {
            return _Data(Res.GetString(Res.Xml_MissingAttributeValue, name));
        }

        static public Exception ValueOutOfRange(string attribute, string value) {
            return _Data(Res.GetString(Res.Xml_ValueOutOfRange, attribute, value));
        }

        static public Exception ValueOutOfRange(string element, string attribute, string value) {
            return _Data(Res.GetString(Res.Xml_ElementValueOutOfRange, element, attribute, value));
        }

        static public Exception InvalidAttributeValue(string name, string value) {
            return _Data(Res.GetString(Res.Xml_ValueOutOfRange, name, value));
        }

        static public Exception InvalidAttributeValue(string name, string attribute, string value) {
            return _Data(Res.GetString(Res.Xml_ElementValueOutOfRange, name, attribute, value));
        }

        static public Exception AttributeValues(string name, string value1, string value2) {
            return _Data(Res.GetString(Res.Xml_AttributeValues, name, value1, value2));
        }

        static public Exception AttributeValue(string name, string attr, string value) {
            return _Data(Res.GetString(Res.Xml_AttributeValue, name, attr, value));
        }

        static public Exception ElementTypeNotFound(string name) {
            return _Data(Res.GetString(Res.Xml_ElementTypeNotFound, name));
        }

        static public Exception RelationParentNameMissing(string rel) {
            return _Data(Res.GetString(Res.Xml_RelationParentNameMissing, rel));
        }

        static public Exception RelationChildNameMissing(string rel) {
            return _Data(Res.GetString(Res.Xml_RelationChildNameMissing, rel));
        }

        static public Exception RelationTableKeyMissing(string rel) {
            return _Data(Res.GetString(Res.Xml_RelationTableKeyMissing, rel));
        }

        static public Exception RelationChildKeyMissing(string rel) {
            return _Data(Res.GetString(Res.Xml_RelationChildKeyMissing, rel));
        }

        static public Exception UndefinedDatatype(string name) {
            return _Data(Res.GetString(Res.Xml_UndefinedDatatype, name));
        }

        static public Exception DatatypeNotDefined() {
            return _Data(Res.GetString(Res.Xml_DatatypeNotDefined));
        }

        static public Exception MismatchKeyLength() {
            return _Data(Res.GetString(Res.Xml_MismatchKeyLength));
        }

        static public Exception InvalidField(string name) {
            return _Data(Res.GetString(Res.Xml_InvalidField, name));
        }

        static public Exception InvalidSelector(string name) {
            return _Data(Res.GetString(Res.Xml_InvalidSelector, name));
        }

        static public Exception CircularComplexType(string name) {
            return _Data(Res.GetString(Res.Xml_CircularComplexType, name));
        }

        static public Exception InvalidKey(string name) {
            return _Data(Res.GetString(Res.Xml_InvalidKey, name));
        }

        static public Exception DiffgramMissingTable(string name) {
            return _Data(Res.GetString(Res.Xml_MissingTable, name));
        }

        static public Exception DiffgramMismatchedSQL(string name1, string name2) {
            return _Data(Res.GetString(Res.Xml_MismatchedSQL, name1, name2));
        }

        static public Exception DiffgramMismatchedSQLID() {
            return _Data(Res.GetString(Res.Xml_MismatchedSQLID));
        }

        static public Exception DiffgramMissingSQL() {
            return _Data(Res.GetString(Res.Xml_MissingSQL));
        }

        static public Exception DuplicateConstraintRead(string str) {
            return _Data(Res.GetString(Res.Xml_DuplicateConstraint, str));
        }

        static public Exception ColumnTypeConflict(string name) {
            return _Data(Res.GetString(Res.Xml_ColumnConflict, name));
        }
        
        static public Exception CannotConvert(string name, string type) {
            return _Data(Res.GetString(Res.Xml_CannotConvert, name, type));
        }

        static public Exception MissingRefer(string name) {
            return _Data(Res.GetString(Res.Xml_MissingRefer, name));
        }

        static public Exception MissingRef(string name) {
            return _Data(Res.GetString(Res.Xml_MissingRef, name));
        }

        static public Exception InvalidPrefix(string name) {
            return _Data(Res.GetString(Res.Xml_InvalidPrefix, name));
        }

        static public Exception PrefixWithEmptyNS() {
            return _Data(Res.GetString(Res.Xml_PrefixWithEmptyNS));
        }
        
        // XML save
        static public Exception NestedCircular(string name) {
            return _Data(Res.GetString(Res.Xml_NestedCircular, name));
        }

        //
        // Merge
        //
        static public Exception MissingDefinition(string name) {
            return _Data(Res.GetString(Res.Xml_MergeMissingDefinition, name));
        }

        static public Exception DuplicateDeclaration(string name) {
            return _Data(Res.GetString(Res.Xml_MergeDuplicateDeclaration, name));
        }

        //Read Xml data
        static public Exception FoundEntity() {
            return _Data(Res.GetString(Res.Xml_FoundEntity));
        }

        // ATTENTION: name has to be localized string here:
        static public Exception MergeFailed(string name) {
            return _Data(name);
        }
    }// ExceptionBuilder
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarowchangeeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRowChangeEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\DataRowChangeEventHandler.uex' path='docs/doc[@for="DataRowChangeEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.Data.DataTable.RowChanging'/>, <see cref='System.Data.DataTable.RowChanged'/>, <see cref='System.Data.DataTable.RowDeleting'/>, and <see cref='System.Data.DataTable.RowDeleted'/> events of a
    /// <see cref='System.Data.DataTable'/>.</para>
    /// </devdoc>
    public delegate void DataRowChangeEventHandler(object sender, DataRowChangeEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarowcreatedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRowCreatedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\DataRowCreatedEventHandler.uex' path='docs/doc[@for="DataRowCreatedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal delegate void DataRowCreatedEventHandler(object sender, DataRow r);
    internal delegate void DataSetClearEventhandler(object sender, DataTable table);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarowchangeevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRowChangeEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;

    /// <include file='doc\DataRowChangeEvent.uex' path='docs/doc[@for="DataRowChangeEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Data.DataTable.RowChanged'/>, <see cref='System.Data.DataTable.RowChanging'/>, <see cref='System.Data.DataTable.OnRowDeleting'/>, and <see cref='System.Data.DataTable.OnRowDeleted'/> events.
    ///    </para>
    /// </devdoc>
    public class DataRowChangeEventArgs : EventArgs {

        private DataRow row;
        private DataRowAction action;

        /// <include file='doc\DataRowChangeEvent.uex' path='docs/doc[@for="DataRowChangeEventArgs.DataRowChangeEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.DataRowChangeEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public DataRowChangeEventArgs(DataRow row, DataRowAction action) {
            this.row = row;
            this.action = action;
        }

        /// <include file='doc\DataRowChangeEvent.uex' path='docs/doc[@for="DataRowChangeEventArgs.Row"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the row upon which an action has occurred.
        ///    </para>
        /// </devdoc>
        public DataRow Row {
            get {
                return row;
            }
        }

        /// <include file='doc\DataRowChangeEvent.uex' path='docs/doc[@for="DataRowChangeEventArgs.Action"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the action that has occurred on a <see cref='System.Data.DataRow'/>.
        ///    </para>
        /// </devdoc>
        public DataRowAction Action {
            get {
                return action;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarow.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRow.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Xml;
    using System.Diagnostics;
    using System.ComponentModel;

    /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow"]/*' />
    /// <devdoc>
    /// <para>Represents a row of data in a <see cref='System.Data.DataTable'/>.</para>
    /// </devdoc>
    // public class DataRow : MarshalByRefObject {
    [Serializable]
    public class DataRow {
        internal int         oldRecord = -1;
        internal int         newRecord = -1;
        internal int         tempRecord = -1;
        internal int         rowID;

        internal bool        inChangingEvent;
        internal bool        inDeletingEvent;
        internal bool        inCascade;

        private DataError   error;
        private XmlBoundElement  _element = null;
        private DataTable   _Table;

        private static DataColumn[] zeroColumns = new DataColumn[0];

        internal XmlBoundElement  Element {
            get { return _element; }
            set { _element = value; }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.DataRow"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the DataRow.
        ///    </para>
        ///    <para>
        ///       Constructs a row from the builder. Only for internal usage..
        ///    </para>
        /// </devdoc>
        protected internal DataRow ( DataRowBuilder builder ) {
            /* 58658: Not to implicitly create under the hood dataset
            if (builder._table.DataSet == null) {
                new DataSet().Tables.Add(builder._table);
                Debug.Assert(builder._table.TableName != null, "Table name should not be null.");
            }
            */

            _Table = builder._table;
            rowID = builder._rowID;
            tempRecord = builder._record;
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.RowError"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the custom error description for a row.</para>
        /// </devdoc>
        public string RowError {
            get {
                return(error == null ? String.Empty :error.Text);
            }
            set {
                if (error == null) {
                    error = new DataError(value);
                    RowErrorChanged();
                }
                else {
                    if(error.Text != value) {
                        error.Text = value;
                        RowErrorChanged();
                    }
                }
            }
        }
        
        private void RowErrorChanged() {
            // We don't know wich record was used by view index. try to use both.
            if (oldRecord != -1)
                Table.RecordChanged(oldRecord);
            if (newRecord != -1)
                Table.RecordChanged(newRecord);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.RowState"]/*' />
        /// <devdoc>
        ///    <para>Gets the current state of the row in regards to its relationship to the table.</para>
        /// </devdoc>
        public DataRowState RowState {
            get {
                DataRowState state = (DataRowState)0;
                if (oldRecord == -1 && newRecord == -1)
                    state = DataRowState.Detached;
                else if (oldRecord == newRecord)
                    state = DataRowState.Unchanged;
                else if (oldRecord == -1)
                    state = DataRowState.Added;
                else if (newRecord == -1)
                    state = DataRowState.Deleted;
                else
                    state = DataRowState.Modified;
                return state;
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.Table"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Data.DataTable'/>
        /// for which this row has a schema.</para>
        /// </devdoc>
        public DataTable Table {
            get {
                return _Table;
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.this"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the data stored in the column specified by index.</para>
        /// </devdoc>
        public object this[int columnIndex] {
            get {
                return this[Table.Columns[columnIndex]];
            }
            set {
                this[Table.Columns[columnIndex]] = value;
            }
        }

        internal void CheckForLoops(DataRelation rel){
            // don't check for loops in the diffgram 
            // because there may be some holes in the rowCollection
            // and index creation may fail. The check will be done
            // after all the loading is done _and_ we are sure there
            // are no holes in the collection.
            if (this._Table.DataSet.fInLoadDiffgram)
              return;
            int count = this.Table.Rows.Count, i = 0;
            // need to optimize this for count > 100
            DataRow parent = this.GetParentRow(rel);
            while (parent != null) {
                if ((parent == this) || (i>count))
                    throw ExceptionBuilder.NestedCircular(this.Table.TableName);
                i++;
                parent = parent.GetParentRow(rel);
            }
        }

        internal DataRow GetNestedParent() {
            DataRelation relation = this.Table.nestedParentRelation;
            if (relation != null) {
                if (relation.ParentTable == this.Table) // self-nested table
                    this.CheckForLoops(relation);
                return this.GetParentRow(relation);
            }
            return null;
        }



        internal string Dump() {
            TypeConverter converter = TypeDescriptor.GetConverter(typeof(DataRowState));
            String output = converter.ConvertToString(RowState) + ":";

            if (HasVersion(DataRowVersion.Original) && (RowState != DataRowState.Unchanged)) {
                output += " [original: ";
                output += GetRowValuesString(this, DataRowVersion.Original);
                output += "]";
            }
            if (HasVersion(DataRowVersion.Current)) {
                output += " [current: ";
                output += GetRowValuesString(this, DataRowVersion.Current);
                output += "]";
            }
            if (HasVersion(DataRowVersion.Proposed)) {
                output += " [proposed: ";
                output += GetRowValuesString(this, DataRowVersion.Proposed);
                output += "]";
            }
            return output;
        }

        internal string GetRowValuesString(DataRow row, DataRowVersion version) {
            String output = String.Empty;
            int count = row.Table.Columns.Count;
            for (int i = 0; i < count; i++) {
                output += row.Table.Columns[i].ColumnName;
                output += "=";
                object value = row[i,version];
                if (value is DateTime) {
                    DateTime date = (DateTime)row[i];
                    output += date.ToString("s", null);
                }
                else
                    output += Convert.ToString(value);
                if (i < count-1)
                    output += ", ";
            }
            return output;
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the data stored in the column specified by 
        ///       name.</para>
        /// </devdoc>
        public object this[string columnName] {
            get {
                DataColumn column = Table.Columns[columnName];
                if (column == null)
                    throw ExceptionBuilder.ColumnNotInTheTable(columnName, Table.TableName);   
                    
                return this[column];
            }
            set {
                DataColumn column = Table.Columns[columnName];
                if (column == null)
                    throw ExceptionBuilder.ColumnNotInTheTable(columnName, Table.TableName);   

                this[column] = value;
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.this2"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the data stored in the specified <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public object this[DataColumn column] {
            get {
                return this[column, DataRowVersion.Default];
            }
            set {
                CheckColumn(column);

#if DEBUG
                if (CompModSwitches.Data_ColumnChange.TraceVerbose) {
                    Debug.WriteLine("Data_ColumnDataChange - rowID: " + (rowID) + ", columnName: " + column.ColumnName + ", value: <" + Convert.ToString(value) + ">");
                }
#endif
                if (inChangingEvent) {
                    throw ExceptionBuilder.EditInRowChanging();
                }

                // allow users to tailor the proposed value, or throw an exception.
                // note we intentionally do not try/catch this event.
                DataColumnChangeEventArgs e = new DataColumnChangeEventArgs(this, column, value);
                Table.RaiseColumnChanging(this, e);

                // Check null
                if (e.ProposedValue == null && column.DataType != typeof(String))
                    throw ExceptionBuilder.CannotSetToNull(column);
               
                bool immediate = (tempRecord == -1);
                if (immediate)
                    BeginEdit(); // for now force the update.  let's try to improve this later.
                column[GetProposedRecordNo()] = e.ProposedValue;
                Table.RaiseColumnChanged(this, e);

                if (immediate)
                    EndEdit();
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.this3"]/*' />
        /// <devdoc>
        ///    <para>Gets the data stored
        ///       in the column, specified by index and version of the data to retrieve.</para>
        /// </devdoc>
        public object this[int columnIndex, DataRowVersion version] {
            get {
                return this[Table.Columns[columnIndex], version];
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.this4"]/*' />
        /// <devdoc>
        ///    <para> Gets the specified version of data stored in
        ///       the named column.</para>
        /// </devdoc>
        public object this[string columnName, DataRowVersion version] {
            get {
                DataColumn column = Table.Columns[columnName];
                if (column == null)
                    throw ExceptionBuilder.ColumnNotInTheTable(columnName, Table.TableName);

                return this[column, version];
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.this5"]/*' />
        /// <devdoc>
        /// <para>Gets the specified version of data stored in the specified <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public object this[DataColumn column, DataRowVersion version] {
            get {
                CheckColumn(column);

                int record = GetRecordFromVersion(version);
                return column[record];
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.ItemArray"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets all of the values for this row through an array.</para>
        /// </devdoc>
        public object[] ItemArray {
            get {
                int colCount = Table.Columns.Count;
                object[] values = new object[colCount];

                for (int i = 0; i < colCount; i++) {
                    values[i] = this[i];
                }
                return values;
            }
            set {
                BeginEdit();

                DataColumn column;
                DataColumnChangeEventArgs e = new DataColumnChangeEventArgs();
                DataColumnCollection collection = Table.Columns;

                if (collection.Count < value.Length)
                    throw ExceptionBuilder.ValueArrayLength();
                int count = value.Length;
                for (int i = 0; i < count; ++i) {
                    // Empty means don't change the row.
                    if (null != value[i]) {
                        column = collection[i];

                        // allow users to tailor the proposed value, or throw an exception.
                        // note we intentionally do not try/catch this event.
                        e.Initialize(this, column, value[i]);
                        Table.RaiseColumnChanging(this, e);
                        column[GetProposedRecordNo()] = e.ProposedValue;
                        Table.RaiseColumnChanged(this, e);
                    }
                }
                EndEdit();
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.AcceptChanges"]/*' />
        /// <devdoc>
        ///    <para>Commits all the changes made to this row
        ///       since the last time <see cref='System.Data.DataRow.AcceptChanges'/> was called.</para>
        /// </devdoc>
        public void AcceptChanges() {
            EndEdit();
            Table.CommitRow(this);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.BeginEdit"]/*' />
        /// <devdoc>
        /// <para>Begins an edit operation on a <see cref='System.Data.DataRow'/>object.</para>
        /// </devdoc>
        public void BeginEdit() {
            if (inChangingEvent) {
                throw ExceptionBuilder.BeginEditInRowChanging();
            }

            if (tempRecord != -1) {
                return;
            }

            if (oldRecord != -1 && newRecord == -1) {
                throw ExceptionBuilder.DeletedRowInaccessible();
            }

            tempRecord = Table.NewRecord(newRecord);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.CancelEdit"]/*' />
        /// <devdoc>
        ///    <para>Cancels the current edit on the row.</para>
        /// </devdoc>
        public void CancelEdit() {
            if (inChangingEvent) {
                throw ExceptionBuilder.CancelEditInRowChanging();
            }

            if (tempRecord != -1) {
                Table.FreeRecord(tempRecord);
            }

            tempRecord = -1;
        }

        private void CheckColumn(DataColumn column) {
            if (column == null) {
                throw ExceptionBuilder.ArgumentNull("column");
            }

            if (column.Table != Table) {
                throw ExceptionBuilder.ColumnNotInTheTable(column.ColumnName, Table.TableName);
            }
        }

        /// <devdoc>
        /// Throws a RowNotInTableException if row isn't in table.
        /// </devdoc>
        internal void CheckInTable() {
            if (rowID == -1) {
                throw ExceptionBuilder.RowNotInTheTable();
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.Delete"]/*' />
        /// <devdoc>
        ///    <para>Deletes the row.</para>
        /// </devdoc>
        public void Delete() {
            if (inDeletingEvent) {
                throw ExceptionBuilder.DeleteInRowDeleting();
            }
            
            if (newRecord == -1)
                return;
                
            Table.DeleteRow(this);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.EndEdit"]/*' />
        /// <devdoc>
        ///    <para>Ends the edit occurring on the row.</para>
        /// </devdoc>
        public void EndEdit() {
            if (inChangingEvent) {
                throw ExceptionBuilder.EndEditInRowChanging();
            }

            if (newRecord == -1) {
                return; // this is meaningless.
            }

            if (tempRecord != -1) {
                //int record = tempRecord;
                //tempRecord = -1;
                SetNewRecord(tempRecord);
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.SetColumnError"]/*' />
        /// <devdoc>
        ///    <para>Sets the error description for a column specified by index.</para>
        /// </devdoc>
        public void SetColumnError(int columnIndex, string error) {
			DataColumn column = Table.Columns[columnIndex];
			if (column == null)
				throw ExceptionBuilder.ColumnOutOfRange(columnIndex);

			SetColumnError(column, error);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.SetColumnError1"]/*' />
        /// <devdoc>
        ///    <para>Sets
        ///       the error description for a column specified by name.</para>
        /// </devdoc>
        public void SetColumnError(string columnName, string error) {
			DataColumn column = Table.Columns[columnName];
			if (column == null)
				throw ExceptionBuilder.ColumnNotInTheTable(columnName, Table.TableName);

			SetColumnError(column, error);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.SetColumnError2"]/*' />
        /// <devdoc>
        /// <para>Sets the error description for a column specified as a <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public void SetColumnError(DataColumn column, string error) {
            CheckColumn(column);
            if (this.error == null)  this.error = new DataError();
            if(GetColumnError(column) != error) {
                this.error.SetColumnError(column, error);
                RowErrorChanged();
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetColumnError"]/*' />
        /// <devdoc>
        ///    <para>Gets the error description for the column specified
        ///       by index.</para>
        /// </devdoc>
        public string GetColumnError(int columnIndex) {
			DataColumn column = Table.Columns[columnIndex];
			if (column == null)
				throw ExceptionBuilder.ColumnOutOfRange(columnIndex);

			return GetColumnError(column);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetColumnError1"]/*' />
        /// <devdoc>
        ///    <para>Gets the error description for a column, specified by name.</para>
        /// </devdoc>
        public string GetColumnError(string columnName) {
			DataColumn column = Table.Columns[columnName];
			if (column == null)
				throw ExceptionBuilder.ColumnNotInTheTable(columnName, Table.TableName);

			return GetColumnError(column);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetColumnError2"]/*' />
        /// <devdoc>
        ///    <para>Gets the error description of
        ///       the specified <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public string GetColumnError(DataColumn column) {
            CheckColumn(column);
            if (error == null)  error = new DataError();
            return error.GetColumnError(column);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.ClearErrors"]/*' />
        /// <devdoc>
        /// <para> Clears the errors for the row, including the <see cref='System.Data.DataRow.RowError'/> 
        /// and errors set with <see cref='System.Data.DataRow.SetColumnError'/>
        /// .</para>
        /// </devdoc>
        public void ClearErrors() {
            if (error != null) {
                error.Clear();
            }
        }

        internal void ClearError(DataColumn column) {
            if (error != null) {
                error.Clear(column);
            }
        }
        
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.HasErrors"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether there are errors in a columns collection.</para>
        /// </devdoc>
        public bool HasErrors {
            get {
                return(error == null ? false : error.HasErrors);
            }
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetColumnsInError"]/*' />
        /// <devdoc>
        ///    <para>Gets an array of columns that have errors.</para>
        /// </devdoc>
        public DataColumn[] GetColumnsInError() {
            if (error == null)
                return zeroColumns;
            else
                return error.GetColumnsInError();
        }


        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetChildRows"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataRow[] GetChildRows(string relationName) {
            return GetChildRows(_Table.ChildRelations[relationName], DataRowVersion.Default);
        }
        
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetChildRows1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataRow[] GetChildRows(string relationName, DataRowVersion version) {
            return GetChildRows(_Table.ChildRelations[relationName], version);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetChildRows2"]/*' />
        /// <devdoc>
        /// <para>Gets the child rows of this <see cref='System.Data.DataRow'/> using the
        ///    specified <see cref='System.Data.DataRelation'/>
        ///    .</para>
        /// </devdoc>
        public DataRow[] GetChildRows(DataRelation relation) {
            return GetChildRows(relation, DataRowVersion.Default);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetChildRows3"]/*' />
        /// <devdoc>
        /// <para>Gets the child rows of this <see cref='System.Data.DataRow'/> using the specified <see cref='System.Data.DataRelation'/> and the specified <see cref='System.Data.DataRowVersion'/></para>
        /// </devdoc>
        public DataRow[] GetChildRows(DataRelation relation, DataRowVersion version) {
            if (relation == null)
                return Table.NewRowArray(0);

            if (Table == null)
                throw ExceptionBuilder.RowNotInTheTable();

            if (relation.DataSet != Table.DataSet)
                throw ExceptionBuilder.RowNotInTheDataSet();

            if (relation.ParentKey.Table != Table)
                throw ExceptionBuilder.RelationForeignTable(relation.ParentTable.TableName, Table.TableName);

            Index index = relation.ChildKey.GetSortIndex();
            return DataRelation.GetChildRows(relation.ParentKey, relation.ChildKey, this, version);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetParentRow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataRow GetParentRow(string relationName) {
            return GetParentRow(_Table.ParentRelations[relationName], DataRowVersion.Default);
        }
        
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetParentRow1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataRow GetParentRow(string relationName, DataRowVersion version) {
            return GetParentRow(_Table.ParentRelations[relationName], version);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetParentRow2"]/*' />
        /// <devdoc>
        /// <para>Gets the parent row of this <see cref='System.Data.DataRow'/> using the specified <see cref='System.Data.DataRelation'/> .</para>
        /// </devdoc>
        public DataRow GetParentRow(DataRelation relation) {
            return GetParentRow(relation, DataRowVersion.Default);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetParentRow3"]/*' />
        /// <devdoc>
        /// <para>Gets the parent row of this <see cref='System.Data.DataRow'/>
        /// using the specified <see cref='System.Data.DataRelation'/> and <see cref='System.Data.DataRowVersion'/>.</para>
        /// </devdoc>
        public DataRow GetParentRow(DataRelation relation, DataRowVersion version) {
            if (relation == null)
                return null;

            if (Table == null)
                throw ExceptionBuilder.RowNotInTheTable();

            if (relation.DataSet != Table.DataSet)
                throw ExceptionBuilder.RelationForeignRow();

            if (relation.ChildKey.Table != Table)
                throw ExceptionBuilder.GetParentRowTableMismatch(relation.ChildTable.TableName, Table.TableName);

            return DataRelation.GetParentRow(relation.ParentKey, relation.ChildKey, this, version);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetParentRows"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataRow[] GetParentRows(string relationName) {
            return GetParentRows(_Table.ParentRelations[relationName], DataRowVersion.Default);
        }
        
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetParentRows1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataRow[] GetParentRows(string relationName, DataRowVersion version) {
            return GetParentRows(_Table.ParentRelations[relationName], version);
        }
        
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetParentRows2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the parent rows of this <see cref='System.Data.DataRow'/> using the specified <see cref='System.Data.DataRelation'/> .
        ///    </para>
        /// </devdoc>
        public DataRow[] GetParentRows(DataRelation relation) {
            return GetParentRows(relation, DataRowVersion.Default);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.GetParentRows3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the parent rows of this <see cref='System.Data.DataRow'/> using the specified <see cref='System.Data.DataRelation'/> .
        ///    </para>
        /// </devdoc>
        public DataRow[] GetParentRows(DataRelation relation, DataRowVersion version) {
            if (relation == null)
                return Table.NewRowArray(0);

            if (Table == null)
                throw ExceptionBuilder.RowNotInTheTable();

            if (relation.DataSet != Table.DataSet)
                throw ExceptionBuilder.RowNotInTheDataSet();

            if (relation.ChildKey.Table != Table)
                throw ExceptionBuilder.GetParentRowTableMismatch(relation.ChildTable.TableName, Table.TableName);

            return DataRelation.GetParentRows(relation.ParentKey, relation.ChildKey, this, version);
        }

        internal object[] GetColumnValues(DataColumn[] columns) {
            return GetColumnValues(columns, DataRowVersion.Default);
        }

        internal object[] GetColumnValues(DataColumn[] columns, DataRowVersion version) {
            return GetKeyValues(new DataKey(columns), version);
        }

        internal object[] GetKeyValues(DataKey key) {
            return GetKeyValues(key, DataRowVersion.Default);
        }

        internal object[] GetKeyValues(DataKey key, DataRowVersion version) {
            object[] keyValues = new object[key.Columns.Length];
            for (int i = 0; i < keyValues.Length; i++) {
                keyValues[i] = this[key.Columns[i], version];
            }
            return keyValues;
        }

        internal int GetCurrentRecordNo() {
            if (newRecord == -1)
                throw ExceptionBuilder.NoCurrentData();
            return newRecord;
        }

        internal int GetDefaultRecord() {
            if (tempRecord != -1)
                return tempRecord;
            if (newRecord != -1) {
                return newRecord;
            }
            // If row has oldRecord - this is deleted row.
            if (oldRecord == -1)
                throw ExceptionBuilder.RowRemovedFromTheTable();
            else
                throw ExceptionBuilder.DeletedRowInaccessible();
        }

        internal int GetOriginalRecordNo() {
            if (oldRecord == -1)
                throw ExceptionBuilder.NoOriginalData();
            return oldRecord;
        }

        private int GetProposedRecordNo() {
            if (tempRecord == -1)
                throw ExceptionBuilder.NoProposedData();
            return tempRecord;
        }

        internal int GetRecordFromVersion(DataRowVersion version) {
            switch (version) {
                case DataRowVersion.Original:
                    return GetOriginalRecordNo();
                case DataRowVersion.Current:
                    return GetCurrentRecordNo();
                case DataRowVersion.Proposed:
                    return GetProposedRecordNo();
                case DataRowVersion.Default:
                    return GetDefaultRecord();
                default:
                    throw ExceptionBuilder.InvalidRowVersion();
            }
        }

        internal DataViewRowState GetRecordState(int record) {
            if (record == -1)
                return DataViewRowState.None;
            if (record == oldRecord && record == newRecord)
                return DataViewRowState.Unchanged;
            if (record == oldRecord)
                return(newRecord != -1) ? DataViewRowState.ModifiedOriginal : DataViewRowState.Deleted;
            if (record == newRecord)
                return(oldRecord != -1) ? DataViewRowState.ModifiedCurrent : DataViewRowState.Added;
            return DataViewRowState.None;
        }

        internal bool HasKeyChanged(DataKey key) {
            return HasKeyChanged(key, DataRowVersion.Current, DataRowVersion.Proposed);
        }

        internal bool HasKeyChanged(DataKey key, DataRowVersion version1, DataRowVersion version2) {
            if (!HasVersion(version1) || !HasVersion(version2))
                return true;
            for (int i = 0; i < key.Columns.Length; i++) {
                if (0 != key.Columns[i].Compare(GetRecordFromVersion(version1), GetRecordFromVersion(version2))) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.HasVersion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether a specified version exists.
        ///    </para>
        /// </devdoc>
        public bool HasVersion(DataRowVersion version) {
            switch (version) {
                case DataRowVersion.Original:
                    return(oldRecord != -1);
                case DataRowVersion.Current:
                    return(newRecord != -1);
                case DataRowVersion.Proposed:
                    return(tempRecord != -1);
                case DataRowVersion.Default:
                    return(tempRecord != -1 || newRecord != -1);
                default:
                    throw ExceptionBuilder.InvalidRowVersion();
            }
        }

        internal bool HaveValuesChanged(DataColumn[] columns) {
            return HaveValuesChanged(columns, DataRowVersion.Current, DataRowVersion.Proposed);
        }

        internal bool HaveValuesChanged(DataColumn[] columns, DataRowVersion version1, DataRowVersion version2) {
            for (int i = 0; i < columns.Length; i++) {
                CheckColumn(columns[i]);
            }
            return HasKeyChanged(new DataKey(columns), version1, version2);
        }

        // TODO: waiting for COM+ internal fix.
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.IsNull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a value indicating whether the column at the specified index contains a
        ///       null value.
        ///    </para>
        /// </devdoc>
        public bool IsNull(int columnIndex) {
			DataColumn column = Table.Columns[columnIndex];
			if (column == null)
				throw ExceptionBuilder.ColumnOutOfRange(columnIndex);

			return IsNull(column);
        }

        // TODO: waiting for COM+ internal fix.
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.IsNull1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the named column contains a null value.
        ///    </para>
        /// </devdoc>
        public bool IsNull(string columnName) {
			DataColumn column = Table.Columns[columnName];
			if (column == null)
				throw ExceptionBuilder.ColumnNotInTheTable(columnName, Table.TableName);

			return IsNull(column);
        }

        // TODO: waiting for COM+ internal fix.
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.IsNull2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the specified <see cref='System.Data.DataColumn'/>
        ///       contains a null value.
        ///    </para>
        /// </devdoc>
        public bool IsNull(DataColumn column) {
            CheckColumn(column);
            return column.IsNull(GetRecordFromVersion(DataRowVersion.Default));
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.IsNull3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull(DataColumn column, DataRowVersion version) {
            CheckColumn(column);
            return column.IsNull(GetRecordFromVersion(version));
        }
                
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.RejectChanges"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rejects all changes made to the row since <see cref='System.Data.DataRow.AcceptChanges'/>
        ///       was last called.
        ///    </para>
        /// </devdoc>
        public void RejectChanges() {
            Table.RollbackRow(this);
        }

        internal void SetKeyValues(DataKey key, object[] keyValues) {
            bool fFirstCall = true;
            bool immediate = (tempRecord == -1);

            for (int i = 0; i < keyValues.Length; i++) {
                object value = this[key.Columns[i]];
                if (!value.Equals(keyValues[i])) {
                    if (immediate && fFirstCall) {
                        fFirstCall = false;
                        BeginEdit();
                    }
                    this[key.Columns[i]] = keyValues[i];                    
                }
            }
            if (!fFirstCall)
                EndEdit();
        }

        // if it's a detached row, we can't add it, we'll just keep it as temp.
        internal void SetNewRecord(int record) {
            //Debug.Assert(oldRecord != -1 || newRecord != -1, "You can't call SetNewRecord on a detached row.");
            Table.SetNewRecord(this, record, DataRowAction.Change, false);
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.SetNull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the specified column's value to a null value.
        ///    </para>
        /// </devdoc>
        protected void SetNull(DataColumn column) {
            this[column] = DBNull.Value;
        }

        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.SetParentRow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetParentRow(DataRow parentRow) {
            if (parentRow == null) {
                SetParentRowToDBNull();
                return;
            }

            if (this.Table == null)
                throw ExceptionBuilder.ChildRowNotInTheTable();

            if (parentRow.Table == null)
                throw ExceptionBuilder.ParentRowNotInTheTable();

            foreach (DataRelation relation in this.Table.ParentRelations) {
                if (relation.ParentKey.Table == parentRow.Table) {
                    object[] parentKeyValues = parentRow.GetKeyValues(relation.ParentKey);
                    this.SetKeyValues(relation.ChildKey, parentKeyValues);
                    if (relation.Nested) {
                        if (parentRow.Table == this.Table)
                            this.CheckForLoops(relation);
                        else
                            this.GetParentRow(relation);
                    }
                }
            }            
        }
        
        /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRow.SetParentRow1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets current row's parent row with specified relation.
        ///    </para>
        /// </devdoc>
        public void SetParentRow(DataRow parentRow, DataRelation relation) {
            if (relation == null) {
                SetParentRow(parentRow);
                return;
            }

            if (parentRow == null) {
                SetParentRowToDBNull(relation);
                return;
            }

            if (this.Table == null)
                throw ExceptionBuilder.ChildRowNotInTheTable();

            if (parentRow.Table == null)
                throw ExceptionBuilder.ParentRowNotInTheTable();

            if (this.Table.DataSet != parentRow.Table.DataSet)
                throw ExceptionBuilder.ParentRowNotInTheDataSet();

            if (relation.ChildKey.Table != this.Table)
                throw ExceptionBuilder.SetParentRowTableMismatch(relation.ChildKey.Table.TableName, this.Table.TableName);

            if (relation.ParentKey.Table != parentRow.Table)
                throw ExceptionBuilder.SetParentRowTableMismatch(relation.ParentKey.Table.TableName, parentRow.Table.TableName);

            object[] parentKeyValues = parentRow.GetKeyValues(relation.ParentKey);
            this.SetKeyValues(relation.ChildKey, parentKeyValues);
        }     

        internal void SetParentRowToDBNull() {
            if (this.Table == null)
                throw ExceptionBuilder.ChildRowNotInTheTable();

            foreach (DataRelation relation in this.Table.ParentRelations)
                SetParentRowToDBNull(relation);
        }
 
        internal void SetParentRowToDBNull(DataRelation relation) {
            Debug.Assert(relation != null, "The relation should not be null here.");
            
            if (this.Table == null)
                throw ExceptionBuilder.ChildRowNotInTheTable();

            if (relation.ChildKey.Table != this.Table)
                throw ExceptionBuilder.SetParentRowTableMismatch(relation.ChildKey.Table.TableName, this.Table.TableName);

            if (tempRecord == -1)
                BeginEdit();
            int count = relation.ChildKey.Columns.Length;
            for (int i = 0; i < count; i++) {
                this[relation.ChildKey.Columns[i]] = DBNull.Value;
            }
            if (tempRecord == -1)
                EndEdit();
        }        
    }

    /// <include file='doc\DataRow.uex' path='docs/doc[@for="DataRowBuilder"]/*' />
    public class DataRowBuilder {
        internal readonly DataTable   _table;
        internal readonly int         _rowID;
        internal int                  _record;
        
        internal DataRowBuilder(DataTable table, int rowID, int record) {
            this._table = table;
            this._rowID = rowID;
            this._record = record;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarowcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRowCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection"]/*' />
    /// <devdoc>
    /// <para>Represents a collection of rows for a <see cref='System.Data.DataTable'/>
    /// .</para>
    /// </devdoc>
    [Serializable]
    public class DataRowCollection : InternalDataCollectionBase {

        private DataTable table;
        private ArrayList list = new ArrayList();
        internal int nullInList = 0;

        /// <devdoc>
        /// Creates the DataRowCollection for the given table.
        /// </devdoc>
        internal DataRowCollection(DataTable table) {
            this.table = table;
        }
        
        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.List"]/*' />
        protected override ArrayList List {
            get {
                return list;
            }
        }
        
        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the row at the specified index.</para>
        /// </devdoc>
        public DataRow this[int index] {
            get {
                if (index >= 0 && index < Count) {
                    return (DataRow) list[index];
                }
                throw ExceptionBuilder.RowOutOfRange(index);
            }
        }
        
        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.Add"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.Data.DataRow'/> to the <see cref='System.Data.DataRowCollection'/> object.</para>
        /// </devdoc>
        public void Add(DataRow row) {
            table.AddRow(row, -1);
        }

        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.InsertAt"]/*' />
        public void InsertAt(DataRow row, int pos) {
            if (pos < 0) 
                throw ExceptionBuilder.RowInsertOutOfRange(pos);
            if (pos >= table.Rows.Count)
                table.AddRow(row, -1);
            else
                table.InsertRow(row, -1, pos);
        }

        internal void DiffInsertAt(DataRow row, int pos) {
            if ((pos < 0) || (pos == table.Rows.Count)) { 
                table.AddRow(row, pos >-1? pos+1 : -1);
                return;
            }
            if (table.nestedParentRelation != null) { // get in this trouble only if 
                                                   // table has a nested parent 
                if (pos < table.Rows.Count) {
                    if (list[pos] != null) 
                        throw ExceptionBuilder.RowInsertTwice(pos, table.TableName);
                    list.RemoveAt(pos);
                    nullInList--;
                    table.InsertRow(row, pos+1, pos);
                }
                else {
                    while (pos>table.Rows.Count) {
                        list.Add(null);
                        nullInList++;
                    }
                    table.AddRow(row, pos+1);
                }
            }
            else {
                table.InsertRow(row, pos+1, pos > table.Rows.Count ? -1 : pos);
            }

        }

        internal Int32 IndexOf(DataRow row) {
            return list.IndexOf(row);
        }

        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para>Creates a row using specified values and adds it to the
        ///    <see cref='System.Data.DataRowCollection'/>.</para>
        /// </devdoc>
        public virtual DataRow Add(object[] values) {
            int record = table.NewRecordFromArray(values);
            DataRow row = table.NewRow(record);
            table.AddRow(row, -1);
            return row;
        }

        internal void ArrayAdd(DataRow row) {
            list.Add(row);
        }

        internal void ArrayInsert(DataRow row, int pos) {
            list.Insert(pos, row);
        }

        internal void ArrayClear() {
            list.Clear();
        }

        internal void ArrayRemove(DataRow row) {
            list.Remove(row);
        }

        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.Find"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the row specified by the primary key value.
        ///       </para>
        /// </devdoc>
        public DataRow Find(object key) {
            return table.FindByPrimaryKey(key);
        }

        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.Find1"]/*' />
        /// <devdoc>
        ///    <para>Gets the row containing the specified primary key values.</para>
        /// </devdoc>
        public DataRow Find(object[] keys) {
            return table.FindByPrimaryKey(keys);
        }

        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>Clears the collection of all rows.</para>
        /// </devdoc>
        public void Clear() {
            table.Clear();
        }

        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the primary key of any row in the
        ///       collection contains the specified value.
        ///    </para>
        /// </devdoc>
        public bool Contains(object key) {
            return(table.FindByPrimaryKey(key) != null);
        }

        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.Contains1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating if the <see cref='System.Data.DataRow'/> with
        ///       the specified primary key values exists.
        ///    </para>
        /// </devdoc>
        public bool Contains(object[] keys) {
            return(table.FindByPrimaryKey(keys) != null);
        }


        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes the specified <see cref='System.Data.DataRow'/> from the collection.</para>
        /// </devdoc>
        public void Remove(DataRow row) {
            if (!list.Contains(row)) {
                throw ExceptionBuilder.RowOutOfRange();
            }
            
            if ((row.RowState != DataRowState.Deleted) && (row.RowState != DataRowState.Detached)) {
                row.Delete();
                if (row.RowState != DataRowState.Detached)
                    row.AcceptChanges();
            }
        }

        /// <include file='doc\DataRowCollection.uex' path='docs/doc[@for="DataRowCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the row with the specified index from
        ///       the collection.
        ///    </para>
        /// </devdoc>
        public void RemoveAt(int index) {
                Remove(this[index]);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarowstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRowState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\DataRowState.uex' path='docs/doc[@for="DataRowState"]/*' />
    /// <devdoc>
    /// <para>Gets the state of a <see cref='System.Data.DataRow'/> object.</para>
    /// </devdoc>
    [ Flags ]
    public enum DataRowState {

        // DataViewRowState.None = 00000000;
        /// <include file='doc\DataRowState.uex' path='docs/doc[@for="DataRowState.Detached"]/*' />
        /// <devdoc>
        ///    <para>The row 
        ///       has been created but is not part of any <see cref='System.Data.DataRowCollection'/>. A <see cref='System.Data.DataRow'/> is in this state immediately
        ///       after it has been created and before it is added to a collection, or if it has
        ///       been removed from a collection. </para>
        /// </devdoc>
        Detached  = 0x00000001,
/// <include file='doc\DataRowState.uex' path='docs/doc[@for="DataRowState.Unchanged"]/*' />
/// <devdoc>
///    <para>
///       The row has not changed since <see cref='System.Data.DataRow.AcceptChanges'/> was last called.
///    </para>
/// </devdoc>
        Unchanged = 0x00000002,
        /// <include file='doc\DataRowState.uex' path='docs/doc[@for="DataRowState.New"]/*' />
        /// <devdoc>
        /// <para>The row was added to a <see cref='System.Data.DataRowCollection'/>, 
        ///    and <see cref='System.Data.DataRow.AcceptChanges'/> has not been called.</para>
        /// </devdoc>
        Added       = 0x00000004,
        /// <include file='doc\DataRowState.uex' path='docs/doc[@for="DataRowState.Deleted"]/*' />
        /// <devdoc>
        /// <para>The row was deleted using the <see cref='System.Data.DataRow.Delete'/> 
        /// method of the <see cref='System.Data.DataRow'/> .</para>
        /// </devdoc>
        Deleted   = 0x00000008,
        /// <include file='doc\DataRowState.uex' path='docs/doc[@for="DataRowState.Modified"]/*' />
        /// <devdoc>
        /// <para>The row was modified and <see cref='System.Data.DataRow.AcceptChanges'/> has not been called.</para>
        /// </devdoc>
        Modified  = 0x000000010
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarowversion.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRowVersion.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System.Configuration.Assemblies;

    using System.Diagnostics;

    /// <include file='doc\DataRowVersion.uex' path='docs/doc[@for="DataRowVersion"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Describes the version of a <see cref='System.Data.DataRow'/>.
    ///    </para>
    /// </devdoc>
    public enum DataRowVersion {
/// <include file='doc\DataRowVersion.uex' path='docs/doc[@for="DataRowVersion.Original"]/*' />
/// <devdoc>
///    <para>
///       The row contains its original values.
///       
///    </para>
/// </devdoc>
        Original =  0x0100,
/// <include file='doc\DataRowVersion.uex' path='docs/doc[@for="DataRowVersion.Current"]/*' />
/// <devdoc>
///    <para>
///       The row contains current values.
///       
///    </para>
/// </devdoc>
        Current  =  0x0200,
/// <include file='doc\DataRowVersion.uex' path='docs/doc[@for="DataRowVersion.Proposed"]/*' />
/// <devdoc>
///    <para>
///       The row contains a proposed value.
///       
///    </para>
/// </devdoc>
        Proposed =  0x0400,
/// <include file='doc\DataRowVersion.uex' path='docs/doc[@for="DataRowVersion.Default"]/*' />
/// <devdoc>
///    <para>
///       The row contains its default values.
///       
///    </para>
/// </devdoc>
        Default     = Proposed | Current,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datarowview.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataRowView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System.Diagnostics;
    using System.ComponentModel;

    /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a customized view of a <see cref='System.Data.DataRow'/>.
    ///    </para>
    /// </devdoc>
    public class DataRowView : ICustomTypeDescriptor, System.ComponentModel.IEditableObject, System.ComponentModel.IDataErrorInfo {

        private DataView dataView;
        private DataRow row;
        private int index;
        private static PropertyDescriptorCollection zeroPropertyDescriptorCollection = new PropertyDescriptorCollection(null);

        internal DataRowView(DataView dataView, int index) {
            this.dataView = dataView;
            this.index = index;
            this.row = dataView.GetRow(index);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the current <see cref='System.Data.DataRowView'/> is
        ///       identical to the specified object.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object other) {
            if (other is DataRowView) {
                DataRowView dataRowView = (DataRowView) other;
                return(
                    dataRowView.row      == row && 
                    dataRowView.dataView == dataView
                );
            }
            return false;
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Int32 GetHashCode() {
            return row.GetHashCode();
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.DataView"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Data.DataView'/> to which this row belongs.</para>
        /// </devdoc>
        public DataView DataView {
            get {
                return dataView;
            }
        }

        internal int Index {
            get {
                return index;
            }
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value in a specified column.
        ///    </para>
        /// </devdoc>
        public object this[int ndx] {
            get {
                if (!(0 <= ndx && ndx < dataView.Table.Columns.Count)) {
                    throw ExceptionBuilder.ColumnOutOfRange(ndx);
                }
                return row[ndx, dataView.IsOriginalVersion(this.index) ? DataRowVersion.Original : DataRowVersion.Default];
            }
            set {
                if (!(0 <= ndx && ndx < dataView.Table.Columns.Count)) {
                    throw ExceptionBuilder.ColumnOutOfRange(ndx);
                }
                if (!dataView.AllowEdit && (row != dataView.addNewRow)) {
                    throw ExceptionBuilder.CanNotEdit();
                }
                SetColumnValue(dataView.Table.Columns[ndx],value);
            }
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.this1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value in a specified column.
        ///    </para>
        /// </devdoc>
        public object this[string property] {
            get {
                if (dataView.Table.Columns.Contains(property)) {
                    return row[property, dataView.IsOriginalVersion(this.index) ? DataRowVersion.Original : DataRowVersion.Default];
                }
                else if (dataView.Table.DataSet != null && dataView.Table.DataSet.Relations.Contains(property)) {
                    return dataView.CreateChildView(property, index);
                }

                throw ExceptionBuilder.PropertyNotFound(property, dataView.Table.TableName);
            }
            set {
                if (!dataView.Table.Columns.Contains(property)) {
                    throw ExceptionBuilder.SetFailed(property);
                }
                if (!dataView.AllowEdit && (row != dataView.addNewRow))
                	throw ExceptionBuilder.CanNotEdit();
                SetColumnValue(dataView.Table.Columns[property],value);
            }
        }

        // IDataErrorInfo stuff
        string System.ComponentModel.IDataErrorInfo.this[string colName] {
            get {
                return row.GetColumnError(colName);
            }
        }

        string System.ComponentModel.IDataErrorInfo.Error {
            get {
                return row.RowError;
            }
        }

        internal object GetColumnValue(DataColumn column) {
            return row[column, dataView.IsOriginalVersion(this.index) ? DataRowVersion.Original : DataRowVersion.Default];
        }

        internal void SetColumnValue(DataColumn column, object value) {
            if (dataView.GetDelayBeginEdit(row)) {
                dataView.SetDelayBeginEdit(row,false);
                row.BeginEdit();
            }
            if (dataView.IsOriginalVersion(this.index)) {
                throw ExceptionBuilder.SetFailed(column.ColumnName);
            }
            row[column] = value;
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.CreateChildView"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataView CreateChildView(DataRelation relation) {
            return dataView.CreateChildView(relation, index);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.CreateChildView1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataView CreateChildView(string relationName) {
            return dataView.CreateChildView(relationName, index);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.Row"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Data.DataRow'/>
        ///       being viewed.
        ///    </para>
        /// </devdoc>
        public DataRow Row {
            get {
                return row;
            }
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.RowVersion"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the current version description of the <see cref='System.Data.DataRow'/>.
        ///    </para>
        /// </devdoc>
        public DataRowVersion RowVersion {
            get {
                return dataView.IsOriginalVersion(this.index) ? DataRowVersion.Original : DataRowVersion.Current;
            }
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.BeginEdit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Begins an edit procedure.
        ///    </para>
        /// </devdoc>
        public void BeginEdit() {
            dataView.SetDelayBeginEdit(row, true);
            //row.BeginEdit();
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.CancelEdit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Cancels an edit procedure.
        ///    </para>
        /// </devdoc>
        public void CancelEdit() {
            if (row == dataView.addNewRow) {
                dataView.FinishAddNew(this.index, false);
            }
            else {
                row.CancelEdit();
            }
            dataView.SetDelayBeginEdit(row, false);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.EndEdit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Ends an edit procedure.
        ///    </para>
        /// </devdoc>
        public void EndEdit() {
            if (row == dataView.addNewRow) {
                dataView.FinishAddNew(this.index, true);
            }
            else {
                row.EndEdit();
            }
            dataView.SetDelayBeginEdit(row, false);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.IsNew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNew {
            get {
                return row == dataView.addNewRow;
            }
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.IsEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsEdit {
            get {                
                return (
                    row.tempRecord != -1            ||          // It was edited or
                    dataView.GetDelayBeginEdit(row)             // DataRowView.BegingEdit() was called, but not edited yet.
                );
            }
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.Delete"]/*' />
        /// <devdoc>
        ///    <para>Deletes a row.</para>
        /// </devdoc>
        public void Delete() {
            dataView.Delete(index);
        }

        // ---------------------- ICustomTypeDescriptor ---------------------------

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves an array of member attributes for the given object.
        /// </devdoc>
        AttributeCollection ICustomTypeDescriptor.GetAttributes() {
            return new AttributeCollection(null);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetClassName"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the class name for this object.  If null is returned,
        /// the type name is used.
        /// </devdoc>
        string ICustomTypeDescriptor.GetClassName() {
            return null;
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetComponentName"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the name for this object.  If null is returned,
        /// the default is used.
        /// </devdoc>
        string ICustomTypeDescriptor.GetComponentName() {
            return null;
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetConverter"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the type converter for this object.
        /// </devdoc>
        TypeConverter ICustomTypeDescriptor.GetConverter() {
            return null;
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetDefaultEvent"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the default event.
        /// </devdoc>
        EventDescriptor ICustomTypeDescriptor.GetDefaultEvent() {
            return null;
        }


        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetDefaultProperty"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the default property.
        /// </devdoc>
        PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty() {
            return null;
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetEditor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the an editor for this object.
        /// </devdoc>
        object ICustomTypeDescriptor.GetEditor(Type editorBaseType) {
            return null;
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetEvents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves an array of events that the given component instance
        /// provides.  This may differ from the set of events the class
        /// provides.  If the component is sited, the site may add or remove
        /// additional events.
        /// </devdoc>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents() {
            return new EventDescriptorCollection(null);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetEvents1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves an array of events that the given component instance
        /// provides.  This may differ from the set of events the class
        /// provides.  If the component is sited, the site may add or remove
        /// additional events.  The returned array of events will be
        /// filtered by the given set of attributes.
        /// </devdoc>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes) {
            return new EventDescriptorCollection(null);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetProperties"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves an array of properties that the given component instance
        /// provides.  This may differ from the set of properties the class
        /// provides.  If the component is sited, the site may add or remove
        /// additional properties.
        /// </devdoc>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties() {
            return((ICustomTypeDescriptor)this).GetProperties(null);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetProperties1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves an array of properties that the given component instance
        /// provides.  This may differ from the set of properties the class
        /// provides.  If the component is sited, the site may add or remove
        /// additional properties.  The returned array of properties will be
        /// filtered by the given set of attributes.
        /// </devdoc>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes) {
            return (dataView.Table != null ? dataView.Table.GetPropertyDescriptorCollection(attributes) : zeroPropertyDescriptorCollection);
        }

        /// <include file='doc\DataRowView.uex' path='docs/doc[@for="DataRowView.ICustomTypeDescriptor.GetPropertyOwner"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the object that directly depends on this value being edited.  This is
        /// generally the object that is required for the PropertyDescriptor's GetValue and SetValue
        /// methods.  If 'null' is passed for the PropertyDescriptor, the ICustomComponent
        /// descripotor implemementation should return the default object, that is the main
        /// object that exposes the properties and attributes,
        /// </devdoc>
        object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd) {
            return this;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datatablepropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataTablePropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;

    /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class DataTablePropertyDescriptor : PropertyDescriptor {

        DataTable table;

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.Table"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataTable Table {
            get {
                return table;
            }
        }

        internal DataTablePropertyDescriptor(DataTable dataTable) : base(dataTable.TableName, null) {
            this.table = dataTable;    
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type ComponentType {
            get {
                return typeof(DataRowView);
            }
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Type PropertyType {
            get {
                return typeof(IBindingList);
            }
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object other) {
            if (other is DataTablePropertyDescriptor) {
                DataTablePropertyDescriptor descriptor = (DataTablePropertyDescriptor) other;
                return(descriptor.Table == Table);
            }
            return false;
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Int32 GetHashCode() {
            return Table.GetHashCode();
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool CanResetValue(object component) {
            return false;
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override object GetValue(object component) {
            DataViewManagerListItemTypeDescriptor dataViewManagerListItem = (DataViewManagerListItemTypeDescriptor) component;
            return dataViewManagerListItem.GetDataView(table);
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void ResetValue(object component) {
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void SetValue(object component, object value) {
        }

        /// <include file='doc\DataTablePropertyDescriptor.uex' path='docs/doc[@for="DataTablePropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool ShouldSerializeValue(object component) {
            return false;
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datatabletypeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataTableTypeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System.ComponentModel;

    internal class DataTableTypeConverter : ReferenceConverter {

        public DataTableTypeConverter() :
        base(typeof(DataTable)) {
        }

        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
           return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datatablecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataTableCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;

    /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the collection of tables for the <see cref='System.Data.DataSet'/>.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("CollectionChanged"),
    Editor("Microsoft.VSDesigner.Data.Design.TablesCollectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    ListBindable(false),
    Serializable
    ]
    public class DataTableCollection : InternalDataCollectionBase {

        private DataSet dataSet      = null;
        // private DataTable[] tables   = new DataTable[2];
        // private int tableCount       = 0;
        private ArrayList list = new ArrayList();
        private int defaultNameIndex = 1;
        private DataTable[] delayedAddRangeTables = null;

        private CollectionChangeEventHandler onCollectionChangedDelegate = null;
        private CollectionChangeEventHandler onCollectionChangingDelegate = null;

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.DataTableCollection"]/*' />
        /// <devdoc>
        /// DataTableCollection constructor.  Used only by DataSet.
        /// </devdoc>
        internal DataTableCollection(DataSet dataSet) {
            this.dataSet = dataSet;
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.List"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the tables
        ///       in the collection as an object.
        ///    </para>
        /// </devdoc>
        protected override ArrayList List {
            get {
                return list;
            }
        }
        

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the table specified by its index.</para>
        /// </devdoc>
        public DataTable this[int index] {
            get {
                if (index >= 0 && index < List.Count) {
                    return(DataTable) List[index];
                }
            throw ExceptionBuilder.TableOutOfRange(index);
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets the table in the collection with the given name (not case-sensitive).</para>
        /// </devdoc>
        public DataTable this[string name] {
            get {
                int index = InternalIndexOf(name);
                if (index == -2) {
                    throw ExceptionBuilder.CaseInsensitiveNameConflict(name);
                }
                return (index < 0) ? null : (DataTable)List[index];
            }
        }

        // Case-sensitive search in Schema, data and diffgram loading
        internal DataTable this[string name, string ns] 
        {
            get
            {
                for (int i = 0; i < List.Count; i++) {
                    DataTable   table = (DataTable) List[i];
                    if (table.TableName == name && table.Namespace == ns)
                        return table;
                }
                return null;
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds
        ///       the specified table to the collection.
        ///    </para>
        /// </devdoc>
        public virtual void Add(DataTable table) {
            OnCollectionChanging(new CollectionChangeEventArgs(CollectionChangeAction.Add, table));
            BaseAdd(table);
            ArrayAdd(table);

            // need to reset indices if CaseSensitve is ambient
            if (table.caseSensitiveAmbient)
                table.ResetIndexes();
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, table));
        }
        
        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(DataTable[] tables) {
            if (dataSet.fInitInProgress) {
                delayedAddRangeTables = tables;
                return;
            }
            
            if (tables != null) {
                foreach(DataTable table in tables) {
                    if (table != null) {
                        Add(table);
                    }
                }
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a table with the given name and adds it to the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public virtual DataTable Add(string name) {
            DataTable table = new DataTable(name);
            Add(table);
            return table;
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.Add2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new table with a default name and adds it to
        ///       the collection.
        ///    </para>
        /// </devdoc>
        public virtual DataTable Add() {
            DataTable table = new DataTable();
            Add(table);
            return table;
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.CollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the collection is changed.
        ///    </para>
        /// </devdoc>
        [ResDescription(Res.collectionChangedEventDescr)]
        public event CollectionChangeEventHandler CollectionChanged {
            add {
                onCollectionChangedDelegate += value;
            }
            remove {
                onCollectionChangedDelegate -= value;
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.CollectionChanging"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public event CollectionChangeEventHandler CollectionChanging {
            add {
                onCollectionChangingDelegate += value;
            }
            remove {
                onCollectionChangingDelegate -= value;
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.ArrayAdd"]/*' />
        /// <devdoc>
        ///  Adds the table to the tables array.
        /// </devdoc>
        private void ArrayAdd(DataTable table) {
            List.Add(table);
        }

        private void ArrayRemove(DataTable table) {
            List.Remove(table);
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.AssignName"]/*' />
        /// <devdoc>
        /// Creates a new default name.
        /// </devdoc>
        internal string AssignName() {
            string newName = MakeName(defaultNameIndex);
            defaultNameIndex++;
            return newName;
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.BaseAdd"]/*' />
        /// <devdoc>
        /// Does verification on the table and it's name, and points the table at the dataSet that owns this collection.
        /// An ArgumentNullException is thrown if this table is null.  An ArgumentException is thrown if this table
        /// already belongs to this collection, belongs to another collection.
        /// A DuplicateNameException is thrown if this collection already has a table with the same
        /// name (case insensitive).
        /// </devdoc>
        private void BaseAdd(DataTable table) {
            if (table == null)
                throw ExceptionBuilder.ArgumentNull("table");
            if (table.DataSet == dataSet)
                throw ExceptionBuilder.TableAlreadyInTheDataSet();
            if (table.DataSet != null)
                throw ExceptionBuilder.TableAlreadyInOtherDataSet();

            if (table.TableName.Length == 0)
                table.TableName = AssignName();
            else {
                if (NamesEqual(table.TableName, dataSet.DataSetName, false, dataSet.Locale) != 0 && !table.fNestedInDataset)
                   throw ExceptionBuilder.DatasetConflictingName(dataSet.DataSetName);
                RegisterName(table.TableName);
            }

            table.SetDataSet(dataSet);

            // TODO (EricVas): must run thru the document incorporating the addition of this data table
            // TODO (EricVas): must make sure there is no other schema component which have the same 
            //                 identity as this table (for example, there must not be a table with the 
            //                 same identity as a column in this schema.            
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.BaseGroupSwitch"]/*' />
        /// <devdoc>
        /// BaseGroupSwitch will intelligently remove and add tables from the collection.
        /// </devdoc>
        private void BaseGroupSwitch(DataTable[] oldArray, int oldLength, DataTable[] newArray, int newLength) {
            // We're doing a smart diff of oldArray and newArray to find out what
            // should be removed.  We'll pass through oldArray and see if it exists
            // in newArray, and if not, do remove work.  newBase is an opt. in case
            // the arrays have similar prefixes.
            int newBase = 0;
            for (int oldCur = 0; oldCur < oldLength; oldCur++) {
                bool found = false;
                for (int newCur = newBase; newCur < newLength; newCur++) {
                    if (oldArray[oldCur] == newArray[newCur]) {
                        if (newBase == newCur) {
                            newBase++;
                        }
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    // This means it's in oldArray and not newArray.  Remove it.
                    if (oldArray[oldCur].DataSet == dataSet) {
                        BaseRemove(oldArray[oldCur]);
                        //ArrayRemove(oldCur);
                        List.Remove(oldArray[oldCur]);
                    }
                }
            }

            // Now, let's pass through news and those that don't belong, add them.
            for (int newCur = 0; newCur < newLength; newCur++) {
                if (newArray[newCur].DataSet != dataSet) {
                    BaseAdd(newArray[newCur]);
                    List.Add(newArray[newCur]);
                }
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.BaseRemove"]/*' />
        /// <devdoc>
        /// Does verification on the table and it's name, and clears the table's dataSet pointer.
        /// An ArgumentNullException is thrown if this table is null.  An ArgumentException is thrown
        /// if this table doesn't belong to this collection or if this table is part of a relationship.
        /// </devdoc>
        private void BaseRemove(DataTable table) {
            if (CanRemove(table, true)) {
                UnregisterName(table.TableName);
                table.SetDataSet(null);

                // TODO (EricVas): must run though the document incorporating the removal of this table
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.CanRemove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Verifies if a given table can be removed from the collection.
        ///    </para>
        /// </devdoc>
        public bool CanRemove(DataTable table) {
            return CanRemove(table, false);
        }

        internal bool CanRemove(DataTable table, bool fThrowException) {
            if (table == null) {
                if (!fThrowException)
                    return false;
                else
                    throw ExceptionBuilder.ArgumentNull("table");
            }
            if (table.DataSet != dataSet) {
                if (!fThrowException)
                    return false;
                else
                    throw ExceptionBuilder.TableNotInTheDataSet(table.TableName);
            }

            // allow subclasses to throw.
            dataSet.OnRemoveTableHack(table);

            if (table.ChildRelations.Count != 0 || table.ParentRelations.Count != 0) {
                if (!fThrowException)
                    return false;
                else
                    throw ExceptionBuilder.TableInRelation();
            }

            for (ParentForeignKeyConstraintEnumerator constraints = new ParentForeignKeyConstraintEnumerator(dataSet, table); constraints.GetNext();) {
                ForeignKeyConstraint constraint = constraints.GetForeignKeyConstraint();
                if (!fThrowException)
                    return false;
                else
                    throw ExceptionBuilder.TableInConstraint(table, constraint);
            }

            for (ChildForeignKeyConstraintEnumerator constraints = new ChildForeignKeyConstraintEnumerator(dataSet, table); constraints.GetNext();) {
                ForeignKeyConstraint constraint = constraints.GetForeignKeyConstraint();
                if (!fThrowException)
                    return false;
                else
                    throw ExceptionBuilder.TableInConstraint(table, constraint);
            }

            return true;
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears the collection of any tables.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            int oldLength = List.Count;
            DataTable[] tables = new DataTable[List.Count];
            List.CopyTo(tables, 0);
            
            OnCollectionChanging(RefreshEventArgs);

            if (dataSet.fInitInProgress && delayedAddRangeTables != null) {
                delayedAddRangeTables = null;
            }

            BaseGroupSwitch(tables, oldLength, null, 0);
            List.Clear();
            
            OnCollectionChanged(RefreshEventArgs);
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Checks if a table, specified by name, exists in the collection.
        ///    </para>
        /// </devdoc>
        public bool Contains(string name) {
            return (InternalIndexOf(name) >= 0);
        }

        internal bool Contains(string name, bool caseSensitive) {
            if (!caseSensitive)
                return (InternalIndexOf(name) >= 0);

            // Case-Sensitive compare
            int count = List.Count;
            for (int i = 0; i < count; i++) {
                DataTable table = (DataTable) List[i];
                if (NamesEqual(table.TableName, name, true, dataSet.Locale) == 1)
                    return true;
            }
            return false;                    
        }


        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the index of a specified <see cref='System.Data.DataTable'/>.
        ///    </para>
        /// </devdoc>
        public virtual int IndexOf(DataTable table) {
            int tableCount = List.Count;
            for (int i = 0; i < tableCount; ++i) {
                if (table == (DataTable) List[i]) {
                    return i;
                }
            }
            return -1;
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.IndexOf1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the index of the
        ///       table with the given name (case insensitive), or -1 if the table
        ///       doesn't exist in the collection.
        ///    </para>
        /// </devdoc>
        public virtual int IndexOf(string tableName) {
            int index = InternalIndexOf(tableName);
            return (index < 0) ? -1 : index;
        }
        
        // Return value:
        //      >= 0: find the match
        //        -1: No match
        //        -2: At least two matches with different cases
        internal int InternalIndexOf(string tableName) {
            int cachedI = -1;
            if ((null != tableName) && (0 < tableName.Length)) {
                int count = List.Count;
                int result = 0;
                for (int i = 0; i < count; i++) {
                    DataTable table = (DataTable) List[i];
                    result = NamesEqual(table.TableName, tableName, false, dataSet.Locale);
                    if (result == 1)
                        return i;

                    if (result == -1)
                        cachedI = (cachedI == -1) ? i : -2;
                }
            }
            return cachedI;                    
        }

        internal void FinishInitCollection() {
            if (delayedAddRangeTables != null) {
                foreach(DataTable table in delayedAddRangeTables) {
                    if (table != null) {
                        Add(table);
                    }
                }
                delayedAddRangeTables = null;
            }
        }
    
        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.MakeName"]/*' />
        /// <devdoc>
        /// Makes a default name with the given index.  e.g. Table1, Table2, ... Tablei
        /// </devdoc>
        private string MakeName(int index) {
            return "Table" + index.ToString();
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.OnCollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Data.DataTableCollection.OnCollectionChanged'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnCollectionChanged(CollectionChangeEventArgs ccevent) {
            if (onCollectionChangedDelegate != null) {
                onCollectionChangedDelegate(this, ccevent);
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.OnCollectionChanging"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal virtual void OnCollectionChanging(CollectionChangeEventArgs ccevent) {
            if (onCollectionChangingDelegate != null) {
                onCollectionChangingDelegate(this, ccevent);
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.RegisterName"]/*' />
        /// <devdoc>
        /// Registers this name as being used in the collection.  Will throw an ArgumentException
        /// if the name is already being used.  Called by Add, All property, and Table.TableName property.
        /// if the name is equivalent to the next default name to hand out, we increment our defaultNameIndex.
        /// </devdoc>
        internal void RegisterName(string name) {
            Debug.Assert (name != null);

            CultureInfo locale = dataSet.Locale;
            int tableCount = List.Count;
            for (int i = 0; i < tableCount; i++) {
                if (NamesEqual(name, ((DataTable) List[i]).TableName, true, locale) != 0) {
                    throw ExceptionBuilder.DuplicateTableName(((DataTable) List[i]).TableName);
                }
            }
            if (NamesEqual(name, MakeName(defaultNameIndex), true, locale) != 0) {
                defaultNameIndex++;
            }
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the specified table from the collection.
        ///    </para>
        /// </devdoc>
        public void Remove(DataTable table) {
            OnCollectionChanging(new CollectionChangeEventArgs(CollectionChangeAction.Remove, table));
            BaseRemove(table);
            ArrayRemove(table);
            
            OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, table));
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the
        ///       table at the given index from the collection
        ///    </para>
        /// </devdoc>
        public void RemoveAt(int index) {
			DataTable dt = this[index];
			if (dt == null)
				throw ExceptionBuilder.TableOutOfRange(index);
			Remove(dt);
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.Remove1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the table with a specified name from the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public void Remove(string name) {
			DataTable dt = this[name];
			if (dt == null)
				throw ExceptionBuilder.TableNotInTheDataSet(name);
            Remove(dt);
        }

        /// <include file='doc\DataTableCollection.uex' path='docs/doc[@for="DataTableCollection.UnregisterName"]/*' />
        /// <devdoc>
        /// Unregisters this name as no longer being used in the collection.  Called by Remove, All property, and
        /// Table.TableName property.  If the name is equivalent to the last proposed default namem, we walk backwards
        /// to find the next proper default name to hang out.
        /// </devdoc>
        internal void UnregisterName(string name) {
            if (NamesEqual(name, MakeName(defaultNameIndex - 1), true, dataSet.Locale) != 0) {
                do {
                    defaultNameIndex--;
                } while (defaultNameIndex > 1 &&
                         !Contains(MakeName(defaultNameIndex - 1)));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datasysattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataSysAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Data {
    using System;
    using System.ComponentModel;

    /// <include file='doc\DataSysAttribute.uex' path='docs/doc[@for="DataSysDescriptionAttribute"]/*' />
    /// <devdoc>
    ///    <para>
    ///       DescriptionAttribute marks a property, event, or extender with a
    ///       description. Visual designers can display this description when referencing
    ///       the member.
    ///    </para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class DataSysDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\DataSysAttribute.uex' path='docs/doc[@for="DataSysDescriptionAttribute.DataSysDescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        public DataSysDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\DataSysAttribute.uex' path='docs/doc[@for="DataSysDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = Res.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataviewlistener.cs ===
//------------------------------------------------------------------------------
// <copyright file="Select.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;
    using System.Collections;
    using System.Diagnostics;

    internal enum TargetEvent {
        IndexListChanged,
        ColumnCollectionChanged,
        ChildRelationCollectionChanged,
        ParentRelationCollectionChanged
    };

    internal sealed class DataViewListener {

        private WeakReference dvWeak;
        private Index index;

        internal DataViewListener(DataView dv) {
            this.dvWeak = new WeakReference(dv);
            this.index = null;
        }

        private void ChildRelationCollectionChanged(object sender, CollectionChangeEventArgs e) {
            DataView dv = (DataView) dvWeak.Target;
            if (dv != null) {
                dv.FireEvent(TargetEvent.ChildRelationCollectionChanged, sender, e);
            }
        }

        private void ParentRelationCollectionChanged(object sender, CollectionChangeEventArgs e) {
            DataView dv = (DataView) dvWeak.Target;
            if (dv != null) {
                dv.FireEvent(TargetEvent.ParentRelationCollectionChanged, sender, e);
            }
        }

        private void ColumnCollectionChanged(object sender, CollectionChangeEventArgs e) {
            DataView dv = (DataView) dvWeak.Target;
            if (dv != null) {
                dv.FireEvent(TargetEvent.ColumnCollectionChanged, sender, e);
            }
        }

        private void IndexListChanged(object sender, ListChangedEventArgs e) {
            DataView dv = (DataView) dvWeak.Target;
            if (dv != null) {
                dv.FireEvent(TargetEvent.IndexListChanged, sender, e);
            }
        }

        internal void RegisterMetaDataEvents(DataTable table) {
            if (table != null) {
                table.Columns.ColumnPropertyChanged            += new CollectionChangeEventHandler( ColumnCollectionChanged         );
                table.Columns.CollectionChanged                += new CollectionChangeEventHandler( ColumnCollectionChanged         );
                ((DataRelationCollection.DataTableRelationCollection)(table.ChildRelations)).RelationPropertyChanged   += new CollectionChangeEventHandler( ChildRelationCollectionChanged  );
                table.ChildRelations.CollectionChanged         += new CollectionChangeEventHandler( ChildRelationCollectionChanged  );
                ((DataRelationCollection.DataTableRelationCollection)(table.ParentRelations)).RelationPropertyChanged  += new CollectionChangeEventHandler( ParentRelationCollectionChanged );
                table.ParentRelations.CollectionChanged        += new CollectionChangeEventHandler( ParentRelationCollectionChanged );
		  AddListener(table);
            }
        }

        internal void UnregisterMetaDataEvents(DataTable table) {
            if (table != null) {
                table.Columns.ColumnPropertyChanged            -= new CollectionChangeEventHandler( ColumnCollectionChanged         );
                table.Columns.CollectionChanged                -= new CollectionChangeEventHandler( ColumnCollectionChanged         );
                ((DataRelationCollection.DataTableRelationCollection)(table.ChildRelations)).RelationPropertyChanged   -= new CollectionChangeEventHandler( ChildRelationCollectionChanged  );
                table.ChildRelations.CollectionChanged         -= new CollectionChangeEventHandler( ChildRelationCollectionChanged  );
                ((DataRelationCollection.DataTableRelationCollection)(table.ParentRelations)).RelationPropertyChanged  -= new CollectionChangeEventHandler( ParentRelationCollectionChanged );
                table.ParentRelations.CollectionChanged        -= new CollectionChangeEventHandler( ParentRelationCollectionChanged );
                RemoveListener(table);
            }
        }

        internal void RegisterListChangedEvent(Index index) {
            // TODO: do we realy need this lock? See considerations in the bug 55221
            lock(index) {
                this.index = index;
                index.AddRef();
                index.ListChanged += new ListChangedEventHandler( IndexListChanged );
            }
        }

        internal void UnregisterListChangedEvent() {
            Debug.Assert(this.index != null, "it should not be null here.");
            if (this.index != null) {
                lock(index) {
                    this.index.ListChanged -= new ListChangedEventHandler( IndexListChanged ); 
                    this.index.RemoveRef();
                    if (this.index.RefCount == 1)
                        this.index.RemoveRef();
                    this.index = null;
                }
            }
        }

        internal void CleanUp(DataTable table) {
             if (dvWeak.Target == null) {
                 UnregisterMetaDataEvents(table);
                 UnregisterListChangedEvent();
             }
        }

        private void AddListener(DataTable table) {
            lock (table.dvListeners) {
                table.dvListeners.Add(this);
            }
        }

        private void RemoveListener(DataTable table) {
            lock (table.dvListeners) {
                table.dvListeners.Remove(this);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\datatable.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataTable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.IO;
    using System.Text;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Xml;
    using System.Globalization;
    using System.Collections;
    using System.Drawing.Design;

    /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable"]/*' />
    /// <devdoc>
    ///    <para>Represents one table of in-memory data.</para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    DefaultProperty("TableName"),
    Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    DefaultEvent("RowChanging"),
    Serializable
    ]
    public class DataTable : MarshalByValueComponent, System.ComponentModel.IListSource, ISupportInitialize, ISerializable {
        private DataSet dataSet;
        private DataView defaultView = null;

        bool System.ComponentModel.IListSource.ContainsListCollection {
            get {
                return false;
            }
        }

        IList System.ComponentModel.IListSource.GetList() {
            return DefaultView;
        }
        
        // rows
        internal int nextRowID;
        internal DataRowCollection rowCollection;

        // columns
        private DataColumnCollection columnCollection;

        // constraints
        private ConstraintCollection constraintCollection;

        //SimpleContent implementation
        private int elementColumnCount = 0;

        // relations
        internal DataRelationCollection parentRelationsCollection;
        internal DataRelationCollection childRelationsCollection;

        // RecordManager
        internal RecordManager recordManager;

        // index mgmt
        internal ArrayList indexes; // haroona : Always refer to LiveIndexes peoperty whenever any need to update indexes.

        // props
        internal PropertyCollection extendedProperties = null;
        private string tableName = "";
        internal string tableNamespace = null;
        private string tablePrefix = "";
        internal bool caseSensitive = false;
        internal bool caseSensitiveAmbient = true;
        internal CultureInfo culture = null;
        internal DataFilter displayExpression;
        private CompareInfo compareInfo;
        internal CompareOptions compareFlags;
        internal bool fNestedInDataset = true;

        // XML properties
        internal string encodedTableName;           // For XmlDataDocument only
        internal DataColumn xmlText;            // text values of a complex xml element
        internal DataColumn _colUnique;
        internal bool textOnly = false;         // the table has only text value with possible attributes
        internal decimal minOccurs = 1;    // default = 1
        internal decimal maxOccurs = 1;    // default = 1
        internal bool repeatableElement = false;
        internal XmlQualifiedName typeName = XmlQualifiedName.Empty;

        // primary key info
        private static Int32[] zeroIntegers = new Int32[0];
        private static DataColumn[] zeroColumns = new DataColumn[0];
        internal UniqueConstraint primaryKey;
        internal int[] primaryIndex = zeroIntegers;
        private DataColumn[] delayedSetPrimaryKey = null;

        // Loading Schema and/or Data related optimization
        private ArrayList saveIndexes = null;
        private Index loadIndex;
        private bool savedEnforceConstraints = false;
        private bool inDataLoad  = false;
        private bool initialLoad;
        private bool schemaLoading = false;
        private bool fComputedColumns = true;
        private bool enforceConstraints = true;

        // Property Descriptor Cache for DataBinding
        private PropertyDescriptorCollection propertyDescriptorCollectionCache = null;
        
        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.fInitInProgress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected internal bool fInitInProgress = false;

        // Cache for relation that has this table as nested child table.
        private  DataRelation _nestedParentRelation = null;

        // events
        private bool mergingData = false;
        private DataRowChangeEventHandler onRowChangedDelegate;
        private DataRowChangeEventHandler onRowChangingDelegate;
        private DataRowChangeEventHandler onRowDeletingDelegate;
        private DataRowChangeEventHandler onRowDeletedDelegate;
        private DataColumnChangeEventHandler onColumnChangedDelegate;
        private DataColumnChangeEventHandler onColumnChangingDelegate;

        private PropertyChangedEventHandler onPropertyChangingDelegate;

        // misc
        private DataRowBuilder rowBuilder = null;
        private const String KEY_XMLSCHEMA = "XmlSchema";
        private const String KEY_XMLDIFFGRAM = "XmlDiffGram";
        private const String KEY_NAME = "TableName";

        internal ArrayList delayedViews = new ArrayList();
        internal ArrayList dvListeners = new ArrayList();


        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.DataTable"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.DataTable'/> class with no arguments.</para>
        /// </devdoc>
        public DataTable() {
            GC.SuppressFinalize(this);
            nextRowID = 1;
            recordManager = new RecordManager(this);
            Reset();
            rowBuilder = new DataRowBuilder(this, -1, -1);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.DataTable1"]/*' />
        /// <devdoc>
        /// <para>Intitalizes a new instance of the <see cref='System.Data.DataTable'/> class with the specified table
        ///    name.</para>
        /// </devdoc>
        public DataTable(string tableName) : this() {
            this.tableName = tableName == null ? "" : tableName;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.DataTable2"]/*' />
        protected DataTable(SerializationInfo info, StreamingContext context)
          : this()
        {
            string strSchema = (String)info.GetValue(KEY_XMLSCHEMA, typeof(System.String));
            string strData = (String)info.GetValue(KEY_XMLDIFFGRAM, typeof(System.String));

            if (strSchema != null) {
                DataSet ds = new DataSet();
                ds.ReadXmlSchema(new XmlTextReader( new StringReader( strSchema ) ) );
                
                Debug.Assert(ds.Tables.Count == 1, "There should be exactly 1 table here");
                DataTable table = ds.Tables[0];
                table.CloneTo(this, null);
                // this is to avoid the cascading rules
                // in the namespace
                this.Namespace = table.Namespace;
                  

                if (strData != null) {
                    ds.Tables.Remove(ds.Tables[0]);
                    ds.Tables.Add(this);
                    ds.ReadXml(new XmlTextReader( new StringReader( strData ) ), XmlReadMode.DiffGram);
                    ds.Tables.Remove(this);
                }
            }
        }

        internal ArrayList LiveIndexes {
            get {
                int i=0;
                while (i < indexes.Count) {
                    if (((Index)indexes[i]).RefCount == 1)
                        ((Index)indexes[i]).RemoveRef();
                    else
                        i++;
                }
                return indexes;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.CaseSensitive"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether string comparisons within the table are
        ///       case-sensitive.</para>
        /// </devdoc>
        [DataSysDescription(Res.DataTableCaseSensitiveDescr)]
        public bool CaseSensitive {
            get {
                if (caseSensitiveAmbient && dataSet != null)
                    return dataSet.CaseSensitive;
                return caseSensitive;
            }
            set {
                if (this.CaseSensitive != value || this.caseSensitive != value) {
                    bool oldValue = this.CaseSensitive;
                    bool oldCaseSensitiveAmbient = this.caseSensitiveAmbient;
                    this.caseSensitive = value;
                    caseSensitiveAmbient = false;
                    if (DataSet != null && !DataSet.ValidateCaseConstraint()) {
                        this.caseSensitiveAmbient = oldCaseSensitiveAmbient;
                        this.caseSensitive = oldValue;
                        throw ExceptionBuilder.CannotChangeCaseLocale();
                    } 
                    ResetIndexes();
                    foreach (Constraint constraint in Constraints)
                       constraint.CheckConstraint();
                }
                caseSensitiveAmbient = false;
            }
        }

        private void RecomputeCompareInfo() {
            compareInfo = Locale.CompareInfo;
            compareFlags = CompareOptions.None;

            if (!CaseSensitive)
                compareFlags |= CompareOptions.IgnoreCase | CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth;
        }

        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataTable.CaseSensitive'/> property to its default state.
        ///    </para>
        /// </devdoc>
        private void ResetCaseSensitive() {
            if (!caseSensitiveAmbient) {
                caseSensitiveAmbient = true;
                caseSensitive = false;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Data.DataTable.CaseSensitive'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeCaseSensitive() {
            return !caseSensitiveAmbient;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ChildRelations"]/*' />
        /// <devdoc>
        /// <para>Gets the collection of child relations for this <see cref='System.Data.DataTable'/>.</para>
        /// </devdoc>
        [
        Browsable(false), 
        DataSysDescription(Res.DataTableChildRelationsDescr),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public DataRelationCollection ChildRelations {
            get {
                if (childRelationsCollection == null)
                    childRelationsCollection = new DataRelationCollection.DataTableRelationCollection(this, false);
                return childRelationsCollection;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Columns"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of columns that belong to this table.</para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataTableColumnsDescr)
        ]
        public DataColumnCollection Columns {
            get {
                if (columnCollection == null) {
                    columnCollection = new DataColumnCollection(this);
                }
                return columnCollection;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataTable.Columns'/> property to its default state.
        ///    </para>
        /// </devdoc>
        private void ResetColumns() {
            Columns.Clear();
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Constraints"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of constraints maintained by this table.</para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataTableConstraintsDescr)
        ]
        public ConstraintCollection Constraints {
            get {
                if (constraintCollection == null) {
                    constraintCollection = new ConstraintCollection(this);
                }
                return constraintCollection;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataTable.Constraints'/> property to its default state.
        ///    </para>
        /// </devdoc>
        private void ResetConstraints() {
            Constraints.Clear();
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.DataSet"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.Data.DataSet'/> that this table belongs to.</para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), Browsable(false), DataSysDescription(Res.DataTableDataSetDescr)]
        public DataSet DataSet {
            get {
                return dataSet;
            }
        }

        /// <devdoc>
        /// Internal method for setting the DataSet pointer.
        /// </devdoc>
        internal void SetDataSet(DataSet dataSet) {
            if (this.dataSet != dataSet) {
                this.dataSet = dataSet;

                // Inform all the columns of the dataset being set.
                DataColumnCollection   cols = Columns;
                for (int i = 0; i < cols.Count; i++)
                    cols[i].OnSetDataSet();

                if (this.DataSet != null) {
                    defaultView = null;
                }
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.DefaultView"]/*' />
        /// <devdoc>
        ///    <para>Gets a customized view of the table which may include a
        ///       filtered view, or a cursor position.</para>
        /// </devdoc>
        [Browsable(false), DataSysDescription(Res.DataTableDefaultViewDescr)]
        public DataView DefaultView {
            get {
                if(defaultView == null) {
                    lock(this) {
                        if(defaultView == null) {
                            if (this.DataSet != null) {
                                defaultView = this.DataSet.DefaultViewManager.CreateDataView(this);
                            }
                            else {
                                defaultView = new DataView(this, true);
                            }
                        }
                    }
                }
                return defaultView;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.DisplayExpression"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the expression that will return a value used to represent
        ///       this table in UI.</para>
        /// </devdoc>
        [
        DefaultValue(""),
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataTableDisplayExpressionDescr)
        ]
        public string DisplayExpression {
            get {
                return(displayExpression != null ? displayExpression.Expression : "");
            }
            set {
                if (value != null && value.Length > 0) {
                    this.displayExpression = new DataFilter(value, this);
                }
                else {
                    this.displayExpression = null;
                }
            }
        }

        internal bool EnforceConstraints {
            get {
                if (dataSet != null)
                    return dataSet.EnforceConstraints;
                    
                return this.enforceConstraints;
            }
            set {
                Debug.Assert(dataSet == null, "The internal function only apply to standalone datatable only.");
                if (dataSet == null && this.enforceConstraints != value) 
                {
                    if (value)
                        EnableConstraints();
                    
                    this.enforceConstraints = value;
                }
            }
        }

        internal void EnableConstraints() 
        {
            bool errors = false;
            foreach (Constraint constr in Constraints) 
            {
                if (constr is UniqueConstraint) 
                    errors |= constr.IsConstraintViolated();
            }

            foreach (DataColumn column in Columns) {
	            if (!column.AllowDBNull) {
		            errors |= column.IsNotAllowDBNullViolated();
	            }
	            if (column.MaxLength >= 0) {
	            		errors |= column.IsMaxLengthViolated();
	            }
	        }

            if (errors) {
                this.EnforceConstraints = false;
                throw ExceptionBuilder.EnforceConstraint();
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ExtendedProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of customized user information.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data), 
        Browsable(false),
        DataSysDescription(Res.ExtendedPropertiesDescr)
        ]
        public PropertyCollection ExtendedProperties {
            get {
                if (extendedProperties == null) {
                    extendedProperties = new PropertyCollection();
                }
                return extendedProperties;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.HasErrors"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether there are errors in any of the rows in any of
        ///       the tables of the <see cref='System.Data.DataSet'/> to which the table belongs.</para>
        /// </devdoc>
        [Browsable(false), DataSysDescription(Res.DataTableHasErrorsDescr)]
        public bool HasErrors {
            get {
                for (int i = 0; i < Rows.Count; i++) {
                    if (Rows[i].HasErrors) {
                        return true;
                    }
                }
                return false;
            }
        }

        // TODO: this is public only because of COM+ bug that prohibits internals
        // from being shared throughout dll.

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Locale"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the locale information used to compare strings within the table.</para>
        /// </devdoc>
        [DataSysDescription(Res.DataTableLocaleDescr)]
        public CultureInfo Locale {
            get {
                if (culture != null)
                    return culture;
                if (dataSet != null)
                    return dataSet.Locale;
                return CultureInfo.CurrentCulture;
            }
            set {
                if (culture != value && (culture == null || (culture != null && !culture.Equals(value)))) {
                    CultureInfo oldLocale = culture;
                    this.culture = value;
                    if (DataSet != null && !DataSet.ValidateLocaleConstraint()) {
                        this.culture = oldLocale;
                        throw ExceptionBuilder.CannotChangeCaseLocale();
                    }

                    if (oldLocale == null && CultureInfo.CurrentCulture.Equals(value) || 
                        oldLocale != null && !oldLocale.Equals(value)) {
                        ResetIndexes();
                        foreach (Constraint constraint in Constraints)
                            constraint.CheckConstraint();
                    }
                }
            }
        }

        /// <devdoc>
        /// <para>Resets the <see cref='System.Data.DataTable.Locale'/> property to its default state.</para>
        /// </devdoc>
        private void ResetLocale() {
            if (culture != null) {
                CultureInfo oldLocale = this.Locale;
                this.culture = null;
                if (!oldLocale.Equals(this.Locale)) {
                    ResetIndexes();
                }
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Data.DataTable.Locale'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeLocale() {
            return(culture != null);
        }


        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.MinimumCapacity"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the initial starting size for this table.</para>
        /// </devdoc>
        [
        DefaultValue(50),
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataTableMinimumCapacityDescr)
        ]
        public int MinimumCapacity {
            get {
                return recordManager.MinimumCapacity;
            }
            set {
				if (value != recordManager.MinimumCapacity) {
					recordManager.MinimumCapacity = value;
				}
            }
        }

        internal int RecordCapacity {
            get {
                return recordManager.RecordCapacity;
            }
            set {
                recordManager.RecordCapacity = value;
            }
        }


        internal int ElementColumnCount {
            get {
                return elementColumnCount;
            }
            set {
                if ((value > 0) && (xmlText != null))
                    throw ExceptionBuilder.TableCannotAddToSimpleContent();
                else elementColumnCount = value;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ParentRelations"]/*' />
        /// <devdoc>
        /// <para>Gets the collection of parent relations for this <see cref='System.Data.DataTable'/>.</para>
        /// </devdoc>
        [
        Browsable(false), 
        DataSysDescription(Res.DataTableParentRelationsDescr),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public DataRelationCollection ParentRelations {
            get {
                if (parentRelationsCollection == null)
                    parentRelationsCollection = new DataRelationCollection.DataTableRelationCollection(this, true);
                return parentRelationsCollection;
            }
        }

        internal bool MergingData {
            get {
                return mergingData;
            }
            set {
                mergingData = value;
            }
        }

        internal DataRelation nestedParentRelation {
            get {
#if DEBUG
                if (_nestedParentRelation == null)
                    Debug.Assert(FindNestedParent() == null, "nestedParent cache is broken");
                else
                    Debug.Assert(FindNestedParent() == _nestedParentRelation.ParentTable, "nestedParent cache is broken");
#endif
                return _nestedParentRelation;
            }
        }

        internal bool SchemaLoading {
            get {
                return schemaLoading;
            }
            set {
                if (!value && schemaLoading) {
                    this.Columns.columnQueue = new ColumnQueue(this, this.Columns.columnQueue);
                }
                schemaLoading = value;
            }
        }

        internal void CacheNestedParent(DataRelation r) {
                _nestedParentRelation = r;
        }

        internal DataTable FindNestedParent() {
            DataTable parent = null;
            foreach(DataRelation relation in this.ParentRelations) {
                if(relation.Nested) {
                    Debug.Assert(parent == null, "we already have this table nested in two diferent tables");
                    parent = relation.ParentTable;
#if ! DEBUG
                    return parent;
#endif
                }
            }
            return parent;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.PrimaryKey"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets an array of columns that function as primary keys for the data
        ///       table.</para>
        /// </devdoc>
        [
        TypeConverter(typeof(PrimaryKeyTypeConverter)),
        DataSysDescription(Res.DataTablePrimaryKeyDescr),
        DataCategory(Res.DataCategory_Data),
        Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
        ]
        public DataColumn[] PrimaryKey {
            get {
                return(primaryKey != null) ? primaryKey.Columns : zeroColumns;
            }
            set {
                UniqueConstraint key = null;
                UniqueConstraint existingKey = null;

                // Loading with persisted property
                if (fInitInProgress && value != null) {
                    delayedSetPrimaryKey = value;
                    return;
                }

                if ((value != null) && (value.Length != 0)) {
                    int count = 0;
                    for (int i = 0; i < value.Length; i++) {
                        if (value[i] != null)
                            count++;
                        else
                            break;
                    }

                    if (count != 0) {
                        DataColumn[] newValue = value;
                        if (count != value.Length) {
                            newValue = new DataColumn[count];
                            for (int i = 0; i < count; i++)
                                newValue[i] = value[i];
                        }
                        key = new UniqueConstraint(newValue);
                        if (key.Table != this)
                            throw ExceptionBuilder.TableForeignPrimaryKey();
                    }
                }

                if (key == primaryKey || (key != null && key.Equals(primaryKey)))
                    return;

                // Use an existing UniqueConstraint that matches if one exists
                if ((existingKey = (UniqueConstraint)Constraints.FindConstraint(key)) != null) {
                    key.Columns.CopyTo(existingKey.Key.Columns, 0);
                    key = existingKey;
                }

                UniqueConstraint oldKey = primaryKey;
                primaryKey = null;
                if (oldKey != null) {
                    Constraints.Remove(oldKey);
                    oldKey.Key.GetSortIndex().RemoveRef();
                }

                // Add the key if there isnt an existing matching key in collection
                if (key != null && existingKey == null)
                    Constraints.Add(key);
                primaryKey = key;

                if (primaryKey != null) {
                    for(int i = 0; i < key.Columns.Length; i++)
                        key.Columns[i].AllowDBNull = false;
                    primaryKey.Key.GetSortIndex().AddRef();
                }

                Debug.Assert(Constraints.FindConstraint(primaryKey) == primaryKey, "PrimaryKey is not in ConstraintCollection");
                primaryIndex = (key != null) ? primaryIndex = key.Key.GetIndexDesc() : zeroIntegers;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ShouldSerializePrimaryKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Data.DataTable.PrimaryKey'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializePrimaryKey() {
            return(primaryKey != null);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ResetPrimaryKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataTable.PrimaryKey'/> property to its default state.
        ///    </para>
        /// </devdoc>
        private void ResetPrimaryKey() {
            PrimaryKey = null;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Rows"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of rows that belong to this table.</para>
        /// </devdoc>
        [Browsable(false), DataSysDescription(Res.DataTableRowsDescr)]
        public DataRowCollection Rows {
            get {
                if (rowCollection == null) {
                    rowCollection = new DataRowCollection(this);
                }
                return rowCollection;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.TableName"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the name of the table.</para>
        /// </devdoc>
        [
        RefreshProperties(RefreshProperties.All),
        DefaultValue(""),
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataTableTableNameDescr)
        ]
        public string TableName {
            get {
                return tableName;
            }
            set {
                if (value == null)
                    value = "";
                if (String.Compare(tableName, value, true, this.Locale) != 0) {
                    if (dataSet != null) {
                        if (value.Length == 0)
                            throw ExceptionBuilder.NoTableName();
                        if ((0 == String.Compare(value, dataSet.DataSetName, true, dataSet.Locale)) && !fNestedInDataset)
                           throw ExceptionBuilder.DatasetConflictingName(dataSet.DataSetName);

                        if (this.nestedParentRelation == null || this.nestedParentRelation.ParentTable.Columns.CanRegisterName(value)) {
                          dataSet.Tables.RegisterName(value);
                        } // if it cannot register the following line will throw exception
                          // otherwise is fine
                          
                        if (this.nestedParentRelation != null) {
                          this.nestedParentRelation.ParentTable.Columns.RegisterName(value, this);
                          this.nestedParentRelation.ParentTable.Columns.UnregisterName(this.TableName);
                        }
                        
                        if (tableName.Length != 0)
                            dataSet.Tables.UnregisterName(tableName);
                    }
                    RaisePropertyChanging("TableName");
                    tableName = value;
                    encodedTableName = null;
                }
                else if (String.Compare(tableName, value, false, this.Locale) != 0) {
                    RaisePropertyChanging("TableName");
                    tableName = value;
                    encodedTableName = null;
                }
            }
        }

        internal string EncodedTableName {
            get {
                if ( this.encodedTableName == null ) {
                    this.encodedTableName = XmlConvert.EncodeLocalName( this.TableName );
                }
                Debug.Assert( this.encodedTableName != null && this.encodedTableName != String.Empty );
                return this.encodedTableName;
            }
        }


        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Namespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the namespace for the <see cref='System.Data.DataTable'/>.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data), 
        DataSysDescription(Res.DataTableNamespaceDescr)
        ]
        public string Namespace {
            get {
                if (tableNamespace == null) {
                    if ((nestedParentRelation!=null) && (nestedParentRelation.ParentTable != this)) {
                        return nestedParentRelation.ParentTable.Namespace;
                    }
                    if (DataSet != null) {
                        return DataSet.Namespace;
                    }
                    return "";
                }
                return tableNamespace;
            }
            set {
                if(value != tableNamespace) {
                    DoRaiseNamespaceChange();
                }
                tableNamespace = value;
            }
        }


        internal void DoRaiseNamespaceChange(){
            RaisePropertyChanging("Namespace");
            // raise column Namespace change

            foreach (DataColumn col in Columns) 
                if (col._columnUri == null)
                    col.RaisePropertyChanging("Namespace");
            
            foreach (DataRelation rel in ChildRelations)
                if ((rel.Nested) && (rel.ChildTable != this))
                    rel.ChildTable.DoRaiseNamespaceChange();
        }
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Data.DataTable.Namespace'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeNamespace() {
            return(tableNamespace != null);
        }

        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataTable.Namespace'/> property to its default state.
        ///    </para>
        /// </devdoc>
        private void ResetNamespace() {
            this.Namespace = null;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.BeginInit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void BeginInit() {
            fInitInProgress = true;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.EndInit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EndInit() {
            if (dataSet == null || !dataSet.fInitInProgress) {
                Columns.FinishInitCollection();
                Constraints.FinishInitConstraints();
            }
            fInitInProgress = false; // haroona : 77890. It is must that we set off this flag after calling FinishInitxxx();
            if (delayedSetPrimaryKey != null) {
                PrimaryKey = delayedSetPrimaryKey;
                delayedSetPrimaryKey = null;
            }
            if (delayedViews.Count > 0) {
                foreach(Object dv in delayedViews) {
                    ((DataView)dv).EndInit();
                }
                delayedViews = new ArrayList();
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Prefix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(""), 
        DataCategory(Res.DataCategory_Data), 
        DataSysDescription(Res.DataTablePrefixDescr)
        ]
        public string Prefix {
            get { return tablePrefix;}
            set {
                if (value == null) {
                    value = "";
                }

		        if ((XmlConvert.DecodeName(value) == value) &&
                    (XmlConvert.EncodeName(value) != value))
                    throw ExceptionBuilder.InvalidPrefix(value);


                tablePrefix = value;
            }
        }

        internal virtual DataColumn XmlText {
            get {
                return xmlText;
            }
            set {
                if (xmlText != value) {
                    if (xmlText != null) {
                        if (value != null) {
                            throw ExceptionBuilder.MultipleTextOnlyColumns();
                        }
                        Columns.Remove(xmlText);
                    }
                    else {
                        Debug.Assert(value != null, "Value shoud not be null ??");
                        Debug.Assert(value.ColumnMapping == MappingType.SimpleContent, "should be text node here");
                        if (value != Columns[value.ColumnName])
                            Columns.Add(value);
                    }
                    xmlText = value;
                }
            }
        }

        internal decimal MaxOccurs {
            get {
                return maxOccurs;
            }
            set {
                maxOccurs = value;
            }
        }

        internal decimal MinOccurs {
            get {
                return minOccurs;
            }
            set {
                minOccurs = value;
            }
        }

        internal virtual object[] GetKeyValues(DataKey key, int record) {
            object[] keyValues = new object[key.Columns.Length];
            for (int i = 0; i < keyValues.Length; i++) {
                keyValues[i] = key.Columns[i][record];
            }
            return keyValues;
        }

        internal virtual void SetKeyValues(DataKey key, object[] keyValues, int record) {
            for (int i = 0; i < keyValues.Length; i++) {
                key.Columns[i][record] = keyValues[i];
            }
        }

        internal DataRow FindByIndex(Index ndx, object[] key) {
            Range range = ndx.FindRecords(key);
            if (range.IsNull) {
                return null;
            }
            return this.recordManager[ndx.GetRecord(range.Min)];
        }

        internal DataRow FindMergeTarget(DataRow row, DataKey key, Index ndx) {
            DataRow targetRow = null;

            // Primary key match
            if (key != null) {
                Debug.Assert(ndx != null);
                int   findRecord = (row.oldRecord == -1) ? row.newRecord : row.oldRecord;
                object[] values = row.Table.recordManager.GetKeyValues(findRecord, key);
                targetRow = FindByIndex(ndx, values);
            }
            return targetRow;
        }

        private void SetMergeRecords(DataRow row, int newRecord, int oldRecord, DataRowAction action) {
            if (newRecord != -1) {
                SetNewRecord(row, newRecord, action, true);
                SetOldRecord(row, oldRecord);
            }
            else {
                SetOldRecord(row, oldRecord);
                if (row.newRecord != -1) {
                    Debug.Assert(action == DataRowAction.Delete, "Unexpected SetNewRecord action in merge function.");
                    SetNewRecord(row, newRecord, action, true);
                }
            }
        }
        
        internal DataRow MergeRow(DataRow row, DataRow targetRow, bool preserveChanges, Index idxSearch) {
             if (targetRow == null) {
                targetRow = this.NewEmptyRow();
                targetRow.oldRecord = recordManager.ImportRecord(row.Table, row.oldRecord);
                targetRow.newRecord = targetRow.oldRecord;
                if(row.oldRecord != row.newRecord) {
                    targetRow.newRecord = recordManager.ImportRecord(row.Table, row.newRecord);
                }
                InsertRow(targetRow, -1);
            }
            else { 
                DataRowState saveRowState = targetRow.RowState;
                int saveIdxRecord = (saveRowState == DataRowState.Added) ? targetRow.newRecord : saveIdxRecord = targetRow.oldRecord;
 		        int newRecord;
 		        int oldRecord;
                if (targetRow.oldRecord == targetRow.newRecord && row.oldRecord == row.newRecord ) {
                    // unchanged row merging with unchanged row
                    oldRecord = targetRow.oldRecord;
                    newRecord = (preserveChanges) ? recordManager.CopyRecord(this, oldRecord, -1) : targetRow.newRecord;
	             oldRecord = recordManager.CopyRecord(row.Table, row.oldRecord, targetRow.oldRecord);
       	      SetMergeRecords(targetRow, newRecord, oldRecord, DataRowAction.Change);
                }
                else if (row.newRecord == -1) {
                    // Incoming row is deleted
                    oldRecord = targetRow.oldRecord;
                    if (preserveChanges)
                	  newRecord = targetRow.oldRecord == targetRow.newRecord ? recordManager.CopyRecord(this, oldRecord, -1) : targetRow.newRecord;
		      else
	                newRecord = -1;
	             oldRecord = recordManager.CopyRecord(row.Table, row.oldRecord, oldRecord);

                    // Change index record, need to update index
                    if (saveIdxRecord != ((saveRowState == DataRowState.Added) ? newRecord : oldRecord)) {
                        SetMergeRecords(targetRow, newRecord, oldRecord, (newRecord == -1) ? DataRowAction.Delete : DataRowAction.Change);
                        idxSearch.Reset();
                        saveIdxRecord = ((saveRowState == DataRowState.Added) ? newRecord : oldRecord);
                    } else {
                        SetMergeRecords(targetRow, newRecord, oldRecord, (newRecord == -1) ? DataRowAction.Delete : DataRowAction.Change);
                    }
                } 
                else {
                	// incoming row is added, modified or unchanged (targetRow is not unchanged)
                    oldRecord = targetRow.oldRecord;
                    newRecord = targetRow.newRecord;
                    if ( targetRow.oldRecord == targetRow.newRecord)
                        newRecord = recordManager.CopyRecord(this, oldRecord, -1);
                    oldRecord = recordManager.CopyRecord(row.Table, row.oldRecord, oldRecord);

                    if (!preserveChanges) { 
                        newRecord = recordManager.CopyRecord(row.Table, row.newRecord, newRecord);
                    }
                    SetMergeRecords(targetRow, newRecord, oldRecord, DataRowAction.Change);
                }

                if (saveRowState == DataRowState.Added && targetRow.oldRecord != -1)
                    idxSearch.Reset();
                Debug.Assert(saveIdxRecord == ((saveRowState == DataRowState.Added) ? targetRow.newRecord : targetRow.oldRecord), "oops, you change index record without noticing it");
            }

            // Merge all errors
            if (row.HasErrors) {
                if (targetRow.RowError.Length == 0) {
                    targetRow.RowError = row.RowError;
                } else {
                    targetRow.RowError += " ]:[ " + row.RowError;
                }
                DataColumn[] cols = row.GetColumnsInError();

                for (int i = 0; i < cols.Length; i++) {
                    DataColumn col = targetRow.Table.Columns[cols[i].ColumnName];
                    targetRow.SetColumnError(col, row.GetColumnError(cols[i]));
                }
            }else {
                if (!preserveChanges) {
                    targetRow.ClearErrors();
                }
            }

            return targetRow;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.AcceptChanges"]/*' />
        /// <devdoc>
        /// <para>Commits all the changes made to this table since the last time <see cref='System.Data.DataTable.AcceptChanges'/> was called.</para>
        /// </devdoc>
        public void AcceptChanges() {
            int c = Rows.Count;
            DataRow[] oldRows = NewRowArray(c);
            Rows.CopyTo(oldRows, 0);
            saveIndexes = LiveIndexes;
            indexes = new ArrayList();

            try {
                for (int i = 0; i < c; i++)
                    oldRows[i].AcceptChanges();
            }
            finally {
                if (saveIndexes != null) {
                    for (int i = 0; i < saveIndexes.Count; i++)
                        ((Index)saveIndexes[i]).Reset();
                }
                indexes = saveIndexes;
                saveIndexes = null;
            }
        }

	/// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.CreateInstance"]/*' />
	protected virtual DataTable CreateInstance() {
		return (DataTable) Activator.CreateInstance(this.GetType(), true);
	}

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Clone"]/*' />
        public virtual DataTable Clone() {
            return Clone(null);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Clone"]/*' />
        internal DataTable Clone(DataSet cloneDS) {
            DataTable clone = CreateInstance();
            if (clone.Columns.Count > 0) // haroona : To clean up all the schema in strong typed dataset.
                clone.Reset();
            return CloneTo(clone, cloneDS);
        }

        private DataTable CloneTo(DataTable clone, DataSet cloneDS) {
            Debug.Assert(clone != null, "The table passed in has to be newly created empty DataTable.");
                            
            // set All properties
            clone.tableName = tableName;
            
            clone.tableNamespace = tableNamespace;
            clone.tablePrefix = tablePrefix;
            clone.fNestedInDataset = fNestedInDataset;
            
            clone.caseSensitive = caseSensitive;
            clone.caseSensitiveAmbient = caseSensitiveAmbient;
            clone.culture = culture;
            clone.displayExpression = displayExpression;
            clone.compareInfo = compareInfo;
            clone.compareFlags = compareFlags;
            clone.typeName = typeName; //enzol
            clone.repeatableElement = repeatableElement; //enzol
            clone.MinimumCapacity = MinimumCapacity;

            // add all columns
            DataColumnCollection clmns = this.Columns;
            for (int i = 0; i < clmns.Count; i++) {
                clone.Columns.Add(clmns[i].Clone());
            }

            // add all expressions if Clone is invoked only on DataTable otherwise DataSet.Clone will assign expressions after creating all relationships.
            if (cloneDS == null) {
                for (int i = 0; i < clmns.Count; i++) {
                    clone.Columns[clmns[i].ColumnName].Expression = clmns[i].Expression;
                }
            }

            // Create PrimaryKey
            if (PrimaryKey.Length > 0) {
                int keyLength = PrimaryKey.Length;
                DataColumn[] key = new DataColumn[keyLength];

                for (int i = 0; i < keyLength; i++) {
                    key[i] = clone.Columns[PrimaryKey[i].Ordinal];
                }
                clone.PrimaryKey = key;
            }
            
            // now clone all unique constraints    

            // Rename first
            for (int j = 0; j < Constraints.Count; j++)  {
                if (Constraints[j] is ForeignKeyConstraint)
                    continue;
                UniqueConstraint clonedConstraint = ((UniqueConstraint)Constraints[j]).Clone(clone);
                Constraint oldConstraint = clone.Constraints.FindConstraint(clonedConstraint);
                if (oldConstraint != null)
                    oldConstraint.ConstraintName = Constraints[j].ConstraintName;
            }

            // then add
            for (int j = 0; j < Constraints.Count; j++)  {
                if (Constraints[j] is ForeignKeyConstraint)
                    continue;
                if (! clone.Constraints.Contains(Constraints[j].ConstraintName, true)) {
                    clone.Constraints.Add(((UniqueConstraint)Constraints[j]).Clone(clone));
                }
            }

            // ...Extended Properties...
            if (this.extendedProperties != null) {
                foreach(Object key in this.extendedProperties.Keys) {
                    clone.ExtendedProperties[key]=this.extendedProperties[key];
                }
            }

            return clone;
        }
        

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Copy"]/*' />
        public DataTable Copy(){
            DataTable destTable = this.Clone();

            foreach (DataRow row in Rows)
                CopyRow(destTable, row);
            
            return destTable;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ColumnChanging"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a value has been submitted for this column.</para>
        /// </devdoc>
        [DataCategory(Res.DataCategory_Data), DataSysDescription(Res.DataTableColumnChangingDescr)]
        public event DataColumnChangeEventHandler ColumnChanging {
            add {
                onColumnChangingDelegate += value;
            }
            remove {
                onColumnChangingDelegate -= value;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ColumnChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [DataCategory(Res.DataCategory_Data), DataSysDescription(Res.DataTableColumnChangedDescr)]
        public event DataColumnChangeEventHandler ColumnChanged {
            add  {
                onColumnChangedDelegate += value;
            }
            remove {
                onColumnChangedDelegate -= value;
            }
        }

        internal event PropertyChangedEventHandler PropertyChanging {
            add {
                onPropertyChangingDelegate += value;
            }
            remove {
                onPropertyChangingDelegate -= value;
            }
        }
        
        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.RowChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs after a row in the table has been successfully edited.
        ///    </para>
        /// </devdoc>
        [DataCategory(Res.DataCategory_Data), DataSysDescription(Res.DataTableRowChangedDescr)]
        public event DataRowChangeEventHandler RowChanged {
            add {
                onRowChangedDelegate += value;
            }
            remove {
                onRowChangedDelegate -= value;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.RowChanging"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the <see cref='System.Data.DataRow'/> is changing.
        ///    </para>
        /// </devdoc>
        [DataCategory(Res.DataCategory_Data), DataSysDescription(Res.DataTableRowChangingDescr)]
        public event DataRowChangeEventHandler RowChanging {
            add {
                onRowChangingDelegate += value;
            }
            remove {
                onRowChangingDelegate -= value;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.RowDeleting"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs before a row in the table is
        ///       about to be deleted.
        ///    </para>
        /// </devdoc>
        [DataCategory(Res.DataCategory_Data), DataSysDescription(Res.DataTableRowDeletingDescr)]
        public event DataRowChangeEventHandler RowDeleting {
            add {
                onRowDeletingDelegate += value;
            }
            remove {
                onRowDeletingDelegate -= value;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.RowDeleted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs after a row in the
        ///       table has been deleted.
        ///    </para>
        /// </devdoc>
        [DataCategory(Res.DataCategory_Data), DataSysDescription(Res.DataTableRowDeletedDescr)]
        public event DataRowChangeEventHandler RowDeleted {
            add {
                onRowDeletedDelegate += value;
            }
            remove {
                onRowDeletedDelegate -= value;
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Site"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override ISite Site {
            get {
                return base.Site;
            }
            set {
                ISite oldSite = Site;
                if (value == null && oldSite != null) {
                    IContainer cont = oldSite.Container;

                    if (cont != null) {
                        for (int i = 0; i < Columns.Count; i++) {
                            if (Columns[i].Site != null) {
                                cont.Remove(Columns[i]);
                            }
                        }
                    }
                }
                base.Site = value;
            }
        }

        internal DataRow AddRecords(int oldRecord, int newRecord) {
            DataRow row;
            if (oldRecord == -1 && newRecord == -1)
            {
                row = NewRow();
                AddRow(row);
            }
            else 
            {
                row = NewEmptyRow();
                row.oldRecord = oldRecord;
                row.newRecord = newRecord;
                InsertRow(row, -1);                
            }
            return row;
        }

        internal void AddRow(DataRow row) {
            AddRow(row, -1);
        }

        internal void AddRow(DataRow row, int proposedID) {
            InsertRow(row, proposedID, -1);
        }

        internal void InsertRow(DataRow row, int proposedID, int pos) {
            if (row == null) {
                throw ExceptionBuilder.ArgumentNull("row");
            }
            if (row.Table != this) {
                throw ExceptionBuilder.RowAlreadyInOtherCollection();
            }
            if (row.rowID != -1) {
                throw ExceptionBuilder.RowAlreadyInTheCollection();
            }
            row.BeginEdit(); // ensure something's there.

            int record = row.tempRecord;
            row.tempRecord = -1;
            
            if (proposedID == -1) {
                    proposedID = nextRowID;
            }

            try {
                row.rowID = proposedID;
                SetNewRecord(row, record, DataRowAction.Add, false);
            }
            catch (Exception e) {
                ExceptionBuilder.Trace(e);

                row.rowID = -1;
                // TODO Figure out why I restore tempRecord on an add and not on a change?
                row.tempRecord = record;
                throw e;
            }



            if (pos == -1)
                Rows.ArrayAdd(row);
            else 
                Rows.ArrayInsert(row, pos);

            if (nextRowID <= proposedID)
                nextRowID = proposedID + 1;

            if (fComputedColumns)
                columnCollection.CalculateExpressions(row, DataRowAction.Add);
        }

        internal void CheckNotModifying(DataRow row) {
            if (row.tempRecord != -1) {
                row.EndEdit();
                //throw ExceptionBuilder.ModifyingRow();
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Clear"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Clears the table of all data.</para>
        /// </devdoc>
        public void Clear() {
            if (dataSet != null)
                dataSet.OnClearFunctionCalled(this);
            
            if (dataSet != null && dataSet.EnforceConstraints) {

                for (ParentForeignKeyConstraintEnumerator constraints = new ParentForeignKeyConstraintEnumerator(dataSet, this); constraints.GetNext();) {
                    ForeignKeyConstraint constraint = constraints.GetForeignKeyConstraint();
                    constraint.CheckCanClearParentTable(this);
                }
            }

            for (int i = 0; i < Rows.Count; i++) {
                DataRow row = Rows[i];
                if (row.oldRecord != -1) {
                    recordManager.FreeRecord(row.oldRecord);
                    row.oldRecord = -1;
                }
                if (row.tempRecord != -1) {
                    recordManager.FreeRecord(row.tempRecord);
                    row.tempRecord = -1;
                }
                if (row.newRecord != -1) {
                    recordManager.FreeRecord(row.newRecord);
                    row.newRecord = -1;
                }
                row.rowID = -1;
            }
            
            Rows.ArrayClear();
            recordManager.Clear();
            ResetIndexes();
        }

        internal void RaiseColumnChanging(DataRow row, DataColumnChangeEventArgs e) {
            if (row.rowID != -1) {
                e.Column.CheckReadOnly(row);
            }
            OnColumnChanging(e);
        }

        internal void RaiseColumnChanged(DataRow row, DataColumnChangeEventArgs e) {
            OnColumnChanged(e);
        }

        internal void CascadeAll(DataRow row, DataRowAction action) {
            if (DataSet != null && DataSet.fEnableCascading) {
                for (ParentForeignKeyConstraintEnumerator constraints = new ParentForeignKeyConstraintEnumerator(dataSet, this); constraints.GetNext();) {
                    constraints.GetForeignKeyConstraint().CheckCascade(row, action);
                }
            }
        }

	internal void CleanUpDVListeners() {
		lock (dvListeners) {
			DataViewListener[] listeners = new DataViewListener[dvListeners.Count];
			dvListeners.CopyTo(listeners);

			for (int i = 0; i < listeners.Length; i++)
				listeners[i].CleanUp(this);
		}
	}
	
        internal void CommitRow(DataRow row) {
            // Fire Changing event
            DataRowChangeEventArgs drcevent = new DataRowChangeEventArgs(row, DataRowAction.Commit);
            OnRowChanging(drcevent);

            if (!inDataLoad)
                CascadeAll(row, DataRowAction.Commit);
                
            SetOldRecord(row, row.newRecord);

            OnRowChanged(drcevent);
        }

        internal int Compare(string s1, string s2, CompareOptions options) {
            object obj1 = s1;
            object obj2 = s2;
            if (obj1 == obj2)
                return 0;
            if (obj1 == null)
                return -1;
            if (obj2 == null)
                return 1;

            int leng1 = s1.Length;
            int leng2 = s2.Length;

            for (; leng1 > 0; leng1--) {
                if (s1[leng1-1] != 0x20 && s1[leng1-1] != 0x3000) // 0x3000 is Ideographic Whitespace
                    break;
            }
            for (; leng2 > 0; leng2--) {
                if (s2[leng2-1] != 0x20 && s2[leng2-1] != 0x3000)
                    break;
            }

            return compareInfo.Compare(s1, 0, leng1, s2, 0, leng2, compareFlags | options);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Compute"]/*' />
        /// <devdoc>
        ///    <para>Computes the given expression on the current rows that pass the filter criteria.</para>
        /// </devdoc>
        public object Compute(string expression, string filter) {
            DataRow[] rows = Select(filter, "", DataViewRowState.CurrentRows);
            DataExpression expr = new DataExpression(expression, this);
            return expr.Evaluate(rows);
        }

        internal void CopyRow(DataTable table, DataRow row)
        {
            int oldRecord = -1, newRecord = -1;
            
            if (row == null)
                return;

            if (row.oldRecord != -1) {
                oldRecord = table.recordManager.ImportRecord(row.Table, row.oldRecord);
            }
            if (row.newRecord != -1) {
                if (row.newRecord != row.oldRecord) {
                    newRecord = table.recordManager.ImportRecord(row.Table, row.newRecord);
                }
                else 
                    newRecord = oldRecord;
            }

            DataRow targetRow = table.AddRecords(oldRecord, newRecord);

            if (row.HasErrors) {
                targetRow.RowError = row.RowError;

                DataColumn[] cols = row.GetColumnsInError();

                for (int i = 0; i < cols.Length; i++) {
                    DataColumn col = targetRow.Table.Columns[cols[i].ColumnName];
                    targetRow.SetColumnError(col, row.GetColumnError(cols[i]));
                }
            }

       }


        internal void DeleteRow(DataRow row) {
            if (row.newRecord == -1) {
                throw ExceptionBuilder.RowAlreadyDeleted();
            }

            // Store.PrepareForDelete(row);
            SetNewRecord(row, -1, DataRowAction.Delete, false);
        }

        private void CheckPrimaryKey() {
            if (primaryKey == null) throw ExceptionBuilder.TableMissingPrimaryKey();
        }

        internal DataRow FindByPrimaryKey(object[] values) {
            CheckPrimaryKey();
            return FindRow(primaryKey.Key, values);
        }

        internal DataRow FindByPrimaryKey(object value) {
            CheckPrimaryKey();
            return FindRow(primaryKey.Key, value);
        }

        private DataRow FindRow(DataKey key, object[] values) {
            Index index = GetIndex(NewIndexDesc(key));
            Range range = index.FindRecords(values);
            if (range.IsNull)
                return null;
            return recordManager[index.GetRecord(range.Min)];
        }

        private DataRow FindRow(DataKey key, object value) {
            Index index = GetIndex(NewIndexDesc(key));
            Range range = index.FindRecords(value);
            if (range.IsNull)
                return null;
            return recordManager[index.GetRecord(range.Min)];
        }

        internal string FormatSortString(Int32[] indexDesc) {
            string result = "";
            foreach (int d in indexDesc) {
                if(result.Length != 0) 
                    result += ", ";
                result += Columns[DataKey.ColumnOrder(d)].ColumnName;
                if (DataKey.SortDecending(d))
                    result += " DESC";
            }
            return result;
        }

        internal void FreeRecord(int record) {
            recordManager.FreeRecord(record);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.GetChanges"]/*' />
        public DataTable GetChanges() {
            DataTable dtChanges = this.Clone();
            DataRow row = null;

            for (int i = 0; i < Rows.Count; i++) {
                row = Rows[i];
                if (row.oldRecord != row.newRecord)
                    dtChanges.ImportRow(row);
            }

            if (dtChanges.Rows.Count == 0)
                return null;

            return dtChanges;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.GetChanges1"]/*' />
        public DataTable GetChanges(DataRowState rowStates) 
        {
            DataTable dtChanges = this.Clone();
            DataRow row = null;

            // check that rowStates is valid DataRowState
            Debug.Assert(Enum.GetUnderlyingType(typeof(DataRowState)) == typeof(Int32), "Invalid DataRowState type");

            for (int i = 0; i < Rows.Count; i++) {
                row = Rows[i];
                if ((row.RowState & rowStates) != 0)
                    dtChanges.ImportRow(row);
            }

            if (dtChanges.Rows.Count == 0)
                return null;

            return dtChanges;      
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.GetErrors"]/*' />
        /// <devdoc>
        /// <para>Returns an array of <see cref='System.Data.DataRow'/> objects that contain errors.</para>
        /// </devdoc>
        public DataRow[] GetErrors() {
            ArrayList errorList = new ArrayList();

            for (int i = 0; i < Rows.Count; i++) {
                DataRow row = Rows[i];
                if (row.HasErrors) {
                    errorList.Add(row);
                }
            }
            DataRow[] temp = NewRowArray(errorList.Count);
            errorList.CopyTo(temp, 0);
            return temp;
        }

        internal Index GetIndex(Int32[] indexDesc) {
            return GetIndex(indexDesc, DataViewRowState.CurrentRows, (IFilter)null);
        }

        internal Index GetIndex(Int32[] indexDesc, DataViewRowState recordStates, string filterExpression) {
            IFilter filter = (filterExpression != null && filterExpression.Length > 0) ? new DataFilter(filterExpression, this) : null;
            return GetIndex(indexDesc, recordStates, filter);
        }

        internal Index GetIndex(string sort, DataViewRowState recordStates, string filterExpression) {
            return GetIndex(ParseSortString(sort), recordStates, filterExpression);
        }

        internal Index GetIndex(string sort, DataViewRowState recordStates, IFilter rowFilter) {
            return GetIndex(ParseSortString(sort), recordStates, rowFilter);
        }

        internal Index GetIndex(Int32[] indexDesc, DataViewRowState recordStates, IFilter rowFilter) {
            for (int i = 0; i < indexes.Count; i++) {
                Index index = (Index)indexes[i];
                if (index != null) {
                    if (index.Equal(indexDesc, recordStates, rowFilter)) {
                        return index;
                    }
                }
            }
            return new Index(this, indexDesc, recordStates, rowFilter);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData (SerializationInfo info, StreamingContext context) 
        {
            Boolean fCreatedDataSet = false;
            if (dataSet == null) {
                DataSet ds = new DataSet("tmpDataSet");
                ds.Tables.Add(this);
                fCreatedDataSet = true;
            }

            info.AddValue(KEY_XMLSCHEMA, dataSet.GetXmlSchemaForRemoting(this));
            info.AddValue(KEY_XMLDIFFGRAM, dataSet.GetRemotingDiffGram(this));

            if (fCreatedDataSet)
                dataSet.Tables.Remove(this);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ImportRow"]/*' />
        public void ImportRow(DataRow row)
        {
            int oldRecord = -1, newRecord = -1;
            
            if (row == null)
                return;

            if (row.oldRecord != -1) {
                oldRecord = recordManager.ImportRecord(row.Table, row.oldRecord);
            }
            if (row.newRecord != -1) {
                if (row.newRecord != row.oldRecord) {
                    newRecord = recordManager.ImportRecord(row.Table, row.newRecord);
                }
                else 
                    newRecord = oldRecord;
            }

            if (oldRecord != -1 || newRecord != -1) {
                DataRow targetRow = AddRecords(oldRecord, newRecord);

                if (row.HasErrors) {
                    targetRow.RowError = row.RowError;

                    DataColumn[] cols = row.GetColumnsInError();

                    for (int i = 0; i < cols.Length; i++) {
                        DataColumn col = targetRow.Table.Columns[cols[i].ColumnName];
                        targetRow.SetColumnError(col, row.GetColumnError(cols[i]));
                    }
                }
            }

       }

        internal void InsertRow(DataRow row, int proposedID) {
            InsertRow(row, proposedID, null);
        }

        internal void InsertRow(DataRow row, int proposedID, DataRow rowParent) {
            if (row.Table != this) {
                throw ExceptionBuilder.RowAlreadyInOtherCollection();
            }
            if (row.rowID != -1) {
                throw ExceptionBuilder.RowAlreadyInTheCollection();
            }

            if (row.oldRecord == -1 && row.newRecord == -1) {
                throw ExceptionBuilder.RowEmpty();
            }

            if (proposedID == -1)
                proposedID = nextRowID;

            row.rowID = proposedID;
            if (nextRowID <= proposedID)
                nextRowID = proposedID + 1;

            if (rowParent != null) {
                DataRelationCollection relations = DataSet.GetParentRelations(this);
                for (int i = 0; i < relations.Count; i++) {
                    if (relations[i].ParentTable == rowParent.Table && relations[i].Nested) {
                        relations[i].SetParentRowRecords(row, rowParent);
                        break;
                    }
                }
            }

            DataRowChangeEventArgs drcevent = new DataRowChangeEventArgs(row, DataRowAction.Add);

            if (row.newRecord != -1) {
                row.tempRecord = row.newRecord;
                row.newRecord = -1;

                try {
                    RaiseRowChanging(drcevent);
                }
                catch (Exception e) {
                    ExceptionBuilder.Trace(e);

                    row.tempRecord = -1;
                    throw e;
                }

                row.newRecord = row.tempRecord;
                row.tempRecord = -1;
            }

            if (row.oldRecord != -1)
                recordManager[row.oldRecord] = row;

            if (row.newRecord != -1)
                recordManager[row.newRecord] = row;

            if (row.oldRecord == row.newRecord) {
                RecordStateChanged(row.oldRecord, DataViewRowState.None, DataViewRowState.Unchanged);
            }
            else {
                RecordStateChanged(row.oldRecord, DataViewRowState.None, row.GetRecordState(row.oldRecord),
                                   row.newRecord, DataViewRowState.None, row.GetRecordState(row.newRecord));
            }

            try {
                RaiseRowChanged(drcevent);
            }
            catch (Exception) {
            }

            Rows.ArrayAdd(row);
        }

        private int[] NewIndexDesc(DataKey key) {
            Debug.Assert(key != null);
            Int32[] indexDesc = key.GetIndexDesc();
            Int32[] newIndexDesc = new Int32[indexDesc.Length];
            Array.Copy(indexDesc, 0, newIndexDesc, 0, indexDesc.Length);
            return newIndexDesc;
        }

        internal int NewRecord() {
            return NewRecord(-1);
        }
        
        internal int NewUninitializedRecord() {
            return recordManager.NewRecordBase();
        }

        internal virtual int NewRecordFromArray(object[] value) {
            int record = recordManager.NewRecordBase();
            int valCount = value.Length;
            int colCount = Columns.Count;
            if (colCount < valCount) {
                throw ExceptionBuilder.ValueArrayLength();
            }

            for (int i = 0; i < valCount; i++) {
                if (null != value[i]) {
                    Columns[i][record] = value[i];
                }
                else {
                    Columns[i].Init(record, true);  // Increase AutoIncrementCurrent
                }
            }
            for (int i = valCount; i < colCount; i++) {
                Columns[i].Init(record, true);
            }
            return record;
        }

        internal virtual int NewRecord(int sourceRecord) {
            int record = recordManager.NewRecordBase();

            DataColumnCollection collection = Columns;
            int count = collection.Count;
            if (-1 == sourceRecord) {
                for (int i = 0; i < count; ++i) {
                    collection[i].Init(record);
                }
            }
            else {
                for (int i = 0; i < count; ++i) {
                    collection[i].Copy(sourceRecord, record);
                }
            }
            return record;
        }

        internal DataRow NewEmptyRow() {
            rowBuilder._record = -1;
            DataRow dr = NewRowFromBuilder( rowBuilder );
            if (dataSet != null)
                DataSet.OnDataRowCreated( dr );
            return dr;
        }

        private DataRow NewUninitializedRow() {
            DataRow dr = NewRow(NewUninitializedRecord());
            return dr;
        }
        
        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.NewRow"]/*' />
        /// <devdoc>
        /// <para>Creates a new <see cref='System.Data.DataRow'/>
        /// with the same schema as the table.</para>
        /// </devdoc>
        public DataRow NewRow() {
            DataRow dr = NewRow(-1);
            return dr;
        }

        // Only initialize DataRelation mapping columns (approximately hidden columns)
        internal DataRow CreateEmptyRow() {
            DataRow row = this.NewUninitializedRow();

            foreach( DataColumn c in this.Columns ) {
                if (!XmlToDatasetMap.IsMappedColumn(c)) {
                    if (!c.AutoIncrement) {
                        if (c.AllowDBNull) {
                            row[c] = DBNull.Value;
                        }
                        else if(c.DefaultValue!=null){
                            row[c] = c.DefaultValue;
                        }
                    }
                    else {
                        c.Init(row.tempRecord);
                    }
                }
            }
            return row;
        }

        //enzol: Do never change this to public.
        // we have it internal here since it's used also by XmlDataDocument
        internal DataRow CreateDefaultRow() {
            DataRow row = this.NewUninitializedRow();

            foreach( DataColumn c in this.Columns ) {
                if (!c.AutoIncrement) {
                    if (c.AllowDBNull) {
                        row[c] = DBNull.Value;
                    }
                    else if(c.DefaultValue!=null){
                        row[c] = c.DefaultValue;
                    }
                }
                else {
                    c.Init(row.tempRecord);
                }       
            }
            return row;
        }

        internal DataRow NewRow(int record) {
            if (-1 == record) {
                record = NewRecord(-1);
            }
            
            rowBuilder._record = record;
            DataRow row = NewRowFromBuilder( rowBuilder );
            recordManager[record] = row;

            if (dataSet != null)
                DataSet.OnDataRowCreated( row );

            return row;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.NewRowFromBuilder"]/*' />
        // This is what a subclassed dataSet overrides to create a new row.
        protected virtual DataRow NewRowFromBuilder(DataRowBuilder builder) {
            return new DataRow(builder);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.GetRowType"]/*' />
        /// <devdoc>
        ///    <para>Gets the row type.</para>
        /// </devdoc>
        protected virtual Type GetRowType() {
            return typeof(DataRow);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.NewRowArray"]/*' />
        protected internal DataRow[] NewRowArray(int size) {
            // UNDONE return new DataRow[size];
            Type rowType = GetRowType();
            return(DataRow[]) Array.CreateInstance(rowType, size);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.OnColumnChanging"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Data.DataTable.ColumnChanging'/> event.</para>
        /// </devdoc>
        protected virtual void OnColumnChanging(DataColumnChangeEventArgs e) {
            // intentionally allow exceptions to bubble up.  We haven't committed anything yet.
            if (onColumnChangingDelegate != null)
                onColumnChangingDelegate(this, e);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.OnColumnChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnColumnChanged(DataColumnChangeEventArgs e) {
            if (onColumnChangedDelegate != null)
                onColumnChangedDelegate(this, e);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.OnPropertyChanging"]/*' />
        protected internal virtual void OnPropertyChanging(PropertyChangedEventArgs pcevent) {
            if (onPropertyChangingDelegate != null)
                onPropertyChangingDelegate(this, pcevent);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.OnRemoveColumn"]/*' />
        /// <devdoc>
        /// <para>Notifies the <see cref='System.Data.DataTable'/> that a <see cref='System.Data.DataColumn'/> is
        ///    being removed.</para>
        /// </devdoc>
        protected internal virtual void OnRemoveColumn(DataColumn column) {
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.OnRowChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Data.DataTable.RowChanged'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnRowChanged(DataRowChangeEventArgs e) {
            if (onRowChangedDelegate != null) {
                onRowChangedDelegate(this, e);
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.OnRowChanging"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Data.DataTable.RowChanging'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnRowChanging(DataRowChangeEventArgs e) {
            if (onRowChangingDelegate != null)
                onRowChangingDelegate(this, e);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.OnRowDeleting"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Data.DataTable.OnRowDeleting'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnRowDeleting(DataRowChangeEventArgs e) {
            if (onRowDeletingDelegate != null)
                onRowDeletingDelegate(this, e);
        }


        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.OnRowDeleted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Data.DataTable.OnRowDeleted'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnRowDeleted(DataRowChangeEventArgs e) {
            if (onRowDeletedDelegate != null)
                onRowDeletedDelegate(this, e);
        }

        internal Int32[] ParseSortString(string sortString) {
            Int32[] indexDesc = null;

            try {
                if (sortString == null || sortString.Length == 0) {
                    indexDesc = zeroIntegers; //primaryIndex;
                }
                else {
                    string[] split = sortString.Split(new char[] { ','});
                    indexDesc = new Int32[split.Length];

                    for (int i = 0; i < split.Length; i++) {
                        string current = split[i].Trim();

                        // handle ASC and DESC.
                        int length = current.Length;
                        bool ascending = true;
                        if (length >= 5 && String.Compare(current, length - 4, " ASC", 0, 4, true, CultureInfo.InvariantCulture) == 0) {
                            current = current.Substring(0, length - 4).Trim();
                        }
                        else if (length >= 6 && String.Compare(current, length - 5, " DESC", 0, 5, true, CultureInfo.InvariantCulture) == 0) {
                            ascending = false;
                            current = current.Substring(0, length - 5).Trim();
                        }

                        // handle brackets.
                        if (current.StartsWith("[")) {
                            if (current.EndsWith("]")) {
                                current = current.Substring(1, current.Length - 2);
                            }
                            else {
                                throw ExceptionBuilder.InvalidSortString(split[i]);
                            }
                        }

                        // find the column.
                        DataColumn column = Columns[current];
                        if(column == null) {
                            throw ExceptionBuilder.ColumnOutOfRange(current);
                        }
                        indexDesc[i] = column.Ordinal | (ascending ? 0 : DataKey.DESCENDING);
                    }
                }
            }
            catch (Exception e) {
#if DEBUG
                if (CompModSwitches.Data_Sorts.TraceVerbose) {
                    Debug.WriteLine("Couldn't parse sort string: " + sortString);
                }
#endif
                throw ExceptionBuilder.Trace(e);
            }

#if DEBUG
            if (CompModSwitches.Data_Sorts.TraceVerbose) {
                string result = "Sort string parse: " + sortString + " -> ";
                for (int i = 0; i < indexDesc.Length; i++) {
                    result += indexDesc[i].ToString("X") + " ";
                }
                Debug.WriteLine(result);
            }
#endif

            return indexDesc;
        }

        internal void RaisePropertyChanging(string name) {
            OnPropertyChanging(new PropertyChangedEventArgs(name));
        }

        // Notify all indexes that record changed.
        // Only called when Error was changed.
        internal void RecordChanged(int record) {
            Debug.Assert (record != -1, "Record number must be given");
            int n = LiveIndexes.Count;
            while (--n >= 0) {
               ((Index)indexes[n]).RecordChanged(record);
            }
        }

        internal void RecordStateChanged(int record, DataViewRowState oldState, DataViewRowState newState) {
            int numIndexes = LiveIndexes.Count;
            for (int i = 0; i < numIndexes; i++) {
                ((Index)indexes[i]).RecordStateChanged(record, oldState, newState);
            }
            // System.Data.XML.Store.Store.OnROMChanged(record, oldState, newState);
        }


        internal void RecordStateChanged(int record1, DataViewRowState oldState1, DataViewRowState newState1,
                                         int record2, DataViewRowState oldState2, DataViewRowState newState2) {
            int numIndexes = LiveIndexes.Count;
            // sdub: The checks can be moved out of loop!
            for (int i = 0; i < numIndexes; i++) {
                if (record1 != -1 && record2 != -1)
                    ((Index)indexes[i]).RecordStateChanged(record1, oldState1, newState1,
                                                           record2, oldState2, newState2);
                else if (record1 != -1)
                    ((Index)indexes[i]).RecordStateChanged(record1, oldState1, newState1);
                else if (record2 != -1)
                    ((Index)indexes[i]).RecordStateChanged(record2, oldState2, newState2);
            }
            // System.Data.XML.Store.Store.OnROMChanged(record1, oldState1, newState1, record2, oldState2, newState2);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.RejectChanges"]/*' />
        /// <devdoc>
        ///    <para>Rolls back all changes that have been made to the table
        ///       since it was loaded, or the last time <see cref='System.Data.DataTable.AcceptChanges'/> was called.</para>
        /// </devdoc>
        public void RejectChanges() {
            int c = Rows.Count;
            DataRow[] oldRows = NewRowArray(c);
            Rows.CopyTo(oldRows, 0);

            for (int i = 0; i < c; i++) {
                RollbackRow(oldRows[i]);
            }
        }

        internal void RemoveRow(DataRow row, bool check) {
            if (row.rowID == -1) {
                throw ExceptionBuilder.RowAlreadyRemoved();
            }

            if (check && dataSet != null) {
                for (ParentForeignKeyConstraintEnumerator constraints = new ParentForeignKeyConstraintEnumerator(dataSet, this); constraints.GetNext();) {
                    constraints.GetForeignKeyConstraint().CheckCanRemoveParentRow(row);
                }
            }

            int oldRecord = row.oldRecord;
            int newRecord = row.newRecord;

            DataViewRowState oldRecordStatePre = row.GetRecordState(oldRecord);
            DataViewRowState newRecordStatePre = row.GetRecordState(newRecord);

            row.oldRecord = -1;
            row.newRecord = -1;

            if (oldRecord == newRecord) {
                oldRecord = -1;
            }

            RecordStateChanged(oldRecord, oldRecordStatePre, DataViewRowState.None,
                               newRecord, newRecordStatePre, DataViewRowState.None);

            if (oldRecord != -1) {
                FreeRecord(oldRecord);
            }
            if (newRecord != -1) {
                FreeRecord(newRecord);
            }

            row.rowID = -1;
            Rows.ArrayRemove(row);
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Reset"]/*' />
        // Resets the table back to its original state.
        public virtual void Reset() {
            RecomputeCompareInfo();
            Clear();
            ResetConstraints();

            DataRelationCollection dr = this.ParentRelations;
            int count = dr.Count;
              while (count > 0) {
               count--;
               dr.RemoveAt(count);
            }

            dr = this.ChildRelations;
            count = dr.Count;
              while (count > 0) {
               count--;
               dr.RemoveAt(count);
            }

            Columns.Clear();
            indexes = new ArrayList(); // haroona : Does it realy mean that we have got rid of all the indexes from memory ???
        }

        internal void ResetIndexes() {
            RecomputeCompareInfo();

            if (indexes == null)
                return;

            int numIndexes = LiveIndexes.Count;
            for (int i = 0; i < numIndexes; i++) {
                ((Index)indexes[i]).Reset();
            }
        }

        internal void RollbackRow(DataRow row) {
            row.CancelEdit();
            SetNewRecord(row, row.oldRecord, DataRowAction.Rollback, false);
        }

        private void RaiseRowChanged(DataRowChangeEventArgs e) {
            if (UpdatingCurrent(e.Row, e.Action)) {
                try {
                    OnRowChanged(e);
                }
                catch (Exception f) { // swallow changed exceptions.
                    ExceptionBuilder.Trace(f);
                }
            }
            // check if we deleting good row
            else if (DataRowAction.Delete == e.Action && e.Row.newRecord == -1) {
                OnRowDeleted(e);
            }
        }

        private void RaiseRowChanging(DataRowChangeEventArgs e) {
            // compute columns.
            DataColumnCollection collection = Columns;
            DataRow eRow = e.Row;
            DataRowAction eAction = e.Action;

            if ((fComputedColumns) && (eAction != DataRowAction.Add))
                collection.CalculateExpressions(eRow, eAction);

            // check all constraints
            if (EnforceConstraints) {
                foreach(DataColumn column in collection)
                        column.CheckColumnConstraint(eRow, eAction);
 
                foreach(Constraint constraint in Constraints)
                        constraint.CheckConstraint(eRow, eAction);
            }
    
            // $$anandra.  Check this event out. May be an issue.
            if (UpdatingCurrent(eRow, eAction)) {
                eRow.inChangingEvent = true;

                // don't catch
                try {
                    OnRowChanging(e);
                }
                finally {
                    eRow.inChangingEvent = false;
                }
            }
            // check if we deleting good row
            else if (DataRowAction.Delete == eAction && eRow.newRecord != -1) {
                eRow.inDeletingEvent = true;
                // don't catch
                try {
                    OnRowDeleting(e);
                }
                finally {
                    eRow.inDeletingEvent = false;
                }
            }

            if (!inDataLoad) {
                // cascade things...
                if (!MergingData && eAction != DataRowAction.Nothing)
                    CascadeAll(eRow, eAction);
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Select"]/*' />
        /// <devdoc>
        /// <para>Returns an array of all <see cref='System.Data.DataRow'/> objects.</para>
        /// </devdoc>
        public DataRow[] Select() {
            return new Select(this, "", "", DataViewRowState.CurrentRows).SelectRows();
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Select1"]/*' />
        /// <devdoc>
        /// <para>Returns an array of all <see cref='System.Data.DataRow'/> objects that match the filter criteria in order of
        ///    primary key (or lacking one, order of addition.)</para>
        /// </devdoc>
        public DataRow[] Select(string filterExpression) {
            return new Select(this, filterExpression, "", DataViewRowState.CurrentRows).SelectRows();
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Select2"]/*' />
        /// <devdoc>
        /// <para>Returns an array of all <see cref='System.Data.DataRow'/> objects that match the filter criteria, in the the
        ///    specified sort order.</para>
        /// </devdoc>
        public DataRow[] Select(string filterExpression, string sort) {
            return new Select(this, filterExpression, sort, DataViewRowState.CurrentRows).SelectRows();
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.Select3"]/*' />
        /// <devdoc>
        /// <para>Returns an array of all <see cref='System.Data.DataRow'/> objects that match the filter in the order of the
        ///    sort, that match the specified state.</para>
        /// </devdoc>
        public DataRow[] Select(string filterExpression, string sort, DataViewRowState recordStates) {
            return new Select(this, filterExpression, sort, recordStates).SelectRows();
        }

        // this is the event workhorse... it will throw the changing/changed events
        // and update the indexes. Used by change, add, delete, revert.
        internal void SetNewRecord(DataRow row, int proposedRecord, DataRowAction action, bool isInMerge) {
            Debug.Assert(row != null, "Row can't be null.");

            if (row.tempRecord != proposedRecord) {
                // $HACK: for performance reasons, EndUpdate calls SetNewRecord with tempRecord == proposedRecord
                if (!inDataLoad) {
                    row.CheckInTable();
                    CheckNotModifying(row);
                }
                if (proposedRecord == row.newRecord) {
                    if (isInMerge) {
                        DataRowChangeEventArgs drcevent0 = new DataRowChangeEventArgs(row, action);
                        try {
                            RaiseRowChanged(drcevent0);
                        }
                        catch (Exception e) { // eat this.
                           ExceptionBuilder.Trace(e);
                        }
                    }
                    return;
                }

                Debug.Assert(!row.inChangingEvent, "How can this row be in an infinite loop?");

                row.tempRecord = proposedRecord;
            }
            DataRowChangeEventArgs drcevent = new DataRowChangeEventArgs(row, action);

            try {
                RaiseRowChanging(drcevent);
            }
            catch (Exception e) {                
                row.tempRecord = -1;
                throw ExceptionBuilder.Trace(e);
            }

            row.tempRecord = -1;

            int currentRecord = row.newRecord;
            // if we're deleting, then the oldRecord value will change, so need to track that if it's distinct from the newRecord.
            int secondRecord = (proposedRecord != -1 ?
                                proposedRecord :
                                (row.oldRecord != row.newRecord ?
                                 row.oldRecord :
                                 -1));
           
            // Check whether we need to update indexes            
            if (LiveIndexes.Count != 0) {
                DataViewRowState currentRecordStatePre = row.GetRecordState(currentRecord);
                DataViewRowState secondRecordStatePre = row.GetRecordState(secondRecord);

                row.newRecord = proposedRecord;
                if (proposedRecord != -1)
                    this.recordManager[proposedRecord] = row;

                DataViewRowState currentRecordStatePost = row.GetRecordState(currentRecord);
                DataViewRowState secondRecordStatePost = row.GetRecordState(secondRecord);

                RecordStateChanged(currentRecord, currentRecordStatePre, currentRecordStatePost,
                                  secondRecord, secondRecordStatePre, secondRecordStatePost);
            }
            else {
                row.newRecord = proposedRecord;
                if (proposedRecord != -1)
                    this.recordManager[proposedRecord] = row;
            }

            if (currentRecord != -1 && currentRecord != row.oldRecord)
                FreeRecord(currentRecord);

            if (row.RowState == DataRowState.Detached && row.rowID != -1) {
                RemoveRow(row, false);
            }
                
            try {
                RaiseRowChanged(drcevent);
            }
            catch (Exception e) { // eat this.
               ExceptionBuilder.Trace(e);
            }
        }

        // this is the event workhorse... it will throw the changing/changed events
        // and update the indexes.  Right now, used only by Commit.
        internal void SetOldRecord(DataRow row, int proposedRecord) {
            if (!inDataLoad) {
                row.CheckInTable();
                CheckNotModifying(row);
            }
            
            if (proposedRecord == row.oldRecord)
                return;

            int originalRecord = row.oldRecord;

            // Check whether we need to update indexes            
            if (LiveIndexes.Count != 0) {
                DataViewRowState originalRecordStatePre = row.GetRecordState(originalRecord);
                DataViewRowState proposedRecordStatePre = row.GetRecordState(proposedRecord);

                row.oldRecord = proposedRecord;
                if (proposedRecord != -1)
                    this.recordManager[proposedRecord] = row;

                DataViewRowState originalRecordStatePost = row.GetRecordState(originalRecord);
                DataViewRowState proposedRecordStatePost = row.GetRecordState(proposedRecord);

                RecordStateChanged(originalRecord, originalRecordStatePre, originalRecordStatePost,
                                   proposedRecord, proposedRecordStatePre, proposedRecordStatePost);
            }
            else {
                row.oldRecord = proposedRecord;
                if (proposedRecord != -1)
                    this.recordManager[proposedRecord] = row;
            }

            if (originalRecord != -1 && originalRecord != row.newRecord)
                FreeRecord(originalRecord);

            if (row.RowState == DataRowState.Detached && row.rowID != -1) {
                RemoveRow(row, false);
            }
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.ToString"]/*' />
        /// <devdoc>
        /// <para>Returns the <see cref='System.Data.DataTable.TableName'/> and <see cref='System.Data.DataTable.DisplayExpression'/>, if there is one as a concatenated string.</para>
        /// </devdoc>
        public override string ToString() {
            if (this.displayExpression == null)
                return this.TableName;
            else
                return this.TableName + " + " + this.DisplayExpression;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.BeginLoadData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void BeginLoadData() {
            if (inDataLoad)
                return;
                
            inDataLoad = true;
            loadIndex  = null;
            initialLoad = (Rows.Count == 0);
            if(initialLoad) {
                saveIndexes = LiveIndexes;
                indexes = new ArrayList();
            }else {
                if (primaryKey != null)
                    loadIndex = primaryKey.Key.GetSortIndex(DataViewRowState.OriginalRows);
                if(loadIndex != null) {
                    loadIndex.AddRef();
                }
            }

            // Search for computed columns
            fComputedColumns = false;
            for (int i = 0; i < Columns.Count; i++) {
                if (Columns[i].Computed) {
                    fComputedColumns = true;
                    break;
                }
            }
            if (DataSet != null) {
                savedEnforceConstraints = DataSet.EnforceConstraints;
                DataSet.EnforceConstraints = false;
            }
            else
                this.EnforceConstraints = false;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.EndLoadData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EndLoadData() {
            if (!inDataLoad)
                return;
                
            if(loadIndex != null) {
                loadIndex.RemoveRef();
            }

            loadIndex  = null;
            inDataLoad = false;

            if(saveIndexes != null) {
                foreach(Index ndx in saveIndexes) {
                    ndx.Reset();
                }
                indexes = saveIndexes;
                saveIndexes = null;
            }

            fComputedColumns = true;
            if (DataSet != null)
                DataSet.EnforceConstraints = savedEnforceConstraints;
            else
                this.EnforceConstraints = true;
        }

        /// <include file='doc\DataTable.uex' path='docs/doc[@for="DataTable.LoadDataRow"]/*' />
        /// <devdoc>
        ///    <para>Finds and updates a specific row. If no matching
        ///       row is found, a new row is created using the given values.</para>
        /// </devdoc>
        public DataRow LoadDataRow(object[] values, bool fAcceptChanges) {
            DataRow row;
            if (inDataLoad) {
                int record = NewRecordFromArray(values);
                if (loadIndex != null) {
                    int result = loadIndex.FindRecord(record);
                    if (result != -1) {
                        int resultRecord = loadIndex.GetRecord(result);
                        row = recordManager[resultRecord];
                        Debug.Assert (row != null, "Row can't be null for index record");
                        row.CancelEdit();
                        if (row.RowState == DataRowState.Deleted)
                            SetNewRecord(row, row.oldRecord, DataRowAction.Rollback, false);
                        // SetNewRecord(row, record, DataRowAction.Change, fAcceptChanges);
                        SetNewRecord(row, record, DataRowAction.Change, false);
                        if (fAcceptChanges)
                            row.AcceptChanges();
                        return row;
                    }
                }
                row = NewRow(record);
                // AddNewRow(row, fAcceptChanges);
                AddRow(row);
                if (fAcceptChanges)
                    row.AcceptChanges();
                return row;
            }
            else {
                // In case, BeginDataLoad is not called yet
                row = UpdatingAdd(values);
                if (fAcceptChanges)
                    row.AcceptChanges();
                return row;
            }
        }

        internal DataRow UpdatingAdd(object[] values) {
            Index index = null;
            if (this.primaryKey != null) {
                index = this.primaryKey.Key.GetSortIndex(DataViewRowState.OriginalRows);
            }

            if (index != null) {
                int record = NewRecordFromArray(values);
                int result = index.FindRecord(record);
                if (result != -1) {
                    int resultRecord = index.GetRecord(result);
                    DataRow row = this.recordManager[resultRecord];
                    Debug.Assert (row != null, "Row can't be null for index record");
                    row.RejectChanges();
                    row.SetNewRecord(record);                            
                    return row;
                }
                DataRow row2 = NewRow(record);
                Rows.Add(row2);
                return row2;
            }

            return Rows.Add(values);
        }
        
        internal bool UpdatingCurrent(DataRow row, DataRowAction action) {
            return(action == DataRowAction.Add || action == DataRowAction.Change ||
                   action == DataRowAction.Rollback);
//                (action == DataRowAction.Rollback && row.tempRecord != -1));
}

        internal DataColumn AddUniqueKey() {
            if (_colUnique != null)
                return _colUnique;

            // check to see if we can use already existant PrimaryKey
            if (PrimaryKey.Length == 1)
                // We have one-column primary key, so we can use it in our heirarchical relation
                return PrimaryKey[0];

            // add Unique, but not primaryKey to the table

            string keyName = XMLSchema.GenUniqueColumnName(TableName + "_Id", this);
            DataColumn key = new DataColumn(keyName, typeof(Int32), null, MappingType.Hidden);
            key.Prefix = tablePrefix;
            key.AutoIncrement = true;
            key.AllowDBNull = false;
            key.Unique = true;
            Columns.Add(key);
            if (PrimaryKey.Length == 0)
                PrimaryKey = new DataColumn[] {
                    key
                };

            _colUnique = key;
            return _colUnique;
        }

        internal DataColumn AddForeignKey(DataColumn parentKey) {
            Debug.Assert(parentKey != null, "AddForeignKey: Invalid paramter.. related primary key is null");

            string      keyName = XMLSchema.GenUniqueColumnName(parentKey.ColumnName, this);
            DataColumn  foreignKey = new DataColumn(keyName, parentKey.DataType, null, MappingType.Hidden);
            Columns.Add(foreignKey);

            return foreignKey;
        }

        internal void UpdatePropertyDescriptorCollectionCache() {
            int columnsCount   = Columns.Count;
            int relationsCount = ChildRelations.Count;
            PropertyDescriptor[] props = new PropertyDescriptor[columnsCount + relationsCount]; {
                for (int i = 0; i < columnsCount; i++) {
                    props[i] = new DataColumnPropertyDescriptor(Columns[i]);
                }
                for (int i = 0; i < relationsCount; i++) {
                    props[columnsCount + i] = new DataRelationPropertyDescriptor(ChildRelations[i]);
                }
            }
            propertyDescriptorCollectionCache = new PropertyDescriptorCollection(props);
        }

        /// <devdoc>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.  The returned array of properties will be
        ///     filtered by the given set of attributes.
        /// </devdoc>
        internal PropertyDescriptorCollection GetPropertyDescriptorCollection(Attribute[] attributes) {
            if (propertyDescriptorCollectionCache == null)
                UpdatePropertyDescriptorCollectionCache();
            return propertyDescriptorCollectionCache;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataset.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                             
//------------------------------------------------------------------------------

// Set in SOURCES file now... 
// [assembly:System.Runtime.InteropServices.ComVisible(false)]
namespace System.Data {
    using System;
    using System.Text;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Collections;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Xml.Schema;

    /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an in-memory cache of data.
    ///    </para>
    /// </devdoc>
    [
    DefaultProperty("DataSetName"),
    ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, " + AssemblyRef.MicrosoftVSDesigner),
    Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, " + AssemblyRef.MicrosoftVSDesigner),
    Serializable
    ]
    public class DataSet : MarshalByValueComponent, System.ComponentModel.IListSource, IXmlSerializable, ISupportInitialize, ISerializable {

        DataViewManager defaultViewManager;

        bool System.ComponentModel.IListSource.ContainsListCollection {
            get {
                return true;
            }
        }

        IList System.ComponentModel.IListSource.GetList() {
            return DefaultViewManager;
        }

        // Public Collections
        private DataTableCollection tableCollection       = null;
        private DataRelationCollection relationCollection = null;
        internal PropertyCollection extendedProperties = null;
        private string dataSetName = "NewDataSet";
        private string _datasetPrefix = String.Empty;
        internal string namespaceURI = string.Empty;
        private bool caseSensitive   = false;
        private CultureInfo culture   = new CultureInfo(1033);
        private bool enforceConstraints = true;
        private const String KEY_XMLSCHEMA = "XmlSchema";
        private const String KEY_XMLDIFFGRAM = "XmlDiffGram";

        // Internal definitions
        internal bool fInReadXml = false;
        internal bool fInLoadDiffgram = false;
        internal bool fTopLevelTable = false;
        internal bool fInitInProgress = false;
        internal bool fEnableCascading = true;
        internal bool fIsSchemaLoading = false;
        internal Hashtable rowDiffId = null;
        private bool fBoundToDocument;        // for XmlDataDocument

        // Events
        private PropertyChangedEventHandler onPropertyChangingDelegate;
        private MergeFailedEventHandler onMergeFailed;
        private DataRowCreatedEventHandler  onDataRowCreated;   // Internal for XmlDataDocument only
        private DataSetClearEventhandler  onClearFunctionCalled;   // Internal for XmlDataDocument only

        private static DataTable[] zeroTables = new DataTable[0];

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.DataSet"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.DataSet'/> class.</para>
        /// </devdoc>
        public DataSet() {
            GC.SuppressFinalize(this);
            // Set default locale            
            Locale = CultureInfo.CurrentCulture;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.DataSet1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of a <see cref='System.Data.DataSet'/>
        /// class with the given name.</para>
        /// </devdoc>
        public DataSet(string dataSetName)
          : this()
        {
            this.DataSetName = dataSetName;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.DataSet2"]/*' />
        protected DataSet(SerializationInfo info, StreamingContext context)
          : this()
        {
            string strSchema = (String)info.GetValue(KEY_XMLSCHEMA, typeof(System.String));
            string strData = (String)info.GetValue(KEY_XMLDIFFGRAM, typeof(System.String));

            if (strSchema != null && strData != null) {
                this.ReadXmlSchema(new XmlTextReader( new StringReader( strSchema ) ), true );
                this.ReadXml(new XmlTextReader( new StringReader( strData ) ), XmlReadMode.DiffGram);
            }
        }
        
        internal void FailedEnableConstraints() {
            this.EnforceConstraints = false;
            throw ExceptionBuilder.EnforceConstraint();
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.CaseSensitive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether string
        ///       comparisons within <see cref='System.Data.DataTable'/>
        ///       objects are
        ///       case-sensitive.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(false),
        DataSysDescription(Res.DataSetCaseSensitiveDescr)
        ]
        public bool CaseSensitive {
            get {
                return caseSensitive;
            }
            set {
                if (this.caseSensitive != value) 
                {
                    bool oldValue = this.caseSensitive;
                    this.caseSensitive = value;
                    if (!ValidateCaseConstraint()) {
                        this.caseSensitive = oldValue;
                        throw ExceptionBuilder.CannotChangeCaseLocale();
                    } 
                    
                    foreach (DataTable table in Tables) {
                        if (table.caseSensitiveAmbient) {
                            table.ResetIndexes();
                            foreach (Constraint constraint in table.Constraints)
                                constraint.CheckConstraint();
                        }
                    }
                }
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.DefaultViewManager"]/*' />
        /// <devdoc>
        /// <para>Gets a custom view of the data contained by the <see cref='System.Data.DataSet'/> , one
        ///    that allows filtering, searching, and navigating through the custom data view.</para>
        /// </devdoc>
        [Browsable(false), DataSysDescription(Res.DataSetDefaultViewDescr)]
        public DataViewManager DefaultViewManager {
            get {
                if (defaultViewManager == null) {
                    lock(this) {
                        if (defaultViewManager == null) {
                            defaultViewManager = new DataViewManager(this, true);
                        }
                    }
                }
                return defaultViewManager;
            }
        }
        
        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.EnforceConstraints"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether constraint rules are followed when
        ///       attempting any update operation.</para>
        /// </devdoc>
        [DefaultValue(true), DataSysDescription(Res.DataSetEnforceConstraintsDescr)]
        public bool EnforceConstraints {
            get {
                return enforceConstraints;
            }
            set {
                if (this.enforceConstraints != value) 
                {
                    if (value)
                        EnableConstraints();
                    
                    this.enforceConstraints = value;
                }
            }
        }

        internal void EnableConstraints() 
        {
            bool errors = false;
            for (ConstraintEnumerator constraints = new ConstraintEnumerator(this); constraints.GetNext();) 
            {
                Constraint constraint = (Constraint) constraints.GetConstraint();
                errors |= constraint.IsConstraintViolated();
            }

            foreach (DataTable table in Tables) {
                foreach (DataColumn column in table.Columns) {
                    if (!column.AllowDBNull) {
                        errors |= column.IsNotAllowDBNullViolated();
                    }
                    if (column.MaxLength >= 0) {
                        errors |= column.IsMaxLengthViolated();
                    }
                }
            }

            if (errors)
                this.FailedEnableConstraints();
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.DataSetName"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets the name of this <see cref='System.Data.DataSet'/> .</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        DataSysDescription(Res.DataSetDataSetNameDescr)
        ]
        public string DataSetName {
            get {
                return dataSetName;
            }
            set {
                if (value != dataSetName) {
                    if (value == null || value.Length == 0)
                        throw ExceptionBuilder.SetDataSetNameToEmpty();
                    DataTable conflicting = Tables[value];
                    if ((conflicting != null) && (!conflicting.fNestedInDataset))
                        throw ExceptionBuilder.SetDataSetNameConflicting(value);
                RaisePropertyChanging("DataSetName");
                this.dataSetName = value;
            }
        }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Namespace"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
        DefaultValue(""),
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataSetNamespaceDescr)
        ]
        public string Namespace {
            get {
                return namespaceURI;
            }
            set {
                if (value == null)
                    value = String.Empty;
                if (value != namespaceURI) {
                RaisePropertyChanging("Namespace");
                    foreach (DataTable dt in Tables) {
                        if ((dt.nestedParentRelation == null) && (dt.tableNamespace == null))
                            dt.DoRaiseNamespaceChange();
                        if ((dt.nestedParentRelation != null) && (dt.nestedParentRelation.ChildTable != dt))
                            dt.DoRaiseNamespaceChange();
                    }
                    namespaceURI = value;


                    if (value == String.Empty)
                        _datasetPrefix=String.Empty;
                    }
            }
        }

        internal Hashtable RowDiffId {
            get {   
                if (rowDiffId == null)
                    rowDiffId = new Hashtable();
                return rowDiffId;
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Prefix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(""),
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataSetPrefixDescr)
        ]
        public string Prefix {
            get { return _datasetPrefix;}
            set {
                if (value == null)
                    value = String.Empty;

                if ((XmlConvert.DecodeName(value) == value) &&
                    (XmlConvert.EncodeName(value) != value))
                    throw ExceptionBuilder.InvalidPrefix(value);


                if (value != _datasetPrefix) {
                    RaisePropertyChanging("Prefix");
                    _datasetPrefix = value;
                }
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ExtendedProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets the collection of custom user information.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data), 
        Browsable(false),
        DataSysDescription(Res.ExtendedPropertiesDescr)
        ]
        public PropertyCollection ExtendedProperties {
            get {
                if (extendedProperties == null) {
                    extendedProperties = new PropertyCollection();
                }
                return extendedProperties;
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.HasErrors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether there are errors in any
        ///       of the rows in any of the tables of this <see cref='System.Data.DataSet'/> .
        ///    </para>
        /// </devdoc>
        [Browsable(false), DataSysDescription(Res.DataSetHasErrorsDescr)]
        public bool HasErrors {
            get {
                for (int i = 0; i < Tables.Count; i++) {
                    if (Tables[i].HasErrors)
                        return true;
                }
                return false;
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Locale"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the locale information used to compare strings within the table.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataSetLocaleDescr)
        ]
        public CultureInfo Locale {
            get {
                return culture;
            }
            set {
                if (value != null) {
                    if (!culture.Equals(value)) {
                        CultureInfo oldLocale = this.culture;
                        this.culture = value;

                        if (!ValidateLocaleConstraint()) {
                            this.Locale = oldLocale;
                            throw ExceptionBuilder.CannotChangeCaseLocale();
                        } 

                        foreach (DataTable table in Tables) {
                            if (table.culture == null) {
                                table.ResetIndexes();
                                foreach (Constraint constraint in table.Constraints)
                                    constraint.CheckConstraint();
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Site"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override ISite Site {
            get {
                return base.Site;
            }
            set {
                ISite oldSite = Site;
                if (value == null && oldSite != null) {
                    IContainer cont = oldSite.Container;

                    if (cont != null) {
                        for (int i = 0; i < Tables.Count; i++) {
                            if (Tables[i].Site != null) {
                                cont.Remove(Tables[i]);
                            }
                        }
                    }
                }
                base.Site = value;
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataSet.Locale'/>
        ///       property to the current system locale.
        ///    </para>
        /// </devdoc>
        private void ResetLocale()
        {
            CultureInfo oldCulture = culture;
            // this.culture = CultureInfo(Microsoft.Win32.Interop.Lang.GetSystenDefaultLCID());
            this.culture = new CultureInfo(1033);
            if (!oldCulture.Equals(Locale)) {
                for (int i = 0; i < Tables.Count; i++) 
                {
                    if (!Tables[i].Locale.Equals(this.Locale)) 
                        Tables[i].ResetIndexes();
                }
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Data.DataSet.Locale'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeLocale() {
            return(culture != new CultureInfo(1033));
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Relations"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Get the collection of relations that link tables and
        ///       allow navigation from parent tables to child tables.
        ///    </para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataSetRelationsDescr)
        ]
        public DataRelationCollection Relations {
            get {
                if (relationCollection == null) 
                    relationCollection = new DataRelationCollection.DataSetRelationCollection(this);
                
                return relationCollection;
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ShouldSerializeRelations"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether <see cref='Relations'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        protected virtual bool ShouldSerializeRelations() {
            return true; /*Relations.Count > 0;*/ // VS7 300569
        }

        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataSet.Relations'/> property to its default state.
        ///    </para>
        /// </devdoc>
        private void ResetRelations()
        {
            Relations.Clear();
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Tables"]/*' />
        /// <devdoc>
        /// <para>Gets the collection of tables contained in the <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.DataSetTablesDescr)
        ]
        public DataTableCollection Tables {
            get {
                if (tableCollection == null) {
                    tableCollection = new DataTableCollection(this);
                }
                return tableCollection;
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ShouldSerializeTables"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether <see cref='System.Data.DataSet.Tables'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        protected virtual bool ShouldSerializeTables() {
            return true;/*(Tables.Count > 0);*/ // VS7 300569
        }

        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataSet.Tables'/> property to its default state.
        ///    </para>
        /// </devdoc>
        private void ResetTables() 
        {
            Tables.Clear();
        }

        internal bool FBoundToDocument {
            get {
                return fBoundToDocument;
            }
            set {
                fBoundToDocument = value;
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.AcceptChanges"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Commits all the changes made to this <see cref='System.Data.DataSet'/> since it was loaded or the last
        ///       time <see cref='System.Data.DataSet.AcceptChanges'/> was called.
        ///    </para>
        /// </devdoc>
        public void AcceptChanges() 
        {
            for (int i = 0; i < Tables.Count; i++)
                Tables[i].AcceptChanges();
        }

        internal event PropertyChangedEventHandler PropertyChanging {
            add {
                onPropertyChangingDelegate += value;
            }
            remove {
                onPropertyChangingDelegate -= value;
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.MergeFailed"]/*' />
        /// <devdoc>
        ///    <para>Occurs when attempting to merge schemas for two tables with the same
        ///       name.</para>
        /// </devdoc>
        [
         DataCategory(Res.DataCategory_Action),
         DataSysDescription(Res.DataSetMergeFailedDescr)
        ]
        public event MergeFailedEventHandler MergeFailed {
            add {
                onMergeFailed += value; 
            }
            remove {
                onMergeFailed -= value;
            }
        }

        internal event DataRowCreatedEventHandler DataRowCreated {
            add {
                onDataRowCreated += value; 
            }
            remove {
                onDataRowCreated -= value;
            }
        }

        internal event DataSetClearEventhandler ClearFunctionCalled {
            add {
                onClearFunctionCalled += value; 
            }
            remove {
                onClearFunctionCalled -= value;
            }
        }


        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.BeginInit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void BeginInit() {
            fInitInProgress = true;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.EndInit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EndInit() {
            Tables.FinishInitCollection();
            for (int i = 0; i < Tables.Count; i++) {
                Tables[i].Columns.FinishInitCollection();
            }

            for (int i = 0; i < Tables.Count; i++) {
                Tables[i].Constraints.FinishInitConstraints();
            }

            ((DataRelationCollection.DataSetRelationCollection)Relations).FinishInitRelations();
                
            fInitInProgress = false;
        }
        
        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Clear"]/*' />
        /// <devdoc>
        /// <para>Clears the <see cref='System.Data.DataSet'/> of any data by removing all rows in all tables.</para>
        /// </devdoc>
        public void Clear() 
        {
            OnClearFunctionCalled(null);
            bool fEnforce = EnforceConstraints;
            EnforceConstraints = false;
            for (int i = 0; i < Tables.Count; i++)
                Tables[i].Clear();

            EnforceConstraints = fEnforce;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Clone"]/*' />
        /// <devdoc>
        /// <para>Clones the structure of the <see cref='System.Data.DataSet'/>, including all <see cref='System.Data.DataTable'/> schemas, relations, and
        ///    constraints.</para>
        /// </devdoc>
        public virtual DataSet Clone() {
            DataSet ds = (DataSet)Activator.CreateInstance(this.GetType(), true);

            if (ds.Tables.Count > 0)  // haroona : To clean up all the schema in strong typed dataset.
                ds.Reset();

            //copy some original dataset properties
            ds.DataSetName = DataSetName;
            ds.CaseSensitive = CaseSensitive;
            ds.Locale = Locale;
            ds.EnforceConstraints = EnforceConstraints;
            ds.Namespace = Namespace;
            ds.Prefix = Prefix;
            ds.fIsSchemaLoading = true; //delay expression evaluation

            // ...Tables...
            DataTableCollection tbls = Tables;
            for (int i = 0; i < tbls.Count; i++)  {
               ds.Tables.Add(tbls[i].Clone(ds));
            }

            // ...Constraints...
            for (int i = 0; i < tbls.Count; i++)  {
                ConstraintCollection constraints = tbls[i].Constraints;
                for (int j = 0; j < constraints.Count; j++)  {
                    if (constraints[j] is UniqueConstraint)
                        continue;
                    ds.Tables[i].Constraints.Add(constraints[j].Clone(ds));
                }
            }

            // ...Relations...
            DataRelationCollection rels = Relations;
            for (int i = 0; i < rels.Count; i++)  {
                ds.Relations.Add(rels[i].Clone(ds));
            }

            // ...Extended Properties...
            if (this.extendedProperties != null) {
                foreach(Object key in this.extendedProperties.Keys) {
                    ds.ExtendedProperties[key]=this.extendedProperties[key];
                }
            }

            foreach (DataTable table in Tables)
                foreach (DataColumn col in table.Columns)
                    if (col.Expression != String.Empty)
                       ds.Tables[table.TableName].Columns[col.ColumnName].Expression = col.Expression;

            ds.fIsSchemaLoading = false; //reactivate column computations

            return ds;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Copy"]/*' />
        /// <devdoc>
        /// <para>Copies both the structure and data for this <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        public DataSet Copy() 
        {
            DataSet dsNew = Clone();
            bool fEnforceConstraints = dsNew.EnforceConstraints;
            dsNew.EnforceConstraints = false;
            foreach (DataTable table in this.Tables)
            {
                DataTable destTable = dsNew.Tables[table.TableName];

                foreach (DataRow row in table.Rows)
                    table.CopyRow(destTable, row);
            }

            dsNew.EnforceConstraints = fEnforceConstraints;

            return dsNew;
        }

        internal Int32 EstimatedXmlStringSize()
        {
            Int32 bytes = 100;
            for (int i = 0; i < Tables.Count; i++) {
                Int32 rowBytes = (Tables[i].TableName.Length + 4) << 2;
                DataTable table = Tables[i];
                for (int j = 0; j < table.Columns.Count; j++) {
                    rowBytes += ((table.Columns[j].ColumnName.Length + 4) << 2);
                    rowBytes += 20;
                }
                bytes += table.Rows.Count * rowBytes;
            }

            return bytes;
        }
        


        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.GetChanges"]/*' />
        /// <devdoc>
        /// <para>Returns a copy of the <see cref='System.Data.DataSet'/> that contains all changes made to
        ///    it since it was loaded or <see cref='System.Data.DataSet.AcceptChanges'/>
        ///    was last called.</para>
        /// </devdoc>
        public DataSet GetChanges() 
        {
            return GetChanges(DataRowState.Added | DataRowState.Deleted | DataRowState.Modified);
        }

        /// <devdoc>
        /// <para>Returns a copy of the <see cref='System.Data.DataSet'/> containing all changes made to it since it was last
        ///    loaded, or since <see cref='System.Data.DataSet.AcceptChanges'/> was called, filtered by <see cref='System.Data.DataRowState'/>.</para>
        /// </devdoc>

        internal bool ShouldWriteRowAsUpdate(DataRow row, DataRowState   _rowStates) {

            DataRowState state = row.RowState;
            if (((int)(state & _rowStates) != 0))
                return true;

            for (int i = 0; i < row.Table.ChildRelations.Count; i++) {
                DataRowVersion version = (state == DataRowState.Deleted) ? DataRowVersion.Original : DataRowVersion.Current;
                DataRow[] childRows = row.GetChildRows(row.Table.ChildRelations[i], version);
                for (int j = 0; j < childRows.Length; j++) {
                    if (ShouldWriteRowAsUpdate(childRows[j], _rowStates))
                        return true;
                }
            }

            return false;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.GetChanges1"]/*' />
        public DataSet GetChanges(DataRowState rowStates) 
        {
            DataSet     dsNew = null;

            // check that rowStates is valid DataRowState
            Debug.Assert(Enum.GetUnderlyingType(typeof(DataRowState)) == typeof(Int32), "Invalid DataRowState type");

            // the DataRowState used as a bit field
            if (!HasChanges(rowStates)) {
                return null;
            }
            dsNew = this.Clone();

            bool fEnforceConstraints = dsNew.EnforceConstraints;
            dsNew.EnforceConstraints = false;
            foreach (DataTable table in this.Tables)
            {
                DataTable destTable = dsNew.Tables[table.TableName];
                    
                foreach (DataRow row in table.Rows)
                    if (ShouldWriteRowAsUpdate(row, rowStates))
                        table.CopyRow(destTable, row);
               
            }

            dsNew.EnforceConstraints = fEnforceConstraints;

            return dsNew;      
        }

        internal string GetRemotingDiffGram(DataTable table)
        {
            StringWriter strWriter = new StringWriter();
            XmlTextWriter writer= new XmlTextWriter( strWriter );
            writer.Formatting = Formatting.Indented;
            if (strWriter != null) {
                // Create and save the updates
                new NewDiffgramGen(this).Save(writer, table);
            }

            return strWriter.ToString();
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.GetSerializationData"]/*' />
        protected void GetSerializationData(SerializationInfo info, StreamingContext context) {
            string strData = (String)info.GetValue(KEY_XMLDIFFGRAM, typeof(System.String));

            if (strData != null) {
                this.ReadXml(new XmlTextReader( new StringReader( strData ) ), XmlReadMode.DiffGram);
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData (SerializationInfo info, StreamingContext context) 
        {
            String strSchema = this.GetXmlSchemaForRemoting(null);
            String strData = null;
            info.AddValue(KEY_XMLSCHEMA, strSchema);
            
            StringBuilder strBuilder;
            
            strBuilder = new StringBuilder(EstimatedXmlStringSize() * 2);
            StringWriter strWriter = new StringWriter(strBuilder);
            XmlTextWriter w =  new XmlTextWriter(strWriter) ;
            WriteXml(w, XmlWriteMode.DiffGram); 
            strData = strWriter.ToString();
            info.AddValue(KEY_XMLDIFFGRAM, strData);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.GetXml"]/*' />
        public string GetXml() 
        {
            // StringBuilder strBuilder = new StringBuilder(EstimatedXmlStringSize());
            // StringWriter strWriter = new StringWriter(strBuilder);
            StringWriter strWriter = new StringWriter();
            if (strWriter != null) {
                XmlTextWriter w =  new XmlTextWriter(strWriter) ;
                w.Formatting = Formatting.Indented;
                new XmlDataTreeWriter(this).Save(w, false); 
            }
            return strWriter.ToString();
        }
        
        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.GetXmlSchema"]/*' />
        public string GetXmlSchema()
        {
            StringWriter strWriter = new StringWriter();
            XmlTextWriter writer= new XmlTextWriter( strWriter );
            writer.Formatting = Formatting.Indented;
            if (strWriter != null) {
                 (new XmlTreeGen(SchemaFormat.Public)).Save(this, writer);              
            }

            return strWriter.ToString();
        }

        internal string GetXmlSchemaForRemoting(DataTable table)
        {
            StringWriter strWriter = new StringWriter();
            XmlTextWriter writer= new XmlTextWriter( strWriter );
            writer.Formatting = Formatting.Indented;
            if (strWriter != null) {
                  if (table == null) 
                     (new XmlTreeGen(SchemaFormat.Remoting)).Save(this, writer); 
                  else
                     (new XmlTreeGen(SchemaFormat.Remoting)).Save(table, writer); 
            }

            return strWriter.ToString();
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.HasChanges"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the <see cref='System.Data.DataSet'/> has changes, including new,
        ///    deleted, or modified rows.</para>
        /// </devdoc>
        public bool HasChanges() 
        {
            return HasChanges(DataRowState.Added | DataRowState.Deleted | DataRowState.Modified);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.HasChanges1"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the <see cref='System.Data.DataSet'/> has changes, including new,
        ///    deleted, or modified rows, filtered by <see cref='System.Data.DataRowState'/>.</para>
        /// </devdoc>
        public bool HasChanges(DataRowState rowStates) 
        {
            const DataRowState allRowStates = DataRowState.Detached | DataRowState.Unchanged | DataRowState.Added | DataRowState.Deleted | DataRowState.Modified;

            if ((rowStates & (~allRowStates)) != 0) {
                throw ExceptionBuilder.ArgumentOutOfRange("rowState");
            }

            bool changesExist = false;

            for (int i = 0; i < Tables.Count; i++) {
                DataTable table = Tables[i];

                for (int j = 0; j < table.Rows.Count; j++) {
                    DataRow row = table.Rows[j];
                    if ((row.RowState & rowStates) != 0) {
                        changesExist = true;
                        break;
                    }
                }
            }

            return changesExist;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.InferXmlSchema"]/*' />
        /// <devdoc>
        /// <para>Infer the XML schema from the specified <see cref='System.IO.TextReader'/> into the <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        public void InferXmlSchema(XmlReader reader, string[] nsArray)
        {
            if (reader == null)
                return;

            XmlDocument xdoc = new XmlDocument();            
            if (reader.NodeType == XmlNodeType.Element) {
                XmlNode node = xdoc.ReadNode(reader);
                xdoc.AppendChild(node);
            }
            else
                xdoc.Load(reader);
            if (xdoc.DocumentElement == null)
                return;
                
            XmlDataLoader xmlload = new XmlDataLoader(this, false);
            xmlload.InferSchema(xdoc, nsArray);
        }
        
        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.InferXmlSchema1"]/*' />
        /// <devdoc>
        /// <para>Infer the XML schema from the specified <see cref='System.IO.TextReader'/> into the <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        public void InferXmlSchema(Stream stream, string[] nsArray) 
        {
            if (stream == null)
                return;

            InferXmlSchema( new XmlTextReader( stream ), nsArray);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.InferXmlSchema2"]/*' />
        /// <devdoc>
        /// <para>Infer the XML schema from the specified <see cref='System.IO.TextReader'/> into the <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        public void InferXmlSchema(TextReader reader, string[] nsArray) 
        {
            if (reader == null)
                return;

            InferXmlSchema( new XmlTextReader( reader ) , nsArray);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.InferXmlSchema3"]/*' />
        /// <devdoc>
        /// <para>Infer the XML schema from the specified file into the <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        public void InferXmlSchema(String fileName, string[] nsArray) 
        {
            XmlTextReader xr = new XmlTextReader(fileName);
            try {
                InferXmlSchema( xr, nsArray);
            }
            finally {
                xr.Close();
            }
        }
        
        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXmlSchema"]/*' />
        /// <devdoc>
        /// <para>Reads the XML schema from the specified <see cref='T:System.Xml.XMLReader'/> into the <see cref='System.Data.DataSet'/> 
        /// .</para>
        /// </devdoc>
        public void ReadXmlSchema(XmlReader reader)
        {
            ReadXmlSchema(reader, false);
        }

        internal void ReadXmlSchema(XmlReader reader, bool denyResolving)
        {
            int iCurrentDepth = -1;
            
            if (reader == null)
                return;

            if (reader is XmlTextReader)
                ((XmlTextReader) reader).WhitespaceHandling = WhitespaceHandling.None;

            XmlDocument xdoc = new XmlDocument(); // we may need this to infer the schema

            if (reader.NodeType == XmlNodeType.Element)
                iCurrentDepth = reader.Depth;
            
            reader.MoveToContent();

            if (reader.NodeType == XmlNodeType.Element) {
                // if reader points to the schema load it...

                if (reader.LocalName == Keywords.XDR_SCHEMA && reader.NamespaceURI==Keywords.XDRNS) {
                    // load XDR schema and exit
                    ReadXDRSchema(reader);
                    return;
                }
                    
                if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI==Keywords.XSDNS) {
                    // load XSD schema and exit
                    ReadXSDSchema(reader, denyResolving);
                    return;
                }
                
                if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START)) 
                    throw ExceptionBuilder.DataSetUnsupportedSchema(Keywords.XSDNS);

                // ... otherwise backup the top node and all its attributes
                XmlElement topNode = xdoc.CreateElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                if (reader.HasAttributes) {
                    int attrCount = reader.AttributeCount;
                    for (int i=0;i<attrCount;i++) {
                        reader.MoveToAttribute(i);
                        if (reader.NamespaceURI.Equals(Keywords.XSD_XMLNS_NS))
                            topNode.SetAttribute(reader.Name, reader.GetAttribute(i));
                        else {
                            XmlAttribute attr = topNode.SetAttributeNode(reader.LocalName, reader.NamespaceURI);
                            attr.Prefix = reader.Prefix;
                            attr.Value = reader.GetAttribute(i);
                        }
                    }
                }
                reader.Read();

                while(MoveToElement(reader, iCurrentDepth)) {

                    // if reader points to the schema load it...
                    if (reader.LocalName == Keywords.XDR_SCHEMA && reader.NamespaceURI==Keywords.XDRNS) {
                    // load XDR schema and exit
                        ReadXDRSchema(reader);
                        return;
                    }
                    
                    if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI==Keywords.XSDNS) {
                        // load XSD schema and exit
                        ReadXSDSchema(reader, denyResolving);
                        return;
                    }

                    if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START)) 
                        throw ExceptionBuilder.DataSetUnsupportedSchema(Keywords.XSDNS);


                    XmlNode node = xdoc.ReadNode(reader);
                    topNode.AppendChild(node);

                }

                // read the closing tag of the current element
                ReadEndElement(reader);

                // if we are here no schema has been found
                xdoc.AppendChild(topNode);

                // so we InferSchema
                XmlDataLoader xmlload = new XmlDataLoader(this, false);
                xmlload.InferSchema(xdoc, null);
            }
        }

        internal bool MoveToElement(XmlReader reader, int depth) {
            while (!reader.EOF && reader.NodeType != XmlNodeType.EndElement && reader.NodeType != XmlNodeType.Element && reader.Depth > depth) {
                reader.Read();
            }
            return (reader.NodeType == XmlNodeType.Element);
        }

        internal void ReadEndElement(XmlReader reader) {
            while (reader.NodeType == XmlNodeType.Whitespace) {
                reader.Skip();
            }
            if (reader.NodeType == XmlNodeType.None) {
                reader.Skip();
            }
            else if (reader.NodeType == XmlNodeType.EndElement) {
                reader.ReadEndElement();
            }
        }

        internal void ReadXSDSchema(XmlReader reader, bool denyResolving) {
            XmlSchema s = XmlSchema.Read(reader, null);
            //read the end tag
            ReadEndElement(reader);

            if (denyResolving) {
                s.Compile(null, null);
            }
            else {
                s.Compile(null);
            }
            XSDSchema schema = new XSDSchema();
            schema.LoadSchema(s, this);
            
            
        }

        internal void ReadXDRSchema(XmlReader reader) {
            XmlDocument xdoc = new XmlDocument(); // we may need this to infer the schema
            XmlNode schNode = xdoc.ReadNode(reader);
            xdoc.AppendChild(schNode);
            XDRSchema schema = new XDRSchema(this, false);
            this.DataSetName = xdoc.DocumentElement.LocalName;
            schema.LoadSchema((XmlElement)schNode, this);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXmlSchema1"]/*' />
        /// <devdoc>
        /// <para>Reads the XML schema from the specified <see cref='System.IO.Stream'/> into the 
        /// <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        public void ReadXmlSchema(Stream stream) 
        {
            if (stream == null)
                return;

            ReadXmlSchema( new XmlTextReader( stream ), false );
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXmlSchema2"]/*' />
        /// <devdoc>
        /// <para>Reads the XML schema from the specified <see cref='System.IO.TextReader'/> into the <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        public void ReadXmlSchema(TextReader reader) 
        {
            if (reader == null)
                return;

            ReadXmlSchema( new XmlTextReader( reader ), false );
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXmlSchema3"]/*' />
        /// <devdoc>
        /// <para>Reads the XML schema from the specified file into the <see cref='System.Data.DataSet'/>.</para>
        /// </devdoc>
        public void ReadXmlSchema(String fileName) 
        {
            XmlTextReader xr = new XmlTextReader(fileName);
            try {
                ReadXmlSchema( xr, false );
            }
            finally {
                xr.Close();
            }
        }
        
        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXmlSchema"]/*' />
        /// <devdoc>
        /// <para>Writes the <see cref='System.Data.DataSet'/> structure as an XML schema to a
        /// <see cref='System.IO.Stream'/> 
        /// object.</para>
        /// </devdoc>
        public void WriteXmlSchema(Stream stream) 
        {
            if (stream == null)
                return;

            XmlTextWriter w =  new XmlTextWriter(stream, null) ;
            w.Formatting = Formatting.Indented;

            WriteXmlSchema( w );
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXmlSchema1"]/*' />
        /// <devdoc>
        /// <para>Writes the <see cref='System.Data.DataSet'/> structure as an XML schema to a <see cref='System.IO.TextWriter'/> 
        /// object.</para>
        /// </devdoc>
        public void WriteXmlSchema( TextWriter writer )
        {

            if (writer == null)
                return;

            XmlTextWriter w =  new XmlTextWriter(writer);
            w.Formatting = Formatting.Indented;

            WriteXmlSchema( w );
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXmlSchema2"]/*' />
        /// <devdoc>
        /// <para>Writes the <see cref='System.Data.DataSet'/> structure as an XML schema to an <see cref='T:System.Xml.XmlWriter'/> 
        /// object.</para>
        /// </devdoc>
        public void WriteXmlSchema(XmlWriter writer) 
        {
            // Generate SchemaTree and write it out
            if (writer != null) {
                 (new XmlTreeGen(SchemaFormat.Public)).Save(this, writer);              
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXmlSchema3"]/*' />
        /// <devdoc>
        /// <para>Writes the <see cref='System.Data.DataSet'/> structure as an XML schema to a file.</para>
        /// </devdoc>
        public void WriteXmlSchema(String fileName) 
        {
            XmlTextWriter xw = new XmlTextWriter( fileName, null );
            try {
                xw.Formatting = Formatting.Indented;
                xw.WriteStartDocument(true);
                WriteXmlSchema(xw);    
                xw.WriteEndDocument();
            }
            finally {
                xw.Close();
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXml"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlReadMode ReadXml(XmlReader reader) 
        {
            return ReadXml(reader, false);
        }


        internal XmlReadMode ReadXml(XmlReader reader, bool denyResolving) 
        {
            bool fDataFound = false;
            bool fSchemaFound = false;
            bool fDiffsFound = false;
            bool fIsXdr = false;
            int iCurrentDepth = -1;
            XmlReadMode ret = XmlReadMode.Auto;

            if (reader == null)
                return ret;

            if (reader is XmlTextReader)
                ((XmlTextReader) reader).WhitespaceHandling = WhitespaceHandling.None;

            XmlDocument xdoc = new XmlDocument(); // we may need this to infer the schema
            XmlDataLoader xmlload = null;


            reader.MoveToContent();

            if (reader.NodeType == XmlNodeType.Element)
                iCurrentDepth = reader.Depth;

            if (reader.NodeType == XmlNodeType.Element) {
                if ((reader.LocalName == Keywords.DIFFGRAM) && (reader.NamespaceURI == Keywords.DFFNS)) {
                    this.ReadXmlDiffgram(reader);
                    // read the closing tag of the current element
                    ReadEndElement(reader);
                    return XmlReadMode.DiffGram;
                }

                // if reader points to the schema load it
                if (reader.LocalName == Keywords.XDR_SCHEMA && reader.NamespaceURI==Keywords.XDRNS) {
                    // load XDR schema and exit
                    ReadXDRSchema(reader);
                    return XmlReadMode.ReadSchema; //since the top level element is a schema return
                }

                if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI==Keywords.XSDNS) {
                    // load XSD schema and exit
                    ReadXSDSchema(reader, denyResolving);
                    return XmlReadMode.ReadSchema; //since the top level element is a schema return
                }

                if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START)) 
                    throw ExceptionBuilder.DataSetUnsupportedSchema(Keywords.XSDNS);

                // now either the top level node is a table and we load it through dataReader...

                // ... or backup the top node and all its attributes because we may need to InferSchema
                XmlElement topNode = xdoc.CreateElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                if (reader.HasAttributes) {
                    int attrCount = reader.AttributeCount;
                    for (int i=0;i<attrCount;i++) {
                        reader.MoveToAttribute(i);
                        if (reader.NamespaceURI.Equals(Keywords.XSD_XMLNS_NS))
                            topNode.SetAttribute(reader.Name, reader.GetAttribute(i));
                        else {
                            XmlAttribute attr = topNode.SetAttributeNode(reader.LocalName, reader.NamespaceURI);
                            attr.Prefix = reader.Prefix;
                            attr.Value = reader.GetAttribute(i);
                        }
                    }
                }
                reader.Read();

                while(MoveToElement(reader, iCurrentDepth)) {

                    if ((reader.LocalName == Keywords.DIFFGRAM) && (reader.NamespaceURI == Keywords.DFFNS)) {
                        this.ReadXmlDiffgram(reader);
                        // read the closing tag of the current element
                        ReadEndElement(reader);
                        return XmlReadMode.DiffGram;
                    }

                    // if reader points to the schema load it...


                    if (!fSchemaFound && !fDataFound && reader.LocalName == Keywords.XDR_SCHEMA && reader.NamespaceURI==Keywords.XDRNS) {
                        // load XDR schema and exit
                        ReadXDRSchema(reader);
                        fSchemaFound = true;
                        fIsXdr = true;
                        continue;
                    }
                    
                    if (!fSchemaFound && !fDataFound && reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI==Keywords.XSDNS) {
                        // load XSD schema and exit
                        ReadXSDSchema(reader, denyResolving);
                        fSchemaFound = true;
                        continue;
                    }

                    if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START)) 
                        throw ExceptionBuilder.DataSetUnsupportedSchema(Keywords.XSDNS);

                    if ((reader.LocalName == Keywords.DIFFGRAM) && (reader.NamespaceURI == Keywords.DFFNS)) {
                        this.ReadXmlDiffgram(reader);
                        fDiffsFound = true;
                        ret = XmlReadMode.DiffGram;
                    }
                    else {
                        // we found data here
                        fDataFound = true;

#if !DOMREADERDATA

                        if (!fSchemaFound && Tables.Count == 0) {
#endif
                            XmlNode node = xdoc.ReadNode(reader);
                            topNode.AppendChild(node);
#if !DOMREADERDATA
                        }
                        else {
                            if (xmlload == null)
                                xmlload = new XmlDataLoader(this, fIsXdr, topNode);
                            xmlload.LoadData(reader);
                            if (fSchemaFound)
                                ret = XmlReadMode.ReadSchema;
                            else
                                ret = XmlReadMode.IgnoreSchema;
                        }
#endif

                    }

                }
                // read the closing tag of the current element
                ReadEndElement(reader);

                // now top node contains the data part
                xdoc.AppendChild(topNode);

                if (xmlload == null)
                    xmlload = new XmlDataLoader(this, fIsXdr);

                // so we InferSchema
                if (!fDiffsFound) {
                    // Load Data
                    if (!fSchemaFound && Tables.Count == 0) {
                        xmlload.InferSchema(xdoc, null);
                        ret = XmlReadMode.InferSchema;

#if !DOMREADERDATA
                        xmlload.LoadData(xdoc);
#endif
                    }
#if DOMREADERDATA
                    xmlload.LoadData(xdoc);
#endif

                }
            }

            return ret;
        }
        
        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXml1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlReadMode ReadXml(Stream stream) 
        {
            if (stream == null)
                return XmlReadMode.Auto;
               
            return ReadXml( new XmlTextReader(stream), false);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXml2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlReadMode ReadXml(TextReader reader) 
        {
            if (reader == null)
                return XmlReadMode.Auto;
                
            return ReadXml( new XmlTextReader(reader), false);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXml3"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlReadMode ReadXml(string fileName) 
        {
            XmlTextReader xr = new XmlTextReader(fileName);
            try {
                return ReadXml( xr , false);                
            }
            finally {
                xr.Close();
            }
        }
        
        private bool IsEmpty() {
            foreach (DataTable table in this.Tables)
                if (table.Rows.Count > 0)
                    return false;
            return true;
        }

        private void ReadXmlDiffgram(XmlReader reader) {
            int d = reader.Depth;
            bool fEnforce = this.EnforceConstraints;
            this.EnforceConstraints =false;
            DataSet newDs;
            bool isEmpty = this.IsEmpty();
            
            if (isEmpty) {
                newDs = this;
            }
            else {
                newDs = this.Clone();
                newDs.EnforceConstraints = false;
            }

            foreach (DataTable t in newDs.Tables) {
                t.Rows.nullInList = 0;
            }
            reader.MoveToContent();
            if ((reader.LocalName != Keywords.DIFFGRAM) && (reader.NamespaceURI != Keywords.DFFNS))
                return;
            reader.Read();
            newDs.fInLoadDiffgram = true;

            if (reader.Depth > d) {
                if ((reader.NamespaceURI != Keywords.DFFNS) && (reader.NamespaceURI != Keywords.MSDNS)) {
                    //we should be inside the dataset part
                    XmlDocument xdoc = new XmlDocument();
                    XmlElement node = xdoc.CreateElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                    reader.Read();
                    if (reader.Depth-1 > d) {
                        XmlDataLoader xmlload = new XmlDataLoader(newDs, false, node);
                        xmlload.isDiffgram = true; // turn on the special processing
                        xmlload.LoadData(reader);
                    }
                    ReadEndElement(reader);
                }
                if (((reader.LocalName == Keywords.SQL_BEFORE) && (reader.NamespaceURI == Keywords.DFFNS)) ||
                    ((reader.LocalName == Keywords.MSD_ERRORS) && (reader.NamespaceURI == Keywords.DFFNS)))

                {
                    //this will consume the changes and the errors part
                    XMLDiffLoader diffLoader = new XMLDiffLoader();
                    diffLoader.LoadDiffGram(newDs, reader);
                }

                // get to the closing diff tag
                while(reader.Depth > d) {
                    reader.Read();
                }
                // read the closing tag
                ReadEndElement(reader);
            }

            foreach (DataTable t in newDs.Tables) {
                if (t.Rows.nullInList > 0)
                    throw ExceptionBuilder.RowInsertMissing(t.TableName);
            }

            newDs.fInLoadDiffgram = false;

            foreach (DataTable t in newDs.Tables) {
              DataRelation rel = t.nestedParentRelation ;
              if (rel != null && rel.ParentTable == t) {
                foreach (DataRow r in t.Rows)
                  r.CheckForLoops(t.nestedParentRelation);
              }
            }
                
            
            
            if (!isEmpty) {
                this.Merge(newDs);
                if (this.dataSetName == "NewDataSet")
                    this.dataSetName = newDs.dataSetName;
                newDs.EnforceConstraints = fEnforce;
            }
            this.EnforceConstraints = fEnforce;

        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXml4"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlReadMode ReadXml(XmlReader reader, XmlReadMode mode) 
        {
            return ReadXml(reader, mode, false);
        }

        internal XmlReadMode ReadXml(XmlReader reader, XmlReadMode mode, bool denyResolving) 
        {
            bool fSchemaFound = false;
            bool fDataFound = false;
            bool fIsXdr = false;
            int iCurrentDepth = -1;
            XmlReadMode ret = mode;

            if (reader == null)
                return ret;

            if (mode == XmlReadMode.Auto) {
                return ReadXml(reader);
            } 

            if (reader is XmlTextReader)
                ((XmlTextReader) reader).WhitespaceHandling = WhitespaceHandling.None;

            XmlDocument xdoc = new XmlDocument(); // we may need this to infer the schema

            if ((mode != XmlReadMode.Fragment) && (reader.NodeType == XmlNodeType.Element))
                iCurrentDepth = reader.Depth;
                
            reader.MoveToContent();
            XmlDataLoader xmlload = null;

            if (reader.NodeType == XmlNodeType.Element) {
                XmlElement topNode = null;
                if (mode == XmlReadMode.Fragment) {
                    xdoc.AppendChild(xdoc.CreateElement("ds_sqlXmlWraPPeR"));
                    topNode = xdoc.DocumentElement;
                }
                else { //handle the top node
                    if ((reader.LocalName == Keywords.DIFFGRAM) && (reader.NamespaceURI == Keywords.DFFNS)) {
                        if ((mode == XmlReadMode.DiffGram) || (mode == XmlReadMode.IgnoreSchema)) {
                            this.ReadXmlDiffgram(reader);
                            // read the closing tag of the current element
                            ReadEndElement(reader);
                        }
                        else {
                            reader.Skip();
                        }
                        return ret;
                    }

                    if (reader.LocalName == Keywords.XDR_SCHEMA && reader.NamespaceURI==Keywords.XDRNS) {
                        // load XDR schema and exit
                        if ((mode != XmlReadMode.IgnoreSchema) && (mode != XmlReadMode.InferSchema)) {
                            ReadXDRSchema(reader);
                        }
                        else {
                            reader.Skip();
                        }
                        return ret; //since the top level element is a schema return
                    }

                    if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI==Keywords.XSDNS) {
                        // load XSD schema and exit
                       	if ((mode != XmlReadMode.IgnoreSchema) && (mode != XmlReadMode.InferSchema))  {
                            ReadXSDSchema(reader, denyResolving);
                        }
                        else
                            reader.Skip();
                        return ret; //since the top level element is a schema return
                    }

                    if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START)) 
                        throw ExceptionBuilder.DataSetUnsupportedSchema(Keywords.XSDNS);

                    // now either the top level node is a table and we load it through dataReader...
                    // ... or backup the top node and all its attributes
                    topNode = xdoc.CreateElement(reader.Prefix, reader.LocalName, reader.NamespaceURI);
                    if (reader.HasAttributes) {
                        int attrCount = reader.AttributeCount;
                        for (int i=0;i<attrCount;i++) {
                            reader.MoveToAttribute(i);
                            if (reader.NamespaceURI.Equals(Keywords.XSD_XMLNS_NS))
                                topNode.SetAttribute(reader.Name, reader.GetAttribute(i));
                            else {
                                XmlAttribute attr = topNode.SetAttributeNode(reader.LocalName, reader.NamespaceURI);
                                attr.Prefix = reader.Prefix;
                                attr.Value = reader.GetAttribute(i);
                            }
                        }
                    }
                    reader.Read();
                }

                while(MoveToElement(reader, iCurrentDepth)) {

                    if (reader.LocalName == Keywords.XDR_SCHEMA && reader.NamespaceURI==Keywords.XDRNS) {
                        // load XDR schema 
                       	if (!fSchemaFound && !fDataFound && (mode != XmlReadMode.IgnoreSchema) && (mode != XmlReadMode.InferSchema))  {
                            ReadXDRSchema(reader);
                            fSchemaFound = true;
                            fIsXdr = true;
                        }
                        else {
                            reader.Skip(); 
                        }
                        continue;
                    }

                    if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI==Keywords.XSDNS) {
                    // load XSD schema and exit
                        if ((mode != XmlReadMode.IgnoreSchema) && (mode != XmlReadMode.InferSchema))  {
                            ReadXSDSchema(reader, denyResolving);
                            fSchemaFound = true;
                        }
                        else {
                            reader.Skip();
                        }
                        continue;
                    }

                    if ((reader.LocalName == Keywords.DIFFGRAM) && (reader.NamespaceURI == Keywords.DFFNS)) {
                        if ((mode == XmlReadMode.DiffGram) || (mode == XmlReadMode.IgnoreSchema)) {
                            this.ReadXmlDiffgram(reader);
                            ret = XmlReadMode.DiffGram;
                        }
                        else {
                            reader.Skip();
                        }
                        continue;
                    }

                    if (reader.LocalName == Keywords.XSD_SCHEMA && reader.NamespaceURI.StartsWith(Keywords.XSD_NS_START)) 
                        throw ExceptionBuilder.DataSetUnsupportedSchema(Keywords.XSDNS);

                    if (mode == XmlReadMode.DiffGram) {
                        reader.Skip();
                        continue; // we do not read data in diffgram mode
                    }

                    // if we are here we found some data
                    fDataFound = true;

#if !DOMREADERDATA
                    if (mode == XmlReadMode.InferSchema) { //save the node in DOM until the end;
#endif
                        XmlNode node = xdoc.ReadNode(reader);
                        topNode.AppendChild(node);
#if !DOMREADERDATA
                    } 
                    else {
                        if (xmlload == null)
                            xmlload = new XmlDataLoader(this, fIsXdr, topNode);
                        xmlload.LoadData(reader);
                    }
#endif
                } //end of the while

                // read the closing tag of the current element
                ReadEndElement(reader);

                // now top node contains the data part
                xdoc.AppendChild(topNode);
                if (xmlload == null)
                    xmlload = new XmlDataLoader(this, fIsXdr);

                if (mode == XmlReadMode.DiffGram) {
                    // we already got the diffs through XmlReader interface
                    return ret;
                }

                // Load Data
                if (mode == XmlReadMode.InferSchema) {
                    xmlload.InferSchema(xdoc, null);
#if !DOMREADERDATA
                    xmlload.LoadData(xdoc);
#endif
                }
#if DOMREADERDATA
                xmlload.LoadData(xdoc);
#endif
            }

            return ret;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXml5"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlReadMode ReadXml(Stream stream, XmlReadMode mode) 
        {
            if (stream == null)
                return XmlReadMode.Auto;

            XmlTextReader reader = (mode == XmlReadMode.Fragment) ? new XmlTextReader(stream, XmlNodeType.Element, null) : new XmlTextReader(stream);
            return ReadXml( reader, mode, false);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXml6"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlReadMode ReadXml(TextReader reader, XmlReadMode mode) 
        {
            if (reader == null)
                return XmlReadMode.Auto;
                
            XmlTextReader xmlreader = (mode == XmlReadMode.Fragment) ? new XmlTextReader(reader.ReadToEnd(), XmlNodeType.Element, null) : new XmlTextReader(reader);
           return  ReadXml( xmlreader, mode, false);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXml7"]/*' />
        /// <devdoc>
        /// </devdoc>
        public XmlReadMode ReadXml(string fileName, XmlReadMode mode) 
        {
            XmlTextReader xr = null;
            if (mode == XmlReadMode.Fragment) {
                FileStream stream = new FileStream(fileName, FileMode.Open);
                xr = new XmlTextReader(stream, XmlNodeType.Element, null);
            }
            else
                xr = new XmlTextReader(fileName);
            try {
               return  ReadXml( xr, mode, false);                
            }
            finally {
                xr.Close();
            }
        }


        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXml"]/*' />
        /// <devdoc>
        ///    Writes schema and data for the DataSet.
        /// </devdoc>
        public void WriteXml(Stream stream) 
        {
            WriteXml(stream, XmlWriteMode.IgnoreSchema);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXml1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void WriteXml(TextWriter writer) 
        {
            WriteXml(writer, XmlWriteMode.IgnoreSchema);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXml2"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void WriteXml(XmlWriter writer) 
        {
            WriteXml(writer, XmlWriteMode.IgnoreSchema);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXml3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void WriteXml(String fileName) 
        {
            WriteXml(fileName, XmlWriteMode.IgnoreSchema);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXml4"]/*' />
        /// <devdoc>
        ///    Writes schema and data for the DataSet.
        /// </devdoc>
        public void WriteXml(Stream stream, XmlWriteMode mode) 
        {
            if (stream != null) {
                XmlTextWriter w =  new XmlTextWriter(stream, null) ;
                w.Formatting = Formatting.Indented;

                WriteXml( w, mode);
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXml5"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void WriteXml(TextWriter writer, XmlWriteMode mode) 
        {
            if (writer != null) {
                XmlTextWriter w =  new XmlTextWriter(writer) ;
                w.Formatting = Formatting.Indented;

                WriteXml(w, mode);
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXml6"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void WriteXml(XmlWriter writer, XmlWriteMode mode) 
        {
            // Generate SchemaTree and write it out
            if (writer != null) {

                if (mode == XmlWriteMode.DiffGram) {
                    // Create and save the updates
//                    new UpdateTreeGen(UpdateTreeGen.UPDATE, (DataRowState)(-1), this).Save(writer, null);
                    new NewDiffgramGen(this).Save(writer);
                }
                else {
                    // Create and save xml data
                    new XmlDataTreeWriter(this).Save(writer, mode == XmlWriteMode.WriteSchema); 
                }
            }
        }
 
        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.WriteXml7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void WriteXml(String fileName, XmlWriteMode mode) 
        {
            XmlTextWriter xw = new XmlTextWriter( fileName, null );
            try {
                xw.Formatting = Formatting.Indented;
                xw.WriteStartDocument(true);
                if (xw != null) {
                    // Create and save the updates
                    if (mode == XmlWriteMode.DiffGram) {
                        new NewDiffgramGen(this).Save(xw);
                    }
                    else {
                        // Create and save xml data
                        new XmlDataTreeWriter(this).Save(xw, mode == XmlWriteMode.WriteSchema); 
                    }
                }
                xw.WriteEndDocument();
            }
            finally {
                xw.Close();
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Gets the collection of parent relations which belong to a
        ///       specified table.
        ///    </para>
        /// </devdoc>
        internal DataRelationCollection GetParentRelations(DataTable table) 
        {
            return table.ParentRelations;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Merge"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Merges this <see cref='System.Data.DataSet'/> into a specified <see cref='System.Data.DataSet'/>.
        ///    </para>
        /// </devdoc>
        public void Merge(DataSet dataSet) 
        {
            Merge(dataSet, false, MissingSchemaAction.Add);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Merge1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Merges this <see cref='System.Data.DataSet'/> into a specified <see cref='System.Data.DataSet'/> preserving changes according to
        ///       the specified argument.
        ///    </para>
        /// </devdoc>
        public void Merge(DataSet dataSet, bool preserveChanges) 
        {
            Merge(dataSet, preserveChanges, MissingSchemaAction.Add);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Merge2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Merges this <see cref='System.Data.DataSet'/> into a specified <see cref='System.Data.DataSet'/> preserving changes according to
        ///       the specified argument, and handling an incompatible schema according to the
        ///       specified argument.
        ///    </para>
        /// </devdoc>
        public void Merge(DataSet dataSet, bool preserveChanges, MissingSchemaAction missingSchemaAction) {
            // Argument checks
            if (dataSet == null)
                throw ExceptionBuilder.ArgumentNull("dataSet");

            if (!Enum.IsDefined(typeof(MissingSchemaAction), (int) missingSchemaAction))
                throw ExceptionBuilder.ArgumentOutOfRange("MissingSchemaAction");

            Merger merger = new Merger(this, preserveChanges, missingSchemaAction);
            merger.MergeDataSet(dataSet);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Merge3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Merges this <see cref='System.Data.DataTable'/> into a specified <see cref='System.Data.DataTable'/>.
        ///    </para>
        /// </devdoc>
        public void Merge(DataTable table) 
        {
            Merge(table, false, MissingSchemaAction.Add);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Merge4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Merges this <see cref='System.Data.DataTable'/> into a specified <see cref='System.Data.DataTable'/>. with a value to preserve changes
        ///       made to the target, and a value to deal with missing schemas.
        ///    </para>
        /// </devdoc>
        public void Merge(DataTable table, bool preserveChanges, MissingSchemaAction missingSchemaAction) 
        {
            // Argument checks
            if (table == null)
                throw ExceptionBuilder.ArgumentNull("table");

            if (!Enum.IsDefined(typeof(MissingSchemaAction), (int)missingSchemaAction))
                throw ExceptionBuilder.ArgumentOutOfRange("MissingSchemaAction");

            Merger merger = new Merger(this, preserveChanges, missingSchemaAction);
            merger.MergeTable(table);
        }


        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Merge5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Merge(DataRow[] rows) 
        {
            Merge(rows, false, MissingSchemaAction.Add);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Merge6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Merge(DataRow[] rows, bool preserveChanges, MissingSchemaAction missingSchemaAction) 
        {
            // Argument checks
            if (rows == null)
                throw ExceptionBuilder.ArgumentNull("rows");

            if (!Enum.IsDefined(typeof(MissingSchemaAction), (int) missingSchemaAction))
                throw ExceptionBuilder.ArgumentOutOfRange("MissingSchemaAction");

            Merger merger = new Merger(this, preserveChanges, missingSchemaAction);
            merger.MergeRows(rows);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.OnPropertyChanging"]/*' />
        protected internal virtual void OnPropertyChanging(PropertyChangedEventArgs pcevent) 
        {
            if (onPropertyChangingDelegate != null)
                onPropertyChangingDelegate(this, pcevent);
        }

        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.OnMergeFailed to send this event to any registered event
        ///     listeners.
        /// </devdoc>
        internal virtual void OnMergeFailed(MergeFailedEventArgs mfevent) 
        {
            if (onMergeFailed != null)
                onMergeFailed(this, mfevent);
            else 
                throw ExceptionBuilder.MergeFailed(mfevent.Conflict);
        }

        internal void RaiseMergeFailed(DataTable table, string conflict, MissingSchemaAction missingSchemaAction) 
        {
            if (MissingSchemaAction.Error == missingSchemaAction)
                throw ExceptionBuilder.MergeFailed(conflict);

            MergeFailedEventArgs mfevent = new MergeFailedEventArgs(table, conflict);
            OnMergeFailed(mfevent);
            return;
        }

        internal void OnDataRowCreated( DataRow row ) {
            if ( onDataRowCreated != null )
                onDataRowCreated( this, row );
        }

        internal void OnClearFunctionCalled( DataTable table ) {
            if ( onClearFunctionCalled != null )
                onClearFunctionCalled( this, table );
        }


        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.OnRemoveTable"]/*' />
        /// <devdoc>
        /// This method should be overriden by subclasses to restrict tables being removed.
        /// </devdoc>
        protected virtual void OnRemoveTable(DataTable table) 
        {
        }

        // UNDONE: This is a hack since we can't make an internal protected method yet.
        internal void OnRemoveTableHack(DataTable table) {
            OnRemoveTable(table);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.OnRemoveRelation"]/*' />
        /// <devdoc>
        /// This method should be overriden by subclasses to restrict tables being removed.
        /// </devdoc>
        protected virtual void OnRemoveRelation(DataRelation relation) 
        {
        }

        // UNDONE: This is a hack since we can't make an internal protected method yet.
        internal void OnRemoveRelationHack(DataRelation relation) 
        {
            OnRemoveRelation(relation);
        }


        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.RaisePropertyChanging"]/*' />
        protected internal void RaisePropertyChanging(string name) 
        {
            OnPropertyChanging(new PropertyChangedEventArgs(name));
        }

        internal DataTable[] TopLevelTables() 
        {
            // first let's figure out if we can represent the given dataSet as a tree using
            // the fact that all connected undirected graphs with n-1 edges are trees.
            ArrayList topTables = new ArrayList();

            for (int i = 0; i < Tables.Count; i++) 
            {
                DataTable table = Tables[i];
                if (table.ParentRelations.Count == 0)
                    topTables.Add(table);
                else {
                    bool fNested = false;
                    for (int j = 0; j < table.ParentRelations.Count; j++) 
                    {
                        
                        if ((table.ParentRelations[j].Nested) && (table.ParentRelations[j].ParentTable != table)) {
                            fNested = true;
                            break;
                        }
                    }
                    if (!fNested)
                        topTables.Add(table);
                }
            }
            if (topTables.Count == 0)
                return zeroTables;

            DataTable[] temp = new DataTable[topTables.Count];
            topTables.CopyTo(temp, 0);
            return temp;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.RejectChanges"]/*' />
        /// <devdoc>
        /// This method rolls back all the changes to have been made to this DataSet since
        /// it was loaded or the last time AcceptChanges was called.
        /// Any rows still in edit-mode cancel their edits.  New rows get removed.  Modified and
        /// Deleted rows return back to their original state.
        /// </devdoc>
        public virtual void RejectChanges() 
        {
            bool fEnforce = EnforceConstraints;
            EnforceConstraints = false;
            for (int i = 0; i < Tables.Count; i++)
                Tables[i].RejectChanges();
            EnforceConstraints = fEnforce;
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.Reset"]/*' />
        /// <devdoc>
        ///    Resets the dataSet back to it's original state.  Subclasses should override
        ///    to restore back to it's original state.
        ///    UNDONE: Not in spec.  Either DCR or rip.
        /// </devdoc>
        public virtual void Reset()
        {
            for (int i=0; i<Tables.Count; i++) {
                ConstraintCollection cons = Tables[i].Constraints;
                for (int j=0; j<cons.Count;) {
                    if (cons[j] is ForeignKeyConstraint) {
                        cons.Remove(cons[j]);
                    }
                    else
                        j++;
                }
            }
            Relations.Clear();
            Clear();
            Tables.Clear();
        }

        internal bool ValidateCaseConstraint () {
            DataRelation relation = null;
            for (int i = 0; i < Relations.Count; i++) {
                relation = Relations[i];
                if (relation.ChildTable.CaseSensitive != relation.ParentTable.CaseSensitive)
                    return false;
            }

            ForeignKeyConstraint constraint = null;
            ConstraintCollection constraints = null;
            for (int i = 0; i < Tables.Count; i++) {
                constraints = Tables[i].Constraints;
                for (int j = 0; j < constraints.Count; j++) {
                    if (constraints[j] is ForeignKeyConstraint) {
                        constraint = (ForeignKeyConstraint) constraints[j];
                        if (constraint.Table.CaseSensitive != constraint.RelatedTable.CaseSensitive)
                            return false;
                    }
                }
            }
            return true;
        }

        internal bool ValidateLocaleConstraint () {
            DataRelation relation = null;
            for (int i = 0; i < Relations.Count; i++) {
                relation = Relations[i];
                if (relation.ChildTable.Locale.LCID != relation.ParentTable.Locale.LCID)
                    return false;
            }

            ForeignKeyConstraint constraint = null;
            ConstraintCollection constraints = null;
            for (int i = 0; i < Tables.Count; i++) {
                constraints = Tables[i].Constraints;
                for (int j = 0; j < constraints.Count; j++) {
                    if (constraints[j] is ForeignKeyConstraint) {
                        constraint = (ForeignKeyConstraint) constraints[j];
                        if (constraint.Table.Locale.LCID != constraint.RelatedTable.Locale.LCID)
                            return false;
                    }
                }
            }
            return true;
        }
        
        // SDUB: may be better to rewrite this as nonrecursive?
        internal DataTable FindTable(DataTable baseTable, PropertyDescriptor[] props, int propStart) {
            if (props.Length < propStart + 1)
                return baseTable;

            PropertyDescriptor currentProp = props[propStart];     

            if (baseTable == null) {
                // the accessor is the table name.  if we don't find it, return null.
                if (currentProp is DataTablePropertyDescriptor) {
                    return FindTable(((DataTablePropertyDescriptor)currentProp).Table, props, propStart + 1);
                }
                return null;
            }

            if (currentProp is DataRelationPropertyDescriptor) {
                return FindTable(((DataRelationPropertyDescriptor)currentProp).Relation.ChildTable, props, propStart + 1);
            }

            return null;            
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.ReadXmlSerializable"]/*' />
        protected virtual void ReadXmlSerializable(XmlReader reader) {
            ReadXml(reader, XmlReadMode.DiffGram, true);
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.GetSchemaSerializable"]/*' />
        protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable() {
            return null;
        }

        // IXmlSerializable interface for Serialization.Xml
        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.IXmlSerializable.GetSchema"]/*' />
        /// <internalonly/>
        XmlSchema IXmlSerializable.GetSchema() {
            if (GetType() == typeof(DataSet)) {
                return null;
            }
            MemoryStream stream = new MemoryStream();
            // WriteXmlSchema(new XmlTextWriter(stream, null));
            XmlWriter writer = new XmlTextWriter(stream, null);
            if (writer != null) {
                 (new XmlTreeGen(SchemaFormat.WebService)).Save(this, writer);              
            }
            stream.Position = 0;
            return XmlSchema.Read(new XmlTextReader(stream), null);
//            return GetSchemaSerializable();
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.IXmlSerializable.ReadXml"]/*' />
        /// <internalonly/>
        void IXmlSerializable.ReadXml(XmlReader reader) {
            XmlTextReader textReader = reader as XmlTextReader;
            bool fNormalization = true;
            if (textReader != null) {
                fNormalization = textReader.Normalization;
                textReader.Normalization = false;
            }
            ReadXmlSerializable(textReader);

            if (textReader != null) {
                textReader.Normalization = fNormalization;
            }
        }

        /// <include file='doc\DataSet.uex' path='docs/doc[@for="DataSet.IXmlSerializable.WriteXml"]/*' />
        /// <internalonly/>
        void IXmlSerializable.WriteXml(XmlWriter writer) {
            WriteXmlSchema(writer);
            WriteXml(writer, XmlWriteMode.DiffGram);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataviewmanagerlistitemtypedescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataViewManagerListItemTypeDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;

    /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class DataViewManagerListItemTypeDescriptor : ICustomTypeDescriptor {

        private DataViewManager dataViewManager;
        private PropertyDescriptorCollection propsCollection;

        internal DataViewManagerListItemTypeDescriptor(DataViewManager dataViewManager) {
            this.dataViewManager = dataViewManager;
        }

        internal void Reset() {
            propsCollection = null;
        }

        internal DataView GetDataView(DataTable table) {
            DataView dataView = new DataView(table);
            dataView.SetDataViewManager(dataViewManager);
            return dataView;
        }        

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetAttributes"]/*' />
        /// <devdoc>
        ///     Retrieves an array of member attributes for the given object.
        /// </devdoc>
        AttributeCollection ICustomTypeDescriptor.GetAttributes() {
            return new AttributeCollection(null);
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetClassName"]/*' />
        /// <devdoc>
        ///     Retrieves the class name for this object.  If null is returned,
        ///     the type name is used.
        /// </devdoc>
        string ICustomTypeDescriptor.GetClassName() {
            return null;
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetComponentName"]/*' />
        /// <devdoc>
        ///     Retrieves the name for this object.  If null is returned,
        ///     the default is used.
        /// </devdoc>
        string ICustomTypeDescriptor.GetComponentName() {
            return null;
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetConverter"]/*' />
        /// <devdoc>
        ///      Retrieves the type converter for this object.
        /// </devdoc>
        TypeConverter ICustomTypeDescriptor.GetConverter() {
            return null;
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetDefaultEvent"]/*' />
        /// <devdoc>
        ///     Retrieves the default event.
        /// </devdoc>
        EventDescriptor ICustomTypeDescriptor.GetDefaultEvent() {
            return null;
        }


        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///     Retrieves the default property.
        /// </devdoc>
        PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty() {
            return null;
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetEditor"]/*' />
        /// <devdoc>
        ///      Retrieves the an editor for this object.
        /// </devdoc>
        object ICustomTypeDescriptor.GetEditor(Type editorBaseType) {
            return null;
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetEvents"]/*' />
        /// <devdoc>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.
        /// </devdoc>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents() {
            return new EventDescriptorCollection(null);
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetEvents1"]/*' />
        /// <devdoc>
        ///     Retrieves an array of events that the given component instance
        ///     provides.  This may differ from the set of events the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional events.  The returned array of events will be
        ///     filtered by the given set of attributes.
        /// </devdoc>
        EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes) {
            return new EventDescriptorCollection(null);
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetProperties"]/*' />
        /// <devdoc>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.
        /// </devdoc>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties() {
            return((ICustomTypeDescriptor)this).GetProperties(null);
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetProperties1"]/*' />
        /// <devdoc>
        ///     Retrieves an array of properties that the given component instance
        ///     provides.  This may differ from the set of properties the class
        ///     provides.  If the component is sited, the site may add or remove
        ///     additional properties.  The returned array of properties will be
        ///     filtered by the given set of attributes.
        /// </devdoc>
        PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes) {
            if (propsCollection == null) {
                PropertyDescriptor[] props = null;
                DataSet dataSet = dataViewManager.DataSet;
                if (dataSet != null) {
                    int tableCount = dataSet.Tables.Count;
                    props = new PropertyDescriptor[tableCount];
                    for (int i = 0; i < tableCount; i++) {
                        props[i] = new DataTablePropertyDescriptor(dataSet.Tables[i]);
                    }
                }                                
                propsCollection = new PropertyDescriptorCollection(props);
            }
            return propsCollection;
        }

        /// <include file='doc\DataViewManagerListItemTypeDescriptor.uex' path='docs/doc[@for="DataViewManagerListItemTypeDescriptor.ICustomTypeDescriptor.GetPropertyOwner"]/*' />
        /// <devdoc>
        ///     Retrieves the object that directly depends on this value being edited.  This is
        ///     generally the object that is required for the PropertyDescriptor's GetValue and SetValue
        ///     methods.  If 'null' is passed for the PropertyDescriptor, the ICustomComponent
        ///     descripotor implemementation should return the default object, that is the main
        ///     object that exposes the properties and attributes,
        /// </devdoc>
        object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd) {
            return this;
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataviewrowstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataViewRowState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Drawing.Design;
    using System.ComponentModel;

    /// <include file='doc\DataViewRowState.uex' path='docs/doc[@for="DataViewRowState"]/*' />
    /// <devdoc>
    /// <para>Describes the version of data in a <see cref='System.Data.DataRow'/>.</para>
    /// </devdoc>
    [
    Flags,
    Editor("Microsoft.VSDesigner.Data.Design.DataViewRowStateEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor))
    ]
    public enum DataViewRowState {

        /// <include file='doc\DataViewRowState.uex' path='docs/doc[@for="DataViewRowState.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       None.
        ///    </para>
        /// </devdoc>
        None = 0x00000000,
        // DataRowState.Detached = 0x01,
        /// <include file='doc\DataViewRowState.uex' path='docs/doc[@for="DataViewRowState.Unchanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Unchanged row.
        ///    </para>
        /// </devdoc>
        Unchanged = DataRowState.Unchanged,
        /// <include file='doc\DataViewRowState.uex' path='docs/doc[@for="DataViewRowState.New"]/*' />
        /// <devdoc>
        ///    <para>
        ///       New row.
        ///    </para>
        /// </devdoc>
        Added = DataRowState.Added,
        /// <include file='doc\DataViewRowState.uex' path='docs/doc[@for="DataViewRowState.Deleted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Deleted row.
        ///    </para>
        /// </devdoc>
        Deleted   = DataRowState.Deleted,
        /// <include file='doc\DataViewRowState.uex' path='docs/doc[@for="DataViewRowState.ModifiedCurrent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Current version, which is a modified version of original
        ///       data (see <see langword='ModifiedOriginal'/>
        ///       ).
        ///    </para>
        /// </devdoc>
        ModifiedCurrent  = DataRowState.Modified,
        /// <include file='doc\DataViewRowState.uex' path='docs/doc[@for="DataViewRowState.ModifiedOriginal"]/*' />
        /// <devdoc>
        ///    <para>The original version (although it has since been
        ///       modified and is available as <see langword='ModifiedCurrent'/>).</para>
        /// </devdoc>
        ModifiedOriginal  = (((int)ModifiedCurrent) << 1),

        /// <include file='doc\DataViewRowState.uex' path='docs/doc[@for="DataViewRowState.OriginalRows"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Original rows, including unchanged and
        ///       deleted rows.
        ///    </para>
        /// </devdoc>
        OriginalRows = Unchanged | Deleted | ModifiedOriginal,
        /// <include file='doc\DataViewRowState.uex' path='docs/doc[@for="DataViewRowState.CurrentRows"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Current rows, including unchanged, new, and modified rows.
        ///    </para>
        /// </devdoc>
        CurrentRows  = Unchanged | Added | ModifiedCurrent
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataviewsetting.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataViewSetting.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;

    /// <include file='doc\DataViewSetting.uex' path='docs/doc[@for="DataViewSetting"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    TypeConverter((typeof(ExpandableObjectConverter))),
    Serializable
    ]
    public class DataViewSetting {
        DataViewManager dataViewManager;
        DataTable       table;
        string sort      = "";
        string rowFilter = "";
        DataViewRowState rowStateFilter = DataViewRowState.CurrentRows;
        bool applyDefaultSort = false;

        /// <include file='doc\DataViewSetting.uex' path='docs/doc[@for="DataViewSetting.DataViewSetting"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal DataViewSetting() {}

        /// <include file='doc\DataViewSetting.uex' path='docs/doc[@for="DataViewSetting.DataViewSetting1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal DataViewSetting(string sort, string rowFilter, DataViewRowState rowStateFilter) {
            this.sort = sort;
            this.rowFilter = rowFilter;
            this.rowStateFilter = rowStateFilter; 
        }

        /// <include file='doc\DataViewSetting.uex' path='docs/doc[@for="DataViewSetting.ApplyDefaultSort"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool ApplyDefaultSort {
            get {
                return applyDefaultSort;
            }
            set {
                if (applyDefaultSort != value) {
                    applyDefaultSort = value;
                }
            }
        }

        /// <include file='doc\DataViewSetting.uex' path='docs/doc[@for="DataViewSetting.DataViewManager"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public DataViewManager DataViewManager {
            get {
                return dataViewManager;
            }
        }

        internal void SetDataViewManager(DataViewManager dataViewManager) {
            if(this.dataViewManager != dataViewManager) {
                if(this.dataViewManager != null) {
                    // throw exception here;
                }
                this.dataViewManager = dataViewManager;
            }
        }

        /// <include file='doc\DataViewSetting.uex' path='docs/doc[@for="DataViewSetting.Table"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public DataTable Table {
            get {
                return table;
            }
        }

        internal void SetDataTable(DataTable table) {
            if(this.table != table) {
                if(this.table != null) {
                    // throw exception here;
                }
                this.table = table;
            }
        }

        /// <include file='doc\DataViewSetting.uex' path='docs/doc[@for="DataViewSetting.RowFilter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string RowFilter {
            get {
                return rowFilter;
            }
            set {
                if (value == null)
                    value = "";

                if (this.rowFilter != value) {
                    // TODO: validate.
                    this.rowFilter = value;
                }
            }
        }

        /// <include file='doc\DataViewSetting.uex' path='docs/doc[@for="DataViewSetting.RowStateFilter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataViewRowState RowStateFilter {
            get {
                return rowStateFilter;
            }
            set {
                if (this.rowStateFilter != value) {
                    // TODO: validate.
                    this.rowStateFilter = value;
                }
            }
        }

        /// <include file='doc\DataViewSetting.uex' path='docs/doc[@for="DataViewSetting.Sort"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Sort {
            get {
                return sort;
            }
            set {
                if (value == null)
                    value = "";

                if (this.sort != value) {
                    // TODO: validate.
                    this.sort = value;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataviewmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataViewManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.IO;
    using System.Xml;
    using System.ComponentModel;
    using System.Collections;

    /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Designer("Microsoft.VSDesigner.Data.VS.DataViewManagerDesigner, " + AssemblyRef.MicrosoftVSDesigner)
    ]
    public class DataViewManager : MarshalByValueComponent, IBindingList, System.ComponentModel.ITypedList {
        private DataViewSettingCollection dataViewSettingsCollection;
        private DataSet dataSet;
        private DataViewManagerListItemTypeDescriptor item;
        private bool locked;
        internal int nViews = 0;

        private System.ComponentModel.ListChangedEventHandler onListChanged;

	private static NotSupportedException NotSupported = new NotSupportedException();

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.DataViewManager"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataViewManager() : this(null, false) {}

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.DataViewManager1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataViewManager(DataSet dataSet) : this(dataSet, false) {}

        internal DataViewManager(DataSet dataSet, bool locked) {
            GC.SuppressFinalize(this);
            this.dataSet = dataSet;
            if (this.dataSet != null) {
                this.dataSet.Tables.CollectionChanged += new CollectionChangeEventHandler(TableCollectionChanged);
                this.dataSet.Relations.CollectionChanged += new CollectionChangeEventHandler(RelationCollectionChanged);
            }
            this.locked = locked;
            this.item = new DataViewManagerListItemTypeDescriptor(this);
            this.dataViewSettingsCollection = new DataViewSettingCollection(this);
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.DataSet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(null),
        DataSysDescription(Res.DataViewManagerDataSetDescr)
        ]
        public DataSet DataSet {
            get {
                return dataSet;
            }
            set {
                if (value == null)
                    throw ExceptionBuilder.SetFailed("DataSet to null");

                if (locked)
                    throw ExceptionBuilder.SetDataSetFailed();

                if (dataSet != null) {
                    if (nViews > 0)
                        throw ExceptionBuilder.CanNotSetDataSet();

                    this.dataSet.Tables.CollectionChanged -= new CollectionChangeEventHandler(TableCollectionChanged);
                    this.dataSet.Relations.CollectionChanged -= new CollectionChangeEventHandler(RelationCollectionChanged);
                }

                this.dataSet = value;
                this.dataSet.Tables.CollectionChanged += new CollectionChangeEventHandler(TableCollectionChanged);
                this.dataSet.Relations.CollectionChanged += new CollectionChangeEventHandler(RelationCollectionChanged);
                this.dataViewSettingsCollection = new DataViewSettingCollection(this);
                item.Reset();
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.DataViewSettings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        DataSysDescription(Res.DataViewManagerTableSettingsDescr)
        ]        
        public DataViewSettingCollection DataViewSettings {
            get {
                return dataViewSettingsCollection;
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.DataViewSettingCollectionString"]/*' />
        public string DataViewSettingCollectionString {
            get {
                if (dataSet == null)
                    return "";

                string str = "<DataViewSettingCollectionString>";
                foreach (DataTable dt in dataSet.Tables) {
                    DataViewSetting ds=dataViewSettingsCollection[dt];
                    str = str + string.Format("<{0} Sort=\"{1}\" RowFilter=\"{2}\" RowStateFilter=\"{3}\"/>",dt.EncodedTableName,ds.Sort,ds.RowFilter,ds.RowStateFilter);
                }
                str = str + "</DataViewSettingCollectionString>";
                return str;
            }
            set {
                if (value == null || value == "")
                    return;

                XmlTextReader r = new XmlTextReader(new StringReader(value));
                r.WhitespaceHandling = WhitespaceHandling.None;
                r.Read();
                if (r.Name != "DataViewSettingCollectionString")
                    throw ExceptionBuilder.SetFailed("DataViewSettingCollectionString");
                while (r.Read()) {
                    if (r.NodeType != XmlNodeType.Element)
                        continue;

                    string table = XmlConvert.DecodeName(r.LocalName);
                    if (r.MoveToAttribute("Sort"))
                        dataViewSettingsCollection[table].Sort = r.Value;

                    if (r.MoveToAttribute("RowFilter"))
                        dataViewSettingsCollection[table].RowFilter = r.Value;

                    if (r.MoveToAttribute("RowStateFilter"))
                        dataViewSettingsCollection[table].RowStateFilter = (DataViewRowState)Enum.Parse(typeof(DataViewRowState),r.Value);
                }
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            DataViewManagerListItemTypeDescriptor[] items = new DataViewManagerListItemTypeDescriptor[1];
            ((ICollection)this).CopyTo(items, 0);
            return items.GetEnumerator();
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get {
                return 1;
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.IsReadOnly"]/*' />
        /// <internalonly/>
        bool IList.IsReadOnly {
            get {
                return true;
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return true;
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            array.SetValue((object)(new DataViewManagerListItemTypeDescriptor(this)), index);
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get {
                return item;
            }
            set {
                throw ExceptionBuilder.CannotModifyCollection();
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object value) {
            throw ExceptionBuilder.CannotModifyCollection();
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.Clear"]/*' />
        /// <internalonly/>
        void IList.Clear() {
            throw ExceptionBuilder.CannotModifyCollection();
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object value) {
            return(value == item);
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object value) {
            return(value == item) ? 1 : -1;
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object value) {
            throw ExceptionBuilder.CannotModifyCollection();
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object value) {
            throw ExceptionBuilder.CannotModifyCollection();
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IList.RemoveAt"]/*' />
        /// <internalonly/>
        void IList.RemoveAt(int index) {
            throw ExceptionBuilder.CannotModifyCollection();
        }

		// ------------- IBindingList: ---------------------------

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.AllowNew"]/*' />
		/// <internalonly/>
		bool IBindingList.AllowNew {
			get {
				return false;
			}
		}
		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.AddNew"]/*' />
		/// <internalonly/>
		object IBindingList.AddNew() {
			throw NotSupported;
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.AllowEdit"]/*' />
		/// <internalonly/>
		bool IBindingList.AllowEdit {
			get { 
				return false;
			}
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.AllowRemove"]/*' />
		/// <internalonly/>
		bool IBindingList.AllowRemove {
			get {
				return false;
			}
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.SupportsChangeNotification"]/*' />
		/// <internalonly/>
		bool IBindingList.SupportsChangeNotification { 
			get {
				return true;
			}
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.SupportsSearching"]/*' />
		/// <internalonly/>
		bool IBindingList.SupportsSearching { 
			get {
				return false;
			}
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.SupportsSorting"]/*' />
		/// <internalonly/>
		bool IBindingList.SupportsSorting { 
			get {
				return false;
			}
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.IsSorted"]/*' />
		/// <internalonly/>
		bool IBindingList.IsSorted { 
			get {
				throw NotSupported;
			}
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.SortProperty"]/*' />
		/// <internalonly/>
		PropertyDescriptor IBindingList.SortProperty {
			get {
				throw NotSupported;
			}
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.SortDirection"]/*' />
		/// <internalonly/>
		ListSortDirection IBindingList.SortDirection {
			get {
				throw NotSupported;
			}
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.ListChanged"]/*' />
		public event System.ComponentModel.ListChangedEventHandler ListChanged {
			add {
				onListChanged += value;
			}
			remove {
				onListChanged -= value;
			}
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.AddIndex"]/*' />
		/// <internalonly/>
		void IBindingList.AddIndex(PropertyDescriptor property) {
			// no operation
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.ApplySort"]/*' />
		/// <internalonly/>
		void IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction) {
			throw NotSupported;
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.Find"]/*' />
		/// <internalonly/>
		int IBindingList.Find(PropertyDescriptor property, object key) {
                    throw NotSupported;
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.RemoveIndex"]/*' />
		/// <internalonly/>
		void IBindingList.RemoveIndex(PropertyDescriptor property) {
			// no operation
		}

		/// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.IBindingList.RemoveSort"]/*' />
		/// <internalonly/>
		void IBindingList.RemoveSort() {
			throw NotSupported;
		}

		/*
		string IBindingList.GetListName() {
			return ((System.Data.ITypedList)this).GetListName(null);
		}
		string IBindingList.GetListName(PropertyDescriptor[] listAccessors) {
			return ((System.Data.ITypedList)this).GetListName(listAccessors);
		}
		*/

        // SDUB: GetListName and GetItemProperties almost the same in DataView and DataViewManager
        string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors) {
            DataSet dataSet = DataSet;
            if (dataSet == null)
                throw ExceptionBuilder.CanNotUseDataViewManager();

            if (listAccessors == null || listAccessors.Length == 0) {
                return dataSet.DataSetName;
            }
            else {
                DataTable table = dataSet.FindTable(null, listAccessors, 0);
                if (table != null) {
                    return table.TableName;
                }
            }
            return String.Empty;
        }

        PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors) {
            DataSet dataSet = DataSet;
            if (dataSet == null)
                throw ExceptionBuilder.CanNotUseDataViewManager();

            if (listAccessors == null || listAccessors.Length == 0) {
                return((ICustomTypeDescriptor)(new DataViewManagerListItemTypeDescriptor(this))).GetProperties();
            }
            else {
                DataTable table = dataSet.FindTable(null, listAccessors, 0);
                if (table != null) {
                    return table.GetPropertyDescriptorCollection(null);
                }
            }
            return new PropertyDescriptorCollection(null);
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.CreateDataView"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataView CreateDataView(DataTable table) {
            if (dataSet == null)
                throw ExceptionBuilder.CanNotUseDataViewManager();

            DataView dataView = new DataView(table);
            dataView.SetDataViewManager(this);
            return dataView;
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.OnListChanged"]/*' />
        protected virtual void OnListChanged(ListChangedEventArgs e) {
            try {
                if (onListChanged != null) {
                    onListChanged(this, e);
                }
            }
            catch (Exception) {
            }
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.TableCollectionChanged"]/*' />
        protected virtual void TableCollectionChanged(object sender, CollectionChangeEventArgs e) {
             PropertyDescriptor NullProp = null;
             OnListChanged(
                 e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded, new DataTablePropertyDescriptor((System.Data.DataTable)e.Element)) :
                 e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged, NullProp) :
                 e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted, new DataTablePropertyDescriptor((System.Data.DataTable)e.Element)) :
                 /*default*/ null
             );
        }

        /// <include file='doc\DataViewManager.uex' path='docs/doc[@for="DataViewManager.RelationCollectionChanged"]/*' />
        protected virtual void RelationCollectionChanged(object sender, CollectionChangeEventArgs e) {
            DataRelationPropertyDescriptor NullProp = null;
            OnListChanged(
                e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded, new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) :
                e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged, NullProp):
                e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted, new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) :
            /*default*/ null
            );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataview.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.Globalization;
    
    /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a databindable, customized view of a <see cref='System.Data.DataTable'/>
    ///       for sorting, filtering, searching, editing, and navigation.
    ///    </para>
    /// </devdoc>
    [
    Designer("Microsoft.VSDesigner.Data.VS.DataViewDesigner, " + AssemblyRef.MicrosoftVSDesigner),
    Editor("Microsoft.VSDesigner.Data.Design.DataSourceEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    DefaultProperty("Table"),
    DefaultEvent("PositionChanged")
    ]
    public class DataView : 
        MarshalByValueComponent, IBindingList, System.ComponentModel.ITypedList, ISupportInitialize {
        private DataViewManager dataViewManager;
        private DataTable table;
        private bool locked = false;
        private Index index;
        private int recordCount;
        Hashtable findIndexes;
        ArrayList delayBeginEditList;

        private string sort = "";
        private DataFilter rowFilter = null;
        private DataViewRowState recordStates = DataViewRowState.CurrentRows;

        private bool shouldOpen = true;
        private bool open = false;

        internal DataRow addNewRow;

        private bool allowNew = true;
        private bool allowEdit = true;
        private bool allowDelete = true;
        private bool applyDefaultSort = false;

        bool suspendChangeEvents = false;
        private bool handledOnIndexListChanged = false;
        // compmod.TableChangedEventHandler will be repalces by  compmod.ListChangedEventHandler
        private System.ComponentModel.ListChangedEventHandler onListChanged;
        internal static ListChangedEventArgs ResetEventArgs = new ListChangedEventArgs(ListChangedType.Reset, -1);

        private DataTable delayedTable = null;
        private string delayedRowFilter = null;
        private string delayedSort = null;
        private DataViewRowState delayedRecordStates = (DataViewRowState)(-1);
        private bool fInitInProgress = false;
        private bool fEndInitInProgress = false;

        DataRowView[] rowViewCache = null;

        DataViewListener dvListener = null;

        internal DataView(DataTable table, bool locked) {
            this.dvListener = new DataViewListener(this);
            GC.SuppressFinalize(this);

            this.locked = locked;
            this.table = table;
            dvListener.RegisterMetaDataEvents(this.table);
            SetIndex("", DataViewRowState.CurrentRows, null);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.DataView"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.DataView'/> class.</para>
        /// </devdoc>
        public DataView() : this(null) {
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.DataView1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.DataView'/> class with the
        ///    specified <see cref='System.Data.DataTable'/>.</para>
        /// </devdoc>
        public DataView(DataTable table) : this(table, false) {
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.DataView2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.DataView'/> class with the
        ///    specified <see cref='System.Data.DataTable'/>.</para>
        /// </devdoc>
        public DataView(DataTable table, String RowFilter, string Sort, DataViewRowState RowState) {
            GC.SuppressFinalize(this);
            if (table == null)
                throw ExceptionBuilder.CanNotUse();

            this.dvListener = new DataViewListener(this);
            this.locked = false;
            this.table = table;
            dvListener.RegisterMetaDataEvents(this.table);

            if ((((int)RowState) &
                 ((int)~(DataViewRowState.CurrentRows | DataViewRowState.OriginalRows))) != 0) {
                throw ExceptionBuilder.RecordStateRange();
            }
            else if (( ((int)RowState) & ((int)DataViewRowState.ModifiedOriginal) ) != 0 &&
                     ( ((int)RowState) &  ((int)DataViewRowState.ModifiedCurrent) ) != 0 
                    ) {
                throw ExceptionBuilder.SetRowStateFilter();
            }

            if (Sort == null)
                Sort = "";

            if (RowFilter == null)
                RowFilter = "";
            DataFilter newFilter = new DataFilter(RowFilter, table);

            SetIndex(Sort, RowState, newFilter);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.AllowDelete"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets or gets a value indicating whether deletes are
        ///       allowed.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(true),
        DataSysDescription(Res.DataViewAllowDeleteDescr)
        ]
        public bool AllowDelete {
            get {
                return allowDelete;
            }
            set {
                if (allowDelete != value) {
                    allowDelete = value;
                    OnListChanged(ResetEventArgs);
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.ApplyDefaultSort"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether to use the default sort.</para>
        /// </devdoc>
        [
        RefreshProperties(RefreshProperties.All),
        DataCategory(Res.DataCategory_Data),
        DefaultValue(false),
        DataSysDescription(Res.DataViewApplyDefaultSortDescr)
        ]
        public bool ApplyDefaultSort {
            get {
                return applyDefaultSort;
            }
            set {
                if (applyDefaultSort != value) {
                    applyDefaultSort = value;
                    UpdateIndex(true);
                    OnListChanged(ResetEventArgs);
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.AllowEdit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether edits are allowed.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(true),
        DataSysDescription(Res.DataViewAllowEditDescr)
        ]
        public bool AllowEdit {
            get {
                return allowEdit;
            }
            set {
                if (allowEdit != value) {
                    allowEdit = value;
                    OnListChanged(ResetEventArgs);
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.AllowNew"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the new rows can
        ///       be added using the <see cref='System.Data.DataView.AddNew'/>
        ///       method.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(true),
        DataSysDescription(Res.DataViewAllowNewDescr)
        ]
        public bool AllowNew {
            get {
                return allowNew;
            }
            set {
                if (allowNew != value) {
                    allowNew = value;
                    OnListChanged(ResetEventArgs);
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of records in the <see cref='System.Data.DataView'/>
        ///       .
        ///    </para>
        /// </devdoc>
        [Browsable(false), DataSysDescription(Res.DataViewCountDescr)]
        public int Count {
            get {
                return recordCount;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.DataViewManager"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Data.DataViewManager'/> associated with this <see cref='System.Data.DataView'/> .
        ///    </para>
        /// </devdoc>
        [Browsable(false), DataSysDescription(Res.DataViewDataViewManagerDescr)]
        public DataViewManager DataViewManager {
            get {
                return dataViewManager;
            }
        }

        // TODO: handle all kinds of property changes.
        internal void SetDataViewManager(DataViewManager dataViewManager) {
            if (this.table == null)
                throw ExceptionBuilder.CanNotUse();

            if (this.dataViewManager != dataViewManager) {
                if (dataViewManager != null)
                    dataViewManager.nViews--;
                this.dataViewManager = dataViewManager;
                if (dataViewManager != null) {
                    dataViewManager.nViews++;
                    DataViewSetting dataViewSetting = dataViewManager.DataViewSettings[table];
                    try {
                        // sdub: check that we will not do unnesasary operation here if dataViewSetting.Sort == this.Sort ...
                        applyDefaultSort = dataViewSetting.ApplyDefaultSort;
                        DataFilter newFilter = new DataFilter(dataViewSetting.RowFilter, table);
                        SetIndex(dataViewSetting.Sort, dataViewSetting.RowStateFilter, newFilter);
                    }catch (Exception) {}
                    locked = true;
                } else {
                    SetIndex("", DataViewRowState.CurrentRows, null);
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IsOpen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the data source is currently open and
        ///       projecting views of data on the <see cref='System.Data.DataTable'/>.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DataSysDescription(Res.DataViewIsOpenDescr)]
        protected bool IsOpen {
            get {
                return open;
            }
        }
      
        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// private implementation.
        /// </devdoc>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.RowFilter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the expression used to filter which rows are viewed in the
        ///    <see cref='System.Data.DataView'/>.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        DataSysDescription(Res.DataViewRowFilterDescr)
        ]
        public virtual string RowFilter {
            get {       // ACCESSOR: virtual was missing from this get
                return(rowFilter == null ? "" : rowFilter.Expression); // CONSIDER: return optimized expression here
            }
            set {
#if DEBUG
                if (CompModSwitches.DataView.TraceVerbose) {
                    Debug.WriteLine("set RowFilter to " + value);
                }
#endif
                if (value == null)
                    value = "";

                if (fInitInProgress) {
                    delayedRowFilter = value;
                    return;
                }

                CultureInfo locale = (table != null ? table.Locale : CultureInfo.CurrentCulture);
                if (null == rowFilter || (String.Compare(rowFilter.Expression,value,false,locale) != 0)) {
                    DataFilter newFilter = new DataFilter(value, table);
                    SetIndex(sort, recordStates, newFilter);
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.RowStateFilter"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the row state filter used in the <see cref='System.Data.DataView'/>.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(DataViewRowState.CurrentRows),
        DataSysDescription(Res.DataViewRowStateFilterDescr)
        ]
        public DataViewRowState RowStateFilter {
            get {
                return recordStates;
            }
            set {
#if DEBUG
                if (CompModSwitches.DataView.TraceVerbose) {
                    Debug.WriteLine("set RowStateFilter to " + ((int)value));
                }
#endif
                if (fInitInProgress) {
                    delayedRecordStates = value;
                    return;
                }

                if ((((int)value) &
                     ((int)~(DataViewRowState.CurrentRows | DataViewRowState.OriginalRows))) != 0)
                    throw ExceptionBuilder.RecordStateRange();
                else if (( ((int)value) & ((int)DataViewRowState.ModifiedOriginal) ) != 0 &&
                         ( ((int)value) &  ((int)DataViewRowState.ModifiedCurrent) ) != 0 
                        )
                    throw ExceptionBuilder.SetRowStateFilter();

                if (recordStates != value) {
                    SetIndex(sort, value, rowFilter);
                }
            }
        }

        internal DataRowView[] RowViewCache {
            get {
                if (rowViewCache == null) {
                    rowViewCache = new DataRowView[Count];
                    for (int i = 0; i < Count; i++) {
                        rowViewCache[i] = new DataRowView(this, i);
                    }
                }
                return rowViewCache;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Sort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the sort column or columns, and sort order for the table.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(""),
        DataSysDescription(Res.DataViewSortDescr)
        ]
        public string Sort {
            get {
                if (sort.Length == 0 && applyDefaultSort && table != null && table.primaryIndex.Length > 0) {
                    return table.FormatSortString(table.primaryIndex);
                }
                else {
                    return sort;
                }
            }
            set {
#if DEBUG
                if (CompModSwitches.DataView.TraceVerbose) {
                    Debug.WriteLine("set Sort to ..");
                }
#endif
                if (value == null) {
                    value = "";
                }

                if (fInitInProgress) {
                    delayedSort = value;
                    return;
                }

                CultureInfo locale = (table != null ? table.Locale : CultureInfo.CurrentCulture);
                if (String.Compare(sort, value, false, locale) != 0) {
                    CheckSort(value);
                    SetIndex(value, recordStates, rowFilter);
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.ResetSort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Data.DataView.Sort'/> property to its default state.
        ///    </para>
        /// </devdoc>
        private void ResetSort() {
            sort = "";
            SetIndex(sort, recordStates, rowFilter);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.ShouldSerializeSort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Data.DataView.Sort'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeSort() {
            return(sort != null);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// private implementation.
        /// </devdoc>
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Table"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the source <see cref='System.Data.DataTable'/>.
        ///    </para>
        /// </devdoc>
        [
        TypeConverterAttribute(typeof(DataTableTypeConverter)),
        DataCategory(Res.DataCategory_Data),
        DefaultValue(null),
        RefreshProperties(RefreshProperties.All),
        DataSysDescription(Res.DataViewTableDescr)
        ]
        public DataTable Table {
            get {
                return table;
            }
            set {
#if DEBUG
                if (CompModSwitches.DataView.TraceVerbose) {
                    Debug.WriteLine("set Table to " + (value == null ? "<null>" : value.ToString()));
                }
#endif
                if (fInitInProgress && value != null) {
                    delayedTable = value;
                    return;
                }

                if (locked)
                    throw ExceptionBuilder.SetTable();

                if (dataViewManager != null)
                    throw ExceptionBuilder.CanNotSetTable();

                if (value != null && value.TableName.Equals(string.Empty))
                    throw ExceptionBuilder.CanNotBindTable();

                if (table != value) {
                    dvListener.UnregisterMetaDataEvents(this.table);
                    table = value;
                    if (table != null) {
                        dvListener.RegisterMetaDataEvents(this.table);
                        OnListChanged(new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged, new DataTablePropertyDescriptor(table)));
                    }
                    SetIndex("", DataViewRowState.CurrentRows, null);
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int recordIndex] {
            get {
                return GetElement(recordIndex);
            }
            set {
                throw ExceptionBuilder.SetIListObject();
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a row of data from a specified table.
        ///    </para>
        /// </devdoc>
        public DataRowView this[int recordIndex] {
            get {
                return GetElement(recordIndex);
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.AddNew"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a new row of data.
        ///    </para>
        /// </devdoc>
        public virtual DataRowView AddNew() {
            CheckOpen();         

            if (!AllowNew)
                throw ExceptionBuilder.AddNewNotAllowNull();
            if (addNewRow != null) {
                FinishAddNew(recordCount-1, true);
                SetDelayBeginEdit(addNewRow, false);
            }

            addNewRow = table.NewRow();
            recordCount++;
            OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, recordCount - 1));
            return this[recordCount - 1];
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.BeginInit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void BeginInit() {
            fInitInProgress = true;
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.EndInit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void EndInit() {
            if (delayedTable != null && this.delayedTable.fInitInProgress) {
                this.delayedTable.delayedViews.Add(this);
                return;
            }

            fInitInProgress = false;
            fEndInitInProgress = true;
            if (delayedTable != null) {
                Table = delayedTable;
                delayedTable = null;
            }
            if (delayedSort != null) {
                Sort = delayedSort;
                delayedSort = null;
            }
            if (delayedRowFilter != null) {
                RowFilter = delayedRowFilter;
                delayedRowFilter = null;
            }
            if (delayedRecordStates != (DataViewRowState)(-1)) {
                RowStateFilter = delayedRecordStates;
                delayedRecordStates = (DataViewRowState)(-1);
            }
            fEndInitInProgress = false;

            SetIndex(Sort, RowStateFilter, rowFilter);
        }

        private void CheckOpen() {
            if (!IsOpen) throw ExceptionBuilder.NotOpen();
        }

        private void CheckSort(string sort) {
            if (table == null)
                throw ExceptionBuilder.CanNotUse();
            if (sort.Length == 0)
                return;
            table.ParseSortString(sort);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the <see cref='System.Data.DataView'/>
        ///       .
        ///    </para>
        /// </devdoc>
        protected void Close() {
            shouldOpen = false;
            UpdateIndex();
            dvListener.UnregisterMetaDataEvents(this.table);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.CopyTo"]/*' />
        //  Copy items into array. Only for Web Forms Interfaces.
        public void CopyTo(Array array, int index) {
            for (int i = 0; i < Count; i++) {
                array.SetValue((object) new DataRowView(this, i), i + index);
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.CreateChildView"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Data.DataView'/> on a related
        ///       table filtered on the relation specified by name, and index.
        ///    </para>
        /// </devdoc>
        internal DataView CreateChildView(string relationName, int recordIndex) {
            return CreateChildView(table.ChildRelations[relationName], recordIndex);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.CreateChildView1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a <see cref='System.Data.DataView'/> on a related table filtered on
        ///       the specified <see cref='System.Data.DataRelation'/>, and index.
        ///    </para>
        /// </devdoc>
        internal DataView CreateChildView(DataRelation relation, int recordIndex) {
            if (relation == null || relation.ParentKey.Table != Table) {
                throw ExceptionBuilder.CreateChildView();
            }
            object[] values = table.GetKeyValues(relation.ParentKey, GetRecord(recordIndex));
            DataView childView = new RelatedView(relation.ChildColumns, values);
            childView.SetDataViewManager(dataViewManager);
            return childView;
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Delete"]/*' />
        /// <devdoc>
        ///    <para>Deletes a row at the specified index.</para>
        /// </devdoc>
        public void Delete(int index) {
            CheckOpen();
            if (addNewRow != null && index == this.index.RecordCount) {
                // We are deleteing just added record.
                FinishAddNew(0, false);
                return;
            }
                
            if (!AllowDelete)
                throw ExceptionBuilder.CanNotDelete();
            DataRow row = GetRow(index);
            row.Delete();
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
            	Close();
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Find"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Finds a row in the <see cref='System.Data.DataView'/> by the specified primary key
        ///       value.
        ///    </para>
        /// </devdoc>
        public int Find(object key) {
            return index.FindRecordByKey(key);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Find1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Finds a row in the <see cref='System.Data.DataView'/> by the specified primary key values.
        ///    </para>
        /// </devdoc>
        public int Find(object[] key) {
            return index.FindRecordByKey(key);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.FindRows"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Finds a row in the <see cref='System.Data.DataView'/> by the specified primary key
        ///       value.
        ///    </para>
        /// </devdoc>
        public DataRowView[] FindRows(object key) {
            return FindRows(new object[] {key});
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.FindRows1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Finds a row in the <see cref='System.Data.DataView'/> by the specified primary key values.
        ///    </para>
        /// </devdoc>
        public DataRowView[] FindRows(object[] key) {
            Range range = index.FindRecords(key);
            if (range.IsNull) {
                return new DataRowView[0];
            }
            DataRowView[] cache = RowViewCache;
            int count = range.Count;
            DataRowView[] rows = new DataRowView[count];
            for (int i=0; i<count; i++) {
                rows[i] = cache[i+range.Min];
            }
            return rows;
        }

        internal void FinishAddNew(int currentIndex, bool success) {
            if (success) {
                suspendChangeEvents = true;
                DataRow newRow = addNewRow;
                addNewRow = null;
                recordCount--;
                suspendChangeEvents = false;
                try {
                    int tempRecord = newRow.tempRecord;

                    handledOnIndexListChanged = false;

                    table.Rows.Add(newRow);

                    if (!handledOnIndexListChanged) {
                        // this means that the record did not get
                        // added, and we did not get an assert.
                        // tell everybody that the last record got deleted
                        //
                        OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, recordCount));
                    }

                    handledOnIndexListChanged = false;

                    int newRowIndex = index.GetIndex(tempRecord);

                    if (newRowIndex != currentIndex) {
                        OnListChanged(new ListChangedEventArgs(ListChangedType.ItemMoved, newRowIndex, currentIndex));
                    }
                }
                catch (Exception e) {
                    addNewRow = newRow;
                    recordCount ++;
                    throw e;
                }
            }
            else {
                addNewRow.CancelEdit();
                addNewRow = null;
                recordCount--;
                OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, recordCount));
            }
        }

        internal bool GetDelayBeginEdit(DataRow row) {
            if (delayBeginEditList != null) {
                return delayBeginEditList.Contains(row);
            }
            return false;
        }

        internal void SetDelayBeginEdit(DataRow row, bool newValue) {
            bool oldValue = GetDelayBeginEdit(row);

            if (oldValue != newValue) {
                if (delayBeginEditList == null) {
                    delayBeginEditList = new ArrayList();
                }

                if (newValue) {
                    delayBeginEditList.Add(row);
                }
                else {
                    delayBeginEditList.Remove(row);
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.GetElement"]/*' />
        /// <devdoc>
        /// gets an element from the dataView.  Only for Web Forms Interfaces.
        /// </devdoc>
        private DataRowView GetElement(int index) {
            if (index < 0 || index >= recordCount)
                throw ExceptionBuilder.GetElementIndex(index);
            return RowViewCache[index];
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an enumerator for this <see cref='System.Data.DataView'/>.
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            DataRowView[] items = new DataRowView[Count];
            CopyTo(items, 0);
            return items.GetEnumerator();
        }

        // ------------- IList: ---------------------------
        // rajeshc : These methods below don't do the right thing. Needed to be added since these are on IList as a part of classlib
        // breaking changes.Please fixup when you can.

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.IsReadOnly"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// private implementation.
        /// </devdoc>
        bool IList.IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// private implementation.
        /// </devdoc>
        bool IList.IsFixedSize {
            get {
                return false;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object value) {
            if (value == null) {
                // null is default value, so we AddNew.
                AddNew();
                return Count - 1;
            }
            throw ExceptionBuilder.AddExternalObject();
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.Clear"]/*' />
        /// <internalonly/>
        void IList.Clear() {
            throw ExceptionBuilder.CanNotClear();
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object value) {
            return(value is DataRowView && ((DataRowView)value).DataView == this);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object value) {
            return(value is DataRowView && ((DataRowView)value).DataView == this) ?
            ((DataRowView)value).Index : -1;
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object value) {
            throw ExceptionBuilder.InsertExternalObject();
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object value) {
            if (value is DataRowView && ((DataRowView)value).DataView == this) {
                ((IList)this).RemoveAt(((DataRowView)value).Index);
            }
            throw ExceptionBuilder.RemoveExternalObject();
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IList.RemoveAt"]/*' />
        /// <internalonly/>
        void IList.RemoveAt(int index) {
            Delete(index);
        }

        internal Index GetFindIndex(string column, bool keepIndex) {
            if (findIndexes == null) {
                findIndexes = new Hashtable();
            }
            Index findIndex = (Index) findIndexes[column];
            if (findIndex == null) {
                findIndex = table.GetIndex(column, ((DataViewRowState)(int)recordStates), GetFilter());
                if (keepIndex) {
                    findIndexes[column] = findIndex;
                    findIndex.AddRef();
                }
            }
            else {
                if (!keepIndex) {
                    findIndexes.Remove(column);
                    findIndex.RemoveRef();
                }
            }
            return findIndex;
        }

        // ------------- IBindingList: ---------------------------

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.AllowNew"]/*' />
        /// <internalonly/>
        bool IBindingList.AllowNew {
            get { return AllowNew; }                       
        }
        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.AddNew"]/*' />
        /// <internalonly/>
        object IBindingList.AddNew() {
            return AddNew();
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.AllowEdit"]/*' />
        /// <internalonly/>
        bool IBindingList.AllowEdit {
            get { return AllowEdit; }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.AllowRemove"]/*' />
        /// <internalonly/>
        bool IBindingList.AllowRemove {
            get { return AllowDelete; }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.SupportsChangeNotification"]/*' />
        /// <internalonly/>
        bool IBindingList.SupportsChangeNotification { 
            get { return true; }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.SupportsSearching"]/*' />
        /// <internalonly/>
        bool IBindingList.SupportsSearching { 
            get { return true; }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.SupportsSorting"]/*' />
        /// <internalonly/>
        bool IBindingList.SupportsSorting { 
            get { return true; }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.IsSorted"]/*' />
        /// <internalonly/>
        bool IBindingList.IsSorted { 
            get { return this.Sort != string.Empty; }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.SortProperty"]/*' />
        /// <internalonly/>
        PropertyDescriptor IBindingList.SortProperty {
            get {
                if (table != null && index != null && index.IndexDesc.Length == 1) {
                    int colIndex = DataKey.ColumnOrder(index.IndexDesc[0]);
                    return new DataColumnPropertyDescriptor(table.Columns[colIndex]);
                }
                return null;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.SortDirection"]/*' />
        /// <internalonly/>
        ListSortDirection IBindingList.SortDirection {
            get {
                if (
                    index.IndexDesc.Length == 1 && 
                    DataKey.SortDecending(index.IndexDesc[0])
                ) {
                    return ListSortDirection.Descending;
                }
                return ListSortDirection.Ascending;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.ListChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the list managed by the <see cref='System.Data.DataView'/> changes.
        ///    </para>
        /// </devdoc>
        [DataCategory(Res.DataCategory_Data), DataSysDescription(Res.DataViewListChangedDescr)]
        public event System.ComponentModel.ListChangedEventHandler ListChanged {
            add {
                onListChanged += value;
            }
            remove {
                onListChanged -= value;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.AddIndex"]/*' />
        /// <internalonly/>
        void IBindingList.AddIndex(PropertyDescriptor property) {
            GetFindIndex(property.Name, /*keepIndex:*/true);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.ApplySort"]/*' />
        /// <internalonly/>
        void IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction) {
            this.Sort = '['+property.Name+']' + (direction == ListSortDirection.Descending ? " DESC" : "");
        }

        int IBindingList.Find(PropertyDescriptor property, object key) { // NOTE: this function had keepIndex previosely
            if (property != null) {
                Index findIndex = GetFindIndex(property.Name, /*keepIndex:*/false);
                Range recordRange = findIndex.FindRecords(key);
                if (!recordRange.IsNull) {
                    // check to see if key is equal
                    return index.GetIndex(findIndex.GetRecord(recordRange.Min));
                }
            }
            return -1;
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.RemoveIndex"]/*' />
        /// <internalonly/>
        void IBindingList.RemoveIndex(PropertyDescriptor property) {
            // Ups: If we don't have index yet we will create it before destroing; Fix this later
            GetFindIndex(property.Name, /*keepIndex:*/false);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IBindingList.RemoveSort"]/*' />
        /// <internalonly/>
        void IBindingList.RemoveSort() {
            this.Sort = string.Empty;
        }

        /*
        string IBindingList.GetListName() {
            return ((System.Data.ITypedList)this).GetListName(null);
        }
        string IBindingList.GetListName(PropertyDescriptor[] listAccessors) {
            return ((System.Data.ITypedList)this).GetListName(listAccessors);
        }
        */

        // ------------- ITypedList: ---------------------------

        string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors) {
            if(table != null) {
                if (listAccessors == null || listAccessors.Length == 0) {
                    return table.TableName;
                }
                else {
                    DataSet dataSet = table.DataSet;
                    if (dataSet != null) {
                        DataTable foundTable = dataSet.FindTable(table, listAccessors, 0);
                        if (foundTable != null) {
                            return foundTable.TableName;
                        }
                    }
                }
            }
            return String.Empty;
        }

        PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors) {
            if (table != null) {
                if (listAccessors == null || listAccessors.Length == 0) {
                    return table.GetPropertyDescriptorCollection(null);
                }
                else {
                    DataSet dataSet = table.DataSet;
                    if (dataSet == null)
                        return new PropertyDescriptorCollection(null);
                    DataTable foundTable = dataSet.FindTable(table, listAccessors, 0);
                    if (foundTable != null) {
                        return foundTable.GetPropertyDescriptorCollection(null);
                    }
                }
            }
            return new PropertyDescriptorCollection(null);
        }

        /*
        public string[] GetFieldAccessors(string accessor) {
            string fakeAccessor = Table.TableName + (accessor.Length > 0 ? "." : "") + accessor;
            string[] subs = Table.DataSet.GetListInfo().GetFieldAccessors(fakeAccessor);
            for (int i = 0; i < subs.Length; i++) {
                subs[i] = subs[i].Substring(subs[i].IndexOf(".")+1);
            }
            return subs;
        }

        public string GetFieldCaption(string accessor) {
            string fakeAccessor = Table.TableName + (accessor.Length > 0 ? "." : "") + accessor;                
            return Table.DataSet.GetListInfo().GetFieldCaption(fakeAccessor);
        }
            
        public Type GetFieldType(string accessor) {
            string fakeAccessor = Table.TableName + (accessor.Length > 0 ? "." : "") + accessor;                
            return Table.DataSet.GetListInfo().GetFieldType(fakeAccessor);
        }
        */

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.GetFilter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the filter for the <see cref='System.Data.DataView'/>.
        ///    </para>
        /// </devdoc>
        internal virtual IFilter GetFilter() {
            return rowFilter;
        }

        private int GetRecord(int recordIndex) {
            if (recordIndex < 0 || recordIndex >= recordCount) 
                throw ExceptionBuilder.RowOutOfRange(recordIndex);
            if (recordIndex == index.RecordCount)
                return addNewRow.GetDefaultRecord();
            return index.GetRecord(recordIndex);
        }

        internal DataRow GetRow(int index) {
            return table.recordManager[GetRecord(index)];
        }

        internal bool IsOriginalVersion(int index) {
            int record = GetRecord(index);
            DataRow row = table.recordManager[record];
            // BUGBUG!(sdub) why the assert failing?
//            Debug.Assert(record != row.tempRecord, "We never putting tempRecords in the DataView. Isn't it?");
            // We can't compare to oldRecord: oldRecord cand be == to newRecord, but this means row is unmodified
            return record != row.newRecord && record != row.tempRecord;
        }

        internal void FireEvent(TargetEvent targetEvent, object sender, EventArgs e) {
            switch (targetEvent) {
                case TargetEvent.IndexListChanged                : IndexListChanged(sender, (ListChangedEventArgs)e); break;
                case TargetEvent.ChildRelationCollectionChanged  : ChildRelationCollectionChanged(sender, (CollectionChangeEventArgs)e); break;
                case TargetEvent.ParentRelationCollectionChanged : ParentRelationCollectionChanged(sender, (CollectionChangeEventArgs)e); break;
                case TargetEvent.ColumnCollectionChanged         : ColumnCollectionChanged(sender, (CollectionChangeEventArgs)e); break;
                default                                          : break;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.IndexListChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void IndexListChanged(object sender, ListChangedEventArgs e) {
            if (addNewRow != null && index.RecordCount == 0) { // haroona : 83032 Clear the newly added row as the underlying index is reset.
                FinishAddNew(0, false);
            }
            UpdateRecordCount();
            OnListChanged(e);
            handledOnIndexListChanged = true;
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.OnListChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='E:System.Data.DataView.ListChanged'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnListChanged(ListChangedEventArgs e) {
            rowViewCache = null;
            if (!suspendChangeEvents) {
                try {
                    if (onListChanged != null) {
                        onListChanged(this, e);
                    }
                }
                catch (Exception) {
                }
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Open"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Opens a <see cref='System.Data.DataView'/>.
        ///    </para>
        /// </devdoc>
        protected void Open() {
            shouldOpen = true;
            UpdateIndex();
            dvListener.RegisterMetaDataEvents(this.table);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.Reset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void Reset() {
            if (IsOpen) {
                index.Reset();
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.SetIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal virtual void SetIndex(string newSort, DataViewRowState newRowStates, DataFilter newRowFilter) {
            this.sort         = newSort;
            this.recordStates = newRowStates;
            this.rowFilter    = newRowFilter;

            if (fEndInitInProgress)
                return;

            UpdateIndex(true);

            if (findIndexes != null) {
                foreach (object value in findIndexes.Values) {
                    Index curIndex = (Index) value;
                    curIndex.RemoveRef();
                }
                findIndexes = null;
            }
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.UpdateIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void UpdateIndex() {
            UpdateIndex(false);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.UpdateIndex1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void UpdateIndex(bool force) {
            if (open != shouldOpen || force) {
                this.open = shouldOpen;
                Index newIndex = null;
                if (open) {
                    if (table != null) {
                        newIndex = table.GetIndex(Sort, ((DataViewRowState)(int)recordStates), GetFilter());
                    }
                }

                if (index == newIndex) {
                    return;
                }

                if (index != null) {
                    this.dvListener.UnregisterListChangedEvent();
                }

                index = newIndex;
                rowViewCache = null;

                if (index != null) {
                    this.dvListener.RegisterListChangedEvent(index);
                }

                UpdateRecordCount();            
                OnListChanged(ResetEventArgs);              
            }
        }

        private void UpdateRecordCount() {
            if (index == null)
                recordCount = 0;
            else
                recordCount = index.RecordCount + (addNewRow != null ? 1 : 0);
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.ChildRelationCollectionChanged"]/*' />
        private void ChildRelationCollectionChanged(object sender, CollectionChangeEventArgs e) {
            DataRelationPropertyDescriptor NullProp = null;
            OnListChanged(
                e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded, new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) :
                e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged, NullProp):
                e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted, new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) :
            /*default*/ null
            );
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.ParentRelationCollectionChanged"]/*' />
        private void ParentRelationCollectionChanged(object sender, CollectionChangeEventArgs e) {
            DataRelationPropertyDescriptor NullProp = null;
            OnListChanged(
                e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded, new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) :
                e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged, NullProp):
                e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted, new DataRelationPropertyDescriptor((System.Data.DataRelation)e.Element)) :
            /*default*/ null
            );
        }

        /// <include file='doc\DataView.uex' path='docs/doc[@for="DataView.ColumnCollectionChanged"]/*' />
        protected virtual void ColumnCollectionChanged(object sender, CollectionChangeEventArgs e) {
            DataColumnPropertyDescriptor NullProp = null;
            OnListChanged(
                e.Action == CollectionChangeAction.Add ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded, new DataColumnPropertyDescriptor((System.Data.DataColumn)e.Element)) :
                e.Action == CollectionChangeAction.Refresh ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged, NullProp):
                e.Action == CollectionChangeAction.Remove ? new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted, new DataColumnPropertyDescriptor((System.Data.DataColumn)e.Element)) :
                /*default*/ null
            );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dataviewsettingcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataViewSettingCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;    
    using System.ComponentModel;
    using System.Drawing.Design;
    using System.Collections;

    // TODO: Listen events on DataSet.Tables and remove table settings on tables removed from collection

    /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Editor("Microsoft.VSDesigner.Data.Design.DataViewSettingsCollectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    Serializable
    ]
    public class DataViewSettingCollection : ICollection {
        private DataViewManager dataViewManager = null;
        private Hashtable list = new Hashtable();

        internal DataViewSettingCollection(DataViewManager dataViewManager) {
            if (dataViewManager == null) {
                throw ExceptionBuilder.ArgumentNull("dataViewManager");
            }
            this.dataViewManager = dataViewManager;
        }

        /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual DataViewSetting this[DataTable table] {
            get {
                if (table == null) {
                    throw ExceptionBuilder.ArgumentNull("table");
                }
                DataViewSetting dataViewSetting = (DataViewSetting) list[table];
                if(dataViewSetting == null) {
                    dataViewSetting = new DataViewSetting();
                    this[table] = dataViewSetting;
                }
                return dataViewSetting;
            }
            set {
                if (table == null) {
                    throw ExceptionBuilder.ArgumentNull("table");
                }
                value.SetDataViewManager(dataViewManager);
                value.SetDataTable(table);
                list[table] = value;
            }
        }

        private DataTable GetTable(string tableName) {
            DataTable dt = null;
            DataSet ds = dataViewManager.DataSet;
            if(ds != null) {
                dt = ds.Tables[tableName];
            }
            return dt;
        }

        private DataTable GetTable(int index) {
            DataTable dt = null;
            DataSet ds = dataViewManager.DataSet;
            if(ds != null) {
                dt = ds.Tables[index];
            }
            return dt;
        }

        /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual DataViewSetting this[string tableName] {
            get {
                DataTable dt = GetTable(tableName);
                if(dt != null) {
                    return this[dt];
                }
                return null;
            }
        }

        /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection.this2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual DataViewSetting this[int index] {
            get {
                DataTable dt = GetTable(index);
                if(dt != null) {
                    return this[dt];
                }
                return null;
            }
            set {
                DataTable dt = GetTable(index);
                if(dt != null) {
                    this[dt] = value;
                }else {
                    // throw excaption here.
                }
            }
        }

        // ----------- ICollection -------------------------
        /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array ar, int index) {
            System.Collections.IEnumerator Enumerator = GetEnumerator();
            while (Enumerator.MoveNext()) {
                ar.SetValue(Enumerator.Current, index++);
            }
        }

        /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public virtual int Count {
            get {
                DataSet ds = dataViewManager.DataSet;
                return (ds == null) ? 0 : ds.Tables.Count;
            }
        }

        /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Gets an IEnumerator for the collection.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            // I have to do something here.
            return new DataViewSettingsEnumerator(dataViewManager);
        }

        /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false)
        ]
        public bool IsReadOnly {
            get {
                return true;
            }
        }

        /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public bool IsSynchronized {
            get {
                // so the user will know that it has to lock this object
                return false;
            }
        }

        /// <include file='doc\DataViewSettingCollection.uex' path='docs/doc[@for="DataViewSettingCollection.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public object SyncRoot {
            get {
                return this;
            }
        }

        private class DataViewSettingsEnumerator : IEnumerator {
            DataViewSettingCollection dataViewSettings;
            IEnumerator                tableEnumerator;
            public DataViewSettingsEnumerator(DataViewManager dvm) {
                DataSet ds = dvm.DataSet;
                if(ds != null) {
                    dataViewSettings = dvm.DataViewSettings;
                    tableEnumerator  = dvm.DataSet.Tables.GetEnumerator();
                }else {
                    dataViewSettings = null;
                    tableEnumerator  = (new ArrayList()).GetEnumerator();
                }
            }
            public bool MoveNext() {
                return tableEnumerator.MoveNext();
            }
            public void Reset() {
                tableEnumerator.Reset();
            }
            public object Current {
                get {
                    return dataViewSettings[(DataTable) tableEnumerator.Current];
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dbtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="dbtype.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data {
    /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType"]/*' />
    public enum DbType {
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.AnsiString"]/*' />
        AnsiString, // 0
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Binary"]/*' />
        Binary,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Byte"]/*' />
        Byte,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Boolean"]/*' />
        Boolean,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Currency"]/*' />
        Currency,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Date"]/*' />
        Date,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.DateTime"]/*' />
        DateTime,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Decimal"]/*' />
        Decimal,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Double"]/*' />
        Double,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Guid"]/*' />
        Guid,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Int16"]/*' />
        Int16,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Int32"]/*' />
        Int32,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Int64"]/*' />
        Int64,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Object"]/*' />
        Object,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.SByte"]/*' />
        SByte,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Single"]/*' />
        Single,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.String"]/*' />
        String,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.Time"]/*' />
        Time,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.UInt16"]/*' />
        UInt16,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.UInt32"]/*' />
        UInt32,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.UInt64"]/*' />
        UInt64,
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.VarNumeric"]/*' />
        VarNumeric, // 21
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.AnsiStringFixedLength"]/*' />
        AnsiStringFixedLength, // MDAC 68654
        /// <include file='doc\dbtype.uex' path='docs/doc[@for="DbType.StringFixedLength // 23"]/*' />
        StringFixedLength, // MDAC 68654 // 23
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\defaultvaluetypeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultValueTypeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Data {
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\TypeListConverter.uex' path='docs/doc[@for="TypeListConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type
    ///       converter that can be used to populate a list box with available types.</para>
    /// </devdoc>
    internal class DefaultValueTypeConverter : StringConverter {
        private static string nullString = "<null>";
        private static string dbNullString = "<DBNull>";

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value == null) {
                    return nullString;
                }
                else if (value == DBNull.Value) {
                    return dbNullString;
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value != null && value.GetType() == typeof(string)) {
                string strValue = (string)value;
                if (string.Compare(strValue, nullString, true, CultureInfo.InvariantCulture) == 0)
                    return null;
                else if (string.Compare(strValue, dbNullString, true, CultureInfo.InvariantCulture) == 0)
                    return DBNull.Value;
            }
            
            return base.ConvertFrom(context, culture, value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\fillerroreventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="FillErrorEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data { // MDAC 59437

    /// <include file='doc\FillErrorEventHandler.uex' path='docs/doc[@for="FillErrorEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void FillErrorEventHandler(object sender, FillErrorEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\dbconcurrencyexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="DBConcurrencyException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    using System;
    using System.Runtime.Serialization;

    /// <include file='doc\DBConcurrencyException.uex' path='docs/doc[@for="DBConcurrencyException"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The exception that is thrown when a concurrency violation is encounted during Update
    ///    </para>
    /// </devdoc>
    [Serializable]
    sealed public class DBConcurrencyException  : SystemException {
        private DataRow dataRow;

        /// <include file='doc\DBConcurrencyException.uex' path='docs/doc[@for="DBConcurrencyException.DBConcurrencyException2"]/*' />
        public DBConcurrencyException() : base() { // MDAC 82931
        }
        
        /// <include file='doc\DBConcurrencyException.uex' path='docs/doc[@for="DBConcurrencyException.DBConcurrencyException"]/*' />
        public DBConcurrencyException(string message) : base(message) {
        }

        /// <include file='doc\DBConcurrencyException.uex' path='docs/doc[@for="DBConcurrencyException.DBConcurrencyException1"]/*' />
        public DBConcurrencyException(String message, Exception inner) : base(message, inner) {
        }

        // runtime will call even if private...
        // <fxcop ignore=SerializableTypesMustHaveMagicConstructorWithAdequateSecurity />
        private DBConcurrencyException(SerializationInfo si, StreamingContext sc) : base(si, sc) {
            // dataRow = (DataRow) si.GetValue("dataRow", typeof(DataRow)); - do not do this till v.next with serialization support for DataRow.  MDAC 72136
        }

        /// <include file='doc\DBConcurrencyExceptionException.uex' path='docs/doc[@for="DBConcurrencyException.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        // <fxcop ignore=GetObjectDataShouldBeSecure /> // MDAC 82934
        override public void GetObjectData(SerializationInfo si, StreamingContext context) { // MDAC 72003
            if (null == si) {
                throw new ArgumentNullException("si");
            }
            // si.AddValue("dataRow", dataRow, typeof(DataRow)); - do not do this till v.next with serialization support for DataRow.    MDAC 72136
            base.GetObjectData(si, context);
        }

        /// <include file='doc\DBConcurrencyException.uex' path='docs/doc[@for="DBConcurrencyException.Row"]/*' />
        public DataRow Row { // MDAC 55735
            get {
                return dataRow;
            }
            set {
                this.dataRow = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\foreignkeyconstraint.cs ===
//------------------------------------------------------------------------------
// <copyright file="ForeignKeyConstraint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;  
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing.Design;

    /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint"]/*' />
    /// <devdoc>
    ///    <para>Represents an action
    ///       restriction enforced on a set of columns in a primary key/foreign key relationship when
    ///       a value or row is either deleted or updated.</para>
    /// </devdoc>
    [
    DefaultProperty("ConstraintName"),
    Editor("Microsoft.VSDesigner.Data.Design.ForeignKeyConstraintEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    Serializable
    ]
    public class ForeignKeyConstraint : Constraint {
        // constants
        internal const Rule                   Rule_Default                   = Rule.Cascade;
        internal const AcceptRejectRule       AcceptRejectRule_Default       = AcceptRejectRule.None;

        // properties
        internal Rule deleteRule = Rule_Default;
        internal Rule updateRule = Rule_Default;
        internal AcceptRejectRule acceptRejectRule = AcceptRejectRule_Default;
        private DataKey childKey  = null;
        private DataKey parentKey = null;

        // Design time serialization
        internal string constraintName = null;
        internal string[] parentColumnNames = null;
        internal string[] childColumnNames = null;
        internal string parentTableName = null;

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.ForeignKeyConstraint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.ForeignKeyConstraint'/> class with the specified parent and
        ///       child <see cref='System.Data.DataColumn'/> objects.
        ///    </para>
        /// </devdoc>
        public ForeignKeyConstraint(DataColumn parentColumn, DataColumn childColumn)
        : this(null, parentColumn, childColumn) {
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.ForeignKeyConstraint1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.ForeignKeyConstraint'/> class with the specified name,
        ///       parent and child <see cref='System.Data.DataColumn'/> objects.
        ///    </para>
        /// </devdoc>
        public ForeignKeyConstraint(string constraintName, DataColumn parentColumn, DataColumn childColumn) {
            DataColumn[] parentColumns = new DataColumn[] {parentColumn};
            DataColumn[] childColumns = new DataColumn[] {childColumn};
            Create(constraintName, parentColumns, childColumns);
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.ForeignKeyConstraint2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.ForeignKeyConstraint'/> class with the specified arrays
        ///       of parent and child <see cref='System.Data.DataColumn'/> objects.
        ///    </para>
        /// </devdoc>
        public ForeignKeyConstraint(DataColumn[] parentColumns, DataColumn[] childColumns)
        : this(null, parentColumns, childColumns) {
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.ForeignKeyConstraint3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.ForeignKeyConstraint'/> class with the specified name,
        ///       and arrays of parent and child <see cref='System.Data.DataColumn'/> objects.
        ///    </para>
        /// </devdoc>
        public ForeignKeyConstraint(string constraintName, DataColumn[] parentColumns, DataColumn[] childColumns) {
            Create(constraintName, parentColumns, childColumns);
        }

        // construct design time object
        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.ForeignKeyConstraint4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public ForeignKeyConstraint(string constraintName, string parentTableName, string[] parentColumnNames, string[] childColumnNames,
                                    AcceptRejectRule acceptRejectRule, Rule deleteRule, Rule updateRule) {
            this.constraintName = constraintName;
            this.parentColumnNames = parentColumnNames;
            this.childColumnNames = childColumnNames;
            this.parentTableName = parentTableName;
            this.acceptRejectRule = acceptRejectRule;
            this.deleteRule = deleteRule;
            this.updateRule = updateRule;
        }
        
        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.ChildKey"]/*' />
        /// <devdoc>
        /// The internal constraint object for the child table.
        /// </devdoc>
        internal virtual DataKey ChildKey {
            get {
                CheckStateForProperty();
                return childKey;
            }
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.Columns"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the child columns of this constraint.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.ForeignKeyConstraintChildColumnsDescr),
        ReadOnly(true)
        ]
        public virtual DataColumn[] Columns {
            get {
                CheckStateForProperty();
                return childKey.Columns;
            }
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.Table"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the child table of this constraint.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.ConstraintTableDescr),
        ReadOnly(true)
        ]
        public override DataTable Table {
            get {
                CheckStateForProperty();
                return childKey.Table;
            }
        }

        internal string[] ParentColumnNames {
            get {
                int count = parentKey.Columns.Length;
                string[] parentNames = new string[count];
                for (int i = 0; i < count; i++)
                    parentNames[i] = parentKey.Columns[i].ColumnName;
                    
                return parentNames;
            }
        }

        internal string[] ChildColumnNames {
            get {
                int count = childKey.Columns.Length;
                string[] childNames = new string[count];
                for (int i = 0; i < count; i++)
                    childNames[i] = childKey.Columns[i].ColumnName;
                    
                return childNames;
            }
        }

        internal override void CheckCanAddToCollection(ConstraintCollection constraints) {
            if (Table != constraints.Table)
                throw ExceptionBuilder.ConstraintAddFailed(constraints.Table);
            if (Table.Locale.LCID != RelatedTable.Locale.LCID || Table.CaseSensitive != RelatedTable.CaseSensitive)
                throw ExceptionBuilder.CaseLocaleMismatch();
        }

        internal override bool CanBeRemovedFromCollection(ConstraintCollection constraints, bool fThrowException) {
            return true;
        }

        internal bool IsKeyNull( object[] values ) {
            for (int i = 0; i < values.Length; i++) {
                if (!(values[i] == null || values[i] is System.DBNull))
                    return false;
            }

            return true;
        }

        internal override bool IsConstraintViolated() {
            Index childIndex = childKey.GetSortIndex();
            object[] uniqueChildKeys = childIndex.GetUniqueKeyValues();
            bool errors = false;

            Index parentIndex = parentKey.GetSortIndex();
            for (int i = 0; i < uniqueChildKeys.Length; i++) {
                object[] childValues = (object[]) uniqueChildKeys[i];

                if (!IsKeyNull(childValues)) {
                    if (!parentIndex.IsKeyInIndex(childValues)) {
                        DataRow[] rows = childIndex.GetRows(childIndex.FindRecords(childValues));
                        string error = Res.GetString(Res.DataConstraint_ForeignKeyViolation, ConstraintName, ExceptionBuilder.KeysToString(childValues));
                        for (int j = 0; j < rows.Length; j++) {
                            rows[j].RowError = error;
                        }
                        errors = true;
                    }
                }
            }
            return errors;
        }

        internal override bool CanEnableConstraint() {
            if (Table.DataSet == null || !Table.DataSet.EnforceConstraints)
                return true;

            Index childIndex = childKey.GetSortIndex();
            object[] uniqueChildKeys = childIndex.GetUniqueKeyValues();

            Index parentIndex = parentKey.GetSortIndex();
            for (int i = 0; i < uniqueChildKeys.Length; i++) {
                object[] childValues = (object[]) uniqueChildKeys[i];
                
                if (!IsKeyNull(childValues) && !parentIndex.IsKeyInIndex(childValues)) {
#if DEBUG
                    if (CompModSwitches.Data_Constraints.TraceVerbose) {
                        string result = "Constraint violation found.  Child values: ";
                        for (int j = 0; j < childValues.Length; j++) {
                            result += Convert.ToString(childValues[j]) + (j < childValues.Length - 1 ? ", " : "");
                        }
                        Debug.WriteLine(result);
                    }
#endif
                    return false;
                }
            }
            return true;
        }

        internal void CascadeCommit(DataRow row) {
            if (row.RowState == DataRowState.Detached)
                return;
            if (acceptRejectRule == AcceptRejectRule.Cascade) {
                Index childIndex = childKey.GetSortIndex(      row.RowState == DataRowState.Deleted ? DataViewRowState.Deleted : DataViewRowState.CurrentRows );
                object[] key     = row.GetKeyValues(parentKey, row.RowState == DataRowState.Deleted ? DataRowVersion.Original  : DataRowVersion.Default       );
                if (IsKeyNull(key)) {
                    return;
                }

                Range range      = childIndex.FindRecords(key);
                if (!range.IsNull) {
                    for (int j = range.Min; j <= range.Max; j++) {
                        DataRow childRow = childIndex.GetRow(j);
                        if (childRow.inCascade)
                            continue;
                        childRow.AcceptChanges();
                    }
                }
            }
        }

        internal void CascadeDelete(DataRow row) {
            if (-1 == row.newRecord)
                return;

            object[] currentKey = row.GetKeyValues(parentKey, DataRowVersion.Current);
            if (IsKeyNull(currentKey)) {
                return;
            }

            Index childIndex = childKey.GetSortIndex();
            switch (DeleteRule) {
            case Rule.None: {
                    if (row.Table.DataSet.EnforceConstraints) {
                        // if we're not cascading deletes, we should throw if we're going to strand a child row under enforceConstraints.
                        Range range = childIndex.FindRecords(currentKey);
                        if (!range.IsNull) {
                            if (range.Count == 1 && childIndex.GetRow(range.Min) == row)
                                return;

                            throw ExceptionBuilder.FailedCascadeDelete(ConstraintName);
                        }
                    }
                    break;
                }

            case Rule.Cascade: {
                    object[] key = row.GetKeyValues(parentKey, DataRowVersion.Default);
                    Range range = childIndex.FindRecords(key);
                    if (!range.IsNull) {
                        DataRow[] rows = childIndex.GetRows(range);

                        for (int j = 0; j < rows.Length; j++) {
                            DataRow r = rows[j];
                            if (r.inCascade)
                                continue;
                            r.Table.DeleteRow(r);
                        }
                    }
                    break;
                }

            case Rule.SetNull: {
                    object[] proposedKey = new object[childKey.Columns.Length];
                    for (int i = 0; i < childKey.Columns.Length; i++)
                        proposedKey[i] = DBNull.Value;
                    Range range = childIndex.FindRecords(currentKey);
                    if (!range.IsNull) {
                        DataRow[] rows = childIndex.GetRows(range);
                        for (int j = 0; j < rows.Length; j++) {
                            // if (rows[j].inCascade)
                            //    continue;
                            if (row != rows[j])
                                rows[j].SetKeyValues(childKey, proposedKey);
                        }
                    }
                    break;
                }
            case Rule.SetDefault: {
                    object[] proposedKey = new object[childKey.Columns.Length];
                    for (int i = 0; i < childKey.Columns.Length; i++)
                        proposedKey[i] = childKey.Columns[i].DefaultValue;
                    Range range = childIndex.FindRecords(currentKey);
                    if (!range.IsNull) {
                        DataRow[] rows = childIndex.GetRows(range);
                        for (int j = 0; j < rows.Length; j++) {
                            // if (rows[j].inCascade)
                            //    continue;
                            if (row != rows[j])
                                rows[j].SetKeyValues(childKey, proposedKey);
                        }
                    }
                    break;
                }
            default: {
                    Debug.Assert(false, "Unknown Rule value");
			break;
                }
            }
        }

        internal void CascadeRollback(DataRow row) {
            Index childIndex = childKey.GetSortIndex(      row.RowState == DataRowState.Deleted  ? DataViewRowState.OriginalRows : DataViewRowState.CurrentRows);
            object[] key     = row.GetKeyValues(parentKey, row.RowState == DataRowState.Modified ? DataRowVersion.Current        : DataRowVersion.Default      );

            // Bug : This is definitely not a proper fix. (Ref. MDAC Bug 73592)
            if (IsKeyNull(key)) {
                return;
            }

            Range range      = childIndex.FindRecords(key);
            if (acceptRejectRule == AcceptRejectRule.Cascade) {
                if (!range.IsNull) {
                    DataRow[] rows = childIndex.GetRows(range);
                    for (int j = 0; j < rows.Length; j++) {
                        if (rows[j].inCascade)
                            continue;
                        rows[j].RejectChanges();
                    }
                }
            }
            else {
                // AcceptRejectRule.None
                if (row.RowState != DataRowState.Deleted && row.Table.DataSet.EnforceConstraints) {
                    if (!range.IsNull) {
                        if (range.Count == 1 && childIndex.GetRow(range.Min) == row)
                            return;

                        throw ExceptionBuilder.FailedCascadeUpdate(ConstraintName);
                    }
                }
            }
        }

        internal void CascadeUpdate(DataRow row) {
            if (-1 == row.newRecord)
                return;

            object[] currentKey = row.GetKeyValues(parentKey, DataRowVersion.Current);
            if (!Table.DataSet.fInReadXml && IsKeyNull(currentKey)) {
                return;
            }

            Index childIndex = childKey.GetSortIndex();
            switch (UpdateRule) {
            case Rule.None: {
                    if (row.Table.DataSet.EnforceConstraints)
                    {
                        // if we're not cascading deletes, we should throw if we're going to strand a child row under enforceConstraints.
                        Range range = childIndex.FindRecords(currentKey);
                        if (!range.IsNull) {
                            throw ExceptionBuilder.FailedCascadeUpdate(ConstraintName);
                        }
                    }
                    break;
                }

            case Rule.Cascade: {
                    Range range = childIndex.FindRecords(currentKey);
                    if (!range.IsNull) {
                        object[] proposedKey = row.GetKeyValues(parentKey, DataRowVersion.Proposed);
                        DataRow[] rows = childIndex.GetRows(range);
                        for (int j = 0; j < rows.Length; j++) {
                            // if (rows[j].inCascade)
                            //    continue;
                            rows[j].SetKeyValues(childKey, proposedKey);
                        }
                    }
                    break;
                }

            case Rule.SetNull: {
                    object[] proposedKey = new object[childKey.Columns.Length];
                    for (int i = 0; i < childKey.Columns.Length; i++)
                        proposedKey[i] = DBNull.Value;
                    Range range = childIndex.FindRecords(currentKey);
                    if (!range.IsNull) {
                        DataRow[] rows = childIndex.GetRows(range);
                        for (int j = 0; j < rows.Length; j++) {
                            // if (rows[j].inCascade)
                            //    continue;
                            rows[j].SetKeyValues(childKey, proposedKey);
                        }
                    }
                    break;
                }
            case Rule.SetDefault: {
                    object[] proposedKey = new object[childKey.Columns.Length];
                    for (int i = 0; i < childKey.Columns.Length; i++)
                        proposedKey[i] = childKey.Columns[i].DefaultValue;
                    Range range = childIndex.FindRecords(currentKey);
                    if (!range.IsNull) {
                        DataRow[] rows = childIndex.GetRows(range);
                        for (int j = 0; j < rows.Length; j++) {
                            // if (rows[j].inCascade)
                            //    continue;
                            rows[j].SetKeyValues(childKey, proposedKey);
                        }
                    }
                    break;
                }
            default: {
                    Debug.Assert(false, "Unknown Rule value");
		    break;
                }
            }
        }

        internal void CheckCanClearParentTable(DataTable table) {
            if (Table.DataSet.EnforceConstraints && Table.Rows.Count > 0) {
                throw ExceptionBuilder.FailedClearParentTable(table.TableName, ConstraintName, Table.TableName);
            }
        }

        internal void CheckCanRemoveParentRow(DataRow row) {
            Debug.Assert(Table.DataSet != null, "Relation " + ConstraintName + " isn't part of a DataSet, so this check shouldn't be happening.");
            if (!Table.DataSet.EnforceConstraints)
                return;
            if (DataRelation.GetChildRows(this.ParentKey, this.ChildKey, row, DataRowVersion.Default).Length > 0) {
                throw ExceptionBuilder.RemoveParentRow(this);
            }
        }

        internal void CheckCascade(DataRow row, DataRowAction action) {
            Debug.Assert(Table.DataSet != null, "ForeignKeyConstraint " + ConstraintName + " isn't part of a DataSet, so this check shouldn't be happening.");

            if (row.inCascade)
                return;
                
            row.inCascade = true;
            try {
                if (action == DataRowAction.Change) {
                    if (row.HasKeyChanged(parentKey)) {
                        CascadeUpdate(row);
                    }
                }
                else if (action == DataRowAction.Delete) {
                    CascadeDelete(row);
                }
                else if (action == DataRowAction.Commit) {
                    CascadeCommit(row);
                }
                else if (action == DataRowAction.Rollback) {
                    if (row.HasKeyChanged(parentKey)) {
                        CascadeRollback(row);
                    }
                }
                else if (action == DataRowAction.Add) {
                }
                else {
                    Debug.Assert(false, "attempt to cascade unknown action: " + ((Enum) action).ToString());
                }
            }
            finally {
                row.inCascade = false;
            }
        }

        internal override void CheckConstraint(DataRow childRow, DataRowAction action) {
            Debug.Assert(Table.DataSet != null, "Relation " + ConstraintName + " isn't part of a DataSet, so this check shouldn't be happening.");
            if ((action == DataRowAction.Change ||
                 action == DataRowAction.Add ||
                 action == DataRowAction.Rollback) &&
                Table.DataSet != null && Table.DataSet.EnforceConstraints &&
                childRow.HasKeyChanged(childKey)) {

                // This branch is for cascading case verification.
                DataRowVersion version = (action == DataRowAction.Rollback) ? DataRowVersion.Original : DataRowVersion.Current;
                object[] childKeyValues = childRow.GetKeyValues(childKey);
                // check to see if this is just a change to my parent's proposed value.
                if (childRow.HasVersion(version)) {
                    // this is the new proposed value for the parent.
                    DataRow parentRow = DataRelation.GetParentRow(this.ParentKey, this.ChildKey, childRow, version);
                    if(parentRow != null && parentRow.inCascade) {
                        object[] parentKeyValues = parentRow.GetKeyValues(parentKey, action == DataRowAction.Rollback ? version : DataRowVersion.Default);

#if DEBUG
                        if (CompModSwitches.Data_Constraints.TraceVerbose) {
                            Debug.WriteLine("Parent and Child values on constraint check.");
                            for (int i = 0; i < childKeyValues.Length; i++) {
                                Debug.WriteLine("... " + i.ToString() + ": " + Convert.ToString(parentKeyValues[i]) + 
                                ", " + Convert.ToString(childKeyValues[i]));
                            }
                        }
#endif

                        int parentKeyValuesRecord = childRow.Table.NewRecord();
                        childRow.Table.SetKeyValues(childKey, parentKeyValues, parentKeyValuesRecord);
                        if (childKey.RecordsEqual(childRow.tempRecord, parentKeyValuesRecord)) {
                            return;
                        }
                    }
                }

                // now check to see if someone exists... it will have to be in a parent row's current, not a proposed.
                object[] childValues = childRow.GetKeyValues(childKey);
                if (!IsKeyNull(childValues)) {
                    Index parentIndex = parentKey.GetSortIndex();
                    if (!parentIndex.IsKeyInIndex(childValues)) {
                        // could be self-join constraint
                        if (childKey.Table == parentKey.Table && childRow.tempRecord != -1) {
                            int lo = 0;
                            for (lo = 0; lo < childValues.Length; lo++) {
                                if (parentKey.Columns[lo].CompareToValue(childRow.tempRecord, childValues[lo]) != 0)
                                    break;
                            }
                            if (lo == childValues.Length)
                                return;
                        }
                        
                        throw ExceptionBuilder.ForeignKeyViolation(ConstraintName, childKeyValues);
                    }
                }
            }
        }

        // If we're not in a DataSet relations collection, we need to verify on every property get that we're
        // still a good relation object.
        internal override void CheckState() {
            if (_DataSet == null) {
                // Make sure columns arrays are valid
                parentKey.CheckState();
                childKey.CheckState();

                if (parentKey.Table.DataSet != childKey.Table.DataSet) {
                    throw ExceptionBuilder.TablesInDifferentSets();
                }

                for (int i = 0; i < parentKey.Columns.Length; i++) {
                    if (parentKey.Columns[i].DataType != childKey.Columns[i].DataType)
                        throw ExceptionBuilder.ColumnsTypeMismatch();
                }

                if (childKey.ColumnsEqual(parentKey)) {
                    throw ExceptionBuilder.KeyColumnsIdentical();
                }
            }
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.AcceptRejectRule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates what kind of action should take place across
        ///       this constraint when <see cref='System.Data.DataTable.AcceptChanges'/>
        ///       is invoked.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(AcceptRejectRule_Default),
        DataSysDescription(Res.ForeignKeyConstraintAcceptRejectRuleDescr)
        ]
        public virtual AcceptRejectRule AcceptRejectRule {
            get {
                CheckStateForProperty();
                return acceptRejectRule;
            }
            set {
                if (acceptRejectRule != value) {
                    if (!Enum.IsDefined(typeof(AcceptRejectRule), (int) value))
                        throw ExceptionBuilder.ArgumentOutOfRange("AcceptRejectRule");
                    this.acceptRejectRule = value;
                }
            }
        }

        internal override bool ContainsColumn(DataColumn column) {
            return parentKey.ContainsColumn(column) || childKey.ContainsColumn(column);
        }

        internal override Constraint Clone(DataSet destination) {
            int iDest = destination.Tables.IndexOf(Table.TableName);
            if (iDest < 0)
                return null;
            DataTable table = destination.Tables[iDest];

            iDest = destination.Tables.IndexOf(RelatedTable.TableName);
            if (iDest < 0)
                return null;
            DataTable relatedTable = destination.Tables[iDest];

            int keys = Columns.Length;
            DataColumn[] columns = new DataColumn[keys];
            DataColumn[] relatedColumns = new DataColumn[keys];

            for (int i = 0; i < keys; i++) {
                DataColumn src = Columns[i];
                iDest = table.Columns.IndexOf(src.ColumnName);
                if (iDest < 0)
                    return null;
                columns[i] = table.Columns[iDest];

                src = RelatedColumns[i];
                iDest = relatedTable.Columns.IndexOf(src.ColumnName);
                if (iDest < 0)
                    return null;
                relatedColumns[i] = relatedTable.Columns[iDest];
            }
            ForeignKeyConstraint clone = new ForeignKeyConstraint(ConstraintName,relatedColumns, columns);
            clone.UpdateRule = this.UpdateRule;
            clone.DeleteRule = this.DeleteRule;
            clone.AcceptRejectRule = this.AcceptRejectRule;

            // ...Extended Properties
            foreach(Object key in this.ExtendedProperties.Keys) {
                clone.ExtendedProperties[key]=this.ExtendedProperties[key];
            }

            return clone;
        }

        private void Create(string relationName, DataColumn[] parentColumns, DataColumn[] childColumns) {
            if (parentColumns.Length == 0 || childColumns.Length == 0)
                throw ExceptionBuilder.KeyLengthZero();

            if (parentColumns.Length != childColumns.Length)
                throw ExceptionBuilder.KeyLengthMismatch();

            for (int i = 0; i < parentColumns.Length; i++) {
                if (parentColumns[i].Computed) {
                    throw ExceptionBuilder.ExpressionInConstraint(parentColumns[i]);
                }
                if (childColumns[i].Computed) {
                    throw ExceptionBuilder.ExpressionInConstraint(childColumns[i]);
                }
            }

            this.parentKey = new DataKey(parentColumns);
            this.childKey = new DataKey(childColumns);

            ConstraintName = relationName;

            CheckState();
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.DeleteRule"]/*' />
        /// <devdoc>
        ///    <para> Gets
        ///       or sets the action that occurs across this constraint when a row is deleted.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(Rule_Default),
        DataSysDescription(Res.ForeignKeyConstraintDeleteRuleDescr)
        ]
        public virtual Rule DeleteRule {
            get {
                CheckStateForProperty();
                return deleteRule;
            }
            set {
                if (deleteRule != value) {
                    if (!Enum.IsDefined(typeof(Rule), (int) value))
                        throw ExceptionBuilder.ArgumentOutOfRange("DeleteRule");
                    this.deleteRule = value;
                }
            }
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.Equals"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the current <see cref='System.Data.ForeignKeyConstraint'/> is identical to the specified object.</para>
        /// </devdoc>
        public override bool Equals(object key) {
            if (!(key is ForeignKeyConstraint))
                return false;
            ForeignKeyConstraint key2 = (ForeignKeyConstraint) key;

            // The ParentKey and ChildKey completely identify the ForeignKeyConstraint
            return this.ParentKey.ColumnsEqual(key2.ParentKey) && this.ChildKey.ColumnsEqual(key2.ChildKey);
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Int32 GetHashCode() {
            return ParentKey.GetHashCode() + ChildKey.GetHashCode();
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.RelatedColumns"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The parent columns of this constraint.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.ForeignKeyConstraintParentColumnsDescr),
        ReadOnly(true)
        ]
        public virtual DataColumn[] RelatedColumns {
            get {
                CheckStateForProperty();
                return parentKey.Columns;
            }
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.ParentKey"]/*' />
        /// <devdoc>
        /// The internal key object for the parent table.
        /// </devdoc>
        internal virtual DataKey ParentKey {
            get {
                CheckStateForProperty();
                return parentKey;
            }
        }

        internal DataRelation FindParentRelation () {
            DataRelationCollection rels = Table.ParentRelations;

            for (int i = 0; i < rels.Count; i++) {
                if (rels[i].ChildKeyConstraint == this)
                    return rels[i];
            }
            return null;
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.RelatedTable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the parent table of this constraint.
        ///    </para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.ForeignKeyRelatedTableDescr),
        ReadOnly(true)
        ]
        public virtual DataTable RelatedTable {
            get {
                CheckStateForProperty();
                return parentKey.Table;
            }
        }

        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.UpdateRule"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets the action that occurs across this constraint on when a row is
        ///       updated.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DefaultValue(Rule_Default),
        DataSysDescription(Res.ForeignKeyConstraintUpdateRuleDescr)
        ]
        public virtual Rule UpdateRule {
            get {
                CheckStateForProperty();
                return updateRule;
            }
            set {
                if (updateRule != value) {
                    if (!Enum.IsDefined(typeof(Rule), (int) value))
                        throw ExceptionBuilder.ArgumentOutOfRange("UpdateRule");
                    this.updateRule = value;
                }
            }
        }

#if DEBUG
        /// <include file='doc\ForeignKeyConstraint.uex' path='docs/doc[@for="ForeignKeyConstraint.Dump"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override void Dump(string header, bool deep) {
            DataColumn[] cols;
            DataColumn    col;
            int i;
            Debug.WriteLine(header + "ForeignKeyConstraint");
            header += "  ";
            Debug.WriteLine(header + "Name:          " + this.name);
            Debug.WriteLine(header + "In collection: " + this.InCollection);
            Debug.WriteLine(header + "Table (FK):    " + this.Table.TableName);
            Debug.Write(    header + "Columns (FK):  ");
            cols = this.Columns;
            if (cols.Length == 0)
                Debug.WriteLine("none");
            else {
                Debug.Write(cols[0].Table.TableName + "." + cols[0].ColumnName);
                for (i = 1; i < cols.Length; i++) {
                    col = cols[i];
                    Debug.Write(" + " + col.Table.TableName + "." + col.ColumnName);
                }
                Debug.WriteLine("");
            }

            Debug.WriteLine(header + "RelatedTable (PK): " + this.RelatedTable.TableName);
            Debug.Write(    header + "RelatedColumns (PK): ");
            cols = this.RelatedColumns;
            if (cols.Length == 0)
                Debug.WriteLine("none");
            else {
                Debug.Write(cols[0].Table.TableName + "." + cols[0].ColumnName);
                for (i = 1; i < cols.Length; i++) {
                    col = cols[i];
                    Debug.Write(" + " + col.Table.TableName + "." + col.ColumnName);
                }
                Debug.WriteLine("");
            }

            Debug.WriteLine(header + "In collection: " + this.InCollection);
            Debug.Write(    header + "AcceptRejectRule: ");
            switch (this.AcceptRejectRule) {
            case AcceptRejectRule.None:
                Debug.WriteLine("AcceptRejectRule.None"); break;
            case AcceptRejectRule.Cascade:
                Debug.WriteLine("AcceptRejectRule.Cascade"); break;
            default:
                Debug.WriteLine("AcceptRejectRule.TODO(unknown!!!)"); break;
            }

            Debug.Write(    header + "DeleteRule: ");
            switch (this.DeleteRule) {
            case Rule.None:
                Debug.WriteLine("Rule.None"); break;
            case Rule.Cascade:
                Debug.WriteLine("Rule.Cascade"); break;
            case Rule.SetNull:
                Debug.WriteLine("Rule.Cascade"); break;
            case Rule.SetDefault:
                Debug.WriteLine("Rule.Cascade"); break;
            default:
                Debug.WriteLine("AcceptRejectRule.TODO(unknown!!!)"); break;
            }

            Debug.Write(    header + "UpdateRule: ");
            switch (this.DeleteRule) {
            case Rule.None:
                Debug.WriteLine("Rule.None"); break;
            case Rule.Cascade:
                Debug.WriteLine("Rule.Cascade"); break;
            case Rule.SetNull:
                Debug.WriteLine("Rule.Cascade"); break;
            case Rule.SetDefault:
                Debug.WriteLine("Rule.Cascade"); break;
            default:
                Debug.WriteLine("AcceptRejectRule.TODO(unknown!!!)"); break;
            }
        }
#endif

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\icolumnmappings.cs ===
//------------------------------------------------------------------------------
// <copyright file="IColumnMappings.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\IColumnMappings.uex' path='docs/doc[@for="IColumnMappingCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Contains the list of source columns and their cooresponding <see cref='System.Data.DataSet'/>
    ///       columns.
    ///    </para>
    /// </devdoc>
    public interface IColumnMappingCollection : System.Collections.IList {

        /// <include file='doc\IColumnMappings.uex' path='docs/doc[@for="IColumnMappingCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the instance of <see cref='System.Data.IColumnMapping'/> with the specified name.
        ///    </para>
        /// </devdoc>
        object this[string index] {
            get;
            set;
        }

        /// <include file='doc\IColumnMappings.uex' path='docs/doc[@for="IColumnMappingCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a column mapping to the collection.
        ///    </para>
        /// </devdoc>
        IColumnMapping Add(string sourceColumnName, string dataSetColumnName);

        /// <include file='doc\IColumnMappings.uex' path='docs/doc[@for="IColumnMappingCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns whether the collection contains a column
        ///       mapping with the specified source column name.
        ///    </para>
        /// </devdoc>
        bool Contains(string sourceColumnName);

        /// <include file='doc\IColumnMappings.uex' path='docs/doc[@for="IColumnMappingCollection.GetByDataSetColumn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a reference to a <see cref='System.Data.IColumnMapping'/> table mapping.
        ///    </para>
        /// </devdoc>
        IColumnMapping GetByDataSetColumn(string dataSetColumnName);

        /// <include file='doc\IColumnMappings.uex' path='docs/doc[@for="IColumnMappingCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the location of the <see cref='System.Data.IColumnMapping'/> object within the collection.
        ///    </para>
        /// </devdoc>
        int IndexOf(string sourceColumnName);

        /// <include file='doc\IColumnMappings.uex' path='docs/doc[@for="IColumnMappingCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the <see cref='System.Data.IColumnMapping'/> object with the specified name from the
        ///       collection.
        ///    </para>
        /// </devdoc>
        void RemoveAt(string sourceColumnName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\fillerroreventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="FillErrorEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data { // MDAC 59437

    using System;
    using System.Data;

    /// <include file='doc\FillErrorEventArgs.uex' path='docs/doc[@for="FillErrorEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class FillErrorEventArgs : System.EventArgs {
        private bool continueFlag;
        private DataTable dataTable;
        private Exception errors;
        private object[] values;

        /// <include file='doc\FillErrorEventArgs.uex' path='docs/doc[@for="FillErrorEventArgs.FillErrorEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public FillErrorEventArgs(DataTable dataTable, object[] values) {
            this.dataTable = dataTable;
            this.values = values;
            if (null == this.values) {
                this.values = new object[0];
            }
        }

        /// <include file='doc\FillErrorEventArgs.uex' path='docs/doc[@for="FillErrorEventArgs.Continue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Continue {
            get {
                return this.continueFlag;
            }
            set {
                this.continueFlag = value;
            }
        }

        /// <include file='doc\FillErrorEventArgs.uex' path='docs/doc[@for="FillErrorEventArgs.DataTable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DataTable DataTable {
            get {
                return this.dataTable;
            }
        }

        /// <include file='doc\FillErrorEventArgs.uex' path='docs/doc[@for="FillErrorEventArgs.Errors"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Exception Errors {
            get {
                return this.errors;
            }
            set {
                this.errors = value;
            }
        }

        /// <include file='doc\FillErrorEventArgs.uex' path='docs/doc[@for="FillErrorEventArgs.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object[] Values {
            get {
                return this.values;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\icolumnmapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="IColumnMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\IColumnMapping.uex' path='docs/doc[@for="IColumnMapping"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Associates a source column with a <see cref='System.Data.DataSet'/> column.
    ///    </para>
    /// </devdoc>
    public interface IColumnMapping {

        /// <include file='doc\IColumnMapping.uex' path='docs/doc[@for="IColumnMapping.DataSetColumn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or set the case-insensitive name of the <see cref='System.Data.DataSet'/> column.
        ///    </para>
        /// </devdoc>
        string DataSetColumn {
            get;
            set;
        }

        /// <include file='doc\IColumnMapping.uex' path='docs/doc[@for="IColumnMapping.SourceColumn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the case-sensitive name of the source column.
        ///    </para>
        /// </devdoc>
        string SourceColumn {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idataparameters.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataParameters.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\IDataParameters.uex' path='docs/doc[@for="IDataParameterCollection"]/*' />
    public interface IDataParameterCollection : System.Collections.IList {

        /// <include file='doc\IDataParameters.uex' path='docs/doc[@for="IDataParameterCollection.this"]/*' />
        object this[string parameterName] {
            get;
            set;
        }

        /// <include file='doc\IDataParameters.uex' path='docs/doc[@for="IDataParameterCollection.Contains"]/*' />
        bool Contains(string parameterName);

        /// <include file='doc\IDataParameters.uex' path='docs/doc[@for="IDataParameterCollection.IndexOf"]/*' />
        int IndexOf(string parameterName);

        /// <include file='doc\IDataParameters.uex' path='docs/doc[@for="IDataParameterCollection.RemoveAt"]/*' />
        void RemoveAt(string parameterName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idatareader.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\IDataReader.uex' path='docs/doc[@for="IDataReader"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a way of reading a forward-only stream of IDataRecord objects.
    ///    </para>
    /// </devdoc>
    public interface IDataReader: IDisposable, IDataRecord {

        /// <include file='doc\IDataReader.uex' path='docs/doc[@for="IDataReader.Depth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the level of nesting, if nested tables ase being returned in-line.
        ///    </para>
        /// </devdoc>
        int Depth {
            get;
        }

        /// <include file='doc\IDataReader.uex' path='docs/doc[@for="IDataReader.IsClosed"]/*' />
        /// <devdoc>
        /// </devdoc>
        bool IsClosed {
            get;
        }

        /// <include file='doc\IDataReader.uex' path='docs/doc[@for="IDataReader.RecordsAffected"]/*' />
        /// <devdoc>
        /// </devdoc>
        int RecordsAffected {
            get;
        }

        /// <include file='doc\IDataReader.uex' path='docs/doc[@for="IDataReader.Close"]/*' />
        /// <devdoc>
        /// </devdoc>
        void Close();

        /// <include file='doc\IDataReader.uex' path='docs/doc[@for="IDataReader.NextResult"]/*' />
        /// <devdoc>
        /// </devdoc>
        bool NextResult();

        /// <include file='doc\IDataReader.uex' path='docs/doc[@for="IDataReader.Read"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Reads the next record from the stream so that the field information can be
        ///       accessed.
        ///    </para>
        /// </devdoc>
        bool Read();

        /// <include file='doc\IDataReader.uex' path='docs/doc[@for="IDataReader.GetSchemaTable"]/*' />
        /// <devdoc>
        /// </devdoc>
        DataTable GetSchemaTable();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idataparameter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataParameter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\IDataParameter.uex' path='docs/doc[@for="IDataParameter"]/*' />
    public interface IDataParameter {

        /// <include file='doc\IDataParameter.uex' path='docs/doc[@for="IDataParameter.DbType"]/*' />
        DbType DbType {
            get;
            set;
        }

        /// <include file='doc\IDataParameter.uex' path='docs/doc[@for="IDataParameter.Direction"]/*' />
        ParameterDirection Direction {
            get;
            set;
        }

         /// <include file='doc\IDataParameter.uex' path='docs/doc[@for="IDataParameter.IsNullable"]/*' />
         Boolean IsNullable {
            get;
        }

        /// <include file='doc\IDataParameter.uex' path='docs/doc[@for="IDataParameter.ParameterName"]/*' />
        String ParameterName {
            get;
            set;
        }

        /// <include file='doc\IDataParameter.uex' path='docs/doc[@for="IDataParameter.SourceColumn"]/*' />
        String SourceColumn {
            get;
            set;
        }

        /// <include file='doc\IDataParameter.uex' path='docs/doc[@for="IDataParameter.SourceVersion"]/*' />
        DataRowVersion SourceVersion {
            get;
            set;
        }

        /// <include file='doc\IDataParameter.uex' path='docs/doc[@for="IDataParameter.Value"]/*' />
        object Value {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idatasetcommand.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataSetCommand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\IDataSetCommand.uex' path='docs/doc[@for="IDataAdapter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Allows an object to create a data set command,
    ///       which represents a set of data commands and a database connection that are used to
    ///       fill the <see cref='System.Data.DataSet'/>, and update the data
    ///       source. At any time, the object that implements this interface
    ///       refers to
    ///       only a single record within the current data set.
    ///    </para>
    /// </devdoc>
    public interface IDataAdapter {

        /// <include file='doc\IDataSetCommand.uex' path='docs/doc[@for="IDataAdapter.MissingMappingAction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether unmapped
        ///       source tables
        ///       or columns are passed with their source names in order to be filtered or to raise an error.
        ///    </para>
        /// </devdoc>
        MissingMappingAction MissingMappingAction {
            get;
            set;
        }

        /// <include file='doc\IDataSetCommand.uex' path='docs/doc[@for="IDataAdapter.MissingSchemaAction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether missing source
        ///       tables, columns, and their relationships are added to the data set schema, ignored, or cause an error to be raised.
        ///    </para>
        /// </devdoc>
        MissingSchemaAction MissingSchemaAction {
            get;
            set;
        }

        /// <include file='doc\IDataSetCommand.uex' path='docs/doc[@for="IDataAdapter.TableMappings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets how a source table is mapped to a data set table.
        ///    </para>
        /// </devdoc>
        ITableMappingCollection TableMappings {
            get;
        }

        /// <include file='doc\IDataSetCommand.uex' path='docs/doc[@for="IDataAdapter.FillSchema"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Fills the <see cref='System.Data.DataSet'/>
        ///       with only the schema, based on the chosen <see cref='System.Data.SchemaType'/> .
        ///    </para>
        /// </devdoc>
        DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType);

        /// <include file='doc\IDataSetCommand.uex' path='docs/doc[@for="IDataAdapter.Fill"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Changes the data in the <see cref='System.Data.DataSet'/>
        ///       to match the data in the data source.
        ///    </para>
        /// </devdoc>
        int Fill(DataSet dataSet);

        /// <include file='doc\IDataSetCommand.uex' path='docs/doc[@for="IDataAdapter.GetFillParameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an array of <see cref='System.Data.IDataParameter'/>
        ///       objects used to fill the <see cref='System.Data.DataSet'/>
        ///       with records from the data source.
        ///    </para>
        /// </devdoc>
        IDataParameter[] GetFillParameters();

        /// <include file='doc\IDataSetCommand.uex' path='docs/doc[@for="IDataAdapter.Update"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Changes the data in the data source to match the data in
        ///       the <see cref='System.Data.DataSet'/>.
        ///    </para>
        /// </devdoc>
        int Update(DataSet dataSet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idatarecord.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataRecord.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * @(#)IDataRecord.cs 1.0 1/3/00
 * 
 * Defines the IDataRecord interface
 *
 * Copyright (c) 2000 Microsoft, Corp. All Rights Reserved.
 * 
 */

namespace System.Data {
    using System;

    /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides forward-only, read-only access
    ///       to a data source.
    ///    </para>
    /// </devdoc>
    public interface IDataRecord {

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.FieldCount"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of fields at the current record.
        ///    </para>
        /// </devdoc>
        int FieldCount { get;}

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the name for the field to find.
        ///    </para>
        /// </devdoc>
        String GetName(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetDataTypeName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the data type information for the specified field.
        ///    </para>
        /// </devdoc>
        String GetDataTypeName(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetFieldType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Type'/> information corresponding to the type
        ///       of <see cref='System.Object'/>
        ///       that would be returned from <see cref='System.Data.IDataRecord.GetValue'/>
        ///       .
        ///    </para>
        /// </devdoc>
        Type GetFieldType(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Return the value of the specified field.
        ///    </para>
        /// </devdoc>
        Object GetValue(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns all the attribute fields in the collection for the current
        ///       record.
        ///    </para>
        /// </devdoc>
        int GetValues(object[] values);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetOrdinal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Return the index of the named field.
        ///    </para>
        /// </devdoc>
        int GetOrdinal(string name);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the field located at the specified index.
        ///    </para>
        /// </devdoc>
        object this [ int i ] { get;}

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.this1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the field with the specified name.
        ///    </para>
        /// </devdoc>
        object this [ String name ] { get;}

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetBoolean"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the boolean value of the specified field.
        ///    </para>
        /// </devdoc>
        bool GetBoolean(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetByte"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the 8-bit unsigned integer value of the specified field.
        ///    </para>
        /// </devdoc>
        byte GetByte(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetBytes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies a stream of bytes from the field offset in the specified field into
        ///       the buffer starting at the given buffer offset.
        ///    </para>
        /// </devdoc>
        long GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the character value of the specified field.
        ///    </para>
        /// </devdoc>
        char GetChar(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetChars"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies a stream of characters from the field offset
        ///       in the specified field into the buffer starting at the given buffer
        ///       offset.
        ///    </para>
        /// </devdoc>
        long GetChars(int i, long fieldoffset, char[] buffer, int bufferoffset, int length);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetGuid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the guid value of the specified field.
        ///    </para>
        /// </devdoc>
        Guid GetGuid(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetInt16"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the 16-bit signed integer value of the specified field.
        ///    </para>
        /// </devdoc>
        Int16 GetInt16(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetInt32"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the 32-bit signed integer value of the specified field.
        ///    </para>
        /// </devdoc>
        Int32 GetInt32(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetInt64"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the 64-bit signed integer value of the specified field.
        ///    </para>
        /// </devdoc>
        Int64 GetInt64(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetFloat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the single-precision floating point number of the specified
        ///       field.
        ///    </para>
        /// </devdoc>
        float GetFloat(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetDouble"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the double-precision floating point number of the specified
        ///       field.
        ///    </para>
        /// </devdoc>
        double GetDouble(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the string value of the specified field.
        ///    </para>
        /// </devdoc>
        String GetString(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetDecimal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the fixed-position numeric value of the specified field.
        ///    </para>
        /// </devdoc>
        Decimal GetDecimal(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetDateTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the date and time data value of the spcified field.
        ///    </para>
        /// </devdoc>
        DateTime GetDateTime(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.GetData"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an <see cref='System.Data.IDataReader'/> to be used when the field points to more remote
        ///       structured data.
        ///    </para>
        /// </devdoc>
        IDataReader GetData(int i);

        /// <include file='doc\IDataRecord.uex' path='docs/doc[@for="IDataRecord.IsDBNull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Return whether the specified field is set to null.
        ///    </para>
        /// </devdoc>
        bool IsDBNull(int i);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idbconnection.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDbConnection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IDbConnection : IDisposable {
        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.ConnectionString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the string used to open a data store.
        ///    </para>
        /// </devdoc>
        string ConnectionString {
            get;
            set; 
        }
        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.ConnectionTimeout"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        int ConnectionTimeout {
            get;
        }
        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.Database"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        string Database {
            get;
        }

        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.State"]/*' />
        ConnectionState State {
            get;
        }

        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.BeginTransaction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Begins a database transaction.
        ///    </para>
        /// </devdoc>
        IDbTransaction BeginTransaction();

        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.BeginTransaction1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Begins a database transaction with the specified isolation level.
        ///    </para>
        /// </devdoc>
        IDbTransaction BeginTransaction(IsolationLevel il); 

        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the
        ///       connection to the database.
        ///    </para>
        /// </devdoc>
        void Close();

        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.ChangeDatabase"]/*' />
        void ChangeDatabase(string databaseName);

        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.CreateCommand"]/*' />
        IDbCommand CreateCommand();

        /// <include file='doc\IDbConnection.uex' path='docs/doc[@for="IDbConnection.Open"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Opens a connection to the database.
        ///    </para>
        /// </devdoc>
        void Open();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idbcommand.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDbCommand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data{
    using System;

    /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand"]/*' />
    public interface IDbCommand : IDisposable {

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.Connection"]/*' />
        IDbConnection Connection {
            get;
            set;
        }

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.Transaction"]/*' />
        IDbTransaction Transaction {
            get;
            set;
        }

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.CommandText"]/*' />
        string CommandText {
            get;
            set;
        }

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.CommandTimeout"]/*' />
        int CommandTimeout {
            get;
            set;
        }

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.CommandType"]/*' />
        CommandType CommandType {
            get;
            set;
        }

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.Parameters"]/*' />
        IDataParameterCollection Parameters {
            get;
        }

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.Prepare"]/*' />
        void Prepare();
         
        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.UpdatedRowSource"]/*' />
        UpdateRowSource UpdatedRowSource {
            get;
            set;
        }

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.Cancel"]/*' />
        void Cancel();

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.CreateParameter"]/*' />
        IDbDataParameter CreateParameter(); // MDAC 68310

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.ExecuteNonQuery"]/*' />
        int ExecuteNonQuery();

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.ExecuteReader"]/*' />
        IDataReader ExecuteReader();

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.ExecuteReader1"]/*' />
        IDataReader ExecuteReader(CommandBehavior behavior);

        /// <include file='doc\IDbCommand.uex' path='docs/doc[@for="IDbCommand.ExecuteScalar"]/*' />
        object ExecuteScalar();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idbdataadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDbDataAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\IDbDataAdapter.uex' path='docs/doc[@for="IDbDataAdapter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IDbDataAdapter : IDataAdapter {
        /// <include file='doc\IDbDataAdapter.uex' path='docs/doc[@for="IDbDataAdapter.SelectCommand"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        IDbCommand SelectCommand {
            get;
            set;
        }
        /// <include file='doc\IDbDataAdapter.uex' path='docs/doc[@for="IDbDataAdapter.InsertCommand"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        IDbCommand InsertCommand {
            get;
            set;
        }
        /// <include file='doc\IDbDataAdapter.uex' path='docs/doc[@for="IDbDataAdapter.UpdateCommand"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        IDbCommand UpdateCommand {
            get;
            set;
        }
        /// <include file='doc\IDbDataAdapter.uex' path='docs/doc[@for="IDbDataAdapter.DeleteCommand"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        IDbCommand DeleteCommand {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idbtransaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDbTransaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data{
    using System;

    /// <include file='doc\IDbTransaction.uex' path='docs/doc[@for="IDbTransaction"]/*' />
    public interface IDbTransaction : IDisposable {

        /// <include file='doc\IDbTransaction.uex' path='docs/doc[@for="IDbTransaction.Connection"]/*' />
        IDbConnection Connection { // MDAC 66655
            get;
        }

        /// <include file='doc\IDbTransaction.uex' path='docs/doc[@for="IDbTransaction.IsolationLevel"]/*' />
        IsolationLevel IsolationLevel {
            get;
        }

        /// <include file='doc\IDbTransaction.uex' path='docs/doc[@for="IDbTransaction.Commit"]/*' />
        void Commit();

        //IDbCommand CreateCommand(); // MDAC 68309

        /// <include file='doc\IDbTransaction.uex' path='docs/doc[@for="IDbTransaction.Rollback"]/*' />
        void Rollback();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\idbdataparameter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDbDataParameter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\IDbDataParameter.uex' path='docs/doc[@for="IDbDataParameter"]/*' />
    public interface IDbDataParameter : IDataParameter { // MDAC 68205

        /// <include file='doc\IDbDataParameter.uex' path='docs/doc[@for="IDbDataParameter.Precision"]/*' />
        byte Precision {
            get;
            set;
        }

        /// <include file='doc\IDbDataParameter.uex' path='docs/doc[@for="IDbDataParameter.Scale"]/*' />
        byte Scale {
            get;
            set;
        }

        /// <include file='doc\IDbDataParameter.uex' path='docs/doc[@for="IDbDataParameter.Size"]/*' />
        int Size {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\isqlconnection.cs ===
#if V2
//------------------------------------------------------------------------------
// <copyright file="ISqlConnection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\ISqlConnection.uex' path='docs/doc[@for="ISqlConnection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface ISqlConnection : IDbConnection {
        /// <include file='doc\ISqlConnection.uex' path='docs/doc[@for="ISqlConnection.ServerVersion"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        string ServerVersion {
            get;
        }            
        /// <include file='doc\ISqlConnection.uex' path='docs/doc[@for="ISqlConnection.BeginTransaction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        new ISqlTransaction BeginTransaction();
        /// <include file='doc\ISqlConnection.uex' path='docs/doc[@for="ISqlConnection.BeginTransaction1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        new ISqlTransaction BeginTransaction(IsolationLevel iso);
        /// <include file='doc\ISqlConnection.uex' path='docs/doc[@for="ISqlConnection.BeginTransaction2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ISqlTransaction BeginTransaction(string transactionName);
        /// <include file='doc\ISqlConnection.uex' path='docs/doc[@for="ISqlConnection.BeginTransaction3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ISqlTransaction BeginTransaction(IsolationLevel iso, string transactionName);

        /// <include file='doc\ISqlConnection.uex' path='docs/doc[@for="ISqlConnection.ChangeDatabase"]/*' />
        void ChangeDatabase(string databaseName);

        /// <include file='doc\ISqlConnection.uex' path='docs/doc[@for="ISqlConnection.CreateCommand"]/*' />
        new ISqlCommand CreateCommand();
    }
}    
#endif // v2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\isolationlevel.cs ===
//------------------------------------------------------------------------------
// <copyright file="IsolationLevel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\IsolationLevel.uex' path='docs/doc[@for="IsolationLevel"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the transaction locking behavior for the connection.
    ///    </para>
    /// </devdoc>
    [Flags] public enum IsolationLevel {
        /// <include file='doc\IsolationLevel.uex' path='docs/doc[@for="IsolationLevel.Unspecified"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A different isolation level than the one specified is being used, but the
        ///       level cannot be determined.
        ///    </para>
        /// </devdoc>
        Unspecified     = unchecked((int)0xffffffff),
        /// <include file='doc\IsolationLevel.uex' path='docs/doc[@for="IsolationLevel.Chaos"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The pending changes from more highly isolated transactions cannot be
        ///       overwritten.
        ///    </para>
        /// </devdoc>
        Chaos           = 0x10,
        /// <include file='doc\IsolationLevel.uex' path='docs/doc[@for="IsolationLevel.ReadUncommitted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A dirty read is possible, meaning that no shared locks are issued and no exclusive locks are honored.
        ///    </para>
        /// </devdoc>
        ReadUncommitted = 0x100,
        /// <include file='doc\IsolationLevel.uex' path='docs/doc[@for="IsolationLevel.ReadCommitted"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Shared locks are held while the data is being read to avoid dirty reads, but
        ///       the data can be changed before the end of the transaction, resulting in
        ///       non-repeatable reads or phantom data.
        ///    </para>
        /// </devdoc>
        ReadCommitted   = 0x1000,
        /// <include file='doc\IsolationLevel.uex' path='docs/doc[@for="IsolationLevel.RepeatableRead"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Locks are placed on all data that is used in a query, preventing other users from updating the data. Prevents non-repeatable reads but phantom rows are still possible.
        ///    </para>
        /// </devdoc>
        RepeatableRead  = 0x10000,
        /// <include file='doc\IsolationLevel.uex' path='docs/doc[@for="IsolationLevel.Serializable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A range lock is palced on the <see cref='System.Data.DataSet'/>
        ///       , preventing other users from updating or inserting rows into the dataset until the transaction is complete.
        ///    </para>
        /// </devdoc>
        Serializable    = 0x100000
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\isqlparametercollection.cs ===
#if V2
//------------------------------------------------------------------------------
// <copyright file="ISqlParameterCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\ISqlParameterCollection.uex' path='docs/doc[@for="ISqlParameterCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Collects all parameters relevant to the <see cref='System.Data.IDbCommand'/>
    ///       and
    ///       their mappings to <see cref='System.Data.DataSet'/>
    ///       columns.
    ///    </para>
    /// </devdoc>
    public interface ISqlParameterCollection : IDataParameterCollection {
        /// <include file='doc\ISqlParameterCollection.uex' path='docs/doc[@for="ISqlParameterCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ISqlParameter Add(ISqlParameter value);
        /// <include file='doc\ISqlParameterCollection.uex' path='docs/doc[@for="ISqlParameterCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        new ISqlParameter this[int i] {get;set;}
        /// <include file='doc\ISqlParameterCollection.uex' path='docs/doc[@for="ISqlParameterCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        new ISqlParameter this[string name] {get;set;}
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\isqlcommand.cs ===
#if V2
//------------------------------------------------------------------------------
// <copyright file="ISqlCommand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
namespace System.Data {
    using System;
    using System.Xml;

    /// <include file='doc\ISqlCommand.uex' path='docs/doc[@for="ISqlCommand"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface ISqlCommand : IDbCommand {
        /// <include file='doc\ISqlCommand.uex' path='docs/doc[@for="ISqlCommand.Connection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        new ISqlConnection Connection {
            get;
            set;
        }
        /// <include file='doc\ISqlCommand.uex' path='docs/doc[@for="ISqlCommand.Transaction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        new ISqlTransaction Transaction {
            get;
            set;
        }            
        /// <include file='doc\ISqlCommand.uex' path='docs/doc[@for="ISqlCommand.Parameters"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        new ISqlParameterCollection Parameters {
            get;
        }
        
        /// <include file='doc\ISqlCommand.uex' path='docs/doc[@for="ISqlCommand.CreateParameter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        new ISqlParameter CreateParameter();
        /// <include file='doc\ISqlCommand.uex' path='docs/doc[@for="ISqlCommand.ExecuteReader"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        new ISqlReader ExecuteReader();
        /// <include file='doc\ISqlCommand.uex' path='docs/doc[@for="ISqlCommand.ExecuteReader1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        new ISqlReader ExecuteReader(CommandBehavior behavior);
        /// <include file='doc\ISqlCommand.uex' path='docs/doc[@for="ISqlCommand.ExecuteResultset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        ISqlResultset ExecuteResultset(int options);
        /// <include file='doc\ISqlCommand.uex' path='docs/doc[@for="ISqlCommand.ExecuteStream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        XmlReader ExecuteXmlReader();
    }
}
#endif // V2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\isqlreader.cs ===
#if V2
//------------------------------------------------------------------------------
// <copyright file="ISqlReader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\ISqlReader.uex' path='docs/doc[@for="ISqlReader"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface ISqlReader: IDataReader {
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\isqlparameter.cs ===
#if V2
//------------------------------------------------------------------------------
// <copyright file="ISqlParameter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\ISqlParameter.uex' path='docs/doc[@for="ISqlParameter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface ISqlParameter : IDbDataParameter {
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\isqlrecord.cs ===
#if V2
//------------------------------------------------------------------------------
// <copyright file="ISqlRecord.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data{
    using System;
    using System.Data.SqlTypes;

    /*
     * ISqlDataReader, ISqlDataRecord
     * 
     * Defines the SQL Server specific IDataReader interfaces
     *
     * Copyright (c) 1999 Microsoft, Corp. All Rights Reserved.
     * 
     */
    /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Exposes SQL Server specific data types.
    ///    </para>
    /// </devdoc>
    public interface ISqlRecord : IDataRecord {
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlBinary"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlBinary'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        // System.SQLType getters
        SqlBinary GetSqlBinary(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlBit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlBit'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        // System.SQLType getters
        SqlBit GetSqlBit(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlByte"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlByte'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlByte GetSqlByte(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlInt16"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlInt16'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlInt16 GetSqlInt16(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlInt32"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlInt32'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlInt32 GetSqlInt32(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlInt64"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlInt64'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlInt64 GetSqlInt64(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlSingle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlSingle'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlSingle GetSqlSingle(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlDouble"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlDouble'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlDouble GetSqlDouble(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlMoney"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlMoney'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlMoney GetSqlMoney(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlDateTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlDateTime'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlDateTime GetSqlDateTime(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlDecimal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlDecimal'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlDecimal GetSqlDecimal(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlString'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlString GetSqlString(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlGuid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Data.SqlTypes.SqlGuid'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        SqlGuid GetSqlGuid(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.Object'/> value of the specified column.
        ///    </para>
        /// </devdoc>
        object GetSqlValue(int i);
        /// <include file='doc\ISqlRecord.uex' path='docs/doc[@for="ISqlRecord.GetSqlValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns values for all columns in the current record using the SQLType
        ///       classes.
        ///    </para>
        /// </devdoc>
        int GetSqlValues(object[] values);
    }
}
#endif // V2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\isqlresultset.cs ===
#if V2
//------------------------------------------------------------------------------
// <copyright file="ISqlResultset.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface ISqlResultset {
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.Restartable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool Restartable {
            get;
        }
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.Scrollable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool Scrollable {
            get;
        }
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.Updatable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        bool Updatable {
            get;
        }
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.Delete"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        void Delete();
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void Insert(ISqlRecord record);
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.MoveAbsolute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool MoveAbsolute(int position); // can you guys really do this?  Won't it be costly?
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.MoveFirst"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool MoveFirst();
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.MoveLast"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool MoveLast();
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.MoveNext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool MoveNext();
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.MovePrevious"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool MovePrevious();
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.MoveRelative"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool MoveRelative(int position);
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.Restart"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool Restart();
        /// <include file='doc\ISqlResultset.uex' path='docs/doc[@for="ISqlResultset.Update"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void Update();
    }        
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\isqltransaction.cs ===
#if V2
//------------------------------------------------------------------------------
// <copyright file="ISqlTransaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
namespace System.Data {
    using System;

    /// <include file='doc\ISqlTransaction.uex' path='docs/doc[@for="ISqlTransaction"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface ISqlTransaction : IDbTransaction {
        /// <include file='doc\ISqlTransaction.uex' path='docs/doc[@for="ISqlTransaction.Rollback"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void Rollback(string transactionName);
        /// <include file='doc\ISqlTransaction.uex' path='docs/doc[@for="ISqlTransaction.Save"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void Save(string savePoint);
    }
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\itablemapping.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITableMapping.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\ITableMapping.uex' path='docs/doc[@for="ITableMapping"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Associates a source table with a table within a <see cref='System.Data.DataSet'/>.
    ///    </para>
    /// </devdoc>
    public interface ITableMapping {

        /// <include file='doc\ITableMapping.uex' path='docs/doc[@for="ITableMapping.ColumnMappings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets how to associate the columns within the source table to the columns
        ///       within the <see cref='System.Data.DataSet'/> table.
        ///    </para>
        /// </devdoc>
        IColumnMappingCollection ColumnMappings {
            get;
        }

        /// <include file='doc\ITableMapping.uex' path='docs/doc[@for="ITableMapping.DataSetTable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the case-insensitive name of the table within the <see cref='System.Data.DataSet'/>.
        ///    </para>
        /// </devdoc>
        string DataSetTable {
            get;
            set;
        }

        /// <include file='doc\ITableMapping.uex' path='docs/doc[@for="ITableMapping.SourceTable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the case-sensitive name of the source
        ///       table.
        ///    </para>
        /// </devdoc>
        string SourceTable {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\mappingtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="MappingType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\MappingType.uex' path='docs/doc[@for="MappingType"]/*' />
    /// <devdoc>
    /// <para>Specifies how a <see cref='System.Data.DataColumn'/> is mapped.</para>
    /// </devdoc>
    [Serializable]
    public enum MappingType {
        /// <include file='doc\MappingType.uex' path='docs/doc[@for="MappingType.Element"]/*' />
        /// <devdoc>
        ///    <para>The column is mapped to an HTML element.</para>
        /// </devdoc>
        Element         = 1,        // Element column
        /// <include file='doc\MappingType.uex' path='docs/doc[@for="MappingType.Attribute"]/*' />
        /// <devdoc>
        ///    <para>The column is mapped to an HTML attribute.</para>
        /// </devdoc>
        Attribute       = 2,        // Attribute column
        /// <include file='doc\MappingType.uex' path='docs/doc[@for="MappingType.Text"]/*' />
        /// <devdoc>
        ///    <para>The column is mapped to text.</para>
        /// </devdoc>
        SimpleContent   = 3,        // SimpleContent column
        /// <include file='doc\MappingType.uex' path='docs/doc[@for="MappingType.Hidden"]/*' />
        /// <devdoc>
        ///    <para>The column is mapped to an internal structure.</para>
        /// </devdoc>
        Hidden          = 4         // Internal mapping
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\itablemappings.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITableMappings.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\ITableMappings.uex' path='docs/doc[@for="ITableMappingCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Contains the list of source tables and columns and their corresponding
    ///       DataSet tables and columns.
    ///    </para>
    /// </devdoc>
    public interface ITableMappingCollection : System.Collections.IList {

        /// <include file='doc\ITableMappings.uex' path='docs/doc[@for="ITableMappingCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the instance of <see cref='System.Data.ITableMapping'/> with the specified name.
        ///    </para>
        /// </devdoc>
        object this[string index] {
            get;
            set;
        }

        /// <include file='doc\ITableMappings.uex' path='docs/doc[@for="ITableMappingCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a table mapping to the collection.
        ///    </para>
        /// </devdoc>
        ITableMapping Add(string sourceTableName, string dataSetTableName);


        /// <include file='doc\ITableMappings.uex' path='docs/doc[@for="ITableMappingCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns whether the collection contains a table mapping
        ///       with the specified source table name.
        ///    </para>
        /// </devdoc>
        bool Contains(string sourceTableName);

        /// <include file='doc\ITableMappings.uex' path='docs/doc[@for="ITableMappingCollection.GetByDataSetTable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a reference to a <see cref='System.Data.ITableMapping'/> table mapping.
        ///    </para>
        /// </devdoc>
        ITableMapping GetByDataSetTable(string dataSetTableName);

        /// <include file='doc\ITableMappings.uex' path='docs/doc[@for="ITableMappingCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the location of the <see cref='System.Data.ITableMapping'/> object within the collection.
        ///    </para>
        /// </devdoc>
        int IndexOf(string sourceTableName);

        /// <include file='doc\ITableMappings.uex' path='docs/doc[@for="ITableMappingCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the <see cref='System.Data.ITableMapping'/> object with the specified name from the
        ///       collection.
        ///    </para>
        /// </devdoc>
        void RemoveAt(string sourceTableName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\mergefailedevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="MergeFailedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\MergeFailedEvent.uex' path='docs/doc[@for="MergeFailedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class MergeFailedEventArgs : EventArgs {
        private DataTable table;
        private string conflict;

        /// <include file='doc\MergeFailedEvent.uex' path='docs/doc[@for="MergeFailedEventArgs.MergeFailedEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public MergeFailedEventArgs(DataTable table, string conflict) {
            this.table = table;
            this.conflict = conflict;
        }

        /// <include file='doc\MergeFailedEvent.uex' path='docs/doc[@for="MergeFailedEventArgs.Table"]/*' />
        /// <devdoc>
        /// <para>Gets the name of the <see cref='System.Data.DataTable'/>.</para>
        /// </devdoc>
        public DataTable Table {
            get { return table; }
        }

        /// <include file='doc\MergeFailedEvent.uex' path='docs/doc[@for="MergeFailedEventArgs.Conflict"]/*' />
        /// <devdoc>
        ///    <para>Gets a description of the merge conflict.</para>
        /// </devdoc>
        public string Conflict {
            get { return conflict; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\merger.cs ===
//------------------------------------------------------------------------------
// <copyright file="Merger.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\Merger.uex' path='docs/doc[@for="Merger"]/*' />
    /// <devdoc>
    /// Merge Utilities.
    /// </devdoc>
    internal class Merger {
        private DataSet dataSet;
        private bool preserveChanges;
        private MissingSchemaAction missingSchemaAction;

        internal Merger(DataSet dataSet, bool preserveChanges, MissingSchemaAction missingSchemaAction) {
            this.dataSet = dataSet;
            this.preserveChanges = preserveChanges;

            // map AddWithKey -> Add
            if (missingSchemaAction == MissingSchemaAction.AddWithKey)
                this.missingSchemaAction = MissingSchemaAction.Add;
            else                
                this.missingSchemaAction = missingSchemaAction;
        }

        internal void MergeDataSet(DataSet source) {
            if (source == dataSet) return;  //somebody is doing an 'automerge'
            bool fEnforce = dataSet.EnforceConstraints;
            dataSet.EnforceConstraints = false;

            for (int i = 0; i < source.Tables.Count;  i++) {
                MergeTableData(source.Tables[i]);
            }

            if (MissingSchemaAction.Ignore != missingSchemaAction) {
                // Add all independent constraints
                MergeConstraints(source);

                // Add all relationships 
                for (int i = 0; i < source.Relations.Count;  i++) {
                    MergeRelation(source.Relations[i]);
                }
            }

            MergeExtendedProperties(source.ExtendedProperties, dataSet.ExtendedProperties);
            dataSet.EnforceConstraints = fEnforce;
        }

        internal void MergeTable(DataTable src) {
            if (src.DataSet == dataSet) return; //somebody is doing an 'automerge'
            bool fEnforce = dataSet.EnforceConstraints;
            dataSet.EnforceConstraints = false;
            MergeTableData(src);
            dataSet.EnforceConstraints = fEnforce;
        }

        private void MergeTable(DataTable src, DataTable dst) {
            int  rowsCount = src.Rows.Count;
            bool wasEmpty  = dst.Rows.Count == 0;
            if(0 < rowsCount) {
                Index   ndxSearch = null;
                DataKey key         = null;
                ArrayList saveIndexes = dst.LiveIndexes;
                dst.indexes = new ArrayList();
                if(! wasEmpty && dst.primaryKey != null) {
                    key = GetSrcKey(src, dst);
                    if (key != null)
                        ndxSearch = dst.primaryKey.Key.GetSortIndex(DataViewRowState.OriginalRows | DataViewRowState.Added );
                }
                for (int i = 0; i < rowsCount; i ++) {
                    DataRow sourceRow = src.Rows[i];
                    DataRow targetRow = null;
                    if(ndxSearch != null) {
                        targetRow = dst.FindMergeTarget(sourceRow, key, ndxSearch);
                    }
                    dst.MergeRow(sourceRow, targetRow, preserveChanges, ndxSearch);
                }
                dst.indexes = saveIndexes;
                dst.ResetIndexes();
            }
            MergeExtendedProperties(src.ExtendedProperties, dst.ExtendedProperties);
        }

        internal void MergeRows(DataRow[] rows) {
            DataTable src = null;
            DataTable dst = null;
            DataKey   key = null;
            Index     ndxSearch = null;

            bool fEnforce = dataSet.EnforceConstraints;
            dataSet.EnforceConstraints = false;
            Hashtable saveTableIndexes = new Hashtable();

            for (int i = 0; i < rows.Length; i++) {
                DataRow row = rows[i];

                if (row == null) {
                    throw ExceptionBuilder.ArgumentNull("rows[" + i + "]");
                }
                if (row.Table == null) {
                    throw ExceptionBuilder.ArgumentNull("rows[" + i + "].Table");
                }

                //somebody is doing an 'automerge'
                if (row.Table.DataSet == dataSet) 
                    continue;  

                if (src != row.Table) {                     // row.Table changed from prev. row.
                    src = row.Table;
                    dst = MergeSchema(row.Table);
                    if (dst == null) {
                        Debug.Assert(MissingSchemaAction.Ignore == missingSchemaAction, "MergeSchema failed");
                        dataSet.EnforceConstraints = fEnforce;
                        return;
                    }
                    if(dst.primaryKey != null)
                        key = GetSrcKey(src, dst);
                    if (key != null)
                        ndxSearch = new Index(dst, dst.primaryKey.Key.GetIndexDesc(), DataViewRowState.OriginalRows | DataViewRowState.Added, (IFilter)null);
                        // Getting our own copy instead. ndxSearch = dst.primaryKey.Key.GetSortIndex();
                }

                if (row.newRecord == -1 && row.oldRecord == -1)
                    continue;
                    
                DataRow targetRow = null;
                if(0 < dst.Rows.Count && ndxSearch != null) {
                    targetRow = dst.FindMergeTarget(row, key, ndxSearch);
                }
                if (!saveTableIndexes.Contains(dst)) {
                    saveTableIndexes[dst] = dst.LiveIndexes;
                    saveTableIndexes[dst] = new ArrayList();
                }
                dst.MergeRow(row, targetRow, preserveChanges, ndxSearch);
            }

            dataSet.EnforceConstraints = fEnforce;
            foreach (DataTable tab in saveTableIndexes.Keys) {
                tab.indexes = (ArrayList) saveTableIndexes[tab];
                tab.ResetIndexes();
            }
        }

        private DataTable MergeSchema(DataTable table) {
            DataTable targetTable = null;
            if (dataSet.Tables.Contains(table.TableName, true))
                targetTable = dataSet.Tables[table.TableName];

            if (targetTable == null) {
                if (MissingSchemaAction.Add == missingSchemaAction) {
                    targetTable = table.Clone();
                    dataSet.Tables.Add(targetTable);
                }
                else if (MissingSchemaAction.Error == missingSchemaAction) {
                    throw ExceptionBuilder.MergeMissingDefinition(table.TableName);
                }
            }
            else {
                if (MissingSchemaAction.Ignore != missingSchemaAction) {
                    // Do the columns
                    int oldCount = targetTable.Columns.Count;
                    for (int i = 0; i < table.Columns.Count; i++) {
                        DataColumn src = table.Columns[i];
                        DataColumn dest = (targetTable.Columns.Contains(src.ColumnName, true)) ? targetTable.Columns[src.ColumnName] : null;
                        if (dest == null) {
                            if (MissingSchemaAction.Add == missingSchemaAction) {
                                dest = src.Clone();
                                targetTable.Columns.Add(dest);
                            }
                            else {
                                dataSet.RaiseMergeFailed(targetTable, Res.GetString(Res.DataMerge_MissingColumnDefinition, table.TableName, src.ColumnName), missingSchemaAction);
                            }
                        }
                        else {
                            if (dest.DataType != src.DataType) {
                                dataSet.RaiseMergeFailed(targetTable, Res.GetString(Res.DataMerge_DataTypeMismatch, src.ColumnName), MissingSchemaAction.Error);
                            }
                            // CONSIDER: check all other properties; 
                            // CONSIDER: if property has default value, change it or not?

                            MergeExtendedProperties(src.ExtendedProperties, dest.ExtendedProperties);
                        }
                    }

                    // Set DataExpression
                    for (int i = oldCount; i < targetTable.Columns.Count; i++) {
                        targetTable.Columns[i].Expression = table.Columns[targetTable.Columns[i].ColumnName].Expression;
                    }
                
                    // check the PrimaryKey
                    if (targetTable.PrimaryKey.Length != table.PrimaryKey.Length) {
                        // special case when the target table does not have the PrimaryKey

                        if (targetTable.PrimaryKey.Length == 0) {
                            int keyLength = table.PrimaryKey.Length;
                            DataColumn[] key = new DataColumn[keyLength];

                            for (int i = 0; i < keyLength; i++) {
                                key[i] = targetTable.Columns[table.PrimaryKey[i].ColumnName];
                            }
                            targetTable.PrimaryKey = key;
                        }
                        else if (table.PrimaryKey.Length != 0) {
                            dataSet.RaiseMergeFailed(targetTable, Res.GetString(Res.DataMerge_PrimaryKeyMismatch), missingSchemaAction);
                        }
                    }
                    else {
                        for (int i = 0; i < targetTable.PrimaryKey.Length; i++) {
                            if (String.Compare(targetTable.PrimaryKey[i].ColumnName, table.PrimaryKey[i].ColumnName, false, targetTable.Locale) != 0) {
                                dataSet.RaiseMergeFailed(table, 
                                    Res.GetString(Res.DataMerge_PrimaryKeyColumnsMismatch, targetTable.PrimaryKey[i].ColumnName, table.PrimaryKey[i].ColumnName), 
                                    missingSchemaAction
                            );
                            }
                        }
                    }
                }

                MergeExtendedProperties(table.ExtendedProperties, targetTable.ExtendedProperties);
            }

            return targetTable;
        }

        private void MergeTableData(DataTable src) {
            DataTable dest = MergeSchema(src);
            if (dest == null) return;

            dest.MergingData = true;
            try {
                MergeTable(src, dest);
            }
            finally {
                dest.MergingData = false;
            }
        }

        private void MergeConstraints(DataSet source) {
            for (int i = 0; i < source.Tables.Count; i ++) {
                MergeConstraints(source.Tables[i]);
            }
        }

        private void MergeConstraints(DataTable table) {
            // Merge constraints
            for (int i = 0; i < table.Constraints.Count; i++) {
                Constraint src = table.Constraints[i];
                Constraint dest = src.Clone(dataSet);

                if (dest == null) {
                    dataSet.RaiseMergeFailed(table, 
                        Res.GetString(Res.DataMerge_MissingConstraint, src.GetType().FullName, src.ConstraintName), 
                        missingSchemaAction
                    );
                }
                else {
                    Constraint cons = dest.Table.Constraints.FindConstraint(dest);
                    if (cons == null) {
                        if (MissingSchemaAction.Add == missingSchemaAction) {
                            try {
                                // try to keep the original name
                                dest.Table.Constraints.Add(dest);
                            }
                            catch (DuplicateNameException) {
                                // if fail, assume default name
                                dest.ConstraintName = "";
                                dest.Table.Constraints.Add(dest);
                            }
                        }
                        else if (MissingSchemaAction.Error == missingSchemaAction) {
                            dataSet.RaiseMergeFailed(table, 
                                Res.GetString(Res.DataMerge_MissingConstraint, src.GetType().FullName, src.ConstraintName), 
                                missingSchemaAction
                            );
                        }
                    }
                    else {
                        MergeExtendedProperties(src.ExtendedProperties, cons.ExtendedProperties);
                    }
                }
            }
        }

        private void MergeRelation(DataRelation relation) {
            Debug.Assert(MissingSchemaAction.Error == missingSchemaAction ||
                         MissingSchemaAction.Add == missingSchemaAction, 
                         "Unexpected value of MissingSchemaAction parameter : " + ((Enum) missingSchemaAction).ToString());
            DataRelation destRelation = null;

            // try to find given relation in this dataSet

            int iDest = dataSet.Relations.InternalIndexOf(relation.RelationName);

            if (iDest >= 0) {
                // check the columns and Relation properties..
                destRelation = dataSet.Relations[iDest];

                if (relation.ParentKey.Columns.Length != destRelation.ParentKey.Columns.Length) {
                    dataSet.RaiseMergeFailed(null, 
                        Res.GetString(Res.DataMerge_MissingDefinition, relation.RelationName), 
                        missingSchemaAction
                    );
                }
                for (int i = 0; i < relation.ParentKey.Columns.Length; i++) {
                    DataColumn dest = destRelation.ParentKey.Columns[i];
                    DataColumn src = relation.ParentKey.Columns[i];

                    if (0 != string.Compare(dest.ColumnName, src.ColumnName, false, dest.Table.Locale)) {
                        dataSet.RaiseMergeFailed(null, 
                            Res.GetString(Res.DataMerge_ReltionKeyColumnsMismatch, relation.RelationName), 
                            missingSchemaAction
                        );
                    }

                    dest = destRelation.ChildKey.Columns[i];
                    src = relation.ChildKey.Columns[i];

                    if (0 != string.Compare(dest.ColumnName, src.ColumnName, false, dest.Table.Locale)) {
                        dataSet.RaiseMergeFailed(null, 
                            Res.GetString(Res.DataMerge_ReltionKeyColumnsMismatch, relation.RelationName), 
                            missingSchemaAction
                        );
                    }
                }

            }
            else {
                if (MissingSchemaAction.Add == missingSchemaAction) {

                    // create identical realtion in the current dataset

                    DataTable parent = dataSet.Tables[relation.ParentTable.TableName];
                    DataTable child = dataSet.Tables[relation.ChildTable.TableName];
                    DataColumn[] parentColumns = new DataColumn[relation.ParentKey.Columns.Length];
                    DataColumn[] childColumns = new DataColumn[relation.ParentKey.Columns.Length];
                    for (int i = 0; i < relation.ParentKey.Columns.Length; i++) {
                        parentColumns[i] = parent.Columns[relation.ParentKey.Columns[i].ColumnName];
                        childColumns[i] = child.Columns[relation.ChildKey.Columns[i].ColumnName];
                    }
                    try {
                        destRelation = new DataRelation(relation.RelationName, parentColumns, childColumns, relation.createConstraints);
                        destRelation.Nested = relation.Nested;
                        dataSet.Relations.Add(destRelation);
                    }
                    catch (Exception e) {
                        dataSet.RaiseMergeFailed(null, e.Message, missingSchemaAction);
                    }
                }
                else {
                    Debug.Assert(MissingSchemaAction.Error == missingSchemaAction, "Unexpected value of MissingSchemaAction parameter : " + ((Enum) missingSchemaAction).ToString());
                    throw ExceptionBuilder.MergeMissingDefinition(relation.RelationName);
                }
            }

            MergeExtendedProperties(relation.ExtendedProperties, destRelation.ExtendedProperties);

            return;
        }

        private void MergeExtendedProperties(PropertyCollection src, PropertyCollection dst) {
            if (MissingSchemaAction.Ignore == missingSchemaAction) {
                return;
            }

            IDictionaryEnumerator srcDE = src.GetEnumerator();
            while (srcDE.MoveNext()) {
                if (!preserveChanges || dst[srcDE.Key] == null)
                    dst[srcDE.Key] = srcDE.Value;
            }
        }

        private DataKey GetSrcKey(DataTable src, DataTable dst) {
            if (src.primaryKey != null)
                return src.primaryKey.Key;

            DataKey key = null;
            if (dst.primaryKey != null) {
                DataColumn[] dstColumns = dst.primaryKey.Key.Columns;
                DataColumn[] srcColumns = new DataColumn[dstColumns.Length];
                for (int j = 0; j < dstColumns.Length; j++) {
                    srcColumns[j] = src.Columns[dstColumns[j].ColumnName];
                }
                key = new DataKey(srcColumns);
            }

            return key;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\mergefailedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="MergeFailedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\MergeFailedEventHandler.uex' path='docs/doc[@for="MergeFailedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void MergeFailedEventHandler(object sender, MergeFailedEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\missingmappingaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="MissingMappingAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\MissingMappingAction.uex' path='docs/doc[@for="MissingMappingAction"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Determines that action that will occur when a <see cref='System.Data.DataColumn'/> or <see cref='System.Data.DataTable'/> is
    ///       missing.
    ///    </para>
    /// </devdoc>
    public enum MissingMappingAction {
        /// <include file='doc\MissingMappingAction.uex' path='docs/doc[@for="MissingMappingAction.Passthrough"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A <see cref='System.Data.Common.DataColumnMapping'/> or a <see cref='System.Data.Common.DataTableMapping'/> is created, but not added to the
        ///       collection.
        ///    </para>
        /// </devdoc>
        Passthrough = 1,
        /// <include file='doc\MissingMappingAction.uex' path='docs/doc[@for="MissingMappingAction.Ignore"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A null is returned.
        ///    </para>
        /// </devdoc>
        Ignore      = 2,
        /// <include file='doc\MissingMappingAction.uex' path='docs/doc[@for="MissingMappingAction.Error"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A <see cref='System.SystemException'/> is thrown.
        ///    </para>
        /// </devdoc>
        Error       = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\missingschemaaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="MissingSchemaAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\MissingSchemaAction.uex' path='docs/doc[@for="MissingSchemaAction"]/*' />
    /// <devdoc>
    ///    <para>Specifies the action to take during a merge of tables whose schemas are
    ///       incompatible.</para>
    /// </devdoc>
    public enum MissingSchemaAction {

        /// <include file='doc\MissingSchemaAction.uex' path='docs/doc[@for="MissingSchemaAction.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the necessary columns to complete the schema.
        ///    </para>
        /// </devdoc>
        Add    = 1,

        /// <include file='doc\MissingSchemaAction.uex' path='docs/doc[@for="MissingSchemaAction.Ignore"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Ignores the extra columns.
        ///    </para>
        /// </devdoc>

        Ignore = 2,
        /// <include file='doc\MissingSchemaAction.uex' path='docs/doc[@for="MissingSchemaAction.Error"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An exception is thown.
        ///    </para>
        /// </devdoc>

        Error  = 3,

        /// <include file='doc\MissingSchemaAction.uex' path='docs/doc[@for="MissingSchemaAction.AddWithKey"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the necessary columns and primary key information to complete the schema.
        ///    </para>
        /// </devdoc>
        AddWithKey = 4
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\parameterdirection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ParameterDirection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\ParameterDirection.uex' path='docs/doc[@for="ParameterDirection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type of a parameter within a query command
    ///       relative to the <see cref='System.Data.DataSet'/>
    ///       .
    ///    </para>
    /// </devdoc>
    public enum ParameterDirection {
        /// <include file='doc\ParameterDirection.uex' path='docs/doc[@for="ParameterDirection.Input"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The parameter
        ///       is an input parameter.
        ///    </para>
        /// </devdoc>
        Input       = 1,
        /// <include file='doc\ParameterDirection.uex' path='docs/doc[@for="ParameterDirection.Output"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The parameter
        ///       is an output parameter.
        ///    </para>
        /// </devdoc>
        Output      = 2,
        /// <include file='doc\ParameterDirection.uex' path='docs/doc[@for="ParameterDirection.InputOutput"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The parameter is capable of both input and output.
        ///    </para>
        /// </devdoc>
        InputOutput = 3,
        /// <include file='doc\ParameterDirection.uex' path='docs/doc[@for="ParameterDirection.ReturnValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The parameter represents a return value.
        ///    </para>
        /// </devdoc>
        ReturnValue = 6
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\propertyattributes.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyAttributes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the attributes of a property.
    ///    </para>
    /// </devdoc>
    [
    Flags()
    ]
    public enum PropertyAttributes {
        /// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.NotSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The property is not supported by the provider.
        ///    </para>
        /// </devdoc>
        NotSupported = 0,    // Indicates that the property is not supported by the provider. 
        /// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.Required"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The user must specify a value for this property before the data source is
        ///       initialized.
        ///    </para>
        /// </devdoc>
        Required     = 1,    // Indicates that the user must specify a value for this property before the data source is initialized. 
        /// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.Optional"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The user does not need to specify a value for this property before the data
        ///       source is initialized.
        ///    </para>
        /// </devdoc>
        Optional     = 2,    // Indicates that the user does not need to specify a value for this property before the data source is initialized. 
        /// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.Read"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The user can read the property.
        ///    </para>
        /// </devdoc>
        Read         = 512,  // Indicates that the user can read the property. 
        /// <include file='doc\PropertyAttributes.uex' path='docs/doc[@for="PropertyAttributes.Write"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The user can write to the property.
        ///    </para>
        /// </devdoc>
        Write        = 1024, // Indicates that the user can set the property.
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\propertycollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;

    /// <include file='doc\PropertiesCollection.uex' path='docs/doc[@for="PropertyCollection"]/*' />
    /// <devdoc>
    /// <para>Represents a collection of properties that can be added to <see cref='System.Data.DataColumn'/>, 
    /// <see cref='System.Data.DataSet'/>, 
    ///    or <see cref='System.Data.DataTable'/>.</para>
    /// </devdoc>
    public class PropertyCollection : Hashtable {}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\primarykeytypeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrimaryKeyTypeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System.ComponentModel;
    using System.Globalization;
    using System.Data;
    
    internal class PrimaryKeyTypeConverter : ReferenceConverter {

        public PrimaryKeyTypeConverter() :
        base(typeof(DataColumn[])) {
        }

        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
           return false;
        }

        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(String)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
            	  return (new DataColumn[] {}).GetType().Name;
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\range.cs ===
//------------------------------------------------------------------------------
// <copyright file="Range.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\Range.uex' path='docs/doc[@for="Range"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal struct Range {

        private int min;
        private int max;
        private bool isNotNull; // zero bit pattern represents null

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Null"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly Range Null = new Range();

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Range"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Range(int min, int max) {
            if (min > max) {
                throw ExceptionBuilder.RangeArgument(min, max);
            }
            this.min = min;
            this.max = max;
            isNotNull = true;
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count {
            get {
                if (IsNull)
                    return 0;
                return max - min + 1;
            }
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Difference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Difference {
            get {
                CheckNull();
                return max - min;
            }
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.IsNull"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsNull {
            get {
                return !isNotNull;
            }
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Max"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Max {
            get {
                CheckNull();
                return max;
            }
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Min"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Min {
            get {
                CheckNull();
                return min;
            }
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Intersection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Range Intersection(Range range1, Range range2) {
            if (range1.IsNull || range2.IsNull)
                return Null;

            int min = Math.Max(range1.min, range2.min);
            int max = Math.Min(range1.max, range2.max);

            if (min < max)
                return new Range(min, max);

            return Range.Null;
        }

		/*
        public static bool operatorEquals(Range range1, Range range2) {
            return(range1.min == range2.min && range1.max == range2.max);
        }
		*/

        internal void CheckNull() {
            if (this.IsNull) {
                throw ExceptionBuilder.NullRange();
            }
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object o) {
            if (o.GetType() == typeof(Range)) {
                Range r = (Range) o;
                return(r.Min == Min && r.Max == Max);
            }
            return false;
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return min + ((max - min) << 16);
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Offset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Range Offset(int offset) {
            if (this.IsNull) {
                return Null;
            }
            return new Range(min + offset, max + offset);
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.Resize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Range Resize(int xoffset, int yoffset) {
            if (this.IsNull) {
                return Null;
            }
            return new Range(min + xoffset, max + yoffset);
        }

        /// <include file='doc\Range.uex' path='docs/doc[@for="Range.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {
            if (IsNull)
                return "Null";
            return "{Min = " + (min).ToString() + ", Max = " + (max).ToString() + "}";
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\recordmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="RecordManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Collections;
    using System.Diagnostics;

    [Serializable]
    internal class RecordManager {
        private DataTable table;

        private int lastFreeRecord;
        private int minimumCapacity = 50;
        private int recordCapacity = 0;
        private ArrayList freeRecordList = new ArrayList();

        DataRow[] rows;

        internal RecordManager(DataTable table) {
            if (table == null) {
                throw ExceptionBuilder.ArgumentNull("table");
            }
            this.table = table;
        }

        private void GrowRecordCapacity() {
            if (NewCapacity(recordCapacity) < NormalizedMinimumCapacity(minimumCapacity))
                RecordCapacity = NormalizedMinimumCapacity(minimumCapacity);
            else
                RecordCapacity = NewCapacity(recordCapacity);

            // set up internal map : record --> row
            DataRow[] newRows = table.NewRowArray(recordCapacity);
            if (rows != null) {
                Array.Copy(rows, 0, newRows, 0, Math.Min(lastFreeRecord, rows.Length));
            }
            rows = newRows;
        }

        internal int MinimumCapacity {
            get {
                return minimumCapacity;
            }
            set {
                if (minimumCapacity != value) {
                    if (value < 0) {
                        throw ExceptionBuilder.NegativeMinimumCapacity();
                    }
                    minimumCapacity = value;
                }
            }
        }

        internal int RecordCapacity {
            get {
                return recordCapacity;
            }
            set {
                if (recordCapacity != value) {
                    for (int i = 0; i < table.Columns.Count; i++) {
                        table.Columns[i].SetCapacity(value);
                    }
                    recordCapacity = value;
                }
            }
        }

        internal static int NewCapacity(int capacity) {
            return (capacity < 128) ? 128 : (capacity + capacity);
        }

        // Normalization: 64, 256, 1024, 2k, 3k, ....
        private int NormalizedMinimumCapacity(int capacity) {
            if (capacity < 1024 - 10) {
                if (capacity < 256 - 10) {
                    if ( capacity < 54 )
                        return 64;
                    return 256;
                }
                return 1024;
            }

            return (((capacity + 10) >> 10) + 1) << 10;
        }
        internal int NewRecordBase() {
            int record;
            if (freeRecordList.Count != 0) {
                record = (int)freeRecordList[freeRecordList.Count - 1];
                freeRecordList.RemoveAt(freeRecordList.Count - 1);
            }
            else {
                if (lastFreeRecord >= recordCapacity) {
                    GrowRecordCapacity();
                }
                record = lastFreeRecord;
                lastFreeRecord++;
            }
            Debug.Assert(record >=0 && record < recordCapacity, "NewRecord: Invalid record=" + record.ToString());
            return record;
        }

        internal void FreeRecord(int record) {
            Debug.Assert(record != -1, "Attempt to Free() <null> record");
            this[record] = null;
            // if freeing the last record, recycle it
            if (lastFreeRecord == record + 1) {
                lastFreeRecord--;
            }
            else {
                freeRecordList.Add(record);
            }
        }

        internal void Clear() {
            if (rows != null) {
                while (lastFreeRecord > 0) {
                    rows[--lastFreeRecord] = null;
                }
                if (freeRecordList.Count != 0) {
                    freeRecordList.Clear();
                }
            }
        }

        internal DataRow this[int record] {
            get {
                Debug.Assert(record >= 0 && record < rows.Length, "Invalid record number " + record.ToString());
                return rows[record];
            }
            set {
                Debug.Assert(record >= 0 && record < rows.Length, "Invalid record number " + record.ToString());
                rows[record] = value;
            }
        }

        internal object GetValue(int record, int columnIndex) {
            return GetValue(record, table.Columns[columnIndex]);
        }

        internal object GetValue(int record, DataColumn column) {
            return column[record];
        }

        internal void SetValue(int record, int columnIndex, object value) {
            SetValue(record, table.Columns[columnIndex], value);
        }

        internal void SetValue(int record, DataColumn column, object value) {
            column[record, false] = value;
        }

        internal object[] GetKeyValues(int record, DataKey key) {
            object[] keyValues = new object[key.Columns.Length];
            for (int i = 0; i < keyValues.Length; i++) {
                keyValues[i] = key.Columns[i][record];
            }
            return keyValues;
        }

        internal void SetKeyValues(int record, DataKey key, object[] keyValues) {
            for (int i = 0; i < keyValues.Length; i++) {
                key.Columns[i][record] = keyValues[i];
            }
        }

        // Increases AutoIncrementCurrent
        internal int ImportRecord(DataTable src, int record) {
            return CopyRecord(src, record, -1);
        }

        // No impact on AutoIncrementCurrent if over written
        internal int CopyRecord(DataTable src, int record, int copy) {
            if (record == -1)
                return copy;

            Debug.Assert(src != null, "Can not Merge record without a table");

            int newRecord = copy;
            if (copy == -1)
                newRecord = table.NewUninitializedRecord();

            for (int i = 0; i < table.Columns.Count; ++i) {
                DataColumn objColumn = table.Columns[i];
                int iSrc = src.Columns.IndexOf(objColumn.ColumnName);
                if (iSrc >= 0)
                    SetValue(newRecord, i, src.Columns[iSrc][record, false]);
                else {
                    if (copy == -1)
                        objColumn.Init(newRecord);
                }
            }
            return newRecord;
        }

#if DEBUG
        internal void DumpFreeList() {
            bool free = false;
            if (freeRecordList.Count != 0) {
                string list = "";
                for (int i = 0; i < freeRecordList.Count; i++) {
                    list += Convert.ToString(freeRecordList[i]) + ", ";
                }
                Debug.WriteLine("records in free list: " + list);
                free = true;
            }

            if (lastFreeRecord < recordCapacity) {
                Debug.WriteLine("also records from " + (lastFreeRecord) + " to " + (recordCapacity - 1));
                free = true;
            }

            if (!free) {
                Debug.WriteLine("no free records");
            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\relationshipconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="RelationshipConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\RelationshipConverter.uex' path='docs/doc[@for="RelationshipConverter"]/*' />
    /// <internalonly/>
    sealed internal class RelationshipConverter : ExpandableObjectConverter {

        /// <include file='doc\RelationshipConverter.uex' path='docs/doc[@for="RelationshipConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\RelationshipConverter.uex' path='docs/doc[@for="RelationshipConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            ConstructorInfo ctor = null;
            if (destinationType == typeof(InstanceDescriptor) && value is DataRelation) {
                DataRelation rel = (DataRelation) value;
 
                ctor = typeof(DataRelation).GetConstructor(new Type[] { typeof(string), typeof(string), typeof(string), 
                    typeof(string[]), typeof(string[]), typeof(bool) } );
                    
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] { rel.RelationName, rel.ParentKey.Table.TableName, rel.ChildKey.Table.TableName,
                    rel.ParentColumnNames, rel.ChildColumnNames, rel.Nested });
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\relatedview.cs ===
//------------------------------------------------------------------------------
// <copyright file="RelatedView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;    

    /// <include file='doc\RelatedView.uex' path='docs/doc[@for="RelatedView"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal class RelatedView : DataView, IFilter {
        internal DataKey key;
        internal object[] values;

        /// <include file='doc\RelatedView.uex' path='docs/doc[@for="RelatedView.RelatedView"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public RelatedView(DataColumn[] columns, object[] values) : base(columns[0].Table) {
            if (values == null) {
                throw ExceptionBuilder.ArgumentNull("values");
            }
            this.Columns = columns;
            this.Values = values;
            UpdateIndex();
            Reset();
        }

        /// <include file='doc\RelatedView.uex' path='docs/doc[@for="RelatedView.Invoke"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Invoke(DataRow row, DataRowVersion version) {
            object[] keyValues = row.GetKeyValues(key, version);
#if false
            for (int i = 0; i < keyValues.Length; i++) {
                Debug.WriteLine("keyvalues[" + (i).ToString() + "] = " + Convert.ToString(keyValues[i]));
            }
            for (int i = 0; i < values.Length; i++) {
                Debug.WriteLine("values[" + (i).ToString() + "] = " + Convert.ToString(values[i]));
            }
#endif
            bool allow = true;
            if (keyValues.Length != values.Length) {
                allow = false;
            }
            else {
                for (int i = 0; i < keyValues.Length; i++) {
                    if (!keyValues[i].Equals(values[i])) {
                        allow = false;
                        break;
                    }
                }
            }

            IFilter baseFilter = base.GetFilter();
            if (baseFilter != null)
                allow &= baseFilter.Invoke(row, version);

            return allow;
        }

        private DataColumn[] Columns {
            get {
                return key.Columns;
            }
            set {
                this.key = new DataKey(value);
                Debug.Assert (this.Table == key.Table, "Key.Table Must be equal to Current Table");
                Reset();
            }
        }

        private object[] Values {
            get {
                return values;
            }
            set {
                this.values = value;
                Reset();
            }
        }

        /// <include file='doc\RelatedView.uex' path='docs/doc[@for="RelatedView.GetFilter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal override IFilter GetFilter() {
            return this;
        }

        // move to OnModeChanged
        /// <include file='doc\RelatedView.uex' path='docs/doc[@for="RelatedView.AddNew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override DataRowView AddNew() {
            // TODO: Add your own implementation.
            DataRowView addNewRowView = base.AddNew();
            addNewRow.SetKeyValues(key, values);
            return addNewRowView;
        }

        /// <include file='doc\RelatedView.uex' path='docs/doc[@for="RelatedView.SetIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal override void SetIndex(string newSort, DataViewRowState newRowStates, DataFilter newRowFilter) {
            base.SetIndex(newSort, newRowStates, newRowFilter);
            Reset();
        }

        /// <include file='doc\RelatedView.uex' path='docs/doc[@for="RelatedView.UpdateIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void UpdateIndex(bool force) {
            if (key != null)
                base.UpdateIndex(force);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\schematype.cs ===
//------------------------------------------------------------------------------
// <copyright file="SchemaType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\SchemaType.uex' path='docs/doc[@for="SchemaType"]/*' />
    /// <devdoc>
    /// </devdoc>
    public enum SchemaType {
        /// <include file='doc\SchemaType.uex' path='docs/doc[@for="SchemaType.Source"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Source = 1,
        /// <include file='doc\SchemaType.uex' path='docs/doc[@for="SchemaType.Mapped"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Mapped = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\select.cs ===
//------------------------------------------------------------------------------
// <copyright file="Select.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Collections;

    internal sealed class Select {
        private DataTable table;
        private int[] indexDesc;
        private DataViewRowState recordStates;
        private DataFilter rowFilter;
        private ExpressionNode expression;

        private Index index;

        private int[] records;
        private int recordCount;

        private ExpressionNode linearExpression;
        private bool candidatesForBinarySearch;

        private class ColumnInfo {
            public bool       flag = false;               // Misc. Use
            public bool       equalsOperator = false;     // True when the associated expr has = Operator defined
            public BinaryNode expr = null;                // Binary Search capable expression associated
        }
        ColumnInfo[] candidateColumns;
        int nCandidates;
        int matchedCandidates;

        public Select(DataTable table, string filterExpression, string sort, DataViewRowState recordStates) {
            this.table = table;
            this.indexDesc = table.ParseSortString(sort);
            if (filterExpression != null && filterExpression.Length > 0) {
                this.rowFilter = new DataFilter(filterExpression, this.table);
                this.expression = this.rowFilter.expr;
            }
            this.recordStates = recordStates;
        }

        private bool IsSupportedOperator(int op) {
            return ((op >= Operators.EqualTo && op <= Operators.LessOrEqual) || op == Operators.Is || op == Operators.IsNot);
        }

        // haroona : Gathers all linear expressions in to this.linearExpression and all binary expressions in to their respective candidate columns expressions
        private void AnalyzeExpression(BinaryNode expr) {
            if (this.linearExpression == this.expression)
                return;

            if (expr.op == Operators.Or) {
                this.linearExpression = this.expression;
                return;
            }
            else
            if (expr.op == Operators.And) {
                bool isLeft=false, isRight=false;
                if (expr.left is BinaryNode) {
                    AnalyzeExpression((BinaryNode)expr.left);
                    if (this.linearExpression == this.expression)
                        return;
                    isLeft = true;
                }
                else
                if (expr.left is UnaryNode && ((UnaryNode)(expr.left)).op == Operators.Noop && ((UnaryNode)(expr.left)).right is BinaryNode) {
                    AnalyzeExpression((BinaryNode)((UnaryNode)(expr.left)).right);
                    if (this.linearExpression == this.expression)
                        return;
                    isLeft = true;
                }

                if (expr.right is BinaryNode) {
                    AnalyzeExpression((BinaryNode)expr.right);
                    if (this.linearExpression == this.expression)
                        return;
                    isRight = true;
                }
                else
                if (expr.right is UnaryNode && ((UnaryNode)(expr.right)).op == Operators.Noop && ((UnaryNode)(expr.right)).right is BinaryNode) {
                    AnalyzeExpression((BinaryNode)((UnaryNode)(expr.right)).right);
                    if (this.linearExpression == this.expression)
                        return;
                    isRight = true;
                }

                if (isLeft && isRight)
                    return;

                ExpressionNode e = isLeft ? expr.right : expr.left;
                this.linearExpression = (this.linearExpression == null ? e : new BinaryNode(Operators.And, e, this.linearExpression));
                return;
            }
            else
            if (IsSupportedOperator(expr.op)) {
                if (expr.left is NameNode && expr.right is ConstNode) {
                    ColumnInfo canColumn = (ColumnInfo)candidateColumns[((NameNode)(expr.left)).column.Ordinal];
                    canColumn.expr = (canColumn.expr == null ? expr : new BinaryNode(Operators.And, expr, canColumn.expr));
                    if (expr.op == Operators.EqualTo) {
                        canColumn.equalsOperator = true;
                    }
                    candidatesForBinarySearch = true;
                    return;
                }
                else
                if (expr.right is NameNode && expr.left is ConstNode) {
                    ExpressionNode temp = expr.left;
                    expr.left = expr.right;
                    expr.right = temp;
                    switch(expr.op) {
                        case Operators.GreaterThen:     expr.op = Operators.LessThen; break;
                        case Operators.LessThen:        expr.op = Operators.GreaterThen; break;
                        case Operators.GreaterOrEqual:  expr.op = Operators.LessOrEqual; break;
                        case Operators.LessOrEqual:     expr.op = Operators.GreaterOrEqual; break;
                        default : break;
                    }
                    ColumnInfo canColumn = (ColumnInfo)candidateColumns[((NameNode)(expr.left)).column.Ordinal];
                    canColumn.expr = (canColumn.expr == null ? expr : new BinaryNode(Operators.And, expr, canColumn.expr));
                    if (expr.op == Operators.EqualTo) {
                        canColumn.equalsOperator = true;
                    }
                    candidatesForBinarySearch = true;
                    return;
                }
            }

            this.linearExpression = (this.linearExpression == null ? expr : new BinaryNode(Operators.And, expr, this.linearExpression));
            return;
        }

        private bool CompareSortIndexDesc(int[] id) {
            if (id.Length < indexDesc.Length)
                return false;
            int j=0;
            int lenId = id.Length;
            int lenIndexDesc = indexDesc.Length;
            for (int i = 0; i < lenId && j < lenIndexDesc; i++) {
                if (id[i] == indexDesc[j]) {
                    j++;
                }
                else {
                    ColumnInfo canColumn = candidateColumns[DataKey.ColumnOrder(id[i])];
                    if (!(canColumn != null && canColumn.equalsOperator))
                        return false;
                }
            }
            return j == lenIndexDesc;
        }

        private bool FindSortIndex() {
            index = null;
            int count = this.table.indexes.Count;
            int rowsCount = this.table.Rows.Count;
            for (int i = 0; i < count; i++) {
                Index ndx = (Index)table.indexes[i];
                if (ndx.RecordStates != recordStates)
                    continue;
                if (ndx.RecordCount != rowsCount)
                    continue;
                if (CompareSortIndexDesc(ndx.IndexDesc)) {
                    index = ndx;
                    return true;
                }
            }
            return false;
        }

        // Returns no. of columns that are matched
        private int CompareClosestCandidateIndexDesc(int[] id) {
            int count = (id.Length < nCandidates ? id.Length : nCandidates);
            int i = 0;
            for (; i < count; i++) {
                ColumnInfo canColumn = candidateColumns[DataKey.ColumnOrder(id[i])];
                if (canColumn == null || canColumn.expr == null) {
                    break;
                }
                else
                if (!canColumn.equalsOperator) {
                    return i+1;
                }
            }
            return i;
        }

        // Returns whether the found index (if any) is a sort index as well
        private bool FindClosestCandidateIndex() {
            index = null;
            matchedCandidates = 0;
            bool sortPriority = true;
            int count = this.table.indexes.Count;
            int rowsCount = this.table.Rows.Count;
            for (int i = 0; i < count; i++) {
                Index ndx = (Index)table.indexes[i];
                if (ndx.RecordStates != recordStates)
                    continue;
                if (ndx.RecordCount != rowsCount)
                    continue;
                int match = CompareClosestCandidateIndexDesc(ndx.IndexDesc);
                if (match > matchedCandidates || (match == matchedCandidates && !sortPriority)) {
                    matchedCandidates = match;
                    index = ndx;
                    sortPriority = CompareSortIndexDesc(ndx.IndexDesc);
                    if (matchedCandidates == nCandidates && sortPriority) {
                        return true;
                    }
                }
            }
            return (index != null ? sortPriority : false);
        }

        // Initialize candidate columns to new columnInfo and leave all non candidate columns to null
        private void InitCandidateColumns() {
            candidateColumns = new ColumnInfo[this.table.Columns.Count];
            if (this.rowFilter == null)
                return;
            DataColumn[] depColumns = rowFilter.GetDependency();
            nCandidates = depColumns.Length;
            for (int i=0; i<nCandidates; i++) {
                candidateColumns[depColumns[i].Ordinal] = new ColumnInfo();
            }
        }

        // Based on the required sorting and candidate columns settings, create a new index; Should be called only when there is no existing index to be reused
        private void CreateIndex() {
            if (index == null) {
                if (nCandidates == 0) {
                    index = new Index(table, indexDesc, recordStates, null);
                }
                else {
                    int i;
                    int lenCanColumns = candidateColumns.Length;
                    int lenIndexDesc = indexDesc.Length;
                    bool equalsOperator = true;
                    for (i=0; i<lenCanColumns; i++) {
                        if (candidateColumns[i] != null) {
                            if (!candidateColumns[i].equalsOperator) {
                                equalsOperator = false;
                                break;
                            }
                        }
                    }

                    for (i=0; i < lenIndexDesc; i++) {
                        if (candidateColumns[DataKey.ColumnOrder(indexDesc[i])] == null) {
                            break;
                        }
                    }
                    int indexNotInCandidates = indexDesc.Length - i;
                    int candidatesNotInIndex = nCandidates - i;
                    int[] ndxDesc = new int[nCandidates + indexNotInCandidates];

                    if (equalsOperator) {
                        for (i=0; i<lenIndexDesc; i++) {
                            ndxDesc[candidatesNotInIndex+i] = indexDesc[i];
                            ColumnInfo canColumn = candidateColumns[DataKey.ColumnOrder(indexDesc[i])];
                            if (canColumn != null)
                                canColumn.flag = true;
                        }
                        int j=0;
                        for (i=0; i<lenCanColumns; i++) {
                            if (candidateColumns[i] != null) {
                                if(!candidateColumns[i].flag) {
                                    ndxDesc[j++] = i;
                                }
                                else {
                                    candidateColumns[i].flag = false;
                                }
                            }
                        }
                        Debug.Assert(j == candidatesNotInIndex, "Whole ndxDesc should be filled!");
                        index = new Index(table, ndxDesc, recordStates, null);
                        matchedCandidates = nCandidates;
                     }
                     else {
                        for (i=0; i<lenIndexDesc; i++) {
                            ndxDesc[i] = indexDesc[i];
                            ColumnInfo canColumn = candidateColumns[DataKey.ColumnOrder(indexDesc[i])];
                            if (canColumn != null)
                                canColumn.flag = true;
                        }
                        int j=i;
                        for (i=0; i<lenCanColumns; i++) {
                            if (candidateColumns[i] != null) {
                                if(!candidateColumns[i].flag) {
                                    ndxDesc[j++] = i;
                                }
                                else {
                                    candidateColumns[i].flag = false;
                                }
                            }
                        }
                        Debug.Assert(j == nCandidates+indexNotInCandidates, "Whole ndxDesc should be filled!");
                        index = new Index(table, ndxDesc, recordStates, null);
                        matchedCandidates = 0;
                        if (this.linearExpression != this.expression) {
                            int[] id = index.IndexDesc;
                            while (matchedCandidates < j) { // haroona : j = index.IndexDesc.Length
                                ColumnInfo canColumn = candidateColumns[DataKey.ColumnOrder(id[matchedCandidates])];
                                if (canColumn == null || canColumn.expr == null)
                                    break;
                                matchedCandidates++;
                                if (!canColumn.equalsOperator)
                                    break;
                            }
                        }
                    }
                }
            }
        }

        // Based on the current index and candidate columns settings, build the linear expression; Should be called only when there is atleast something for Binary Searching
        private void BuildLinearExpression() {
            int i;
            int[] id = index.IndexDesc;
            int lenId = id.Length;
            Debug.Assert(matchedCandidates > 0 && matchedCandidates <= lenId, "BuildLinearExpression : Invalid Index");
            for (i=0; i<matchedCandidates; i++) {
                ColumnInfo canColumn = candidateColumns[DataKey.ColumnOrder(id[i])];
                Debug.Assert(canColumn != null && canColumn.expr != null, "BuildLinearExpression : Must be a matched candidate");
                canColumn.flag = true;
            }
            Debug.Assert(matchedCandidates==1 || candidateColumns[matchedCandidates-1].equalsOperator, "BuildLinearExpression : Invalid matched candidates");
            int lenCanColumns = candidateColumns.Length;
            for (i=0; i<lenCanColumns; i++) {
                if (candidateColumns[i] != null) {
                    if (!candidateColumns[i].flag) {
                        if (candidateColumns[i].expr != null) {
                            this.linearExpression = (this.linearExpression == null ? candidateColumns[i].expr : new BinaryNode(Operators.And, candidateColumns[i].expr, this.linearExpression));
                        }
                    }
                    else {
                        candidateColumns[i].flag = false;
                    }
                }
            }
            Debug.Assert(this.linearExpression != null, "BuildLinearExpression : How come there is nothing to search linearly");
        }

        public DataRow[] SelectRows() {
            bool needSorting = true;

            InitCandidateColumns();

            if (this.expression is BinaryNode) {
                AnalyzeExpression((BinaryNode)this.expression);
                if (!candidatesForBinarySearch) {
                    this.linearExpression = this.expression;
                }
                if (this.linearExpression == this.expression) {
                    for (int i=0; i<candidateColumns.Length; i++) {
                        if (candidateColumns[i] != null) {
                            candidateColumns[i].equalsOperator = false;
                            candidateColumns[i].expr = null;
                        }
                    }
                }
                else {
                    needSorting = !FindClosestCandidateIndex();
                }
            }
            else {
                this.linearExpression = this.expression;
            }

            if (index == null && (indexDesc.Length > 0 || this.linearExpression == this.expression)) {
                needSorting = !FindSortIndex();
            }

            if (index == null) {
                CreateIndex();
                needSorting = false;
            }

            if (index.RecordCount == 0)
                return table.NewRowArray(0);

            Range range;
            if (matchedCandidates == 0) { // haroona : Either dont have rowFilter or only linear search expression
                range = new Range(0, index.RecordCount-1);
                Debug.Assert(!needSorting, "What are we doing here if no real reuse of this index ?");
                this.linearExpression = this.expression;
                return GetLinearFilteredRows(range);
            }
            else {
                range = GetBinaryFilteredRecords();
                if (range.Count == 0)
                    return table.NewRowArray(0);
                if (matchedCandidates < nCandidates) {
                    BuildLinearExpression();
                }
                if (!needSorting) {
                    return GetLinearFilteredRows(range);
                }
                else {
                    this.records = GetLinearFilteredRecords(range);
                    this.recordCount = this.records.Length;
                    if (this.recordCount == 0)
                        return table.NewRowArray(0);
                    Sort(0, this.recordCount-1);
                    return GetRows();
                }
            }
        }

        public DataRow[] GetRows() {
            DataRow[] newRows = table.NewRowArray(recordCount);
            int rowsCount = newRows.Length;
            for (int i = 0; i < rowsCount; i++) {
                newRows[i] = table.recordManager[records[i]];
            }
            return newRows;
        }

        private bool AcceptRecord(int record) {
            DataRow row = table.recordManager[record];

            if (row == null)
                return true;

            // UNDONE: perf switch to (row, version) internaly

            DataRowVersion version = DataRowVersion.Default;
            if (row.oldRecord == record) {
                version = DataRowVersion.Original;
            }
            else if (row.newRecord == record) {
                version = DataRowVersion.Current;
            }
            else if (row.tempRecord == record) {
                version = DataRowVersion.Proposed;
            }

            object val = this.linearExpression.Eval(row, version);
            bool result;
            try {
                result = DataExpression.ToBoolean(val);
            }
            catch (Exception) {
                throw ExprException.FilterConvertion(this.rowFilter.Expression);
            }
            return result;
        }

        private int Eval(BinaryNode expr, DataRow row, DataRowVersion version) {
            if (expr.op == Operators.And) {
                int lResult = Eval((BinaryNode)expr.left,row,version);
                if (lResult != 0)
                    return lResult;
                int rResult = Eval((BinaryNode)expr.right,row,version);
                if (rResult != 0)
                    return rResult;
                return 0;
            }

            long c = 0;
            object vLeft  = expr.left.Eval(row, version);
            if (expr.op != Operators.Is && expr.op != Operators.IsNot) {
                object vRight = expr.right.Eval(row, version);
                bool isLConst = (expr.left is ConstNode);
                bool isRConst = (expr.right is ConstNode);

                if (vLeft == DBNull.Value)
                    return -1;
                if (vRight == DBNull.Value)
                    return 1;

                if (vLeft.GetType() == typeof(char)) {
                    vRight = Convert.ToChar(vRight);
                }

                Type result = expr.ResultType(vLeft.GetType(), vRight.GetType(), isLConst, isRConst, expr.op);
                if (result == null)
                    expr.SetTypeMismatchError(expr.op, vLeft.GetType(), vRight.GetType());

                c = expr.Compare(vLeft, vRight, result, expr.op);
            }
            switch(expr.op) {
                case Operators.EqualTo:         c = (c == 0 ? 0 : c < 0  ? -1 :  1); break;
                case Operators.GreaterThen:     c = (c > 0  ? 0 : -1); break;
                case Operators.LessThen:        c = (c < 0  ? 0 : 1); break;
                case Operators.GreaterOrEqual:  c = (c >= 0 ? 0 : -1); break;
                case Operators.LessOrEqual:     c = (c <= 0 ? 0 : 1); break;
                case Operators.Is:              c = (vLeft == DBNull.Value ? 0 : -1); break;
                case Operators.IsNot:           c = (vLeft != DBNull.Value ? 0 : 1);  break;
                default:                        Debug.Assert(true, "Unsupported Binary Search Operator!"); break;
            }
            return (int)c;
        }

        private int Evaluate(int record) {
            DataRow row = table.recordManager[record];

            if (row == null)
                return 0;

            // UNDONE: perf switch to (row, version) internaly

            DataRowVersion version = DataRowVersion.Default;
            if (row.oldRecord == record) {
                version = DataRowVersion.Original;
            }
            else if (row.newRecord == record) {
                version = DataRowVersion.Current;
            }
            else if (row.tempRecord == record) {
                version = DataRowVersion.Proposed;
            }

            int[] id = index.IndexDesc;
            for (int i=0; i < matchedCandidates; i++) {
                Debug.Assert(candidateColumns[DataKey.ColumnOrder(id[i])] != null, "How come this is not a candidate column");
                Debug.Assert(candidateColumns[DataKey.ColumnOrder(id[i])].expr != null, "How come there is no associated expression");
                int c = Eval(candidateColumns[DataKey.ColumnOrder(id[i])].expr, row, version);
                if (c != 0)
                    return DataKey.SortDecending(id[i]) ? -c : c;
            }
            return 0;
        }

        private int FindFirstMatchingRecord() {
            int rec = -1;
            int lo = 0;
            int hi = index.RecordCount - 1;
            while (lo <= hi) {
                int i = lo + hi >> 1;
                int c = Evaluate(index.GetRecord(i));
                if (c == 0) { rec = i; }
                if (c < 0) lo = i + 1;
                else hi = i - 1;
            }
            return rec;
        }

        private int FindLastMatchingRecord() {
            int rec = -1;
            int lo = 0;
            int hi = index.RecordCount - 1;
            while (lo <= hi) {
                int i = lo + hi >> 1;
                int c = Evaluate(index.GetRecord(i));
                if (c == 0) { rec = i; }
                if (c <= 0) lo = i + 1;
                else hi = i - 1;
            }
            return rec;
        }

        private Range GetBinaryFilteredRecords() {
            if (matchedCandidates == 0) {
                return new Range(0, index.RecordCount-1);
            }
            Debug.Assert(matchedCandidates <= index.IndexDesc.Length, "GetBinaryFilteredRecords : Invalid Index");
            int lo = FindFirstMatchingRecord();
            if (lo == -1)
                return Range.Null;
            int hi = FindLastMatchingRecord();
            Debug.Assert (lo <= hi, "GetBinaryFilteredRecords : Invalid Search Results");
            return new Range(lo, hi);
        }

        private int[] GetLinearFilteredRecords(Range range) {
            int[] resultRecords;
            if (this.linearExpression == null) {
                int count = range.Count;
                resultRecords = new int[count];
                for (int i=0; i<count; i++) {
                    resultRecords[i] = index.GetRecord(i+range.Min);
                }
                return resultRecords;
            }
            ArrayList matchingRecords = new ArrayList();
            for (int i=range.Min; i<=range.Max; i++) {
                int record = index.GetRecord(i);
                if (AcceptRecord(record))
                    matchingRecords.Add(record);
            }
            resultRecords = new int[matchingRecords.Count];
            matchingRecords.CopyTo((Array)resultRecords);
            return resultRecords;
        }

        private DataRow[] GetLinearFilteredRows(Range range) {
            DataRow[] resultRows;
            if (this.linearExpression == null) {
                int count = range.Count;
                resultRows = table.NewRowArray(count);
                for (int i=0; i<count; i++) {
                    resultRows[i] = index.GetRow(i+range.Min);
                }
                return resultRows;
            }

            ArrayList matchingRows = new ArrayList();
            for (int i=range.Min; i<=range.Max; i++) {
                int record = index.GetRecord(i);
                if (AcceptRecord(record))
                    matchingRows.Add(index.GetRow(i));
            }
            resultRows = table.NewRowArray(matchingRows.Count);
            matchingRows.CopyTo((Array)resultRows);
            return resultRows;
        }

        private int CompareRecords(int record1, int record2) {
            int lenIndexDesc = indexDesc.Length;
            for (int i = 0; i < lenIndexDesc; i++) {
                Int32 d = indexDesc[i];
                int c = table.Columns[DataKey.ColumnOrder(d)].Compare(record1, record2);
                if (c != 0) {
                    if (DataKey.SortDecending(d)) c = -c;
                    return c;
                }
            }

            int id1 = table.recordManager[record1] == null? 0: table.recordManager[record1].rowID;
            int id2 = table.recordManager[record2] == null? 0: table.recordManager[record2].rowID;
            int diff = id1 - id2;

            // if they're two records in the same row, we need to be able to distinguish them.
            if (diff == 0 && record1 != record2 && 
                table.recordManager[record1] != null && table.recordManager[record2] != null) {
                id1 = (int)table.recordManager[record1].GetRecordState(record1);
                id2 = (int)table.recordManager[record2].GetRecordState(record2);
                diff = id1 - id2;
            }

            return diff;
        }

        private void Sort(int left, int right) {
            int i, j;
            int record;
            do {
                i = left;
                j = right;
                record = records[i + j >> 1];
                do {
                    while (CompareRecords(records[i], record) < 0) i++;
                    while (CompareRecords(records[j], record) > 0) j--;
                    if (i <= j) {
                        int r = records[i];
                        records[i] = records[j];
                        records[j] = r;
                        i++;
                        j--;
                    }
                } while (i <= j);
                if (left < j) Sort(left, j);
                left = i;
            } while (i < right);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\selection.cs ===
//------------------------------------------------------------------------------
// <copyright file="Selection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Collections;

    [Serializable]
    internal class Index {
        private DataTable table;
        private int[] indexDesc;
        private DataViewRowState recordStates;
        private WeakReference rowFilter;
        private int[] records;
        private int recordCount;
        private int refCount;
        private ListChangedEventHandler onListChanged;

        private bool suspendEvents;

        private static object[] zeroObjects = new object[0];

        public Index(DataTable table, Int32[] indexDesc, DataViewRowState recordStates, IFilter rowFilter) {
            Debug.Assert(indexDesc != null);
            if ((recordStates &
                 (~(DataViewRowState.CurrentRows | DataViewRowState.OriginalRows))) != 0) {
                throw ExceptionBuilder.RecordStateRange();
            }
            this.table = table;
            this.indexDesc = indexDesc;
            this.recordStates = recordStates;
            this.rowFilter = new WeakReference(rowFilter);
            InitRecords();

            AddRef(); // haroona : To keep this index in memory. Will be thrown away by DataTable.LiveIndexes property as soon as it is gonna become dirty
        }

        public bool Equal(Int32[] indexDesc, DataViewRowState recordStates, IFilter rowFilter) {
            IFilter filter = RowFilter;
            if (
                this.indexDesc.Length != indexDesc.Length ||
                this.recordStates     != recordStates     ||
                filter                != rowFilter
            ) {
                return false;
            }

            for (int loop = 0; loop < this.indexDesc.Length; loop++) {
                if (this.indexDesc[loop] != indexDesc[loop]) {
                    return false;
                }
            }

            return true;
        }

        public int[] IndexDesc {
            get { return indexDesc; }
        }

        public DataViewRowState RecordStates {
            get { return recordStates; }
        }

        public IFilter RowFilter {
            get { return (IFilter)rowFilter.Target; }
        }

        public int GetRecord(int recordIndex) {
            Debug.Assert (recordIndex >= 0 && recordIndex < recordCount, "recordIndex out of range");
            return records[recordIndex];
        }

        public int[] Records {
            get {
                int[] recs = new int[recordCount];
                records.CopyTo(recs,0);
                return recs;
            }
        }

        public int RecordCount {
            get {
                return recordCount;
            }
        }

        private bool AcceptRecord(int record) {
            IFilter filter = RowFilter;
            if (filter == null)
                return true;

            DataRow row = table.recordManager[record];

            if (row == null)
                return true;

            // UNDONE: perf switch to (row, version) internaly

            DataRowVersion version = DataRowVersion.Default;
            if (row.oldRecord == record) {
                version = DataRowVersion.Original;
            }
            else if (row.newRecord == record) {
                version = DataRowVersion.Current;
            }
            else if (row.tempRecord == record) {
                version = DataRowVersion.Proposed;
            }

            return filter.Invoke(row, version);
        }

        public event ListChangedEventHandler ListChanged {
            add {
                onListChanged += value;
		table.CleanUpDVListeners();
            }
            remove {
                onListChanged -= value;
            }
        }

        public int RefCount {
            get {
                return refCount;
            }
        }

        public void AddRef() {
            if (refCount == 0) {
                table.indexes.Add(this);
            }
            refCount++;
        }

        public void RemoveRef() {
            lock (table.indexes) {
                Debug.Assert(0 < refCount, "Index Ref counting is broken.");
                refCount--;
                if (refCount == 0) {
                    Debug.Assert(0 <= table.indexes.IndexOf(this), "Index Ref counting is broken.");
                    table.indexes.Remove(this);
                }
            }
        }

        private void ApplyChangeAction(int record, int action) {
            if (action != 0) {
                if (action > 0) {
                    if (AcceptRecord(record)) InsertRecord(record, GetIndex(record) & 0x7FFFFFFF);
                }
                else {
                    DeleteRecord(GetIndex(record));
                }
            }
        }

        public bool CheckUnique() {
            for (int i = 1; i < recordCount; i++) {
                if (EqualKeys(records[i - 1], records[i])) {
                    if ((object)records[i] != null)
                        return false;
                }
            }
            return true;
        }

        private int CompareRecords(int record1, int record2) {
            for (int i = 0; i < indexDesc.Length; i++) {
                Int32 d = indexDesc[i];
                int c = table.Columns[DataKey.ColumnOrder(d)].Compare(record1, record2);
                if (c != 0) {
                    if (DataKey.SortDecending(d)) c = -c;
                    return c;
                }
            }

            int id1 = table.recordManager[record1] == null? 0: table.recordManager[record1].rowID;
            int id2 = table.recordManager[record2] == null? 0: table.recordManager[record2].rowID;
            int diff = id1 - id2;

            // if they're two records in the same row, we need to be able to distinguish them.
            if (diff == 0 && record1 != record2 && 
                table.recordManager[record1] != null && table.recordManager[record2] != null) {
                id1 = (int)table.recordManager[record1].GetRecordState(record1);
                id2 = (int)table.recordManager[record2].GetRecordState(record2);
                diff = id1 - id2;
            }

            return diff;
        }

        private int CompareRecordToKey(int record1, object[] vals) {
            for (int i = 0; i < indexDesc.Length; i++) {
                Int32 d = indexDesc[i];
                int c = table.Columns[DataKey.ColumnOrder(d)].CompareToValue(record1, vals[i]);
                if (c != 0) {
                    if (DataKey.SortDecending(d)) c = -c;
                    return c;
                }
            }
            return 0;
        }

        private int CompareRecordToKey(int record1, object val) {
            Debug.Assert(indexDesc.Length == 1, "Invalid ussage: CompareRecordToKey");
            Int32 d = indexDesc[0];
            int c = table.Columns[DataKey.ColumnOrder(d)].CompareToValue(record1, val);
            if (c != 0) {
                if (DataKey.SortDecending(d)) c = -c;
                return c;
            }
            return 0;
        }

        private void DeleteRecord(int recordIndex) {
            if (recordIndex >= 0) {
                recordCount--;
                System.Array.Copy(records, recordIndex + 1, records, recordIndex, recordCount - recordIndex);
                OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, recordIndex));
            }
        }

        public bool EqualKeys(int record1, int record2) {
            for (int i = 0; i < indexDesc.Length; i++) {
                int col = DataKey.ColumnOrder(indexDesc[i]);
                if (table.Columns[col].Compare(record1, record2) != 0) {
                    return false;
                }
            }
            return true;
        }

        // What it actually does is find the index in the records[] that
        // this record inhabits, and if it doesn't, suggests what index it would
        // inhabit while setting the high bit.
        public int GetIndex(int record) {
            int lo = 0;
            int hi = recordCount - 1;
            while (lo <= hi) {
                int i = lo + hi >> 1;
                int c = CompareRecords(records[i], record);
                if (c == 0) return i;
                if (c < 0) lo = i + 1;
                else hi = i - 1;
            }
            return lo | unchecked((int)0x80000000);
        }

        public object[] GetUniqueKeyValues() {
            if (indexDesc == null || indexDesc.Length == 0) {
                return zeroObjects;
            }

            ArrayList list = new ArrayList();
            for (int i = 0; i < recordCount; i++) {
                if (i > 0 && EqualKeys(records[i], records[i-1]))
                    continue;
                object[] element = new object[indexDesc.Length];
                for (int j = 0; j < indexDesc.Length; j++) {
                    element[j] = table.recordManager.GetValue(records[i], indexDesc[j]);
                }
                list.Add(element);
            }
            object[] temp = new object[list.Count];
            list.CopyTo(temp, 0);
            return temp;
        }

        public int FindRecord(int record) {
            int lo = 0;
            int hi = recordCount - 1;
            while (lo <= hi) {
                int i = lo + hi >> 1;
                int c = CompareRecords(records[i], record);
//                if (c == 0) return i; // haroona : By commenting this line, we get FIND_FIRST search. Uncommenting this and returning -1 would be FIND_ANY
                if (c < 0) lo = i + 1;
                else hi = i - 1;
            }
            return (lo < recordCount ? (EqualKeys(records[lo], record) ? lo : -1) : -1);
        }

        public int FindRecordByKey(object key) {
            // Perf: Undone before final release
            return FindRecordByKey(new object[] {key});
        }

        public int FindRecordByKey(object[] key) {
            int nValues = (key == null ? 0 : key.Length);
            if (nValues == 0 || nValues != indexDesc.Length) {
                throw ExceptionBuilder.IndexKeyLength(indexDesc.Length, nValues);
            }

            int lo = 0;
            int hi = recordCount - 1;
            while (lo <= hi) {
                int i = lo + hi >> 1;
                int c = CompareRecordToKey(records[i], key);
                if (c == 0) return i;
                if (c < 0) lo = i + 1;
                else hi = i - 1;
            }
            return -1;
        }

        private int FindRecordByKey(object[] key, bool findFirst) { // This function does not make sure whether any matching record is present or not.
            int lo = 0;
            int hi = recordCount - 1;
            while (lo <= hi) {
                int i = lo + hi >> 1;
                int c = CompareRecordToKey(records[i], key);
                if (c == 0) c = (findFirst ? 1 : -1);
                if (c < 0) lo = i + 1;
                else hi = i - 1;
            }
            return lo;
        }

        public Range FindRecords(object key) {
            // Perf: Undone before final release
            return FindRecords(new object[] {key});
        }

        public Range FindRecords(object[] key) {
            int nValues = (key == null ? 0 : key.Length);
            if (nValues == 0 || nValues != indexDesc.Length) {
                throw ExceptionBuilder.IndexKeyLength(indexDesc.Length, nValues);
            }

            int lo = FindRecordByKey(key, true);
            int hi = FindRecordByKey(key, false) - 1;
            if (lo > hi)
                return Range.Null;
            else
                return new Range(lo, hi);
        }

        private int GetChangeAction(DataViewRowState oldState, DataViewRowState newState) {
            int oldIncluded = ((int)recordStates & (int)oldState) == 0? 0: 1;
            int newIncluded = ((int)recordStates & (int)newState) == 0? 0: 1;
            return newIncluded - oldIncluded;
        }

        public DataRow GetRow(int i) {
            return table.recordManager[GetRecord(i)];
        }

        public DataRow[] GetRows() {
            DataRow[] newRows = table.NewRowArray(recordCount);
            for (int i = 0; i < newRows.Length; i++) {
                newRows[i] = table.recordManager[GetRecord(i)];
            }
            return newRows;
        }

        public DataRow[] GetRows(Object[] values) {
            return GetRows(FindRecords(values));
        }

        public DataRow[] GetRows(Range range) {
            DataRow[] newRows = table.NewRowArray(range.Count);
            for (int i = 0; i < newRows.Length; i++) {
                newRows[i] = table.recordManager[GetRecord(range.Min + i)];
            }
            return newRows;
        }

        private void GrowRecords() {
            int[] newRecords = new int[RecordManager.NewCapacity(recordCount)];
            System.Array.Copy(records, 0, newRecords, 0, recordCount);
            records = newRecords;
        }

        private void InitRecords() {
            int count = table.Rows.Count;
            DataViewRowState states = recordStates;
            records = new int[count];
            recordCount = 0;
            for (int i = 0; i < count; i++) {
                DataRow b = table.Rows[i];
                int record = -1;
                if (b.oldRecord == b.newRecord) {
                    if ((int)(states & DataViewRowState.Unchanged) != 0) {
                        record = b.oldRecord;
                    }
                }
                else if (b.oldRecord == -1) {
                    if ((int)(states & DataViewRowState.Added) != 0) {
                        record = b.newRecord;
                    }
                }
                else if (b.newRecord == -1) {
                    if ((int)(states & DataViewRowState.Deleted) != 0) {
                        record = b.oldRecord;
                    }
                }
                else {
                    if ((int)(states & DataViewRowState.ModifiedCurrent) != 0) {
                        record = b.newRecord;
                    }
                    else if ((int)(states & DataViewRowState.ModifiedOriginal) != 0) {
                        record = b.oldRecord;
                    }
                }
                if (record != -1 && AcceptRecord(record)) records[recordCount++] = record;
            }
            if (recordCount > 1 && indexDesc.Length > 0) Sort(0, recordCount - 1);
        }

        private void InsertRecord(int record, int recordIndex) {
            if (recordCount == records.Length) GrowRecords();
            System.Array.Copy(records, recordIndex, records, recordIndex + 1, recordCount - recordIndex);
            records[recordIndex] = record;
            recordCount++;
            OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, recordIndex));
        }

        public bool IsKeyInIndex(object key) {
            int lo = 0;
            int hi = recordCount - 1;
            while (lo <= hi) {
                int i = lo + hi >> 1;
                int c = CompareRecordToKey(records[i], key);
                if (c == 0) return true;
                if (c < 0) lo = i + 1;
                else hi = i - 1;
            }
            return false;
        }

        public bool IsKeyInIndex(object[] key) {
            int lo = 0;
            int hi = recordCount - 1;
            while (lo <= hi) {
                int i = lo + hi >> 1;
                int c = CompareRecordToKey(records[i], key);
                if (c == 0) return true;
                if (c < 0) lo = i + 1;
                else hi = i - 1;
            }
            return false;
        }

        private void OnListChanged(ListChangedEventArgs e) {
            if (!suspendEvents && onListChanged != null) {
                onListChanged(this, e);
            }
        }

        public void Reset() {
            InitRecords();
            OnListChanged(DataView.ResetEventArgs);
        }

        public void RecordChanged(int record) {
            int index = GetIndex(record);
            if (index >= 0) {
                OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
            }
        }

        public void RecordStateChanged(int record, DataViewRowState oldState, DataViewRowState newState) {
            int action = GetChangeAction(oldState, newState);
            ApplyChangeAction(record, action);
        }

        public void RecordStateChanged(int oldRecord, DataViewRowState oldOldState, DataViewRowState oldNewState,
                                                 int newRecord, DataViewRowState newOldState, DataViewRowState newNewState) {
            int oldAction = GetChangeAction(oldOldState, oldNewState);
            int newAction = GetChangeAction(newOldState, newNewState);
            if (oldAction == -1 && newAction == 1 && AcceptRecord(newRecord)) {
                int recordIndex = GetIndex(newRecord);
                int newLocation = recordIndex & 0x7FFFFFFF;
                if (newLocation < recordCount && records[newLocation] == oldRecord) {
                    records[newLocation] = newRecord;
                    OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, newLocation));
                }
                else if (newLocation > 0 && records[newLocation-1] == oldRecord) {
                    records[newLocation-1] = newRecord;
                    OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, newLocation-1));
                }
                else {
                    suspendEvents = true;            
                    int oldLocation = GetIndex(oldRecord);
                    InsertRecord(newRecord, newLocation);
                    DeleteRecord(GetIndex(oldRecord));
                    suspendEvents = false;
                    OnListChanged(new ListChangedEventArgs(ListChangedType.ItemMoved, GetIndex(newRecord), oldLocation));
                }
            }
            else {
                ApplyChangeAction(oldRecord, oldAction);
                ApplyChangeAction(newRecord, newAction);                
            }
        }

        private void Sort(int left, int right) {
            int i, j;
            int record;
            do {
                i = left;
                j = right;
                record = records[i + j >> 1];
                do {
                    while (CompareRecords(records[i], record) < 0) i++;
                    while (CompareRecords(records[j], record) > 0) j--;
                    if (i <= j) {
                        int r = records[i];
                        records[i] = records[j];
                        records[j] = r;
                        i++;
                        j--;
                    }
                } while (i <= j);
                if (left < j) Sort(left, j);
                left = i;
            } while (i < right);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\rule.cs ===
//------------------------------------------------------------------------------
// <copyright file="Rule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\Rule.uex' path='docs/doc[@for="Rule"]/*' />
    /// <devdoc>
    /// <para>Indicates the action that occurs when a <see cref='System.Data.ForeignKeyConstraint'/>
    /// is enforced.</para>
    /// </devdoc>
    public enum Rule {
    
        /// <include file='doc\Rule.uex' path='docs/doc[@for="Rule.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No action occurs.
        ///    </para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\Rule.uex' path='docs/doc[@for="Rule.Cascade"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Changes are cascaded through the relationship.
        ///    </para>
        /// </devdoc>
        Cascade = 1,
        /// <include file='doc\Rule.uex' path='docs/doc[@for="Rule.SetNull"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Null values are set in the rows affected by the deletion.
        ///    </para>
        /// </devdoc>
        SetNull = 2,
        /// <include file='doc\Rule.uex' path='docs/doc[@for="Rule.SetDefault"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Default values are set in the rows affected by the deletion.
        ///    </para>
        /// </devdoc>
        SetDefault = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\simpletype.cs ===
//------------------------------------------------------------------------------
// <copyright file="SimpleType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Xml;
    using System.Xml.Schema;
    using System.Diagnostics;
    using System.ComponentModel;

    /// <include file='doc\SimpleType.uex' path='docs/doc[@for="SimpleType"]/*' />
    /// <devdoc>
    ///
    /// </devdoc>
    [Serializable]
    internal class SimpleType {
        string baseType = null;
        XmlQualifiedName xmlBaseType = null;
        string name = "";
        int length = -1;
        int minLength = -1;
        int maxLength = -1;
        string pattern = "";
        // UNDONE: change to object, and make sure that the format is right
        string maxExclusive = "";
        string maxInclusive = "";
        string minExclusive = "";
        string minInclusive = "";
        //REMOVED: encoding due to March 2001 XDS changes

        // UNDONE : change access when CreateEnumeratedType goes away
        internal string enumeration = "";

        internal SimpleType (string baseType) {
            this.baseType = baseType;
        }

        internal SimpleType (XmlSchemaSimpleType node) {
            name = node.Name;
            LoadTypeValues(node);
        }

        internal void LoadTypeValues (XmlSchemaSimpleType node) {
            if ((node.Content is XmlSchemaSimpleTypeList) || 
                (node.Content is XmlSchemaSimpleTypeUnion))
                throw ExceptionBuilder.SimpleTypeNotSupported();

            if (node.Content is XmlSchemaSimpleTypeRestriction) {
                XmlSchemaSimpleTypeRestriction content = (XmlSchemaSimpleTypeRestriction) node.Content;

                baseType = content.BaseTypeName.Name;
                xmlBaseType = content.BaseTypeName;

                if (baseType == null || baseType.Length == 0) {
                    baseType = content.BaseType.Name;
                    xmlBaseType = null;
                }

                foreach(XmlSchemaFacet facet in content.Facets) {

                    if (facet is XmlSchemaLengthFacet)
                        length = Convert.ToInt32(facet.Value);
                        
                    if (facet is XmlSchemaMinLengthFacet)
                        minLength = Convert.ToInt32(facet.Value);
                        
                    if (facet is XmlSchemaMaxLengthFacet)
                        maxLength = Convert.ToInt32(facet.Value);
                        
                    if (facet is XmlSchemaPatternFacet)
                        pattern = facet.Value;
                        
                    if (facet is XmlSchemaEnumerationFacet)
                        enumeration = !enumeration.Equals(string.Empty) ? enumeration + " " + facet.Value : facet.Value;
                        
                    if (facet is XmlSchemaMinExclusiveFacet)
                        minExclusive = facet.Value;
                        
                    if (facet is XmlSchemaMinInclusiveFacet)
                        minInclusive = facet.Value;
                       
                    if (facet is XmlSchemaMaxExclusiveFacet)
                        maxExclusive = facet.Value;
                        
                    if (facet is XmlSchemaMaxInclusiveFacet)
                        maxInclusive = facet.Value;

                    }
                }
            }

        internal bool IsEqual(SimpleType st) {
            return (
                XSDSchema.QualifiedName(this.baseType)     == XSDSchema.QualifiedName(st.baseType)     &&
                XSDSchema.QualifiedName(this.name)         == XSDSchema.QualifiedName(st.name)         &&
                this.length       == st.length       &&
                this.minLength    == st.minLength    &&
                this.maxLength    == st.maxLength    &&
                this.pattern      == st.pattern      &&
                this.maxExclusive == st.maxExclusive &&
                this.maxInclusive == st.maxInclusive &&
                this.minExclusive == st.minExclusive &&
                this.minInclusive == st.minInclusive &&
                this.enumeration  == st.enumeration
            );
        }

        internal bool IsPlainString() {
            return (
                XSDSchema.QualifiedName(this.baseType)     == XSDSchema.QualifiedName("string")     &&
                this.name         == "" &&
                this.length       == -1       &&
                this.minLength    == -1    &&
                this.maxLength    == -1    &&
                this.pattern      == ""      &&
                this.maxExclusive == "" &&
                this.maxInclusive == "" &&
                this.minExclusive == "" &&
                this.minInclusive == "" &&
                this.enumeration  == ""
            );
        }

        internal virtual string BaseType {
            get {
                return baseType;
            }
        }

        internal virtual XmlQualifiedName XmlBaseType {
            get {
                return xmlBaseType;
            }
        }

        internal virtual string Name {
            get {
                return name;
            }
        }

        internal virtual int Length {
            get {
                return length;
            }
        }

        internal virtual int MaxLength {
            get {
                return maxLength;
            }
            set {
                maxLength = value;
            }
        }

        internal string QualifiedName(string name) {
            int iStart = name.IndexOf(":");
            if (iStart == -1)
                return Keywords.XSD_PREFIXCOLON + name;
            else
                return name;
        }

        internal XmlNode ToNode(XmlDocument dc) {
            XmlElement typeNode = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SIMPLETYPE, Keywords.XSDNS);

            if (name != null && name.Length != 0) {
                // this is a global type : UNDONE: add to the _tree
                typeNode.SetAttribute(Keywords.NAME, name);
            }
            XmlElement type = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_RESTRICTION, Keywords.XSDNS);
            type.SetAttribute(Keywords.BASE, QualifiedName(baseType));

            XmlElement constraint;
            if (length >= 0) {
                constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_LENGTH, Keywords.XSDNS);
                constraint.SetAttribute(Keywords.VALUE, length.ToString());
                type.AppendChild(constraint);
            }
            if (maxLength >= 0) {
                constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_MAXLENGTH, Keywords.XSDNS);
                constraint.SetAttribute(Keywords.VALUE, maxLength.ToString());
                type.AppendChild(constraint);
            }
/*        // removed due to MDAC bug 83892
            // will be reactivated in whidbey with the proper handling
            if (pattern != null && pattern.Length > 0) {
                constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_PATTERN, Keywords.XSDNS);
                constraint.SetAttribute(Keywords.VALUE, pattern);
                type.AppendChild(constraint);
            }
            if (minLength >= 0) {
                constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_MINLENGTH, Keywords.XSDNS);
                constraint.SetAttribute(Keywords.VALUE, minLength.ToString());
                type.AppendChild(constraint);
            }
            if (minInclusive != null && minInclusive.Length > 0) {
                constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_MININCLUSIVE, Keywords.XSDNS);
                constraint.SetAttribute(Keywords.VALUE, minInclusive);
                type.AppendChild(constraint);
            }
            if (minExclusive != null && minExclusive.Length > 0) {
                constraint =dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_MINEXCLUSIVE, Keywords.XSDNS);
                constraint.SetAttribute(Keywords.VALUE, minExclusive);
                type.AppendChild(constraint);
            }
            if (maxInclusive != null && maxInclusive.Length > 0) {
                constraint =dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_MAXINCLUSIVE, Keywords.XSDNS);
                constraint.SetAttribute(Keywords.VALUE, maxInclusive);
                type.AppendChild(constraint);
            }
            if (maxExclusive != null && maxExclusive.Length > 0) {
                constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_MAXEXCLUSIVE, Keywords.XSDNS);
                constraint.SetAttribute(Keywords.VALUE, maxExclusive);
                type.AppendChild(constraint);
            }
            if (enumeration.Length > 0) {
                string[] list = enumeration.TrimEnd(null).Split(null);

                for (int i = 0; i < list.Length; i++) {
                    constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ENUMERATION, Keywords.XSDNS);
                    constraint.SetAttribute(Keywords.VALUE, list[i]);
                    type.AppendChild(constraint);
                }
            }
            */
            typeNode.AppendChild(type);
            return typeNode;
        }

        int ToInteger(XmlNode node, string value) {
            int result;

            try {
                result = Convert.ToInt32(value);
            }
            catch {
                throw ExceptionBuilder.InvalidAttributeValue(node.LocalName, value);
            }

            if (result < 0)
                throw ExceptionBuilder.InvalidAttributeValue(node.LocalName, value);

            return result;
        }

        // UNDONE: remove me, used only for parsing XDR
        internal static SimpleType CreateEnumeratedType(string values) {
            SimpleType enumType = new SimpleType("string");
            enumType.enumeration = values;
            return enumType;
        }

        internal static SimpleType CreateByteArrayType(string encoding) {
            SimpleType byteArrayType = new SimpleType("base64Binary");
            return byteArrayType;
        }
        
        internal static SimpleType CreateLimitedStringType(int length) {
            SimpleType limitedString = new SimpleType("string");
            limitedString.maxLength = length;
            return limitedString;
        }

        internal static SimpleType CreateSimpleType(Type type) {
            SimpleType simpleType = null;
            if(type == typeof(Char)) {
                simpleType = new SimpleType("string");
                simpleType.length = 1;
            }
            return simpleType;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\statechangeeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="StateChangeEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\StateChangeEventHandler.uex' path='docs/doc[@for="StateChangeEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Data.OleDb.OleDbConnection.StateChange'/> event.
    ///       Represents the method that will handle the <see cref='System.Data.SqlClient.SqlConnection.StateChange'/> event.
    ///    </para>
    /// </devdoc>
    public delegate void StateChangeEventHandler(object sender, StateChangeEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\statementtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatementType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\StatementType.uex' path='docs/doc[@for="StatementType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       a SQL query command.
    ///    </para>
    /// </devdoc>
    public enum StatementType {
        /// <include file='doc\StatementType.uex' path='docs/doc[@for="StatementType.Select"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A SQL query command that is a select command.
        ///    </para>
        /// </devdoc>
        Select = 0,
        /// <include file='doc\StatementType.uex' path='docs/doc[@for="StatementType.Insert"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A SQL query command that is an insert command.
        ///    </para>
        /// </devdoc>
        Insert = 1,
        /// <include file='doc\StatementType.uex' path='docs/doc[@for="StatementType.Update"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A SQL query command that is an update command.
        ///    </para>
        /// </devdoc>
        Update = 2,
        /// <include file='doc\StatementType.uex' path='docs/doc[@for="StatementType.Delete"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A SQL query command that is a delete command.
        ///    </para>
        /// </devdoc>
        Delete = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\statechangeevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="StateChangeEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    /// <include file='doc\StateChangeEvent.uex' path='docs/doc[@for="StateChangeEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Data.OleDb.OleDbConnection.StateChange'/> event.
    ///       Provides data for the <see cref='System.Data.SqlClient.SqlConnection.StateChange'/> event.
    ///    </para>
    /// </devdoc>
    sealed public class StateChangeEventArgs : System.EventArgs {
        private ConnectionState originalState;
        private ConnectionState currentState;

        /// <include file='doc\StateChangeEvent.uex' path='docs/doc[@for="StateChangeEventArgs.StateChangeEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.StateChangeEventArgs'/> class when given the original
        ///       state and the current state of the object.
        ///    </para>
        /// </devdoc>
        public StateChangeEventArgs(ConnectionState originalState, ConnectionState currentState) {
            this.originalState = originalState;
            this.currentState = currentState;
        }

        /// <include file='doc\StateChangeEvent.uex' path='docs/doc[@for="StateChangeEventArgs.CurrentState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the current state of the connection. This property is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public ConnectionState CurrentState {
            get {
                return this.currentState;
            }
        }

        /// <include file='doc\StateChangeEvent.uex' path='docs/doc[@for="StateChangeEventArgs.OriginalState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the original state of the connection. This property is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public ConnectionState OriginalState {
            get {
                return this.originalState;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\updaterowsource.cs ===
//------------------------------------------------------------------------------
// <copyright file="UpdateRowSource.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\UpdateRowSource.uex' path='docs/doc[@for="UpdateRowSource"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how query command results are applied to the row being updated.
    ///    </para>
    /// </devdoc>
    public enum UpdateRowSource {

        /// <include file='doc\UpdateRowSource.uex' path='docs/doc[@for="UpdateRowSource.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Any returned parameters are ignored.
        ///    </para>
        /// </devdoc>
        None = 0,

        /// <include file='doc\UpdateRowSource.uex' path='docs/doc[@for="UpdateRowSource.OutputParameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Output parameters are mapped to the changed row in the <see cref='System.Data.DataSet'/>.
        ///    </para>
        /// </devdoc>
        OutputParameters = 1,

        /// <include file='doc\UpdateRowSource.uex' path='docs/doc[@for="UpdateRowSource.FirstReturnedRecord"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The data in the first returned record are mapped to the changed row in the
        ///    <see cref='System.Data.DataSet'/>.
        ///    </para>
        /// </devdoc>
        FirstReturnedRecord = 2,

        /// <include file='doc\UpdateRowSource.uex' path='docs/doc[@for="UpdateRowSource.Both"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Both the output parameters and the first returned record are mapped to the
        ///       changed row in the <see cref='System.Data.DataSet'/>.
        ///    </para>
        /// </devdoc>
        Both = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\sqldbtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="SqlDbType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    using System.Diagnostics;

    /* enumeration used to identify data types specific to SQL Server
     * 
     * note that these are a subset of the types exposed by OLEDB so keep the enum values in ssync with
     * OleDbType values
     */

    using System;

    //
    // UNDONE:  It would be nice if these were compatible with the OLEDBDataTypeEnum, but they aren't.
    // For example, OLEDB doesn't have a smallmoney or smalldatetime ovlerload
    //

    /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the SQL Server data type.
    ///    </para>
    /// </devdoc>
    public enum SqlDbType {
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.BigInt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A 64-bit signed integer.
        ///    </para>
        /// </devdoc>
        BigInt,     //0
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Binary"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A fixed-length stream of binary
        ///       data ranging between 1
        ///       and 8,000 bytes.
        ///    </para>
        /// </devdoc>
        Binary,     //1
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Bit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An unsigned numeric value that can be 0, 1, or
        ///    <see langword='null'/>
        ///    .
        /// </para>
        /// </devdoc>
        Bit,        //2
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Char"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A fixed-length stream of non-Unicode characters
        ///       ranging between 1
        ///       and 8,000 characters.
        ///    </para>
        /// </devdoc>
        Char,       //3
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.DateTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Date and time data ranging in value from January 1, 1753
        ///       to December 31, 9999 to
        ///       an accuracy of 3.33 milliseconds.
        ///    </para>
        /// </devdoc>
        DateTime,   //4
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Decimal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A fixed precision and scale numeric
        ///       value between -10<superscript term='38'/> -1 and 10<superscript term='38'/>
        ///       -1.
        ///    </para>
        /// </devdoc>
        Decimal,    //5
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Float"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A floating point number within the range of -1.79E +308 through 1.79E
        ///       +308.
        ///    </para>
        /// </devdoc>
        Float,      //6
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Image"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A variable-length stream of binary data ranging from 0
        ///       to 2<superscript term='31 '/>-1
        ///       (or 2,147,483,647) bytes.
        ///    </para>
        /// </devdoc>
        Image,      //7
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Int"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A 32-bit signed integer.
        ///    </para>
        /// </devdoc>
        Int,        //8
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Money"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A currency value ranging from -2<superscript term='63'/> (or
        ///       -922,337,203,685,477.5808) to 2<superscript term='63'/> -1 (or +922,337,203,685,477.5807) with an accuracy
        ///       to a ten-thousandth of currency unit.
        ///    </para>
        /// </devdoc>
        Money,      //9
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.NChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A fixed-length stream of Unicode characters ranging between 1
        ///       and 4,000 characters.
        ///    </para>
        /// </devdoc>
        NChar,      //10
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.NText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A variable-length stream of Unicode data with a maximum length
        ///       of 2<superscript term='30'/> - 1 (or 1,073,741,823) characters.
        ///    </para>
        /// </devdoc>
        NText,      //11
//                Numeric,  //12
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.NVarChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A variable-length stream of Unicode characters ranging between 1
        ///       and 4,000 characters.
        ///    </para>
        /// </devdoc>
        NVarChar,   //12
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Real"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A floating point number within the range of -3.40E +38 through 3.40E +38.
        ///    </para>
        /// </devdoc>
        Real,       //13
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.UniqueIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A globally unique identifier (or guid).
        ///    </para>
        /// </devdoc>
        UniqueIdentifier,       //14
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.SmallDateTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Date
        ///       and time data
        ///       ranging in value from
        ///       January 1, 1900 to June 6, 2079 to an accuracy of one minute.
        ///    </para>
        /// </devdoc>
        SmallDateTime,  //15
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.SmallInt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A 16-bit signed integer.
        ///    </para>
        /// </devdoc>
        SmallInt,       //16
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.SmallMoney"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A
        ///       currency value ranging from -214,748.3648 to
        ///       +214,748.3647 with an accuracy to a ten-thousandth of a currency unit.
        ///    </para>
        /// </devdoc>
        SmallMoney,     //17
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A variable-length stream of non-Unicode data with a
        ///       maximum length of 2<superscript term='31 '/>-1
        ///       (or 2,147,483,647) characters.
        ///    </para>
        /// </devdoc>
        Text,          //18
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Timestamp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A binary row identifier.
        ///    </para>
        /// </devdoc>
        Timestamp,    //19
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.TinyInt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An 8-bit unsigned integer.
        ///    </para>
        /// </devdoc>
        TinyInt,        //20
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.VarBinary"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A variable-length stream of binary data ranging between 1 and 8,000
        ///       bytes.
        ///    </para>
        /// </devdoc>
        VarBinary,      //21
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.VarChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A variable-length stream of non-Unicode characters ranging between 1
        ///       and 8,000 characters.
        ///    </para>
        /// </devdoc>
        VarChar,        //22
        /// <include file='doc\SqlDbType.uex' path='docs/doc[@for="SqlDbType.Variant"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A special data
        ///       type that can contain numeric, string, binary, or date data as well
        ///       as the SQL Server values Empty and Null, which is assumed if no other type is
        ///       declared.
        ///    </para>
        /// </devdoc>
        Variant         //23
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\uniqueconstraint.cs ===
//------------------------------------------------------------------------------
// <copyright file="UniqueConstraint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Drawing.Design;

    /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a restriction on a set of columns in which all values must be unique.
    ///    </para>
    /// </devdoc>
    [
    DefaultProperty("ConstraintName"),
    Editor("Microsoft.VSDesigner.Data.Design.UniqueConstraintEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(UITypeEditor)),
    Serializable
    ]
    public class UniqueConstraint : Constraint {
        DataKey key = null;
        internal bool bPrimaryKey = false;

        // Design time serialization
        internal string constraintName = null;
        internal string[] columnNames = null;

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.UniqueConstraint"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.UniqueConstraint'/> with the specified name and
        /// <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public UniqueConstraint(String name, DataColumn column) {
            DataColumn[] columns = new DataColumn[1];
            columns[0] = column;
            Create(name, columns);
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.UniqueConstraint1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.UniqueConstraint'/> with the specified <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public UniqueConstraint(DataColumn column) {
            DataColumn[] columns = new DataColumn[1];
            columns[0] = column;
            Create(null, columns);
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.UniqueConstraint2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.UniqueConstraint'/> with the specified name and array
        ///    of <see cref='System.Data.DataColumn'/> objects.</para>
        /// </devdoc>
        public UniqueConstraint(String name, DataColumn[] columns) {
            Create(name, columns);
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.UniqueConstraint3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.UniqueConstraint'/> with the given array of <see cref='System.Data.DataColumn'/>
        ///       objects.
        ///    </para>
        /// </devdoc>
        public UniqueConstraint(DataColumn[] columns) {
            Create(null, columns);
        }

        // Construct design time object
        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.UniqueConstraint4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false)]
        public UniqueConstraint(String name, string[] columnNames, bool isPrimaryKey) {
            this.constraintName = name;
            this.columnNames = columnNames;
            this.bPrimaryKey = isPrimaryKey;
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.UniqueConstraint5"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.UniqueConstraint'/> with the specified name and
        /// <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public UniqueConstraint(String name, DataColumn column, bool isPrimaryKey) {
            DataColumn[] columns = new DataColumn[1];
            columns[0] = column;
            this.bPrimaryKey = isPrimaryKey;
            Create(name, columns);
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.UniqueConstraint6"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.UniqueConstraint'/> with the specified <see cref='System.Data.DataColumn'/>.</para>
        /// </devdoc>
        public UniqueConstraint(DataColumn column, bool isPrimaryKey) {
            DataColumn[] columns = new DataColumn[1];
            columns[0] = column;
            this.bPrimaryKey = isPrimaryKey;
            Create(null, columns);
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.UniqueConstraint7"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Data.UniqueConstraint'/> with the specified name and array
        ///    of <see cref='System.Data.DataColumn'/> objects.</para>
        /// </devdoc>
        public UniqueConstraint(String name, DataColumn[] columns, bool isPrimaryKey) {
            this.bPrimaryKey = isPrimaryKey;
            Create(name, columns);
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.UniqueConstraint8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Data.UniqueConstraint'/> with the given array of <see cref='System.Data.DataColumn'/>
        ///       objects.
        ///    </para>
        /// </devdoc>
        public UniqueConstraint(DataColumn[] columns, bool isPrimaryKey) {
            this.bPrimaryKey = isPrimaryKey;
            Create(null, columns);
        }

        // design time serialization only
        internal string[] ColumnNames {
            get {
                int count = key.Columns.Length;
                string[] columnNames = new string[count];
                for (int i = 0; i < count; i++)
                    columnNames[i] = key.Columns[i].ColumnName;
                    
                return columnNames;
            }
        }

        internal override void CheckState() {
            key.CheckState();
        }

        internal override void CheckCanAddToCollection(ConstraintCollection constraints) {
        }

        internal override bool CanBeRemovedFromCollection(ConstraintCollection constraints, bool fThrowException) {
            if (this.Equals(constraints.Table.primaryKey)) {
                Debug.Assert(constraints.Table.primaryKey == this, "If the primary key and this are 'Equal', they should also be '=='");
                if (!fThrowException)
                    return false;
                else
                    throw ExceptionBuilder.RemovePrimaryKey(constraints.Table);
            }
            for (ParentForeignKeyConstraintEnumerator cs = new ParentForeignKeyConstraintEnumerator(Table.DataSet, Table); cs.GetNext();) {
                ForeignKeyConstraint constraint = cs.GetForeignKeyConstraint();
                if (!key.ColumnsEqual(constraint.ParentKey))
                    continue;

                if (!fThrowException)
                    return false;
                else
                    throw ExceptionBuilder.NeededForForeignKeyConstraint(this, constraint);
            }

            return true;
        }

        internal override bool CanEnableConstraint() {
            if (Table.EnforceConstraints)
                return key.GetSortIndex().CheckUnique();

            return true;
        }

        internal override bool IsConstraintViolated() {
            Index index = key.GetSortIndex();
            object[] uniqueKeys = index.GetUniqueKeyValues();
            bool errors = false;

            for (int i = 0; i < uniqueKeys.Length; i++) {
                Range r = index.FindRecords((object[])uniqueKeys[i]);
                DataRow[] rows = index.GetRows(r);
                if (rows.Length > 1) {
                    string error = ExceptionBuilder.UniqueConstraintViolationText(key.Columns, (object[])uniqueKeys[i]);
                    for (int j = 0; j < rows.Length; j++) {
                        rows[j].RowError = error;
                        errors = true;
                    }
                }
            }
            return errors;
        }

        internal override void CheckConstraint(DataRow row, DataRowAction action) {
            if (Table.EnforceConstraints &&
                (action == DataRowAction.Add ||
                 action == DataRowAction.Change ||
                 (action == DataRowAction.Rollback && row.tempRecord != -1))) {
                if (row.HaveValuesChanged(Columns)) {
                    Index index = Key.GetSortIndex();
                    object[] values = row.GetColumnValues(Columns);
                    if (index.IsKeyInIndex(values)) {
#if DEBUG
                        if (CompModSwitches.Data_Constraints.TraceVerbose) {
                            Debug.WriteLine("UniqueConstraint violation...");
                            string valuesText = "";
                            for (int i = 0; i < values.Length; i++) {
                                valuesText = Convert.ToString(values[i]) + (i < values.Length - 1 ? ", " : "");
                            }
                            Debug.WriteLine("   constraint: " + this.GetDebugString());
                            Debug.WriteLine("   key values: " + valuesText);
                            Range range = index.FindRecords(values);
                            int record = index.GetRecord(range.Min);
                            Debug.WriteLine("   conflicting record: " + record.ToString());
                        }
#endif
                        throw ExceptionBuilder.ConstraintViolation(Columns, values);
                    }
                }
            }
        }

        internal override bool ContainsColumn(DataColumn column) {
            return key.ContainsColumn(column);
        }

        internal override Constraint Clone(DataSet destination) {
            int iDest = destination.Tables.IndexOf(Table.TableName);
            if (iDest < 0)
                return null;
            DataTable table = destination.Tables[iDest];

            int keys = Columns.Length;
            DataColumn[] columns = new DataColumn[keys];

            for (int i = 0; i < keys; i++) {
                DataColumn src = Columns[i];
                iDest = table.Columns.IndexOf(src.ColumnName);
                if (iDest < 0)
                    return null;
                columns[i] = table.Columns[iDest];
            }

            UniqueConstraint clone = new UniqueConstraint(ConstraintName, columns);

            // ...Extended Properties
            foreach(Object key in this.ExtendedProperties.Keys) {
               clone.ExtendedProperties[key]=this.ExtendedProperties[key];
            }

            return clone;
        }

        internal UniqueConstraint Clone(DataTable table) {
            int keys = Columns.Length;
            DataColumn[] columns = new DataColumn[keys];

            for (int i = 0; i < keys; i++) {
                DataColumn src = Columns[i];
                int iDest = table.Columns.IndexOf(src.ColumnName);
                if (iDest < 0)
                    return null;
                columns[i] = table.Columns[iDest];
            }
            return(new UniqueConstraint(ConstraintName, columns));
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.Columns"]/*' />
        /// <devdoc>
        ///    <para>Gets the array of columns that this constraint affects.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.KeyConstraintColumnsDescr),
        ReadOnly(true)
        ]
        public virtual DataColumn[] Columns {
            get {
                return key.Columns;
            }
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.IsPrimaryKey"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       a value indicating whether or not the constraint is on a primary key.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.KeyConstraintIsPrimaryKeyDescr)
        ]
        public bool IsPrimaryKey {
            get {
                if (Table == null) {
                    return false;
                }
                return(this == Table.primaryKey);
            }
        }

        private void Create(String constraintName, DataColumn[] columns) {
            for (int i = 0; i < columns.Length; i++) {
                if (columns[i].Computed) {
                    throw ExceptionBuilder.ExpressionInConstraint(columns[i]);
                }
            }
            this.key = new DataKey(columns);
            ConstraintName = constraintName;
            CheckState();
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.Equals"]/*' />
        /// <devdoc>
        ///    <para>Compares this constraint to a second to
        ///       determine if both are identical.</para>
        /// </devdoc>
        public override bool Equals(object key2) {
            if (!(key2 is UniqueConstraint))
                return false;

            return Key.ColumnsEqual(((UniqueConstraint)key2).Key);
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Int32 GetHashCode() {
            return Key.GetHashCode();
        }

        internal override bool InCollection {
            set {
                base.InCollection = value;
                if (key.Columns.Length == 1) {
                    key.Columns[0].InternalUnique = value;
                }
            }
        }

        internal virtual DataKey Key {
            get {
                return key;
            }
        }

        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.Table"]/*' />
        /// <devdoc>
        ///    <para>Gets the table to which this constraint belongs.</para>
        /// </devdoc>
        [
        DataCategory(Res.DataCategory_Data),
        DataSysDescription(Res.ConstraintTableDescr),
        ReadOnly(true)
        ]
        public override DataTable Table {
            get {
                if (key == null)
                    return null;
                return key.Table;
            }
        }

#if DEBUG
        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.GetDebugString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public string GetDebugString() {
            return key.GetDebugString();
        }
#endif

        // misc

#if DEBUG
        /// <include file='doc\UniqueConstraint.uex' path='docs/doc[@for="UniqueConstraint.Dump"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override void Dump(string header, bool deep) {
            DataColumn[] cols;
            DataColumn    col;
            int i;
            Debug.WriteLine(header + "UniqueContraint");
            header += "  ";
            Debug.WriteLine(header + "Name:          " + this.name);
            Debug.WriteLine(header + "In collection: " + this.InCollection);
            Debug.WriteLine(header + "Table:         " + this.Table.TableName);
            Debug.WriteLine(header + "IsPrimaryKey:  " + (this.IsPrimaryKey ? "true" : "false"));
            Debug.Write(    header + "Columns:       ");
            cols = this.Columns;
            if (cols.Length == 0)
                Debug.WriteLine("none");
            else {
                Debug.Write(cols[0].Table.TableName + "." + cols[0].ColumnName);
                for (i = 1; i < cols.Length; i++) {
                    col = cols[i];
                    Debug.Write(" + " + col.Table.TableName + "." + col.ColumnName);
                }
                Debug.WriteLine("");
            }
        }
#endif        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xdrschema.cs ===
//------------------------------------------------------------------------------
// <copyright file="XDRSchema.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Xml;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel;
    using System.Diagnostics;

    internal class XDRSchema : XMLSchema {
        internal String             _schemaName;
        internal String             _schemaUri;
        internal XmlElement         _schemaRoot;
        internal DataSet            _ds;
        private  static char[] colonArray = new char[] {':'};


        internal XDRSchema(DataSet ds, bool fInline) {
            _schemaUri = String.Empty;
            _schemaName = String.Empty;
            _schemaRoot = null;
            _ds = ds;
        }

        internal void LoadSchema(XmlElement schemaRoot, DataSet ds) {
            if (schemaRoot == null)
                return;

            _schemaRoot = schemaRoot;
            _ds = ds;
            _schemaName = schemaRoot.GetAttribute(Keywords.NAME);
                

            _schemaUri = "";
            Debug.Assert(FEqualIdentity(schemaRoot, Keywords.XDR_SCHEMA, Keywords.XDRNS), "Illegal node");

            // Get Locale and CaseSensitive properties
            
            if (_schemaName == "" || _schemaName == null)
                _schemaName = "NewDataSet";

            ds.Namespace = _schemaUri;

            // TODO (Jasonzhu): Need to get XDO properties here
            
            // Walk all the top level Element tags.  
            for (XmlNode n = schemaRoot.FirstChild; n != null; n = n.NextSibling) {
                if (!(n is XmlElement))
                    continue;

                XmlElement child = (XmlElement) n;

                if (FEqualIdentity(child, Keywords.XDR_ELEMENTTYPE, Keywords.XDRNS)) {
                    HandleTable(child);
                }
            }
            
            _schemaName = XmlConvert.DecodeName(_schemaName);
            if (ds.Tables[_schemaName] == null)
                ds.DataSetName = _schemaName;
                         
        }

      


        internal XmlNode FindChild(XmlNode node, string name, string ns) {
            XmlNode tmpNode = node.FirstChild;

            while (tmpNode != null) {
                if (tmpNode.LocalName == name && tmpNode.NamespaceURI == ns)
                    break;

                tmpNode = tmpNode.NextSibling;
            }

            return tmpNode;
        }

        internal XmlElement FindReferenceChild(XmlNode schema, string name, string ns, string refName) {
            XmlNode tmpNode = schema.FirstChild;

            while (tmpNode != null) {
                if ((tmpNode is XmlElement) && tmpNode.LocalName == name && tmpNode.NamespaceURI == ns) {
                    if (refName == null || refName == ((XmlElement)tmpNode).GetAttribute(Keywords.NAME))
                        return(XmlElement)tmpNode;
                }

                tmpNode = tmpNode.NextSibling;
            }

            return(XmlElement)tmpNode;
        }

        internal XmlElement FindTypeNode(XmlElement node) {
            string      strType;
            XmlNode     vn;
            XmlNode     vnRoof;

            Debug.Assert(FEqualIdentity(node, Keywords.XDR_ELEMENT, Keywords.XDRNS) ||
                         FEqualIdentity(node, Keywords.XDR_SCHEMA, Keywords.XDRNS) ||
                         FEqualIdentity(node, Keywords.XDR_ATTRIBUTE, Keywords.XDRNS) ||
                         FEqualIdentity(node, Keywords.XDR_ELEMENTTYPE, Keywords.XDRNS),
                         "Invalid node type " + node.LocalName);

            if (FEqualIdentity(node, Keywords.XDR_ELEMENTTYPE, Keywords.XDRNS))
                return node;

            strType = node.GetAttribute(Keywords.TYPE);

            if (FEqualIdentity(node, Keywords.XDR_ELEMENT, Keywords.XDRNS) || 
                FEqualIdentity(node, Keywords.XDR_ATTRIBUTE, Keywords.XDRNS)) {
                if (strType == null || strType.Length == 0)
                    return null;

                // Find an ELEMENTTYPE or ATTRIBUTETYPE with name=strType
                vn = node.OwnerDocument.FirstChild;
                vnRoof = node.OwnerDocument;

                while (vn != vnRoof) {
                    if ((FEqualIdentity(vn, Keywords.XDR_ELEMENTTYPE, Keywords.XDRNS) && 
                         FEqualIdentity(node, Keywords.XDR_ELEMENT, Keywords.XDRNS)) ||
                        (FEqualIdentity(vn, Keywords.XDR_ATTRIBUTETYPE, Keywords.XDRNS) && 
                         FEqualIdentity(node, Keywords.XDR_ATTRIBUTE, Keywords.XDRNS))) {
                        if (vn is XmlElement && ((XmlElement)vn).GetAttribute(Keywords.NAME) == strType)
                            return(XmlElement)vn;
                    }

                    // Move vn node
                    if (vn.FirstChild != null)
                        vn = vn.FirstChild;
                    else if (vn.NextSibling != null)
                        vn = vn.NextSibling;
                    else {
                        while (vn != vnRoof) {
                            vn = vn.ParentNode;
                            if (vn.NextSibling != null) {
                                vn = vn.NextSibling;
                                break;
                            }
                        }                            
                    }                        
                } 

                return null;
            }

            return null;
        }

        internal bool IsTextOnlyContent(XmlElement node) {
            Debug.Assert(FEqualIdentity(node, Keywords.XDR_ELEMENTTYPE, Keywords.XDRNS), 
                         "Invalid node type " + node.LocalName);

            string value = node.GetAttribute(Keywords.CONTENT);
            if (value == null || value.Length == 0) {
                string type = node.GetAttribute(Keywords.DT_TYPE, Keywords.DTNS);
                if (type != null && type.Length > 0)
                    return true;

                return false;
            }

            if (value == Keywords.EMPTY || value == Keywords.ELTONLY || value == Keywords.ELEMENTONLY || value == Keywords.MIXED)
                return false;
            if (value == Keywords.TEXTONLY)
                return true;

            throw ExceptionBuilder.InvalidAttributeValue("content", value);
        }

        internal bool IsXDRField(XmlElement node, XmlElement typeNode) {
            int         min = 1;
            int         max = 1;

            if (!IsTextOnlyContent(typeNode))
                return false;

            for (XmlNode n = typeNode.FirstChild; n != null; n = n.NextSibling) {
                if (FEqualIdentity(n, Keywords.XDR_ELEMENT, Keywords.XDRNS) || 
                    FEqualIdentity(n, Keywords.XDR_ATTRIBUTE, Keywords.XDRNS))
                    return false;
            }

            if (FEqualIdentity(node, Keywords.XDR_ELEMENT, Keywords.XDRNS)) {
                GetMinMax(node, ref min, ref max);
                if (max == -1 || max > 1)
                    return false;
            }

            return true;
        }

        internal DataTable HandleTable(XmlElement node) {
            XmlElement     typeNode;

            Debug.Assert(FEqualIdentity(node, Keywords.XDR_ELEMENTTYPE, Keywords.XDRNS) ||
                         FEqualIdentity(node, Keywords.XDR_ELEMENT, Keywords.XDRNS), "Invalid node type");

            
            // Figure out if this really is a table.  If not, bail out.
            typeNode = FindTypeNode(node);

            string occurs = node.GetAttribute(Keywords.MINOCCURS);

            if (occurs != null && occurs.Length > 0) 
                if ((Convert.ToInt32(occurs)>1) && (typeNode==null)){
                    return InstantiateSimpleTable(_ds, node);
                }
            
            occurs = node.GetAttribute(Keywords.MAXOCCURS);

            if (occurs != null && occurs.Length > 0) 
                if ((string.Compare(occurs, "1" , false, CultureInfo.InvariantCulture) != 0) && (typeNode==null)){
                    return InstantiateSimpleTable(_ds, node);
                }
            

            if (typeNode == null)
                return null;

            if (IsXDRField(node, typeNode))
                    return null;

            return InstantiateTable(_ds, node, typeNode);
        }

        private class NameTypeComparer : IComparer {
            public int Compare(object x, object y) {return String.Compare(((NameType)x).name, ((NameType)y).name, false, CultureInfo.InvariantCulture);}
        }
        private class NameType : IComparable {
            public String   name;
            public Type     type;
            public NameType(String n, Type t) { 
                name = n;
                type = t;
            }
            public int CompareTo(object obj) { return String.Compare(name, (string)obj, false, CultureInfo.InvariantCulture); }
        };
        // XDR spec: http://www.ltg.ed.ac.uk/~ht/XMLData-Reduced.htm
        //           http://webdata/newspecs/schema/xdr_dt_schema.xml
        private static NameType[] mapNameTypeXdr = {
            new NameType("id"                  , typeof(string)  ), /* XDR */ 
            new NameType("idref"               , typeof(string)  ), /* XDR */ 
            new NameType("idrefs"              , typeof(string)  ), /* XDR */ 
            new NameType("entity"              , typeof(string)  ), /* XDR */ 
            new NameType("entities"            , typeof(string)  ), /* XDR */ 
            new NameType("nmtoken"             , typeof(string)  ), /* XDR */ 
            new NameType("nmtokens"            , typeof(string)  ), /* XDR */ 
            new NameType("enumeration"         , typeof(string)  ), /* XDR */ 
            new NameType("notation"            , typeof(string)  ), /* XDR */ 
            new NameType("string"              , typeof(string)  ), /* XDR */ 
            new NameType("number"              , typeof(Decimal) ), /* XDR */ 
            new NameType("int"                 , typeof(Int32)   ), /* XDR */ 
            new NameType("fixed.14.4"          , typeof(Decimal) ), /* XDR */ 
            new NameType("boolean"             , typeof(bool)    ), /* XDR */ 
            new NameType("dateTime"            , typeof(DateTime)), /* XDR */ 
            new NameType("dateTime.tz"         , typeof(DateTime)), /* XDR */ 
            new NameType("date"                , typeof(DateTime)), /* XDR */ 
            new NameType("time"                , typeof(DateTime)), /* XDR */ 
            new NameType("time.tz"             , typeof(DateTime)), /* XDR */ 
            new NameType("byte"                , typeof(SByte)   ), /* XDR */
            new NameType("i1"                  , typeof(SByte)   ), /* XDR */ 
            new NameType("i2"                  , typeof(Int16)   ), /* XDR */ 
            new NameType("i4"                  , typeof(Int32)   ), /* XDR */ 
            new NameType("i8"                  , typeof(Int64)   ), /* XDR */ 
            new NameType("ui1"                 , typeof(Byte)    ), /* XDR */ 
            new NameType("ui2"                 , typeof(UInt16)  ), /* XDR */ 
            new NameType("ui4"                 , typeof(UInt32)  ), /* XDR */ 
            new NameType("ui8"                 , typeof(UInt64)  ), /* XDR */ 
            new NameType("r4"                  , typeof(Single)  ), /* XDR */ 
            new NameType("r8"                  , typeof(Double)  ), /* XDR */ 
            new NameType("float"               , typeof(Double)  ), /* XDR */
            new NameType("uuid"                , typeof(Guid)    ), /* XDR */
            new NameType("uri"                 , typeof(string)  ), /* XDR */ 
            new NameType("bin.hex"             , typeof(Byte[])  ), /* XDR */ 
            new NameType("bin.base64"          , typeof(Byte[])  ), /* XDR */ 
            new NameType("char"                , typeof(Char)    ), /* XDR */ 
        };
        private static bool _wasSorted;

        private static NameType FindNameType(string name) {
            if(! _wasSorted) {
                lock(typeof(NameType)) {
                    if(! _wasSorted) {
                        NameTypeComparer comparer = new NameTypeComparer(); 
                        // REVIEW: (davidgut) why not sort the static list?
                        Array.Sort(mapNameTypeXdr, comparer);
                        _wasSorted = true;
                    }
                }
            }
            int index = Array.BinarySearch(mapNameTypeXdr, name);
            if (index < 0) {
#if DEBUG
                // Let's check that we realy don't have this name:
                foreach (NameType nt in mapNameTypeXdr) {
                    Debug.Assert(nt.name != name, "FindNameType('" + name + "') -- failed. Existed name not found");
                }
#endif
                throw ExceptionBuilder.UndefinedDatatype(name);
            }
            Debug.Assert(mapNameTypeXdr[index].name == name, "FindNameType('" + name + "') -- failed. Wrong name found");
            return mapNameTypeXdr[index];
        }

        private static NameType enumerationNameType = FindNameType("enumeration");

        private Type ParseDataType(string dt, string dtValues) {
            string strType = dt;
            string[] parts = dt.Split(colonArray);  // ":"

            if (parts.Length > 2) {
                throw ExceptionBuilder.InvalidAttributeValue("type", dt);
            }
            else if (parts.Length == 2) {
                // CONSIDER: check that we have valid prefix
                strType = parts[1];
            }
                
            NameType nt = FindNameType(strType);
            if (nt == enumerationNameType && (dtValues == null || dtValues.Length == 0))
                throw ExceptionBuilder.MissingAttribute("type", Keywords.DT_VALUES);
            return nt.type;
        }

        internal string GetInstanceName(XmlElement node) {
            string  instanceName;

            if (FEqualIdentity(node, Keywords.XDR_ELEMENTTYPE, Keywords.XDRNS) ||
                FEqualIdentity(node, Keywords.XDR_ATTRIBUTETYPE, Keywords.XDRNS)) {
                instanceName = node.GetAttribute(Keywords.NAME);
                if (instanceName == null || instanceName.Length == 0) {
                    throw ExceptionBuilder.MissingAttribute("Element", Keywords.NAME);
                }
            }
            else {
                instanceName = node.GetAttribute(Keywords.TYPE);
                if (instanceName == null || instanceName.Length == 0)
                    throw ExceptionBuilder.MissingAttribute("Element", Keywords.TYPE);
            }

            return instanceName;
        }


        internal static AcceptRejectRule TranslateAcceptRejectRule( string strRule ) {
            if (strRule == "Cascade")
                return AcceptRejectRule.Cascade;
            else if (strRule == "None")
                return AcceptRejectRule.None;
            else
                return ForeignKeyConstraint.AcceptRejectRule_Default;
        }

        internal static Rule TranslateRule( string strRule ) {
            if (strRule == "Cascade")
                return Rule.Cascade;
            else if (strRule == "None")
                return Rule.None;
            else if (strRule == "SetDefault")
                return Rule.SetDefault;
            else if (strRule == "SetNull")
                return Rule.SetNull;
            else
                return ForeignKeyConstraint.Rule_Default;
        }

        internal void HandleColumn(XmlElement node, DataTable table) {
            Debug.Assert(FEqualIdentity(node, Keywords.XDR_ELEMENT, Keywords.XDRNS) ||
                         FEqualIdentity(node, Keywords.XDR_ATTRIBUTE, Keywords.XDRNS), "Illegal node type");

            string          instanceName;
            string          strName;
            Type            type;
            string          strType;
            string          strValues;
            int             minOccurs = 0;
            int             maxOccurs = 1;
            string          strDefault;
            DataColumn      column;

            string strUse = node.GetAttribute(Keywords.USE);



            // Get the name
            if (node.Attributes.Count > 0) {
                string strRef = node.GetAttribute(Keywords.REF);
                
                if (strRef != null && strRef.Length>0)
                    return; //skip ref nodes. B2 item

                strName = instanceName = GetInstanceName(node);
                column = table.Columns[instanceName, _schemaUri];
                if (column != null) {
                    if (column.ColumnMapping == MappingType.Attribute) {
                        if (FEqualIdentity(node, Keywords.XDR_ATTRIBUTE, Keywords.XDRNS))
                            throw ExceptionBuilder.DuplicateDeclaration(strName);
                    }
                    else {
                        if (FEqualIdentity(node, Keywords.XDR_ELEMENT, Keywords.XDRNS)) {
                            throw ExceptionBuilder.DuplicateDeclaration(strName);
                        }
                    }
                    instanceName = GenUniqueColumnName(strName, table);
                }
            }
            else
            {
                strName = instanceName = "";
            }

            // Now get the type
            XmlElement typeNode = FindTypeNode(node);

            SimpleType xsdType = null;

            if (typeNode == null) {
                strType = node.GetAttribute(Keywords.TYPE);
                throw ExceptionBuilder.UndefinedDatatype(strType);
            }

            strType = typeNode.GetAttribute(Keywords.DT_TYPE, Keywords.DTNS);
            strValues = typeNode.GetAttribute(Keywords.DT_VALUES, Keywords.DTNS);
            if (strType == null || strType.Length == 0) {
                strType = "";
                type = typeof(string);
            }
            else {
                type = ParseDataType(strType, strValues);
                // HACK: temp work around special types
                if (strType == "float") {
                    strType = "";
                }

                if (strType == "char") {
                    strType = "";
                    xsdType = SimpleType.CreateSimpleType(type);
                }


                if (strType == "enumeration") {
                    strType = "";
                    xsdType = SimpleType.CreateEnumeratedType(strValues);
                }
                
                if (strType == "bin.base64") {
                    strType = "";
                    xsdType = SimpleType.CreateByteArrayType("base64");
                }

                if (strType == "bin.hex") {
                    strType = "";
                    xsdType = SimpleType.CreateByteArrayType("hex");
                }

            }

            bool isAttribute = FEqualIdentity(node, Keywords.XDR_ATTRIBUTE, Keywords.XDRNS);

            GetMinMax(node, isAttribute,  ref minOccurs, ref maxOccurs);

            strDefault = null;

            // Does XDR has default?
            strDefault = node.GetAttribute(Keywords.DEFAULT);


            bool bNullable = false;

            column = new DataColumn(XmlConvert.DecodeName(instanceName), type, null, 
                isAttribute ? MappingType.Attribute : MappingType.Element);
                 
            SetProperties(column, node.Attributes);
            column.XmlDataType = strType;
            column.SimpleType = xsdType;
            column.AllowDBNull = (minOccurs == 0) || bNullable;
            column.Namespace = (isAttribute) ? String.Empty : _schemaUri;

            String targetNamespace = node.GetAttribute(Keywords.TARGETNAMESPACE);
            if (targetNamespace != null && targetNamespace.Length > 0)
                column.Namespace = targetNamespace;
            
            table.Columns.Add(column);
            if (strDefault != null && strDefault.Length != 0)
                try {
                    column.DefaultValue = Convert.ChangeType(strDefault, type);
                }
                catch (System.FormatException) {

                    throw ExceptionBuilder.CannotConvert(strDefault, type.FullName);
                }    

            for (XmlNode n = node.FirstChild ; n != null ; n = n.NextSibling) {
                if (FEqualIdentity(n, Keywords.XDR_DESCRIPTION, Keywords.XDRNS))
                    column.Description = ((XmlElement) n).InnerText;
            }


        }
        
        internal void GetMinMax(XmlElement elNode, ref int minOccurs, ref int maxOccurs) {

            GetMinMax(elNode, false,  ref minOccurs, ref maxOccurs);

        }

        internal void GetMinMax(XmlElement elNode, bool isAttribute, ref int minOccurs, ref int maxOccurs) {
            
            string occurs = elNode.GetAttribute(Keywords.MINOCCURS);
            if (occurs != null && occurs.Length > 0) {
                try {
                    minOccurs = Int32.Parse(occurs, CultureInfo.InvariantCulture);
                }
                catch (Exception) {
                    throw ExceptionBuilder.AttributeValues("minOccurs", "0", "1");
                }
            }
            occurs = elNode.GetAttribute(Keywords.MAXOCCURS);

            if (occurs != null && occurs.Length > 0) {
                int bZeroOrMore = string.Compare(occurs, Keywords.STAR , false, CultureInfo.InvariantCulture);
                if (bZeroOrMore == 0) {
                    maxOccurs = -1;
                }
                else {
                    try {
                        maxOccurs = Int32.Parse(occurs, CultureInfo.InvariantCulture);
                    }
                    catch (Exception) {
                        throw ExceptionBuilder.AttributeValues("maxOccurs", "1", Keywords.STAR);
                    }
                    if (maxOccurs != 1) {
                        throw ExceptionBuilder.AttributeValues("maxOccurs", "1", Keywords.STAR);
                    }
                }
            }
        
        }


        internal void HandleTypeNode(XmlElement typeNode, DataTable table, ArrayList tableChildren)
        {
            DataTable       tableChild;
            
            for (XmlNode n = typeNode.FirstChild; n != null; n = n.NextSibling) {

                if (!(n is XmlElement))
                    continue;

                if (FEqualIdentity(n, Keywords.XDR_ELEMENT, Keywords.XDRNS)) {
                    
                    
                    tableChild = HandleTable((XmlElement) n);
                    if (tableChild != null) {
                            tableChildren.Add(tableChild);
                        continue;
                    }
                }

                if (FEqualIdentity(n, Keywords.XDR_ATTRIBUTE, Keywords.XDRNS) ||
                    FEqualIdentity(n, Keywords.XDR_ELEMENT, Keywords.XDRNS)) {
                    HandleColumn((XmlElement) n, table);
                    continue;
                }


                
            }

    
        }

        internal DataTable InstantiateTable(DataSet dataSet, XmlElement node, XmlElement typeNode) {
            string          typeName = "";
            XmlAttributeCollection      attrs = node.Attributes;
            DataTable       table;
            int             minOccurs = 1;
            int             maxOccurs = 1;
            string          keys = null;
            ArrayList       tableChildren = new ArrayList();
            
         

            if (attrs.Count > 0) {
                typeName = GetInstanceName(node);
                table = dataSet.Tables[typeName, _schemaUri];
                if (table != null) {
                      return  table;
                }
            }

            table = new DataTable(XmlConvert.DecodeName(typeName));
                
            table.Namespace = _schemaUri;            

            GetMinMax(node, ref minOccurs, ref maxOccurs);
            table.MinOccurs = minOccurs;
            table.MaxOccurs = maxOccurs;

            _ds.Tables.Add(table);

            HandleTypeNode(typeNode, table, tableChildren);

            SetProperties(table, attrs);

            // check to see if we fave unique constraint

            if (keys != null) {
                string[] list = keys.TrimEnd(null).Split(null);
                int keyLength = list.Length;

                DataColumn[] cols = new DataColumn[keyLength];

                for (int i = 0; i < keyLength; i++) {
                    DataColumn col = table.Columns[list[i], _schemaUri];
                    if (col == null)
                        throw ExceptionBuilder.ElementTypeNotFound(list[i]);
                    cols[i] = col;
                }
                table.PrimaryKey = cols;
            }

 
            foreach(DataTable _tableChild in tableChildren) {
                DataRelation relation = null;

                DataRelationCollection childRelations = table.ChildRelations;
                
                for (int j = 0; j < childRelations.Count; j++) {
                    if (!childRelations[j].Nested)
                        continue;

                    if (_tableChild == childRelations[j].ChildTable)
                        relation = childRelations[j];
                }

                if (relation!=null)
                    continue;

                DataColumn parentKey = table.AddUniqueKey();
                // foreign key in the child table
                DataColumn childKey = _tableChild.AddForeignKey(parentKey);
                // create relationship
                // setup relationship between parent and this table
                relation = new DataRelation(table.TableName + "_" + _tableChild.TableName, parentKey, childKey, true);
                relation.Nested = true;
                _tableChild.DataSet.Relations.Add(relation);
            }

            return table;
        }

        internal DataTable InstantiateSimpleTable(DataSet dataSet, XmlElement node) {
            string          typeName;
            XmlAttributeCollection      attrs = node.Attributes;
            DataTable       table;
            int             minOccurs = 1;
            int             maxOccurs = 1;

            typeName = GetInstanceName(node);
            table = dataSet.Tables[typeName, _schemaUri];
            if (table != null) {
                throw ExceptionBuilder.DuplicateDeclaration(typeName);
            }
            String tbName = XmlConvert.DecodeName(typeName);
            table = new DataTable(tbName);
            

            table.Namespace = _schemaUri;
            GetMinMax(node, ref minOccurs, ref maxOccurs);
            table.MinOccurs = minOccurs;
            table.MaxOccurs = maxOccurs;
            SetProperties(table, attrs);
            table.repeatableElement = true;
            
            HandleColumn((XmlElement) node, table);
            
            table.Columns[0].ColumnName = tbName + "_Column";
            _ds.Tables.Add(table);


            return table;
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xmldiffloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XMLDiffLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Runtime.Serialization.Formatters;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Xml;
    
    internal class XMLDiffLoader {

    internal void LoadDiffGram(DataSet ds, XmlReader reader) {
            while (reader.LocalName == Keywords.SQL_BEFORE && reader.NamespaceURI==Keywords.DFFNS)  {
                ProcessDiffs(ds, reader);
				reader.Read(); // now the reader points to the error section
            }

            while (reader.LocalName == Keywords.MSD_ERRORS && reader.NamespaceURI==Keywords.DFFNS) {
				ProcessErrors(ds, reader);
				Debug.Assert(reader.LocalName == Keywords.MSD_ERRORS && reader.NamespaceURI==Keywords.DFFNS, "something fishy");
				reader.Read(); // pass the end of errors tag
			}

        }

        internal void ProcessDiffs(DataSet ds, XmlReader ssync) {
            DataTable tableBefore;
            DataRow row;
            int oldRowRecord;
            int pos = -1;

            int iSsyncDepth = ssync.Depth; 
			ssync.Read(); // pass the before node.

            while (iSsyncDepth < ssync.Depth) {
                tableBefore = null;
                string diffId = null;

                oldRowRecord = -1;

                // the diffgramm always contains sql:before and sql:after pairs

                int iTempDepth = ssync.Depth;

				diffId = ssync.GetAttribute(Keywords.DIFFID, Keywords.DFFNS);
                bool hasErrors = (bool) (ssync.GetAttribute(Keywords.HASERRORS, Keywords.DFFNS) == Keywords.TRUE);
                oldRowRecord = ReadOldRowData(ds, ref tableBefore, ref pos, ssync);
 
                if (tableBefore == null) 
                    throw ExceptionBuilder.DiffgramMissingSQL();

                row = (DataRow)ds.RowDiffId[diffId];
				if (row != null) {
                    row.oldRecord = oldRowRecord ;
                    tableBefore.recordManager[oldRowRecord] = row;
                } else {
                    row = tableBefore.NewEmptyRow();
                    tableBefore.recordManager[oldRowRecord] = row;
                    row.oldRecord = oldRowRecord;
                    row.newRecord = oldRowRecord;
                    tableBefore.Rows.DiffInsertAt(row, pos);
                    row.Delete();
                    if (hasErrors)
                        ds.RowDiffId[diffId] = row;
                }
            }

            return; 
        }

        internal void ProcessErrors(DataSet ds, XmlReader ssync) {
            DataTable table;

            int iSsyncDepth = ssync.Depth;
			ssync.Read(); // pass the before node.

            while (iSsyncDepth < ssync.Depth) {
                table = ds.Tables[XmlConvert.DecodeName(ssync.LocalName), ssync.NamespaceURI];
                if (table == null) 
                    throw ExceptionBuilder.DiffgramMissingSQL();
				string diffId = ssync.GetAttribute(Keywords.DIFFID, Keywords.DFFNS);
                DataRow row = (DataRow)ds.RowDiffId[diffId];
				string rowError = ssync.GetAttribute(Keywords.MSD_ERROR, Keywords.DFFNS);
				if (rowError != null)
					row.RowError = rowError;
				int iRowDepth = ssync.Depth;
	            ssync.Read(); // we may be inside a column
				while (iRowDepth < ssync.Depth) {
					DataColumn col = table.Columns[XmlConvert.DecodeName(ssync.LocalName), ssync.NamespaceURI];
					//if (col == null)
					// throw exception here
					string colError = ssync.GetAttribute(Keywords.MSD_ERROR, Keywords.DFFNS);
					row.SetColumnError(col, colError);
					ssync.Read();
				}
                while (ssync.NodeType == XmlNodeType.EndElement)
                    ssync.Read();

            }

            return; 
        }
        private int ReadOldRowData(DataSet ds, ref DataTable table, ref int pos, XmlReader row) {
            // read table information
            table = ds.Tables[XmlConvert.DecodeName(row.LocalName), row.NamespaceURI];
            int iRowDepth = row.Depth;
            string value = null;

            if (table == null)
                throw ExceptionBuilder.DiffgramMissingTable(XmlConvert.DecodeName(row.LocalName));

            
            value = row.GetAttribute(Keywords.ROWORDER, Keywords.MSDNS);
            if ((value != null) && (value.Length>0))
                pos = (Int32) Convert.ChangeType(value, typeof(Int32));

            int record = table.NewRecord();
            foreach (DataColumn col in table.Columns) {
                col[record] = DBNull.Value;
            }

            foreach (DataColumn col in table.Columns) {
                if ((col.ColumnMapping == MappingType.Element) ||
                    (col.ColumnMapping == MappingType.SimpleContent))
                    continue;

                if (col.ColumnMapping == MappingType.Hidden)
                    value = row.GetAttribute("hidden"+col.EncodedColumnName, Keywords.MSDNS);
                else
                    value = row.GetAttribute(col.EncodedColumnName, col.Namespace);

                if (value == null)
                    continue;

                col[record] = col.ConvertXmlToObject(value);
            }

            row.Read();
            if (row.Depth <= iRowDepth) {
                // the node is empty
                return record;
            }

            if (table.XmlText != null) {
                DataColumn col = table.XmlText;
                col[record] = col.ConvertXmlToObject(row.ReadString());
            }
            else {
                while (row.Depth > iRowDepth)  {
                    String ln =XmlConvert.DecodeName( row.LocalName) ;
                    String ns = row.NamespaceURI;
                    DataColumn column = table.Columns[ln, ns];

                    if (column == null) {
                        while((row.NodeType != XmlNodeType.EndElement) && (row.LocalName!=ln) && (row.NamespaceURI!=ns))
                            row.Read(); // consume the current node
                        row.Read(); // now points to the next column
                        continue;// add a read here!
                    }


                    int iColumnDepth = row.Depth;
                    row.Read();
                    if (row.Depth > iColumnDepth) { //we are inside the column
                        if (row.NodeType == XmlNodeType.Text) {
                            String text = row.ReadString();
                            column[record] = column.ConvertXmlToObject(text);

                            row.Read(); // now points to the next column
                        }
                    }
                    else {
                        // <element></element> case
                        if (column.DataType == typeof(string))
                            column[record] = string.Empty;
                    }
                }
            }
            row.Read(); //now it should point to next row
            return record;
        }

    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\updatestatus.cs ===
//------------------------------------------------------------------------------
// <copyright file="updatestatus.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\updatestatus.uex' path='docs/doc[@for="UpdateStatus"]/*' />
    /// <devdoc>
    /// </devdoc>
    public enum UpdateStatus {
        /// <include file='doc\updatestatus.uex' path='docs/doc[@for="UpdateStatus.Continue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Continue = 0,
        /// <include file='doc\updatestatus.uex' path='docs/doc[@for="UpdateStatus.ErrorsOccurred"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ErrorsOccurred = 1,
        /// <include file='doc\updatestatus.uex' path='docs/doc[@for="UpdateStatus.SkipCurrentRow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SkipCurrentRow = 2,
        /// <include file='doc\updatestatus.uex' path='docs/doc[@for="UpdateStatus.SkipAllRemainingRows"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SkipAllRemainingRows = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xmlreadmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlReadMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\XmlReadMode.uex' path='docs/doc[@for="XmlReadMode"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum XmlReadMode {    
        /// <include file='doc\XmlReadMode.uex' path='docs/doc[@for="XmlReadMode.Auto"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Auto = 0,
        /// <include file='doc\XmlReadMode.uex' path='docs/doc[@for="XmlReadMode.ReadSchema"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ReadSchema = 1,
        /// <include file='doc\XmlReadMode.uex' path='docs/doc[@for="XmlReadMode.IgnoreSchema"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IgnoreSchema = 2,
        /// <include file='doc\XmlReadMode.uex' path='docs/doc[@for="XmlReadMode.InferSchema"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InferSchema = 3,
        /// <include file='doc\XmlReadMode.uex' path='docs/doc[@for="XmlReadMode.DiffGram"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DiffGram = 4,
        /// <include file='doc\XmlReadMode.uex' path='docs/doc[@for="XmlReadMode.SqlXml"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Fragment = 5
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xmlsaver.cs ===
//------------------------------------------------------------------------------
// <copyright file="xmlsaver.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Xml;
    using System.Globalization;
    using System.Collections;
    using System.ComponentModel;    
    using System.Diagnostics;    
    using System.IO;    

    internal enum SchemaFormat {
        Public = 1,
        Remoting = 2,
        WebService = 3
    }
    
    /// <include file='doc\xmlsaver.uex' path='docs/doc[@for="XmlTreeGen"]/*' />
    /// <devdoc>
    ///
    /// </devdoc>
    internal sealed class XmlTreeGen {
        ArrayList ConstraintNames;
        Hashtable namespaces;
        Hashtable autogenerated;
        Hashtable prefixes;

        DataSet _ds;
        XmlDocument _dc;
        XmlElement _sRoot;
        int prefixCount = 0;
        private SchemaFormat schFormat = SchemaFormat.Public;
        private string filePath = null;
        private string fileName = null;
        private string fileExt = null;
        XmlElement dsElement = null;
        XmlElement constraintSeparator = null;

        internal XmlTreeGen(SchemaFormat format) {
            this.schFormat = format;
        }

        internal static void AddXdoProperties(Object instance, XmlElement root, XmlDocument xd) {
            if (instance == null) {
                return;
            }

            PropertyDescriptorCollection pds = TypeDescriptor.GetProperties(instance) ;
            
            bool known = (instance is DataSet) || (instance is DataTable) || (instance is DataColumn) || (instance is DataRelation);

            if (!known) {
                return;
            }

            for (int i = 0 ; i < pds.Count ; i++) {
                AddXdoProperty(pds[i], instance, root, xd);
            }
            return;
        }

        internal static void AddExtendedProperties(PropertyCollection props, XmlElement node) {
            AddExtendedProperties(props, node, null);
        }

        internal static void AddExtendedProperties(PropertyCollection props, XmlElement node, Type type) {
            if(props != null) {
                foreach (Object o in props.Keys) {
                    String s = (String) Convert.ToString(o);
                    String v = (String) Convert.ToString(props[s]);
                    if (type == typeof(DataRelation))
                        s = Keywords.MSD_REL_PREFIX + s;
                    if (type == typeof(ForeignKeyConstraint))
                        s = Keywords.MSD_FK_PREFIX + s;
                    node.SetAttribute(XmlConvert.EncodeName(s), Keywords.MSPROPNS, v);
                }
            }
        }


        internal static void AddXdoProperty(PropertyDescriptor pd, Object instance, XmlElement root, XmlDocument xd) {
            Type type = pd.PropertyType;

            if (type != typeof(string) &&
                type != typeof(bool) &&
                type != typeof(Type) &&
                type != typeof(object) &&
                type != typeof(CultureInfo) &&
                type != typeof(Int64) &&
                type != typeof(Int32)) {
                return;
            }

            if (!pd.ShouldSerializeValue(instance) || !pd.Attributes.Contains(DesignerSerializationVisibilityAttribute.Visible)) {
                return;
            }

            Object propInst = pd.GetValue(instance) ;

            if (propInst is InternalDataCollectionBase)
                return;

            if (propInst is PropertyCollection) {
                return;
            }
            // SDUB: perf: Why not have this as a table?
            // there are several xdo properties that equal to some xml attributes, we should not explicitly ouput them.
            if (
                0 == String.Compare(pd.Name, "Namespace"    , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "PrimaryKey"   , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "ColumnName"   , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "DefaultValue" , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "TableName"    , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "DataSetName"  , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "AllowDBNull"  , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "Unique"       , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "NestedInDataSet" , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "Locale"       , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "CaseSensitive", false, CultureInfo.InvariantCulture)
            ) {
                return;
            }

            if (instance is DataColumn) {
                if (0 == String.Compare(pd.Name, "DataType", false, CultureInfo.InvariantCulture)) {
                    DataColumn col = (DataColumn)instance;
                    string dt = XmlDataTypeName(col.DataType);
                    if (dt.Length == 0) {
                        root.SetAttribute(Keywords.MSD_DATATYPE, Keywords.MSDNS, col.DataType.AssemblyQualifiedName);
#if DEBUG
                        if (CompModSwitches.XmlWriter.TraceVerbose) {
                            Debug.WriteLine("Adding AttrNode " + Keywords.MSD_DATATYPE + " = " + col.DataType.FullName );
                        }
#endif
                    }
                    return;
                }
                if (0 == String.Compare(pd.Name, "Attribute", false, CultureInfo.InvariantCulture)) {
                    return;
                }
            }

            string textValue = pd.Converter.ConvertToString(propInst) ;
            root.SetAttribute(pd.Name, Keywords.MSDNS, textValue);
#if DEBUG
            if (CompModSwitches.XmlWriter.TraceVerbose) {
                Debug.WriteLine("Adding AttrNode " + pd.Name + " = " + textValue );
            }
#endif
            return;
        }

        internal static string XmlDataTypeName(Type type) {
            if (type == typeof(Char))
                return "_";         // has to have SimpleType in this column.
            if (type == typeof(Byte[]))
                return "base64Binary";       // has to have SimpleType in this column.
            if (type == typeof(DateTime))
                return "dateTime";
            if (type == typeof(TimeSpan))
                return "duration";
            if (type == typeof(Decimal))
                return "decimal";
            if (type == typeof(int))
                return "int";
            if (type == typeof(Boolean))
                return "boolean";
            if (type == typeof(Single))
                return "float";
            if (type == typeof(double))
                return "double";
            if (type == typeof(SByte))
                return "byte";
            if (type == typeof(Byte))
                return "unsignedByte";
            if (type == typeof(Int16))
                return "short";
            if (type == typeof(Int32))
                return "int";
            if (type == typeof(Int64))
                return "long";
            if (type == typeof(UInt16))
                return "unsignedShort";
            if (type == typeof(UInt32))
                return "unsignedInt";
            if (type == typeof(UInt64))
                return "unsignedLong";
            if (type == typeof(Uri))
                return "anyURI";

            return String.Empty;
        }

        private void GenerateConstraintNames(DataTable table) {
          
            foreach(Constraint constr in table.Constraints) {
                string name = constr.ConstraintName;
                int nameInt = 0;

                while (ConstraintNames.Contains(name)) 
                {
                    name= table.TableName + '_' +constr.ConstraintName;
                    if (nameInt > 0) 
                        name = name + '_'  + nameInt.ToString();
                    nameInt++;
                }
            
                ConstraintNames.Add(name);
                constr.SchemaName = name;
            }
        }

        private void GenerateConstraintNames(DataSet ds) {
        
            DataTable[] tables = new DataTable[ds.Tables.Count];
            ds.Tables.CopyTo(tables, 0);
            
            for (int i = 0; i < tables.Length; i++) {
                GenerateConstraintNames(tables[i]);
            }            
        }

        //Does the DS or ANY object in it have ExtendedProperties?
        private static bool _PropsNotEmpty(PropertyCollection props) {
            return props != null && props.Count != 0;
        }

        private bool HaveExtendedProperties(DataSet ds) {
            if(_PropsNotEmpty(ds.extendedProperties)) {
                return true;
            }
            for(int t = 0; t < ds.Tables.Count; t ++) {
                DataTable table = ds.Tables[t];
                if(_PropsNotEmpty(table.extendedProperties)) {
                    return true;
                }
                for(int c = 0; c < table.Columns.Count; c ++) {
                    if(_PropsNotEmpty(table.Columns[c].extendedProperties)) {
                        return true;
                    }
                }
            }
            // What is the best way to enumerate relations? from DataSet of from DataTable?
            for(int r = 0; r < ds.Relations.Count; r ++) {
                if(_PropsNotEmpty(ds.Relations[r].extendedProperties)) {
                    return true;
                }
            }
            // What about constraints?
            return false;                            
        }// HaveExtendedProperties
        
        internal void WriteSchemaRoot(XmlDocument xd, XmlElement rootSchema, string targetNamespace) {
            rootSchema.SetAttribute(Keywords.XSDID, XmlConvert.EncodeLocalName(_ds.DataSetName));
            if (targetNamespace != string.Empty) {
                rootSchema.SetAttribute(Keywords.TARGETNAMESPACE, targetNamespace );
                rootSchema.SetAttribute(Keywords.XMLNS_MSTNS, targetNamespace );
            }
            // Add the namespaces
            // rootSchema.SetAttribute(Keywords.XMLNS, Keywords.XSD_ATOM.String));
            rootSchema.SetAttribute(Keywords.XMLNS, targetNamespace);
            rootSchema.SetAttribute(Keywords.XMLNS_XSD, Keywords.XSDNS);
            rootSchema.SetAttribute(Keywords.XMLNS_MSDATA, Keywords.MSDNS);
            if(HaveExtendedProperties(_ds)) {
                rootSchema.SetAttribute(Keywords.XMLNS_MSPROP, Keywords.MSPROPNS);
            }

            if (targetNamespace != "") {
                rootSchema.SetAttribute(Keywords.XSD_ATTRIBUTEFORMDEFAULT, Keywords.QUALIFIED);
                rootSchema.SetAttribute(Keywords.XSD_ELEMENTFORMDEFAULT, Keywords.QUALIFIED);
            }
        }

        internal void SetupAutoGenerated(DataSet ds){
            foreach (DataTable dt in ds.Tables) {
                foreach (DataColumn col in dt.Columns) {
                    if (AutoGenerated(col))
                        autogenerated[col] = col;
                }
                foreach (Constraint cs in dt.Constraints) {
                    if (cs is ForeignKeyConstraint) {
                        ForeignKeyConstraint fk = (ForeignKeyConstraint) cs;
                        if (AutoGenerated(fk))
                            autogenerated[fk] = fk;
                        else {
                            if (autogenerated[fk.Columns[0]] != null)
                                autogenerated[fk.Columns[0]] = null;

                            if (autogenerated[fk.RelatedColumns[0]] != null)
                                autogenerated[fk.RelatedColumns[0]] = null;
                                // special case of the ghosted constraints:
                                UniqueConstraint _constraint = (UniqueConstraint) fk.RelatedTable.Constraints.FindConstraint( new UniqueConstraint( "TEMP", fk.RelatedColumns));

                                if (_constraint == null)
                                    continue;

                                if(autogenerated[_constraint] != null)
                                    autogenerated[_constraint] = null;
                                if(autogenerated[_constraint.Key.Columns[0]] != null)
                                    autogenerated[_constraint.Key.Columns[0]] = null;
                        }
                    }
                    else {
                        UniqueConstraint unique = (UniqueConstraint) cs;
                        if (AutoGenerated(unique))
                            autogenerated[unique] = unique;
                        else {
                            if (autogenerated[unique.Key.Columns[0]] != null)
                                autogenerated[unique.Key.Columns[0]] = null; 
                        }
                    }
                }
            }
        }

        internal XmlElement SchemaTree(XmlDocument xd, DataSet ds) {
            ConstraintNames = new ArrayList();
            autogenerated = new Hashtable();
            bool genSecondary = filePath != null;
            dsElement = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);

            DataTable   []  top;
            bool            fFlat = false;
            _ds = ds;
            _dc = xd;
            if (schFormat != SchemaFormat.Remoting) {
                namespaces = new Hashtable();
                prefixes = new Hashtable();
            }

            XmlElement rootSchema = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SCHEMA, Keywords.XSDNS);
            _sRoot = rootSchema;
            WriteSchemaRoot(xd, rootSchema, _ds.Namespace);

            if (schFormat != SchemaFormat.Remoting) {
                namespaces[_ds.Namespace] = rootSchema;
                if (_ds.Namespace == "")
                    prefixes[_ds.Namespace] = null;
                else {
                    // generate a prefix for the dataset schema itself.
                    rootSchema.SetAttribute(Keywords.XMLNS_MSTNS, _ds.Namespace );
                    prefixes[_ds.Namespace] = "mstns";
                }
            }

            // Generate all the constraint names            
            GenerateConstraintNames(ds);
            // Setup AutoGenerated table
            if (schFormat != SchemaFormat.Remoting) 
                SetupAutoGenerated(ds);


            //
            // Output all top level elements, which will recursively invoke to other tables.
            //
            
            top = ds.TopLevelTables();
            if (top.Length == 0) {
                // return an empty schema for now.
                // probably we need to throw an exception
                FillDataSetElement(xd, ds);
                rootSchema.AppendChild(dsElement);
                AddXdoProperties(_ds, dsElement, xd );
                AddExtendedProperties(ds.extendedProperties, dsElement);
                return rootSchema;
            }
 
            // Fill out dataset element
            XmlElement dsCompositor = FillDataSetElement(xd, ds);

            constraintSeparator =  xd.CreateElement(Keywords.XSD_PREFIX, "SHOULDNOTBEHERE", Keywords.XSDNS);
            dsElement.AppendChild(constraintSeparator);
            // DataSet properties
            AddXdoProperties(_ds, dsElement, xd );
            AddExtendedProperties(ds.extendedProperties, dsElement);


            for (int i = 0; i < top.Length; i++) {
                XmlElement el = HandleTable(top[i], xd, rootSchema);
                if ((_ds.Namespace == top[i].Namespace) || (top[i].Namespace == "") || (schFormat == SchemaFormat.Remoting)) {
                    bool fNestedInDataset = top[i].fNestedInDataset;
                    
                    if ((_ds.Namespace != "") && (top[i].Namespace == ""))
                        fNestedInDataset = true;

                    if ((top[i].nestedParentRelation!= null) && (top[i].nestedParentRelation.ParentTable == top[i]))
                        fNestedInDataset = false;  

                    if(fNestedInDataset) { //deal with maxOccurs properly
	                if (top[i].MinOccurs != 1) {
	                    el.SetAttribute(Keywords.MINOCCURS, top[i].MinOccurs.ToString());
	                  }
	                if (top[i].MaxOccurs == -1){
	                    el.SetAttribute(Keywords.MAXOCCURS, Keywords.ZERO_OR_MORE);
	                  }
	                else if (top[i].MaxOccurs != 1){
	                    el.SetAttribute(Keywords.MAXOCCURS, top[i].MaxOccurs.ToString());
	                  }
                    }

                    if (!fNestedInDataset) {
                            rootSchema.AppendChild(el);
                            XmlElement node = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
                            if ((_ds.Namespace == top[i].Namespace)  || (top[i].Namespace == "") || (schFormat == SchemaFormat.Remoting))
                                node.SetAttribute(Keywords.REF, top[i].EncodedTableName);
                            else
                                node.SetAttribute(Keywords.REF, ((string)prefixes[top[i].Namespace])+':'+top[i].EncodedTableName);
                    
                            dsCompositor.AppendChild(node);
                        }
                    else
                        dsCompositor.AppendChild(el);
                    }
                else {
                    AppendChildWithoutRef(rootSchema, top[i].Namespace, el, Keywords.XSD_ELEMENT);
                    XmlElement node = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
                    node.SetAttribute(Keywords.REF, ((string)prefixes[top[i].Namespace])+':'+top[i].EncodedTableName);
                    dsCompositor.AppendChild(node);
                }
            }


            dsElement.RemoveChild(constraintSeparator);
            rootSchema.AppendChild(dsElement);

            // Output all non-heirarchical relations without constraints
            DataRelationCollection rels = ds.Relations;

            XmlElement nodeAnn = null;
            XmlElement nodeApp = null;

            for (int i = 0; i < rels.Count; ++i) {
                DataRelation rel = rels[i];

                if (!rel.Nested || fFlat) {
                    if (rel.ChildKeyConstraint == null) {
                        if (nodeAnn == null) {
                            nodeAnn = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ANNOTATION, Keywords.XSDNS);
                            rootSchema.AppendChild(nodeAnn);

                            nodeApp = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_APPINFO, Keywords.XSDNS);
                            nodeAnn.AppendChild(nodeApp);
                        }
                        Debug.Assert(nodeApp != null, "Need to create <application..> node first.");
                        nodeApp.AppendChild(HandleRelation(rel, xd));
                    }
                }
            }        


            XmlComment comment = null;
            if(schFormat != SchemaFormat.Remoting)
                foreach(string ns in namespaces.Keys)
                {
                    if (ns == _ds.Namespace || ns=="")
                        continue;
                    XmlElement _import =  xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_IMPORT, Keywords.XSDNS);
                    _import.SetAttribute(Keywords.XSD_NAMESPACE, ns);
                    if (schFormat != SchemaFormat.WebService)
                        _import.SetAttribute(Keywords.XSD_SCHEMALOCATION, fileName + "_" + prefixes[ns]+".xsd");
                    ((XmlNode)rootSchema).PrependChild((XmlNode)_import);

                    if (!genSecondary) {
                        if (comment == null)
                            comment = _dc.CreateComment("ATTENTION: This schema contains references to other imported schemas");
                        continue;
                    }

                    XmlTextWriter xw = new XmlTextWriter( filePath+ fileName + "_" + prefixes[ns]+".xsd", null );
                    try {
                        xw.Formatting = Formatting.Indented;
                        xw.WriteStartDocument(true);
                        XmlElement tNode = (XmlElement) namespaces[ns] ;
                        _dc.AppendChild( tNode );
                        
                        foreach(string imp_ns in namespaces.Keys)
                        {
                            if (ns == imp_ns)
                                continue; // don't write out yourself
                            string prefix = (string) prefixes[imp_ns];
                            if (prefix == null) // only for dataset.Namespace == empty
                                continue; // do nothing
                            tNode.SetAttribute("xmlns:"+prefix, imp_ns);
                            XmlElement _import2 =  _dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_IMPORT, Keywords.XSDNS);
                            _import2.SetAttribute(Keywords.XSD_NAMESPACE, imp_ns);
                            if (imp_ns == _ds.Namespace)
                                _import2.SetAttribute(Keywords.XSD_SCHEMALOCATION, fileName + fileExt); // for the dataset namespace don't append anything
                            else
                                _import2.SetAttribute(Keywords.XSD_SCHEMALOCATION, fileName + "_" + prefix +".xsd");
                            ((XmlNode)tNode).PrependChild((XmlNode)_import2);
                        }
                        _dc.Save(xw);
                        _dc.RemoveChild( tNode );
                        xw.WriteEndDocument();
                    }
                    finally {
                        xw.Close();
                    }
                }
        
            if (comment != null)
                ((XmlNode)rootSchema).PrependChild((XmlNode)comment);

            return rootSchema;
        }

        internal XmlElement SchemaTree(XmlDocument xd, DataTable dt) {
            dsElement = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
            ConstraintNames = new ArrayList();
            _ds = dt.DataSet;
            _dc = xd;
            if (schFormat != SchemaFormat.Remoting) {
                namespaces = new Hashtable();
                prefixes = new Hashtable();
                autogenerated = new Hashtable();
            }

            XmlElement rootSchema = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SCHEMA, Keywords.XSDNS);
            _sRoot = rootSchema;
            WriteSchemaRoot(xd, rootSchema, dt.Namespace);

            XmlElement dsCompositor = FillDataSetElement(xd, _ds);

            constraintSeparator =  xd.CreateElement(Keywords.XSD_PREFIX, "SHOULDNOTBEHERE", Keywords.XSDNS);
            dsElement.AppendChild(constraintSeparator);


            if (schFormat != SchemaFormat.Remoting) {
                namespaces[_ds.Namespace] = rootSchema;
                prefixes[_ds.Namespace] = null;
            }

            // Generate all the constraint names            
            GenerateConstraintNames(dt);

            //
            // Output all top level elements, which will recursively invoke to other tables.
            //
            
            XmlElement el = HandleTable(dt, xd, rootSchema, false);
            rootSchema.AppendChild(el);

            dsElement.RemoveChild(constraintSeparator);
            rootSchema.AppendChild(dsElement);

            return rootSchema;
        }

        internal XmlElement FillDataSetElement(XmlDocument xd, DataSet ds) {
            dsElement.SetAttribute(Keywords.NAME, XmlConvert.EncodeLocalName(ds.DataSetName));
            dsElement.SetAttribute(Keywords.MSD_ISDATASET, Keywords.MSDNS, Keywords.TRUE);
            
            // Add CaseSensitive and locale properties
            if (ds.CaseSensitive)
                dsElement.SetAttribute(Keywords.MSD_CASESENSITIVE, Keywords.MSDNS, Keywords.TRUE);
            if (!ds.Locale.Equals(new CultureInfo(0x409)))
                dsElement.SetAttribute(Keywords.MSD_LOCALE, Keywords.MSDNS, _ds.Locale.ToString());

            XmlElement type = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_COMPLEXTYPE, Keywords.XSDNS);
            dsElement.AppendChild(type);
            XmlElement compositor = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_CHOICE, Keywords.XSDNS);
            compositor.SetAttribute(Keywords.MAXOCCURS, Keywords.ZERO_OR_MORE);
            type.AppendChild(compositor);

            return compositor;
        }
        
        internal void SetPath(XmlWriter xw){
            XmlTextWriter textw = xw as XmlTextWriter;
            if (textw == null)
                return;
            
            FileStream fs = textw.BaseStream as FileStream;

            if (fs == null)
                return;

            this.filePath = Path.GetDirectoryName(fs.Name);
            this.fileName = Path.GetFileNameWithoutExtension(fs.Name);
            this.fileExt = Path.GetExtension(fs.Name);
            if (this.filePath != String.Empty)
                this.filePath  = filePath + "\\";
        }
        
        internal void Save(DataSet ds, XmlWriter xw) {
            XmlDocument doc = new XmlDocument();
            SetPath(xw);
            XmlElement rootSchema = SchemaTree(doc, ds);
            doc.AppendChild( rootSchema );
            doc.Save(xw);
        }
        
        internal void Save(DataTable dt, XmlWriter xw) {
            XmlDocument doc = new XmlDocument();
            XmlElement rootSchema = SchemaTree(doc, dt);
            doc.AppendChild( rootSchema );
            doc.Save(xw);
        }

       
        internal XmlElement HandleRelation(DataRelation rel, XmlDocument dc) {
            XmlElement root = dc.CreateElement(Keywords.MSD, Keywords.MSD_RELATION, Keywords.MSDNS);

            // convert relation name to valid xml name 
            root.SetAttribute( Keywords.NAME,  XmlConvert.EncodeLocalName( rel.RelationName ));

            string text = null;

            root.SetAttribute(Keywords.MSD_PARENT, Keywords.MSDNS, rel.ParentKey.Table.EncodedTableName);
            root.SetAttribute(Keywords.MSD_CHILD, Keywords.MSDNS, rel.ChildKey.Table.EncodedTableName);

            DataColumn[] key = rel.ParentKey.columns;
            text = key[0].EncodedColumnName;
            for (int i = 1; i < key.Length; i++) {
                text += Keywords.MSD_KEYFIELDSEP + key[i].EncodedColumnName;
            }
            root.SetAttribute( Keywords.MSD_PARENTKEY, Keywords.MSDNS, text );

            key = rel.ChildKey.columns;
            text = key[0].EncodedColumnName;
            for (int i = 1; i < key.Length; i++) {
                text += Keywords.MSD_KEYFIELDSEP + key[i].EncodedColumnName;
            }
            root.SetAttribute( Keywords.MSD_CHILDKEY, Keywords.MSDNS, text);
            AddExtendedProperties(rel.extendedProperties, root);
            return root;                
        }

        private static XmlElement FindSimpleType(XmlElement schema, string name) {
            for (XmlNode n = schema.FirstChild; n != null; n = n.NextSibling) {
                if (n is XmlElement) {
                    XmlElement e = (XmlElement) n;
                    if(e.GetAttribute(Keywords.NAME) == name) {
                        return e;
                    }
                }
            }
            return null;
        }// FindSimpleType

        internal XmlElement GetSchema(string NamespaceURI) {
            XmlElement schemaEl = (XmlElement) namespaces[NamespaceURI];
            if (schemaEl == null) {
                schemaEl = _dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SCHEMA, Keywords.XSDNS);
                WriteSchemaRoot(_dc, schemaEl, NamespaceURI);
                if (NamespaceURI != "") {
                    string prefix = Keywords.APP+Convert.ToString(++prefixCount);
                    _sRoot.SetAttribute("xmlns:"+prefix, NamespaceURI);
                    schemaEl.SetAttribute("xmlns:"+prefix, NamespaceURI);
                    prefixes[NamespaceURI] = prefix;
                } 
                namespaces[NamespaceURI] = schemaEl;
            }
            return schemaEl;
        }

        internal void HandleColumnType(DataColumn col, XmlDocument dc, XmlElement root, XmlElement schema) {
            string keyword = Keywords.TYPE;
            if (col.ColumnMapping == MappingType.SimpleContent)
                keyword = Keywords.BASE; 

            if (col.SimpleType != null) {
                // generate simpleType node

                XmlNode type = col.SimpleType.ToNode(dc);
                string name = col.SimpleType.Name;

                if (name != null && name.Length != 0) {
                    root.SetAttribute(keyword, name);
                    XmlElement elmSimpeType = FindSimpleType(schema, name);
                    if(elmSimpeType == null) {
                        // if we don't have the defenition for this simpleType yet. Add it
                        schema.AppendChild(type);
                    }else {
#if DEBUG
// enzol: TO DO: replace the constructor with IsEqual(XmlElement)
//                        Debug.Assert(col.SimpleType.IsEqual(new SimpleType(elmSimpeType)), "simpleTypes with the same name have to be the same: "+name);
#endif
                    }
                }
                else {
                    root.AppendChild(type);
                }
            }
            else if (col.XmlDataType != null && col.XmlDataType.Length != 0 && XSDSchema.IsXsdType(col.XmlDataType)) {
                root.SetAttribute(keyword, XSDSchema.QualifiedName(col.XmlDataType));
            }
            else {
                string typeName = XmlDataTypeName(col.DataType);
                if (typeName == null || typeName.Length == 0)
                    typeName = "string";
                root.SetAttribute(keyword, XSDSchema.QualifiedName(typeName));
            }

        }

        internal void AddColumnProperties(DataColumn col, XmlElement root){
            
            if (col.DataType != typeof(String)) {
                string dt = XmlDataTypeName(col.DataType);
                if (dt.Length == 0) {
                    root.SetAttribute(Keywords.MSD_DATATYPE, Keywords.MSDNS, col.DataType.AssemblyQualifiedName);
                }
            }

            if (col.ReadOnly)
                root.SetAttribute("ReadOnly", Keywords.MSDNS, Keywords.TRUE);

            if (col.Expression != "")
                root.SetAttribute("Expression", Keywords.MSDNS, col.Expression);

            if (col.AutoIncrement) {
                root.SetAttribute("AutoIncrement", Keywords.MSDNS, Keywords.TRUE);
            }

            if (col.AutoIncrementSeed !=0 )
                root.SetAttribute("AutoIncrementSeed", Keywords.MSDNS, col.AutoIncrementSeed.ToString());

            if (col.AutoIncrementStep !=1 )
                root.SetAttribute("AutoIncrementStep", Keywords.MSDNS, col.AutoIncrementStep.ToString());

	    if (col.Caption != col.ColumnName)
                root.SetAttribute("Caption", Keywords.MSDNS, col.Caption);

            if (col.Prefix != "")
                root.SetAttribute("Prefix", Keywords.MSDNS, col.Prefix);

        }

        internal XmlElement HandleColumn(DataColumn col, XmlDocument dc, XmlElement schema, bool fWriteOrdinal) {
            XmlElement  root;
            int         minOccurs;

            Debug.Assert(col.ColumnMapping != MappingType.SimpleContent , "Illegal state");

            String refString = (col.ColumnMapping != MappingType.Element) ? Keywords.XSD_ATTRIBUTE : Keywords.XSD_ELEMENT;
            root = dc.CreateElement(Keywords.XSD_PREFIX, refString, Keywords.XSDNS);

            // First add any attributes.  
            root.SetAttribute( Keywords.NAME, col.EncodedColumnName);
            
            if (col.Namespace =="") {
                DataTable _table = col.Table;
                string tgNamespace = _table.typeName.IsEmpty ? _table.Namespace : _table.typeName.Namespace;
                while (tgNamespace == "") {
                    if (_table.nestedParentRelation == null){
                        tgNamespace = _ds.Namespace;
                        break;
                    }
                    if (_table.nestedParentRelation.ParentTable == _table)
                        break;
                        
                    _table = _table.nestedParentRelation.ParentTable;
                    tgNamespace = _table.typeName.IsEmpty ? _table.Namespace : _table.typeName.Namespace;
                }
                if (col.Namespace != tgNamespace)
                    root.SetAttribute( Keywords.FORM, Keywords.UNQUALIFIED);

            }

            if (col.GetType() != typeof(DataColumn))
                AddXdoProperties(col, root, dc);
            else
                AddColumnProperties(col, root);

            AddExtendedProperties(col.extendedProperties, root);
			HandleColumnType(col, dc, root, schema);
            if (col.ColumnMapping == MappingType.Hidden) {
                if (!col.AllowDBNull)
                    root.SetAttribute(Keywords.MSD_ALLOWDBNULL, Keywords.MSDNS, Keywords.FALSE);
                if (col.DefaultValue!=null && (col.DefaultValue != DBNull.Value))
                    if (col.DataType == typeof(bool))
                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, (bool)(col.DefaultValue)? Keywords.TRUE : Keywords.FALSE);
                    else
                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, col.ConvertObjectToXml(col.DefaultValue));
            }

            if (col.DefaultValue!=null && (col.DefaultValue != DBNull.Value) && (col.ColumnMapping != MappingType.Hidden) ) {
                if (col.ColumnMapping == MappingType.Attribute && !col.AllowDBNull ) {
                    if (col.DataType == typeof(bool))
                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, (bool)(col.DefaultValue)? Keywords.TRUE : Keywords.FALSE);
                    else
                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, col.ConvertObjectToXml(col.DefaultValue));
                }
                else {
                    if (col.DataType == typeof(bool))
                        root.SetAttribute(Keywords.DEFAULT, (bool)(col.DefaultValue)? Keywords.TRUE : Keywords.FALSE);
                    else
                        root.SetAttribute(Keywords.DEFAULT, col.ConvertObjectToXml(col.DefaultValue));
                }
            }

            if (schFormat == SchemaFormat.Remoting)
                root.SetAttribute( Keywords.TARGETNAMESPACE, Keywords.MSDNS, col.Namespace);

            else {

	            if ((col.Namespace != (col.Table.typeName.IsEmpty ? col.Table.Namespace : col.Table.typeName.Namespace)) && (col.Namespace != ""))
			 {
	                    XmlElement schNode = GetSchema(col.Namespace);
	                    if (FindTypeNode(schNode, col.EncodedColumnName) == null)
	                        schNode.AppendChild(root);
	                    root = _dc.CreateElement(Keywords.XSD_PREFIX, refString, Keywords.XSDNS);
	                    root.SetAttribute( Keywords.REF, prefixes[ col.Namespace]+":"+ col.EncodedColumnName);
	                    if (col.Table.Namespace!=_ds.Namespace) {
	                        string prefix = (string)prefixes[col.Namespace];
	                        XmlElement tNode = GetSchema(col.Table.Namespace);
	                }
	            	}
            	}


            minOccurs = (col.AllowDBNull) ? 0 : 1;
            
            
            // March 2001 change
            if (col.ColumnMapping == MappingType.Attribute && minOccurs != 0) 
                root.SetAttribute(Keywords.USE, Keywords.REQUIRED);

               
			if (col.ColumnMapping == MappingType.Hidden) {
				root.SetAttribute(Keywords.USE, Keywords.PROHIBITED);
			}
			else 			
                if (col.ColumnMapping != MappingType.Attribute && minOccurs != 1)
                    root.SetAttribute(Keywords.MINOCCURS, minOccurs.ToString());
			
			if ((col.ColumnMapping == MappingType.Element) && fWriteOrdinal)
				root.SetAttribute(Keywords.MSD_ORDINAL,Keywords.MSDNS, col.Ordinal.ToString());
            
            return root;
        }

       
        internal static string TranslateAcceptRejectRule( AcceptRejectRule rule ) {
            switch (rule) {
                case AcceptRejectRule.Cascade:  return "Cascade";
                case AcceptRejectRule.None:     return "None";
                default:                        return null;
            }
        }

        internal static string TranslateRule( Rule rule ) {
            switch (rule) {
                case Rule.Cascade:  return "Cascade";
                case Rule.None:     return "None";
                case Rule.SetNull:  return "SetNull";
                case Rule.SetDefault: return "SetDefault";
                default: return null;
            }
        }

        internal void AppendChildWithoutRef(XmlElement node, string Namespace, XmlElement el, string refString) {
            XmlElement schNode = GetSchema(Namespace);
            if (FindTypeNode(schNode, el.GetAttribute(Keywords.NAME)) == null)
                schNode.AppendChild(el);
        }

        internal XmlElement FindTypeNode(XmlQualifiedName qnType) {
            XmlElement node = null;
            if ((!qnType.IsEmpty) && schFormat != SchemaFormat.Remoting) {
                    node = (XmlElement) namespaces[qnType.Namespace];
                }
            else 
                node = _sRoot;

            return FindTypeNode (node, qnType.Name);
        }

        internal XmlElement FindTypeNode(XmlElement node, string strType) {
            if (node == null)
                return null;
                
            for (XmlNode n = node.FirstChild; n != null; n = n.NextSibling) {
                if (!(n is XmlElement))
                    continue;

                XmlElement child = (XmlElement) n;

                if (XSDSchema.FEqualIdentity(child, Keywords.XSD_ELEMENT, Keywords.XSDNS) || 
                    XSDSchema.FEqualIdentity(child, Keywords.XSD_ATTRIBUTE, Keywords.XSDNS) || 
                    XSDSchema.FEqualIdentity(child, Keywords.XSD_COMPLEXTYPE, Keywords.XSDNS) || 
                    XSDSchema.FEqualIdentity(child, Keywords.XSD_SIMPLETYPE, Keywords.XSDNS)) {
                    if (child.GetAttribute(Keywords.NAME) == strType)
                        return child;
                }
            }
            return null;
        }

        internal XmlElement HandleTable(DataTable table, XmlDocument dc, XmlElement schema) {
            return HandleTable(table, dc, schema, true);
        }
        
        // we write out column Ordinals only if the table contains columns
        // that map both to Attributes and Elements
        
        private bool HasMixedColumns(DataTable table) {
            bool hasAttributes = false;
            bool hasElements = false;
            foreach(DataColumn col in table.Columns) {
                if (!hasElements && col.ColumnMapping == MappingType.Element)
                    hasElements = true;
                if (!hasAttributes && (col.ColumnMapping == MappingType.Attribute || col.ColumnMapping == MappingType.Hidden))
                    hasAttributes = !AutoGenerated(col);
                if (hasAttributes && hasElements)
                    return true;
            }
            return false;
        }

        private bool AutoGenerated(DataColumn col) {
            // for now we use just this simple logic for the columns.

            if (col.ColumnMapping != MappingType.Hidden)
                return false;

            if (col.DataType != typeof(int))
                return false;
                
            string generatedname = col.Table.TableName+"_Id";
            
            if ((col.ColumnName == generatedname) || (col.ColumnName == generatedname+"_0"))
                return true;

            generatedname = "";

            foreach (DataRelation rel in col.Table.ParentRelations) {
                if (!rel.Nested)
                    continue;
                if (rel.ChildColumns.Length != 1)
                    continue;

                if (rel.ChildColumns[0] != col)
                    continue;

                if (rel.ParentColumns.Length != 1)
                    continue;
                
                //ok if we are here it means that we have a 1column-1column relation
                generatedname = rel.ParentColumns[0].Table.TableName+"_Id";
            }

            if ((col.ColumnName == generatedname) || (col.ColumnName == generatedname+"_0"))
                return true;

            return false;
        }
        private bool AutoGenerated(DataRelation rel) {
            string rName = rel.ParentTable.TableName + "_" + rel.ChildTable.TableName;
            if (!rel.RelationName.StartsWith(rName))
                return false;
            if (rel.ExtendedProperties.Count > 0)
                return false;
            return true;
        } 
        private bool AutoGenerated(UniqueConstraint unique) {
            // for now we use just this simple logic for the columns.
            if (!unique.ConstraintName.StartsWith("Constraint"))
                return false;
            if (unique.Key.Columns.Length !=1)
                return false;
            if (unique.ExtendedProperties.Count > 0)
                return false;
            return AutoGenerated(unique.Key.Columns[0]);
        }

        private bool AutoGenerated(ForeignKeyConstraint fk) {
            // for now we use just this simple logic for the columns.
            DataRelation rel = fk.FindParentRelation();
            if (rel == null)
                return false; // otherwise roundtrip will create column

            if (!AutoGenerated(rel))
                return false;

            if (rel.RelationName != fk.ConstraintName)
                return false;

            if (fk.ExtendedProperties.Count > 0)
                return false;

            if (fk.AcceptRejectRule != AcceptRejectRule.None)
                return false;
            if (fk.DeleteRule != Rule.Cascade)
                return false;
            if (fk.DeleteRule != Rule.Cascade)
                return false;

            
            if (fk.RelatedColumns.Length !=1)
                return false;
            return AutoGenerated(fk.RelatedColumns[0]);
        }

        private bool IsAutoGenerated(object o) {
            if (schFormat != SchemaFormat.Remoting)
                return autogenerated[o]!=null;
            return false;
        }

        internal XmlElement HandleTable(DataTable table, XmlDocument dc, XmlElement schema, bool genNested) {

            XmlElement root = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
            bool fWriteOrdinals = false;
            bool fUnqualified = false;

            if ((table.Namespace != _ds.Namespace) && (schFormat == SchemaFormat.Remoting))
                root.SetAttribute( Keywords.TARGETNAMESPACE, Keywords.MSDNS, table.Namespace);
            
            // First add any attributes.  
            root.SetAttribute( Keywords.NAME, table.EncodedTableName );

            if (table.Namespace =="") {
                DataTable _table = table;
                string tgNamespace = _table.Namespace;
                while (tgNamespace == "") {
                    if (_table.nestedParentRelation == null){
                        tgNamespace = _ds.Namespace;
                        break;
                    }
                    if (_table.nestedParentRelation.ParentTable == _table)
                        break;
                        
                    _table = _table.nestedParentRelation.ParentTable;
                    tgNamespace = _table.Namespace;
                }
                if (table.Namespace != tgNamespace) {
                    root.SetAttribute( Keywords.FORM, Keywords.UNQUALIFIED);
                    fUnqualified = true;
                }

            }


            if (!table.caseSensitiveAmbient)
                root.SetAttribute(Keywords.MSD_CASESENSITIVE, Keywords.MSDNS, table.CaseSensitive.ToString());
            if (table.culture!=null)
                root.SetAttribute(Keywords.MSD_LOCALE, Keywords.MSDNS, table.Locale.ToString());

            AddXdoProperties(table, root, dc);

            DataColumnCollection columns = table.Columns;

            int cCount = columns.Count;
            int realCount = 0;

            if (cCount ==1 || cCount ==2)
                for (int i = 0; i < cCount; i++) {
                    DataColumn col = columns[i];

                    if (col.ColumnMapping == MappingType.Hidden) {
                        DataRelationCollection childRelations = table.ChildRelations;
                        for (int j = 0; j < childRelations.Count; j++) {
                            if (childRelations[j].Nested && childRelations[j].ParentKey.columns.Length == 1 && childRelations[j].ParentKey.columns[0] == col)
                                    realCount++;
                        }
                    }
                    
                    if (col.ColumnMapping == MappingType.Element)
                        realCount++;
                }
                         
               
            if ((table.repeatableElement) && (realCount ==1)) {
                // I only have 1 column and that gives me
                // the type for this element
                DataColumn col = table.Columns[0];
                string _typeName = XmlDataTypeName(col.DataType);
                if (_typeName == null || _typeName.Length == 0)
                    _typeName = "string";

                root.SetAttribute(Keywords.TYPE, XSDSchema.QualifiedName(_typeName));
                return root;
            }
         
            // Now add the type information nested inside the element or global.
            XmlElement type = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_COMPLEXTYPE, Keywords.XSDNS);

            if (!table.typeName.IsEmpty && schFormat != SchemaFormat.Remoting) {
                XmlElement typeSchema = GetSchema(table.typeName.Namespace);
                if (table.typeName.Namespace == "")
                    typeSchema = fUnqualified ? GetSchema(_ds.Namespace) : GetSchema(table.Namespace);
                if (FindTypeNode(typeSchema, table.typeName.Name) == null) 
                    typeSchema.AppendChild(type);

                type.SetAttribute(Keywords.NAME, table.typeName.Name);
            }
            else {
                root.AppendChild(type);
            }

            if (!table.typeName.IsEmpty) {
                if (schFormat != SchemaFormat.Remoting)
                    root.SetAttribute( Keywords.TYPE, NewDiffgramGen.QualifiedName((string)prefixes[table.typeName.Namespace], table.typeName.Name) );
                else
                    root.SetAttribute( Keywords.TYPE,  table.typeName.Name );
            }

            XmlElement compositor = null;

            DataColumn colTxt = table.XmlText;

            if (colTxt != null) {
                XmlElement sc = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SIMPLECONTENT , Keywords.XSDNS);

                if (colTxt.GetType() != typeof(DataColumn))
                    AddXdoProperties(colTxt, sc, dc);
                else
                    AddColumnProperties(colTxt, sc);
                AddExtendedProperties(colTxt.extendedProperties, sc);

                 if (colTxt.AllowDBNull)
                     root.SetAttribute(Keywords.XSD_NILLABLE, String.Empty, Keywords.TRUE);
                if (colTxt.DefaultValue!=null && (colTxt.DefaultValue != DBNull.Value))
                    sc.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, colTxt.ConvertObjectToXml(colTxt.DefaultValue));
                    
                sc.SetAttribute(Keywords.MSD_COLUMNNAME, Keywords.MSDNS, colTxt.ColumnName);
				sc.SetAttribute(Keywords.MSD_ORDINAL, Keywords.MSDNS, colTxt.Ordinal.ToString());

                type.AppendChild (sc);
                XmlElement ext = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_EXTENSION, Keywords.XSDNS);
                sc.AppendChild(ext);
                HandleColumnType(colTxt, dc, ext, schema);
                type = ext;
            }

            compositor = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SEQUENCE, Keywords.XSDNS);
            type.AppendChild(compositor);

            fWriteOrdinals = HasMixedColumns(table);
 
            for (int i = 0; i < cCount; i++) {
                DataColumn col = columns[i];

                if (col.ColumnMapping == MappingType.SimpleContent)
                    continue;

                if (col.ColumnMapping == MappingType.Attribute || col.ColumnMapping == MappingType.Element || col.ColumnMapping == MappingType.Hidden ) {
                    if (IsAutoGenerated(col)) // skip automanifactured columns
                        continue; 
                    bool isAttribute = col.ColumnMapping != MappingType.Element;
                    XmlElement el = HandleColumn(col, dc, schema, fWriteOrdinals);

                    XmlElement node = isAttribute ? type : compositor;
                    //bool flag = isAttribute ? col.Namespace == "" : col.Namespace == table.Namespace;
                    node.AppendChild(el);
                }


            }
            
            if ((table.XmlText == null) && (genNested)) {

                DataRelationCollection childRelations = table.ChildRelations;

                for (int j = 0; j < childRelations.Count; j++) {
                    XmlElement NestedTable; 
            
                    if (!childRelations[j].Nested)
                        continue;

                    DataTable childTable = childRelations[j].ChildTable;

                    if (childTable == table) { // o-ho self join
                        NestedTable = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
            
                        NestedTable.SetAttribute( Keywords.REF, table.EncodedTableName );
                    } 
                    else
                        NestedTable = HandleTable(childTable, dc, schema);

                    if (childTable.Namespace == table.Namespace) {
				        NestedTable.SetAttribute(Keywords.MINOCCURS , "0");
				        NestedTable.SetAttribute(Keywords.MAXOCCURS , Keywords.ZERO_OR_MORE);
                    }

                    if ((childTable.Namespace == table.Namespace) || (childTable.Namespace == "") || schFormat == SchemaFormat.Remoting) {
                        compositor.AppendChild(NestedTable);
                    }
                    else {
                        GetSchema(childTable.Namespace).AppendChild(NestedTable);
                        NestedTable = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
                        NestedTable.SetAttribute( Keywords.REF, ((string)prefixes[childTable.Namespace])+':'+childTable.EncodedTableName);
                        compositor.AppendChild(NestedTable);
                    }

                    if (childRelations[j].ChildKeyConstraint != null)
                        continue; // we write the relation using the constraint

                    XmlElement nodeAnn = _dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ANNOTATION, Keywords.XSDNS);
                    NestedTable.PrependChild(nodeAnn);

                    XmlElement nodeApp = _dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_APPINFO, Keywords.XSDNS);
                    nodeAnn.AppendChild(nodeApp);

                    nodeApp.AppendChild(HandleRelation(childRelations[j], dc));

                }
        
            }

            if (compositor != null)
                if (!compositor.HasChildNodes)
                    type.RemoveChild(compositor);

            // Output all constraints.


            ConstraintCollection constraints = table.Constraints;
            XmlElement selector, field;
            String xpathprefix = _ds.Namespace != String.Empty ? Keywords.MSTNS_PREFIX : String.Empty;
            if (schFormat != SchemaFormat.Remoting) {
                GetSchema(table.Namespace); // to ensure prefix handling
                xpathprefix = table.Namespace != String.Empty ? (string) prefixes[table.Namespace] +':' : String.Empty;
            }

            for (int i = 0; i < constraints.Count; i++) {
                XmlElement constraint = null;
                DataColumn[] fields;

                if (constraints[i] is UniqueConstraint) {

                    UniqueConstraint unique = (UniqueConstraint)constraints[i];

                    if (IsAutoGenerated(unique))
                        continue;

                    // special case of the ghosted constraints:
                    fields = unique.Key.Columns;
                
                    
                    constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_UNIQUE, Keywords.XSDNS);

                    // convert constraint name to valid xml name
                    constraint.SetAttribute( Keywords.NAME, XmlConvert.EncodeLocalName( unique.SchemaName ));

                    if (unique.ConstraintName != unique.SchemaName)
                        constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME, Keywords.MSDNS, unique.ConstraintName);

                    AddExtendedProperties(unique.extendedProperties, constraint);


                    selector = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SELECTOR, Keywords.XSDNS);
                    selector.SetAttribute(Keywords.XSD_XPATH, ".//"+xpathprefix+table.EncodedTableName);

                    constraint.AppendChild(selector);
                    

                    if (unique.IsPrimaryKey)
                        constraint.SetAttribute(Keywords.MSD_PRIMARYKEY, Keywords.MSDNS, Keywords.TRUE);

                    for (int k = 0; k < fields.Length; k++) {
                        String EncodedName = xpathprefix+fields[k].EncodedColumnName ;
                        if (schFormat != SchemaFormat.Remoting) {
                            GetSchema(fields[k].Namespace);
                            String xpathcolprefix = fields[k].Namespace != String.Empty ? (string) prefixes[fields[k].Namespace]+':' : String.Empty;
                            EncodedName = xpathcolprefix+fields[k].EncodedColumnName ;
                        }
                        if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))
                            EncodedName = '@' +EncodedName;
                        field = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_FIELD, Keywords.XSDNS);
                        field.SetAttribute(Keywords.XSD_XPATH, EncodedName);

                        constraint.AppendChild(field);
                    }

                    dsElement.InsertBefore(constraint, constraintSeparator);
                }
                else if (constraints[i] is ForeignKeyConstraint && genNested) {
                    ForeignKeyConstraint foreign = (ForeignKeyConstraint)constraints[i];

                    if (IsAutoGenerated(foreign))
                        continue;
                        

                    DataRelation rel = foreign.FindParentRelation();

                    // special case of the ghosted constraints:
                    fields = foreign.RelatedColumns;


                    UniqueConstraint _constraint = (UniqueConstraint) foreign.RelatedTable.Constraints.FindConstraint( new UniqueConstraint( "TEMP", fields));

                    if (_constraint == null) {
                        constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_KEY, Keywords.XSDNS);
                        constraint.SetAttribute( Keywords.NAME, XmlConvert.EncodeLocalName( foreign.SchemaName ));

                        selector = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SELECTOR, Keywords.XSDNS);
                        selector.SetAttribute(Keywords.XSD_XPATH, ".//"+xpathprefix+ foreign.RelatedTable.EncodedTableName);

                        constraint.AppendChild(selector);

                        for (int k = 0; k < fields.Length; k++) {
                            String EncodedName = xpathprefix+fields[k].EncodedColumnName ;
                            if (schFormat != SchemaFormat.Remoting) {
                                GetSchema(fields[k].Namespace);
                                String xpathcolprefix = fields[k].Namespace != String.Empty ? (string) prefixes[fields[k].Namespace]+':' : String.Empty;
                                EncodedName = xpathcolprefix+fields[k].EncodedColumnName ;
                            }
                            if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))
                                EncodedName = '@' +EncodedName;
                            field = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_FIELD, Keywords.XSDNS);
                            field.SetAttribute(Keywords.XSD_XPATH, EncodedName);

                            constraint.AppendChild(field);
                        }

                        dsElement.InsertBefore(constraint, constraintSeparator);
                    }
 
                    constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_KEYREF, Keywords.XSDNS);
                    // convert constraint name to valid xml name
                    constraint.SetAttribute( Keywords.NAME,XmlConvert.EncodeLocalName(  foreign.SchemaName ));

                    if (_constraint == null) 
                        constraint.SetAttribute( Keywords.REFER, XmlConvert.EncodeLocalName( foreign.SchemaName ));
                    else
                        constraint.SetAttribute( Keywords.REFER, XmlConvert.EncodeLocalName( _constraint.SchemaName ));

                    AddExtendedProperties(foreign.extendedProperties, constraint, typeof(ForeignKeyConstraint));

                    if (foreign.ConstraintName != foreign.SchemaName)
                        constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME, Keywords.MSDNS, foreign.ConstraintName);

                    if (null == rel) {
                        constraint.SetAttribute(Keywords.MSD_CONSTRAINTONLY , Keywords.MSDNS, Keywords.TRUE );
                    }else {
                        if (rel.Nested)
                            constraint.SetAttribute(Keywords.MSD_ISNESTED, Keywords.MSDNS, Keywords.TRUE);

                        AddExtendedProperties(rel.extendedProperties, constraint, typeof(DataRelation));
                        if (foreign.ConstraintName != rel.RelationName) {
                            constraint.SetAttribute( Keywords.MSD_RELATIONNAME , Keywords.MSDNS, XmlConvert.EncodeLocalName( rel.RelationName ));
                        }
                    }

                    selector = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SELECTOR, Keywords.XSDNS);
                    selector.SetAttribute(Keywords.XSD_XPATH, ".//"+xpathprefix+table.EncodedTableName);
 
                    constraint.AppendChild(selector);

                    if (foreign.AcceptRejectRule != ForeignKeyConstraint.AcceptRejectRule_Default)
                        constraint.SetAttribute(Keywords.MSD_ACCEPTREJECTRULE, Keywords.MSDNS, 
                                                TranslateAcceptRejectRule(foreign.AcceptRejectRule) );

                    if (foreign.UpdateRule != ForeignKeyConstraint.Rule_Default)
                        constraint.SetAttribute( Keywords.MSD_UPDATERULE, Keywords.MSDNS, TranslateRule(foreign.UpdateRule) );

                    if (foreign.DeleteRule != ForeignKeyConstraint.Rule_Default)
                        constraint.SetAttribute( Keywords.MSD_DELETERULE, Keywords.MSDNS, TranslateRule(foreign.DeleteRule) );

                    fields = foreign.Columns;

                    for (int k = 0; k < fields.Length; k++) {
                        String EncodedName =xpathprefix+ fields[k].EncodedColumnName;
                        if (schFormat != SchemaFormat.Remoting) {
                            GetSchema(fields[k].Namespace);
                            String xpathcolprefix = fields[k].Namespace != String.Empty ? (string) prefixes[fields[k].Namespace]+':' : String.Empty;
                            EncodedName =xpathcolprefix+ fields[k].EncodedColumnName;
                        }
                        if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))
                            EncodedName = '@' +EncodedName;
                        field = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_FIELD, Keywords.XSDNS);
                        field.SetAttribute(Keywords.XSD_XPATH, EncodedName);

                        constraint.AppendChild(field);
                    }

                    dsElement.InsertAfter(constraint, constraintSeparator);
                }
            }

            AddExtendedProperties(table.extendedProperties, root);
            return root;
        }
    } 


  
 internal sealed class NewDiffgramGen {
        internal XmlDocument    _doc;
        internal DataSet        _ds;
        internal XmlWriter      _xmlw;
        private bool fBefore = false;
        private bool fErrors = false;
        internal Hashtable rowsOrder = null;
         

        internal NewDiffgramGen(DataSet ds) {
            _ds = ds;
            _doc = new XmlDocument();
            int rows = 0;
            for (int i = 0; i < ds.Tables.Count; i++) {
                rows += ds.Tables[i].Rows.Count ;
            }
            rowsOrder = new Hashtable(rows);
            for (int i = 0; i < ds.Tables.Count; i++) {
                DataTable dt = ds.Tables[i];
                DataRowCollection rc = dt.Rows;
                rows = rc.Count ;
                for (int j=0; j<rows; j++)
                  rowsOrder[rc[j]] = j;
            }
            
        }

        private bool EmptyDataSet(DataSet ds) {
            for (int i = 0; i < ds.Tables.Count; i++) {
                if (ds.Tables[i].Rows.Count > 0)
                    return false;
            }
            return true;
        }


        internal void Save(XmlWriter xmlw) {
			Save (xmlw, null);
		}

        internal void Save(XmlWriter xmlw, DataTable table) {
            _xmlw = xmlw;

            _xmlw.WriteStartElement(Keywords.DFF, Keywords.DIFFGRAM,  Keywords.DFFNS);
            _xmlw.WriteAttributeString(Keywords.XMLNS, Keywords.MSD, null, Keywords.MSDNS);
//            _xmlw.WriteAttributeString(Keywords.XMLNS, Keywords.UPDG, null, Keywords.UPDGNS);

            if (!EmptyDataSet(_ds))
            {   
                // write the datapart
                new XmlDataTreeWriter(_ds, table).SaveDiffgramData(_xmlw, rowsOrder);

                // Walk the xd using relational apis and create nodes in nodeRoot appropriately.                   

                if (table==null)
					for (int i = 0; i < _ds.Tables.Count; ++i) {
						GenerateTable(_ds.Tables[i]);
					}
				else
					GenerateTable(table);

                if (fBefore)
                    _xmlw.WriteEndElement();  //SQL_BEFORE
                
                if (table==null)
					for (int i = 0; i < _ds.Tables.Count; ++i) {
						GenerateTableErrors(_ds.Tables[i]);
					}
				else
					GenerateTableErrors(table);

                if (fErrors)
                    _xmlw.WriteEndElement();  //ERRORS
            }

            _xmlw.WriteEndElement();
            _xmlw.Flush();
        }

        private void GenerateTable(DataTable table) {
            int rowCount = table.Rows.Count;

            if (rowCount <= 0)
                return;

            for (int rowNum = 0; rowNum < rowCount; ++rowNum)
                GenerateRow(table.Rows[rowNum]);
        }


        private void GenerateTableErrors(DataTable table) {
            int rowCount = table.Rows.Count;
            int colCount = table.Columns.Count;

            if (rowCount <= 0)
                return;

            for (int rowNum = 0; rowNum < rowCount; ++rowNum) {
				bool tableName = false;
				
				DataRow row = table.Rows[rowNum];
                string rowIDString = table.TableName+row.rowID.ToString();
				string prefix = (table.Namespace != "") ? table.Prefix : String.Empty;
				if ((row.HasErrors) && (row.RowError.Length > 0)) {
					if (!fErrors) {
                        _xmlw.WriteStartElement( Keywords.DFF, Keywords.MSD_ERRORS, Keywords.DFFNS );
                        fErrors = true;
                    }
                    _xmlw.WriteStartElement( prefix, row.Table.EncodedTableName, row.Table.Namespace);
				    _xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFID, Keywords.DFFNS, row.Table.TableName+row.rowID.ToString());
                    _xmlw.WriteAttributeString( Keywords.DFF, Keywords.MSD_ERROR, Keywords.DFFNS, row.RowError);
					tableName = true;
				}
				if (colCount <=0)
					continue;
	            for (int colNum = 0; colNum < colCount; ++colNum) {
					DataColumn column = table.Columns[colNum];
					string error = row.GetColumnError(column);
					string columnPrefix = (column.Namespace != "") ? column.Prefix : String.Empty;
					if (error == null || error.Length == 0) {
						continue;
					}

                    if (!tableName) {
						if (!fErrors) {
                            _xmlw.WriteStartElement( Keywords.DFF, Keywords.MSD_ERRORS, Keywords.DFFNS );
                            fErrors = true;
                        }
                            
                        _xmlw.WriteStartElement( prefix, row.Table.EncodedTableName, row.Table.Namespace);
				        _xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFID, Keywords.DFFNS, row.Table.TableName+row.rowID.ToString());
						tableName = true;
                        
					}


					_xmlw.WriteStartElement( columnPrefix, column.EncodedColumnName, column.Namespace);
					_xmlw.WriteAttributeString( Keywords.DFF, Keywords.MSD_ERROR, Keywords.DFFNS, error);

					_xmlw.WriteEndElement();
					

				}

				if(tableName)
					_xmlw.WriteEndElement();
			}
        }

        private void GenerateRow(DataRow row) {
            DataRowState state = row.RowState;
            if ((state == DataRowState.Unchanged ) || (state  == DataRowState.Added)) {
                return;
            }
            if (!fBefore) {
                _xmlw.WriteStartElement( Keywords.DFF, Keywords.SQL_BEFORE, Keywords.DFFNS);
                fBefore = true;
            }

            DataTable table = row.Table;
            int colCount = table.Columns.Count;
            string rowIDString = table.TableName+row.rowID.ToString();
            string parentId = null;
            if ( (state == DataRowState.Deleted )  && (row.Table.nestedParentRelation != null)){
                DataRow parentRow = row.GetParentRow(row.Table.nestedParentRelation, DataRowVersion.Original);
                if (parentRow != null)
                    parentId = parentRow.Table.TableName+parentRow.rowID.ToString();
            }
                

            string tablePrefix = (table.Namespace != "") ? table.Prefix : String.Empty;

            // read value if the TextOnly column (if any)
            object val = (table.XmlText == null ? DBNull.Value : row[table.XmlText, DataRowVersion.Original]);

                    //old row
            _xmlw.WriteStartElement( tablePrefix, row.Table.EncodedTableName, row.Table.Namespace);
            
			_xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFID, Keywords.DFFNS, rowIDString);

            if ( (state == DataRowState.Deleted ) && XmlDataTreeWriter.RowHasErrors(row))
				_xmlw.WriteAttributeString( Keywords.DFF, Keywords.HASERRORS, Keywords.DFFNS, Keywords.TRUE);
            
            if (parentId != null)
			    _xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFPID, Keywords.DFFNS, parentId);
                        
			_xmlw.WriteAttributeString( Keywords.MSD, Keywords.ROWORDER, Keywords.MSDNS, rowsOrder[row].ToString());
            for (int colNum = 0; colNum < colCount; ++colNum) {
                if ((row.Table.Columns[colNum].ColumnMapping == MappingType.Attribute) ||
                    (row.Table.Columns[colNum].ColumnMapping == MappingType.Hidden))
                GenerateColumn(row,  row.Table.Columns[colNum], DataRowVersion.Original);
            }
            for (int colNum = 0; colNum < colCount; ++colNum) {
                if ((row.Table.Columns[colNum].ColumnMapping == MappingType.Element) ||
                    (row.Table.Columns[colNum].ColumnMapping == MappingType.SimpleContent))
                GenerateColumn(row,  row.Table.Columns[colNum], DataRowVersion.Original);
            }
            _xmlw.WriteEndElement();  //old row
        } 

        private void GenerateColumn(DataRow row, DataColumn col, DataRowVersion version) {
            string value = null;

            value = col.GetColumnValueAsString(row, version);
            if (value == null) {
                if (col.ColumnMapping == MappingType.SimpleContent)
                    _xmlw.WriteAttributeString(Keywords.XSI, Keywords.XSI_NIL, Keywords.XSINS, Keywords.TRUE);
                return;
            }
             
            string colPrefix = (col.Namespace != "") ? col.Prefix : String.Empty;
            switch (col.ColumnMapping) {

                case MappingType.Attribute:
                    _xmlw.WriteAttributeString(colPrefix, col.EncodedColumnName, col.Namespace, value);
                    break;

                case MappingType.Hidden:
                    _xmlw.WriteAttributeString(Keywords.MSD, "hidden"+col.EncodedColumnName, Keywords.MSDNS, value);
                    break;

                case MappingType.SimpleContent:
                    _xmlw.WriteString(value);
                    break;

                case MappingType.Element:
                    _xmlw.WriteStartElement( colPrefix, col.EncodedColumnName, col.Namespace);
                    _xmlw.WriteString(value);
                    _xmlw.WriteEndElement();
                    break;
            }
        }

        internal static string QualifiedName(string prefix, string name) {
            if (prefix != null)
                return prefix + ":" + name;

            return name;
        }
    }

    // DataTreeWriter
    internal sealed class XmlDataTreeWriter {
        XmlWriter _xmlw;
        DataSet _ds;
		    DataTable _dt=null;
        bool    isDiffgram = false;
        Hashtable rowsOrder = null;

        internal XmlDataTreeWriter(DataSet ds) {
          _ds = ds;
        }

        internal XmlDataTreeWriter(DataSet ds, DataTable dt) {
          _ds = ds;
			    _dt = dt;
        }
		
        internal static bool RowHasErrors(DataRow row) {
          int colCount = row.Table.Columns.Count;

			    if ((row.HasErrors) && (row.RowError.Length > 0)) 
            return true;

	        for (int colNum = 0; colNum < colCount; ++colNum) {
				      DataColumn column = row.Table.Columns[colNum];
				      string error = row.GetColumnError(column);
				      if (error == null || error.Length == 0) {
					      continue;
				      }
              return true;
            }
            
          return false;
        }

        // the following line writes the data part
        // for the new diffgram format 

        internal void SaveDiffgramData(XmlWriter xw, Hashtable rowsOrder) {
            _xmlw = xw; 
            isDiffgram = true;
            this.rowsOrder = rowsOrder;
           
            int countTopTable = _ds.TopLevelTables().Length;

            string prefix = ( _ds.Namespace == "" )? "" : _ds.Prefix;
            
			if (_ds.DataSetName == null || _ds.DataSetName.Length == 0)
				_xmlw.WriteStartElement(prefix, Keywords.DOCUMENTELEMENT, _ds.Namespace);
			else
				_xmlw.WriteStartElement(prefix, XmlConvert.EncodeLocalName(_ds.DataSetName), _ds.Namespace);

            // new XmlTreeGen(true).Save(_ds,_xmlw, false /* we don't care since we specified it's serialized */);


            if (_dt != null) {
                foreach (DataRow row in _dt.Rows) {
                    if (row.RowState == DataRowState.Deleted)
                        continue;
					if (row.GetNestedParent() == null)
					{
                        XmlDataRowWriter(row,_dt.EncodedTableName);
					}
                }

			}
			else 
				foreach (DataTable table in _ds.Tables) {

					foreach (DataRow row in table.Rows) {
						if (row.RowState == DataRowState.Deleted)
							continue;
						if (row.GetNestedParent() == null)
						{
							XmlDataRowWriter(row,table.EncodedTableName);
						}
					}
				}

			_xmlw.WriteEndElement();
            _xmlw.Flush();            

        }
   
        
        internal void Save(XmlWriter xw, bool writeSchema) {
            _xmlw = xw;
            int countTopTable = _ds.TopLevelTables().Length;
            bool fWriteDSElement = true;
            string prefix = ( _ds.Namespace == "" )? "" : _ds.Prefix;
            
            if (!writeSchema && _ds.fTopLevelTable && countTopTable == 1) {
                if (_ds.TopLevelTables()[0].Rows.Count == 1)
                    fWriteDSElement = false;
            }
            
            if (fWriteDSElement) {
                if (_ds.DataSetName == null || _ds.DataSetName.Length == 0)
                    _xmlw.WriteStartElement(prefix, Keywords.DOCUMENTELEMENT, _ds.Namespace);
                else
                    _xmlw.WriteStartElement(prefix, XmlConvert.EncodeLocalName(_ds.DataSetName), _ds.Namespace);
    
      			foreach (DataTable table in _ds.Tables) {
                    if (table.xmlText != null) {
                        _xmlw.WriteAttributeString(Keywords.XMLNS, Keywords.XSI, Keywords.XSD_XMLNS_NS, Keywords.XSINS);
                        break;
                    }
                }

                if (writeSchema) {
                    new XmlTreeGen(SchemaFormat.Public).Save(_ds,_xmlw);
                }
            }

			foreach (DataTable table in _ds.Tables) {

				foreach (DataRow row in table.Rows) {
					if (row.RowState == DataRowState.Deleted)
						continue;
					if (row.GetNestedParent() == null)
					{
						XmlDataRowWriter(row,table.EncodedTableName);
					}
				}
			}

            if (fWriteDSElement)
                _xmlw.WriteEndElement();
            _xmlw.Flush();            
        }
        
        private ArrayList GetNestedChildRelations(DataRow row) {
            ArrayList list = new ArrayList();

            foreach( DataRelation r in row.Table.ChildRelations ) {
                if (r.Nested)
                    list.Add(r);
            }

            return list;
        }


        internal void  XmlDataRowWriter(DataRow row, String encodedTableName) {

            object value;
            string prefix = (row.Table.Namespace == "") ? "" : row.Table.Prefix;

            _xmlw.WriteStartElement(prefix, encodedTableName, row.Table.Namespace);

            if (isDiffgram)  {
				_xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFID, Keywords.DFFNS, row.Table.TableName+row.rowID.ToString());

                _xmlw.WriteAttributeString( Keywords.MSD, Keywords.ROWORDER, Keywords.MSDNS, rowsOrder[row].ToString());
				
				if (row.RowState == DataRowState.Added)
					_xmlw.WriteAttributeString( Keywords.DFF, Keywords.HASCHANGES, Keywords.DFFNS, Keywords.INSERTED);
				if (row.RowState == DataRowState.Modified)
					_xmlw.WriteAttributeString( Keywords.DFF, Keywords.HASCHANGES, Keywords.DFFNS, Keywords.MODIFIED);

				if (RowHasErrors(row))
					_xmlw.WriteAttributeString( Keywords.DFF, Keywords.HASERRORS, Keywords.DFFNS, Keywords.TRUE);

            }


                

            //write the attribute columns first, if any
            foreach( DataColumn col in row.Table.Columns ) 
            {
                if (col.columnMapping == MappingType.Attribute)
                {
                    value = row[col];
                    string colPrefix = (col.Namespace == "") ? "" : col.Prefix;

                    if (value != DBNull.Value){
                        _xmlw.WriteAttributeString(colPrefix, col.EncodedColumnName, col.Namespace, col.ConvertObjectToXml(value));
                    }
                }
                
                if (!isDiffgram)
                    continue;

                if (col.columnMapping == MappingType.Hidden)
                {
                    value = row[col];

                    if (value != DBNull.Value){
                        _xmlw.WriteAttributeString(Keywords.MSD, "hidden"+col.EncodedColumnName, Keywords.MSDNS, col.ConvertObjectToXml(value));
                    }
                }
            } //end foreach
                 
            foreach( DataColumn col in row.Table.Columns  ) 
            {
                if (col.columnMapping != MappingType.Hidden)
                {
                    value = row[col];
                    string colPrefix = (col.Namespace == "") ? "" : col.Prefix;

                    if ((value == DBNull.Value) && (col.ColumnMapping == MappingType.SimpleContent))
                        _xmlw.WriteAttributeString(Keywords.XSI, Keywords.XSI_NIL, Keywords.XSINS, Keywords.TRUE);
                    
                    if ((value != DBNull.Value) && (col.columnMapping != MappingType.Attribute)) {
                        if (col.columnMapping != MappingType.SimpleContent)
                            _xmlw.WriteStartElement(colPrefix, col.EncodedColumnName, col.Namespace);
                        _xmlw.WriteString( col.ConvertObjectToXml(value));
                        if (col.columnMapping != MappingType.SimpleContent)
                            _xmlw.WriteEndElement();
                    }
                }


            } //end foreach

			if (_dt == null)
				foreach( DataRelation dr in GetNestedChildRelations(row) ) {
					foreach( DataRow r in row.GetChildRows(dr) ) {                       					   
                       XmlDataRowWriter(r,dr.ChildTable.EncodedTableName);
					}
				}

            _xmlw.WriteEndElement();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xmlcontent.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlContent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
 
namespace System.Data {

    /// <include file='doc\XmlContent.uex' path='docs/doc[@for="XmlContent"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal enum XmlContent {
        /// <include file='doc\XmlContent.uex' path='docs/doc[@for="XmlContent.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\XmlContent.uex' path='docs/doc[@for="XmlContent.Empty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Empty = 1,
        /// <include file='doc\XmlContent.uex' path='docs/doc[@for="XmlContent.TextOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        TextOnly = 2,
        /// <include file='doc\XmlContent.uex' path='docs/doc[@for="XmlContent.EltOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EltOnly = 3,
        /// <include file='doc\XmlContent.uex' path='docs/doc[@for="XmlContent.Mixed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Mixed = 4,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xmlkeywords.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlKeywords.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;

    internal class Keywords {
            // Keywords for DataSet Namespace
        internal const string DFF                   = "diffgr";
        internal const string DFFNS                 = "urn:schemas-microsoft-com:xml-diffgram-v1";
        internal const string DIFFGRAM              = "diffgram";
        internal const string DIFFID                = "id";
        internal const string DIFFPID               = "parentId";
        internal const string HASCHANGES            = "hasChanges";
        internal const string HASERRORS             = "hasErrors";
        internal const string ROWORDER              = "rowOrder";
        internal const string MSD_ERRORS            = "errors"; 
        internal const string CHANGES               = "changes";   
        internal const string MODIFIED              = "modified";   
        internal const string INSERTED              = "inserted";   
        //internal const string DESCENDENT            = "descendent";   
                                   

	

        internal const string MSD                   = "msdata";
        internal const string MSDNS                 = "urn:schemas-microsoft-com:xml-msdata";
        internal const string MSD_ACCEPTREJECTRULE  = "AcceptRejectRule";                    
        internal const string MSD_ALLOWDBNULL       = "AllowDBNull";                           
        internal const string MSD_CHILD             = "child";                               
        internal const string MSD_CHILDKEY          = "childkey";                            
        internal const string MSD_COLUMNNAME        = "ColumnName";    
        internal const string MSD_CONSTRAINTNAME    = "ConstraintName"; 
        internal const string MSD_CONSTRAINTONLY    = "ConstraintOnly"; 
   //     internal const string MSD_CREATECONSTRAINTS = "CreateConstraints";                   
        internal const string MSD_CASESENSITIVE     = "CaseSensitive";
        internal const string MSD_DATATYPE          = "DataType";                            
        internal const string MSD_DEFAULTVALUE      = "DefaultValue";                            
        internal const string MSD_DELETERULE        = "DeleteRule";                          
        internal const string MSD_ERROR             = "Error";                               
        internal const string MSD_ISDATASET         = "IsDataSet";
        internal const string MSD_ISNESTED          = "IsNested";
        internal const string MSD_LOCALE            = "Locale";
        internal const string MSD_ORDINAL           = "Ordinal";                              
        internal const string MSD_PARENT            = "parent";                              
        internal const string MSD_PARENTKEY         = "parentkey";                           
        internal const string MSD_PRIMARYKEY        = "PrimaryKey";                          
        internal const string MSD_RELATION          = "Relationship";                            
        internal const string MSD_RELATIONNAME      = "RelationName";                            
        internal const string MSD_UPDATERULE        = "UpdateRule";                          
        internal const char   MSD_KEYFIELDSEP       = ' ';
        internal const char   MSD_KEYFIELDOLDSEP    = '+';
        internal const string MSD_REL_PREFIX        = "rel_";
        internal const string MSD_FK_PREFIX         = "fk_";




            // Keywords for datatype namespace
        internal const string DTNS      = "urn:schemas-microsoft-com:datatypes"; 
        internal const string DT_TYPE   = "type";                                
        internal const string DT_VALUES = "values";                              

            // Keywords for schema namespace
        internal const string XDRNS             = "urn:schemas-microsoft-com:xml-data";   
        internal const string XDR_ATTRIBUTE     = "attribute";                            
        internal const string XDR_ATTRIBUTETYPE = "AttributeType";                        
        internal const string XDR_DATATYPE      = "datatype";                             
        internal const string XDR_DESCRIPTION   = "description";                          
        internal const string XDR_ELEMENT       = "element";                              
        internal const string XDR_ELEMENTTYPE   = "ElementType";                          
        internal const string XDR_GROUP         = "group";                                
        internal const string XDR_SCHEMA        = "Schema";                               

            // Keywords for the xsd namespace

        internal const string XSDNS            = "http://www.w3.org/2001/XMLSchema"; 

        internal const string XSD_NS_START     = "http://www.w3.org/"; 
        internal const string XSD_XMLNS_NS     = "http://www.w3.org/2000/xmlns/";
        internal const string XSD_PREFIX       = "xs";
        internal const string XSD_PREFIXCOLON  = "xs:";
        internal const string XSD_ANNOTATION   = "annotation";                       
        internal const string XSD_APPINFO      = "appinfo";                          
        internal const string XSD_ATTRIBUTE    = "attribute";                        
        internal const string XSD_SIMPLETYPE   = "simpleType";                       
        internal const string XSD_ELEMENT      = "element";                          
        internal const string XSD_COMPLEXTYPE  = "complexType";    
        internal const string XSD_SCHEMA       = "schema";                           
        internal const string XSD_PATTERN      = "pattern";                          
        internal const string XSD_LENGTH       = "length";                    
        internal const string XSD_MAXLENGTH    = "maxLength";                        
        internal const string XSD_MINLENGTH    = "minLength";                          
        internal const string XSD_ENUMERATION  = "enumeration";                      
        internal const string XSD_MININCLUSIVE = "minInclusive";                        
        internal const string XSD_MINEXCLUSIVE = "minExclusive";                     
        internal const string XSD_MAXINCLUSIVE = "maxInclusive";                    
        internal const string XSD_MAXEXCLUSIVE = "maxExclusive";                     
        internal const string XSD_NAMESPACE    = "namespace";                     
        internal const string XSD_NILLABLE     = "nillable";                     
        internal const string XSD_IMPORT       = "import";                     
        internal const string XSD_SELECTOR     = "selector";                     
        internal const string XSD_FIELD        = "field";                            
        internal const string XSD_UNIQUE       = "unique";                        
        internal const string XSD_KEY          = "key";                              
        internal const string XSD_KEYREF       = "keyref";                                
        internal const string XSD_DATATYPE     = "datatype"; 
        internal const string XSD_ALL          = "all";
        internal const string XSD_SEQUENCE     = "sequence";
        internal const string XSD_ENCODING     = "encoding";
        internal const string XSD_EXTENSION    = "extension";
        internal const string XSD_SIMPLECONTENT = "simpleContent";
        internal const string XSD_XPATH          = "xpath";
        internal const string XSD_ATTRIBUTEFORMDEFAULT = "attributeFormDefault";
        internal const string XSD_ELEMENTFORMDEFAULT = "elementFormDefault";
        internal const string XSD_SCHEMALOCATION = "schemaLocation";
        internal const string XSD_CHOICE       = "choice";
        internal const string XSD_RESTRICTION  = "restriction";

        internal const string XSINS            = "http://www.w3.org/2001/XMLSchema-instance"; 
        internal const string XSI_NIL  = "nil";
        internal const string XSI      = "xsi";

                 
                                                                       
            // Keywords for sql Namespace
        internal const string UPDGNS          = "urn:schemas-microsoft-com:xml-updategram";
        internal const string UPDG            = "updg";
        internal const string SQL_SYNC        = "sync";                            
        internal const string SQL_BEFORE      = "before";                           
        internal const string SQL_AFTER       = "after";                            
        internal const string SQL_ID          = "id";          
        internal const string SQL_UNCHANGED   = "unchanged";                     

            // Keywords that don't have any namespace, but are atomized
        internal const string ATTRIBUTE       = "attribute";        
        internal const string CONTENT         = "content";          
        internal const string DEFAULT         = "default";          
        internal const string XSDID           = "id";               
        internal const string MINOCCURS       = "minOccurs";        
        internal const string MAXOCCURS       = "maxOccurs";        
        internal const string MODEL           = "model";            
        internal const string NAME            = "name";             
        internal const string NULLABLE        = "nullable";             
        internal const string ORDER           = "order";            
        internal const string REQUIRED        = "required";         
        internal const string REF             = "ref";              
        internal const string BASE            = "base";             
        internal const string TARGETNAMESPACE = "targetNamespace";  
        internal const string TYPE            = "type";             
        internal const string XMLNS           = "xmlns";    
        internal const string XMLNS_XSD       = "xmlns:xs";    
        internal const string XMLNS_XSI       = "xmlns:xsi";    
        internal const string XMLNS_MSDATA    = "xmlns:msdata";    
        internal const string XMLNS_MSPROP    = "xmlns:msprop";    
        internal const string XMLNS_MSTNS     = "xmlns:mstns";    
        internal const string MSTNS_PREFIX    = "mstns:";    
                
        internal const string VALUE           = "value";            
        internal const string REFER           = "refer";  
        internal const string USE             = "use";
        internal const string PROHIBITED      = "prohibited";  
        internal const string POSITIVEINFINITY = "INF";
        internal const string NEGATIVEINFINITY = "-INF";
    	internal const string QUALIFIED       = "qualified";
    	internal const string UNQUALIFIED       = "unqualified";

                                               
            // Keywords that are not atomized, just strings
            // they are mostly legal values for an attribute
            // NOTE: datatypes are enumerated in mapNameType table in XMLSchema.cs
        internal const string APP          = "app";                
        internal const string CLOSED       = "closed";                
        internal const string CURRENT      = "Current"; 
        internal const string DOCUMENTELEMENT      = "DocumentElement";              
        internal const string FALSE        = "false";                 
        internal const string FIXED        = "fixed";                 
        internal const string FORM         = "form";                 
        internal const string ENCODING     = "encoding";              
        internal const string ELEMENTONLY  = "elementOnly";           
        internal const string ELTONLY      = "eltOnly";               
        internal const string EMPTY        = "empty";                 
        internal const string MANY         = "many";                  
        internal const string MIXED        = "mixed";                 
        internal const string NO           = "no";                    
        internal const string NOTATION     = "notation";              
        internal const string OCCURS       = "occurs";                
        internal const string ONE_OR_MORE  = "oneormore";             
        internal const string ONE          = "one";                   
        internal const string ONE_DIGIT    = "1";                   
        internal const string ONCE         = "once";                  
        internal const string OPTIONAL     = "optional";              
        internal const string OPEN         = "open";                  
        internal const string ORIGINAL     = "Original";              
        internal const string RANGE        = "range";                 
        internal const string SEQ          = "seq";   
        internal const string STAR         = "*";   
        internal const string TRUE         = "true";                  
        internal const string TEXTONLY     = "textOnly";              
        internal const string VERSION      = "version";               
        internal const string XML          = "xml";                   
        internal const string X_SCHEMA     = "x-schema";              
        internal const string YES          = "yes";                   
        internal const string ZERO_DIGIT   = "0";                   
        internal const string ZERO_OR_MORE    = "unbounded";                     

            // Keywords for Msprop Namespace
        internal const string MSPROPNS              = "urn:schemas-microsoft-com:xml-msprop";   
    } // Keywords
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xmlwritemode.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlWriteMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {

    /// <include file='doc\XmlWriteMode.uex' path='docs/doc[@for="XmlWriteMode"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum XmlWriteMode {    
        /// <include file='doc\XmlWriteMode.uex' path='docs/doc[@for="XmlWriteMode.WriteSchema"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WriteSchema = 0,
        /// <include file='doc\XmlWriteMode.uex' path='docs/doc[@for="XmlWriteMode.IgnoreSchema"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        IgnoreSchema = 1,
        /// <include file='doc\XmlWriteMode.uex' path='docs/doc[@for="XmlWriteMode.DiffGram"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DiffGram = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\codegen\strongtypingexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="StrongTypingException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StrongTypingException.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Data {
    using System;
    using System.Collections;
    using System.Runtime.Serialization;

    /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="StrongTypingException"]/*' />
    /// <devdoc>
    ///    <para>DEV: The exception that is throwing from strong typed DataSet when user access to DBNull value.</para>
    /// </devdoc>
    [Serializable]
    public class StrongTypingException : DataException {
        /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="StrongTypingException.StrongTypingException2"]/*' />
        protected StrongTypingException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
        }
        /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="StrongTypingException.StrongTypingException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public StrongTypingException() : base() {
            HResult = HResults.StrongTyping;
        }
        /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="StrongTypingException.StrongTypingException1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public StrongTypingException(string s, Exception innerException) : base(s, innerException) {
            HResult = HResults.StrongTyping;
        }
    }


    /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="StrongTypingCodegenException"]/*' />
    /// <devdoc>
    ///    <para>DEV: The exception that is throwing in generating strong typed DataSet when name conflict happens.</para>
    /// </devdoc>
    [Serializable]
    public class TypedDataSetGeneratorException : DataException {        
        private ArrayList errorList;
        private string KEY_ARRAYCOUNT = "KEY_ARRAYCOUNT";
        private string KEY_ARRAYVALUES = "KEY_ARRAYVALUES";

        /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="TypedDataSetGeneratorException.TypedDataSetGeneratorException"]/*' />
        protected TypedDataSetGeneratorException(SerializationInfo info, StreamingContext context)
        : base(info, context) {
            int count = (int) info.GetValue(KEY_ARRAYCOUNT, typeof(System.Int32));
            if (count > 0) {
                errorList = new ArrayList();
                for (int i = 0; i < count; i++) {
                    errorList.Add(info.GetValue(KEY_ARRAYVALUES + i, typeof(System.String)));
                }
            }
            else
                errorList = null;
        }

        /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="StrongTypingCodegenException.StrongTypingCodegenException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TypedDataSetGeneratorException() : base() {
            errorList = null;
            HResult = HResults.StrongTyping;

        }

        /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="StrongTypingCodegenException.StrongTypingCodegenException1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TypedDataSetGeneratorException(ArrayList list) : this() {
            errorList = list;
            HResult = HResults.StrongTyping;
        }

        /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="StrongTypingCodegenException.ErrorList"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ArrayList ErrorList {
            get {
                return errorList;
            }
        }

        /// <include file='doc\StrongTypingException.uex' path='docs/doc[@for="TypedDataSetGeneratorException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) 
        {
            base.GetObjectData(info, context);

            if (errorList != null) {
                info.AddValue(KEY_ARRAYCOUNT, errorList.Count);
                for (int i = 0; i < errorList.Count; i++) {
                    info.AddValue(KEY_ARRAYVALUES + i, errorList[i].ToString());
                }
            }
            else {
                info.AddValue(KEY_ARRAYCOUNT, 0);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xmldataloader.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlDataLoader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlDataLoader.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Data {
    using System;
    using System.Collections;
    using System.Xml;
    using System.Text;
    using System.Diagnostics;

    internal class XmlDataLoader {
        DataSet dataSet;
        XmlToDatasetMap nodeToSchemaMap = null;
        Hashtable       nodeToRowMap;
        Stack           childRowsStack = null;
        Hashtable       htableExcludedNS = null;
        bool    fIsXdr = false;
        internal bool    isDiffgram = false;
        DataRow topMostRow = null;
        XmlElement topMostNode = null;

        internal XmlDataLoader( DataSet dataset, bool IsXdr) {
            // Initialization
            this.dataSet = dataset;
            this.nodeToRowMap = new Hashtable();
            this.fIsXdr = IsXdr;
        }

        internal XmlDataLoader( DataSet dataset, bool IsXdr, XmlElement topNode) {
            // Initialization
            this.dataSet = dataset;
            this.nodeToRowMap = new Hashtable();
            this.fIsXdr = IsXdr;

            // Allocate the stack and create the mappings
            childRowsStack = new Stack(50);
            topMostNode = topNode;
        }

        // after loading, all detached DataRows are attached to their tables
        private void AttachRows( DataRow parentRow, XmlNode parentElement ) {
            if (parentElement == null)
                return;

            for (XmlNode n = parentElement.FirstChild; n != null; n = n.NextSibling) {
                if (n.NodeType == XmlNodeType.Element) {
                    XmlElement e = (XmlElement) n;
                    DataRow r = GetRowFromElement( e );
                    if (r != null && r.RowState == DataRowState.Detached) {
                        if (parentRow != null)
                            r.SetParentRow( parentRow );

                        r.Table.Rows.Add( r );
                    } 
                    else if (r == null) {
                        // n is a 'sugar element'
                        AttachRows( parentRow, n );
                    }

                    // attach all detached rows
                    AttachRows( r, n );
                }
            }
        }

        // TODO: This might get changed with future XML changes
        private int CountNonNSAttributes (XmlNode node) {
            int count = 0;
            for (int i = 0; i < node.Attributes.Count; i++) {
                XmlAttribute attr = node.Attributes[i];
                if (!FExcludedNamespace(node.Attributes[i].NamespaceURI))
                        count++;
            }            
            return count;
        }
        
        public void FindTableAtoms(XmlElement tree, Hashtable tableAtoms, XmlElement rootElement) {
            // check if the current elemend should be mapped to DataTable
            bool isTable = false;

            if (tree.LocalName == Keywords.XSD_SCHEMA)
                return;

            if (tree != rootElement) {
                if (CountNonNSAttributes(tree) > 0)
                    isTable = true;
                else if (tree.FirstChild != null && !OnlyTextChild(tree))
                    isTable = true;
            }

            if (isTable) {
                tableAtoms[QualifiedName(tree.LocalName, tree.NamespaceURI)] = true;
            }

            Hashtable atomsCount = new Hashtable();
            for (int i = 0; i < tree.ChildNodes.Count; i++) {
                XmlNode node = tree.ChildNodes[i]; 

                if (node is XmlElement) {
                    XmlElement el = (XmlElement)node;
                    FindTableAtoms(el, tableAtoms, rootElement);

                    string tabIdentity = QualifiedName(el.LocalName, el.NamespaceURI);
                    object atomLookup = tableAtoms[tabIdentity];
                    if (atomLookup != null && (bool)atomLookup == true) {
                        continue;
                    }

                    bool several = false;
                    int children = 0;

                    // count XmlElement children
                    XmlNode child = el.FirstChild;
                    while (child != null) {
                        if (child is XmlElement) {
                            if (children == 1) {
                                several = true;
                                break;
                            }
                            children++;
                        }
                        child = child.NextSibling;
                    }

                    if (several || (el.Attributes != null && CountNonNSAttributes(el) > 0)) {
                        atomsCount[tabIdentity] = 2;
                        continue;
                    }
                    object count = atomsCount[tabIdentity];
                    if (count == null)
                        atomsCount[tabIdentity] = 1;
                    else
                        atomsCount[tabIdentity] = ((int)count) + 1;
                }
            }

            foreach (object key in atomsCount.Keys) {
                object count = atomsCount[key];
                object atomLookup = tableAtoms[key];
                if (atomLookup != null && (bool)atomLookup == true)
                    continue;

                tableAtoms[key] = (count != null ? ((int)count > 1 ? true : false) : false);
            }
        }

        private string GetValueForTextOnlyColums( XmlNode n ) {
            string value = null;

            // don't consider whitespace
            while (n != null && (n.NodeType == XmlNodeType.Whitespace || !IsTextLikeNode(n.NodeType))) {
                n = n.NextSibling;
            }
            
            if (n != null) {
                if (IsTextLikeNode( n.NodeType ) && (n.NextSibling == null || !IsTextLikeNode( n.NodeType ))) {
                    // don't use string builder if only one text node exists
                    value = n.Value;
                    n = n.NextSibling;
                }
                else {
                    StringBuilder sb = new StringBuilder();
                    while (n != null && IsTextLikeNode( n.NodeType )) {
                        sb.Append( n.Value );
                        n = n.NextSibling;
                    }
                    value = sb.ToString();
                }
            }

            if (value == null)
                value = String.Empty;

            return value;
        }

        private string GetInitialTextFromNodes( ref XmlNode n ) {
            string value = null;

            if (n != null) {
                // don't consider whitespace
                while (n.NodeType == XmlNodeType.Whitespace)
                    n = n.NextSibling;

                if (IsTextLikeNode( n.NodeType ) && (n.NextSibling == null || !IsTextLikeNode( n.NodeType ))) {
                    // don't use string builder if only one text node exists
                    value = n.Value;
                    n = n.NextSibling;
                }
                else {
                    StringBuilder sb = new StringBuilder();
                    while (n != null && IsTextLikeNode( n.NodeType )) {
                        sb.Append( n.Value );
                        n = n.NextSibling;
                    }
                    value = sb.ToString();
                }
            }

            if (value == null)
                value = String.Empty;

            return value;
        }

        private DataColumn GetTextOnlyColumn( DataRow row ) {
            DataColumnCollection columns = row.Table.Columns;
            int cCols = columns.Count;
            for (int iCol = 0; iCol < cCols; iCol++) {
                DataColumn c = columns[iCol];
                if (IsTextOnly( c ))
                    return c;
            }
            return null;
        }

        internal DataRow GetRowFromElement( XmlElement e ) {
            return(DataRow) nodeToRowMap[e];
        }        

        internal bool FColumnElement(XmlElement e) {
            if (nodeToSchemaMap.GetColumnSchema(e, FIgnoreNamespace(e)) == null)
                return false;

            if (CountNonNSAttributes(e) > 0)
                return false;

            for (XmlNode tabNode = e.FirstChild; tabNode != null; tabNode = tabNode.NextSibling)
                if (tabNode is XmlElement)
                    return false;

            return true;                          
        }
        
        private bool FExcludedNamespace(string ns) {
            if (ns.Equals(Keywords.XSD_XMLNS_NS))
                return true;
                
            if (htableExcludedNS == null)
                return false;
                
            return htableExcludedNS.Contains(ns);
        }

        private bool FIgnoreNamespace(XmlNode node) {
            XmlNode ownerNode;
            if (!fIsXdr)
                return false;
            if (node is XmlAttribute)
                ownerNode = ((XmlAttribute)node).OwnerElement;
            else
                ownerNode = node;
            if (ownerNode.NamespaceURI.StartsWith("x-schema:#"))
                return true;
            else
                return false;
        }
        
        private bool FIgnoreNamespace(XmlReader node) {
            if (fIsXdr && node.NamespaceURI.StartsWith("x-schema:#"))
                return true;
            else
                return false;
        }

        private XmlNode FirstTextChild(XmlElement el) {
            XmlNode child = el.FirstChild;

            while (child != null) {
                if (IsTextLikeNode(child.NodeType))
                    return child;
                child = child.NextSibling;
            }

            return null;
        }

        internal void InferSchema(XmlDocument xdoc, string[] excludedNamespaces) {
            XmlElement rootElement = xdoc.DocumentElement;
            if (rootElement == null)
                return;

            htableExcludedNS = new Hashtable();
            htableExcludedNS.Add(Keywords.XSINS, null);

            if (excludedNamespaces != null) {
                for (int i = 0; i < excludedNamespaces.Length; i++)
                    htableExcludedNS.Add(excludedNamespaces[i], null);
            }
                
            // Find all table names
            Hashtable tableAtoms = new Hashtable();
            XmlNode tabNode;
            dataSet.fTopLevelTable = false;            
            FindTableAtoms(rootElement, tableAtoms, rootElement);

            // Top level table or dataset ?
            if (CountNonNSAttributes(rootElement) > 0)
                dataSet.fTopLevelTable = true;
            else {
                for (tabNode = rootElement.FirstChild; tabNode != null; tabNode = tabNode.NextSibling) {
                    if (tabNode is XmlElement && tabNode.LocalName != Keywords.XSD_SCHEMA) {
                        object value = tableAtoms[QualifiedName(tabNode.LocalName, tabNode.NamespaceURI)];
                        if (value == null || (bool) value == false) {
                            dataSet.fTopLevelTable = true;
                            break;
                        }
                    }
                }
            }
            
            // Set default schema name
            if (!dataSet.fTopLevelTable) {
                dataSet.DataSetName = XmlConvert.DecodeName(rootElement.LocalName);
                dataSet.Namespace = rootElement.NamespaceURI; 
                dataSet.Prefix = rootElement.Prefix;

                tabNode = rootElement.FirstChild;
            }
            else {
                tabNode = rootElement;

                DataTable docTable = dataSet.Tables[XmlConvert.DecodeName(tabNode.LocalName), tabNode.NamespaceURI];
                if (docTable == null) {
                    docTable = new DataTable(XmlConvert.DecodeName(tabNode.LocalName));
                    if (tabNode.NamespaceURI == dataSet.Namespace) 
                        docTable.Namespace = null;
                    else
                        docTable.Namespace = tabNode.NamespaceURI;
                    docTable.Prefix    = tabNode.Prefix;
                    dataSet.Tables.Add(docTable);
                }
                dataSet.Namespace = tabNode.NamespaceURI;
                dataSet.Prefix    = tabNode.Prefix;
                docTable.fNestedInDataset = false;

            }

            // fill all tables with schema information
            for (; tabNode != null; tabNode = tabNode.NextSibling) {
                // Ignore non-Element node and /SCHEMA node for now
                if (tabNode is XmlElement && tabNode.LocalName != Keywords.XSD_SCHEMA && tabNode.LocalName != Keywords.XDR_SCHEMA) {
                    DataTable topTable = dataSet.Tables[XmlConvert.DecodeName(tabNode.LocalName), tabNode.NamespaceURI];
                    if (topTable == null) {
                        object value = tableAtoms[QualifiedName(tabNode.LocalName, tabNode.NamespaceURI)];
                        if (value != null && (bool) value == true) {
                            topTable = new DataTable(XmlConvert.DecodeName(tabNode.LocalName));
                            if (tabNode.NamespaceURI == dataSet.Namespace)
                                topTable.Namespace = null;
                            else
                                topTable.Namespace = tabNode.NamespaceURI;
                            topTable.Prefix    = tabNode.Prefix;
                            dataSet.Tables.Add(topTable);
                        }
                    }

                    // infer schema
                    InferSchema((XmlElement)tabNode, tableAtoms, topTable);
                }
            }
        }

        internal void InferSchema(XmlElement tree, Hashtable tableAtoms, DataTable table) {
            // Sequences of processing Elements, Attributes, and Text-Only columns should be the same as in ReadXmlSchema
            
            // Elements
            foreach (XmlNode node in tree.ChildNodes) {
                if (node is XmlElement) {
                    XmlElement element = (XmlElement) node;

                    // table case
                    object atomValue = tableAtoms[QualifiedName(element.LocalName, element.NamespaceURI)];
                    if (atomValue != null && (bool)atomValue == true) {
                        DataRelation relation = null;
                        DataTable childTable = dataSet.Tables[XmlConvert.DecodeName(element.LocalName), element.NamespaceURI];
                        if (childTable == null) {
                            childTable = new DataTable(XmlConvert.DecodeName(element.LocalName));
                            if (element.NamespaceURI == table.Namespace) 
                                childTable.Namespace = null;
                            else
                                childTable.Namespace = element.NamespaceURI;
                            childTable.Prefix    = element.Prefix;
                            dataSet.Tables.Add(childTable);
                        }
                        else {
                            if (table != null) {
                                foreach (DataRelation curRelation in childTable.ParentRelations) {
                                    if (curRelation.ParentTable == table && curRelation.Nested) {
                                        relation = curRelation;
                                        break;
                                    }
                                }
                            }
                        }
                        InferSchema(element, tableAtoms, childTable);
                        if ((table == childTable) && (childTable.nestedParentRelation != null) && (childTable.nestedParentRelation.ParentTable == table))
                            relation = childTable.nestedParentRelation ;
                        if (table != null && relation == null) {
                            DataColumn parentKey = table.AddUniqueKey();
                            table.XmlText = null; //remove text column if exist
                            dataSet.Relations.Add(table.TableName+'_'+childTable.TableName, parentKey, childTable.AddForeignKey(parentKey)).Nested = true;
                        }
                    }
                    else {
                        // column case
                        if (table == null) {
                            table = new DataTable(XmlConvert.DecodeName(tree.LocalName));
                            if (tree.NamespaceURI == dataSet.Namespace)
                                table.Namespace = null;
                            else
                                table.Namespace = tree.NamespaceURI;
                            table.Prefix    = tree.Prefix;
                            dataSet.Tables.Add(table);
                        }
                        DataColumn column = table.Columns[XmlConvert.DecodeName(element.LocalName), element.NamespaceURI];
                        if (column == null || column == table._colUnique) {
                            column = new DataColumn(XmlConvert.DecodeName(element.LocalName), typeof(string), null, MappingType.Element);
                            if (element.NamespaceURI == table.Namespace) 
                                column.Namespace = null;
                            else
                                column.Namespace = element.NamespaceURI;
                            column.Prefix = element.Prefix;
                            table.XmlText = null; //remove text column if exist
                            if (table._colUnique != null && column.ColumnName == table._colUnique.ColumnName) {
                                table._colUnique.ColumnName = XMLSchema.GenUniqueColumnName(column.ColumnName, table);
                            }
                            table.Columns.Add(column);
                        }
                        else {
                            if (column.ColumnMapping != MappingType.Element)
                                throw ExceptionBuilder.ColumnTypeConflict(column.ColumnName);
                        }                        
                    }
                }
            }

            // Attributes
            if (table != null) {
                foreach (XmlAttribute attribute in tree.Attributes) {
                    if (!FExcludedNamespace(attribute.NamespaceURI))
                        {
                        DataColumn column = table.Columns[XmlConvert.DecodeName(attribute.LocalName), attribute.NamespaceURI];
                        if (column == null || column == table._colUnique) {
                            column = new DataColumn(XmlConvert.DecodeName(attribute.LocalName), typeof(string), null, MappingType.Attribute);
                            column.Namespace = attribute.NamespaceURI;
                            column.Prefix = attribute.Prefix;
                            if (table._colUnique != null && column.ColumnName == table._colUnique.ColumnName) {
                                table._colUnique.ColumnName = XMLSchema.GenUniqueColumnName(column.ColumnName, table);
                            }
                            table.Columns.Add(column);
                        }
                        else {
                            if (column.ColumnMapping != MappingType.Attribute)
                                throw ExceptionBuilder.ColumnTypeConflict(column.ColumnName);
                        }
                    }
                    if ((attribute.NamespaceURI == Keywords.XSINS) && 
                        (attribute.LocalName == Keywords.XSI_NIL ) && 
                        ((attribute.Value == Keywords.TRUE) || (attribute.Value == Keywords.ONE_DIGIT)) && 
                        (table.ElementColumnCount == 0) && 
                        (table.XmlText == null)) {
                        int i = 0;
                        string colName = table.TableName + "_Text";
                        while (table.Columns[colName] != null) {
                            colName = colName + i++;
                        }
                        DataColumn textColumn = new DataColumn(colName, typeof(string), null, MappingType.SimpleContent);
                        table.Columns.Add(textColumn);
                    }
                }
            }

            if (table.ElementColumnCount == 0) {
                // Text-only column
                XmlNode text = FirstTextChild(tree);
                if (text != null && table != null) {
                    if (table.XmlText == null) {
                        int i = 0;
                        string colName = table.TableName + "_Text";
                        while (table.Columns[colName] != null) {
                            colName = colName + i++;
                        }
                        DataColumn textColumn = new DataColumn(colName, typeof(string), null, MappingType.SimpleContent);
                        table.Columns.Add(textColumn);
                    }
                }
            }

        }

        internal bool IsTextLikeNode( XmlNodeType n ) {
            switch (n) {
                case XmlNodeType.EntityReference:
                    throw ExceptionBuilder.FoundEntity();

                case XmlNodeType.Text:
                case XmlNodeType.Whitespace:
                case XmlNodeType.CDATA:
                    return true;

                default:
                    return false;
            }
        }

        internal bool IsTextOnly( DataColumn c ) {
            if (c.ColumnMapping != MappingType.SimpleContent)
                return false;
            else
                return true;
        }

        internal void LoadData( XmlDocument xdoc ) {
            if (xdoc.DocumentElement == null)
                return;

            bool saveEnforce = dataSet.EnforceConstraints;
            dataSet.EnforceConstraints = false;
            dataSet.fInReadXml = true;

            nodeToSchemaMap = new XmlToDatasetMap(dataSet, xdoc.NameTable);

            DataRow topRow = null;
            if (dataSet.fTopLevelTable) {
                XmlElement e = xdoc.DocumentElement;
                DataTable topTable = (DataTable) nodeToSchemaMap.GetSchemaForNode(e, FIgnoreNamespace(e));
                if (topTable != null) {
                    topRow = topTable.CreateEmptyRow(); //enzol perf
                    nodeToRowMap[ e ] = topRow;

                    // get all field values.
                    LoadRowData( topRow, e );
                    topTable.Rows.Add(topRow);
                }
            }
            
            LoadRows( topRow, xdoc.DocumentElement );
            AttachRows( topRow, xdoc.DocumentElement );

            dataSet.fInReadXml = false;
            dataSet.EnforceConstraints = saveEnforce;
        }

        private void LoadRowData(DataRow row, XmlElement rowElement) {
            XmlNode n;
            DataTable table = row.Table;

            // keep a list of all columns that get updated
            Hashtable foundColumns = new Hashtable();

            row.BeginEdit();

            // examine all children first
            n = rowElement.FirstChild;

            // Look for data to fill the TextOnly column
            DataColumn column = GetTextOnlyColumn( row );
            if (column != null) {
                foundColumns[column] = column;
                string text = GetValueForTextOnlyColums( n ) ;
                if (XMLSchema.GetBooleanAttribute(rowElement, Keywords.XSI_NIL, Keywords.XSINS, false) && (text == String.Empty) )
                    row[column] = DBNull.Value;
                else
                    SetRowValueFromXmlText( row, column, text );
            }

            // Walk the region to find elements that map to columns
            while (n != null && n != rowElement) {
                if (n.NodeType == XmlNodeType.Element) {
                    XmlElement e = (XmlElement) n;

                    object schema = nodeToSchemaMap.GetSchemaForNode( e, FIgnoreNamespace(e) );

                    if (schema is DataTable) {
                        if (FColumnElement(e))
                            schema = nodeToSchemaMap.GetColumnSchema( e, FIgnoreNamespace(e) );
                    }
                    
                    // if element has its own table mapping, it is a separate region
                    if (schema == null || schema is DataColumn) {
                        // descend to examine child elements
                        n = e.FirstChild;

                        if (schema != null && schema is DataColumn) {
                            DataColumn c = (DataColumn) schema;

                            if (c.Table == row.Table && c.ColumnMapping != MappingType.Attribute && foundColumns[c] == null) {
                                foundColumns[c] = c;
                                string text = GetValueForTextOnlyColums( n ) ;
                                if (XMLSchema.GetBooleanAttribute(e, Keywords.XSI_NIL, Keywords.XSINS, false) && (text == String.Empty) )
                                    row[c] = DBNull.Value;
                                else
                                    SetRowValueFromXmlText( row, c, text );
                            }
                        } 
                        else if ((schema == null) && (n!=null)) {
                            continue;
                        }


                        // nothing left down here, continue from element
                        if (n == null)
                            n = e;
                    }
                }

                // if no more siblings, ascend back toward original element (rowElement)
                while (n != rowElement && n.NextSibling == null) {
                    n = n.ParentNode;
                }

                if (n != rowElement)
                    n = n.NextSibling;
            }

            //
            // Walk the attributes to find attributes that map to columns.
            //
            foreach( XmlAttribute attr in rowElement.Attributes ) {
                object schema = nodeToSchemaMap.GetColumnSchema( attr, FIgnoreNamespace(attr) );

                if (schema != null && schema is DataColumn) {
                    DataColumn c = (DataColumn) schema;

                    if (c.ColumnMapping == MappingType.Attribute && foundColumns[c] == null) {
                        foundColumns[c] = c;
                        n = attr.FirstChild;
                        SetRowValueFromXmlText( row, c, GetInitialTextFromNodes( ref n ) );
                    }
                }
            }

            // Null all columns values that aren't represented in the tree
            foreach( DataColumn c in row.Table.Columns ) {
                if (foundColumns[c] == null && XmlToDatasetMap.IsMappedColumn(c)) {
                    if (!c.AutoIncrement) {
                        if (c.AllowDBNull) {
                            row[c] = DBNull.Value;
                        }
                        else {
                            row[c] = c.DefaultValue;
                        }
                    }
                    else {
                        c.Init(row.tempRecord);
                    }
                }
            }

            row.EndEdit();
        }
        

        // load all data from tree structre into datarows
        private void LoadRows( DataRow parentRow, XmlNode parentElement ) {
            if (parentElement == null)
                return;

            // Skip schema node as well
            if (parentElement.LocalName == Keywords.XSD_SCHEMA && parentElement.NamespaceURI == Keywords.XSDNS ||
                parentElement.LocalName == Keywords.SQL_SYNC   && parentElement.NamespaceURI == Keywords.UPDGNS ||
                parentElement.LocalName == Keywords.XDR_SCHEMA && parentElement.NamespaceURI == Keywords.XDRNS)
                return;

            for (XmlNode n = parentElement.FirstChild; n != null; n = n.NextSibling) {
                if (n is XmlElement) {
                    XmlElement e = (XmlElement) n;
                    object schema = nodeToSchemaMap.GetSchemaForNode( e, FIgnoreNamespace(e) );

                    if (schema != null && schema is DataTable) {
                        DataRow r = GetRowFromElement( e );
                        if (r == null) {
                            // skip columns which has the same name as another table
                            if (parentRow != null && FColumnElement(e))
                                continue;
                                
                            r = ((DataTable)schema).CreateEmptyRow();
                            nodeToRowMap[ e ] = r;

                            // get all field values.
                            LoadRowData( r, e );
                        }

                        // recurse down to inner elements
                        LoadRows( r, n );
                    }
                    else {
                        // recurse down to inner elements
                        LoadRows( null, n );
                    }
                }
            }
        }

        private bool OnlyTextChild(XmlElement el) {
            if (CountNonNSAttributes(el) > 0)
                return false;
                
            XmlNode child = el.FirstChild;
            Object text = null;
            int children = 0;

            while (child != null) {
                if ((child is XmlText) || (child is XmlCDataSection) || (child is XmlEntityReference)) {
                    children++;
                    text = (Object) child;
                }

                if (child is XmlElement || children > 1)
                    return false;
                    
                child = child.NextSibling;
            }
            return (text!=null);
        }

        internal string QualifiedName(string name, string ns) {
            return name + ns;
        }

        private void SetRowValueFromXmlText( DataRow row, DataColumn col, string xmlText ) {
            row[col] = col.ConvertXmlToObject(xmlText);
        }

     
        internal void LoadTopMostRow(ref bool[] foundColumns) {
            Object obj = nodeToSchemaMap.GetSchemaForNode(topMostNode,FIgnoreNamespace(topMostNode));
            if (obj is DataTable) {
                DataTable table = (DataTable) obj;
                topMostRow = table.CreateEmptyRow();
                foundColumns = new bool[topMostRow.Table.Columns.Count];

                //
                // Walk the attributes to find attributes that map to columns.
                //
                foreach( XmlAttribute attr in topMostNode.Attributes ) {
                    object schema = nodeToSchemaMap.GetColumnSchema( attr, FIgnoreNamespace(attr) );

                    if (schema != null && schema is DataColumn) {
                        DataColumn c = (DataColumn) schema;

                        if (c.ColumnMapping == MappingType.Attribute) {
                            XmlNode n = attr.FirstChild;
                            SetRowValueFromXmlText( topMostRow, c, GetInitialTextFromNodes( ref n ) );
                            foundColumns[c.Ordinal] = true;
                        }
                    }
                }

            }
            topMostNode = null;
        }

        private XmlReader dataReader = null;
        private object XSD_XMLNS_NS;
        private object XDR_SCHEMA;
        private object XDRNS;
        private object SQL_SYNC;
        private object UPDGNS;
        private object XSD_SCHEMA;
        private object XSDNS;

        private object DFFNS;
        private object MSDNS;
        private object DIFFID;
        private object HASCHANGES;
        private object ROWORDER;

        private void InitNameTable() {
            XmlNameTable nameTable = dataReader.NameTable;

            XSD_XMLNS_NS = nameTable.Add(Keywords.XSD_XMLNS_NS);
            XDR_SCHEMA = nameTable.Add(Keywords.XDR_SCHEMA);
            XDRNS = nameTable.Add(Keywords.XDRNS);
            SQL_SYNC = nameTable.Add(Keywords.SQL_SYNC);
            UPDGNS = nameTable.Add(Keywords.UPDGNS);
            XSD_SCHEMA = nameTable.Add(Keywords.XSD_SCHEMA);
            XSDNS = nameTable.Add(Keywords.XSDNS);

            DFFNS = nameTable.Add(Keywords.DFFNS);
            MSDNS = nameTable.Add(Keywords.MSDNS);
            DIFFID = nameTable.Add(Keywords.DIFFID);
            HASCHANGES = nameTable.Add(Keywords.HASCHANGES);
            ROWORDER = nameTable.Add(Keywords.ROWORDER);
        }


        internal void LoadData(XmlReader reader) {
            bool fEnforce = dataSet.EnforceConstraints;
            bool [] foundColumns = null;

            dataReader = reader;
            InitNameTable();
            dataSet.EnforceConstraints = false;
            dataSet.fInReadXml = true;

            if (nodeToSchemaMap == null)
                nodeToSchemaMap = new XmlToDatasetMap(dataReader.NameTable, dataSet);

            if (topMostNode != null)
                LoadTopMostRow(ref foundColumns);
            
            int currentDepth = dataReader.Depth;
            while(!dataReader.EOF) { 
                DataTable table = nodeToSchemaMap.GetTableForNode(dataReader,FIgnoreNamespace(dataReader));
                
                DataColumn column = null;
                if (topMostRow!=null)
                    column = (DataColumn) nodeToSchemaMap.GetColumnSchema(topMostRow.Table, dataReader, FIgnoreNamespace(dataReader));
                    
                    
                if (((object)dataReader.LocalName == XDR_SCHEMA && (object)dataReader.NamespaceURI == XDRNS ) || 
                    ((object)dataReader.LocalName == SQL_SYNC   && (object)dataReader.NamespaceURI == UPDGNS) ||
                    ((object)dataReader.LocalName == XSD_SCHEMA && (object)dataReader.NamespaceURI == XSDNS ))
                {
                    dataReader.Skip();
                    continue;
                }

                if ((table == null) && (column!=null))
                   table = column.Table;

                Object ret = LoadData(table);
                if ((ret is String) && (column == null) && (table != null)) {
                        DataRow childRow = table.CreateDefaultRow();    
                        table.Rows.Add(childRow);
                        if (topMostRow != null)
                            childRowsStack.Push(childRow);
                    }

                if (topMostRow != null) {
                    if (ret is String) {
                        if ((column != null) && (!foundColumns[column.Ordinal])) {
                            topMostRow[column] = column.ConvertXmlToObject((String)ret); 
                            foundColumns[column.Ordinal] = true;
                        }
                    }
                    else if (ret is DataRow) {
                        childRowsStack.Push(ret);
                    }
                }

                while (dataReader.NodeType == XmlNodeType.EndElement && currentDepth <= dataReader.Depth)
                    dataReader.Read();

                if (dataReader.Depth < currentDepth)
                   break;
            }
            
            bool fSpecialCase = (topMostRow != null);
        
            if (fSpecialCase) {
                fSpecialCase = (topMostRow.Table.TableName == dataSet.DataSetName);
            }

            if (fSpecialCase) 
                foreach( DataColumn c in topMostRow.Table.Columns ) 
                    if (foundColumns[c.Ordinal]) {
                        fSpecialCase = false;
                        break;
                    }

            if ((!fSpecialCase) && (topMostRow != null)){
                foreach( DataColumn c in topMostRow.Table.Columns ) {
                    if (isDiffgram && !foundColumns[c.Ordinal]) {
                        topMostRow[c] = DBNull.Value;
                        continue;
                    }
                    
                    // Null all columns values that aren't represented in the tree
                    if (XmlToDatasetMap.IsMappedColumn(c) && !foundColumns[c.Ordinal]) {
                        if (!c.AutoIncrement) {
                            if (c.AllowDBNull) {
                                topMostRow[c] = DBNull.Value;
                            }
                            else if (c.DefaultValue != null) {
                                topMostRow[c] = c.DefaultValue;
                            }
                        }
                        else {
                            c.Init(topMostRow.tempRecord);
                        }
                    }
                }

                while (0 != childRowsStack.Count) {
                    DataRow childRow = (DataRow) childRowsStack.Pop();
                    bool unchanged = (childRow.oldRecord == childRow.newRecord);
                    childRow.SetParentRow(topMostRow);
                    if (unchanged)
                        childRow.oldRecord = childRow.newRecord; // it's unchanged
                }
                    
                topMostRow.Table.Rows.Add(topMostRow);
            }
            dataSet.fInReadXml = false;
            dataSet.EnforceConstraints = fEnforce;
        }

        private void GetDiffGramData(ref string hasChanges, ref bool hasErrors, ref String diffId, ref int rowOrder, ref DataRow row, DataTable parentTable, bool [] foundColumns){
            for(int i=0; i<dataReader.AttributeCount;i++){
                dataReader.MoveToAttribute(i);

                // set the Diffgram properties
                if ((dataReader.NamespaceURI!=Keywords.DFFNS) &&  (dataReader.NamespaceURI!=Keywords.MSDNS))
                    continue;

                if ((dataReader.LocalName==Keywords.DIFFID) && (dataReader.NamespaceURI==Keywords.DFFNS)) {
                    if (row == null)
                        row = parentTable.CreateEmptyRow();
                    diffId = dataReader.Value;
                    continue;
                }

                if ((dataReader.LocalName==Keywords.HASCHANGES) && (dataReader.NamespaceURI==Keywords.DFFNS)) {
                    hasChanges = dataReader.Value;
                    continue;
                }

                if ((dataReader.LocalName==Keywords.HASERRORS) && (dataReader.NamespaceURI==Keywords.DFFNS)) {
                    hasErrors = (bool)Convert.ChangeType(dataReader.Value,typeof(bool));
                    continue;
                }

                if  (dataReader.NamespaceURI!=Keywords.MSDNS)
                    continue;

                if (dataReader.LocalName==Keywords.ROWORDER) {
                    rowOrder = (Int32) Convert.ChangeType(dataReader.Value, typeof(Int32));
                    continue;
                }

                if (dataReader.LocalName.StartsWith("hidden")) {
                    DataColumn col = parentTable.Columns[XmlConvert.DecodeName(dataReader.LocalName.Substring(6))];
                    if ((col!= null)  && (col.ColumnMapping == MappingType.Hidden)) {
                        if (row == null)
                            row = parentTable.CreateEmptyRow();
                        row[col] = col.ConvertXmlToObject(dataReader.Value);
                        foundColumns[col.Ordinal] = true;
                    }
                }

            }
            dataReader.MoveToElement();
        }


        private Object LoadData(DataTable parentTable) {
            // keep a list of all columns that get updated
            int currentDepth = dataReader.Depth;
            bool fIgnoreNamespace = FIgnoreNamespace(dataReader);
            int stackSize = childRowsStack.Count;
            DataRow row = null; 
            bool [] foundColumns = null;
            int rowOrder = -1;
            string diffId = "";
            string hasChanges = null;
            bool hasErrors = false;
            String TextValue = "";
            bool isEmpty = dataReader.IsEmptyElement;

            // read the attributes
            if (parentTable != null){
                foundColumns = new bool[parentTable.Columns.Count];
                if (dataReader.AttributeCount>0){
                    for(int i=0; i<dataReader.AttributeCount;i++){
                        dataReader.MoveToAttribute(i);
                        object schema = nodeToSchemaMap.GetColumnSchema( parentTable, dataReader, fIgnoreNamespace);
                        DataColumn col = schema as DataColumn;
                        if ((col != null) && (col.ColumnMapping == MappingType.Attribute)) {
                            if (row==null) 
                                row = parentTable.CreateEmptyRow();
                            row[col] = col.ConvertXmlToObject(dataReader.Value);
                            foundColumns[col.Ordinal] = true;
                        }
                        else if (parentTable.XmlText != null && dataReader.NamespaceURI == Keywords.XSINS && dataReader.LocalName == Keywords.XSI_NIL) {
                            if (XmlConvert.ToBoolean(dataReader.Value)) {
                                if (row==null) 
                                    row = parentTable.CreateEmptyRow();
                                row[parentTable.XmlText] = DBNull.Value;
                                foundColumns[parentTable.XmlText.Ordinal] = true;
                            }
                        }
                    }

                    if (isDiffgram)
                        GetDiffGramData(ref hasChanges, ref hasErrors, ref diffId, ref rowOrder, ref row, parentTable, foundColumns);
                }

            }

            if (!isEmpty) {
               
                TextValue = LoadData( ref row, parentTable, foundColumns);
                if (TextValue != String.Empty) {
                    DataColumn col = parentTable!=null ? parentTable.xmlText : null;
                    if (col!=null) {
                        if (row==null) 
                            row = parentTable.CreateEmptyRow();
                        row[col] = col.ConvertXmlToObject(TextValue);
                        foundColumns[col.Ordinal] = true;
                    }
                }
                if ((stackSize != childRowsStack.Count) &&  (row==null))
                  row = parentTable.CreateEmptyRow();
            }
            else
                dataReader.Read();
            
            if (row!=null) {
                foreach( DataColumn c in row.Table.Columns ) {
                    if (isDiffgram && !foundColumns[c.Ordinal]) {
                        row[c] = DBNull.Value;
                        continue;
                    }
                    // Null all columns values that aren't represented in the tree
                    if (XmlToDatasetMap.IsMappedColumn(c) && !foundColumns[c.Ordinal]) {
                        if (!c.AutoIncrement) {
                            if (c.AllowDBNull) {
                                row[c] = DBNull.Value;
                            }
                            else if (c.DefaultValue != null) {
                                row[c] = c.DefaultValue;
                            }
                        }
                        else {
                            c.Init(row.tempRecord);
                        }
                    }
                }
                     

                while (stackSize != childRowsStack.Count) {
                    DataRow childRow = (DataRow) childRowsStack.Pop();
                    bool unchanged = (childRow.oldRecord == childRow.newRecord);
                    childRow.SetParentRow(row);
                    if (unchanged)
                        childRow.oldRecord = childRow.newRecord; // it's unchanged
                }
                
                if (isDiffgram) {
                    parentTable.Rows.DiffInsertAt(row, rowOrder);

                    if (hasChanges == null) {
                        row.oldRecord = row.newRecord;
                    }

                    if ((hasChanges == Keywords.MODIFIED) || hasErrors) {
                        dataSet.RowDiffId[diffId] = row;	
                    }
                }
                else
                    parentTable.Rows.Add(row);

                while (dataReader.NodeType == XmlNodeType.EndElement && currentDepth <= dataReader.Depth) {
                    dataReader.Read();
                }

                return row;
            } 
            else {
                while (dataReader.NodeType == XmlNodeType.EndElement && currentDepth <= dataReader.Depth)
                    dataReader.Read();
                return TextValue;
            }
        }

        private String LoadData(ref DataRow row, DataTable parentTable, bool[] foundColumns) {
            // keep a list of all columns that get updated
            int currentDepth = dataReader.Depth;
            if (dataReader.NodeType == XmlNodeType.Attribute)
                currentDepth --;
            bool fIgnoreNamespace = FIgnoreNamespace(dataReader);
            String TextValue = String.Empty;
            int stackSize = childRowsStack.Count;
            // DataTable parentTable = (row == null ? null : row.Table);
            Object ret = null;

                
            if (!dataReader.EOF)
                dataReader.Read();

            while(!dataReader.EOF) { 
                if (dataReader.Depth <= currentDepth) // row was empty
                    break;
                
                if (((object)dataReader.LocalName == XDR_SCHEMA && (object)dataReader.NamespaceURI == XDRNS ) || 
                    ((object)dataReader.LocalName == SQL_SYNC   && (object)dataReader.NamespaceURI == UPDGNS) ||
                    ((object)dataReader.LocalName == XSD_SCHEMA && (object)dataReader.NamespaceURI == XSDNS ))
                {
                    dataReader.Skip();
                    continue;
                }

                String localName = dataReader.LocalName;
                fIgnoreNamespace = FIgnoreNamespace(dataReader);

                if (parentTable != null) {
                    switch (dataReader.NodeType) {
                        case XmlNodeType.Element:
                            object schema = nodeToSchemaMap.GetColumnSchema( parentTable, dataReader, fIgnoreNamespace);

                            DataColumn col = schema as DataColumn;

                            DataTable nodeTable = nodeToSchemaMap.GetTableForNode(dataReader,fIgnoreNamespace);

                            if (nodeTable==null && col == null) {
                                dataReader.MoveToElement();
                                dataReader.Read();
                                continue;
                            }
                           
                            if (nodeTable!=null){
                                DataTable childTable =  nodeToSchemaMap.GetTableForNode(dataReader,fIgnoreNamespace);
                                ret = LoadData(childTable);
                                if (ret == null)
                                    continue;

                                if ((ret is String) && (col == null) ) {
                                    DataRow childRow = childTable.CreateDefaultRow();    
                                    childTable.Rows.Add(childRow);
                                    childRowsStack.Push(childRow);
                                    break;
                                }
                                if ((ret is String) && (col != null) && (!foundColumns[col.Ordinal])) {
                                    if (row==null) 
                                        row = parentTable.CreateEmptyRow();
                                   row[col] = col.ConvertXmlToObject((String) ret);
                                   foundColumns[col.Ordinal] = true;
                                   // reader points to next element or end element
                                   break;
                                }
                                if (ret is DataRow) {
                                    if (row==null) 
                                        row = parentTable.CreateEmptyRow();
                                    childRowsStack.Push((DataRow) ret);
                                    break;
                                }
                                // add here the code for the relation
                            } 
                            else {
                                string xsiNilString = dataReader.GetAttribute(Keywords.XSI_NIL, Keywords.XSINS);
                                bool wasFound = foundColumns[col.Ordinal]; // BUG 71884
                                String value = LoadData( ref row, parentTable, foundColumns);
                                if ((value != null) && (!wasFound)){
                                    if (row==null) 
                                        row = parentTable.CreateEmptyRow();
                                    if (value == String.Empty && xsiNilString != null && XmlConvert.ToBoolean(xsiNilString))
                                        row[col] = DBNull.Value;
                                    else
                                        row[col] = col.ConvertXmlToObject(value);
                                    foundColumns[col.Ordinal] = true;
                                }
                            }
                            break;

                        default:
                            if (IsTextLikeNode(dataReader.NodeType) && TextValue==String.Empty)
                                TextValue = dataReader.ReadString();
                            else
                                dataReader.Read();
                            break;
                    }
                } 
                else { // is a root table
                    return null;
                }

            }

            return TextValue;

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\data\system\data\xmltodatasetmap.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlToDatasetMap.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   XmlToDatasetMap.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Data {
    using System;
    using System.Xml;
    using System.Collections;
    using System.Diagnostics;

    // This is an internal helper class used during Xml load to DataSet/DataDocument.
    // XmlToDatasetMap class provides functionality for binding elemants/atributes
    // to DataTable / DataColumn 
    internal class XmlToDatasetMap {

        private class XmlNodeIdentety {
            public string LocalName;
            public string NamespaceURI;
            public XmlNodeIdentety(string localName, string namespaceURI) {
                this.LocalName    = localName;
                this.NamespaceURI = namespaceURI;
            }
            override public int GetHashCode() {
                return ((object) LocalName).GetHashCode();
            }
            override public bool Equals(object obj) {
                XmlNodeIdentety id = (XmlNodeIdentety) obj;
                return (
                  (object) this.LocalName    == (object) id.LocalName    &&
                  (object) this.NamespaceURI == (object) id.NamespaceURI                    
                );
            }
        }

        // This class exist to avoid alocatin of XmlNodeIdentety to every acces to the hash table.
        // Unfortunetely XmlNode doesn't export single identety object.
        internal class XmlNodeIdHashtable : Hashtable {
            private XmlNodeIdentety id = new XmlNodeIdentety(string.Empty, string.Empty);
            public XmlNodeIdHashtable(Int32 capacity) 
                : base(capacity) {}
            public object this[XmlNode node] {
                get {
                    id.LocalName    = node.LocalName;
                    id.NamespaceURI = node.NamespaceURI;
                    return this[id];
                }
            }

            public object this[XmlReader dataReader] {
                get {
                    id.LocalName    = dataReader.LocalName;
                    id.NamespaceURI = dataReader.NamespaceURI;
                    return this[id];
                }
            }

            public object this[DataTable table] {
                get {
                    id.LocalName    = table.EncodedTableName;
                    id.NamespaceURI = table.Namespace;
                    return this[id];
                }
            }

            public object this[string name] {
                get {
                    id.LocalName    = name;
                    id.NamespaceURI = String.Empty;
                    return this[id];
                }
            }



        }

        private class TableSchemaInfo {
            public DataTable          TableSchema;
            public XmlNodeIdHashtable ColumnsSchemaMap;

            public XmlNodeIdHashtable ChildTablesSchemaMap;

            public TableSchemaInfo(DataTable tableSchema) {
                this.TableSchema      = tableSchema;
                this.ColumnsSchemaMap = new XmlNodeIdHashtable(tableSchema.Columns.Count);

                this.ChildTablesSchemaMap = new XmlNodeIdHashtable(tableSchema.ChildRelations.Count);
            }
        }

        XmlNodeIdHashtable tableSchemaMap;

        public XmlToDatasetMap(DataSet dataSet, XmlNameTable nameTable) {
            Debug.Assert(dataSet   != null, "DataSet can't be null");
            Debug.Assert(nameTable != null, "NameTable can't be null");
            BuildIdentityMap(dataSet, nameTable);
        }

        public XmlToDatasetMap(XmlNameTable nameTable, DataSet dataSet) {
            Debug.Assert(dataSet   != null, "DataSet can't be null");
            Debug.Assert(nameTable != null, "NameTable can't be null");
            BuildIdentityMap(nameTable, dataSet);
        }

        static internal bool IsMappedColumn(DataColumn c) {
            return (c.ColumnMapping != MappingType.Hidden);
        }

        private TableSchemaInfo AddTableSchema(DataTable table, XmlNameTable nameTable) {
            // SDUB: Because in our case reader already read the document all names that we can meet in the
            //       document already has an entry in NameTable.
            //       If in future we will build identity map before reading XML we can replace Get() to Add()
            // Sdub: GetIdentity is called from two places: BuildIdentityMap() and LoadRows()
            //       First case deals with decoded names; Second one with encoded names.
            //       We decided encoded names in first case (instead of decoding them in second) 
            //       because it save us time in LoadRows(). We have, as usual, more data them schemas
            string tableLocalName = nameTable.Get(table.EncodedTableName);
            string tableNamespace = nameTable.Get(table.Namespace );
            if(tableLocalName == null) {
                // because name of this table isn't present in XML we don't need mapping for it.
                // Less mapping faster we work.
                return null;
            }
            TableSchemaInfo tableSchemaInfo = new TableSchemaInfo(table);
            tableSchemaMap[new XmlNodeIdentety(tableLocalName, tableNamespace)] = tableSchemaInfo;
            return tableSchemaInfo;
        }

        private TableSchemaInfo AddTableSchema(XmlNameTable nameTable, DataTable table) {
            // Enzol:This is the opposite of the previous function:
            //       we populate the nametable so that the hash comparison can happen as
            //       object comparison instead of strings.
            // Sdub: GetIdentity is called from two places: BuildIdentityMap() and LoadRows()
            //       First case deals with decoded names; Second one with encoded names.
            //       We decided encoded names in first case (instead of decoding them in second) 
            //       because it save us time in LoadRows(). We have, as usual, more data them schemas

            string _tableLocalName = table.EncodedTableName;
            string tableLocalName = nameTable.Get(_tableLocalName);
            if(tableLocalName == null) {
                tableLocalName = nameTable.Add(_tableLocalName);
            }
            table.encodedTableName = tableLocalName;

            string tableNamespace = nameTable.Get(table.Namespace);
            if (tableNamespace == null) {
                tableNamespace = nameTable.Add(table.Namespace);
            }
            else {
                if (table.tableNamespace != null) 
                    table.tableNamespace = tableNamespace;
            }

            TableSchemaInfo tableSchemaInfo = new TableSchemaInfo(table);
            tableSchemaMap[new XmlNodeIdentety(tableLocalName, tableNamespace)] = tableSchemaInfo;
            return tableSchemaInfo;
        }

        private bool AddColumnSchema(DataColumn col, XmlNameTable nameTable, XmlNodeIdHashtable columns) {
            string columnLocalName = nameTable.Get(col.EncodedColumnName );
            string columnNamespace = nameTable.Get(col.Namespace   );
            if(columnLocalName == null) {
                return false;
            }
            XmlNodeIdentety idColumn = new XmlNodeIdentety(columnLocalName, columnNamespace);
            columns[idColumn] = col;
            return true;
        }

        private bool AddColumnSchema(XmlNameTable nameTable, DataColumn col, XmlNodeIdHashtable columns) {
            string _columnLocalName = XmlConvert.EncodeName(col.ColumnName);
            string columnLocalName = nameTable.Get(_columnLocalName);
            if(columnLocalName == null) {
                columnLocalName = nameTable.Add(_columnLocalName);
            }
            col.encodedColumnName = columnLocalName;

            string columnNamespace = nameTable.Get(col.Namespace );
            if(columnNamespace == null) {
                columnNamespace = nameTable.Add(col.Namespace);
            }
            else {
                if (col._columnUri != null ) 
                    col._columnUri = columnNamespace;
            }

            XmlNodeIdentety idColumn = new XmlNodeIdentety(columnLocalName, columnNamespace);
            columns[idColumn] = col;
            return true;
        }

        private bool AddChildTableSchema(XmlNameTable nameTable, DataRelation rel, XmlNodeIdHashtable childtables) {
            string _tableLocalName = XmlConvert.EncodeName(rel.ChildTable.TableName);
            string tableLocalName = nameTable.Get(_tableLocalName);
            if(tableLocalName == null) {
                tableLocalName = nameTable.Add(_tableLocalName);
            }

            string tableNamespace = nameTable.Get(rel.ChildTable.Namespace );

            if(tableNamespace == null) {
                tableNamespace = nameTable.Add(rel.ChildTable.Namespace);
            }

            XmlNodeIdentety idTable = new XmlNodeIdentety(tableLocalName, tableNamespace);
            childtables[idTable] = rel;
            return true;
        }

        private void BuildIdentityMap(DataSet dataSet, XmlNameTable nameTable) {
            this.tableSchemaMap    = new XmlNodeIdHashtable(dataSet.Tables.Count);

            foreach(DataTable t in dataSet.Tables) {
                TableSchemaInfo tableSchemaInfo = AddTableSchema(t, nameTable);
                if(tableSchemaInfo != null) {
                    foreach( DataColumn c in t.Columns ) {
                        // don't include auto-generated PK, FK and any hidden columns to be part of mapping
                        if (IsMappedColumn(c)) {
                            AddColumnSchema(c, nameTable, tableSchemaInfo.ColumnsSchemaMap);
                        }
                    }
                }
            }
        }

        private void BuildIdentityMap(XmlNameTable nameTable, DataSet dataSet) {
            this.tableSchemaMap    = new XmlNodeIdHashtable(dataSet.Tables.Count);
            
            string dsNamespace = nameTable.Get(dataSet.Namespace);
            if (dsNamespace == null) {
                dsNamespace = nameTable.Add(dataSet.Namespace);
            }
            dataSet.namespaceURI = dsNamespace;

            foreach(DataTable t in dataSet.Tables) {
                TableSchemaInfo tableSchemaInfo = AddTableSchema(nameTable, t);
                if(tableSchemaInfo != null) {
                    foreach( DataColumn c in t.Columns ) {
                        // don't include auto-generated PK, FK and any hidden columns to be part of mapping
                        if (IsMappedColumn(c)) {
                            AddColumnSchema(nameTable, c, tableSchemaInfo.ColumnsSchemaMap);
                        }
                    }

                    foreach( DataRelation r in t.ChildRelations ) {
                        if (r.Nested) {
                            // don't include non nested tables
                            AddChildTableSchema(nameTable, r, tableSchemaInfo.ChildTablesSchemaMap);
                        }
                    }
                
                }
            }

        }

        public object GetColumnSchema(XmlNode node, bool fIgnoreNamespace) {
            Debug.Assert(node != null, "Argument validation");
            TableSchemaInfo tableSchemaInfo = null;

            XmlNode nodeRegion = (node.NodeType == XmlNodeType.Attribute) ? ((XmlAttribute)node).OwnerElement : node.ParentNode;
            do {
                if(nodeRegion == null || nodeRegion.NodeType != XmlNodeType.Element) {
                    return null;
                }
                tableSchemaInfo = (TableSchemaInfo) (fIgnoreNamespace ? tableSchemaMap[nodeRegion.LocalName] : tableSchemaMap[nodeRegion]);
                nodeRegion = nodeRegion.ParentNode;
            } while(tableSchemaInfo == null);

            if (fIgnoreNamespace)
                return tableSchemaInfo.ColumnsSchemaMap[node.LocalName];
            else
                return tableSchemaInfo.ColumnsSchemaMap[node];
        }

        public object GetColumnSchema(DataTable table, XmlReader dataReader, bool fIgnoreNamespace){
            TableSchemaInfo tableSchemaInfo = null;
            tableSchemaInfo = (TableSchemaInfo)(fIgnoreNamespace ? tableSchemaMap[table.EncodedTableName] : tableSchemaMap[table]);

            if (fIgnoreNamespace)
                return tableSchemaInfo.ColumnsSchemaMap[dataReader.LocalName];
            else
                return tableSchemaInfo.ColumnsSchemaMap[dataReader];
        }


        public object GetSchemaForNode(XmlNode node, bool fIgnoreNamespace) {
            TableSchemaInfo tableSchemaInfo = null;

            if (node.NodeType == XmlNodeType.Element) {
                tableSchemaInfo = (TableSchemaInfo) (fIgnoreN