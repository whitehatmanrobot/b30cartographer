         DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMulti8Filter(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
    DWORD       MixMulti16(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength);
    DWORD       MixMulti16Filter(short *ppBuffer[], 
                    DWORD dwBufferCount,
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod, 
                    VFRACT vfDeltaVolume[], 
                    VFRACT vfLastVolume[], 
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
    DWORD Mix8Filter(short * pBuffer, 
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
    DWORD Mix16Filter(short * pBuffer, 
                    DWORD dwLength, 
                    DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, 
                    VFRACT vfDeltaRVolume,
                    VFRACT vfLastVolume[],
                    PFRACT pfDeltaPitch, 
                    PFRACT pfSampleLength, 
                    PFRACT pfLoopLength,
                    COEFF cfdK,
                    COEFF cfdB1,
                    COEFF cfdB2);
private:
    void        BeforeBigSampleMix();
    void        AfterBigSampleMix();

private:
    CSourceSample   m_Source;           // Preset values for sample.
    CSynth *        m_pSynth;           // For access to sample rate, etc.

    static PFRACT   m_spfCents[201];    // Pitch increment lookup.
    static PFRACT   m_spfSemiTones[97]; // Four octaves up and down.
    static VFRACT   m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1]; // dB conversion table.
    static BOOL     m_sfMMXEnabled;

private:
    short *     m_pnWave;           // Private pointer to wave.

    PFRACT      m_pfBasePitch;      // Overall pitch.
    PFRACT      m_pfLastPitch;      // The last pitch value.
    PREL        m_prLastPitch;      // Same for pitch, in PREL.
    PFRACT      m_pfLastSample;     // The last sample position.
    PFRACT      m_pfLoopStart;      // Start of loop.
    PFRACT      m_pfLoopEnd;        // End of loop.
    PFRACT      m_pfSampleLength;   // Length of sample buffer.
    BOOL        m_fElGrande;        // Indicates larger than 1m wave.
    ULONGLONG   m_ullLastSample;    // Used to track > 1m wave.
    ULONGLONG   m_ullLoopStart;     // Used to track > 1m wave.
    ULONGLONG   m_ullLoopEnd;       // Used to track > 1m wave.
    ULONGLONG   m_ullSampleLength;  // Used to track > 1m wave.
    DWORD       m_dwAddressUpper;   // Temp storage for upper bits of address.
    BOOL        m_bOneShot;         // Is the source region we're mixing a one-shot?

    /* DLS2 filter members */
    COEFF       m_cfLastK;          // Held filter coefficients
    COEFF       m_cfLastB1;
    COEFF       m_cfLastB2;
    long        m_lPrevSample;      // Last two samples, post-filter
    long        m_lPrevPrevSample;

    /* DirectX8 members */
    CWaveBuffer*    m_pCurrentBuffer;
    CWaveArt*       m_pWaveArt;
    ULONGLONG       m_ullSamplesSoFar;
};


/*  The CVoice class pulls together everything needed to perform
    one voice. It has the envelopes, lfo, and sample embedded
    within it. 

    StartVoice() initializes a voice structure for playback. The
    CSourceRegion structure carries the region and sample as well
    as a pointer to the articulation, which is used to set up
    the various articulation modules. It also carries pointers to 
    all the MIDI modulation inputs and the values for the note key
    and channel which are used by the parent ControlLogic object
    to match incoming note off events with the right voice. 
*/

class CVoice : public CListItem
{
public:
                CVoice();
    CVoice *     GetNext() {return (CVoice *)CListItem::GetNext();};

    BOOL        StartVoice(CSynth *pControl,
                    CSourceRegion *pRegion, STIME stStartTime,
                    CModWheelIn * pModWheelIn, 
                    CPitchBendIn * pPitchBendIn,
                    CExpressionIn * pExpressionIn,
                    CVolumeIn * pVolumeIn,
                    CPanIn * pPanIn,
                    CPressureIn * pPressureIn,
                    CReverbIn * pReverbSend,
                    CChorusIn * pChorusSend,
                    CCutOffFreqIn * PCCutOffFreqIn,
                    CBusIds * pBusIds,
                    WORD nKey,WORD nVelocity,
                    VREL vrVolume,      // Added for GS
                    PREL prPitch);      // Added for GS

    BOOL        StartWave(CSynth *pSynth,
                       CWaveArt *pWaveArt,
                       DWORD dwVoiceId,
                       STIME stStartTime,
                       CPitchBendIn * pPitchBendIn,
                       CExpressionIn * pExpressionIn,   
                       CVolumeIn * pVolumeIn,
                       CPanIn * pPanIn,
                       CReverbIn * pReverbSend,
                       CChorusIn * pChorusSend,
                       CCutOffFreqIn * pCCutOffFreqIn,
                       CBusIds * pBusIds,
                       VREL vrVolume,
                       PREL prPitch,
                       SAMPLE_TIME stVoiceStart,
                       SAMPLE_TIME stLoopStart,
                       SAMPLE_TIME stLoopEnd       
                       );
    static void Init();             // Initialize LFO, Digital Audio.
    void  StopVoice(STIME stTime);// Called on note off event.
    void  QuickStopVoice(STIME stTime);// Called to get quick release.
    void  SpeedRelease();     // Force an already off envelope to release quickly.
    void  ClearVoice();       // Release use of sample.
    void  GetNewPitch(STIME stTime, PREL& prPitch);// Return current pitch value
    void  GetNewVolume(STIME stTime, VREL& vrVolume, VREL& vrVolumeL, VREL& vrVolumeR, VREL& vrVolumeReverb, VREL& vrVolumeChorus);
    void  GetNewCoeff(STIME stTime, PREL& prCutOff, COEFF& cfK, COEFF& cfB1, COEFF& cfB2);
    DWORD Mix(short **ppvBuffer, DWORD dwBufferFlags, DWORD dwLength, STIME stStart,STIME stEnd);
    SAMPLE_POSITION GetCurrentPos();

private:
    static VREL m_svrPanToVREL[128];// Converts Pan to db.
    CVoiceLFO   m_LFO;             // LFO.
    CVoiceEG    m_PitchEG;         // Pitch Envelope.
    CVoiceEG    m_VolumeEG;        // Volume Envelope.
    CDigitalAudio m_DigitalAudio;  // The Digital Audio Engine structure.
    CPitchBendIn *  m_pPitchBendIn; // Pitch bend source.
    CExpressionIn * m_pExpressionIn;// Expression source.
    CVolumeIn * m_pVolumeIn;        // Volume source, if allowed to vary
    CPanIn *    m_pPanIn;           // Pan source, if allowed to vary
    CReverbIn * m_pReverbSend;      //>>>> comment 
    CChorusIn * m_pChorusSend;      //>>>> comment 
    CCutOffFreqIn * m_CCutOffFreqIn;//>>>> comment
    CSynth *    m_pSynth;           // To access sample rate, etc.
    STIME       m_stMixTime;        // Next time we need a mix.
    STIME       m_stLastMix;        // Last sample position mixed.
    long        m_lDefaultPan;      // Default pan
    PREL        m_prLastCutOff;     // Last cut off value.

public:
    DWORD       m_dwNoteID;         // Unique id to keep all voices that represent layers of one note connected.
    STIME       m_stStartTime;      // Time the sound starts.
    STIME       m_stStopTime;       // Time the sound stops.
    STIME       m_stWaveStopTime;   // Stop time set by direct call to stop the wave voice.
    BOOL        m_fInUse;           // This is currently in use.
    BOOL        m_fNoteOn;          // Note is considered on.
    BOOL        m_fTag;             // Used to track note stealing.
    VREL        m_vrVolume;         // Volume, used for voice stealing...
    BOOL        m_fSustainOn;       // Sus pedal kept note on after off event.
    WORD        m_nPart;            // Part that is playing this (channel).
    WORD        m_nKey;             // Note played.
    BOOL        m_fAllowOverlap;    // Allow overlapped note.
    DWORD       m_dwGroup;          // Group this voice is playing now
    DWORD       m_dwProgram;        // Bank and Patch choice.
    DWORD       m_dwPriority;       // Priority.
    CControlLogic * m_pControl;     // Which control group is playing voice.
    DWORD       m_dwVoiceId;        // Used to identify a playing wave
    CSourceRegion *m_pRegion;       // Used to determin which region a voice is playing out of 
    CVoiceFilter m_Filter;          // Low pass filter
    CVoiceLFO   m_LFO2;             // Vibrato
    CBusIds     m_BusIds;           // Bus Id's to playe on this voice
    DWORD       m_dwLoopType;       // Loop type
    BOOL        m_fIgnorePan;       // If we're part of a multichannel wave/sample
    VREL        m_vrLastVolume[MAX_DAUD_CHAN];
    VREL        m_vrBaseVolume[MAX_DAUD_CHAN];    
    VFRACT      m_vfLastVolume[MAX_DAUD_CHAN];  
};


class CVoiceList : public CList
{
public:
    CVoice *     GetHead() {return (CVoice *)CList::GetHead();};
    CVoice *     RemoveHead() {return (CVoice *)CList::RemoveHead();};
    CVoice *     GetItem(LONG lIndex) {return (CVoice *) CList::GetItem(lIndex);};
};

/*  Finally, ControlLogic is the big Kahuna that manages 
    the whole system. It parses incoming MIDI events
    by channel and event type. And, it manages the mixing
    of voices into the buffer.

  MIDI Input:

    The most important events are the note on and
    off events. When a note on event comes in, 
    ControlLogic searches for an available voice.
    ControlLogic matches the channel and finds the
    instrument on that channel. It then call the instrument's
    ScanForRegion() command which finds the region 
    that matches the note. At this point, it can copy
    the region and associated articulation into the
    voice, using the StartVoice command.
    When it receives the sustain pedal command,
    it artificially sets all notes on the channel on
    until a sustain off arrives. To keep track of notes
    that have been shut off while the sustain was on
    it uses an array of 128 shorts, with each bit position 
    representing a channel. When the sustain releases,
    it scans through the array and creates a note off for
    each bit that was set.
    It also receives program change events to set the
    instrument choice for the channel. When such
    a command comes in, it consults the softsynth.ini file 
    and loads an instrument with the file name described
    in the ini file.
    Additional continuous controller events are managed
    by the CModWheelIn, CPitchBendIn, etc., MIDI input recording
    modules.

  Mixing:

    Control Logic is also called to mix the instruments into
    a buffer at regular intervals. The buffer is provided by the
    calling sound driver (initially, AudioMan.) 
    Each voice is called to mix its sample into the buffer.
*/

typedef struct PerfStats
{
    DWORD dwTotalTime;
    DWORD dwTotalSamples;
    DWORD dwNotesLost;
    DWORD dwVoices;
    DWORD dwCPU;
    DWORD dwMaxAmplitude;
} PerfStats;

#define MIX_BUFFER_LEN          500 // Set the sample buffer size to 500 mils
#define MAX_NUM_VOICES          32  
#define NUM_EXTRA_VOICES        8   // Extra voices for when we overload.
#define NUM_DEFAULT_BUSES       4


class CControlLogic
{
public:
                    CControlLogic();
                    ~CControlLogic();
    HRESULT         Init(CInstManager *pInstruments, CSynth *pSynth);
    void            ClearAll();
    void            Flush(STIME stTime); // Clears all events after time.
    BOOL            RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2);
    HRESULT         RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, STIME stTime);
    CSynth *        m_pSynth;
    void            QueueNotes(STIME stStartTime, STIME stEndTime);
    void            ClearMIDI(STIME stEndTime);
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT         SetChannelPriority(DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority);

    /* DirectX8 methods */
    void            QueueWaves(STIME stEndTime);
    void            FlushWaveByStopTime(DWORD dwID, STIME stStopTime);
    BOOL            RecordWaveEvent(STIME stTime, BYTE bChannel, DWORD dwVoiceId, VREL prVolume, PREL prPitch, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd, CWaveArt* pWaveArt);
    HRESULT         AssignChannelToBuses(DWORD dwChannel, LPDWORD pdwBusIds, DWORD dwBusCount);
    
private:
    void            GMReset();
    CInstManager *  m_pInstruments;
    CNoteIn         m_Notes;            // All Note ons and offs.
    CModWheelIn     m_ModWheel[16];     // Sixteen channels of Mod Wheel.
    CPitchBendIn    m_PitchBend[16];    // Sixteen channels of Pitch Bend.
    CVolumeIn       m_Volume[16];       // Sixteen channels of Volume.
    CExpressionIn   m_Expression[16];   // Sixteen channels of Expression.
    CPanIn          m_Pan[16];          // Sixteen channels of Pan.
    CReverbIn       m_ReverbSends[16];  //>>>> comment  
    CChorusIn       m_ChorusSends[16];  //>>>> comment
    CCutOffFreqIn   m_CutOffFreqCC[16]; //>>>> comment
    BOOL            m_fSustain[16];     // Sustain on / off.
    short           m_nCurrentRPN[16];  // RPN number.
    BYTE            m_bBankH[16];       // Bank selects for instrument.
    BYTE            m_bBankL[16];     
    DWORD           m_dwProgram[16];    // Instrument choice.
    BOOL            m_fEmpty;           // Indicates empty lists, no need to flush.
    VREL            m_vrGainAdjust;     // Final stage gain adjust
    DWORD           m_dwPriority[16];   // Priorities for each channel.
    
    BOOL            m_fXGActive;        // Is XG Active?
    BOOL            m_fGSActive;        // Is GS enabled?
    WORD            m_nData[16];        // Used to track RPN reading.
    VREL            m_vrMasterVolume;   // Master Volume.
    PREL            m_prFineTune[16];   // Fine tune for each channel.
    PREL            m_prScaleTune[16][12]; // Alternate scale for each channel.
    PREL            m_prCoarseTune[16]; // Coarse tune.
    BYTE            m_bPartToChannel[16]; // Channel to Part converter.
    BYTE            m_bDrums[16];       // Melodic or which drum?
    BOOL            m_fMono[16];        // Mono mode?

public:
    // This is static to protect the CMIDIRecorder free list, which is also static.
    // 
    static CRITICAL_SECTION s_CriticalSection; // Critical section to manage access.
    static BOOL             s_fCSInitialized;

    static BOOL InitCriticalSection();
    static void KillCriticalSection();

    /* DirectX8 members */
private:
    CWaveIn         m_Waves;            // All waves scheduled to be played
    CPressureIn     m_Pressure[16];     // Sixteen channels of Channel Pressure.
    CBusIds         m_BusIds[16];       // Bus Id's for each channel 
};

#endif // __SYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmsynth\umsynth.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
// UMSynth.h : Declaration of CUserModeSynth

#ifndef __UMSYNTH_H_
#define __UMSYNTH_H_

#include <ks.h>
#include <ksproxy.h>
#include <mmsystem.h>
#include "dsound.h"   
#include "dmusicc.h"
#include "dmusics.h"
#include "CSynth.h"
#include "synth.h"
#include "dsoundp.h"    // For IDirectSoundSource

class CUserModeSynth;

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
// {F5038F82-C052-11D2-872F-00600893B1BD}
DEFINE_GUID(CLSID_DDKSynth, 
0xf5038f82, 0xc052, 0x11d2, 0x87, 0x2f, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

typedef HRESULT (CUserModeSynth::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


#include <pshpack4.h>
struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};
#include <poppack.h>

/////////////////////////////////////////////////////////////////////////////
// CDMSynth

class CUserModeSynth : public IDirectMusicSynth8, public IDirectSoundSource, public IKsControl
{
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
friend class CDSLink;
friend class CClock;
// @@END_DDKSPLIT

public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicSynth
public:
	virtual STDMETHODIMP Open(LPDMUS_PORTPARAMS pPortParams);
	virtual STDMETHODIMP Close(); 
	virtual STDMETHODIMP SetNumChannelGroups(DWORD dwGroups);
	virtual STDMETHODIMP Download(LPHANDLE phDownload, LPVOID pvData, LPBOOL pbFree);
	virtual STDMETHODIMP Unload(HANDLE hDownload,
								HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
								HANDLE hUserData);
	virtual STDMETHODIMP PlayBuffer(REFERENCE_TIME rt, LPBYTE pbBuffer, DWORD cbBuffer);
	virtual STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
	virtual STDMETHODIMP GetPortCaps(LPDMUS_PORTCAPS pCaps);
	virtual STDMETHODIMP SetMasterClock(IReferenceClock *pClock);
	virtual STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
	virtual STDMETHODIMP Activate(BOOL fEnable);
	virtual STDMETHODIMP SetSynthSink(IDirectMusicSynthSink *pSynthSink);
	virtual STDMETHODIMP Render(short *pBuffer, DWORD dwLength, LONGLONG llPosition);
    virtual STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    virtual STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize);
    virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

// IDirectMusicSynth8
public:
	virtual STDMETHODIMP PlayVoice(REFERENCE_TIME rt, DWORD dwVoiceId, DWORD dwChannelGroup, DWORD dwChannel, DWORD dwDLId, PREL prPitch, VREL vrVolume, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd );
    virtual STDMETHODIMP StopVoice(REFERENCE_TIME rt, DWORD dwVoiceId );
    virtual STDMETHODIMP GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] );
    virtual STDMETHODIMP Refresh(DWORD dwDownloadID, DWORD dwFlags );
    virtual STDMETHODIMP AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBuses, DWORD cBuses );

// IDirectSoundSource
public:
    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    virtual STDMETHODIMP SetSink(IDirectSoundConnect* pSinkConnect);
    virtual STDMETHODIMP Seek(ULONGLONG sp);
    virtual STDMETHODIMP Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD cpvBuffer, PULONGLONG pcb);
	virtual STDMETHODIMP GetSize(PULONGLONG pcb);

// IDirectSoundSource : members 
private:
	ULONGLONG m_ullPosition;

// IKsControl
public:
 	virtual STDMETHODIMP KsProperty(
		PKSPROPERTY pPropertyIn, 
		ULONG ulPropertyLength,
		LPVOID pvPropertyData, 
		ULONG ulDataLength,
		PULONG pulBytesReturned);

    virtual STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
	CUserModeSynth();
	~CUserModeSynth();
	HRESULT		Init();

private:
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
	HRESULT		UseDefaultSynthSink();
// @@END_DDKSPLIT
	long		m_cRef;
	IDirectMusicSynthSink *m_pSynthSink;
	IDirectSoundSynthSink *m_pSynthSink8;
	CSynth *	m_pSynth;		// Just one synth engine.
	BOOL		m_fActive;		// Currently active.
	DWORD		m_dwSampleRate;	// Synths sample rate 
	DWORD		m_dwChannels;	// number of ouput channels 
	DWORD 		m_dwBufferFlags;// flags the type of output buffer dssink or interleaved or plain mono
    LONG        m_lVolume;      // in 1/100 dB
    LONG        m_lBoost;       // in 1/100 dB
    LONG        m_lGainAdjust;  // in 1/100 dB
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL        m_fCSInitialized;

    HRESULT HandleSetVolume(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);

    HRESULT HandleSetBoost(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);
        
	HRESULT HandleReverb(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
	HRESULT HandleEffects(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandleGetSampleRate(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    //static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);

};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicSynthFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CDirectMusicSynthFactory();

	// Destructor
	~CDirectMusicSynthFactory();

private:
	long m_cRef;
};



#endif //__UMSYNTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmsynth\umsynth.cpp ===
//
// Copyright (c) 1996-2001 Microsoft Corporation
// UMSynth.cpp : Implementation of CUserModeSynth
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

#pragma warning(disable:4530)

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include <ks.h>

#include "debug.h"
#include "UMSynth.h"
#include "dmusicc.h"
#include "dmusics.h"
#include "math.h"
#include "misc.h"
#include "dmksctrl.h"
#include "dsoundp.h"    // For IDirectSoundSource
#include "..\shared\dmusiccp.h" // For class ids.

#include <dmusprop.h>

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#include "..\shared\validate.h"
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
#include "validate.h"
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

extern long g_cComponent;

/////////////////////////////////////////////////////////////////////
// User mode registry helper
//
BOOL GetRegValueDword(
    LPCTSTR szRegPath,
    LPCTSTR szValueName,
    LPDWORD pdwValue)
{
    HKEY  hKeyOpen;
    DWORD dwType;
    DWORD dwCbData;
    LONG  lResult;
    BOOL  fReturn = FALSE;

    assert(pdwValue);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szRegPath,
                           0, KEY_QUERY_VALUE,
                           &hKeyOpen );

    if (lResult == ERROR_SUCCESS)
    {
        dwCbData = sizeof(DWORD);

        lResult = RegQueryValueEx(hKeyOpen,
                                  szValueName,
                                  NULL,
                                  &dwType,
                                  (LPBYTE)pdwValue,
                                  &dwCbData);

        if (lResult == ERROR_SUCCESS &&
            dwType == REG_DWORD)
        {
            fReturn = TRUE;
        }

        RegCloseKey( hKeyOpen );
    }

    return fReturn;
}

DWORD GetTheCurrentTime()
{
    static BOOL s_fFirstTime = TRUE;
    static LARGE_INTEGER s_liPerfFrequency;
    static BOOL s_fUsePerfCounter = FALSE;
    if (s_fFirstTime)
    {
        s_fFirstTime = FALSE;
        s_fUsePerfCounter = QueryPerformanceFrequency(&s_liPerfFrequency);
        s_liPerfFrequency.QuadPart /= 1000;
    }
    if (s_fUsePerfCounter)
    {
        LARGE_INTEGER liPerfCounter;
        QueryPerformanceCounter(&liPerfCounter);
        liPerfCounter.QuadPart /= s_liPerfFrequency.QuadPart;
        return (DWORD) liPerfCounter.QuadPart;
    }
    else
    {
        return timeGetTime();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CUserModeSynth

HRESULT CUserModeSynth::Init()
{
    return S_OK;
}

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
HRESULT CUserModeSynth::UseDefaultSynthSink()
{
    HRESULT hr = S_OK;
    if (!m_pSynthSink)
    {
        IDirectMusicSynthSink *pSink = NULL;
        hr = CoCreateInstance(CLSID_DirectMusicSynthSink,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDirectMusicSynthSink,
                              (void **) &pSink);
        if (pSink)
        {
            SetSynthSink(pSink);
            pSink->Release();
        }
    }
    return hr;
}
// @@END_DDKSPLIT

CUserModeSynth::CUserModeSynth()
{
    InterlockedIncrement(&g_cComponent);

    m_fCSInitialized = FALSE;
    ::InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCSInitialized = TRUE;

    m_cRef = 0;
    m_dwSampleRate = 22050;
    m_dwChannels = 2;
    m_lVolume = 0;
    m_lBoost = 6 * 100;
    m_lGainAdjust = 6 * 100;            // Default 6 dB boost
    m_fActive = FALSE;
    m_pSynth = NULL;
    m_pSynthSink = NULL;
    m_pSynthSink8 = NULL;
    m_ullPosition = 0;
    m_dwBufferFlags = BUFFERFLAG_INTERLEAVED;
}

CUserModeSynth::~CUserModeSynth()
{
    Activate(FALSE);

    if (m_fCSInitialized)
    {
        ::EnterCriticalSection(&m_CriticalSection);
        if (m_pSynth)
        {
            delete m_pSynth;
            m_pSynth = NULL;
        }

        if (m_pSynthSink)
        {
            m_pSynthSink->Release();
        }

        if (m_pSynthSink8)
        {
            m_pSynthSink8->Release();
        }

        ::LeaveCriticalSection(&m_CriticalSection);
        ::DeleteCriticalSection(&m_CriticalSection);
    }

      InterlockedDecrement(&g_cComponent);
}


// CUserModeSynth::QueryInterface
//
STDMETHODIMP
CUserModeSynth::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicSynth::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicSynth) {
        *ppv = static_cast<IDirectMusicSynth*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicSynth8 )
    {
        *ppv = static_cast<IDirectMusicSynth8*>(this);
    }
    else if (iid == IID_IDirectSoundSource)
    {
        *ppv = static_cast<IDirectSoundSource*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

// CUserModeSynth::AddRef
//
STDMETHODIMP_(ULONG)
CUserModeSynth::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CUserModeSynth::Release
//
STDMETHODIMP_(ULONG)
CUserModeSynth::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CUserModeSynth::SetSynthSink(
    IDirectMusicSynthSink *pSynthSink)    // <i IDirectMusicSynthSink> to connect to synth, or
                                        // NULL to disconnect.
{
    HRESULT hr = S_OK;
    V_INAME(IDirectMusicSynth::SetSynthSink);
    V_INTERFACE_OPT(pSynthSink);

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>>. RELEASE THE DSINK IF PRESENT !!!!

    if (m_pSynthSink)
    {
        hr = m_pSynthSink->Init(NULL);
        m_pSynthSink->Release();
    }

    m_pSynthSink = pSynthSink;

//>>>>>>>>> the current state of the format of the the synth is
//>>>>>>>>> ambiguos if a sink has been previously applied.
    m_dwBufferFlags &= ~BUFFERFLAG_MULTIBUFFER;    // .... just in case

    if (m_pSynthSink)
    {
        m_pSynthSink->AddRef();
        hr = m_pSynthSink->Init(static_cast<IDirectMusicSynth*>(this));
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Open(
    LPDMUS_PORTPARAMS pPortParams)        // <t DMUS_PORTPARAMS> structure for opening the port. If NULL, default settings are used.
{
    V_INAME(IDirectMusicSynth::Open);
    //if (pPortParams == NULL)
    //{
    //    Trace(1, "Error: Open called with NULL PortParams.\n");
    //    return E_FAIL;
    //}

    DWORD cbPortParams = 0;
    DWORD dwVer;

    if (pPortParams)
    {
        V_STRUCTPTR_READ_VER(pPortParams, dwVer);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 7);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 8);
        V_STRUCTPTR_READ_VER_END(DMUS_PORTPARAMS, pPortParams);

        switch (dwVer)
        {
            case 7:
                cbPortParams = sizeof(DMUS_PORTPARAMS7);
                break;

            case 8:
                cbPortParams = sizeof(DMUS_PORTPARAMS8);
                break;
        }
    }

    bool bPartialOpen = false;

    DMUS_PORTPARAMS myParams;
    myParams.dwSize = sizeof (myParams);
    myParams.dwVoices = 32;
    myParams.dwChannelGroups = 2;
    myParams.dwAudioChannels = 2;
    myParams.dwSampleRate = 22050;
#ifdef REVERB_ENABLED
    myParams.dwEffectFlags = DMUS_EFFECT_REVERB;
#else
    myParams.dwEffectFlags = DMUS_EFFECT_NONE;
#endif
    myParams.fShare = FALSE;
    myParams.dwValidParams =
        DMUS_PORTPARAMS_VOICES |
        DMUS_PORTPARAMS_CHANNELGROUPS |
        DMUS_PORTPARAMS_AUDIOCHANNELS |
        DMUS_PORTPARAMS_SAMPLERATE |
        DMUS_PORTPARAMS_EFFECTS |
        DMUS_PORTPARAMS_SHARE;

    if (pPortParams)
    {
        if (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8))
        {
            myParams.dwValidParams |= DMUS_PORTPARAMS_FEATURES;
            myParams.dwFeatures = 0;
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_VOICES)
        {
            if (pPortParams->dwVoices)
            {
                if (pPortParams->dwVoices <= MAX_VOICES)
                {
                    myParams.dwVoices = pPortParams->dwVoices;
                }
                else
                {
                    bPartialOpen = true;
                    myParams.dwVoices = MAX_VOICES;
                }
            }
            else
            {
                bPartialOpen = true;
                myParams.dwVoices = 1; // MIN_VOICES
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            if (pPortParams->dwChannelGroups)
            {
                if (pPortParams->dwChannelGroups <= MAX_CHANNEL_GROUPS)
                {
                    myParams.dwChannelGroups = pPortParams->dwChannelGroups;
                }
                else
                {
                    bPartialOpen = true;
                    myParams.dwChannelGroups = MAX_CHANNEL_GROUPS;
                }
            }
            else
            {
                bPartialOpen = true;
                myParams.dwChannelGroups = 1; // MIN_CHANNEL_GROUPS
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS)
        {
            if (pPortParams->dwAudioChannels)
            {
                if (pPortParams->dwAudioChannels <= 2)
                {
                    myParams.dwAudioChannels = pPortParams->dwAudioChannels;
                }
                else
                {
                    bPartialOpen = true;
                    myParams.dwAudioChannels = 2; // MAX_AUDIO_CHANNELS
                }
            }
            else
            {
                bPartialOpen = true;
                myParams.dwAudioChannels = 1; // MIN_AUDIO_CHANNELS
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE)
        {
            if (dwVer == 7)
            {
                // DX-7 compat: clamp sample rate to one of the
                // understood rates.
                //
                if (pPortParams->dwSampleRate > 30000)
                {
                    if(pPortParams->dwSampleRate != 44100)
                    {
                        bPartialOpen = true;
                    }

                    myParams.dwSampleRate = 44100;
                }
                else if (pPortParams->dwSampleRate > 15000)
                {
                    if(pPortParams->dwSampleRate != 22050)
                    {
                        bPartialOpen = true;
                    }

                    myParams.dwSampleRate = 22050;
                }
                else
                {
                    if(pPortParams->dwSampleRate != 11025)
                    {
                        bPartialOpen = true;
                    }

                    myParams.dwSampleRate = 11025;
                }
            }
            else
            {
                if (pPortParams->dwSampleRate > 96000)
                {
                    bPartialOpen = true;
                    myParams.dwSampleRate = 96000;
                }
                else if (pPortParams->dwSampleRate < 11025)
                {
                    bPartialOpen = true;
                    myParams.dwSampleRate = 11025;
                }
                else myParams.dwSampleRate = pPortParams->dwSampleRate;
            }
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_EFFECTS)
        {
            if (pPortParams->dwEffectFlags & ~DMUS_EFFECT_REVERB)
            {
                bPartialOpen = true;
                pPortParams->dwEffectFlags &= DMUS_EFFECT_REVERB;
            }

#ifdef REVERB_ENABLED
            myParams.dwEffectFlags = pPortParams->dwEffectFlags;
#else
            myParams.dwEffectFlags = DMUS_EFFECT_NONE;
            if (pPortParams->dwEffectFlags & DMUS_EFFECT_REVERB)
            {
                bPartialOpen = true;
            }
#endif
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE)
        {
            if (pPortParams->fShare)
            {
                bPartialOpen = true;
            }
        }

        if ((pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
            (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8)))
        {
            myParams.dwFeatures = pPortParams->dwFeatures;
        }
    }

    if (pPortParams)
    {
        DWORD dwSize = min(cbPortParams, myParams.dwSize);

        memcpy(pPortParams, &myParams, dwSize);
        pPortParams->dwSize = dwSize;
    }

    m_dwSampleRate = myParams.dwSampleRate;
    m_dwChannels = myParams.dwAudioChannels;
    m_dwBufferFlags = (m_dwChannels==1)?BUFFERFLAG_MONO:BUFFERFLAG_INTERLEAVED;

    ::EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = DMUS_E_ALREADYOPEN;
    if (!m_pSynth)
    {
        try
        {
            m_pSynth = new CSynth;
        }
        catch( ... )
        {
            m_pSynth = NULL;
        }

        if (!m_pSynth)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = m_pSynth->Open(myParams.dwChannelGroups,
                myParams.dwVoices,
                (myParams.dwEffectFlags & DMUS_EFFECT_REVERB) ? TRUE : FALSE);
            if (SUCCEEDED(hr))
            {
                m_pSynth->SetGainAdjust(m_lGainAdjust);
                m_pSynth->Activate(m_dwSampleRate, m_dwBufferFlags);
            }
            else
            {
                delete m_pSynth;
                m_pSynth = NULL;
            }
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    if(SUCCEEDED(hr))
    {
        if(bPartialOpen)
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

STDMETHODIMP CUserModeSynth::SetNumChannelGroups(
    DWORD dwGroups)        // Number of ChannelGroups requested.
{
    ::EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    if (m_pSynth)
    {
        hr = m_pSynth->SetNumChannelGroups(dwGroups);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CUserModeSynth::Close()
{
    ::EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = DMUS_E_ALREADYCLOSED;
    if (m_pSynth)
    {
        hr = m_pSynth->Close();
        delete m_pSynth;
        m_pSynth = NULL;
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
STDMETHODIMP CUserModeSynth::Download(
    LPHANDLE phDownload,    // Pointer to download handle, to be created by <om IDirectMusicSynth::Download> and used later to unload the data.
    LPVOID pvData,          // Pointer to continuous memory segment with download data.
    LPBOOL pbFree)          // <p pbFree> indicates whether the synthesizer wishes to keep the memory in <p pvData> allocated.
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    V_INAME(IDirectMusicSynth::Download);
    V_PTR_WRITE(phDownload, HANDLE);
    V_PTR_WRITE(pbFree, BOOL);

    // pvData is validated inside synth while parsing.
    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->Download(phDownload, pvData, pbFree);
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Unload(
    HANDLE hDownload,   // Handle to data, previously downloaded with a call to <om IDirectMusicSynth::Download>.
    HRESULT ( CALLBACK *lpFreeHandle)(HANDLE, HANDLE), // If the original call to
                        // <om IDirectMusicSynth::Download> returned FALSE in <p pbFree>,
                        // the synthesizer hung onto the memory in the download chunk. If so,
                        // the caller must be notified once the memory has been freed,
                        // but that could occur later than <om IDirectMusicSynth::Download>
                        // since a wave might be currently in use. <p lpFreeHandle> is a
                        // pointer to a callback
                        // function which will be called when the memory is no longer in use.
    HANDLE hUserData)   // Pointer to user data, passed as a parameter to the
                        // <p lpFreeHandle> function, typically used so the callback routine can retrieve
                        // its state.
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->Unload(hDownload, lpFreeHandle, hUserData);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CUserModeSynth::PlayBuffer(
    REFERENCE_TIME rt,  // Start time of the buffer. This should be in
                        // REFERENCE_TIME units, relative to the master
                        // clock, previously set with a call to <om IDirectMusicSynth::SetMasterClock>.
                        // And, this should be after the time returned by the clock in
                        // <om IDirectMusicSynth::GetLatencyClock>.
    LPBYTE pbBuffer,    // Memory chunk with all the MIDI events, generated by <i IDirectMusicBuffer>.
    DWORD cbBuffer)     // Size of buffer.
{
    class MIDIEVENT : public DMUS_EVENTHEADER {
    public:
         BYTE  abEvent[4];           /* Actual event data, rounded up to be an even number */
                                     /* of QWORD's (8 bytes) */
    };

    typedef class MIDIEVENT FAR  *LPMIDIEVENT;
    #define QWORD_ALIGN(x) (((x) + 7) & ~7)

    HRESULT hr = DMUS_E_NOT_INIT;

    V_INAME(IDirectMusicSynth::PlayBuffer);
    V_BUFPTR_READ(pbBuffer, cbBuffer);

    ::EnterCriticalSection(&m_CriticalSection);

    if (!m_pSynthSink && !m_pSynthSink8)
    {
        ::LeaveCriticalSection(&m_CriticalSection);
        return DMUS_E_NOSYNTHSINK;
    }

    if (!m_fActive)
    {
        ::LeaveCriticalSection(&m_CriticalSection);
        Trace(3, "Warning: Synth is inactive, can not process MIDI events.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    LPMIDIEVENT lpEventHdr;
    DWORD cbEvent;

    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMUS_EVENTHEADER))
        {
            Trace(1, "Error: PlayBuffer called with error in buffer size.\n");
            ::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }

        lpEventHdr = (LPMIDIEVENT)pbBuffer;
        cbEvent = DMUS_EVENT_SIZE(lpEventHdr->cbEvent);
        if (cbEvent > cbBuffer)
        {
            Trace(1, "Error: PlayBuffer called with error in event size.\n");
            ::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }

        pbBuffer += cbEvent;
        cbBuffer -= cbEvent;
        if ( m_pSynthSink )
        {
            hr = m_pSynth->PlayBuffer(m_pSynthSink,
                                      rt + lpEventHdr->rtDelta,
                                      &lpEventHdr->abEvent[0],
                                      lpEventHdr->cbEvent,
                                      lpEventHdr->dwChannelGroup);
        }

        if ( m_pSynthSink8 )
        {
            hr = m_pSynth->PlayBuffer(m_pSynthSink8,
                                      rt + lpEventHdr->rtDelta,
                                      &lpEventHdr->abEvent[0],
                                      lpEventHdr->cbEvent,
                                      lpEventHdr->dwChannelGroup);
        }

        if (FAILED(hr))
        {
            ::LeaveCriticalSection(&m_CriticalSection);
            return hr;
        }
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}


STDMETHODIMP CUserModeSynth::GetPortCaps(
    LPDMUS_PORTCAPS pCaps)    // <t DMUS_PORTCAPS> structure to be filled in by synth.
{
    V_INAME(IDirectMusicSynth::GetPortCaps);
    V_STRUCTPTR_WRITE(pCaps, DMUS_PORTCAPS);

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    wcscpy(pCaps->wszDescription, L"Microsoft Synthesizer");
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
    wcscpy(pCaps->wszDescription, L"Microsoft DDK Synthesizer");
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

    pCaps->dwClass = DMUS_PC_OUTPUTCLASS;
    pCaps->dwType = DMUS_PORT_USER_MODE_SYNTH;
    pCaps->dwFlags = DMUS_PC_DLS | DMUS_PC_DLS2 | DMUS_PC_SOFTWARESYNTH |
        DMUS_PC_DIRECTSOUND | DMUS_PC_AUDIOPATH | DMUS_PC_WAVE;

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    pCaps->guidPort = CLSID_DirectMusicSynth;
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
    pCaps->guidPort = CLSID_DDKSynth;
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

    pCaps->dwMemorySize = DMUS_PC_SYSTEMMEMORY;
    pCaps->dwMaxChannelGroups = MAX_CHANNEL_GROUPS;
    pCaps->dwMaxVoices = MAX_VOICES;
    pCaps->dwMaxAudioChannels = 2;

    pCaps->dwEffectFlags = 0;
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    pCaps->dwEffectFlags = DMUS_EFFECT_REVERB;
// @@END_DDKSPLIT

    return S_OK;
}

STDMETHODIMP CUserModeSynth::SetMasterClock(
    IReferenceClock *pClock)    // Pointer to master <i IReferenceClock>,
                                // used by all devices in current instance of DirectMusic.

{
    V_INAME(IDirectMusicSynth::SetMasterClock);
    V_INTERFACE(pClock);

    return S_OK;
}

STDMETHODIMP CUserModeSynth::GetLatencyClock(
    IReferenceClock **ppClock)    // <i IReferenceClock> interface designed to return the current mix time.

{
    IDirectSoundSynthSink* pDSSink = NULL;

    V_INAME(IDirectMusicSynth::GetLatencyClock);
    V_PTR_WRITE(ppClock, IReferenceClock *);

    HRESULT hr = DMUS_E_NOSYNTHSINK;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynthSink)
    {
         hr = m_pSynthSink->GetLatencyClock(ppClock);
         ::LeaveCriticalSection(&m_CriticalSection);
    }
     else if (m_pSynthSink8)
    {
         pDSSink = m_pSynthSink8;
         ::LeaveCriticalSection(&m_CriticalSection);

         // FIXME:: The call to GetLatencyClock requres the DSound DLL Mutex and
         // so we have to be outside of the Synth CriticalSection to make the call
         // In theory, pDSSink could have been released by another thread at this point
         //
         // That happens if we get a simultaneous call to the destructor or to SetSink.
         try
         {
            hr = pDSSink->GetLatencyClock(ppClock);
         }
         catch(...)
         {
            // If we're here the pointer to pDSSink has gone bad.
            hr = E_UNEXPECTED;
         }

    }
    else // still need to leave the critical section...
    {
         ::LeaveCriticalSection(&m_CriticalSection);
    }

    return hr;
}

STDMETHODIMP CUserModeSynth::Activate(
    BOOL fEnable)            // Whether to activate or deactivate audio.
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

//    ::EnterCriticalSection(&m_CriticalSection);
    if (fEnable)
    {
        if (m_pSynthSink || m_pSynthSink8)
        {
            if (!m_fActive)
            {
                if (m_dwSampleRate && m_dwChannels)
                {
                    if (m_pSynth)
                    {
                        m_pSynth->Activate(m_dwSampleRate, m_dwBufferFlags);

                        if (m_pSynthSink)
                        {
                            if (SUCCEEDED(m_pSynthSink->Activate(fEnable)))
                            {
                                m_fActive = TRUE;
                                hr = S_OK;
                            }
                        }

                        if ( m_pSynthSink8 )
                        {
                            hr = m_pSynthSink8->Activate(fEnable);
                            if (SUCCEEDED(hr) || hr == DMUS_E_SYNTHACTIVE)
                            {
                                m_fActive = TRUE;
                                hr = S_OK;
                            }
                        }
                    }
                }
            }
            else
            {
                Trace(1, "Error: Synth::Activate- synth already active\n");
                hr = DMUS_E_SYNTHACTIVE;
//>>>>>>>>>>>>>>>>>>>>> what's this about test it before removing????
hr = S_FALSE;
            }
        }
        else
        {
            Trace(1, "Error: Synth::Activate- sink not connected\n");
            hr = DMUS_E_NOSYNTHSINK;
        }
    }
    else
    {
        if (m_fActive)
        {
            m_fActive = FALSE;
            if (m_pSynth)
            {
                m_pSynth->Deactivate();
            }

            if (m_pSynthSink)
            {
                if (SUCCEEDED(m_pSynthSink->Activate(fEnable)))
                {
                    hr = S_OK;
                }
            }

            if (m_pSynthSink8)
            {
                hr = m_pSynthSink8->Activate(fEnable);
            }
        }
        else
        {
            Trace(2, "Warning: Synth::Activate- synth already inactive\n");
            hr = S_FALSE;
        }
    }
//    ::LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CUserModeSynth::Render(
    short *pBuffer,        // Pointer to buffer to write into.
    DWORD dwLength,        // Length of buffer, in samples. This is not the
                        // memory size of the buffer. The memory size may vary,
                        // dependant on the buffer format, which the synth
                        // sets when in response to an <om IDirectMusicSynth::Activate>
                        // command.
    LONGLONG llPosition)    // Position in the audio stream, also in samples.
                        // This should always increment by <p dwLength> after
                        // each call.
{
    V_INAME(IDirectMusicSynth::Render);
    V_BUFPTR_WRITE(pBuffer, dwLength << (m_dwBufferFlags&BUFFERFLAG_INTERLEAVED)?1:0 );

    if (!m_pSynthSink)
    {
        Trace(1, "Error: Synth is not configured, can not render.\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }
    if (!m_fActive)
    {
        Trace(1, "Error: Synth is not inactive, can not render.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        DWORD dwID[2];
        DWORD dwFuncID[2];
        long lPitchBend[2];

        // Setup busid for a Backward compatible DX7 interleaved buffer
        dwID[0]     = DSBUSID_LEFT;
        dwID[1]     = DSBUSID_RIGHT;
        dwFuncID[0] = DSBUSID_LEFT;
        dwFuncID[1] = DSBUSID_RIGHT;
        lPitchBend[0] = lPitchBend[1] = 0;

        DWORD dwChannels = 1;
        if (m_pSynth->m_dwStereo)
        {
            dwChannels = 2;
        }
        m_pSynth->Mix(&pBuffer, dwID, dwFuncID, lPitchBend, dwChannels, m_dwBufferFlags, dwLength, llPosition);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CUserModeSynth::SetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    DWORD dwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->SetChannelPriority(dwChannelGroup, dwChannel, dwPriority);
    }
    Trace(1, "Error: Synth not initialized.\n");
    return E_FAIL;
}

STDMETHODIMP CUserModeSynth::GetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->GetChannelPriority(dwChannelGroup, dwChannel, pdwPriority);
    }
    Trace(1, "Error: Synth not initialized.\n");
    return E_FAIL;
}

// IDirectSoundSource version of GetFormat()

STDMETHODIMP CUserModeSynth::GetFormat(
    LPWAVEFORMATEX pWaveFormatEx,
    DWORD dwSizeAllocated,
    LPDWORD pdwSizeWritten)
{
    V_INAME(IDirectMusicSynth::GetFormat);

    if (!m_pSynth)
    {
        Trace(1, "Error: Synth is not configured, can not get format.\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }

    if (!pWaveFormatEx && !pdwSizeWritten)
    {
        Trace(1, "Error: GetFormat failed, must request either the format or the required size");
        return E_INVALIDARG;
    }

    if (pdwSizeWritten)
    {
        V_PTR_WRITE(pdwSizeWritten, DWORD);
        *pdwSizeWritten = sizeof(WAVEFORMATEX);
    }

    if (pWaveFormatEx)
    {
        V_BUFPTR_WRITE_OPT(pWaveFormatEx, dwSizeAllocated);
        WAVEFORMATEX wfx;
        memset(&wfx, 0, sizeof(wfx));
        wfx.wFormatTag = WAVE_FORMAT_PCM;
        wfx.nChannels = (WORD)m_dwChannels;
        wfx.nSamplesPerSec = (WORD)m_dwSampleRate;
        wfx.wBitsPerSample = 16;
        wfx.nBlockAlign = wfx.nChannels * (wfx.wBitsPerSample / 8);
        wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        wfx.cbSize = 0; // no extra data

        memcpy(pWaveFormatEx, &wfx, min(sizeof wfx, dwSizeAllocated));
    }

    return S_OK;
}

// IDirectMusicSynth8 version of GetFormat()

STDMETHODIMP CUserModeSynth::GetFormat(
    LPWAVEFORMATEX pWaveFormatEx,
    LPDWORD pdwWaveFormatExSize)
{
    V_INAME(IDirectMusicSynth::GetFormat);
    V_PTR_WRITE(pdwWaveFormatExSize, DWORD);
    V_BUFPTR_WRITE_OPT(pWaveFormatEx, *pdwWaveFormatExSize);
    return GetFormat(pWaveFormatEx, *pdwWaveFormatExSize, pdwWaveFormatExSize);
}

STDMETHODIMP CUserModeSynth::GetAppend(
    DWORD* pdwAppend)
{
    V_INAME(IDirectMusicSynth::GetAppend);
    V_PTR_WRITE(pdwAppend, DWORD);

    *pdwAppend = 2; // The synth needs 1 extra sample for loop interpolation.
                    // We're adding one more to be paranoid.
    return S_OK;
}

STDMETHODIMP CUserModeSynth::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)    // <t DMUS_SYNTHSTATS> structure to fill in.

{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    V_INAME(IDirectMusicSynth::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);
    if ( pStats->dwSize == sizeof(DMUS_SYNTHSTATS8) )
    {
        V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS8);
    }

    if (!m_pSynthSink && !m_pSynthSink8)
    {
        Trace(1, "Error: Synth::GetRunningStats failed because synth is inactove.\n");
        return hr;
    }

    if (m_fActive)
    {
        ::EnterCriticalSection(&m_CriticalSection);
        if (m_pSynth)
        {
            PerfStats Stats;
            m_pSynth->GetPerformanceStats(&Stats);
            long lCPU = Stats.dwCPU;
            if (Stats.dwVoices)
            {
                lCPU /= Stats.dwVoices;
            }
            else
            {
                lCPU = 0;
            }
            pStats->dwVoices = Stats.dwVoices;
            pStats->dwCPUPerVoice = lCPU * 10;
            pStats->dwTotalCPU = Stats.dwCPU * 10;
            pStats->dwLostNotes = Stats.dwNotesLost;
            long ldB = 6;
            double fLevel = Stats.dwMaxAmplitude;
            if (Stats.dwMaxAmplitude < 1)
            {
                fLevel = -96.0;
            }
            else
            {
                fLevel /= 32768.0;
                fLevel = log10(fLevel);
                fLevel *= 20.0;
            }
            pStats->lPeakVolume = (long) fLevel;
            pStats->dwValidStats = DMUS_SYNTHSTATS_VOICES | DMUS_SYNTHSTATS_TOTAL_CPU |
                DMUS_SYNTHSTATS_CPU_PER_VOICE | DMUS_SYNTHSTATS_LOST_NOTES | DMUS_SYNTHSTATS_PEAK_VOLUME;

            if ( pStats->dwSize == sizeof(DMUS_SYNTHSTATS8) )
            {
                ((DMUS_SYNTHSTATS8*)pStats)->dwSynthMemUse = m_pSynth->m_Instruments.m_dwSynthMemUse;
            }


            hr = S_OK;
        }
        ::LeaveCriticalSection(&m_CriticalSection);
    }
    else
    {
        DWORD dwSize = pStats->dwSize;
        memset(pStats, 0, dwSize);
        pStats->dwSize = dwSize;

        hr = S_OK;
    }
    return hr;
}

static DWORD dwPropFalse = FALSE;
static DWORD dwPropTrue  = TRUE;
static DWORD dwSystemMemory = DMUS_PC_SYSTEMMEMORY;

GENERICPROPERTY CUserModeSynth::m_aProperty[] =
{
    {
        &GUID_DMUS_PROP_GM_Hardware,        // Set
        0,                                  // Item
        KSPROPERTY_SUPPORT_GET,             // KS support flags
        GENPROP_F_STATIC,                   // GENPROP flags
        &dwPropFalse, sizeof(dwPropFalse),  // static data and size
        NULL                                // Handler
    },
    {   &GUID_DMUS_PROP_GS_Hardware,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse),
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Hardware,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse),
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Capable,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_GS_Capable,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_INSTRUMENT2,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_DLS1,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_DLS2,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    {
        &GUID_DMUS_PROP_SampleMemorySize,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_STATIC,
        &dwSystemMemory,  sizeof(dwSystemMemory),
        NULL
    },
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUME,
        KSPROPERTY_SUPPORT_SET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleSetVolume
    },
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUMEBOOST,
        KSPROPERTY_SUPPORT_SET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleSetBoost
    },
    {
        &GUID_DMUS_PROP_WavesReverb,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleReverb
    },
    {
        &GUID_DMUS_PROP_Effects,
        0,
        KSPROPERTY_SUPPORT_SET | KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleEffects
    },
    {
        &GUID_DMUS_PROP_SamplePlaybackRate,
        0,
        KSPROPERTY_SUPPORT_GET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleGetSampleRate
    }
};

const int CUserModeSynth::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);

HRESULT CUserModeSynth::HandleGetSampleRate(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }
    if (!fSet)
    {
        *(long*)pbBuffer = m_dwSampleRate;
    }
    return S_OK;
}

HRESULT CUserModeSynth::HandleSetVolume(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }

    m_lVolume =  *(LONG*)pbBuffer;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }
    return S_OK;
}

HRESULT CUserModeSynth::HandleSetBoost(
        ULONG               ulId,
        BOOL                fSet,
        LPVOID              pbBuffer,
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }

    m_lBoost =  *(LONG*)pbBuffer;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }
    return S_OK;
}

HRESULT CUserModeSynth::HandleReverb(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    DMUS_WAVES_REVERB_PARAMS *pParams;
    if (*pcbBuffer != sizeof(DMUS_WAVES_REVERB_PARAMS))
    {
        return E_INVALIDARG;
    }

    pParams = (DMUS_WAVES_REVERB_PARAMS *) pbBuffer;
    if (m_pSynth)
    {
        if (fSet)
        {
            m_pSynth->SetReverb(pParams);
        }
        else
        {
            m_pSynth->GetReverb(pParams);
        }
    }

    return S_OK;
}

HRESULT CUserModeSynth::HandleEffects(
    ULONG               ulId,
    BOOL                fSet,
    LPVOID              pbBuffer,
    PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG))
    {
        return E_INVALIDARG;
    }
    if (fSet)
    {
        long lEffects = *(long*)pbBuffer;

        if (m_pSynth)
        {
            m_pSynth->SetReverbActive(lEffects & DMUS_EFFECT_REVERB);
        }
    }
    else
    {
        if (m_pSynth && m_pSynth->IsReverbActive())
        {
            *(long*)pbBuffer = DMUS_EFFECT_REVERB;
        }
        else
        {
            *(long*)pbBuffer = 0;
        }
    }
    return S_OK;
}

//
// CDirectMusicEmulatePort::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CUserModeSynth::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    // Special Case -- We don't support Waves Reverb on a SinthSink8
    if ((rguid == GUID_DMUS_PROP_WavesReverb) && (this->m_pSynthSink8 != NULL))
        return NULL;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid &&
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }



    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

STDMETHODIMP CUserModeSynth::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
            break;

        case KSPROPERTY_TYPE_SET:
            V_BUFPTR_READ(pvPropertyData, ulDataLength);
            break;

        case KSPROPERTY_TYPE_BASICSUPPORT:
            V_BUFPTR_WRITE(pvPropertyData, ulDataLength);
            break;
    }


    V_PTR_WRITE(pulBytesReturned, ULONG);

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        Trace(2, "Warning: KsProperty call requested unknown property.\n");
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                Trace(1, "Error: SynthSink does not support Get for the requested property.\n");
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, FALSE, pvPropertyData, pulBytesReturned);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            if (pvPropertyData != NULL)
            {
                CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            }
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                Trace(1, "Error: SynthSink does not support Set for the requested property.\n");
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, TRUE, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;


        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                Trace(1, "Error: Synth does not provide support for requested property type.\n");
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                Trace(1, "Error: Data size for property is too small.\n");
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;
            *pulBytesReturned = sizeof(DWORD);

            return S_OK;
    }

    Trace(1, "Error: KSProperty Flags must contain one of: %s\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

STDMETHODIMP CUserModeSynth::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}
STDMETHODIMP CUserModeSynth::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}

/////////////////////////////////////////////////////////////////////
// Implementation of IDirectMusicSynth8

STDMETHODIMP CUserModeSynth::PlayVoice(REFERENCE_TIME rt, DWORD dwVoiceId, DWORD dwChannelGroup, DWORD dwChannel, DWORD dwDLId, PREL prPitch, VREL vrVolume, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->PlayVoice(m_pSynthSink8,
                                 rt,
                                 dwVoiceId,
                                 dwChannelGroup,
                                 dwChannel,
                                 dwDLId,
                                 vrVolume,
                                 prPitch,
                                 stVoiceStart,
                                 stLoopStart,
                                 stLoopEnd);
    }
    else
    {
        Trace(1, "Error: Failed wave playback, synth is not properly configured.\n");
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::StopVoice(REFERENCE_TIME rt, DWORD dwVoiceId )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->StopVoice(m_pSynthSink8,
                                 rt,
                                 dwVoiceId);
    }
    else
    {
        Trace(1, "Error: Failed stop of wave playback, synth is not properly configured.\n");
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] )
{
    V_INAME(IDirectMusicSynth::GetVoiceState);
    V_PTR_READ(dwVoice, sizeof(DWORD)*cbVoice);

    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {

        hr = m_pSynth->GetVoiceState(dwVoice,
                                     cbVoice,
                                     VoiceState);

    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Refresh(DWORD dwDownloadID, DWORD dwFlags )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->Refresh(dwDownloadID,
                               dwFlags);
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBuses, DWORD cBuses )
{
    HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
    hr = m_pSynth->AssignChannelToBuses(dwChannelGroup,
                                         dwChannel,
                                         pdwBuses,
                                         cBuses);
    }
    else
    {
        Trace(1, "Error: Failed synth channel assignment, synth is not properly configured.\n");
    }
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

/////////////////////////////////////////////////////////////////////
// Implementation of IDirectSoundSource

STDMETHODIMP CUserModeSynth::SetSink(IDirectSoundConnect* pSinkConnect)
{
    V_INAME(IDirectSoundSink::SetSink);
    V_INTERFACE_OPT(pSinkConnect);

    HRESULT hr = S_OK;

    LPVOID ptr = NULL;
    V_BUFPTR_WRITE_OPT(ptr, 0);

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>> RELEASE THE DSLINK IF PRESENT !!!!

// FIXME: The calls into the SynthSink8 may require the DSound DLL Mutex.  If the Sink
// is making a a call to READ then we end up in a deadlock.  We need to be sure that the
// Synth isn't playing when we do this.

    if (m_pSynthSink8)
    {
        // FIXME: whoever called us->SetSink() should previously have called
        // pOldSink->RemoveSource(us) - it shouldn't be our responsibility to
        // do this call (??):
        // m_pSynthSink8->RemoveSource(this);
        m_pSynthSink8->Release();
        m_pSynthSink8 = NULL;
    }

    if (pSinkConnect)
    {
        // Obtain the IDirectSoundSynthSink interface on the sink
        hr = pSinkConnect->QueryInterface(IID_IDirectSoundSynthSink, (void**)&m_pSynthSink8);

        if (SUCCEEDED(hr))
        {
            //
            // Get the sink's format and validate it
            //
            WAVEFORMATEX wfx;
            DWORD dwSize = sizeof wfx;
            hr = m_pSynthSink8->GetFormat(&wfx, dwSize, NULL);
            if (SUCCEEDED(hr) && wfx.wBitsPerSample != 16 )
            {
                Trace(1, "Error; Synth can not write to any format other than 16 bit PCM.\n");
                hr = DMUS_E_WAVEFORMATNOTSUPPORTED;
            }

            if (SUCCEEDED(hr))
            {
                // Flag the buffer format to be non-interleaved
                m_dwChannels = 1;    // This synth with a sink is concidered a mono source.
                m_dwBufferFlags = BUFFERFLAG_MULTIBUFFER;

                if (m_pSynth)
                {
                    m_pSynth->SetStereoMode(m_dwBufferFlags);

                    // reset sample rate if it has changed
                    if (wfx.nSamplesPerSec != (WORD)m_dwSampleRate)
                    {
                        m_pSynth->SetSampleRate(wfx.nSamplesPerSec);
                    }

                    // disable DX7 Reverb
                    m_pSynth->SetReverbActive(FALSE);
                }
            }
        }
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::Seek(ULONGLONG sp)
{
    m_ullPosition = sp/2;    // Convert from bytes to samples

    return S_OK;
}

STDMETHODIMP CUserModeSynth::Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD dwBufferCount, PULONGLONG pullLength )
{
    V_INAME(IDirectMusicSynth::Read);
    V_PTR_READ(ppvBuffer, sizeof(LPVOID)*dwBufferCount);
    V_PTR_READ(pdwIDs, sizeof(LPDWORD)*dwBufferCount);

    for ( DWORD i = 0; i < dwBufferCount; i++ )
    {
        V_BUFPTR_WRITE(ppvBuffer[i], (DWORD)*pullLength);
        if ( ppvBuffer[i] == NULL )
        {
            Trace(1, "Error: Read called with NULL buffer.\n");
            return E_INVALIDARG;
        }
    }

    if ( *pullLength > 0x00000000FFFFFFFF )    // can't read more than a DWORD's worth of data
    {
        Trace(1, "Error: Read called with invalid buffer length.\n");
        return E_INVALIDARG;
    }

    if ( dwBufferCount == 0 )                // don't read no buffers
    {
        Trace(4, "Warning: Read called with 0 buffers.\n");
        return E_INVALIDARG;
    }
    if (!m_pSynthSink8)
    {
        Trace(1, "Error: Synth is not configured, can not play.\n");
        return DMUS_E_SYNTHNOTCONFIGURED;
    }
    if (!m_fActive)
    {
        Trace(3, "Warning: Synth is not active, can not play.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    ::EnterCriticalSection(&m_CriticalSection);

    if (m_pSynth)
    {
        // Mix
        DWORD dwLength = (DWORD)(*pullLength)/2;    // Convert from bytes to number of samples. Synth assumes 16 bit
        m_pSynth->Mix((short**)ppvBuffer, pdwIDs, pdwFuncIDs, plPitchBends, dwBufferCount, m_dwBufferFlags, dwLength, m_ullPosition);

        // Increment current sample position in the audio stream
        m_ullPosition += dwLength;
    }

    ::LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

STDMETHODIMP CUserModeSynth::GetSize(PULONGLONG pcb)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmsynth\syslink.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// syslink.cpp
//
#include "common.h"
#include <mmsystem.h>


CSysLink::CSysLink()
{
    m_cRef = 1;
}

CSysLink::~CSysLink()
{
}

STDMETHODIMP CSysLink::QueryInterface(const IID &iid, void **ppv)
{
    if (IsEqualGUIDAligned(iid, IID_IUnknown))
    {
        *ppv = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(iid, IID_IDirectMusicSynthSink))
    {
        *ppv = PVOID(PDIRECTMUSICSYNTHSINK(this));
    }
    else
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

STDMETHODIMP_(ULONG) CSysLink::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSysLink::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSysLink::Init(CSynth *pSynth) 
{
    return S_OK;
}

STDMETHODIMP CSysLink::SetFormat(LPCWAVEFORMATEX pWaveFormat)
{
    return S_OK;
}

STDMETHODIMP CSysLink::SetMasterClock(IReferenceClock *pClock)
{
    return S_OK;
}

STDMETHODIMP CSysLink::GetLatencyClock(IReferenceClock **ppClock)
{
    return S_OK;
}

STDMETHODIMP CSysLink::Activate(HWND hWnd, BOOL fEnable)
{
    return S_OK;
}

STDMETHODIMP CSysLink::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)
{
    return S_OK;
}

STDMETHODIMP CSysLink::RefTimeToSample(REFERENCE_TIME rfTime, LONGLONG *pllSampleTime)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmsynth\voice.cpp ===
//
// Voice.cpp
// Copyright (c) 1996-2001 Microsoft Corporation
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#include <math.h>
#include "muldiv32.h"
#else
#include "debug.h"
#include "simple.h"
#include <mmsystem.h>
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include <math.h>
#include <stdio.h>
#include "csynth.h"
#endif

#include "fparms.h" // Generated filter parameter arrays

#ifdef _X86_
#define MMX_ENABLED 1
#endif

#ifdef DBG
extern DWORD sdwDebugLevel;
#endif

CVoiceLFO::CVoiceLFO()
{
    m_pModWheelIn = NULL;
    m_pPressureIn = NULL;
    m_bEnable = TRUE;
}

short CVoiceLFO::m_snSineTable[256];

void CVoiceLFO::Init()
{
    double flTemp;
    long lIndex;

    for (lIndex = 0;lIndex < 256;lIndex++)
    {
        flTemp = lIndex;
        flTemp *= 6.283185307;
        flTemp /= 256.0;
        flTemp = sin(flTemp);
        flTemp *= 100.0;
        m_snSineTable[lIndex] = (short) flTemp;
    }
}


STIME CVoiceLFO::StartVoice(CSourceLFO *pSource,
                    STIME stStartTime, CModWheelIn * pModWheelIn, CPressureIn * pPressureIn)
{
    m_bEnable = TRUE;

    m_pModWheelIn = pModWheelIn;
    m_pPressureIn = pPressureIn;
    m_Source = *pSource;
    m_stStartTime = stStartTime;
    if ((m_Source.m_prMWPitchScale == 0) && (m_Source.m_vrMWVolumeScale == 0) &&
        (m_Source.m_prPitchScale == 0) && (m_Source.m_vrVolumeScale == 0))
    {
        m_stRepeatTime = 44100;
    }
    else
    {
        m_stRepeatTime = 2097152 / m_Source.m_pfFrequency; // (1/8 * 256 * 4096 * 16)
    }
    return (m_stRepeatTime);
}

long CVoiceLFO::GetLevel(STIME stTime, STIME *pstNextTime)
{
    if ( !m_bEnable )
        return 0;

    stTime -= (m_stStartTime + m_Source.m_stDelay);
    if (stTime < 0)
    {
        *pstNextTime = -stTime;
        return (0);
    }
    *pstNextTime = m_stRepeatTime;
    stTime *= m_Source.m_pfFrequency;
    stTime = stTime >> (12 + 4); // We've added 4 extra bits of resolution...
    return (m_snSineTable[stTime & 0xFF]);
}

VREL CVoiceLFO::GetVolume(STIME stTime, STIME *pstNextTime)
{
    VREL vrVolume;
    VREL vrCPVolume;
    VREL vrMWVolume;

    if ( !m_bEnable )
        return 0;

    vrCPVolume = m_pPressureIn->GetPressure(stTime);
    vrCPVolume *= m_Source.m_vrCPVolumeScale;
    vrCPVolume /= 127;

    vrMWVolume = m_pModWheelIn->GetModulation(stTime);
    vrMWVolume *= m_Source.m_vrMWVolumeScale;
    vrMWVolume /= 127;

    vrVolume  = vrMWVolume;
    vrVolume += vrCPVolume;
    vrVolume += m_Source.m_vrVolumeScale;
    vrVolume *= GetLevel(stTime, pstNextTime);
    vrVolume /= 100;
    return (vrVolume);
}

PREL CVoiceLFO::GetPitch(STIME stTime, STIME *pstNextTime)
{
    PREL prPitch;
    PREL prCPPitch;
    PREL prMWPitch;

    if ( !m_bEnable )
        return 0;

    prCPPitch = m_pPressureIn->GetPressure(stTime);
    prCPPitch *= m_Source.m_prCPPitchScale;
    prCPPitch /= 127;

    prMWPitch = m_pModWheelIn->GetModulation(stTime);
    prMWPitch *= m_Source.m_prMWPitchScale;
    prMWPitch /= 127;

    prPitch  = prMWPitch;
    prPitch += prCPPitch;
    prPitch += m_Source.m_prPitchScale;
    prPitch *= GetLevel(stTime, pstNextTime);
    prPitch /= 100;

    return (prPitch);
}

PREL CVoiceLFO::GetCutoff(STIME stTime)
{
    PREL prPitch;
    PREL prCPPitch;
    PREL prMWPitch;
    STIME stNextTime;

    if ( !m_bEnable )
        return 0;

    prCPPitch = m_pPressureIn->GetPressure(stTime);
    prCPPitch *= m_Source.m_prCPCutoffScale;
    prCPPitch /= 127;

    prMWPitch = m_pModWheelIn->GetModulation(stTime);
    prMWPitch *= m_Source.m_prMWCutoffScale;
    prMWPitch /= 127;

    prPitch  = prMWPitch;
    prPitch += prCPPitch;
    prPitch += m_Source.m_prCutoffScale;
    prPitch *= GetLevel(stTime, &stNextTime);
    prPitch /= 100;

    return (prPitch);
}

CVoiceEG::CVoiceEG()
{
    m_stStopTime = 0;
    m_bEnable = TRUE;
}

short CVoiceEG::m_snAttackTable[201];

void CVoiceEG::Init()
{
    double flTemp;
    long lV;

    m_snAttackTable[0] = 0;
    for (lV = 1;lV <= 200; lV++)
    {
        flTemp = lV;
        flTemp /= 200.0;
        flTemp *= flTemp;
        flTemp = log10(flTemp);
        flTemp *= 10000.0;
        flTemp /= 96.0;
        flTemp += 1000.0;
        m_snAttackTable[lV] = (short) flTemp;
    }
}

void CVoiceEG::StopVoice(STIME stTime)
{
    if ( m_bEnable )
    {
        m_Source.m_stRelease *= GetLevel(stTime, &m_stStopTime, TRUE);    // Adjust for current sustain level.
        m_Source.m_stRelease /= 1000;
    }
    m_stStopTime = stTime;
}

void CVoiceEG::QuickStopVoice(STIME stTime, DWORD dwSampleRate)

{
    if ( m_bEnable )
    {
        m_Source.m_stRelease *= GetLevel(stTime, &m_stStopTime, TRUE);    // Adjust for current sustain level.
        m_Source.m_stRelease /= 1000;
        dwSampleRate /= 70;
        if (m_Source.m_stRelease > (long) dwSampleRate)
        {
            m_Source.m_stRelease = dwSampleRate;
        }
    }
    m_stStopTime = stTime;
}

STIME CVoiceEG::StartVoice(CSourceEG *pSource, STIME stStartTime,
                    WORD nKey, WORD nVelocity, STIME stMinAttack)
{
    m_bEnable = TRUE;

    m_stStartTime = stStartTime;
    m_stStopTime = 0x7fffffffffffffff;      // set to indefinite future
    m_Source = *pSource;
    if (m_Source.m_stAttack < stMinAttack)
    {
        m_Source.m_stAttack = stMinAttack;
    }
    if (m_Source.m_stRelease < stMinAttack)
    {
        m_Source.m_stRelease = stMinAttack;
    }

    // apply velocity to attack length scaling here
    m_Source.m_stAttack *= CDigitalAudio::PRELToPFRACT(nVelocity * m_Source.m_trVelAttackScale / 127);
    m_Source.m_stAttack /= 4096;

    m_Source.m_stHold  *= CDigitalAudio::PRELToPFRACT(nKey * m_Source.m_trKeyDecayScale / 127);
    m_Source.m_stHold  /= 4096;

    m_Source.m_stDecay *= CDigitalAudio::PRELToPFRACT(nKey * m_Source.m_trKeyDecayScale / 127);
    m_Source.m_stDecay /= 4096;

    m_Source.m_stDecay *= (1000 - m_Source.m_pcSustain);
    m_Source.m_stDecay /= 1000;

    if ( m_Source.m_stDelay )
        return ((STIME)m_Source.m_stDelay);
    else
        return ((STIME)m_Source.m_stAttack);
}

//note: appears to not be in use
BOOL CVoiceEG::InAttack(STIME st)
{
    if ( !m_bEnable )
        return FALSE;

    // has note been released?
    if (st >= m_stStopTime)
        return FALSE;

    // past length of attack?
    if (st >= m_stStartTime + m_Source.m_stDelay + m_Source.m_stAttack)
        return FALSE;

    return TRUE;
}

BOOL CVoiceEG::InRelease(STIME st)
{
    if ( !m_bEnable )
        return FALSE;

    // has note been released?
    if (st > m_stStopTime)
        return TRUE;

    return FALSE;
}

long CVoiceEG::GetLevel(STIME stEnd, STIME *pstNext, BOOL fVolume)
{
    long lLevel = 0;

    if (stEnd <= m_stStopTime)
    {
        stEnd -= m_stStartTime;
        if (stEnd < m_Source.m_stDelay )
        {
            lLevel = 0;
            *pstNext = m_Source.m_stDelay - stEnd;
        }
        else
        {
            stEnd -= m_Source.m_stDelay;
            if (stEnd < m_Source.m_stAttack )
            {
                // still in attack
                lLevel = 1000 * (long) stEnd;
                if (m_Source.m_stAttack)
                {
                    lLevel /= (long) m_Source.m_stAttack;
                }
                else // This should never happen, but it does...
                {
                    lLevel = 0;
                }
                *pstNext = m_Source.m_stAttack - stEnd;
                if (lLevel < 0) lLevel = 0;
                if (lLevel > 1000) lLevel = 1000;
                if (fVolume)
                {
                    lLevel = m_snAttackTable[lLevel / 5];
                }
            }
            else
            {
                stEnd -= m_Source.m_stAttack;
                if ( stEnd < m_Source.m_stHold )
                {
                    lLevel = 1000;
                    *pstNext = m_Source.m_stHold - stEnd;
                    if (fVolume)
                    {
                        lLevel = m_snAttackTable[lLevel / 5];
                    }
                }
                else
                {
                    stEnd -= m_Source.m_stHold;
                    if (stEnd < m_Source.m_stDecay)
                    {
                        // still in decay
                        lLevel = (1000 - m_Source.m_pcSustain) * (long) stEnd;
                        lLevel /= (long) m_Source.m_stDecay;
                        lLevel = 1000 - lLevel;
                        // To improve the decay curve, set the next point to be 1/4, 1/2, or end of slope.
                        // To avoid close duplicates, fudge an extra 100 samples.
                        if (stEnd < ((m_Source.m_stDecay >> 2) - 100))
                        {
                            *pstNext = (m_Source.m_stDecay >> 2) - stEnd;
                        }
                        else if (stEnd < ((m_Source.m_stDecay >> 1) - 100))
                        {
                            *pstNext = (m_Source.m_stDecay >> 1) - stEnd;
                        }
                        else
                        {
                            *pstNext = m_Source.m_stDecay - stEnd;  // Next is end of decay.
                        }
                    }
                    else
                    {
                        // in sustain
                        lLevel = m_Source.m_pcSustain;
                        *pstNext = 44100;
                    }
                }
            }
        }
    }
    else
    {
        STIME stBogus;
        // in release
        stEnd -= m_stStopTime;

        if (stEnd < m_Source.m_stRelease)
        {
            lLevel = GetLevel(m_stStopTime, &stBogus, fVolume) * (long) (m_Source.m_stRelease - stEnd);
            lLevel /= (long) m_Source.m_stRelease;
            if (stEnd < ((m_Source.m_stRelease >> 2) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 2) - stEnd;
            }
            else if (stEnd < ((m_Source.m_stRelease >> 1) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 1) - stEnd;
            }
            else
            {
                *pstNext = m_Source.m_stRelease - stEnd;  // Next is end of decay.
            }
        }
        else
        {
            lLevel = 0;   // !!! off
            *pstNext = 0x7FFFFFFFFFFFFFFF;
        }
    }

    return lLevel;
}

VREL CVoiceEG::GetVolume(STIME stTime, STIME *pstNextTime)
{
    if ( !m_bEnable )
        return 0;

    VREL vrLevel = GetLevel(stTime, pstNextTime, TRUE) * 96;
    vrLevel /= 10;
    vrLevel = vrLevel - 9600;
    return vrLevel;
}

PREL CVoiceEG::GetPitch(STIME stTime, STIME *pstNextTime)
{
    if ( !m_bEnable )
        return 0;

    PREL prLevel;
    if (m_Source.m_sScale != 0)
    {
        prLevel = GetLevel(stTime, pstNextTime, FALSE);
        prLevel *= m_Source.m_sScale;
        prLevel /= 1000;
    }
    else
    {
        *pstNextTime = 44100;
        prLevel = 0;
    }
    return prLevel;
}

PREL CVoiceEG::GetCutoff(STIME stTime)
{
    if ( !m_bEnable )
        return 0;

    PREL prLevel;
    STIME pstNextTime;  // not used
    if (m_Source.m_prCutoffScale != 0)
    {
        prLevel = GetLevel(stTime, &pstNextTime, FALSE);
        prLevel *= m_Source.m_prCutoffScale;
        prLevel /= 1000;
    }
    else
    {
        prLevel = 0;
    }
    return prLevel;
}

void CVoiceFilter::StartVoice(CSourceFilter *pSource, CVoiceLFO *pLFO, CVoiceEG *pEG, WORD nKey, WORD nVelocity)
{
    m_Source = *pSource;
    m_pLFO = pLFO;
    m_pEG  = pEG;
    m_prVelScale = (nVelocity * m_Source.m_prVelScale) / 127;
    m_prKeyScale = (nKey * m_Source.m_prKeyScale) / 127;
}


/////////////////////////////////////////////////////////////////////////////////
// DLS2 Lowpass Filter Filter
/*

>>>>> finish low pass filter comment

        b1 = -2.0 * r * cos(theta);
        b2 = r * r;
        K  = (1.0 + b1 + b2) * pow(10.0, -qIndex * 0.0375);

  The Filter :

        z  = (K * sample[i]) - (b1 * z1) - (b2 * z2)
        z2 = z1
        z1 = z

>>> B1 negation turned to positive then used as an add instead of subtraction.

  Resonance : Q
    GainUnits

        -qIndex * 0.0375

        0.0375 = 1.5/40 in db's

    Values
        Q min/max Values are 0db to 22.5db
        Q min/max Values are 0   to 225 in 1/10th db's


  Cutoff Fequency : Fc
    Pitch absolute values

        Absolute Pitch = ((1200 * log2(F/440)) + 6900)

    Values
        Initial Fc min/max Values are 200Hz to 7998Hz
        Initial Fc min/max Values are 5535  to 11921 in abosolute pitch cents


  Table Indexs

        65 - entries in the table

                                Hertz   Pitch
        --------------------------------------
        Max Sample Rate     -> 48000Hz (15023) ---|
                               44100Hz (14877)    |
                               22050Hz (13676)    |
                               .......          9488
        Max Cutoff Freq     -> 7999Hz  (11921)    |
                               .......            |
        Min Cutoff Freq     ->  200Hz  (5535)  ---|


        More Acurately .....

        48KHz       15023.26448623030034519401770744100
        200Hz     -  5534.99577150007811000514765931632
                  =====================================
        Feq Range    9488.26871473022223518887004812496

        Feq Range/1200 =  7.906890596 is the Feq Range in octaves
        Feq Range/100  = 94.882687147 is the Feq Range in setimtones


      Behavoir of Fc to indexes according to ouput Sample Rate

        SampleRate of 48k (15023)
            Fc < 5535  (200Hz)   -> fIndex = 0
            Fc = 11921 (7999Hz)  -> fIndex = 63.86
            Fc > 11935 (8064Hz)  -> fIndex = 64

        SampleRate of 41k (14877)
            Fc = 5535  (200Hz)   -> fIndex = 0
            Fc < 5389  (200Hz)   -> fIndex = 0
            Fc > 11789 (7411Hz)  -> fIndex = 64
            Fc = 11921 (7999Hz)  -> fIndex = 65.32

        SampleRate of 22k (13676)
            Fc < 4188  (92Hz)    -> fIndex = 0
            Fc = 5535  (200Hz)   -> fIndex = 13.44
                 10574 (3675Hz)  -> spec min of 1/6th the sample rate
            Fc > 10588 (3704Hz)  -> fIndex = 64
                 11276 (5510Hz)  -> filter fails one octave bellow Nyquist
            Fc = 11921 (7999Hz)  -> fIndex = 77.33
                 12476 (11025Hz) -> nyquist

  Precision

        0.01 - minimal acuracy for interpolation

        9488.2687
        0.00025 +/- error

        m_aB1[0][63] =    0x33ea24fb  = 0.811166044148771133412393865559
        m_aB1[0][64] =  - 0x2fa8ebf5  = 0.744685163483661751713288716704
                        ============
                          0x04413906  = 0.066480880665109381699105148854

        fIndex's fractional constant  = 0.002687147302222351888700481249

        interpolation of
        m_aB1[0][63] + constant       = 0.810987400229642518622447868604

        difference                    = 0.000178643919128614789945996955

        One 2.30 fixpoint bit         = 0.000000000931322575482840254421

        9488.2687147
        7.906890596 * 1200 = 9488.2687152 <-- precision error

        1-bit lossed when going to intger math
*/
//
void CVoiceFilter::GetCoeff(STIME stTime, PREL prFreqIn, COEFF& cfK, COEFF& cfB1, COEFF& cfB2)
{
    PREL prCutoff;
    DWORD dwFract;
    int iQIndex;
    int iIndex;

    //
    // Check if filter is disabled
    //
    if (m_Source.m_prCutoff == 0x7FFF)
    {
        cfK  = 0x40000000;  // is unity in 2.30 fixpoint
        cfB1 = 0;
        cfB2 = 0;
        return;
    }

    //
    // Accumulate the current Cutoff Frequency
    //
    prCutoff  = m_Source.m_prCutoffSRAdjust;
    prCutoff += m_pLFO->GetCutoff(stTime);
    prCutoff += m_pEG->GetCutoff(stTime);
    prCutoff += m_prVelScale;
    prCutoff += prFreqIn;

    //
    // Set the Resonance Q index
    //
    iQIndex = m_Source.m_iQIndex;

    //
    // Set the cutoff frequency index, and retrive
    // the fractional part for interpolation
    //
    iIndex  = prCutoff;
    if ( iIndex >= 0 )
    {
        dwFract = iIndex % 100;
        iIndex /= 100;
    }
    else
    {
        dwFract = 0;
        iIndex  = -1;
    }

    if (iIndex < 0) // Cutoff fequency is less than 100Hz (at 48k Fs)
    {
        cfK  =  m_aK[iQIndex][0];
        cfB1 = m_aB1[iQIndex][0];
        cfB2 = m_aB2[iQIndex][0];
    }
    else if (iIndex >= FILTER_PARMS_DIM_FC - 1)
    {
        cfK  =  m_aK[iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB1 = m_aB1[iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB2 = m_aB2[iQIndex][FILTER_PARMS_DIM_FC - 1];
    }
    else if (iIndex >= FILTER_PARMS_DIM_FC - 5)
    {
        //
        // Not enough headroom to handle the calculation,
        // shift the range douwn by half
        //
        cfK  =  m_aK[iQIndex][iIndex] + (((( m_aK[iQIndex][iIndex+1] -  m_aK[iQIndex][iIndex])   >> 1) * dwFract)/50);
        cfB1 = m_aB1[iQIndex][iIndex] - ((((m_aB1[iQIndex][iIndex]   - m_aB1[iQIndex][iIndex+1]) >> 1) * dwFract)/50);
        cfB2 = m_aB2[iQIndex][iIndex] - ((((m_aB2[iQIndex][iIndex]   - m_aB2[iQIndex][iIndex+1]) >> 1) * dwFract)/50);
    }
    else
    {
        cfK  =  m_aK[iQIndex][iIndex] + (((( m_aK[iQIndex][iIndex+1] -  m_aK[iQIndex][iIndex]))   * dwFract)/100);
        cfB1 = m_aB1[iQIndex][iIndex] - ((((m_aB1[iQIndex][iIndex]   - m_aB1[iQIndex][iIndex+1])) * dwFract)/100);
        cfB2 = m_aB2[iQIndex][iIndex] - ((((m_aB2[iQIndex][iIndex]   - m_aB2[iQIndex][iIndex+1])) * dwFract)/100);
    }
}

//------------------------------------------------------------------------------------
// Reference Filter
// Note: This code is used only for testing or to understance the derivation
// of the above filter code. It was the original source for the current implementation
// aboce was optimized
//------------------------------------------------------------------------------------
/*void CVoiceFilter::GetCoeffRef(STIME stTime, COEFF &cfK, COEFF &cfB1, COEFF &cfB2)
{
    PREL prCutoff;
    int iQIndex;
    int iIndex;
    double fIndex;
    double fIntrp;

    //
    // Check if filter is disabled
    //
    if (m_Source.m_prCutoff == 0x7FFF)
    {
        cfK  = 0x40000000;  // unity in 2.30 fixpoint
        cfB1 = 0;
        cfB2 = 0;
        return;
    }

    //
    // Accumulate the current Cutoff Frequency
    //
    prCutoff  = m_Source.m_prCutoff;
    prCutoff += m_pLFO->GetCutoff(stTime);
    prCutoff += m_pEG->GetCutoff(stTime);
    prCutoff += m_prVelScale;

    //
    // There are 16 resonance values spaced 1.5db arpart
    // DLS2's has a minimum 1.5db error tolerance
    // Range of values it  0db to 22.5db
    // m_Source.m_vrQ are in 1/10 db's
    // The 15.0 represents the 1.5db'in 1/10 db's
    // with the 0.5 for rounding to the nearest index
    //
    iQIndex = (int)((m_Source.m_vrQ / 15.0f) + 0.5f);
    if (iQIndex < 0)
        iQIndex = 0;
    if (iQIndex > FILTER_PARMS_DIM_Q-1) // FILTER_PARMS_DIM_Q = 16
        iQIndex = FILTER_PARMS_DIM_Q-1;

    // >>>>> docdoc
    //
    //
    fIndex = 12.0 * (((prCutoff - m_Source.m_prSampleRate) / 1200.0 ) + 7.906890596);
    iIndex = (int)fIndex;
    fIntrp = fIndex - iIndex;

    if (iIndex < 0)
    {
        cfK  = m_aK [iQIndex][0];
        cfB1 = m_aB1[iQIndex][0];
        cfB2 = m_aB2[iQIndex][0];
    }
    else if (iIndex >= FILTER_PARMS_DIM_FC - 1)
    {
        cfK  = m_aK [iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB1 = m_aB1[iQIndex][FILTER_PARMS_DIM_FC - 1];
        cfB2 = m_aB2[iQIndex][FILTER_PARMS_DIM_FC - 1];
    }
    else
    {
        //
        // Linearly interpolate the fractional part of the index
        // accross two values of the coeficient table
        //
        cfK  = (COEFF)(m_aK[iQIndex][iIndex] * (1.0 - fIntrp) +
                         m_aK[iQIndex][iIndex+1] * fIntrp);

        cfB1 = (COEFF)(m_aB1[iQIndex][iIndex] * (1.0 - fIntrp) +
                         m_aB1[iQIndex][iIndex+1] * fIntrp);

        cfB2 = (COEFF)(m_aB2[iQIndex][iIndex] * (1.0 - fIntrp) +
                         m_aB2[iQIndex][iIndex+1] * fIntrp);
    }
}*/

BOOL CVoiceFilter::IsFiltered()
{
    return (m_Source.m_prCutoff != 0x7FFF);
}

CDigitalAudio::CDigitalAudio()
{
    m_pfBasePitch = 0;
    m_pfLastPitch = 0;
    m_pfLastSample = 0;
    m_pfLoopEnd = 0;
    m_pfLoopStart = 0;
    m_pfSampleLength = 0;
    m_prLastPitch = 0;
    m_ullLastSample = 0;
    m_ullLoopStart = 0;
    m_ullLoopEnd = 0;
    m_ullSampleLength = 0;
    m_fElGrande = FALSE;
    m_pCurrentBuffer = NULL;
    m_pWaveArt = NULL;
    m_ullSamplesSoFar = 0;
    m_lPrevSample = 0;
    m_lPrevPrevSample = 0;
};

CDigitalAudio::~CDigitalAudio()
{
    if (m_pWaveArt)
    {
        m_pWaveArt->Release();
    }
}

PFRACT CDigitalAudio::m_spfCents[201];
PFRACT CDigitalAudio::m_spfSemiTones[97];
VFRACT CDigitalAudio::m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1];
BOOL CDigitalAudio::m_sfMMXEnabled = FALSE;

#ifdef MMX_ENABLED
BOOL MultiMediaInstructionsSupported();
#endif
#pragma optimize("", off) // Optimize causes crash! Argh!

void CDigitalAudio::Init()
{
    double flTemp;
    VREL    vrdB;

#ifdef MMX_ENABLED
    m_sfMMXEnabled = MultiMediaInstructionsSupported();
#endif // MMX_ENABLED
    for (vrdB = MINDB * 10;vrdB <= MAXDB * 10;vrdB++)
    {
        flTemp = vrdB;
        flTemp /= 100.0;
        flTemp = pow(10.0, flTemp);
        flTemp = pow(flTemp, 0.5);   // square root.
        flTemp *= 4095.0; // 2^12th, but avoid overflow...
        m_svfDbToVolume[vrdB - (MINDB * 10)] = (long) flTemp;
    }

    PREL prRatio;

    for (prRatio = -100;prRatio <= 100;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 1200.0;
        flTemp = pow(2.0, flTemp);
        flTemp *= 4096.0;
        m_spfCents[prRatio + 100] = (long) flTemp;
    }

    for (prRatio = -48;prRatio <= 48;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 12.0;
        flTemp = pow(2.0, flTemp);
        flTemp *= 4096.0;
        m_spfSemiTones[prRatio + 48] = (long) flTemp;
    }
}
#pragma optimize("", on)

VFRACT CDigitalAudio::VRELToVFRACT(VREL vrVolume)
{
    vrVolume /= 10;

    if (vrVolume < MINDB * 10)
        vrVolume = MINDB * 10;
    else if (vrVolume >= MAXDB * 10)
        vrVolume = MAXDB * 10;

    return (m_svfDbToVolume[vrVolume - MINDB * 10]);
}

PFRACT CDigitalAudio::PRELToPFRACT(PREL prPitch)
{
    PFRACT pfPitch = 0;
    PREL prOctave;
    if (prPitch > 100)
    {
        if (prPitch > 4800)
        {
            prPitch = 4800;
        }
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = m_spfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= m_spfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
        if (prPitch < -4800)
        {
            prPitch = -4800;
        }
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = m_spfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= m_spfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = m_spfCents[prPitch + 100];
    }
    return (pfPitch);
}

void CDigitalAudio::ClearVoice()

{
    if (m_Source.m_pWave != NULL)
    {
        m_Source.m_pWave->PlayOff();
        m_Source.m_pWave->Release();    // Releases wave structure.
        m_Source.m_pWave = NULL;
    }
    if (m_pWaveArt)
    {
        m_pWaveArt->Release();
        m_pWaveArt = NULL;
    }
}

STIME CDigitalAudio::StartVoice(CSynth *pSynth,
                               CSourceSample *pSample,
                               PREL prBasePitch,
                               long lKey)
{
    m_prLastPitch = 0;
    m_lPrevSample = 0;
    m_lPrevPrevSample = 0;
    m_cfLastK  = 0;
    m_cfLastB1 = 0;
    m_cfLastB2 = 0;

    m_Source = *pSample;
    m_pnWave = pSample->m_pWave->m_pnWave;
    m_pSynth = pSynth;

    m_bOneShot = m_Source.m_bOneShot;

    pSample->m_pWave->AddRef(); // Keeps track of Wave usage.
    pSample->m_pWave->PlayOn();

    // Set initial pitch
    prBasePitch += pSample->m_prFineTune;
    prBasePitch += ((lKey - pSample->m_bMIDIRootKey) * 100);
    m_pfBasePitch = PRELToPFRACT(prBasePitch);
    m_pfBasePitch *= pSample->m_dwSampleRate;
    m_pfBasePitch /= pSynth->m_dwSampleRate;
    m_pfLastPitch = m_pfBasePitch;

    m_fElGrande = pSample->m_dwSampleLength >= 0x80000;     // Greater than 512k.
    if ((pSample->m_dwLoopEnd - pSample->m_dwLoopStart) >= 0x80000)
    {   // We can't handle loops greater than 1 meg!
        m_bOneShot = TRUE;
    }

    m_ullLastSample = 0;
    m_ullLoopStart = pSample->m_dwLoopStart;
    m_ullLoopStart = m_ullLoopStart << 12;
    m_ullLoopEnd = pSample->m_dwLoopEnd;
    m_ullLoopEnd = m_ullLoopEnd << 12;
    m_ullSampleLength = pSample->m_dwSampleLength;
    m_ullSampleLength = m_ullSampleLength << 12;
    m_pfLastSample = 0;
    m_pfLoopStart = (long) m_ullLoopStart;
    m_pfLoopEnd = (long) m_ullLoopEnd;

    if (m_ullLoopEnd <= m_ullLoopStart) // Should never happen, but death if it does!
    {
        m_bOneShot = TRUE;
    }
    if (m_fElGrande)
    {
        m_pfSampleLength = 0x7FFFFFFF;
    }
    else
    {
        m_pfSampleLength = (long) m_ullSampleLength;
    }

    m_pCurrentBuffer = NULL;    // Used by wave playing must be null for standard sample
    m_pWaveArt = NULL;
    m_ullSamplesSoFar = 0;

    return (0); // !!! what is this return value?
}


STIME CDigitalAudio::StartWave(CSynth *pSynth,
                               CWaveArt *pWaveArt,
                               PREL prBasePitch,
                               SAMPLE_TIME stVoiceStart,
                               SAMPLE_TIME stLoopStart,
                               SAMPLE_TIME stLoopEnd)
{
    m_pSynth   = pSynth;    // Save Synth

    if (pWaveArt)
    {
        pWaveArt->AddRef();
    }
    if (m_pWaveArt)
    {
        m_pWaveArt->Release();
    }
    m_pWaveArt = pWaveArt;  // Save Wave articulation

    // Reset all wave buffer flags
    CWaveBuffer* pWavBuf = pWaveArt->m_pWaves.GetHead();
    while ( pWavBuf )
    {
        pWavBuf->m_pWave->m_bActive = FALSE;
        pWavBuf = pWavBuf->GetNext();
    }

    // Initialize the current play buffer
    m_pCurrentBuffer = pWaveArt->m_pWaves.GetHead();;

    //if m_pCurrentBuffer is NULL the articulation contains
    //no samples... this shouldn't be possible.
    assert(m_pCurrentBuffer);

    m_pCurrentBuffer->m_pWave->m_bActive = TRUE;
    m_pCurrentBuffer->m_pWave->AddRef(); // Keeps track of Wave usage.
    m_pCurrentBuffer->m_pWave->PlayOn();

    // Fill CSourceSample class with CWave Defaults
    m_Source.m_pWave          = m_pCurrentBuffer->m_pWave;
    m_Source.m_dwSampleLength = m_pCurrentBuffer->m_pWave->m_dwSampleLength;
    m_Source.m_dwSampleRate   = m_pCurrentBuffer->m_pWave->m_dwSampleRate;
    m_Source.m_bSampleType    = m_pCurrentBuffer->m_pWave->m_bSampleType;
    m_Source.m_dwID           = m_pCurrentBuffer->m_pWave->m_dwID;
    m_Source.m_dwLoopStart    = 0;
    m_Source.m_dwLoopEnd      = m_pCurrentBuffer->m_pWave->m_dwSampleLength;
    m_Source.m_bMIDIRootKey   = 0;
    m_Source.m_prFineTune     = 0;

    m_bOneShot                = TRUE;

    // The the current sample pointer
    m_pnWave = m_pCurrentBuffer->m_pWave->m_pnWave;

    // Set initial pitch
    m_pfBasePitch = PRELToPFRACT(prBasePitch);
    m_pfBasePitch *= m_Source.m_dwSampleRate;
    m_pfBasePitch /= pSynth->m_dwSampleRate;
    m_pfLastPitch = m_pfBasePitch;
    m_prLastPitch = 0;

    m_fElGrande = m_Source.m_dwSampleLength >= 0x80000;     // Greater than 512k.

    m_ullLastSample = stVoiceStart;
    m_ullLastSample = m_ullLastSample << 12;
    m_ullSamplesSoFar = 0;
    m_ullLoopStart = m_Source.m_dwLoopStart;
    m_ullLoopStart = m_ullLoopStart << 12;
    m_ullLoopEnd = m_Source.m_dwLoopEnd;
    m_ullLoopEnd = m_ullLoopEnd << 12;
    m_ullSampleLength = m_Source.m_dwSampleLength;
    m_ullSampleLength = m_ullSampleLength << 12;
    m_pfLastSample = (long) m_ullLastSample;
    m_pfLoopStart = (long) m_ullLoopStart;
    m_pfLoopEnd = (long) m_ullLoopEnd;

    if (stLoopStart || stLoopEnd)
    {
        m_bOneShot = FALSE;

        m_ullLoopStart = stLoopStart;
        m_ullLoopStart = m_ullLoopStart << 12;
        m_ullLoopEnd = stLoopEnd;
        m_ullLoopEnd = m_ullLoopEnd << 12;
        m_pfLoopStart = (long) m_ullLoopStart;
        m_pfLoopEnd = (long) m_ullLoopEnd;
    }

    if ((stLoopEnd - stLoopStart) >= 0x80000)
    {
        m_bOneShot = TRUE;
    }

    // This could be WAY beyond the actual wave data range
    // So find out the sample we want to start at
    if(stVoiceStart > stLoopStart)
    {
        SAMPLE_TIME stLoopLen = stLoopEnd - stLoopStart;
        if(m_bOneShot == FALSE && stLoopLen != 0)
        {
            m_ullLastSample = stVoiceStart - stLoopStart;
            m_ullLastSample = m_ullLastSample - (stLoopLen * (m_ullLastSample / stLoopLen));
            m_ullLastSample = stLoopStart + m_ullLastSample;
            m_ullLastSample = m_ullLastSample << 12;
            m_pfLastSample = (long) (m_ullLastSample);
        }

        // Must be a wave with an start offset?
        // In any case we need to correct this or else we crash
        if(m_bOneShot && stVoiceStart > m_Source.m_dwSampleLength)
        {
            m_ullLastSample = 0;
            m_pfLastSample = 0;
        }
    }


    if(m_fElGrande)
    {
        m_pfSampleLength = 0x7FFFFFFF;
    }
    else
    {
        m_pfSampleLength = (long) m_ullSampleLength;
    }

    return (0);
}

/*  If the wave is bigger than one meg, the index can overflow.
    Solve this by assuming no mix session will ever be as great
    as one meg AND loops are never that long. We keep all our
    fractional indexes in two variables. In one case, m_pfLastSample,
    is the normal mode where the lower 12 bits are the fraction and
    the upper 20 bits are the index. And, m_ullLastSample
    is a LONGLONG with an extra 32 bits of index. The mix engine
    does not want the LONGLONGs, so we need to track the variables
    in the LONGLONGs and prepare them for the mixer as follows:
    Prior to mixing,
    if the sample is large (m_fElGrande is set), BeforeSampleMix()
    is called. This finds the starting point for the mix, which
    is either the current position or the start of the loop,
    whichever is earlier. It subtracts this starting point from
    the LONGLONG variables and stores an offset in m_dwAddressUpper.
    It also adjusts the pointer to the wave data appropriately.
    AfterSampleMix() does the inverse, reconstructing the the LONGLONG
    indeces and returning everthing back to normal.
*/

void CDigitalAudio::BeforeBigSampleMix()
{
    if (m_fElGrande)
    {
        ULONGLONG ullBase = 0;
        DWORD dwBase;
        if (m_bOneShot)
        {
            ullBase = m_ullLastSample;
        }
        else
        {
            if (m_ullLastSample < m_ullLoopStart)
            {
                ullBase = m_ullLastSample;
            }
            else
            {
                ullBase = m_ullLoopStart;
            }
        }

        // Keep the value as we want to offset into the wave buffer
        ULONGLONG ullWaveOffset = ullBase;

        ullBase >>= 12;
        dwBase = (DWORD) ullBase & 0xFFFFFFFE;      // Clear bottom bit so 8 bit pointer aligns with short.
        ullBase = dwBase;
        ullBase <<= 12;
        m_dwAddressUpper = dwBase;

        m_pfLastSample = (long) (m_ullLastSample - ullBase);

        if ((m_ullLoopEnd - ullBase) < 0x7FFFFFFF)
        {
            m_pfLoopStart = (long) (m_ullLoopStart - ullBase);
            m_pfLoopEnd = (long) (m_ullLoopEnd - ullBase);
        }
        else
        {
            m_pfLoopStart = 0;
            m_pfLoopEnd = 0x7FFFFFFF;
        }

        ullBase = m_ullSampleLength - ullBase;
        dwBase = (DWORD)(ullWaveOffset >> 12);

        if (ullBase > 0x7FFFFFFF)
        {
            m_pfSampleLength = 0x7FFFFFFF;
        }
        else
        {
            m_pfSampleLength = (long) ullBase;
        }
        if (m_Source.m_bSampleType & SFORMAT_8)
        {
            dwBase >>= 1;
        }
        m_pnWave = &m_Source.m_pWave->m_pnWave[dwBase];
    }
}

void CDigitalAudio::AfterBigSampleMix()
{
    m_pnWave = m_Source.m_pWave->m_pnWave;
    if (m_fElGrande)
    {
        ULONGLONG ullBase = m_dwAddressUpper;
        m_ullLastSample = m_pfLastSample;
        m_ullLastSample += (ullBase << 12);
        m_dwAddressUpper = 0;
    }
}

BOOL CDigitalAudio::Mix(short **ppBuffers,      // Array of mix buffers
                        DWORD dwBufferCount,    // Number of mix buffers
                        DWORD dwInterleaved,    // Are the buffers interleaved data?
                        DWORD dwLength,         // Length to mix, in samples
                        VREL  vrMaxVolumeDelta, // Maximum volume accross all buses
                        VFRACT vfNewVolume[],
                        VFRACT vfLastVolume[],
                        PREL  prPitch,          // Pitch to play the sample too
                        DWORD dwIsFiltered,     // Is the mix filtered
                        COEFF cfK,              // filter coeficients
                        COEFF cfB1,
                        COEFF cfB2)
{
    DWORD i;
    PFRACT pfDeltaPitch;
    PFRACT pfEnd;
    PFRACT pfLoopLen;
    PFRACT pfNewPitch;
    VFRACT vfDeltaVolume[MAX_DAUD_CHAN];
    DWORD dwPeriod = 64;
    DWORD dwSoFar;
    DWORD dwStart; // position in WORDs
    DWORD dwMixChoice = 0;
    DWORD dwBuffers;
    PFRACT pfPreMix;
    COEFFDELTA  cfdK  = 0;
    COEFFDELTA  cfdB1 = 0;
    COEFFDELTA  cfdB2 = 0;

    if (dwLength == 0)      // Attack was instant.
    {
        m_pfLastPitch = (m_pfBasePitch * PRELToPFRACT(prPitch)) >> 12;
        m_prLastPitch = prPitch;
        m_cfLastK  = cfK;
        m_cfLastB1 = cfB1;
        m_cfLastB2 = cfB2;

        return TRUE;
    }

    if ( m_pWaveArt ) // Playing a wave or Streaming
    {
        if ( m_pWaveArt->m_bStream )
        {
            // Check if the buffer is valid yet
            if ( !m_pCurrentBuffer->m_pWave->m_bValid )
            {
                Trace(3, "Warning: Synth starting mix with invalid streaming wave buffer\n\r");
                return TRUE; // not valid yet, get out of here
            }
            m_pCurrentBuffer->m_pWave->m_bActive = TRUE;

            if ( m_pCurrentBuffer->m_pWave->m_bLastSampleInit == FALSE )
            {
                CWaveBuffer* pnextbuffer = m_pCurrentBuffer->GetNextLoop();

                if ( pnextbuffer->m_pWave->m_bValid )
                {
                    DWORD dwSampleLength = m_pCurrentBuffer->m_pWave->m_dwSampleLength;   // Length of sample.

                    if ( m_Source.m_bSampleType == SFORMAT_8 )
                    {
                        ((BYTE*)m_pCurrentBuffer->m_pWave->m_pnWave)[dwSampleLength-1] = ((BYTE*)pnextbuffer->m_pWave->m_pnWave)[0];
                    }
                    else
                    {
                        m_pCurrentBuffer->m_pWave->m_pnWave[dwSampleLength-1] = pnextbuffer->m_pWave->m_pnWave[0];
                    }

                    m_pCurrentBuffer->m_pWave->m_bLastSampleInit = TRUE;
                }
            }
        }
    }

    if ((m_Source.m_pWave == NULL) || (m_Source.m_pWave->m_pnWave == NULL))
    {
        return FALSE;
    }

    DWORD dwMax = max(vrMaxVolumeDelta, abs(prPitch - m_prLastPitch) << 1);
    dwMax >>= 1;
    m_prLastPitch = prPitch;

    if (dwMax > 0)
    {
        dwPeriod = (dwLength << 3) / dwMax;
        if (dwPeriod > 512)
        {
            dwPeriod = 512;
        }
        else if (dwPeriod < 1)
        {
            dwPeriod = 1;
        }
    }
    else
    {
        dwPeriod = 512;     // Make it happen anyway.
    }

    // This makes MMX sound a little better (MMX bug will be fixed)
    dwPeriod += 3;
    dwPeriod &= 0xFFFFFFFC;

    pfNewPitch = m_pfBasePitch * PRELToPFRACT(prPitch);
    pfNewPitch >>= 12;

    pfDeltaPitch = MulDiv(pfNewPitch - m_pfLastPitch, dwPeriod << 8, dwLength);


    if ( dwInterleaved )
    {
        vfDeltaVolume[0] = MulDiv(vfNewVolume[0] - vfLastVolume[0], dwPeriod << 8, dwLength);
        vfDeltaVolume[1] = MulDiv(vfNewVolume[1] - vfLastVolume[1], dwPeriod << 8, dwLength);
    }
    else
    {
        for (dwBuffers = 0; dwBuffers < dwBufferCount; dwBuffers++)
        {
            vfDeltaVolume[dwBuffers] = MulDiv(vfNewVolume[dwBuffers] - vfLastVolume[dwBuffers], dwPeriod << 8, dwLength);
        }
    }

    if ( dwInterleaved )
    {
        dwMixChoice |= SPLAY_INTERLEAVED;
    }

    if (m_sfMMXEnabled && (dwLength > 8))
    {
        dwMixChoice |= SPLAY_MMX;
    }

    dwMixChoice |= m_Source.m_bSampleType;
    dwStart = 0;

    if (dwIsFiltered)
    {
        dwMixChoice |= SPLAY_FILTERED;

        //
        // The coeficients have been stored as DWORD's to gain an additional
        // bit of presision when calculating the interpolation between
        // coefiecients in the table.  Since these calcutlations always
        // result in positive coefiecients no greater the 1.9999,
        // we can safely cast to a signed int, from which negative deltas
        // can be correctly determined.
        //
        cfdK =  MulDiv((LONG)cfK  - (LONG)m_cfLastK,  dwPeriod, dwLength);
        cfdB1 = MulDiv((LONG)cfB1 - (LONG)m_cfLastB1, dwPeriod, dwLength);
        cfdB2 = MulDiv((LONG)cfB2 - (LONG)m_cfLastB2, dwPeriod, dwLength);
    }

    for (;;)
    {
        if (dwLength <= 8)
        {
            dwMixChoice &= ~SPLAY_MMX;
        }

        if (m_fElGrande)
        {
            BeforeBigSampleMix();
        }

        if (m_bOneShot)
        {
            pfEnd = m_pfSampleLength;
            if(m_pCurrentBuffer && m_pCurrentBuffer->m_pWave)
            {
                // We grow the buffers by one sample for interpolation so we can transition smoothly
                // between the multiple streaming buffers. This will cause a click at the end of the 
                // buffer if the wave is ending as there's no valid nex tbuffer. So we check for that
                // and adjust the length of the buffer so that the mix engine doesn't try to interpolate
                // the additional (last) sample. If it's NOT the last buffer then we proceed as planned.
                if((pfEnd >> 12) >= (long)(m_pCurrentBuffer->m_pWave->m_dwSampleLength - 1))
                {
                    CWaveBuffer* pnextbuffer = m_pCurrentBuffer->GetNextLoop();
                    if(pnextbuffer == NULL || pnextbuffer->m_pWave->m_bValid == FALSE)
                    {
                        pfEnd = (m_pCurrentBuffer->m_pWave->m_dwSampleLength - 2) << 12;    
                    }
                    else
                    {
                        pfEnd = (m_pCurrentBuffer->m_pWave->m_dwSampleLength - 1) << 12;
                    }
                }
            }

            pfLoopLen = 0;
            pfPreMix = m_pfLastSample;      // save off last sample pos
        }
        else
        {
            pfEnd = m_pfLoopEnd;
            pfLoopLen = m_pfLoopEnd - m_pfLoopStart;
            pfPreMix = 0;
            if (pfLoopLen <= pfNewPitch)
            {
                return FALSE;
            }

            if(pfLoopLen > m_pfSampleLength)
            {
                return FALSE;
            }
        }

        switch (dwMixChoice)
        {
        case SFORMAT_8 | SPLAY_INTERLEAVED :
            dwSoFar = Mix8(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 | SPLAY_INTERLEAVED :
            dwSoFar = Mix16(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_8 | SPLAY_INTERLEAVED | SPLAY_FILTERED | SPLAY_MMX : 
        case SFORMAT_8 | SPLAY_INTERLEAVED | SPLAY_FILTERED  : 
            dwSoFar = Mix8Filter(ppBuffers[0],dwLength,dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
        case SFORMAT_16 | SPLAY_INTERLEAVED | SPLAY_FILTERED | SPLAY_MMX : 
        case SFORMAT_16 | SPLAY_INTERLEAVED | SPLAY_FILTERED  : 
            dwSoFar = Mix16Filter(ppBuffers[0],dwLength,dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
#ifdef MMX_ENABLED
        case SFORMAT_8 | SPLAY_MMX | SPLAY_INTERLEAVED :
            dwSoFar = Mix8X(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);

            break;
        case SFORMAT_16 | SPLAY_MMX | SPLAY_INTERLEAVED :
            dwSoFar = Mix16X(ppBuffers[0], dwLength, dwPeriod,
                vfDeltaVolume[0], vfDeltaVolume[1],
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
#endif
        case SFORMAT_8 :
        case SFORMAT_8 | SPLAY_MMX :
            dwSoFar = MixMulti8(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_8 | SPLAY_FILTERED :
        case SFORMAT_8 | SPLAY_FILTERED | SPLAY_MMX :
            dwSoFar = MixMulti8Filter(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
        case SFORMAT_16 :
        case SFORMAT_16 | SPLAY_MMX :
            dwSoFar = MixMulti16(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 | SPLAY_FILTERED :
        case SFORMAT_16 | SPLAY_FILTERED | SPLAY_MMX :
            dwSoFar = MixMulti16Filter(ppBuffers, dwBufferCount,
                dwLength, dwPeriod,
                vfDeltaVolume,
                vfLastVolume,
                pfDeltaPitch,
                pfEnd, pfLoopLen,
                cfdK, cfdB1, cfdB2);
            break;
        default :
            return (FALSE);
        }

        if (m_fElGrande)
        {
            AfterBigSampleMix();
        }

        if (m_bOneShot)
        {
            // have mixed all we needed at this time to break
            if (dwSoFar >= dwLength)
            {
                m_ullSamplesSoFar += (m_pfLastSample - pfPreMix)>>12;
                break;
            }

            // the mix engine reached the end of the source data
            m_ullSamplesSoFar += ((m_pfLastSample - pfPreMix)>>12)-1;

            if ( m_pWaveArt ) // Playing or Streaming a Wave
            {
                if ( !m_pWaveArt->m_bStream )   // we must be at the end of the buffer
                    return FALSE;

                // Set completion flags
                m_pCurrentBuffer->m_pWave->m_bActive = FALSE;
                m_pCurrentBuffer->m_pWave->m_bValid  = FALSE;
                m_pCurrentBuffer->m_pWave->m_bLastSampleInit = FALSE;

                // Get next buffer
                m_pCurrentBuffer = m_pCurrentBuffer->GetNextLoop();

                // Set new wave pointer to play out of
                m_pnWave = m_pCurrentBuffer->m_pWave->m_pnWave;

                // Check if the buffer is valid yet
                if ( !m_pCurrentBuffer->m_pWave->m_bValid )
                {
                    Trace(2, "Warning: Synth attempting to start invalid streaming wave buffer\n\r");
                    break;  // nothing to play yet, get out of here
                }
                m_pCurrentBuffer->m_pWave->m_bActive = TRUE;

                CWaveBuffer* pnextbuffer = m_pCurrentBuffer->GetNextLoop();
                if ( pnextbuffer->m_pWave->m_bValid )
                {
                    DWORD dwSampleLength = m_pCurrentBuffer->m_pWave->m_dwSampleLength;   // Length of sample.

                    if ( m_Source.m_bSampleType == SFORMAT_8 )
                    {
                        ((BYTE*)m_pCurrentBuffer->m_pWave->m_pnWave)[dwSampleLength-1] = ((BYTE*)pnextbuffer->m_pWave->m_pnWave)[0];
                    }
                    else
                    {
                        m_pCurrentBuffer->m_pWave->m_pnWave[dwSampleLength-1] = pnextbuffer->m_pWave->m_pnWave[0];
                    }

                    m_pCurrentBuffer->m_pWave->m_bLastSampleInit = TRUE;
                }

//>>>>>>>>>> CHECK FOR LOOP POINT, IF SO NOT TRY AGAIN HERE

                dwStart  += dwSoFar << dwInterleaved;
                dwLength -= dwSoFar;
                m_pfLastSample = 0;

//>>>>>>>>>> CHECK INTERLEAVED FLAG FOR CORRECT DISTANCE ????????
                // Move buffer pointers since we are mixing more samples
                for ( i = 0; i < dwBufferCount; i++ )
                    ppBuffers[i] += dwStart;

                continue;   // keep playing
            }
            else
                return FALSE;   // Playing a standard one shot, we hit the end of the buffer
        }
        else
        {
            if (dwSoFar >= dwLength)
                break;

            // Loops are handled in the mix engine, however
            // when you reach the end of source data you will
            // reach this code.

            dwStart  += dwSoFar << dwInterleaved;
            dwLength -= dwSoFar;
            m_pfLastSample -= (m_pfLoopEnd - m_pfLoopStart);

            // Move buffer pointers since we are mixing more samples
            for ( i = 0; i < dwBufferCount; i++ )
                ppBuffers[i] += dwStart;
        }
    }

    m_pfLastPitch = pfNewPitch;
    m_cfLastK  = cfK;
    m_cfLastB1 = cfB1;
    m_cfLastB2 = cfB2;

    return (TRUE);
}

CVoice::CVoice()
{
    m_pControl = NULL;
    m_pPitchBendIn = NULL;
    m_pExpressionIn = NULL;
    m_dwPriority = 0;
    m_nPart = 0;
    m_nKey = 0;
    m_fInUse = FALSE;
    m_fSustainOn = FALSE;
    m_fNoteOn = FALSE;
    m_fTag = FALSE;
    m_stStartTime = 0;
    m_stStopTime = 0x7fffffffffffffff;
    m_stWaveStopTime = 0;
    m_vrVolume = 0;
    m_fAllowOverlap = FALSE;
    m_pRegion = NULL;
    m_pReverbSend = NULL;
    m_pChorusSend = NULL;
    m_dwLoopType = 0;

    for ( int i = 0; i < MAX_DAUD_CHAN; i++ )
    {
        m_vfLastVolume[i] = 0;
        m_vrLastVolume[i] = 0;
    }
}

VREL CVoice::m_svrPanToVREL[128];

void CVoice::Init()
{
    static BOOL fBeenHereBefore = FALSE;
    if (fBeenHereBefore) return;
    fBeenHereBefore = TRUE;
    CVoiceLFO::Init();
    CVoiceEG::Init();
    CDigitalAudio::Init();

    WORD nI;
    for (nI = 1; nI < 128; nI++)
    {
        double flTemp;
        flTemp = nI;
        flTemp /= 127.0;
        flTemp = log10(flTemp);
        flTemp *= 1000.0;
        m_svrPanToVREL[nI] = (long) flTemp;
    }
    m_svrPanToVREL[0] = -2500;
}

void CVoice::StopVoice(STIME stTime)
{
    if (m_fNoteOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.StopVoice(stTime);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
        m_stWaveStopTime = 0;

        if (m_dwLoopType == WLOOP_TYPE_RELEASE)
        {
            m_DigitalAudio.BreakLoop();
        }
    }
}

void CVoice::QuickStopVoice(STIME stTime)
{
    m_fTag = TRUE;
    if (m_fNoteOn || m_fSustainOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.QuickStopVoice(stTime, m_pSynth->m_dwSampleRate);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
    }
    else
    {
        m_VolumeEG.QuickStopVoice(m_stStopTime, m_pSynth->m_dwSampleRate);
    }
}

BOOL CVoice::StartVoice(CSynth *pSynth,
                           CSourceRegion *pRegion,
                           STIME stStartTime,
                           CModWheelIn * pModWheelIn,
                           CPitchBendIn * pPitchBendIn,
                           CExpressionIn * pExpressionIn,
                           CVolumeIn * pVolumeIn,
                           CPanIn * pPanIn,
                           CPressureIn * pPressureIn,
                           CReverbIn * pReverbSend,
                           CChorusIn * pChorusSend,
                           CCutOffFreqIn * pCCutOffFreqIn,
                           CBusIds * pBusIds,
                           WORD nKey,
                           WORD nVelocity,
                           VREL vrVolume,
                           PREL prPitch)
{
    m_pSynth = pSynth;

    CSourceArticulation * pArticulation = pRegion->m_pArticulation;
    if (pArticulation == NULL)
    {
        return FALSE;
    }

    m_dwLoopType = pRegion->m_Sample.m_dwLoopType;

    // if we're going to handle volume later, don't read it now.
    if (!pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += pVolumeIn->GetVolume(stStartTime);

    prPitch += pRegion->m_prTuning;
    m_dwGroup = pRegion->m_bGroup;
    m_fAllowOverlap = pRegion->m_bAllowOverlap;

    vrVolume += CMIDIRecorder::VelocityToVolume(nVelocity);

    vrVolume += pRegion->m_vrAttenuation;

    m_lDefaultPan = pRegion->m_pArticulation->m_sDefaultPan;

    // ignore pan here if allowing pan to vary after note starts
    // or if the source is multichannel or the dest is mono
    //

    m_fIgnorePan = pRegion->IsMultiChannel();
    if (pBusIds->m_dwBusCount == 1)
    {
        DWORD dwFunctionID;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[0], &dwFunctionID, NULL, NULL))
        {
            if (dwFunctionID == DSBUSID_LEFT)
            {
                m_fIgnorePan = TRUE;
            }
        }
    }

    VREL vrVolumeL;
    VREL vrVolumeR;
    if ( pSynth->m_dwStereo &&
        !pSynth->m_fAllowPanWhilePlayingNote &&
        !m_fIgnorePan)
    {
        long lPan = pPanIn->GetPan(stStartTime) + m_lDefaultPan;

        if (lPan < 0)
            lPan = 0;

        if (lPan > 127)
            lPan = 127;

        vrVolumeL = m_svrPanToVREL[127 - lPan] + vrVolume;
        vrVolumeR = m_svrPanToVREL[lPan] + vrVolume;
    }
    else
    {
        vrVolumeL = vrVolume;
        vrVolumeR = vrVolume;
    }

    VREL vrVolumeReverb = vrVolume;
    VREL vrVolumeChorus = vrVolume;

    PREL prBusPitchBend = 0;  // This gets a pitch offset that is set by DSound in response to SetFrequency and Doppler commands.
                             // When this is applied to multiple buses, only one of the values can be used, so we always give
                             // preference to the buffer that has DSBUSID_DYNAMIC_0 for the functional id, since that
                             // would most likely be a 3D sound effect.
    BOOL fDynamic = false;

    for( DWORD i = 0; i < pBusIds->m_dwBusCount; i++ )
    {
        DWORD dwFunctionID;
        PREL prGetPitch = 0;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[i], &dwFunctionID, &prGetPitch, NULL))
        {
            if (!fDynamic)
            {
                // If no previous bus was dynamic, get this value.
                prBusPitchBend = prGetPitch;
            }
            m_vrBaseVolume[i] = MIN_VOLUME;

            if (DSBUSID_IS_SPKR_LOC(dwFunctionID))
            {
                if (pRegion->IsMultiChannel())
                {
                    // Explicit channel assignment with no pan. For every bus
                    // that matches a bit in the channel mask, turn it on.
                    //
                    if (pRegion->m_dwChannel & (1 << dwFunctionID))
                    {
                        m_vrBaseVolume[i] = vrVolume;
                    }
                }
                else
                {
                    switch(dwFunctionID)
                    {
                    case DSBUSID_LEFT:
                        m_vrBaseVolume[i] = vrVolumeL;
                        break;

                    case DSBUSID_RIGHT:
                        m_vrBaseVolume[i] = vrVolumeR;
                        break;
                    }
                }
            }
            else
            {
                // Not a speaker location, a send or a 3D buffer.
                //
                switch(dwFunctionID)
                {
                case DSBUSID_REVERB_SEND:
                    m_vrBaseVolume[i] = vrVolumeReverb;
                    break;

                case DSBUSID_CHORUS_SEND:
                    m_vrBaseVolume[i] = vrVolumeChorus;
                    break;

                case DSBUSID_NULL:
                    m_vrBaseVolume[i] = MIN_VOLUME;
                    break;

                case DSBUSID_DYNAMIC_0:
                    fDynamic = true;
                default:
                    m_vrBaseVolume[i] = vrVolume;
                }
            }

            m_vrLastVolume[i] = MIN_VOLUME;
            m_vfLastVolume[i] = m_DigitalAudio.VRELToVFRACT(MIN_VOLUME);
        }
    }

    m_stMixTime = m_LFO.StartVoice(&pArticulation->m_LFO,
        stStartTime, pModWheelIn, pPressureIn);

    STIME stMixTime = m_LFO2.StartVoice(&pArticulation->m_LFO2,
        stStartTime, pModWheelIn, pPressureIn);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }

    stMixTime = m_PitchEG.StartVoice(&pArticulation->m_PitchEG,
        stStartTime, nKey, nVelocity, 0);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }

    // Force attack to never be shorter than a millisecond.
    stMixTime = m_VolumeEG.StartVoice(&pArticulation->m_VolumeEG,
        stStartTime, nKey, nVelocity, pSynth->m_dwSampleRate/1000);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }

    if (m_stMixTime > pSynth->m_stMaxSpan)
    {
        m_stMixTime = pSynth->m_stMaxSpan;
    }

    m_Filter.StartVoice(&pArticulation->m_Filter,
        &m_LFO, &m_PitchEG, nKey, nVelocity);

    // Make sure we have a pointer to the wave ready:
    if ((pRegion->m_Sample.m_pWave == NULL) || (pRegion->m_Sample.m_pWave->m_pnWave == NULL))
    {
        return (FALSE);     // Do nothing if no sample.
    }

    m_DigitalAudio.StartVoice(pSynth,
                              &pRegion->m_Sample,
                              prPitch,
                              (long)nKey);

    m_pPitchBendIn = pPitchBendIn;
    m_pExpressionIn = pExpressionIn;
    m_pPanIn = pPanIn;
    m_pReverbSend = pReverbSend;
    m_pChorusSend = pChorusSend;
    m_CCutOffFreqIn = pCCutOffFreqIn;
    m_pVolumeIn = pVolumeIn;
    m_BusIds = *pBusIds;
    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_fSustainOn = FALSE;
    m_stStartTime = stStartTime;
    m_stLastMix = stStartTime - 1;
    m_stStopTime = 0x7fffffffffffffff;
    m_stWaveStopTime = 0;

    //
    // Zero length attack,
    // be sure initial settings aren't missed....
    //
    if (m_stMixTime == 0)
    {
        PREL  prNewPitch;
        COEFF cfK, cfB1, cfB2;

        GetNewPitch(stStartTime, prNewPitch);
        GetNewCoeff(stStartTime, m_prLastCutOff, cfK, cfB1, cfB2);

        m_DigitalAudio.Mix(NULL,
                           0,
                           0,
                           0,
                           0,
                           NULL,
                           NULL,
                           prNewPitch + prBusPitchBend,
                           m_Filter.IsFiltered(),
                           cfK, cfB1, cfB2);
    }

    m_vrVolume = MAX_VOLUME;

    return (TRUE);
}

BOOL CVoice::StartWave(CSynth *pSynth,
                       CWaveArt *pWaveArt,
                       DWORD dwVoiceId,
                       STIME stStartTime,
                       CPitchBendIn * pPitchBendIn,
                       CExpressionIn * pExpressionIn,
                       CVolumeIn * pVolumeIn,
                       CPanIn * pPanIn,
                       CReverbIn * pReverbSend,
                       CChorusIn * pChorusSend,
                       CCutOffFreqIn * pCCutOffFreqIn,
                       CBusIds * pBusIds,
                       VREL vrVolume,
                       PREL prPitch,
                       SAMPLE_TIME stVoiceStart,
                       SAMPLE_TIME stLoopStart,
                       SAMPLE_TIME stLoopEnd
                       )
{
    m_pSynth = pSynth;

    DWORD dwFuncId = pWaveArt->m_WaveArtDl.ulBus;

    VREL vrVolumeReverb = vrVolume;
    VREL vrVolumeChorus = vrVolume;

    m_fIgnorePan = (BOOL)(DSBUSID_IS_SPKR_LOC(dwFuncId) && (pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL));
    if (pBusIds->m_dwBusCount == 1)
    {
        DWORD dwFunctionID;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[0], &dwFunctionID, NULL, NULL))
        {
            if (dwFunctionID == DSBUSID_LEFT)
            {
                m_fIgnorePan = TRUE;
            }
        }
    }

    for( DWORD i = 0; i < pBusIds->m_dwBusCount; i++ )
    {
        m_vrBaseVolume[i] = MIN_VOLUME;

        DWORD dwFunctionID;
        if (m_pSynth->BusIDToFunctionID(pBusIds->m_dwBusIds[i], &dwFunctionID, NULL, NULL))
        {
            // If this bus is a speaker location
            //
            if (DSBUSID_IS_SPKR_LOC(dwFunctionID))
            {
                if (pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL)
                {
                    if (dwFuncId == dwFunctionID)
                    {
                        m_vrBaseVolume[i] = vrVolume;
                    }
                }
                else
                {
                    if (dwFunctionID == DSBUSID_LEFT || dwFunctionID == DSBUSID_RIGHT)
                    {
                        m_vrBaseVolume[i] = vrVolume;
                    }
                }
            }
            else switch (dwFunctionID)
            {
            case DSBUSID_REVERB_SEND:
                m_vrBaseVolume[i] = vrVolumeReverb;
                break;

            case DSBUSID_CHORUS_SEND:
                m_vrBaseVolume[i] = vrVolumeChorus;
                break;

            case DSBUSID_NULL:
                m_vrBaseVolume[i] = MIN_VOLUME;
                break;

            default:
                m_vrBaseVolume[i] = vrVolume;
            }

            m_vrLastVolume[i] = MIN_VOLUME;
            m_vfLastVolume[i] = m_DigitalAudio.VRELToVFRACT(MIN_VOLUME);
        }
    }

    // Initialize an envelope for wave playing
    //
    CSourceEG WaveVolumeEG;
    WaveVolumeEG.Init();
    WaveVolumeEG.m_pcSustain = 1000;
    // Force the envelope attack and release to be no smaller than 4ms. This ensures we won't get
    // clicks if we start and stop at non-zero crossings.
    m_stMixTime = m_VolumeEG.StartVoice(&WaveVolumeEG, stStartTime, 0, 0, pSynth->m_dwSampleRate/250);
    if (m_stMixTime > pSynth->m_stMaxSpan)
    {
        m_stMixTime = pSynth->m_stMaxSpan;
    }

    m_pPitchBendIn = pPitchBendIn;
    m_pExpressionIn = pExpressionIn;
    m_pPanIn = pPanIn;
    m_pReverbSend = pReverbSend;
    m_pChorusSend = pChorusSend;
    m_CCutOffFreqIn = pCCutOffFreqIn;
    m_pVolumeIn = pVolumeIn;
    m_BusIds = *pBusIds;
    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_stStartTime = stStartTime;
    m_stLastMix = stStartTime - 1;
    m_stStopTime = 0x7fffffffffffffff;
    m_stWaveStopTime = 0;
    m_dwGroup = 0;
    m_lDefaultPan = 0;
    m_vrVolume = 0;
    m_fAllowOverlap = FALSE;
    m_fSustainOn = FALSE;
    m_dwVoiceId = dwVoiceId;

    m_LFO.Enable(FALSE);             // Disable LFO.
    m_LFO2.Enable(FALSE);            // Disable LFO2.
    m_PitchEG.Enable(FALSE);         // Disable Pitch Envelope.
    m_Filter.m_Source.m_prCutoff = 0x7FFF;

    m_DigitalAudio.StartWave(pSynth,
                             pWaveArt,
                             prPitch,
                             stVoiceStart,
                             stLoopStart,
                             stLoopEnd);

    return (TRUE);
}

SAMPLE_POSITION CVoice::GetCurrentPos()
{
    return m_DigitalAudio.GetCurrentPos();
}

void CVoice::ClearVoice()
{
    m_fInUse = FALSE;
    m_DigitalAudio.ClearVoice();
}

// return the volume delta at time <stTime>.
// volume is sum of volume envelope, LFO, expression, optionally the
// channel volume if we're allowing it to change, and optionally the current
// pan if we're allowing that to change.
// This will be added to the base volume calculated in CVoice::StartVoice().
inline void CVoice::GetNewVolume(STIME stTime, VREL& vrVolume, VREL& vrVolumeL, VREL& vrVolumeR, VREL& vrVolumeReverb, VREL& vrVolumeChorus)
{
    STIME stMixTime = m_stMixTime;

    //
    // the evelope volume is used by code that detects whether this note is off
    // and for voice stealing
    //
    m_vrVolume = m_VolumeEG.GetVolume(stTime, &stMixTime);
    if (stMixTime < m_stMixTime)
        m_stMixTime = stMixTime;

    vrVolume = m_vrVolume;
    vrVolume += m_LFO.GetVolume(stTime, &stMixTime);
    if (stMixTime < m_stMixTime)
        m_stMixTime = stMixTime;

    vrVolume += m_pExpressionIn->GetVolume(stTime);

    if (m_pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += m_pVolumeIn->GetVolume(stTime);

    vrVolume += m_pSynth->m_vrGainAdjust;

    // handle pan here if allowing pan to vary after note starts
    vrVolumeL = vrVolume;
    vrVolumeR = vrVolume;
    if (m_pSynth->m_dwStereo && m_pSynth->m_fAllowPanWhilePlayingNote && !m_fIgnorePan)
    {
        // add current pan & instrument default pan
        LONG lPan;

        if (m_pPanIn)
        {
            lPan = m_pPanIn->GetPan(stTime) + m_lDefaultPan;
        }
        else
        {
            lPan = 63;
        }

        // don't go off either end....
        if (lPan < 0) lPan = 0;
        if (lPan > 127) lPan = 127;
        vrVolumeL += m_svrPanToVREL[127 - lPan];
        vrVolumeR += m_svrPanToVREL[lPan];
    }
    // Get Reverb Send volume
    vrVolumeReverb  = vrVolume + m_pReverbSend->GetVolume(stTime);
    // Get Chorus Send volume
    vrVolumeChorus  = vrVolume + m_pChorusSend->GetVolume(stTime);
}

// Returns the current pitch for time <stTime>.
// Pitch is the sum of the pitch LFO, the pitch envelope, and the current
// pitch bend.
inline void CVoice::GetNewPitch(STIME stTime, PREL& prPitch)
{
    STIME stMixTime = m_stMixTime;

    prPitch = m_LFO.GetPitch(stTime, &stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;

    prPitch += m_LFO2.GetPitch(stTime, &stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;

    prPitch += m_PitchEG.GetPitch(stTime, &stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;

    prPitch += m_pPitchBendIn->GetPitch(stTime);
}

// Returns the current cutoff frequency for time <stTime>.
// cutoff frequency is the sum of the pitch LFO, the pitch envelope, and the current
// MIDI filter CC control.
inline void CVoice::GetNewCoeff(STIME stTime, PREL& prCutOff, COEFF& cfK, COEFF& cfB1, COEFF& cfB2)
{

    DWORD dwfreq;

    // returned frequency is in semitones, where 64 is the mid range
    dwfreq = m_CCutOffFreqIn->GetFrequency(stTime);
    prCutOff = (dwfreq - 64)*100;   // convert to PREL's

    m_Filter.GetCoeff(stTime, prCutOff, cfK, cfB1, cfB2);
}

DWORD CVoice::Mix(short **ppvBuffer,
                  DWORD dwBufferFlags,
                  DWORD dwLength,
                  STIME stStart,
                  STIME stEnd)

{
    BOOL   fInUse    = TRUE;
    BOOL   fFullMix   = TRUE;
    STIME  stEndMix   = stStart;
    STIME  stStartMix = m_stStartTime;
    COEFF  cfK, cfB1, cfB2;
    PREL   prPitch;
    PREL   prCutOff;
    VREL   vrVolume, vrVolumeL, vrVolumeR;
    VREL   vrVolumeReverb, vrVolumeChorus;
    VREL   vrMaxVolumeDelta;
    VFRACT vfNewVolume[MAX_DAUD_CHAN];
    VFRACT vfLastVolume[MAX_DAUD_CHAN];
    short  *ppsMixBuffers[MAX_DAUD_CHAN];

    if (stStartMix < stStart)
    {
        stStartMix = stStart;
    }

    if (m_stLastMix >= stEnd)
    {
        return (0);
    }

    if (m_stLastMix >= stStartMix)
    {
        stStartMix = m_stLastMix;
    }

    while (stStartMix < stEnd && fInUse)
    {
        stEndMix = stStartMix + m_stMixTime;
        if (stEndMix > stEnd)
        {
            stEndMix = stEnd;
        }

        m_stMixTime = m_pSynth->m_stMaxSpan;
        if ((m_stLastMix < m_stStopTime) && (m_stStopTime < stEnd))
        {
            if (m_stMixTime > (m_stStopTime - m_stLastMix))
            {
                m_stMixTime = m_stStopTime - m_stLastMix;
            }
        }

        //
        // Get the new pitch
        //
        GetNewPitch(stEndMix, prPitch);

        //
        // Get the new volume
        //
        GetNewVolume(stEndMix, vrVolume, vrVolumeL, vrVolumeR, vrVolumeReverb, vrVolumeChorus);

        //
        // Get the new filter coeficients
        //
        GetNewCoeff(stEndMix, prCutOff, cfK, cfB1, cfB2);

        //
        // Check to see if the volume is precievable, if not kill voice
        //
        if (m_VolumeEG.InRelease(stEndMix))
        {
            if (m_vrVolume < PERCEIVED_MIN_VOLUME) // End of release slope
            {
                // Breaking the loop ensures that the mixmulti functions don't mix any more samples
                // for looped wave Without this the mix engine will mix a few more samples for
                // looped waves resulting in a pop at the end of the wave.
                m_DigitalAudio.BreakLoop();
                fInUse = FALSE;
            }
        }

        vrMaxVolumeDelta = 0;
        vfNewVolume[0]   = 0;
        ppsMixBuffers[0] = NULL;
        DWORD dwMixBufferCount = 0;
        PREL prBusPitchBend = 0;  // This gets a pitch offset that is set by DSound in response to SetFrequency and Doppler commands.
                                 // When this is applied to multiple buses, only one of the values can be used, so we always give
                                 // preference to the buffer that has DSBUSID_DYNAMIC_0 for the functional id, since that
                                 // would most likely be a 3D sound effect.
        BOOL fDynamic = false;

        if (dwBufferFlags & BUFFERFLAG_MULTIBUFFER)
        {
            // Iterate through each bus id in the voice, assigning a sink bus to each one.
            for ( DWORD nBusID = 0; nBusID < m_BusIds.m_dwBusCount; nBusID++ )
            {
                DWORD dwFunctionalID;
                DWORD dwBusIndex;
                PREL prGetPitch;

                if (m_pSynth->BusIDToFunctionID(m_BusIds.m_dwBusIds[nBusID], &dwFunctionalID, &prGetPitch, &dwBusIndex))
                {
                    if (!fDynamic)
                    {
                        // If no previous bus was dynamic, get this value.
                        prBusPitchBend = prGetPitch;
                    }
                    // Default to original volume (before pan, reverb or chorus modifiers.)
                    VREL vrTemp = vrVolume;
                    // Replace for any of the other cases (left, right, reverb, chorus.)
                    if ( dwFunctionalID == DSBUSID_NULL )
                    {
                        continue;
                    }
                    if ( dwFunctionalID == DSBUSID_LEFT )
                    {
                        vrTemp = vrVolumeL;
                    }
                    if ( dwFunctionalID == DSBUSID_RIGHT )
                    {
                        vrTemp = vrVolumeR;
                    }
                    else if ( dwFunctionalID == DSBUSID_REVERB_SEND )
                    {
                        vrTemp = vrVolumeReverb;
                    }
                    else if ( dwFunctionalID == DSBUSID_CHORUS_SEND )
                    {
                        vrTemp = vrVolumeChorus;
                    }
                    else if ( dwFunctionalID == DSBUSID_DYNAMIC_0 )
                    {
                        fDynamic = true;
                    }

                    vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(vrTemp - m_vrLastVolume[nBusID]));
                    m_vrLastVolume[nBusID] = vrTemp;

                    vrTemp += m_vrBaseVolume[nBusID];
                    vfNewVolume[dwMixBufferCount]  = m_DigitalAudio.VRELToVFRACT(vrTemp);
                    vfLastVolume[dwMixBufferCount] = m_vfLastVolume[nBusID];
                    m_vfLastVolume[nBusID] = vfNewVolume[dwMixBufferCount];
                    ppsMixBuffers[dwMixBufferCount] = &ppvBuffer[dwBusIndex][(stStartMix - stStart)];
                    dwMixBufferCount++;
                }
            }
        }
        else
        {
            // This is the DX7 compatibility case.
            vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(vrVolumeL - m_vrLastVolume[0]));
            m_vrLastVolume[0] = vrVolumeL;
            vfNewVolume[0]  = m_DigitalAudio.VRELToVFRACT(m_vrBaseVolume[0] + vrVolumeL);
            vfLastVolume[0] = m_vfLastVolume[0];
            m_vfLastVolume[0] = vfNewVolume[0];
            dwMixBufferCount = 1;
            if ( dwBufferFlags & BUFFERFLAG_INTERLEAVED )   // Is this a stereo buffer?
            {
                vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(vrVolumeR - m_vrLastVolume[1]));
                m_vrLastVolume[1] = vrVolumeR;
                vfNewVolume[1]  = m_DigitalAudio.VRELToVFRACT(m_vrBaseVolume[1] + vrVolumeR);
                vfLastVolume[1] = m_vfLastVolume[1];
                m_vfLastVolume[1] = vfNewVolume[1];
                ppsMixBuffers[0] = &ppvBuffer[0][(stStartMix - stStart) << 1];
            }
            else    // Or mono?
            {
                ppsMixBuffers[0] = &ppvBuffer[0][(stStartMix - stStart)];
            }
        }
        // If dwMixBufferCount is 0, this indicates there is no buffer available to play into.
        // This is caused by a buffer being deactivated. Under such circumstances, the
        // voice should not continue playing, or it will hold until the buffer reactivates, which
        // doesn't make sense. So, set fInUse to FALSE.
        if (dwMixBufferCount)
        {
            DWORD dwIsFiltered = m_Filter.IsFiltered();
            if (dwIsFiltered)
            {
                vrMaxVolumeDelta = max((long)vrMaxVolumeDelta, abs(prCutOff - m_prLastCutOff));
                m_prLastCutOff = prCutOff;
            }


            //
            // note: mix will in some cases modify the pointers found ppsMixBuffers array
            //
            fFullMix = m_DigitalAudio.Mix(ppsMixBuffers,                    // Array of mix buffers
                                          dwMixBufferCount,                 // Number of mix buffers
                                          (dwBufferFlags & BUFFERFLAG_INTERLEAVED), // Are the buffers interleaved data?
                                          (DWORD) (stEndMix - stStartMix),  // Length to mix in Samples
                                          vrMaxVolumeDelta,                 //
                                          vfNewVolume,
                                          vfLastVolume,
                                          prPitch + prBusPitchBend,         // Pitch to play the sample too
                                          dwIsFiltered,         // Is the mix filtered
                                          cfK, cfB1, cfB2);
            stStartMix = stEndMix;
        }
        else
        {
            fInUse = FALSE;
        }
    }

    m_fInUse = fInUse && fFullMix;
    if (!m_fInUse)
    {
        ClearVoice();
        m_stStopTime = stEndMix;    // For measurement purposes.
    }

    m_stLastMix = stEndMix;

    return (dwLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmsynth\sverb.c ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/***********************************************************
General description :

The functions in this file provides for any apoplication to process audio data
with the SVerb algorithm.

In order to do so the application should :

1. Allocate two chunks of memory for 'Coefs' and 'States' with sizes as returned 
   by the functions 'GetCoefsSize' and 'GetStatesSize' accordingly.
   
2. Initialize these memory chunks using the functions : 'InitSVerb' and 'InitSVerbStates' 
   accordingly.

3. Change the settings of the SVerb sound using the function 'SetSVerb'.

4. Call one of the process functions according to the input/output data format:

   SVerbMonoToMonoShort 
   SVerbMonoToStereoShort
   SVerbStereoToStereoShort 
   SVerbMonoToMonoFloat
   SVerbMonoToStereoFloat
   SVerbStereoToStereoFloat

   The input/output are always the same data type (i.e. both input and output are short integer
   or both are 32bits floats).

   Stereo data format is always'interlaced' left,right samples.

   The 'coefs' and 'states' memory should be passed to the process functions.
   
5. Many coefs structures can be initialized each for different SVerb settings. Passing a different
   coefs structure will cause a real time change of sound quality.

   As long as sound continuity should be maintained the states structure should not be changes or
   re-initialized. Only when a completly new audio sequence is desired should the states be re-initialized.

6. Note that the coefs are valid per sampling rate.

7. Althaugh provisions for coefs compatibility for future versions are provided, it should be avoided to save coefs
   structures to files as-is and re-use them later. Rather the application should save the 'real-world'
   settings of the reverb - namely the parameters passed to 'SetSVerb'. These 'real-world' settings 
   will always be valid for future versions, as well as if other sampling rates are used. The coefs 
   structur(es) should be re-initialized in run time using the real-world settings and call to 
   'SetSverb'.


************************************************************/

#include <windows.h>
#include <String.h>
#include <math.h>
#include "SVerb.h"

#pragma optimize( "ty", on )

/****************************************************************************

Function Name	: GetCoefsSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold coefficients.

Description		:  

This function must be called before any calls to other functions that uses the coefs structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerb()'
and 'SetSVerb()'.

The caller should not be botherred by the internals of the coefs structure, rather only konw it's size 
and than allocate enough memory to hold it.

The structure allocated can be used in a very flexible way in order to allow for real-time, pre-computed
changes in Reverb Sound. 

*****************************************************************************/

long GetCoefsSize(void) 
{
	return sizeof(sCoefsStruct); 
};

/****************************************************************************

Function Name	: GetStatesSize

Input Arguments : None

Return Value    : The size of memory in bytes, to be allocated in order to hold states.

Description		:  

This function must be called before any calls to other functions that uses the states structure.
The calling app must than allocate the returned size of memory and initialize it using 'InitSVerbStates()'.

The states allocated are valid in run-time only, and sould be re-initialized only when a complete
new input is to be processed by the SVerb. 

When changing the settings of revevreb in real time while audio is playing, the states should not 
be re-initialized, rather the same passed states must be passed to the process functions in order 
to maintain sound continuity.

*****************************************************************************/

long GetStatesSize(void) 
{
	return sizeof(long)*(BASE_REV_DELAY+2*BASE_DSPS_DELAY+2); 
};

/****************************************************************************

Function Name	: GetSVerbVersion

Input Arguments : None

Return Value    : Version of SVerb implementation - for future compatibility.

Description		:  

Since the caller do not know about the internals of the coefs structure, this function,
together with 'VerifyVersion' function provides a way to verify if a coefs structure
match the version of the reverb used.

This should be needed only if one is using a coefs structure that was saved to file, and 
being used later.

NOTE : In normal operation, this way of usage should be avoided... and only real-world reverb
settings should be saved to files, and re-initialize the coefs in run time.

*****************************************************************************/

long GetSVerbVersion(void) 
{
	return 0x1; 
};

/****************************************************************************

Function Name	: VerifySampleRate

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The sample rate for which this coefs are valid.

Description		:  

When an application uses different sampling rates, and re-uses same coefs structures, 
it should verify that the coefs match the audio sampling rate.

*****************************************************************************/

float VerifySampleRate(void *pC) {
	return ((sCoefsStruct *)pC)->SampleRate; 
};

/****************************************************************************

Function Name	: VerifyVersion

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The version of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's version.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifyVersion(void *pC) {
	return ((sCoefsStruct *)pC)->myVersion; 
};

/****************************************************************************

Function Name	: VerifySize

Input Arguments : 

 void *pC		: The pointer to the coefs memory.

Return Value    : The size of this coefs structure.

Description		:  

When initialized, each coefs structure is 'stamped' with it's size.
The location of this variable in the structure is fixed, and thus all future versions of
SVerb will know to read it.

Note : as explained above, in normal uses coefs should not be saved to files, rather the 
'real-world' settings should be saved and coefs re-initialized in run-time.
*****************************************************************************/

long VerifySize(void *pC) {
	return ((sCoefsStruct *)pC)->mySize; 
};


/****************************************************************************

Function Name	: InitSVerbStates

Input Arguments : 

 float *pStates	: The pointer to the states memory.

Return Value    : none.

Description		:  

After allocating memory for the states, according to thge size returned by 'GetStatesSize'
The application MUST initialize the states using this function. 
Note : in future versions this may be more complex than simply memset to 0...
*****************************************************************************/

void InitSVerbStates( long *pStates )
{
    memset( pStates, 0, GetStatesSize() ) ;
}

/****************************************************************************

Function Name	: DToF16

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

Converts a float number between -1.0 .. 1.0 to a 16bits integer 
fixed point representation.
This allows for fix point arithmetics, where two 16bits integers are multiplied to 
a 32bits integer, and we than take the upper 16 bits of the result.

*****************************************************************************/

long DToF16( float dbl  )
{
	dbl *= MAX_16;
	dbl = max(-MAX_16,min(MAX_16-(float)1.0,dbl+(float)0.5));
	return (long)(dbl);
}

/****************************************************************************

Function Name	: ConvertCoefsToFix

Input Arguments : 

 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  converts coefficients to longs, as fixed point numbers

*****************************************************************************/


void ConvertCoefsToFix( void *pC )
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

//		float directGain; 

	pCoefs->l_directGain =  DToF16(pCoefs->directGain);

//		float revGain; 
	pCoefs->l_revGain =  DToF16(pCoefs->revGain);
//		float dDsps;
	pCoefs->l_dDsps =  DToF16(pCoefs->dDsps);
//		float dDG1;
	pCoefs->l_dDG1 =  DToF16(pCoefs->dDG1);
//		float dDG2; 
	pCoefs->l_dDG2 =  DToF16(pCoefs->dDG2);
//	float dFB11;
	pCoefs->l_dFB11 =  DToF16(pCoefs->dFB11);
//		float dFB12;
	pCoefs->l_dFB12 =  DToF16(pCoefs->dFB12);
//		float dFB21;
	pCoefs->l_dFB21 =  DToF16(pCoefs->dFB21);
//		float dFB22;
	pCoefs->l_dFB22 =  DToF16(pCoefs->dFB22);
//		float dFB31;
	pCoefs->l_dFB31 =  DToF16(pCoefs->dFB31);
//		float dFB32;
	pCoefs->l_dFB32 =  DToF16(pCoefs->dFB32);
//		float dFB41;
	pCoefs->l_dFB41 =  DToF16(pCoefs->dFB41);
//		float dFB42;
	pCoefs->l_dFB42 =  DToF16(pCoefs->dFB42);
//		float dDamp;
	pCoefs->l_dDamp =  DToF16(pCoefs->dDamp);



}

/****************************************************************************

Function Name	: InitSVerb

Input Arguments : 

 float SampleRate	: The sampling rate.
 void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

After allocating memory for the coefs, according to thge size returned by 'GetCoefsSize'
The application MUST initialize the coefs using this function. 
The initialization takes the sampling rate as an argument, ans thus is valid per this
sampling rate only.

It is possible to find out what is the sampling rate a coefs structure is valid for by calling 
the function 'VerifySampleRate'.

This function initialises the SVerb to so reasonable default setting by calling 'SetSVerb' with
the following real-world settings :

InGain				= -3.0dB   (to avoid output overflows)
dRevMix				= -6.0dB   (a reasonable reverb mix)
dRevTime			= 1000.0ms (one second global reverb time)
dHighFreqRTRatio	= 0.001    (the ratio of the high frequencies to the global reverb time) 

*****************************************************************************/

void InitSVerb( float SampleRate, void *pC)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
 	//Magic numbers ...
    long lRefD;
	
	float dRatio =  (float)1.189207115003;
	
	float dD2MRatio = (float)0.2309333333;

	pCoefs->mySize = sizeof(sCoefsStruct);
	pCoefs->myVersion = 0x1;

	pCoefs->dDsps =  (float)0.6180339887499;

	pCoefs->SampleRate = SampleRate;

    lRefD = (long)( 0.5 + 0.045 * pCoefs->SampleRate ) ;

	pCoefs->lDelay1 = lRefD;
	pCoefs->lDelay3 = (long)(0.5 + dRatio * (float)pCoefs->lDelay1);
	pCoefs->lDelay2 = (long)(0.5 + dRatio * (float)pCoefs->lDelay3);
	pCoefs->lDelay4 = (long)(0.5 + dRatio * (float)pCoefs->lDelay2);
  
    pCoefs->lDDly1 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay1+pCoefs->lDelay2));
	pCoefs->lDDly2 = (long)(0.5 + 0.5 * dD2MRatio * (float)(pCoefs->lDelay3+pCoefs->lDelay4));

    pCoefs->lDelay1 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay2 -= pCoefs->lDDly1 ;    
    pCoefs->lDelay3 -= pCoefs->lDDly2 ;    
    pCoefs->lDelay4 -= pCoefs->lDDly2 ;        

    pCoefs->lDelay1 <<= 2;    
    pCoefs->lDelay2 <<= 2;    
    pCoefs->lDelay3 <<= 2;    
    pCoefs->lDelay4 <<= 2;        

	pCoefs->lDDly1 <<= 1;
	pCoefs->lDDly2 <<= 1;

	SetSVerb( (float)0.0, (float)-10.0, (float)1000.0, (float)0.001, pC );

}

/****************************************************************************

Function Name	: SetSVerb

Input Arguments : 

InGain				: input gain in dB (to avoid output overflows)

dRevMix				: Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                      Negative values gives less wet signal.
					  The coeficients are calculated so that the overall output level stays 
					  (approximately) constant regardless of the ammount of reverb mix.
dRevTime			: The global reverb time (decay time) in milliseconds.

dHighFreqRTRatio	: The ratio of the high frequencies to the global reverb time. 
					  Unless very 'splashy-bright' reverbs are wanted, this should be set to 
					  a value < 1.0.
					  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
					  decay time for high frequencies will be 100ms.

void *pC			: The pointer to the coefs memory.

Return Value    : none.

Description		:  

This function accepts the 'real world' settings or SVerb and computes the corresponding 
coefs structure.

The coefs pointer passed to it MUST have been initialized first by InitSVerb.

In normal uses one coefs structure is allocated, initialized, and than as the user changes 
SVerb settings this function should be called repeatedly with the same coefs pointer and the 
new 'real world' settings. 

And the coefs structure passed to the process function in the next buffer to process.

Also few coefs structures can be pre allocated, and initialized, and than different 'presets' 
can be pre-computed into each of them, and switched in real time. 

The coefs structures should not be saved to files by the application for future uses, rather 
the 'real world' settings them selvs. This way future compatibility is guaranteed.

*****************************************************************************/

void SetSVerb( float InGain, float dRevMix, 
			   float dRevTime, float dHighFreqRTRatio, void *pC )
{


	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);

    float dD,dTmp,dInGain,dRevGain;

	float dHfR;
    float dAPS;

    if (dHighFreqRTRatio > (float) 0.999)
    {
        dHighFreqRTRatio = (float) 0.999;
    }
    if (dHighFreqRTRatio <= (float) 0.0)
    {
        dHighFreqRTRatio = (float) 0.001;
    }
    dHfR = ( (float)1.0/dHighFreqRTRatio - (float)1.0);

    if (dRevTime < (float) 0.001) 
    {
        dRevTime = (float) 0.001;
    }

    if (InGain > (float) 0.0)
    {
        InGain = (float) 0.0;
    }

    if (dRevMix > (float) 0.0)
    {
        dRevMix = (float) 0.0;
    }

    if (pCoefs->SampleRate < (float) 1.0) 
    {
        pCoefs->SampleRate = (float) 22050.0;
    }

    dAPS = (float)(-3000.0) / (pCoefs->SampleRate * dRevTime);


    pCoefs->dDamp = 0.0;

 	pCoefs->dDG1 = (float)pow((float)10.0,(float)(pCoefs->lDDly1>>1)*dAPS);
 	pCoefs->dDG2 = (float)pow((float)10.0,(float)(pCoefs->lDDly2>>1)*dAPS);

	//////////////////////////////

		pCoefs->dFB11 = (float)pow((float)10.0,(float)(pCoefs->lDelay1>>2)*dAPS);
        
		dD = pCoefs->dFB11 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay1>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB12 = pCoefs->dFB11 * dTmp;
		pCoefs->dFB11 *= ((float)1.0-dTmp);

	///////////////////////////////

		pCoefs->dFB21 = (float)pow((float)10.0,(float)(pCoefs->lDelay2>>2)*dAPS);
        
		dD = pCoefs->dFB21 * pCoefs->dDG1;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly1>>1)+(pCoefs->lDelay2>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB22 = pCoefs->dFB21 * dTmp;
		pCoefs->dFB21 *= ((float)1.0-dTmp);

	////////////////////////////////

		pCoefs->dFB31 = (float)pow((float)10.0,(float)(pCoefs->lDelay3>>2)*dAPS);
        
		dD = pCoefs->dFB31 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
		    pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay3>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB32 = pCoefs->dFB31 * dTmp;
		pCoefs->dFB31 *= ((float)1.0-dTmp);


	//////////////////////////////

		pCoefs->dFB41 = (float)pow((float)10.0,(float)(pCoefs->lDelay4>>2)*dAPS);

        dD = pCoefs->dFB41 * pCoefs->dDG2;
        dD = (float)1.0+dD*((float)1.0+dD*((float)1.0+dD*((float)1.0 + dD)));
        pCoefs->dDamp += dD *dD;

		dTmp = (float)pow((float)10.0,(float)((pCoefs->lDDly2>>1)+(pCoefs->lDelay4>>2))*dAPS*dHfR);
		dTmp = ((float)1.0 - dTmp)*(float)0.5;

		pCoefs->dFB42 = pCoefs->dFB41 * dTmp;
		pCoefs->dFB41 *= ((float)1.0-dTmp);


    pCoefs->dDamp = (float)sqrt(pCoefs->dDamp);

 	dInGain = (float)pow((float)10.0, (float)0.05*InGain ) ;
	dRevMix = (float)pow((float)10.0,(float)0.1*dRevMix);

	dRevGain = (float)4.0 / pCoefs->dDamp * dInGain;

	//in the DSP we used -  	 
	

	pCoefs->directGain = dInGain * (float)sqrt((float)1.0-dRevMix);
	pCoefs->revGain = dRevGain * (float)sqrt(dRevMix);

	ConvertCoefsToFix( pC );

}

///////////////////////////////////////////////////////////////////////////////////////
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
/* Process functions */
/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/

/**********************************************************************************

Bellow are 6 different process functions.
The difference between the functions is only in the input/output data formats.

3 functions support short samples input/output.
3 other functions support float samples input/output.

Per each of the data types there are 3 functions :

  Mono-Mono
  Mono-Stereo
  Stereo-Stereo

The names of the functions are clear to which format they apply.

Stereo data is always interlaced left,right samples.

All process functions have basically the same format namely :

  SVerbXXXXXX(long NumInFrames, short *pInShort, short *pOutShort, 
			  void *pC, float *pStates)

Input arguments :

long NumInFrames	: Number of input frames
short *pInXXX		: Pointer to input buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.
short *pOutXXX		: Pointer to output buffer.
					  Each function expects the data format suggested by it's name in terms of
					  data type (short or float) and mono/stereo.

void *pC			: The coefs structure allocated and initialized as explained above.
float *pStates		: The states structure allocated and initialized as explained above.

*******************************************************************************************/

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						  void *pC, long *pStates)
{

	sCoefsStruct *pCoefs =  ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (long)(*pInShort++)>>1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			Out1 += Out2;
			CLIP_SHORT_TO_SHORT(Out1)

			*pOutShort++ = (short)(Out1);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS
void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						    void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In1 += (In1>>1) - (In1>>2);
			In2 = In1;

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}
#endif

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						      void *pC, long *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	long In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	long *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	long *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	long	*pDelay = pStates+2;
	long	*pDD1	 = pDelay+0x4000;
	long	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (long)(*pInShort++);
			In2 = (long)(*pInShort++);

			Out1 = (In1 * pCoefs->l_directGain)>>15;

			Out2 = (In2 * pCoefs->l_directGain)>>15;

			In1 = (In1 * pCoefs->l_revGain)>>15;

			In2 = (In2 * pCoefs->l_revGain)>>15;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dspsL( pDD1, DIndx, pCoefs->lDDly1, pCoefs->l_dDG1, pCoefs->l_dDsps, pNewDll1, pNewDll2 );
			dspsL( pDD2, DIndx, pCoefs->lDDly2, pCoefs->l_dDG2, pCoefs->l_dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + ((*pNewDll1*pCoefs->l_dFB11 + *pPrevDll1*pCoefs->l_dFB12)>>15);
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + ((*pNewDll2*pCoefs->l_dFB21 + *pPrevDll2*pCoefs->l_dFB22)>>15);			
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + ((*pNewDll3*pCoefs->l_dFB31 + *pPrevDll3*pCoefs->l_dFB32)>>15);
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + ((*pNewDll4*pCoefs->l_dFB41 + *pPrevDll4*pCoefs->l_dFB42)>>15);
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			CLIP_SHORT_TO_SHORT(Out1)
			CLIP_SHORT_TO_SHORT(Out2)

			*pOutShort++ = (short)(Out1);
			*pOutShort++ = (short)(Out2);
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

#ifdef USE_ALL_VERBS

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						  void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.5 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1+Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						    void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = In2 = (float)0.7071 * (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						      void *pC, float *pStates)
{

	sCoefsStruct *pCoefs = ((sCoefsStruct *)pC);
	long n_sample;
	float In1, In2, Out1, Out2;
	long Indx1,Indx2,Indx3,Indx4;
	float *pNewDll1, *pNewDll2, *pNewDll3, *pNewDll4;
	float *pPrevDll1, *pPrevDll2, *pPrevDll3, *pPrevDll4, *pDelayIn;
	float	*pDelay = pStates+2;
	float	*pDD1	 = pDelay+0x4000;
	float	*pDD2	 = pDD1+0x800;
	long Indx = ((long *)pStates)[0];
	long DIndx = ((long *)pStates)[1] ;

	Indx1 = (Indx+4+pCoefs->lDelay1) & REV_MASK;
	Indx2 = (Indx+4+pCoefs->lDelay2) & REV_MASK;
	Indx3 = (Indx+4+pCoefs->lDelay3) & REV_MASK;
	Indx4 = (Indx+4+pCoefs->lDelay4) & REV_MASK;

	pPrevDll1 = pDelay+Indx1;
	pPrevDll2 = pDelay+Indx2+1;
	pPrevDll3 = pDelay+Indx3+2;
	pPrevDll4 = pDelay+Indx4+3;

	Indx1 = (Indx1-4)&REV_MASK;
	Indx2 = (Indx2-4)&REV_MASK;
	Indx3 = (Indx3-4)&REV_MASK;
	Indx4 = (Indx4-4)&REV_MASK;

		for (n_sample = 0;n_sample < NumInFrames;n_sample++)
		{

			In1 = (*pInFloat++) + FPU_DENORM_OFFS;
			In2 = (*pInFloat++) + FPU_DENORM_OFFS;

			Out1 = In1 * pCoefs->directGain;
			Out2 = In2 * pCoefs->directGain;

			In1 *= pCoefs->revGain;
			In2 *= pCoefs->revGain;

			pNewDll1 = pDelay+Indx1;
			pNewDll2 = pDelay+Indx2+1;
			pNewDll3 = pDelay+Indx3+2;
			pNewDll4 = pDelay+Indx4+3;

			dsps( pDD1, DIndx, pCoefs->lDDly1, pCoefs->dDG1, pCoefs->dDsps, pNewDll1, pNewDll2 );
			dsps( pDD2, DIndx, pCoefs->lDDly2, pCoefs->dDG2, pCoefs->dDsps, pNewDll3, pNewDll4 );

			Out1 += *pNewDll1 + *pNewDll3;
			Out2 += *pNewDll2 + *pNewDll4;

			pDelayIn = pDelay + Indx;

			*pDelayIn++ = In1 + *pNewDll1*pCoefs->dFB11 + *pPrevDll1*pCoefs->dFB12;
			pPrevDll1 = pNewDll1;
			Indx1 = (Indx1 - 4) & REV_MASK;

			*pDelayIn++ = In2 + *pNewDll2*pCoefs->dFB21 + *pPrevDll2*pCoefs->dFB22;
			pPrevDll2 = pNewDll2;
			Indx2 = (Indx2 - 4) & REV_MASK;

			*pDelayIn++ = -In2 + *pNewDll3*pCoefs->dFB31 + *pPrevDll3*pCoefs->dFB32;
			pPrevDll3 = pNewDll3;
			Indx3 = (Indx3 - 4) & REV_MASK;

			*pDelayIn++ = In1 + *pNewDll4*pCoefs->dFB41 + *pPrevDll4*pCoefs->dFB42;
			pPrevDll4 = pNewDll4;
			Indx4 = (Indx4 - 4) & REV_MASK;

			Indx = (Indx - 4) & REV_MASK;
			DIndx = (DIndx - 2) & DSPS_MASK;

			*pOutFloat++ = Out1;
			*pOutFloat++ = Out2;
			
		}

	((long *)pStates)[0] = Indx ;
	((long *)pStates)[1] = DIndx ;

}

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR )
{
	float outL, outR;
	float *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = dDG1 * (*pDlyOut++) + *inR * dDsps;
	outR = dDG1 * (*pDlyOut) - *inL * dDsps ;

    // here we feed back the output.
	*pDly++ = *inL + dDsps * outR ;
	*pDly = *inR - dDsps * outL ;

	*inL = outL;
	*inR = outR;

}
#endif

__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR )
{
	long outL, outR;
	long *pDlyOut; 

    pDlyOut = pDly + ((ref+delay) & DSPS_MASK);
    pDly += (ref & DSPS_MASK);

    outL = (dDG1 * (*pDlyOut++) + *inR * dDsps)>>15;

	outR = (dDG1 * (*pDlyOut) - *inL * dDsps)>>15;

    // here we feed back the output.
	*pDly++ = *inL + ((dDsps * outR)>>15) ;

	*pDly = *inR - ((dDsps * outL)>>15) ;

	*inL = outL;
	*inR = outR;

}
#pragma optimize( "ty", off )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMTOOL"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\basetool.cpp ===
// BaseTool.cpp : Implementation of CBaseTool
//
// Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "basetool.h"

CBaseTool::CBaseTool()
{
    m_cRef = 1; // set to 1 so one call to Release() will free this
    InitializeCriticalSection(&m_CrSec);
}

CBaseTool::~CBaseTool()
{
    DeleteCriticalSection(&m_CrSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\dll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// loader dll.cpp
//
// Dll entry points and CToolFactory, CContainerFactory implementation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include <objbase.h>
#include "debug.h"

#include "oledll.h"
#include "debug.h" 
#include "dmusicc.h" 
#include "dmusici.h" 
#include "BaseTool.h"
#include "Echo.h"
#include "Transpose.h"
#include "Duration.h"
#include "Quantize.h"
#include "TimeShift.h"
#include "Swing.h"
#include "Velocity.h"

#ifndef UNDER_CE
#include <regstr.h>
#endif

// Globals
//

// Version information for our class
//
TCHAR g_szEchoFriendlyName[]            = TEXT("Microsoft Echo Tool");
TCHAR g_szEchoShortName[]               = TEXT("Echo");
TCHAR g_szEchoDescription[]             = TEXT("Echoes notes");
TCHAR g_szEchoVerIndProgID[]            = TEXT("Microsoft.DirectMusicEchoTool");
TCHAR g_szEchoProgID[]                  = TEXT("Microsoft.DirectMusicEchoTool.1");

TCHAR g_szTransposeFriendlyName[]       = TEXT("Microsoft Transpose Tool");
TCHAR g_szTransposeShortName[]          = TEXT("Transpose");
TCHAR g_szTransposeDescription[]        = TEXT("Transposes notes");
TCHAR g_szTransposeVerIndProgID[]       = TEXT("Microsoft.DirectMusicTransposeTool");
TCHAR g_szTransposeProgID[]             = TEXT("Microsoft.DirectMusicTransposeTool.1");

TCHAR g_szDurationFriendlyName[]        = TEXT("Microsoft Duration Modifier Tool");
TCHAR g_szDurationShortName[]           = TEXT("Duration");
TCHAR g_szDurationDescription[]         = TEXT("Scales note durations");
TCHAR g_szDurationVerIndProgID[]        = TEXT("Microsoft.DirectMusicDurationTool");
TCHAR g_szDurationProgID[]              = TEXT("Microsoft.DirectMusicDurationTool.1");

TCHAR g_szQuantizeFriendlyName[]        = TEXT("Microsoft Quantize Tool");
TCHAR g_szQuantizeShortName[]           = TEXT("Quantize");
TCHAR g_szQuantizeDescription[]         = TEXT("Quantizes note starts and durations");
TCHAR g_szQuantizeVerIndProgID[]        = TEXT("Microsoft.DirectMusicQuantizeTool");
TCHAR g_szQuantizeProgID[]              = TEXT("Microsoft.DirectMusicQuantizeTool.1");

TCHAR g_szTimeShiftFriendlyName[]       = TEXT("Microsoft Time Shift Tool");
TCHAR g_szTimeShiftShortName[]          = TEXT("Time Shift");
TCHAR g_szTimeShiftDescription[]        = TEXT("Shifts and randomizes note starts");
TCHAR g_szTimeShiftVerIndProgID[]       = TEXT("Microsoft.DirectMusicTimeShiftTool");
TCHAR g_szTimeShiftProgID[]             = TEXT("Microsoft.DirectMusicTimeShiftTool.1");

TCHAR g_szSwingFriendlyName[]           = TEXT("Microsoft Swing Tool");
TCHAR g_szSwingShortName[]              = TEXT("Swing");
TCHAR g_szSwingDescription[]            = TEXT("Changes the timing to a adopt a triplet rhythm");
TCHAR g_szSwingVerIndProgID[]           = TEXT("Microsoft.DirectMusicSwingTool");
TCHAR g_szSwingProgID[]                 = TEXT("Microsoft.DirectMusicSwingTool.1");

TCHAR g_szVelocityFriendlyName[]        = TEXT("Microsoft Velocity Transform Tool");
TCHAR g_szVelocityShortName[]           = TEXT("Velocity Transform");
TCHAR g_szVelocityDescription[]         = TEXT("Modifies note velocities");
TCHAR g_szVelocityVerIndProgID[]        = TEXT("Microsoft.DirectMusicVelocityTool");
TCHAR g_szVelocityProgID[]              = TEXT("Microsoft.DirectMusicVelocityTool.1");

// Dll's hModule
//
HMODULE g_hModule = NULL; 

#ifndef UNDER_CE
// Track whether running on Unicode machine.

BOOL g_fIsUnicode = FALSE;
#endif

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

// CToolFactory::QueryInterface
//
HRESULT __stdcall
CToolFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CToolFactory::CToolFactory(DWORD dwToolType)

{
	m_cRef = 1;
    m_dwToolType = dwToolType;
	InterlockedIncrement(&g_cLock);
}

CToolFactory::~CToolFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CToolFactory::AddRef
//
ULONG __stdcall
CToolFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CToolFactory::Release
//
ULONG __stdcall
CToolFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CToolFactory::CreateInstance
//
//
HRESULT __stdcall
CToolFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CBaseTool *pTool;
    switch (m_dwToolType)
    {
    case TOOL_ECHO:
        pTool = new CEchoTool;
        break;
    case TOOL_TRANSPOSE:
        pTool = new CTransposeTool;
        break;
    case TOOL_SWING:
        pTool = new CSwingTool;
        break;
    case TOOL_DURATION:
        pTool = new CDurationTool;
        break;
    case TOOL_QUANTIZE:
        pTool = new CQuantizeTool;
        break;
    case TOOL_TIMESHIFT:
        pTool = new CTimeShiftTool;
        break;
    case TOOL_VELOCITY:
        pTool = new CVelocityTool;
        break;
    }

    if (pTool == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pTool->QueryInterface(iid, ppv);
    pTool->Release();
    
    return hr;
}

// CToolFactory::LockServer
//
HRESULT __stdcall
CToolFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;

    if(clsid == CLSID_DirectMusicEchoTool)
    {
        dwTypeID = TOOL_ECHO;
    }
    else if(clsid == CLSID_DirectMusicTransposeTool) 
    {
        dwTypeID = TOOL_TRANSPOSE;
    }
    else if(clsid == CLSID_DirectMusicDurationTool) 
    {
        dwTypeID = TOOL_DURATION;
    }
    else if(clsid == CLSID_DirectMusicQuantizeTool) 
    {
        dwTypeID = TOOL_QUANTIZE;
    }
    else if(clsid == CLSID_DirectMusicTimeShiftTool) 
    {
        dwTypeID = TOOL_TIMESHIFT;
    }
    else if(clsid == CLSID_DirectMusicSwingTool) 
    {
        dwTypeID = TOOL_SWING;
    }
    else if(clsid == CLSID_DirectMusicVelocityTool) 
    {
        dwTypeID = TOOL_VELOCITY;
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}
    pIUnknown = static_cast<IUnknown*> (new CToolFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
	return E_OUTOFMEMORY;
}

const TCHAR cszToolRegRoot[] = TEXT(DMUS_REGSTR_PATH_TOOLS) TEXT("\\");
const TCHAR cszDescriptionKey[] = TEXT("Description");
const TCHAR cszNameKey[] = TEXT("Name");
const TCHAR cszShortNameKey[] = TEXT("ShortName");
const int CLSID_STRING_SIZE = 39;
HRESULT CLSIDToStr(const CLSID &clsid, TCHAR *szStr, int cbStr);

HRESULT RegisterTool(REFGUID guid,
                      const TCHAR szDescription[],
                      const TCHAR szShortName[],
                      const TCHAR szName[])
{
    HKEY hk;
    TCHAR szCLSID[CLSID_STRING_SIZE];
    TCHAR szRegKey[256];
    
    HRESULT hr = CLSIDToStr(guid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    lstrcpy(szRegKey, cszToolRegRoot);
    lstrcat(szRegKey, szCLSID);

    if (RegCreateKey(HKEY_LOCAL_MACHINE,
                     szRegKey,
                     &hk))
    {
        return E_FAIL;
    }

    hr = S_OK;

    if (RegSetValueEx(hk,
                  cszDescriptionKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szDescription,
                  lstrlen(szDescription) + 1))
    {
        hr = E_FAIL;
    }

    if (RegSetValueEx(hk,
                  cszNameKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szName,
                  lstrlen(szName) + 1))
    {
        hr = E_FAIL;
    }

    if (RegSetValueEx(hk,
                  cszShortNameKey,
                  0L,
                  REG_SZ,
                  (CONST BYTE*)szShortName,
                  lstrlen(szName) + 1))
    {
        hr = E_FAIL;
    }

    RegCloseKey(hk);
    return hr;
}

HRESULT UnregisterTool(REFGUID guid)
{
    HKEY hk;
    TCHAR szCLSID[CLSID_STRING_SIZE];
    TCHAR szRegKey[256];
    
    HRESULT hr = CLSIDToStr(guid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    lstrcpy(szRegKey, cszToolRegRoot);
    lstrcat(szRegKey, szCLSID);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRegKey,0,KEY_ALL_ACCESS | KEY_WRITE, &hk))
    {
        return E_FAIL;
    }

    hr = S_OK;

    if (RegDeleteValue(hk,cszDescriptionKey))
    {
        hr = E_FAIL;
    }

    if (RegDeleteValue(hk,cszNameKey))
    {
        hr = E_FAIL;
    }

    if (RegDeleteValue(hk,cszShortNameKey))
    {
        hr = E_FAIL;
    }

    RegCloseKey(hk);

    if (RegDeleteKey(HKEY_LOCAL_MACHINE,szRegKey))
    {
        hr = E_FAIL;
    }

    return hr;
}


STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicEchoTool,
                     g_szEchoFriendlyName,
                     g_szEchoVerIndProgID,
                     g_szEchoProgID);
    UnregisterTool(CLSID_DirectMusicEchoTool);
    UnregisterServer(CLSID_DirectMusicTransposeTool,
                     g_szTransposeFriendlyName,
                     g_szTransposeVerIndProgID,
                     g_szTransposeProgID);
    UnregisterTool(CLSID_DirectMusicTransposeTool);
    UnregisterServer(CLSID_DirectMusicDurationTool,
                     g_szDurationFriendlyName,
                     g_szDurationVerIndProgID,
                     g_szDurationProgID);
    UnregisterTool(CLSID_DirectMusicDurationTool);
    UnregisterServer(CLSID_DirectMusicQuantizeTool,
                     g_szQuantizeFriendlyName,
                     g_szQuantizeVerIndProgID,
                     g_szQuantizeProgID);
    UnregisterTool(CLSID_DirectMusicQuantizeTool);
    UnregisterServer(CLSID_DirectMusicSwingTool,
                     g_szSwingFriendlyName,
                     g_szSwingVerIndProgID,
                     g_szSwingProgID);
    UnregisterTool(CLSID_DirectMusicSwingTool);
    UnregisterServer(CLSID_DirectMusicTimeShiftTool,
                     g_szTimeShiftFriendlyName,
                     g_szTimeShiftVerIndProgID,
                     g_szTimeShiftProgID);
    UnregisterTool(CLSID_DirectMusicTimeShiftTool);
    UnregisterServer(CLSID_DirectMusicVelocityTool,
                     g_szVelocityFriendlyName,
                     g_szVelocityVerIndProgID,
                     g_szVelocityProgID);
    UnregisterTool(CLSID_DirectMusicVelocityTool);
    return S_OK;
}

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicEchoTool,
                   g_szEchoFriendlyName,
                   g_szEchoVerIndProgID,
                   g_szEchoProgID);
    RegisterTool(CLSID_DirectMusicEchoTool, g_szEchoDescription, g_szEchoShortName, g_szEchoFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicTransposeTool,
                   g_szTransposeFriendlyName,
                   g_szTransposeVerIndProgID,
                   g_szTransposeProgID);
    RegisterTool(CLSID_DirectMusicTransposeTool, g_szTransposeDescription, g_szTransposeShortName, g_szTransposeFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicDurationTool,
                   g_szDurationFriendlyName,
                   g_szDurationVerIndProgID,
                   g_szDurationProgID);
    RegisterTool(CLSID_DirectMusicDurationTool, g_szDurationDescription, g_szDurationShortName, g_szDurationFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicQuantizeTool,
                   g_szQuantizeFriendlyName,
                   g_szQuantizeVerIndProgID,
                   g_szQuantizeProgID);
    RegisterTool(CLSID_DirectMusicQuantizeTool, g_szQuantizeDescription, g_szQuantizeShortName, g_szQuantizeFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicSwingTool,
                   g_szSwingFriendlyName,
                   g_szSwingVerIndProgID,
                   g_szSwingProgID);
    RegisterTool(CLSID_DirectMusicSwingTool, g_szSwingDescription, g_szSwingShortName, g_szSwingFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicTimeShiftTool,
                   g_szTimeShiftFriendlyName,
                   g_szTimeShiftVerIndProgID,
                   g_szTimeShiftProgID);
    RegisterTool(CLSID_DirectMusicTimeShiftTool, g_szTimeShiftDescription, g_szTimeShiftShortName, g_szTimeShiftFriendlyName);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicVelocityTool,
                   g_szVelocityFriendlyName,
                   g_szVelocityVerIndProgID,
                   g_szVelocityProgID);
    RegisterTool(CLSID_DirectMusicVelocityTool, g_szVelocityDescription, g_szVelocityShortName, g_szVelocityFriendlyName);
    return S_OK; 
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        DebugTrace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        DebugTrace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
        { 
            g_hModule = (HMODULE)hModule;
#ifndef UNDER_CE
            OSVERSIONINFO osvi;

            DisableThreadLibraryCalls(hModule);
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx(&osvi);
            g_fIsUnicode = 
				(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS);
#endif
#ifdef DBG
			DebugInit();
#endif
		}
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\basetool.h ===
#ifndef _BASE_TOOL_
#define _BASE_TOOL_

#include "dmusici.h"
#include "medparam.h"

extern long g_cComponent;

class CBaseTool : public IDirectMusicTool8
{
public:
    CBaseTool()
    {
        m_cRef = 1; // set to 1 so one call to Release() will free this
        m_pParams = NULL;
        InitializeCriticalSection(&m_CrSec);
        // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
        // ever pops in stress, we can add an exception handler and retry loop.
        InterlockedIncrement(&g_cComponent);
    }
    ~CBaseTool()
    {
        if (m_pParams)
        {
            m_pParams->Release();
        }
        DeleteCriticalSection(&m_CrSec);
        InterlockedDecrement(&g_cComponent);
    }
    void CreateParams()
    {
    }
    void CloneParams()
    {
    }
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) PURE;
    STDMETHODIMP_(ULONG) AddRef() PURE;
    STDMETHODIMP_(ULONG) Release() PURE;

/*// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID) PURE;

// IPersistStream functions
    STDMETHODIMP IsDirty() PURE;
    STDMETHODIMP Load(IStream* pStream) PURE;
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty) PURE;
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) PURE;*/

// IDirectMusicTool
    STDMETHODIMP Init(IDirectMusicGraph* pGraph) {return E_NOTIMPL;}
    STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) {return E_NOTIMPL;}
    STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) {return E_NOTIMPL;}
    STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) {return E_NOTIMPL;}
    STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) PURE;
    STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) {return E_NOTIMPL;}

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) PURE;

protected:
    long m_cRef;                // reference counter
    CRITICAL_SECTION m_CrSec;   // to make SetEchoNum() and SetDelay() thread-safe
    IMediaParams * m_pParams;   // Helper object that manages IMediaParams.
};

class CToolFactory : public IClassFactory
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    STDMETHODIMP LockServer(BOOL bLock);

    // Constructor
    //
    CToolFactory(DWORD dwToolType);

    // Destructor
    ~CToolFactory();

private:
    long m_cRef;
    DWORD m_dwToolType;
};

// We use one class factory to create all tool classes. We need an identifier for each
// type so the class factory knows what it is creating.

#define TOOL_ECHO       1
#define TOOL_TRANSPOSE  2
#define TOOL_SWING      3
#define TOOL_QUANTIZE   4
#define TOOL_VELOCITY   5
#define TOOL_DURATION   6
#define TOOL_TIMESHIFT  7

#endif // _BASE_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\duration.cpp ===
// Duration.cpp : Implementation of CDurationTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "duration.h"
#include "toolhelp.h"


CDurationTool::CDurationTool()
{
    ParamInfo Params[DMUS_DURATION_PARAMCOUNT] = 
    {
        { DMUS_DURATION_SCALE, MPT_INT,MP_CAPS_ALL,0,8,1,
            L"Times",L"Scale",NULL},        // Scale - default to 1 (no change)
    };
    InitParams(DMUS_DURATION_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CDurationTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDurationTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CDurationTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicDurationTool)
	{
		*ppv = static_cast<IDirectMusicDurationTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CDurationTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicDurationTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CDurationTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CDurationTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_DURATION_CHUNK))
	{
        DMUS_IO_DURATION_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_DURATION_SCALE,(float) Header.flScale);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CDurationTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_DURATION_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_DURATION_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_DURATION_HEADER Header;
        GetParamFloat(DMUS_DURATION_SCALE,MAX_REF_TIME,&Header.flScale);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CDurationTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_DURATION_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CDurationTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_DurationPage;
	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CDurationTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // Only adjust the durations of notes. 
    if( pPMsg->dwType == DMUS_PMSGT_NOTE ) 
    {
        REFERENCE_TIME rtTime;
        if (m_fMusicTime) rtTime = pPMsg->mtTime;
        else rtTime = pPMsg->rtTime;
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        float flScale;

        GetParamFloat(DMUS_DURATION_SCALE,rtTime,&flScale);
        if (flScale >= 0)
        {
            flScale *= pNote->mtDuration;
            pNote->mtDuration = (MUSIC_TIME) flScale;
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CDurationTool::Clone( IDirectMusicTool ** ppTool)

{
    CDurationTool *pNew = new CDurationTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CDurationTool::SetScale(float flScale) 
{
    return SetParam(DMUS_DURATION_SCALE,flScale);
}

STDMETHODIMP CDurationTool::GetScale(float * pflScale) 
{
    return GetParamFloat(DMUS_DURATION_SCALE,MAX_REF_TIME, pflScale);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\duration.h ===
#ifndef _DURATION_TOOL_
#define _DURATION_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CDurationTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicDurationTool

{
public:
	CDurationTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicDurationTool
	STDMETHODIMP SetScale(float flScale) ;
	STDMETHODIMP GetScale(float * pflScale);
};

#endif // _DURATION_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\dmobase.h ===
// dmobase.h - a collection of DMO base classes

// Current hierarchy:
//
//   IMediaObject
//   |
//   +-- C1in1outDMO - generic base class for DMOs with 1 in and 1 out
//   |   |
//   |   +-- FBRDMO - base class for fixed sample size, fixed bitrate DMOs
//   |   |   |
//   |   |   +-- CPCMDMO - base class for PCM audio DMOs
//   |   |
//   |   +-- C1for1 - base class for single sample per buffer 1-in/1-out DMOs
//   |
//   +-- CGenericDMO - resonably generic base class for multi-input/output DMOs
// 

#ifndef __DMOBASE_H_
#define __DMOBASE_H_

#include "dmo.h"
#include "assert.h"
#include "math.h"

//
// locking helper class
//
#ifdef DMO_NOATL
class CDMOAutoLock {
public:
   CDMOAutoLock(CRITICAL_SECTION* pcs)
      : m_pcs(pcs)
   {
      EnterCriticalSection(m_pcs);
   }
   ~CDMOAutoLock() {
      LeaveCriticalSection(m_pcs);
   }
private:
   CRITICAL_SECTION* m_pcs;
};
#else
class CDMOAutoLock {
public:
   CDMOAutoLock(CComAutoCriticalSection* pcs)
      : m_pcs(pcs)
   {
      m_pcs->Lock();
   }
   ~CDMOAutoLock() {
      m_pcs->Unlock();
   }
private:
   CComAutoCriticalSection* m_pcs;
};
#endif


//
// C1in1outDMO - generic base class for 1-input/1-output DMOs.
//
//
//
// C1in1outDMO implements all IMediaObject methods.  The derived class
// customizes the DMO's behavior by overriding some or all of the following
// virtual functions:
//
// Main Streaming:
//    AcceptInput          // accept one new input buffer
//    ProduceOutput        // fill up one output buffer with new data
//    AcceptingInput       // check if DMO is ready for new input
// Other streaming:
//    PrepareForStreaming  // hook called after both types have been set
//    Discontinuity        // notify DMO of a discontinuity
//    DoFlush              // discard all data and start anew
// Mediatype negotiation:
//    GetInputType         // input type enumerator
//    GetOutputType        // output type enumerator
//    CheckInputType       // verifies proposed input type is acceptable
//    CheckOutputType      // verifies proposed output type is acceptable
// Buffer size negotiation:
//    GetInputFlags        // input data flow flags
//    GetOutputFlags       // output fata flow flags
//    GetInputSizeInfo     // input buffer size requirements
//    GetOutputSizeInfo    // output buffer size requirements
//
// This base class assumes that the derived class will not override any
// IMediaObject methods directly - the derived class should override the
// methods listed above instead.
//
//
//
// The base class provides a default implementation for each of the
// overridables listed above.  However, to make a useful DMO the derived class
// probably needs to override at least the following two methods:
//
//    HRESULT AcceptingInput();
//    HRESULT AcceptInput(BYTE* pData,
//                        ULONG ulSize,
//                        DWORD dwFlags,
//                        REFERENCE_TIME rtTimestamp,
//                        REFERENCE_TIME rtTimelength,
//                        IMediaBuffer* pMediaBuffer);
//    HRESULT ProduceOutput(BYTE *pData,
//                        ULONG ulAvail,
//                        ULONG* pulUsed,
//                        DWORD* pdwStatus,
//                        REFERENCE_TIME *prtTimestamp,
//                        REFERENCE_TIME *prtTimelength);
//
// All good DMOs should also override these (the default implementation
// simply accepts any mediatype, which in general is not good DMO behavior):
//
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// DMOs that store data and/or state information may need to implement
//
//    HRESULT PrepareForStreaming();
//    HRESULT Discontinuity();
//    HRESULT Flush();
//
// Finally, DMOs that make any buffer size assumptions will need to override
// these:
//
//    HRESULT GetInputFlags(DWORD* pdwFlags);
//    HRESULT GetOutputFlags(DWORD* pdwFlags);
//    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment);
//    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment);
//
//
//
// The following functions are provided by this base class exclusively for use
// by the derived class.  The derived class should call these to find out the
// currently set mediatype(s) whenever it needs to make a decision that
// depends on the mediatype used.  Each of these returns NULL if the mediatype
// has not been set yet.
//
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

#define PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulStreamIndex >= 1) \
       return DMO_E_INVALIDSTREAMINDEX

class C1in1outDMO : public IMediaObject
{
public:
    C1in1outDMO() :
       m_bInputTypeSet(FALSE),
       m_bOutputTypeSet(FALSE),
       m_bIncomplete(FALSE)
    {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
    }
    ~C1in1outDMO() {
#ifdef DMO_NOATL
       DeleteCriticalSection(&m_cs);
#endif
    }

public:    
    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = 1;
        *pulNumberOfOutputStreams = 1;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       PROLOGUE;
       return GetInputFlags(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       PROLOGUE;
       return GetOutputFlags(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetInputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetOutputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       if (m_bInputTypeSet)
          return MoCopyMediaType(pmt, &m_InputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       if (m_bOutputTypeSet)
          return MoCopyMediaType(pmt, &m_OutputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       PROLOGUE;
       if (!m_bInputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetInputSizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
       PROLOGUE;
       if (!m_bOutputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetOutputSizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       PROLOGUE;
       HRESULT hr = CheckInputType(pmt);
       if (FAILED(hr))
          return hr;

       if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
          return NOERROR;

       // Free any previous mediatype
       if (m_bInputTypeSet)
          MoFreeMediaType(&m_InputType);

       // actually set the type
       MoCopyMediaType(&m_InputType, pmt);
       m_bInputTypeSet = TRUE;

       if (m_bOutputTypeSet)
          PrepareForStreaming();
       return NOERROR;
    }
    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       PROLOGUE;
       HRESULT hr = CheckOutputType(pmt);
       if (FAILED(hr))
          return hr;

       if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
          return NOERROR;

       // Free any previous mediatype
       if (m_bOutputTypeSet)
          MoFreeMediaType(&m_OutputType);

       // actually set the type
       MoCopyMediaType(&m_OutputType, pmt);
       m_bOutputTypeSet = TRUE;

       if (m_bInputTypeSet)
          PrepareForStreaming();
       return NOERROR;
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {
       PROLOGUE;
       *pdwStatus = 0;
       if (AcceptingInput() == S_OK)
          *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
       return NOERROR;

    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
       PROLOGUE;
       return Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);
       DoFlush();
       return NOERROR;
    }
    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}
    
    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       PROLOGUE;
       if (AcceptingInput() != S_OK)
          return DMO_E_NOTACCEPTING;
       if (!pBuffer)
          return E_POINTER;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pData;
       ULONG ulSize;
       HRESULT hr = pBuffer->GetBufferAndLength(&pData, &ulSize);
       if (FAILED(hr))
          return hr;
       if (pData == NULL)
          ulSize = 0;

       m_bIncomplete = TRUE; // new input means we may be able to produce output

       return AcceptInput(pData, ulSize, dwFlags, rtTimestamp, rtTimelength, pBuffer);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       HRESULT hr;
       CDMOAutoLock l(&m_cs);
       
       if (ulOutputBufferCount != 1)
          return E_INVALIDARG;

       pOutputBuffers[0].dwStatus = 0;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pOut;
       ULONG ulSize;
       ULONG ulAvail;

       if (pOutputBuffers[0].pBuffer) {
          hr = pOutputBuffers[0].pBuffer->GetBufferAndLength(&pOut, &ulSize);
          if (FAILED(hr)) return hr;
          hr = pOutputBuffers[0].pBuffer->GetMaxLength(&ulAvail);
          if (FAILED(hr)) return hr;
   
          if (ulSize) { // skip any already used portion of the buffer
             if (ulSize > ulAvail)
                return E_INVALIDARG;
             ulAvail -= ulSize;
             pOut += ulSize;
          }
       }
       else
          ulAvail = 0;

       if (ulAvail) { // have output buffer - call process
          ULONG ulProduced = 0;
          hr = ProduceOutput(pOut,
                             ulAvail,
                             &ulProduced,
                             &(pOutputBuffers[0].dwStatus),
                             &(pOutputBuffers[0].rtTimestamp),
                             &(pOutputBuffers[0].rtTimelength));
          if (FAILED(hr))
             return hr;

          HRESULT hrProcess = hr; // remember this in case it's S_FALSE

          // remember the DMO's incomplete status
          if (pOutputBuffers[0].dwStatus | DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
             m_bIncomplete = TRUE;
          else
             m_bIncomplete = FALSE;

          if (ulProduced > ulAvail)
             return E_FAIL;

          hr = pOutputBuffers[0].pBuffer->SetLength(ulSize + ulProduced);
          if (FAILED(hr))
             return hr;

          return hrProcess;
       }
       else { // no output buffer - assume they just want the incomplete flag
          if (m_bIncomplete)
             pOutputBuffers[0].dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
          return NOERROR;
       }
    }
    
protected:
    //
    // private methods for use by derived class
    //
    DMO_MEDIA_TYPE *InputType() {
       if (m_bInputTypeSet)
          return &m_InputType;
       else
          return NULL;
    }
    DMO_MEDIA_TYPE *OutputType() {
       if (m_bOutputTypeSet)
          return &m_OutputType;
       else
          return NULL;
    }

protected:    
    //
    // To be overriden by the derived class
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0; // default implementation assumes no lookahead
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0;
       return NOERROR;
    }
    
    virtual HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }
    virtual HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }

    virtual HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pcbMaxLookahead = 0; // default implementation assumes no lookahead
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }
    virtual HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }

    virtual HRESULT PrepareForStreaming() {
       return NOERROR;
    }
    virtual HRESULT AcceptingInput() {
       return S_FALSE;
    }
    virtual HRESULT Discontinuity() {
       return NOERROR;
    }
    virtual HRESULT DoFlush() {
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pMediaBuffer
    ) {
       m_bIncomplete = FALSE;
       return S_FALSE;
    }
    virtual HRESULT ProduceOutput(BYTE *pData,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       return S_FALSE;
    }

private:
    // mediatype stuff
    BOOL m_bInputTypeSet;
    BOOL m_bOutputTypeSet;
    DMO_MEDIA_TYPE m_InputType;
    DMO_MEDIA_TYPE m_OutputType;
    
    BOOL m_bIncomplete;
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};



//
// C1for1DMO - base class for 1-input/1-output DMOs which
//  - work on whole samples at a time, one sample per buffer
//  - produce exactly one output sample for every input sample
//  - don't need to accumulate more than 1 input sample before producing
//  - don't produce any additional stuff at the end
//  - the output sample corresponds in time to the input sample
//
// The derived class must implement:
//    HRESULT Process(BYTE* pIn,
//                    ULONG ulBytesIn,
//                    BYTE* pOut,
//                    ULONG* pulProduced);
//    HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
//                           ULONG* pulMaxOutputSampleSize);
//
//
// The derived class should implement:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// The derived class may implement if it needs to:
//    HRESULT Init();
//
// The following methods are implemented by the base class.  The derived class
// should call these to find out if the input/output type has been set and if
// so what it was set to.
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

class C1for1DMO : public C1in1outDMO
{
public:
    C1for1DMO() :
       m_pBuffer(NULL)
    {
    }
    ~C1for1DMO() {
       if (m_pBuffer)
          m_pBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }
    
    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;
       
       *pulSize = m_ulMaxInputSize;
       *pcbMaxLookahead = 0;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;
       
       *pulSize = m_ulMaxOutputSize;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT PrepareForStreaming() {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       return Init();
    }
    HRESULT AcceptingInput() {
       return m_pBuffer ? S_FALSE : S_OK; // accept unless holding one already
    }
    HRESULT AcceptInput(BYTE* pData,
                        ULONG ulSize,
                        DWORD dwFlags,
                        REFERENCE_TIME rtTimestamp,
                        REFERENCE_TIME rtTimelength,
                        IMediaBuffer* pMediaBuffer
    ) {
       if (AcceptingInput() != S_OK)
          return E_FAIL;
       m_pData        = pData;
       m_ulSize       = ulSize;
       m_dwFlags      = dwFlags;
       m_rtTimestamp  = rtTimestamp;
       m_rtTimelength = rtTimelength;
       m_pBuffer      = pMediaBuffer;
       pMediaBuffer->AddRef();
       return NOERROR;
    }
    HRESULT DoFlush() {
       if (m_pBuffer) {
          m_pBuffer->Release();
          m_pBuffer = NULL;
       }
       return NOERROR;
    }
    HRESULT ProduceOutput(BYTE *pOut,
                          ULONG ulAvail,
                          ULONG* pulUsed,
                          DWORD* pdwStatus,
                          REFERENCE_TIME *prtTimestamp,
                          REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       *pdwStatus = 0;

       if (!m_pBuffer)
          return S_FALSE;
       if (ulAvail < m_ulMaxOutputSize)
          return E_INVALIDARG;

       HRESULT hr = Process(m_pData,
                            m_ulSize,
                            pOut,
                            pulUsed);
       
       m_pBuffer->Release();
       m_pBuffer = NULL;

       if (FAILED(hr))
          return hr;

       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIME)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIMELENGTH)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       *prtTimestamp = m_rtTimestamp;
       *prtTimelength = m_rtTimelength;

       if (*pulUsed == 0)
          return S_FALSE;
       return hr;
    }
protected:
    //
    // To be implemented by derived class
    //
    virtual HRESULT Process(BYTE* pIn,
                            ULONG ulBytesIn,
                            BYTE* pOut,
                            ULONG* pulProduced) = 0;
    virtual HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
                                   ULONG* pulMaxOutputSampleSize) = 0;
    virtual HRESULT Init() {return NOERROR;}

private:
   IMediaBuffer* m_pBuffer;
   BYTE* m_pData;
   ULONG m_ulSize;
   DWORD m_dwFlags;
   REFERENCE_TIME m_rtTimestamp;
   REFERENCE_TIME m_rtTimelength;

   ULONG m_ulMaxOutputSize;
   ULONG m_ulMaxInputSize;
};


//
// CFBRDMO - DMO base class for 'fixed bitrate' DMOs.  More specifically,
// this base class assumes the following:
//  - 1 input, 1 output;
//  - both input and output consist of equally sized 'quanta';
//  - input/output quantum sizes can be determined from mediatypes;
//  - each output quantum can be generated independently (without looking at
//     previous output quanta);
//  - if multiple input quanta are needed to generate a particular output
//     quantum ('window overhead'), then the range of input required has an upper
//     bound derived from mediatypes on both sides (i.e., both 'lookahead'
//     and 'input memory' are bounded).
//
// The derived class must implement the following virtual functions:
//    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
//    HRESULT GetStreamingParams(
//       DWORD *pdwInputQuantumSize, // in bytes
//       DWORD *pdwOutputQuantumSize, // in bytes
//       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
//       DWORD *pdwLookBehind,
//       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
//       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
//    );
// The derived class should also implement the following:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
// The derived class may need to implement the followng:
//    HRESULT Init();
//    HRESULT Discontinuity();
//
// The derived class may use these entry points into the base class to get
// the currently set mediatypes:
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//
// The sum of *pdwMaxLookahead and *pdwLoookbehind is the 'window overhead' of
// the algorithm (the window overhead is 0 if the algorithm only needs the
// current input sample).
//
// Because the non-zero window overhead case is more complicated, it is handled by a
// separate set of functions in this base class.  The names of all non-zero
// window overhead functions have the 'NZWO' prefix.  The names of the
// zero window overhead functions begin with 'ZWO'.
//
// A data copy on the input side is necessary in the non-zero window overhead case.
//

class CFBRDMO : public C1in1outDMO
{
public:
    CFBRDMO() :
       m_bParametersSet(FALSE),
       m_pMediaBuffer(NULL),
       m_pAllocAddr(NULL),
       m_bStreaming(FALSE)
    {
    }
    ~CFBRDMO() {
       /*
       if (m_bStreaming)
          StopStreaming();
       */
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;
       if (m_pMediaBuffer)
          m_pMediaBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       //
       // For efficiency reasons we might like to be fed fairly large amounts
       // of data at a time, but technically all we need is one quantum.
       //
       *pulSize = m_ulInputQuantumSize;
       *pcbMaxLookahead = 0; // this base class does not rely on HOLDS_BUFFERS
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       *pulSize = m_ulOutputQuantumSize;
       *pulAlignment = 1;
       return NOERROR;
    }
    
    virtual HRESULT Discontinuity() {
       m_bDiscontinuity = TRUE;
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pBuffer
    ) {
       // Every sample is a syncpoint for mediatypes
       // supported by objects of this class.
       assert(dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT);
       BOOL bTimestamp = (dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) ? TRUE : FALSE;

       if (m_ulWindowOverhead)
          return NZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
       else
          return ZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
    }
    virtual HRESULT ProduceOutput(BYTE *pOut,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       HRESULT hr;
       if (!m_bParametersSet)
          return DMO_E_TYPE_NOT_SET;
       
       // call Discontinuity() if this is the first ProcessOutput() call
       if (!m_bStreaming) {
          HRESULT hr = Discontinuity();
          if (FAILED(hr))
             return hr;
          m_bStreaming = TRUE;
       }

       *pdwStatus = 0;

       ULONG ulInputQuantaAvailable = InputQuantaAvailable();
       if (!ulInputQuantaAvailable)
          return S_FALSE; // did not produce anything

       ULONG ulOutputQuantaPossible = ulAvail / m_ulOutputQuantumSize;
       if (!ulOutputQuantaPossible)
          return E_INVALIDARG; // this would be rather lame

       ULONG ulQuantaToProcess = min(ulOutputQuantaPossible, ulInputQuantaAvailable);
       assert(ulQuantaToProcess > 0);

       BOOL bTimestamp;
       if (m_ulWindowOverhead)
          hr = NZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       else
          hr = ZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       if (FAILED(hr))
          return hr;

       *pulUsed = ulQuantaToProcess * m_ulOutputQuantumSize;

       *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (bTimestamp)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;

       // any data left ?
       if (InputQuantaAvailable()) // yes - set incomplete
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
       else if (m_bDiscontinuity) // no - process any discontinuity
          DoFlush();

       return NOERROR;
    }
    HRESULT DoFlush()
    {
       // reset flags
       m_bDiscontinuity = FALSE;
       m_bTimestamps = FALSE;

       if (m_ulWindowOverhead)
          NZWODiscardData();
       else
          ZWODiscardData();
          
       // notify the derived class
       Discontinuity();

       return NOERROR;
    }
    HRESULT AcceptingInput() {
       if (!m_bParametersSet) // uninitialized
          return FALSE;

       BOOL bResult;
       if (m_ulWindowOverhead)
          bResult = NZWOQueryAccept();
       else
          bResult = ZWOQueryAccept();

       return bResult ? S_OK : S_FALSE;
    }
    // End C1in1out overridables implementation
    
private:
    //
    // Common private code (window overhead or no window overhead)
    //
    // returns the number of input quanta available minus any window overhead
    ULONG InputQuantaAvailable() {
       if (m_ulWindowOverhead)
          return NZWOAvail();
       else
          return ZWOAvail();
    }

    // Private method to compute/allocate stuff once all types have been set.
    HRESULT PrepareForStreaming () {
       m_bParametersSet = FALSE;
       // Now that both types are set, query the derived class for params
       HRESULT hr;
       if (FAILED(hr = GetStreamingParams(&m_ulInputQuantumSize,
                               &m_ulOutputQuantumSize,
                               &m_ulLookahead,
                               &m_ulLookbehind,
                               &m_rtDurationNumerator,
                               &m_rtDenominator)))
          return hr;
       if (!m_rtDenominator) {
          assert(!"bad object - duration denominator should not be 0 !");
          return E_FAIL;
       }
       // Attempt to reduce the fraction.  Probably the most complicated number
       // we will ever see is 44100 = (3 * 7 * 2 * 5) ^ 2, so trying the first
       // few numbers should suffice in most cases.
       DWORD dwP[] = {2,3,5,7,11,13,17,19,23,29,31};
       for (DWORD c = 0; c < sizeof(dwP) / sizeof(DWORD); c++) {
          while ((m_rtDurationNumerator % dwP[c] == 0) &&
                 (m_rtDenominator % dwP[c] == 0)) {
             m_rtDurationNumerator /= dwP[c];
             m_rtDenominator /= dwP[c];
          }
       }

       // We cannot afford to have huge denominators, unfortunately, because
       // we store timestamp numerators using 64 bits, so a large denominator
       // could result in timestamp overflows.  So if the denominator is still
       // too large, reduce it anyway with loss of precision.
       ULONG ulMax = 0x10000; // largest acceptable denominator value
       if (m_rtDenominator >= ulMax) {
          double actual_ratio = (double)m_rtDurationNumerator * (double)m_rtDenominator;
          ULONG ulDenominator = 1;
          // Repeatedly increase the denominator until either the actual ratio
          // can be represented precisely using the denominator, or the
          // denominator gets too large.
          do {
             double fractional_part = actual_ratio * (double)ulDenominator 
                                    - floor(actual_ratio * (double)ulDenominator);
             if (fractional_part == 0)
                break;
             ULONG ulNewDenominator = (ULONG)floor(ulDenominator / fractional_part);
             if (ulNewDenominator >= ulMax)
                break;
             ulDenominator = ulNewDenominator;
          } while(1);
          m_rtDurationNumerator = (ULONG)floor(actual_ratio * ulDenominator);
          m_rtDenominator = ulDenominator;
       }

       m_ulWindowOverhead = m_ulLookahead + m_ulLookbehind;
       if (!m_ulWindowOverhead) // No window overhead - the simple case
          m_bParametersSet = TRUE;
       else // The complicated case with window overhead
          AllocateCircularBuffer();
       
       m_bTimestamps = FALSE;
       m_bDiscontinuity = FALSE;

       if (m_bStreaming) {
          //StopStreaming();
          m_bStreaming = FALSE;
       }
       Init();
       return m_bParametersSet ? NOERROR : E_FAIL;
    }
    // end common code

    //
    // zero window overhead case code
    //
    HRESULT ZWOProcessInput(IMediaBuffer* pBuffer,
                                     BYTE* pData,
                                     ULONG ulSize,
                                     BOOL bTimestamp,
                                     REFERENCE_TIME rtTimestamp) {
       assert(!m_pMediaBuffer);
       
       m_bTimestamp = bTimestamp;
       m_rtTimestamp = rtTimestamp;
       m_pData = pData;
       m_ulData = ulSize;
       m_ulUsed = 0;
       
       // make sure they gave us a meaningful amount of data
       if (m_ulData < m_ulInputQuantumSize)
          return S_FALSE;

       // save the buffer we were given
       m_pMediaBuffer = pBuffer;
       pBuffer->AddRef();
       return NOERROR;
    }
    HRESULT ZWOProcessOutput(BYTE* pOut,
                                      ULONG ulQuantaToProcess,
                                      BOOL* pbTimestamp,
                                      REFERENCE_TIME* prtTimestamp) {
       assert(m_ulUsed % m_ulInputQuantumSize == 0);
       HRESULT hr = FBRProcess(ulQuantaToProcess, m_pData + m_ulUsed, pOut);
       if (FAILED(hr)) return hr;
       ZWOConsume(ulQuantaToProcess);

       if (m_bTimestamp) { // there was a timestamp on this input buffer
          // m_rtTimestamp refers to the beginning of the input buffer.
          // Extrapolate to the beginning of the area we just processed.
          *prtTimestamp = m_rtTimestamp +
               (m_ulUsed % m_ulInputQuantumSize) * m_rtDurationNumerator /
                                                   m_rtDenominator;
          *pbTimestamp = TRUE;
       }
       else if (m_bTimestamps) { // there was a timestamp earlier
          // bugbug: should we extrapolate from a previous timestamp ?
          *pbTimestamp = FALSE;
       }
       else // no timestamps at all
          *pbTimestamp = FALSE;

       return NOERROR;
    }
    ULONG ZWOAvail() {
       if (m_pMediaBuffer) {
          assert(m_ulData - m_ulUsed > m_ulInputQuantumSize);
          return (m_ulData - m_ulUsed) / m_ulInputQuantumSize;
       }
       else
          return 0;
    }
    void ZWOConsume(ULONG ulN) { // the zero window overhead version
       assert(m_pMediaBuffer);
       m_ulUsed += ulN * m_ulInputQuantumSize;
       assert(m_ulData >= m_ulUsed);
       if (m_ulData - m_ulUsed < m_ulInputQuantumSize) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    BOOL ZWOQueryAccept() {
        // accept IFF not holding something already
       if (!m_pMediaBuffer)
          return TRUE;
       else
          return FALSE;
    }
    void ZWODiscardData() {
       if (m_pMediaBuffer) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    // End zero window overhead case code

    //
    // Non zero window overhead case code.
    //
    HRESULT NZWOProcessInput(IMediaBuffer* pBuffer,
                                  BYTE* pData,
                                  ULONG ulSize,
                                  BOOL bTimestamp,
                                  REFERENCE_TIME rtTimestamp) {
       if (bTimestamp) { // process the timestamp
          if (!m_bTimestamps) { // this is the first timestamp we've seen
             // Just getting started - initialize the timestamp to refer to
             // the first input quantum for which we will actually generate
             // output (the first m_ulLookbehind quanta are pure lookbehind and
             // generate no output).
             m_rtTimestampNumerator = rtTimestamp * m_rtDenominator
                                    + m_ulLookbehind * m_rtDurationNumerator;
   
          }
          else {
             // We are already streaming and just got a new timestamp.  Use it
             // to check if our stored timestamp has somehow drifted away from
             // where it should be and adjust if it is far enough off.
   
             ULONG ulInputQuantaAvailable = InputQuantaAvailable();
             if (ulInputQuantaAvailable) {
                // ulInputQuantaAvailable is how far back in time the next
                // quantum we would process is located relative the beginning
                // of the new buffer we just received.
   
                // Compute what the timestamp back there ought to be now.
                REFERENCE_TIME rtTimestampNumerator;
                rtTimestampNumerator = m_rtDenominator * rtTimestamp
                                     - ulInputQuantaAvailable * m_rtDurationNumerator;
   
                // Adjust the stored timestamp if it is off by more than half
                // the duration of a quantum.  Should also have a DbgLog here.
                if ((m_rtTimestampNumerator >= rtTimestampNumerator + m_rtDurationNumerator / 2) ||
                    (m_rtTimestampNumerator <= rtTimestampNumerator - m_rtDurationNumerator / 2)) {
                   m_rtTimestampNumerator = rtTimestampNumerator;
                }
             }
             else {
                // We must still be accumulating the initial window overhead.
                // Too early to need an adjustment, one would hope.
             }
          }
          m_bTimestamps = TRUE;
       }

       if (BufferUsed() + ulSize > m_ulBufferAllocated)
          return E_FAIL; // need a max input size to prevent this

       // append to our buffer
       AppendData(pData, ulSize);
       
       // are we ready to produce now ?
       if (NZWOAvail())
          return NOERROR;
       else
          return S_FALSE; // no output can be produced yet
    }
    HRESULT NZWOProcessOutput(BYTE* pOut,
                                   ULONG ulQuantaToProcess,
                                   BOOL* pbTimestamp,
                                   REFERENCE_TIME* prtTimestamp) {
       //
       // Handle any timestamps
       //
       if (m_bTimestamps) {
          // In window overhead mode the stored timestamp refers to the input
          // data immediately after lookbehind, which corresponds to the
          // begining of the output buffer by definition of FDRProcess.
          *prtTimestamp = m_rtTimestampNumerator / m_rtDenominator;
          *pbTimestamp = TRUE;
          
       }
       else
          *pbTimestamp = FALSE;

       //
       // Handle the data
       //
       HRESULT hr;
       ULONG ulInputNeeded = m_ulInputQuantumSize * (ulQuantaToProcess + m_ulWindowOverhead);
       assert(ulInputNeeded < BufferUsed());
       if (m_ulDataHead + ulInputNeeded <= m_ulBufferAllocated) {
          // No wraparound, everything is easy
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       }
       else { // The data we want to send wraps around the end
          // Q.: does it wrap around inside the window overhead area
          // or inside the main data area ?
          if (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize < m_ulBufferAllocated) {
             // The wraparound occurs inside the main data area.  Advance the
             // window overhead up to the wraparound point by processing some data.
             ULONG ulAdvance = m_ulBufferAllocated - (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize);
             assert(ulAdvance % m_ulInputQuantumSize == 0);
             ulAdvance /= m_ulInputQuantumSize; // convert to quanta
             assert(ulAdvance > 0);
             assert(ulAdvance < ulQuantaToProcess);
             hr = FBRProcess(ulAdvance,
                             m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                             pOut);
             if (FAILED(hr))
                return hr;
             NZWOConsume(ulAdvance);
             
             // Adjust stuff so that the code below can act
             // as if this extra process call never happened.
             pOut += m_ulOutputQuantumSize * ulAdvance;
             ulQuantaToProcess -= ulAdvance;
             assert(ulQuantaToProcess > 0);

             // Now the wraparound point should be exactly on the boundary
             // between window overhead and main data.
             assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize == m_ulBufferAllocated);
          } // wraparound in main data
          
          // When we get here, the wraparound point occurs somewhere inside
          // the window overhead area or right on the border between window overhead and
          // main data.
          assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize >= m_ulBufferAllocated);
          ULONG ulLookaheadToCopy = m_ulBufferAllocated - m_ulDataHead;
          
          // copy to the special area we reserved at the front
          memcpy(m_pCircularBuffer - ulLookaheadToCopy,
                 m_pCircularBuffer + m_ulDataHead,
                 ulLookaheadToCopy);
          
          // Now the block we are interested in is all in one piece
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer - ulLookaheadToCopy  + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       } // data handling - wraparound case
       return NOERROR;
    }
    void AllocateCircularBuffer() {
       // free any previously allocated input buffer
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;

       // bugbug: need a better way to decide this number
       m_ulBufferAllocated = max(m_ulInputQuantumSize * 16, 65536L);
       m_ulDataHead = m_ulDataTail = 0;

       // reserve room at the front for copying window overhead
       ULONG ulPrefix = m_ulWindowOverhead * m_ulInputQuantumSize;
       m_pAllocAddr = new BYTE[m_ulBufferAllocated + ulPrefix];
       if (!m_pAllocAddr)
          return;
       m_pCircularBuffer = m_pAllocAddr + ulPrefix;
       
       m_bParametersSet = TRUE;
    }
    BOOL NZWOQueryAccept() {
       // We are using a temp input buffer.  Is there room to append more ?
       // The answer really depends on how much data they will try to feed
       // us.  Without knowing the maximum input buffer size, we will accept
       // more if the input buffer is less than half full.
       if (2 * BufferUsed() < m_ulBufferAllocated)
          return TRUE;
       else
          return FALSE;
    }
    ULONG NZWOAvail() {
       ULONG ulInputQuantaAvailable = BufferUsed() / m_ulInputQuantumSize;
       if (ulInputQuantaAvailable > m_ulWindowOverhead)
          return ulInputQuantaAvailable - m_ulWindowOverhead;
       else
          return 0;
    }
    void NZWOConsume(ULONG ulN) { // the window overhead version
       assert(ulN * m_ulInputQuantumSize <= BufferUsed());
       m_ulDataHead += ulN * m_ulInputQuantumSize;
       if (m_ulDataHead > m_ulBufferAllocated) //wraparound
          m_ulDataHead -= m_ulBufferAllocated;
       
       // Advance the timestamp.
       // The same denominator is used for both timestamp and duration.
       m_rtTimestampNumerator += ulN * m_rtDurationNumerator;
    }
    ULONG BufferUsed() {
       if (m_ulDataTail >= m_ulDataHead)
          return m_ulDataTail - m_ulDataHead;
       else
          return m_ulBufferAllocated - (m_ulDataHead - m_ulDataTail);
    }
    void AppendData(BYTE *pData, ULONG ulSize) {
       if (m_ulDataTail + ulSize <= m_ulBufferAllocated) { // no wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, ulSize);
		  m_ulDataTail += ulSize;
       }
       else { // wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, m_ulBufferAllocated - m_ulDataTail);
          memcpy(m_pCircularBuffer, pData + m_ulBufferAllocated - m_ulDataTail, ulSize - (m_ulBufferAllocated - m_ulDataTail));
		  m_ulDataTail += ulSize;
		  m_ulDataTail -= m_ulBufferAllocated;
       }
    }
    void NZWODiscardData() {
       m_ulDataHead = m_ulDataTail = 0;
    }
    // End window overhead case code


protected:    
    //
    // To be implemebted by the derived class
    //
    virtual HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut) = 0;
    virtual HRESULT GetStreamingParams(
                       DWORD *pdwInputQuantumSize, // in bytes
                       DWORD *pdwOutputQuantumSize, // in bytes
                       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
                       DWORD *pdwLookbehind,
                       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
                       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
                    ) = 0;
    virtual HRESULT Init() {
       return NOERROR;
    }
    // Because AllocateStreamingResources() and FreeStreamingResources() are
    // optional, we have no place to call StopStreaming() from except the
    // destructor, and calling a virtual function from the destructor doesn't
    // work.  Without StopStreaming(), StartStreaming() is not much use either.
    // We need to change the IMediaObject spec and make those
    // calls mandatory.  Then we can implement StartStreaming/StopStraming.
    // virtual HRESULT StartStreaming() = 0;
    // virtual HRESULT StopStreaming() = 0;

private:

    BOOL m_bNewInput;

    // streaming parameters
    BOOL m_bParametersSet;
    ULONG m_ulInputQuantumSize;
    ULONG m_ulOutputQuantumSize;
    ULONG m_ulLookahead;
    ULONG m_ulLookbehind;
    ULONG m_ulWindowOverhead;
    REFERENCE_TIME m_rtDurationNumerator;
    REFERENCE_TIME m_rtDenominator;

    // streaming state
    BOOL m_bTimestamps; // we have seen at least one timestamp
    BOOL m_bDiscontinuity;
    BOOL m_bStreaming;
    
    // zero window overhead case input data
    IMediaBuffer *m_pMediaBuffer;
    BYTE *m_pData;
    ULONG m_ulData;
    ULONG m_ulUsed;
    BOOL m_bTimestamp; // timestamp on current buffer
    REFERENCE_TIME m_rtTimestamp;

    // window overhead case input data
    BYTE *m_pCircularBuffer;
    BYTE *m_pAllocAddr;
    ULONG m_ulBufferAllocated;
    ULONG m_ulDataHead;
    ULONG m_ulDataTail;
    REFERENCE_TIME m_rtTimestampNumerator; // uses the same denominator as duration

};


// CPCMDMO - base class for PCM audio transform filters.
// Helps non-converting PCM audio transforms with mediatype negotiation.
// Based on CFBRDMO - study that first.
//
// Derived class must implement:
//     FBRProcess()
// Deriver class may implement:
//   Discontinuity() // default implementaion does nothing
//   Init()          // default implementaion does nothing
//   GetPCMParams()    // default implementation proposes 44100/2/16
//   CheckPCMParams()  // default implementation accepts any 8/16 bit format
//   GetWindowParams()   // default implementation assumes no lookahead/lookbehind
//
// This class conveniently provides the following data members accessible
// by the derived class:
//   ULONG m_ulSamplingRate
//   ULONG m_cChannels
//   BOOL m_b8bit
//
#include <mmreg.h>
#include <uuids.h>

class CPCMDMO : public CFBRDMO
{
protected:
   //
   // implement pure virtual CFBRDMO methods
   //
   HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      return GetType(pmt, OutputType());
   }
   HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      return GetType(pmt, InputType());
   }
   HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, OutputType());
   }
   HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, InputType());
   }
   HRESULT Init() {
      return NOERROR;
   }
   HRESULT Discontinuity() {
      return NOERROR;
   }
   HRESULT GetStreamingParams(
              DWORD *pdwInputQuantumSize, // in bytes
              DWORD *pdwOutputQuantumSize, // in bytes
              DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
              DWORD *pdwMaxLookbehind,
              REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
              REFERENCE_TIME *prtDurationDenominator // optional, normally 1
           ) {
      // Sanity check: all of this should have been taken care of by base class
      DMO_MEDIA_TYPE* pmtIn =  InputType();
      DMO_MEDIA_TYPE* pmtOut = OutputType();
      if (!pmtIn || !pmtOut)
         return DMO_E_TYPE_NOT_SET;
      if (CheckType(pmtIn, NULL) || CheckType(pmtOut, pmtIn))
         return DMO_E_TYPE_NOT_ACCEPTED;
      
      WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmtIn->pbFormat;
      
      m_b8bit          = (pWave->wBitsPerSample == 8);
      m_cChannels      = pWave->nChannels;
      m_ulSamplingRate = pWave->nSamplesPerSec;
      
      *pdwInputQuantumSize    = pWave->nBlockAlign;
      *pdwOutputQuantumSize   = pWave->nBlockAlign;
      *prtQuantumDuration     = 10000000; // rt units per sec
      *prtDurationDenominator = pWave->nSamplesPerSec;
      
      GetWindowParams(pdwMaxLookahead, pdwMaxLookbehind);
      return NOERROR;
   }

protected:
   //
   // Methods to be overridden by derived class
   //
   // We use this to get lookahead/lookbehind from the derived class
   virtual void GetWindowParams(DWORD *pdwMaxLookahead,
                                DWORD *pdwMaxLookbehind) {
      *pdwMaxLookahead = 0;
      *pdwMaxLookbehind = 0;
   }
   // derived class can override these if it has specific requirements
   virtual void GetPCMParams(BOOL* pb8bit, DWORD* pcChannels, DWORD* pdwSamplesPerSec) {
      // These values are what the DMO will advertise in its media type.
      // Specifying them here does not mean that this is the only acceptable
      // combination - CheckPCMParams() is the ultimate authority on what we will
      // accept.
      *pb8bit = FALSE;
      *pcChannels = 2;
      *pdwSamplesPerSec = 44100;
   }
   virtual BOOL CheckPCMParams(BOOL b8bit, DWORD cChannels, DWORD dwSamplesPerSec) {
      // Default implementation accepts anything.  Override if you have specific
      // requirements WRT sampling rate, number of channels, or bit depth.
      return TRUE;
   }
   
private:
   //
   // private helpers
   //
   HRESULT GetType(DMO_MEDIA_TYPE* pmt, const DMO_MEDIA_TYPE *pmtOther) {
      // If the other type is set, enumerate that.  Otherwise propose 44100/2/16.
      if (pmtOther) {
         MoCopyMediaType(pmt, pmtOther);
         return NOERROR;
      }
   
      HRESULT hr = MoInitMediaType(pmt, sizeof(WAVEFORMATEX));
      if (FAILED(hr))
         return hr;
   
      pmt->majortype  = MEDIATYPE_Audio;
      pmt->subtype    = MEDIASUBTYPE_PCM;
      pmt->formattype = FORMAT_WaveFormatEx;
   
      WAVEFORMATEX* pWave = (WAVEFORMATEX*) pmt->pbFormat;
      pWave->wFormatTag = WAVE_FORMAT_PCM;
   
      BOOL b8bit;
      DWORD cChannels;
      GetPCMParams(&b8bit, &cChannels, &(pWave->nSamplesPerSec));
      (pWave->nChannels) = (unsigned short)cChannels;
      pWave->wBitsPerSample = b8bit ? 8 : 16;
      pWave->nBlockAlign = pWave->nChannels * pWave->wBitsPerSample / 8;
      pWave->nAvgBytesPerSec = pWave->nSamplesPerSec * pWave->nBlockAlign;
      pWave->cbSize = 0;
   
      return NOERROR;
   }
   HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DMO_MEDIA_TYPE *pmtOther) {
      // verify that this is PCM with a WAVEFORMATEX format specifier
      if ((pmt->majortype  != MEDIATYPE_Audio) ||
          (pmt->subtype    != MEDIASUBTYPE_PCM) ||
          (pmt->formattype != FORMAT_WaveFormatEx) ||
          (pmt->cbFormat < sizeof(WAVEFORMATEX)) ||
          (pmt->pbFormat == NULL))
         return DMO_E_TYPE_NOT_ACCEPTED;
      
      // If other type set, accept only if identical to that.  Otherwise accept
      // any standard PCM audio.
      if (pmtOther) {
         if (memcmp(pmt->pbFormat, pmtOther->pbFormat, sizeof(WAVEFORMATEX)))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      else {
         WAVEFORMATEX* pWave = (WAVEFORMATEX*)pmt->pbFormat;
         if ((pWave->wFormatTag != WAVE_FORMAT_PCM) ||
             ((pWave->wBitsPerSample != 8) && (pWave->wBitsPerSample != 16)) ||
             (pWave->nBlockAlign != pWave->nChannels * pWave->wBitsPerSample / 8) ||
             (pWave->nAvgBytesPerSec != pWave->nSamplesPerSec * pWave->nBlockAlign) ||
             !CheckPCMParams((pWave->wBitsPerSample == 8), pWave->nChannels, pWave->nSamplesPerSec))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      return NOERROR;
   }

protected:
   // format info - the derived class may look at these (but no modify)
   ULONG m_ulSamplingRate;
   ULONG m_cChannels;
   BOOL m_b8bit;
};


//
// CGenericDMO - generic DMO base class.  This is currently the only base
// class for DMOs that have multiple inputs or multiple outputs.
//
// This base class tries to be reasonably generic.  The derived class reports
// how many streams it supports and describes each stream by calling
// CreateInputStreams() and CreateOutputStreams().  Each of these functions
// takes an array of STREAMDESCRIPTOR structures, each of which poits to an
// array of FORMATENTRY structures.
//
// This base class uses CInputStream and COutputStream classes (both derived
// from CStream) to keep track of input and output stream.  However, these
// objects are not visible to the derived class - the derived class only sees
// stream IDs.
//
// One limitation of the scheme use here is that the derived class cannot
// override the GetType/SetType methods individually for each stream.  It must
// either (a) live with a static, finite set of types communicated via the
// STREAMDESCRIPTOR structure, or (b) override all IMediaObject type methods
// and handle type negotiation for all streams itself.
//
// Processing occurs when the base class calles DoProcess (overridden by the
// derived class).  DoProcess receives an array of input buffer structs and
// an array of output buffer structs.  The base class takes care of talking
// to IMediaBuffers, so the derived class only sees actual data pointers.
//

// flags used to communicate with the derived class
enum _INPUT_STATUS_FLAGS {
   INPUT_STATUSF_RESIDUAL // cannot be further processed w/o additional input
};
                            
// These are used to pass buffers between this class and the derived class.
typedef struct _INPUTBUFFER {
   BYTE *pData;                 // [in] - if NULL, the rest are garbage
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [in] - DMO_INPUT_DATA_BUFFERF_XXX
   DWORD dwStatus;              // [out] - INPUT_STATUSF_XXX from above
   REFERENCE_TIME rtTimestamp;  // [in]
   REFERENCE_TIME rtTimelength; // [in]
} INPUTBUFFER, *PINPUTBUFFER;
typedef struct _OUTPUTBUFFER {
   BYTE *pData;                 // [in]
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [out] - DMO_OUTPUT_DATA_BUFFERF_XXX
   REFERENCE_TIME rtTimestamp;  // [out]
   REFERENCE_TIME rtTimelength; // [out]
} OUTPUTBUFFER, *POUTPUTBUFFER;

// Used by derived class to describe the format supported by each stream
typedef struct _FORMATENTRY
{
    const GUID *majortype;
    const GUID *subtype;
    const GUID *formattype;
    DWORD cbFormat;
    BYTE* pbFormat;
} FORMATENTRY;

// These are used by the derived class to described its streams
typedef struct _INPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
   BOOL         bHoldsBuffers;
   DWORD        dwMaxLookahead; // used if HOLDS_BUFFERS set
} INPUTSTREAMDESCRIPTOR;
typedef struct _OUTPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
} OUTPUTSTREAMDESCRIPTOR;

// Common input/output stream stuff
class CStream {
public:
    DMO_MEDIA_TYPE       m_MediaType;
    BOOL                m_bEOS;
    BOOL                m_bTypeSet;

    DWORD        m_cFormats;
    FORMATENTRY *m_pFormats;
    DWORD        m_dwMinBufferSize;

    //  Should really pass in a format type list
    CStream()
    {
        MoInitMediaType(&m_MediaType, 0);
        m_bTypeSet = FALSE;
        Flush();
    }
    ~CStream()
    {
        MoFreeMediaType(&m_MediaType);
    }
    HRESULT Flush() {
       m_bEOS = FALSE;
       return NOERROR;
    }
    HRESULT StreamInfo(unsigned long *pdwFlags)
    {
       if (pdwFlags == NULL) {
           return E_POINTER;
       }
       *pdwFlags = 0;
       return S_OK;
    }
    HRESULT GetType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt)
    {
        if (ulTypeIndex >= m_cFormats) {
            return E_INVALIDARG;
        }
        //  Just return our types
        MoInitMediaType(pmt, m_pFormats[ulTypeIndex].cbFormat);
        pmt->majortype  = *m_pFormats[ulTypeIndex].majortype;
        pmt->subtype    = *m_pFormats[ulTypeIndex].subtype;
        pmt->formattype = *m_pFormats[ulTypeIndex].formattype;
        memcpy(pmt->pbFormat, m_pFormats[ulTypeIndex].pbFormat, m_pFormats[ulTypeIndex].cbFormat);
        return S_OK;
    }
    HRESULT GetCurrentType(DMO_MEDIA_TYPE *pmt)
    {
        if (NULL == pmt) {
            return E_POINTER;
        }

        if (m_bTypeSet) {
           //  BUGBUG check success
           MoCopyMediaType(pmt, &(m_MediaType));
           return S_OK;
        }
        else
           return DMO_E_TYPE_NOT_SET;
    }
    HRESULT SetType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        //  Need to check this
        HRESULT hr = CheckType(pmt, 0);
        if (FAILED(hr)) {
            return hr;
        }
        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR; // check konly
        }
        //  BUGBUG - check success
        MoCopyMediaType(&m_MediaType, pmt);

        m_bTypeSet = TRUE;;
        return S_OK;
    }
    HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        if (pmt == NULL) {
            return E_POINTER;
        }
        //if (dwFlags & ~DMO_SET_TYPEF_NOT_PARTIAL)
        //    return E_INVALIDARG;

        //  Default - check GUIDs

        bool bMatched = false;
        for (DWORD i = 0; i < m_cFormats; i++) {
            const FORMATENTRY *pFormat = &(m_pFormats[i]);
            if (pmt->majortype  == *(pFormat->majortype) &&
                pmt->subtype    == *(pFormat->subtype) &&
                pmt->formattype == *(pFormat->formattype)) {
                bMatched = true;
                break;
            }
        }

        if (bMatched) {
            return S_OK;
        } else {
            return DMO_E_INVALIDTYPE;
        }
    }
    HRESULT SizeInfo(ULONG *plSize, ULONG *plAlignment)
    {
        if (plSize == NULL || plAlignment == NULL) {
            return E_POINTER;
        }

        *plAlignment = 1;
        *plSize      = m_dwMinBufferSize;
        return S_OK;
    }
};

// Input stream specific stuff
class CInputStream : public CStream {
public:
    BOOL         m_bHoldsBuffers;
    DWORD        m_dwMaxLookahead; // used if HOLDS_BUFFERS set

    // Current input sample
    IMediaBuffer *m_pMediaBuffer;
    DWORD m_dwFlags; // discontinuity, etc.
    REFERENCE_TIME m_rtTimestamp;
    REFERENCE_TIME m_rtTimelength;
    BYTE *m_pData;
    DWORD m_cbSize;
    DWORD m_cbUsed;

    // residual
    BYTE *m_pbResidual;
    DWORD m_cbResidual;
    DWORD m_cbResidualBuffer;

    // temporary buffer for handling the residual
    BYTE *m_pbTemp;

   HRESULT Flush() {
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      return CStream::Flush();
   }
   CInputStream() {
      m_pMediaBuffer = NULL;
      m_pbResidual = NULL;
      m_pbTemp = NULL;
   }
   ~CInputStream() {
      if (m_pMediaBuffer)
         m_pMediaBuffer->Release();
      if (m_pbResidual)
         delete[] m_pbResidual;
   }
   HRESULT StreamInfo(DWORD *pdwFlags) {
      HRESULT hr = CStream::StreamInfo(pdwFlags);
      if (FAILED(hr))
         return hr;
      if (m_bHoldsBuffers)
         *pdwFlags |= DMO_INPUT_STREAMF_HOLDS_BUFFERS;
      return NOERROR;
   }
   HRESULT Init(INPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      m_bHoldsBuffers = pDescriptor->bHoldsBuffers;
      m_dwMaxLookahead = pDescriptor->dwMaxLookahead;
      
      // Just in case Init is called multiple times:
      // delete any preexisting stuff.
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      if (m_pbResidual) {
         delete[] m_pbResidual;
         m_pbResidual = NULL;
      }

      m_cbResidual = 0;
      m_cbResidualBuffer = m_dwMinBufferSize * 2; // enough ?
      m_pbResidual = new BYTE[m_cbResidualBuffer];

      return NOERROR;
   }
   HRESULT InputStatus(DWORD *pdwStatus) {
       // objects that hold buffers must implement InputStatus themselves
      assert(!m_bHoldsBuffers);
      *pdwStatus = 0;
      if (!m_pMediaBuffer)
         *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
      return NOERROR;
   }
   HRESULT Deliver(
      IMediaBuffer *pBuffer, // [in], must not be NULL
      DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
      REFERENCE_TIME rtTimestamp, // [in], valid if flag set
      REFERENCE_TIME rtTimelength // [in], valid if flag set
   ) {
      if (!pBuffer)
         return E_POINTER;
       // objects that hold buffers must implement Deliver themselves
      assert(!m_bHoldsBuffers);
      DWORD dwStatus = 0;
      InputStatus(&dwStatus);
      if (!(dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA))
         return DMO_E_NOTACCEPTING;
      assert(!m_pMediaBuffer); // can't hold multiple buffers

      //Deal with the IMediaBuffer
      HRESULT hr;
      hr = pBuffer->GetBufferAndLength(&m_pData, &m_cbSize);
      if (FAILED(hr))
         return hr;

      if (!m_cbSize) // empty buffer
         return S_FALSE; // no data

      pBuffer->AddRef();
      m_pMediaBuffer = pBuffer;
      m_dwFlags = dwFlags;
      m_rtTimestamp = rtTimestamp;
      m_rtTimelength = rtTimelength;
      m_cbUsed = 0;
      return NOERROR;
   }
   
   //
   // Fetch data from the currently held IMediaBuffer plus any residual
   //
   HRESULT PrepareInputBuffer(INPUTBUFFER *pBuffer)
   {
      // Q.: do we even have any data to give it ?
      if (m_pMediaBuffer) {
         // Is there a residual we need to feed first ?
         if (m_cbResidual) {
            // Yes, prepend the residual to the new input

            // If we have used some of the input buffer by now, we
            // should have also used up any residual with that.
            assert(m_cbUsed == 0);

            // compute how many bytes total we are going to send
            pBuffer->cbSize = m_cbResidual
                                      + m_cbSize;
            
            // Make sure we have at least dwMinBufferSize bytes of data.
            // We really should - the input buffer alone ought to be at
            // least that big.
            assert(pBuffer->cbSize >
                   m_dwMinBufferSize);

            // Is the residual buffer big enough to hold the residual plus
            // all of the new buffer ?
            if (pBuffer->cbSize <= m_cbResidualBuffer) {
               // Yes - wonderful, we can use the residual buffer
               memcpy(m_pbResidual + m_cbResidual,
                      m_pData,
                      m_cbSize);
               pBuffer->pData = m_pbResidual;
            }
            else {
               // No - allocate a sufficiently large temporary buffer.
               // This is supposed to be a rare case.
               m_pbTemp = new BYTE[pBuffer->cbSize];
               if (m_pbTemp == NULL)
                  return E_OUTOFMEMORY;
               // copy the residual
               memcpy(m_pbTemp,
                      m_pbResidual,
                      m_cbResidual);
               // append the new buffer
               memcpy(m_pbTemp + m_cbResidual,
                      m_pData,
                      m_cbSize);

               // set the buffer pointer to our temp buffer
               pBuffer->pData = m_pbTemp;
            }

            // BUGBUG - is this the correct way to handle timestamps &
            // discontinuities when handling a residual ?
            pBuffer->dwFlags = 0; 
         }
         else { // no residual
            pBuffer->pData = m_pData + m_cbUsed;
            pBuffer->cbSize = m_cbSize - m_cbUsed;
            pBuffer->dwFlags = m_dwFlags; 
            pBuffer->rtTimestamp = m_rtTimestamp;
            pBuffer->rtTimelength= m_rtTimelength;
         }
         pBuffer->cbUsed = 0; // derived class should set this
         pBuffer->dwStatus = 0; // derived class should set this
      }
      else {
         pBuffer->pData = NULL;
         pBuffer->cbSize = 0;
      }
      return NOERROR;
   }
   
   //
   // Save any residual and release the IMediaBuffer as appropriate.
   // Returns TRUE if there is enough data left to call ProcesInput again.
   //
   BOOL PostProcessInputBuffer(INPUTBUFFER *pBuffer)
   {
      BOOL bRet = FALSE;
      // did we even give this stream anything ?
      if (m_pMediaBuffer) {
         // Yes, but did it eat any of it ?
         if (pBuffer->cbUsed) {
            // Did we even get past the residual
            if (pBuffer->cbUsed > m_cbResidual) {
               // Yes - reflect this in the current buffer's cbUsed.
               m_cbUsed += (pBuffer->cbUsed - m_cbResidual);
               m_cbResidual = 0;
            }
            else { 
               // No - just subtract from the residual.
               // This is a rather strange case.
               m_cbResidual -= pBuffer->cbUsed;
               memmove(m_pbResidual,
                       m_pbResidual + pBuffer->cbUsed,
                       m_cbResidual);
            }
         }

         // Is there enough left to feed again the next time ?
         if ((m_cbSize - m_cbUsed <
              m_dwMinBufferSize) 
              || (pBuffer->dwStatus & INPUT_STATUSF_RESIDUAL)) {
            // No - copy the residual and release the buffer
            memcpy(m_pbResidual,
                   m_pData + m_cbUsed,
                   m_cbSize - m_cbUsed);
            m_cbResidual
              = pBuffer->cbSize - pBuffer->cbUsed;
            m_pMediaBuffer->Release();
            m_pMediaBuffer = NULL;
         }
         else { // Yes - need another Process call to eat remaining input
            bRet = TRUE;
         }

         // Free any temporary buffer we may have used - rare case
         if (m_pbTemp) {
            delete[] m_pbTemp;
            m_pbTemp = NULL;
         }
      }
      return bRet;
   }
   HRESULT Discontinuity() {
      // BUGBUG - implement
      // m_bDiscontinuity = TRUE;
      return NOERROR;
   }
   HRESULT SizeInfo(ULONG *pulSize,
                    ULONG *pulMaxLookahead,
                    ULONG *pulAlignment) {
      HRESULT hr = CStream::SizeInfo(pulSize, pulAlignment);
      if (FAILED(hr))
         return hr;

      if (m_bHoldsBuffers)
         *pulMaxLookahead = m_dwMaxLookahead;
      else
         *pulMaxLookahead = *pulSize;
      return NOERROR;
   }
};

// Output stream specific stuff
class COutputStream : public CStream {
public:
   BOOL m_bIncomplete;
   DWORD m_cbAlreadyUsed; // temp per-stream variable used during Process
   
   HRESULT Init(OUTPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      return NOERROR;
   }

   //
   // Initialize the OUTPUTBUFFER struct with info from the IMediaBuffer 
   //
   HRESULT PrepareOutputBuffer(OUTPUTBUFFER *pBuffer, IMediaBuffer *pMediaBuffer, BOOL bNewInput)
   {
      //
      // See if the caller supplied an output buffer
      //
      if (pMediaBuffer == NULL) {
         // This is allowed to be NULL only if (1) the object did not set
         // the INCOMPLETE flag for this stream during the last Process
         // call, and (2) no new input data has been supplied to the object
         // since the last Process call.  
         if (bNewInput)
            return E_POINTER;
         if (m_bIncomplete)
            return E_POINTER;

         // ok - initialize assuming no buffer
         pBuffer->cbSize = 0;
         pBuffer->pData = NULL;
      }
      else { // the IMediaBuffer is not NULL - deal with it
         HRESULT hr;
         hr = pMediaBuffer->GetMaxLength(&pBuffer->cbSize);
         if (FAILED(hr))
            return hr;

         hr = pMediaBuffer->GetBufferAndLength(
                 &(pBuffer->pData),
                 &(m_cbAlreadyUsed));
         if (FAILED(hr))
            return hr;

         // Check current size - should we even bother with this ?
         if (m_cbAlreadyUsed) {
            if (m_cbAlreadyUsed >= pBuffer->cbSize)
               return E_INVALIDARG; // buffer already full ?!?
            pBuffer->cbSize -= m_cbAlreadyUsed;
            pBuffer->pData += m_cbAlreadyUsed;
         }
      }
      
      // It is really the derived class's job to set these, but we
      // will be nice to it and initialize them anyway just in case.
      pBuffer->cbUsed = 0;
      pBuffer->dwFlags = 0;

      return NOERROR;
   }

   //
   // Copy the OUTPUTBUFFER back into the DMO_OUTPUT_DATA_BUFFER (yawn)
   //
   void PostProcessOutputBuffer(OUTPUTBUFFER *pBuffer, DMO_OUTPUT_DATA_BUFFER *pDMOBuffer, BOOL bForceIncomplete) {
      assert(pBuffer->cbUsed <= pBuffer->cbSize);
      if (pDMOBuffer->pBuffer)
         pDMOBuffer->pBuffer->SetLength(pBuffer->cbUsed + m_cbAlreadyUsed);
      pDMOBuffer->dwStatus = pBuffer->dwFlags;
      pDMOBuffer->rtTimestamp = pBuffer->rtTimestamp;
      pDMOBuffer->rtTimelength = pBuffer->rtTimelength;

      // Even if the derived class did not set INCOMPLETE, we may need to
      // set it anyway if some input buffer we are holding still has
      // enough data to call Process() again.
      if (bForceIncomplete)
         pDMOBuffer->dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;

      // remember this output stream's INCOMPLETE state
      if (pDMOBuffer->dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
         m_bIncomplete = TRUE;
      else
         m_bIncomplete = FALSE;
   }
};

// Code that goes at the beginning of every IMediaObject method
#define INPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulInputStreamIndex >= m_nInputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    CInputStream *pStream = &m_pInputStreams[ulInputStreamIndex]

#define OUTPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulOutputStreamIndex >= m_nOutputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    COutputStream *pStream = &m_pOutputStreams[ulOutputStreamIndex]


class CGenericDMO : public IMediaObject
{
public:
    CGenericDMO() {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
       m_nInputStreams = 0;
       m_nOutputStreams = 0;
    }
#ifdef DMO_NOATL
    ~CGenericDMO() {
       DeleteCriticalSection(&m_cs);
    }
#endif
    
public:
    //
    // Implement IMediaObject methods
    //
    STDMETHODIMP GetInputStreamInfo(ULONG ulInputStreamIndex, DWORD *pdwFlags)
    {
       INPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulOutputStreamIndex, DWORD *pdwFlags)
    {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulInputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulOutputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulInputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulOutputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulInputStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulOutputStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulInputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP SetOutputType(ULONG ulOutputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulInputStreamIndex,
        DWORD *pdwStatus
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->InputStatus(pdwStatus);
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME *prtLatency) {
       // BUGBUG - I don't know what to do with this right now.
       // Punt to the derived class ?
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP ProcessInput(
        DWORD ulInputStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Deliver(pBuffer, dwFlags, rtTimestamp, rtTimelength);
    }
    STDMETHODIMP Discontinuity(ULONG ulInputStreamIndex) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);
        
       //  Flush all the streams
       ULONG i;
       for (i = 0; i < m_nInputStreams; i++) {
          m_pInputStreams[i].Flush();
       }
       for (i = 0; i < m_nOutputStreams; i++) {
          m_pOutputStreams[i].Flush();
       }
       return S_OK;
    }

    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}

    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = m_nInputStreams;
        *pulNumberOfOutputStreams = m_nOutputStreams;
        return S_OK;
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       CDMOAutoLock l(&m_cs);
       if (ulOutputBufferCount != m_nOutputStreams)
          return E_INVALIDARG;

       HRESULT hr;
       DWORD c;
 
       // Prepare the input buffers
       for (c = 0; c < m_nInputStreams; c++) {
          // objects that hold buffers must implement Process themselves
          assert(!m_pInputStreams[c].m_bHoldsBuffers);
          hr = m_pInputStreams[c].PrepareInputBuffer(&m_pInputBuffers[c]);
          if (FAILED(hr))
             return hr;
       }
 
       //
       // Prepare the output buffers
       //
       for (c = 0; c < m_nOutputStreams; c++) {
          hr = m_pOutputStreams[c].PrepareOutputBuffer(&m_pOutputBuffers[c], pOutputBuffers[c].pBuffer, m_bNewInput);
          if (FAILED(hr))
             return hr;
       }

       hr = DoProcess(m_pInputBuffers,m_pOutputBuffers);
       if (FAILED(hr))
          return hr; // BUGBUG - don't just "return hr", do something !

       // post-process input buffers
       BOOL bSomeInputStillHasData = FALSE;
       for (c = 0; c < m_nInputStreams; c++) {
          if (m_pInputStreams[c].PostProcessInputBuffer(&m_pInputBuffers[c]))
             bSomeInputStillHasData = TRUE;
       }

       // post-process output buffers
       for (c = 0; c < m_nOutputStreams; c++) {
          m_pOutputStreams[c].PostProcessOutputBuffer(&m_pOutputBuffers[c],
                                                      &pOutputBuffers[c],
                                                      bSomeInputStillHasData);
       }

       m_bNewInput = FALSE;
       return NOERROR;
    }

protected:
    //
    // These are called by the derived class at initialization time
    //
    HRESULT CreateInputStreams(INPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pInputStreams = new CInputStream[cStreams];

       if (m_pInputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pInputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pInputStreams;
             return hr;
          }
       }

       m_pInputBuffers = new INPUTBUFFER[cStreams];
       if (!m_pInputBuffers) {
          delete[] m_pInputStreams;
          return E_OUTOFMEMORY;
       }

       m_nInputStreams = cStreams;
       return NOERROR;
    }
    HRESULT CreateOutputStreams(OUTPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pOutputStreams = new COutputStream[cStreams];

       if (m_pOutputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pOutputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pOutputStreams;
             return hr;
          }
       }
	   
       m_pOutputBuffers = new OUTPUTBUFFER[cStreams];
       if (!m_pOutputBuffers) {
          delete[] m_pOutputStreams;
          return E_OUTOFMEMORY;
       }

       m_nOutputStreams = cStreams;
       return NOERROR;
    }

    virtual HRESULT DoProcess(INPUTBUFFER*, OUTPUTBUFFER *) = 0;

private:

    ULONG           m_nInputStreams;
    CInputStream*   m_pInputStreams;
    ULONG           m_nOutputStreams;
    COutputStream*  m_pOutputStreams;

    INPUTBUFFER*    m_pInputBuffers;
    OUTPUTBUFFER*   m_pOutputBuffers;

    BOOL m_bNewInput;
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};

#endif // __DMOBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\echo.cpp ===
// Echo.cpp : Implementation of CEchoTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "echo.h"
#include "toolhelp.h"


CEchoTool::CEchoTool()
{
    ParamInfo Params[DMUS_ECHO_PARAMCOUNT] = 
    {
        { DMUS_ECHO_REPEAT, MPT_INT,MP_CAPS_ALL,0,100,2,
            L"Repeats",L"Repeat",NULL },            // Repeat - twice by default
        { DMUS_ECHO_DECAY, MPT_INT,MP_CAPS_ALL,0,100,12,
            L"dB",L"Decay",NULL },           // Decay - 12 db by default
        { DMUS_ECHO_TIMEUNIT, MPT_ENUM,MP_CAPS_ALL, DMUS_TIME_UNIT_MS,DMUS_TIME_UNIT_1,DMUS_TIME_UNIT_GRID,
            L"",L"Delay Units",L"Milliseconds,Music Clicks,Grid,Beat,Bar,64th note triplets,64th notes,32nd note triplets,32nd notes,16th note triplets,16th notes,8th note triplets,8th notes,Quarter note triplets,Quarter notes,Half note triplets,Half notes,Whole note triplets,Whole notes" },
        { DMUS_ECHO_DELAY, MPT_INT,MP_CAPS_ALL,1,1000,1,
            L"",L"Delay",NULL},   // Delay - 1 grid note by default
        { DMUS_ECHO_GROUPOFFSET, MPT_INT,MP_CAPS_ALL,0,100,0,
            L"Channel Groups",L"Channel Offset", NULL },            // Group offset - none by default
        { DMUS_ECHO_TYPE, MPT_ENUM,MP_CAPS_ALL, DMUS_ECHOT_FALLING,DMUS_ECHOT_RISING_CLIP,DMUS_ECHOT_FALLING_CLIP,
            L"",L"Type",L"Falling,Falling & Truncated,Rising,Rising & Truncated"} // Type - falling by default
    };
    InitParams(DMUS_ECHO_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CEchoTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEchoTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CEchoTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicEchoTool)
	{
		*ppv = static_cast<IDirectMusicEchoTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CEchoTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicEchoTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CEchoTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CEchoTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_ECHO_CHUNK))
	{
        DMUS_IO_ECHO_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_ECHO_REPEAT,(float) Header.dwRepeat);
            SetParam(DMUS_ECHO_DECAY,(float) Header.dwDecay);
            SetParam(DMUS_ECHO_TIMEUNIT,(float) Header.dwTimeUnit);
            SetParam(DMUS_ECHO_DELAY,(float) Header.dwDelay);
            SetParam(DMUS_ECHO_GROUPOFFSET,(float) Header.dwGroupOffset);
            SetParam(DMUS_ECHO_TYPE,(float) Header.dwType);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CEchoTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_ECHO_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_ECHO_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_ECHO_HEADER Header;
        GetParamInt(DMUS_ECHO_REPEAT,MAX_REF_TIME,(long *) &Header.dwRepeat);
        GetParamInt(DMUS_ECHO_DECAY,MAX_REF_TIME,(long *) &Header.dwDecay);
        GetParamInt(DMUS_ECHO_TIMEUNIT,MAX_REF_TIME,(long *) &Header.dwTimeUnit);
        GetParamInt(DMUS_ECHO_DELAY,MAX_REF_TIME,(long *) &Header.dwDelay);
        GetParamInt(DMUS_ECHO_GROUPOFFSET,MAX_REF_TIME,(long *) &Header.dwGroupOffset);
        GetParamInt(DMUS_ECHO_TYPE,MAX_REF_TIME,(long *) &Header.dwType);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CEchoTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_ECHO_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CEchoTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_EchoPage;
	return NOERROR;
}


static long glResTypes[DMUS_TIME_UNIT_COUNT] = 
{ 1,    // DMUS_TIME_UNIT_MS
  1,    // DMUS_TIME_UNIT_MTIME 
  384,  // DMUS_TIME_UNIT_GRID
  768,  // DMUS_TIME_UNIT_BEAT
  3072, // DMUS_TIME_UNIT_BAR
  32,   // DMUS_TIME_UNIT_64T
  48,   // DMUS_TIME_UNIT_64
  64,   // DMUS_TIME_UNIT_32T  
  96,   // DMUS_TIME_UNIT_32 
  128,  // DMUS_TIME_UNIT_16T     
  192,  // DMUS_TIME_UNIT_16     
  256,  // DMUS_TIME_UNIT_8T    
  384,  // DMUS_TIME_UNIT_8         
  512,  // DMUS_TIME_UNIT_4T  
  768,  // DMUS_TIME_UNIT_4         
  1024, // DMUS_TIME_UNIT_2T   
  1536, // DMUS_TIME_UNIT_2   
  2048, // DMUS_TIME_UNIT_1T
  3072  // DMUS_TIME_UNIT_1
};

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CEchoTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    // We need to know if there's an offset, because that determines which kinds of messages we process.
    long lGroupOffset;
    GetParamInt(DMUS_ECHO_GROUPOFFSET,rtTime,&lGroupOffset);
    lGroupOffset *= 16; // Convert to pchannels.
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lRepeats, lDecay, lTimeUnit, lDelay, lType;
            
            GetParamInt(DMUS_ECHO_REPEAT,rtTime,&lRepeats);
            GetParamInt(DMUS_ECHO_DELAY,rtTime,&lDelay);
            GetParamInt(DMUS_ECHO_TIMEUNIT,rtTime,&lTimeUnit);
            GetParamInt(DMUS_ECHO_DECAY,rtTime,&lDecay);
            GetParamInt(DMUS_ECHO_TYPE,rtTime,&lType);
            long lStartVolume;
            if (lTimeUnit > DMUS_TIME_UNIT_BAR)
            {
                lDelay *= glResTypes[lTimeUnit];
            }
            else if (lTimeUnit >= DMUS_TIME_UNIT_GRID)
            {
                DMUS_TIMESIGNATURE TimeSig;
                if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime,NULL,&TimeSig)))
                {
                    DWORD dwBeat = (4 * 768) / TimeSig.bBeat;
                    if (lTimeUnit == DMUS_TIME_UNIT_BEAT)
                    {
                        lDelay *= dwBeat;
                    }
                    else if (lTimeUnit == DMUS_TIME_UNIT_GRID)
                    {
                        lDelay *= (dwBeat / TimeSig.wGridsPerBeat);
                    }
                    else 
                    {
                        lDelay *= (dwBeat * TimeSig.bBeatsPerMeasure);
                    }
                }
            }
            lDecay *= 100;  // We'll do our math in 1/100ths of a dB.
            if (lType & DMUS_ECHOT_RISING)
            {
                lStartVolume = MidiToVolume(pNote->bVelocity) - (lRepeats * lDecay);
                lDecay = -lDecay;
            }
            else
            {
                lStartVolume = MidiToVolume(pNote->bVelocity);
            }
            long lCount;
            for (lCount = 0; lCount <= lRepeats; lCount++)
            {
                DMUS_NOTE_PMSG *pCopy = NULL;
                if (lCount > 0)
                {
                    pNote->dwSize = sizeof (DMUS_NOTE_PMSG);
                    pPerf8->ClonePMsg((DMUS_PMSG *) pNote,(DMUS_PMSG **)&pCopy);
                }
                else
                {
                    pCopy = pNote;
                }
                if (pCopy)
                {
                    pCopy->bVelocity = VolumeToMidi(lStartVolume - (lCount * lDecay));
                    pCopy->dwPChannel += (lCount * lGroupOffset);
                    if (lTimeUnit != DMUS_TIME_UNIT_MS)
                    {
                        pCopy->mtTime += (lCount * lDelay);
                        pCopy->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                    else
                    {
                        pCopy->rtTime += (lCount * lDelay * 10000); // Convert from ms to rt.
                        pCopy->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
                    }
                    if (lType & DMUS_ECHOT_FALLING_CLIP)
                    {
                        if (pCopy->mtDuration <= lDecay)
                        {
                            pCopy->mtDuration = lDecay - 1;
                        }
                    }
                    if (lCount) // Don't send the original note. We need it for clone and
                                // it will be requeued on DMUS_S_REQUEUE anyway.
                    {
                        if (SUCCEEDED(pCopy->pGraph->StampPMsg((DMUS_PMSG *)pCopy))) 
                        {
                            pPerf->SendPMsg((DMUS_PMSG *)pCopy);
                        }
                        else
                        {
                            pPerf->FreePMsg((DMUS_PMSG *)pCopy);
                        }
                    }
                }
            }
            pPerf8->Release();
        }
    }
    else if (lGroupOffset > 0)
    {
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            // If the echoes are being sent to other pchannels, duplicate all other events
            // so they go down those pchannels too.
            long lRepeats, lTimeUnit, lDelay;
            GetParamInt(DMUS_ECHO_REPEAT,rtTime,&lRepeats);
            GetParamInt(DMUS_ECHO_DELAY,rtTime,&lDelay);
            GetParamInt(DMUS_ECHO_TIMEUNIT,rtTime,&lTimeUnit);
            if (lTimeUnit > DMUS_TIME_UNIT_MS)
            {
                lDelay *= glResTypes[lTimeUnit];
            }
            long lCount;
            for (lCount = 0; lCount <= lRepeats; lCount++)
            {
                DMUS_PMSG *pCopy = NULL;
                if (lCount > 0)
                {
                    pPerf8->ClonePMsg(pPMsg,&pCopy);
                }
                else
                {
                    pCopy = pPMsg;
                }
                if (pCopy)
                {
                    pCopy->dwPChannel += (lCount * lGroupOffset);
                    if (lTimeUnit != DMUS_TIME_UNIT_MS)
                    {
                        pCopy->mtTime += (lCount * lDelay);
                        pCopy->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                    else
                    {
                        pCopy->rtTime += (lCount * lDelay * 10000); // Convert from ms to rt.
                        pCopy->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
                    }
                    if (lCount) // Don't send the original note. We need it for clone and
                                // it will be requeued on DMUS_S_REQUEUE anyway.
                    {
                        if (SUCCEEDED(pCopy->pGraph->StampPMsg((DMUS_PMSG *)pCopy))) 
                        {
                            pPerf->SendPMsg((DMUS_PMSG *)pCopy);
                        }
                        else
                        {
                            pPerf->FreePMsg((DMUS_PMSG *)pCopy);
                        }
                    }
                }
            }
            pPerf8->Release();
        }
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CEchoTool::Clone( IDirectMusicTool ** ppTool)

{
    CEchoTool *pNew = new CEchoTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CEchoTool::SetRepeat(DWORD dwRepeat) 
{
    return SetParam(DMUS_ECHO_REPEAT,(float) dwRepeat);
}

STDMETHODIMP CEchoTool::SetDecay(DWORD dwDecay) 
{
    return SetParam(DMUS_ECHO_DECAY,(float) dwDecay);
}

STDMETHODIMP CEchoTool::SetTimeUnit(DWORD dwTimeUnit) 
{
    return SetParam(DMUS_ECHO_TIMEUNIT,(float) dwTimeUnit);
}

STDMETHODIMP CEchoTool::SetDelay(DWORD dwDelay) 
{
    return SetParam(DMUS_ECHO_DELAY,(float) dwDelay);
}

STDMETHODIMP CEchoTool::SetGroupOffset(DWORD dwGroupOffset) 
{
    return SetParam(DMUS_ECHO_GROUPOFFSET,(float) dwGroupOffset);
}

STDMETHODIMP CEchoTool::SetType(DWORD dwType) 
{
    return SetParam(DMUS_ECHO_TYPE,(float) dwType);
}

STDMETHODIMP CEchoTool::GetRepeat(DWORD * pdwRepeat) 
{
    return GetParamInt(DMUS_ECHO_REPEAT,MAX_REF_TIME,(long *) pdwRepeat);
}

STDMETHODIMP CEchoTool::GetDecay(DWORD * pdwDecay) 
{
    return GetParamInt(DMUS_ECHO_DECAY,MAX_REF_TIME,(long *) pdwDecay);
}

STDMETHODIMP CEchoTool::GetTimeUnit(DWORD * pdwTimeUnit) 
{
    return GetParamInt(DMUS_ECHO_TIMEUNIT,MAX_REF_TIME,(long *) pdwTimeUnit);
}

STDMETHODIMP CEchoTool::GetDelay(DWORD * pdwDelay) 
{
    return GetParamInt(DMUS_ECHO_DELAY,MAX_REF_TIME,(long *) pdwDelay);
}

STDMETHODIMP CEchoTool::GetGroupOffset(DWORD * pdwGroupOffset) 
{
    return GetParamInt(DMUS_ECHO_GROUPOFFSET,MAX_REF_TIME,(long *) pdwGroupOffset);
}

STDMETHODIMP CEchoTool::GetType(DWORD * pdwType) 
{
    return GetParamInt(DMUS_ECHO_TYPE,MAX_REF_TIME,(long *) pdwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\guids.cpp ===
#include <objbase.h>
#include "initguid.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "basetool.h"
#include "tools.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\echo.h ===
#ifndef _ECHO_TOOL_
#define _ECHO_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CEchoTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicEchoTool

{
public:
	CEchoTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicEchoTool
	STDMETHODIMP SetRepeat(DWORD dwRepeat) ;
	STDMETHODIMP SetDecay(DWORD dwDecay) ;
    STDMETHODIMP SetTimeUnit(DWORD dwTimeUnit) ;
	STDMETHODIMP SetDelay(DWORD dwDelay) ;
    STDMETHODIMP SetGroupOffset(DWORD dwChannelOffset) ;
	STDMETHODIMP SetType(DWORD dwType) ;
	STDMETHODIMP GetRepeat(DWORD * pdwRepeat) ;
	STDMETHODIMP GetDecay(DWORD * pdwDecay) ;
    STDMETHODIMP GetTimeUnit(DWORD * pdwTimeUnit) ;
	STDMETHODIMP GetDelay(DWORD * pdwDelay) ;
	STDMETHODIMP GetType(DWORD * pdwType) ;
    STDMETHODIMP GetGroupOffset(DWORD * pdwChannelOffset) ;
protected:	
};

#endif // _ECHO_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\medparam_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Mar 24 17:07:36 2000
 */
/* Compiler settings for C:\dx8\dmusic\dmime\medparam.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IMediaParamInfo = {0x6d6cbb60,0xa223,0x44aa,{0x84,0x2f,0xa2,0xf0,0x67,0x50,0xbe,0x6d}};


const IID IID_IMediaParams = {0x6d6cbb61,0xa223,0x44aa,{0x84,0x2f,0xa2,0xf0,0x67,0x50,0xbe,0x6e}};


const IID IID_IMediaParamsRecordNotify = {0xfea74878,0x4e39,0x4267,{0x8a,0x17,0x6a,0xaf,0x05,0x36,0xff,0x7c}};


const IID IID_IMediaParamsRecord = {0x21b64d1a,0x8e24,0x40f6,{0x87,0x97,0x44,0xcc,0x02,0x1b,0x2a,0x0a}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\quantize.cpp ===
// Quantize.cpp : Implementation of CQuantizeTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "quantize.h"
#include "toolhelp.h"

CQuantizeTool::CQuantizeTool()
{
    ParamInfo Params[DMUS_QUANTIZE_PARAMCOUNT] = 
    {
        { DMUS_QUANTIZE_STRENGTH, MPT_INT,MP_CAPS_ALL,0,110,80,
            L"Percent",L"Strength",NULL },            // Strength - 80% by default
        { DMUS_QUANTIZE_TIMEUNIT, MPT_ENUM,MP_CAPS_ALL, DMUS_TIME_UNIT_MTIME,DMUS_TIME_UNIT_1,DMUS_TIME_UNIT_GRID,
            L"",L"Resolution Units",L"Music Clicks,Grid,Beat,Bar,64th note triplets,64th notes,32nd note triplets,32nd notes,16th note triplets,16th notes,8th note triplets,8th notes,Quarter note triplets,Quarter notes,Half note triplets,Half notes,Whole note triplets,Whole notes" },
        { DMUS_QUANTIZE_RESOLUTION, MPT_INT,MP_CAPS_ALL,1,1000,1,
            L"",L"Resolution",NULL},   // Resolution - 1 grid note by default
        { DMUS_QUANTIZE_TYPE, MPT_ENUM,MP_CAPS_ALL, DMUS_QUANTIZET_START,DMUS_QUANTIZET_ALL,DMUS_QUANTIZET_START,
            L"",L"Type",L"Start Time,Duration,Start and Duration"} // Type - quantize start time by default
    };
    InitParams(DMUS_QUANTIZE_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CQuantizeTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CQuantizeTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CQuantizeTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicQuantizeTool)
	{
		*ppv = static_cast<IDirectMusicQuantizeTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CQuantizeTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicQuantizeTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CQuantizeTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CQuantizeTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_QUANTIZE_CHUNK))
	{
        DMUS_IO_QUANTIZE_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_QUANTIZE_STRENGTH,(float) Header.dwStrength);
            SetParam(DMUS_QUANTIZE_TIMEUNIT,(float) Header.dwTimeUnit);
            SetParam(DMUS_QUANTIZE_RESOLUTION,(float) Header.dwResolution);
            SetParam(DMUS_QUANTIZE_TYPE,(float) Header.dwType);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CQuantizeTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_QUANTIZE_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_QUANTIZE_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_QUANTIZE_HEADER Header;
        GetParamInt(DMUS_QUANTIZE_STRENGTH,MAX_REF_TIME,(long *)&Header.dwStrength);
        GetParamInt(DMUS_QUANTIZE_TIMEUNIT,MAX_REF_TIME,(long *) &Header.dwTimeUnit);
        GetParamInt(DMUS_QUANTIZE_RESOLUTION,MAX_REF_TIME,(long *) &Header.dwResolution);
        GetParamInt(DMUS_QUANTIZE_TYPE,MAX_REF_TIME,(long *) &Header.dwType);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CQuantizeTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_QUANTIZE_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CQuantizeTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_QuantizePage;
	return NOERROR;
}

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CQuantizeTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lStrength, lResolution, lTimeUnit, lType;
            
            GetParamInt(DMUS_QUANTIZE_STRENGTH,rtTime,&lStrength);
            GetParamInt(DMUS_QUANTIZE_RESOLUTION,rtTime,&lResolution);
            GetParamInt(DMUS_QUANTIZE_TIMEUNIT,rtTime,&lTimeUnit);
            GetParamInt(DMUS_QUANTIZE_TYPE,rtTime,&lType);
            DMUS_TIMESIGNATURE TimeSig;
            if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime - pNote->nOffset,NULL,&TimeSig)))
            {
                lResolution *= CToolHelper::TimeUnitToTicks(lTimeUnit,&TimeSig);
                if (lResolution < 1) lResolution = 1;
                if ((lType == DMUS_QUANTIZET_START) || (lType == DMUS_QUANTIZET_ALL))
                {
                    MUSIC_TIME mtTime = -TimeSig.mtTime;
                    long lIntervals = (mtTime + (lResolution >> 1)) / lResolution;
                    long lOffset = mtTime - (lIntervals * lResolution);
                    lOffset *= lStrength;
                    lOffset /= 100;
                    pNote->mtTime -= lOffset;
                    pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
                if ((lType == DMUS_QUANTIZET_LENGTH) || (lType == DMUS_QUANTIZET_ALL))
                {
                    long lIntervals = (pNote->mtDuration + (lResolution >> 1)) / lResolution;
                    if (lIntervals < 1) lIntervals = 1;
                    long lOffset = pNote->mtDuration - (lIntervals * lResolution);
                    lOffset *= lStrength;
                    lOffset /= 100;
                    pNote->mtDuration -= lOffset;
                }
                
            }
            pPerf8->Release();
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CQuantizeTool::Clone( IDirectMusicTool ** ppTool)

{
    CQuantizeTool *pNew = new CQuantizeTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CQuantizeTool::SetStrength(DWORD dwStrength) 
{
    return SetParam(DMUS_QUANTIZE_STRENGTH,(float) dwStrength);
}

STDMETHODIMP CQuantizeTool::SetTimeUnit(DWORD dwTimeUnit) 
{
    return SetParam(DMUS_QUANTIZE_TIMEUNIT,(float) dwTimeUnit);
}

STDMETHODIMP CQuantizeTool::SetResolution(DWORD dwResolution) 
{
    return SetParam(DMUS_QUANTIZE_RESOLUTION,(float) dwResolution);
}

STDMETHODIMP CQuantizeTool::SetType(DWORD dwType) 
{
    return SetParam(DMUS_QUANTIZE_TYPE,(float) dwType);
}

STDMETHODIMP CQuantizeTool::GetStrength(DWORD * pdwStrength) 
{
    return GetParamInt(DMUS_QUANTIZE_STRENGTH,MAX_REF_TIME,(long *) pdwStrength);
}

STDMETHODIMP CQuantizeTool::GetTimeUnit(DWORD * pdwTimeUnit) 
{
    return GetParamInt(DMUS_QUANTIZE_TIMEUNIT,MAX_REF_TIME,(long *) pdwTimeUnit);
}

STDMETHODIMP CQuantizeTool::GetResolution(DWORD * pdwResolution) 
{
    return GetParamInt(DMUS_QUANTIZE_RESOLUTION,MAX_REF_TIME,(long *) pdwResolution);
}

STDMETHODIMP CQuantizeTool::GetType(DWORD * pdwType) 
{
    return GetParamInt(DMUS_QUANTIZE_TYPE,MAX_REF_TIME,(long *) pdwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\quantize.h ===
#ifndef _QUANTIZE_TOOL_
#define _QUANTIZE_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CQuantizeTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicQuantizeTool

{
public:
	CQuantizeTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicQuantizeTool
	STDMETHODIMP SetStrength(DWORD dwStrength) ;
    STDMETHODIMP SetTimeUnit(DWORD dwTimeUnit) ;
	STDMETHODIMP SetResolution(DWORD dwResolution) ;
	STDMETHODIMP SetType(DWORD dwType) ;
	STDMETHODIMP GetStrength(DWORD * pdwStrength) ;
    STDMETHODIMP GetTimeUnit(DWORD * pdwTimeUnit) ;
	STDMETHODIMP GetResolution(DWORD * pdwResolution) ;
	STDMETHODIMP GetType(DWORD * pdwType) ;
protected:	
};

#endif // _QUANTIZE_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc
!include $(DXROOT)\project.mk

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmtool

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF



TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmtool.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1
USE_IOSTREAM=1

!if !$(FREEBUILD)

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif


C_DEFINES= $(C_DEFINES) -D_WIN32


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
           $(SDK_LIB_PATH)\ole32.lib        \
           $(SDK_LIB_PATH)\uuid.lib

INCLUDES=$(INCLUDES) \
    $(DXROOT)\dmusic\shared

SOURCES=\
    ..\alist.cpp                \
    ..\debug.cpp                \
    ..\dll.cpp                  \
    ..\duration.cpp             \
    ..\echo.cpp                 \
    ..\guids.cpp                \
    ..\oledll.cpp               \
    ..\param.cpp                \
	..\swing.cpp				\
    ..\toolhelp.cpp             \
    ..\transpose.cpp			\
	..\quantize.cpp				\
	..\timeshift.cpp			\
	..\velocity.cpp				\
	..\toolprop_i.c				\
    ..\medparam_i.c				\
	..\dmtool.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		= TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\param.h ===
#ifndef __TOOLPARAM_H__
#define __TOOLPARAM_H__



#include "medparam.h"
#include "alist.h"

typedef struct _ParamInfo
{
    DWORD dwIndex;                      // Which parameter.
    MP_PARAMINFO    MParamInfo;         // Standard MediaParams structure.
    WCHAR *         pwchText;           // Array of text names for enumerated types.
} ParamInfo;

class CCurveItem : public AListItem
{
public:
    CCurveItem* GetNext() { return (CCurveItem*)AListItem::GetNext();}
    MP_ENVELOPE_SEGMENT m_Envelope;     // Envelope segment.
};

class CCurveList : public AList
{
public:
//    void Clear();
    void AddHead(CCurveItem* pCurveItem) { AList::AddHead((AListItem*)pCurveItem);}
//    void Insert(CCurveItem* pCurveItem);
    CCurveItem* GetHead(){return (CCurveItem*)AList::GetHead();}
//    CCurveItem* GetItem(LONG lIndex){return (CCurveItem*)AList::GetItem(lIndex);}
    CCurveItem* RemoveHead(){ return (CCurveItem*)AList::RemoveHead();}
//    void Remove(CCurveItem* pCurveItem){AList::Remove((AListItem*)pCurveItem);}
//    void AddTail(CCurveItem* pCurveItem){AList::AddTail((AListItem*)pCurveItem);}
//    CCurveItem* GetTail(){ return (CCurveItem*)AList::GetTail();}
};

#define MAX_REF_TIME    0x7FFFFFFFFFFFFFFF
#define MP_CAPS_ALL     MP_CAPS_CURVE_JUMP | MP_CAPS_CURVE_LINEAR | MP_CAPS_CURVE_SQUARE | MP_CAPS_CURVE_INVSQUARE | MP_CAPS_CURVE_SINE

class CParamsManager :	public IMediaParams, public IMediaParamInfo
{
public:
    CParamsManager();
    ~CParamsManager();

	// IUnknown
	STDMETHOD(QueryInterface)(REFIID, LPVOID FAR *) PURE;
	STDMETHOD_(ULONG, AddRef)() PURE;
	STDMETHOD_(ULONG, Release)() PURE;

	// IMediaParams
	STDMETHODIMP GetParam(DWORD dwParamIndex, MP_DATA *pValue);
	STDMETHODIMP SetParam( DWORD dwParamIndex,MP_DATA value);
	STDMETHODIMP AddEnvelope(DWORD dwParamIndex,DWORD cPoints,MP_ENVELOPE_SEGMENT *ppEnvelope);
	STDMETHODIMP FlushEnvelope( DWORD dwParamIndex,REFERENCE_TIME refTimeStart,REFERENCE_TIME refTimeEnd);
	STDMETHODIMP SetTimeFormat( GUID guidTimeFormat,MP_TIMEDATA mpTimeData);

    // IMediaParamInfo
    STDMETHODIMP GetParamCount(DWORD *pdwParams);
    STDMETHODIMP GetParamInfo(DWORD dwParamIndex,MP_PARAMINFO *pInfo);
    STDMETHODIMP GetParamText(DWORD dwParamIndex,WCHAR **ppwchText);
    STDMETHODIMP GetNumTimeFormats(DWORD *pdwNumTimeFormats);
    STDMETHODIMP GetSupportedTimeFormat(DWORD dwFormatIndex,GUID *pguidTimeFormat);        
    STDMETHODIMP GetCurrentTimeFormat( GUID *pguidTimeFormat,MP_TIMEDATA *pTimeData);

protected:
    HRESULT InitParams( DWORD cParams, ParamInfo *pParamInfos);
	HRESULT GetParamFloat (DWORD dwParamIndex,REFERENCE_TIME rt,float *pval);
    HRESULT GetParamInt (DWORD dwParamIndex,REFERENCE_TIME rt,long *pval);
    HRESULT CopyParamsFromSource(CParamsManager * pSource);

	// data

	CRITICAL_SECTION m_ParamsCriticalSection;
    BOOL            m_fDirty;       // Has data changed since last file load or save?
	BOOL			m_fMusicTime;	// True if time format is music time, else false for clock time.
	DWORD           m_cParams;		// Nuimber of parameters.
	ParamInfo       *m_pParamInfos; // Array of ParamInfo structures, one for each parameter.
	CCurveList      *m_pCurveLists; // Array of Curve lists, one for each parameter.
};

#endif // __TOOLPARAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\swing.h ===
#ifndef _SWING_TOOL_
#define _SWING_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CSwingTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicSwingTool

{
public:
	CSwingTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicSwingTool
	STDMETHODIMP SetStrength(DWORD dwStrength) ;
	STDMETHODIMP GetStrength(DWORD * pdwStrength) ;
protected:	
};

#endif // _SWING_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\swing.cpp ===
// Swing.cpp : Implementation of CSwingTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "swing.h"
#include "toolhelp.h"

CSwingTool::CSwingTool()
{
    ParamInfo Params[DMUS_SWING_PARAMCOUNT] = 
    {
        { DMUS_SWING_STRENGTH, MPT_INT,MP_CAPS_ALL,0,100,100,
            L"Percent",L"Strength",NULL },            // Strength - 100% by default
    };
    InitParams(DMUS_SWING_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CSwingTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSwingTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSwingTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicSwingTool)
	{
		*ppv = static_cast<IDirectMusicSwingTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CSwingTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicSwingTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CSwingTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CSwingTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_SWING_CHUNK))
	{
        DMUS_IO_SWING_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_SWING_STRENGTH,(float) Header.dwStrength);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CSwingTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_SWING_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_SWING_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_SWING_HEADER Header;
        GetParamInt(DMUS_SWING_STRENGTH,MAX_REF_TIME,(long *)&Header.dwStrength);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CSwingTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_SWING_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CSwingTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_SwingPage;
	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CSwingTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lStrength;
            
            GetParamInt(DMUS_SWING_STRENGTH,rtTime,&lStrength);
            DMUS_TIMESIGNATURE TimeSig;
            if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime,NULL,&TimeSig)))
            {
                long lGrid = ((4 * 768) / TimeSig.bBeat) / TimeSig.wGridsPerBeat;
                if ((TimeSig.wGridsPerBeat == 3) || (TimeSig.wGridsPerBeat == 6) || 
                    (TimeSig.wGridsPerBeat == 9) || (TimeSig.wGridsPerBeat == 12))
                {
                    // This is already in a triplet feel, so work in reverse.
                    // Adjust the timing, as set by the lStrength parameter.
                    // lStrength is a range from 0 for no swing to 100 for full swing.
                    // We are moving from grids 0,1,2,3,4,5... in triplet feel to grids 
                    // 0,1,2,4,5,6... in non-triplet feel.
                    // So, the notes need to be adjusted in time in either direction.
                    // When we change the time, we clear the DMUS_PMSGF_REFTIME flag, 
                    // telling the performance to recalculate the reference time stamp
                    // in the event when it is requeued.
                    static long lFromTriplet[12] = { 0,1,2,4,5,6,8,9,10,12,13,14 };
                    if (pNote->bGrid < 12)
                    {
                        // Calculate the position we are moving to.
                        long lTwoplet = ((lGrid * 3) / 4) * lFromTriplet[pNote->bGrid];
                        // Calculate the position we are moving from. 
                        lGrid *= pNote->bGrid;
                        // Calculate the new time. Note that we inverse strength since we are going from triplet.
                        pNote->mtTime += ((100 - lStrength) * (lTwoplet - lGrid)) / 100;
		                pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                }
                else if (TimeSig.wGridsPerBeat <= 16)
                {
                    // Adjust the timing, as set by the lStrength parameter.
                    // lStrength is a range from 0 for no swing to 100 for full swing.
                    // We are moving from grids 0,1,2,3 in straight ahead feel to grids 
                    // 0,1,2 in triplet feel.
                    // So, the notes need to be adjusted in time in either direction.
                    // When we change the time, we clear the DMUS_PMSGF_REFTIME flag, 
                    // telling the performance to recalculate the reference time stamp
                    // in the event when it is requeued.
                    static long lToTriplet[16] = { 0,1,2,2,3,4,5,5,6,7,8,8,9,10,11,11 };
                    if (pNote->bGrid < 16)
                    {
                        // Calculate the position we are moving to.
                        long lTriplet = ((lGrid * 4) / 3) * lToTriplet[pNote->bGrid];
                        // Calculate the position we are moving from. 
                        Trace(0,"%ld,%ld,%ld,%ld\t%ld,%ld,%ld\t",
                            (long)TimeSig.bBeatsPerMeasure,(long)TimeSig.bBeat,(long)TimeSig.wGridsPerBeat,
                            lGrid,(long)pNote->bBeat,(long)pNote->bGrid,(long)pNote->nOffset);
                        lGrid *= pNote->bGrid;
                        Trace(0,"%ld,%ld,%ld\n",lStrength,lTriplet,lGrid);
                        pNote->mtTime += (lStrength * (lTriplet - lGrid)) / 100;
		                pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                    }
                }
            }
            pPerf8->Release();
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CSwingTool::Clone( IDirectMusicTool ** ppTool)

{
    CSwingTool *pNew = new CSwingTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CSwingTool::SetStrength(DWORD dwStrength) 
{
    return SetParam(DMUS_SWING_STRENGTH,(float) dwStrength);
}

STDMETHODIMP CSwingTool::GetStrength(DWORD * pdwStrength) 
{
    return GetParamInt(DMUS_SWING_STRENGTH,MAX_REF_TIME,(long *) pdwStrength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\param.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamsManager.
//

#include "dmerror.h"
#include "param.h"
#include "math.h"
#include "..\shared\validate.h"

CParamsManager::CParamsManager()
{
    m_fDirty = FALSE;
    m_fMusicTime = FALSE;
    m_cParams = 0;
    m_pCurveLists = NULL;
    m_pParamInfos = NULL;
    InitializeCriticalSection(&m_ParamsCriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
}

CParamsManager::~CParamsManager()
{
    delete[] m_pCurveLists;
    delete[] m_pParamInfos;
    DeleteCriticalSection(&m_ParamsCriticalSection);
}

HRESULT CParamsManager::InitParams(DWORD cParams, ParamInfo *pParamInfo)
{
    m_pCurveLists = new CCurveList[cParams];
    if (!m_pCurveLists)
        return E_OUTOFMEMORY;

    // save the parameter info
    m_pParamInfos = new ParamInfo[cParams];
    if (!m_pParamInfos)
        return E_OUTOFMEMORY;
    for (DWORD dwIndex = 0; dwIndex < cParams; dwIndex++)
    {
        if (pParamInfo[dwIndex].dwIndex < cParams)
        {
            memcpy(&m_pParamInfos[pParamInfo[dwIndex].dwIndex], &pParamInfo[dwIndex], sizeof(ParamInfo));
        }
    }
    m_cParams = cParams;

    return S_OK;
}

HRESULT CParamsManager::GetParamCount(DWORD *pdwParams)
{
    if (pdwParams == NULL)
        return E_POINTER;

    *pdwParams = m_cParams;
    return S_OK;
}

HRESULT CParamsManager::GetParamInfo(DWORD dwParamIndex, MP_PARAMINFO *pInfo)
{
    if (!pInfo)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        *pInfo = m_pParamInfos[dwParamIndex].MParamInfo;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetParamText(DWORD dwParamIndex, WCHAR **ppwchText)
{
    if (!ppwchText)
    {
        return E_POINTER;
    }
    if (dwParamIndex < m_cParams)
    {
        // write string of format: "Label\0Unit\0Enums1\0Enum2\0...EnumN\0\0"
        ParamInfo &pinfo = m_pParamInfos[dwParamIndex];
        int iUnit = wcslen(pinfo.MParamInfo.szLabel) + 1; // begin writing unit text here
        int iEnums = iUnit + wcslen(pinfo.MParamInfo.szUnitText) + 1; // begin writing enum text here
        int iEnd = iEnums + wcslen(pinfo.pwchText) + 1; // write the final (second) null terminator here
        WCHAR *pwsz = static_cast<WCHAR *>(CoTaskMemAlloc((iEnd + 1) * sizeof(WCHAR)));
        if (!pwsz)
            return E_OUTOFMEMORY;

        // wcscpy will write into various points of the string, neatly terminating each with a null
        wcscpy(pwsz, pinfo.MParamInfo.szLabel);
        wcscpy(pwsz + iUnit, pinfo.MParamInfo.szUnitText);
        wcscpy(pwsz + iEnums, pinfo.pwchText);

        // The text field was defined with commas to separate the enum values.
        // Replace them with NULL characters now.
        for (WCHAR *pwch = pwsz + iEnums; *pwch; ++pwch)
        {
            if (*pwch == L',')
                *pwch = L'\0';
        }

        pwsz[iEnd] = L'\0';

        *ppwchText = pwsz;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CParamsManager::GetNumTimeFormats(DWORD *pdwNumTimeFormats)
{
    if (!pdwNumTimeFormats)
    {
        return E_POINTER;
    }
    *pdwNumTimeFormats = 2;
    return S_OK;
}

HRESULT CParamsManager::GetSupportedTimeFormat(DWORD dwFormatIndex, GUID *pguidTimeFormat)
{
    if (!pguidTimeFormat)
    {
        return E_POINTER;
    }
    if (dwFormatIndex == 0)
    {
        *pguidTimeFormat = GUID_TIME_REFERENCE;
    }
    else
    {
        *pguidTimeFormat = GUID_TIME_MUSIC;
    }
    return S_OK;
}

HRESULT CParamsManager::GetCurrentTimeFormat( GUID *pguidTimeFormat, MP_TIMEDATA *pTimeData)
{
    return E_NOTIMPL;
}

HRESULT CParamsManager::CopyParamsFromSource( CParamsManager * pSource)
{
    HRESULT hr = S_OK;
    hr = InitParams(pSource->m_cParams, pSource->m_pParamInfos);
    if (SUCCEEDED(hr))
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < m_cParams; dwIndex++)
        {
            CCurveItem *pCurve = pSource->m_pCurveLists[dwIndex].GetHead();
            for (;pCurve;pCurve = pCurve->GetNext())
            {
                CCurveItem *pNew = new CCurveItem;
                if (!pNew)
                {
                    return E_OUTOFMEMORY;
                }
                pNew->m_Envelope = pCurve->m_Envelope;
                m_pCurveLists[dwIndex].AddTail(pNew);
            }
        }
    }
    return hr;
}

inline float ValRange(float valToClip, float valMin, float valMax)
{
    return valToClip < valMin
           ? valMin
           : (valToClip > valMax ? valMax : valToClip);
}

HRESULT CParamsManager::GetParamFloat(DWORD dwParamIndex, REFERENCE_TIME rtTime, float *pval)
{
    HRESULT hr = S_OK;

    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    // if no points, then neutral value
    CCurveItem *pCurve = pList->GetHead();
    if (!pCurve)
    {
        *pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
        return S_OK;
    }

    // Find the curve during or before the requested time
    // If the time is during a curve, we will use that.
    // If not, we need the end value of the previous curve.
    // Our list keeps these in backwards order, so we are scanning from the
    // highest point in time backwards.

    for (;pCurve && pCurve->m_Envelope.rtStart > rtTime;pCurve = pCurve->GetNext());

    // If there is no pCurve, there was no curve prior to or during rtTime. Give up.
    if (!pCurve)
    {
        *pval = pInfo->MParamInfo.mpdNeutralValue;
        LeaveCriticalSection(&m_ParamsCriticalSection);
        return S_OK;
    }
    // Now, if pCurve ends before the requested time,
    // return the final value of pCurve, since that will hold until the start of the next curve.
    if (pCurve->m_Envelope.rtEnd < rtTime)
    {
        *pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
        return S_OK;
    }

    // If we get this far, the curve must bound rtTime.

    if (pCurve->m_Envelope.iCurve & MP_CURVE_JUMP)
    {
        *pval = pCurve->m_Envelope.valEnd;
        LeaveCriticalSection(&m_ParamsCriticalSection);
        return S_OK;
    }

    REFERENCE_TIME rtTimeChange = pCurve->m_Envelope.rtEnd - pCurve->m_Envelope.rtStart;
    REFERENCE_TIME rtTimeIntermediate = rtTime - pCurve->m_Envelope.rtStart;

    float fltScalingX = static_cast<float>(rtTimeIntermediate) / rtTimeChange; // horizontal distance along curve between 0 and 1
    float fltScalingY; // height of curve at that point between 0 and 1 based on curve function
    switch (pCurve->m_Envelope.iCurve)
    {
    case MP_CURVE_SQUARE:
        fltScalingY = fltScalingX * fltScalingX;
        break;
    case MP_CURVE_INVSQUARE:
        fltScalingY = (float) sqrt(fltScalingX);
        break;
    case MP_CURVE_SINE:
        //  Maybe we should have a lookup table here?
        fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
        break;
    case MP_CURVE_LINEAR:
    default:
        fltScalingY = fltScalingX;
    }
    // Find out if we need to pull the start point from the previous curve,
    // the default neutral value, or the current curve.
    float fStartVal = pCurve->m_Envelope.valStart;
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_NEUTRALVAL)
    {
        fStartVal = pInfo->MParamInfo.mpdNeutralValue;
    }
    // Currentval, if it exists, will override neutralval.
    if (pCurve->m_Envelope.flags & MPF_ENVLP_BEGIN_CURRENTVAL)
    {
        // Take advantage of the fact that these are inserted in backwards order.
        // Scan for the previous curve that ends before this time.
        CCurveItem *pPrevious = pCurve->GetNext();
           for (;pPrevious && pPrevious->m_Envelope.rtEnd > rtTime;pPrevious = pPrevious->GetNext());
        if (pPrevious)
        {
            fStartVal = pPrevious->m_Envelope.valEnd;
        }
    }

    // Apply that scaling to the range of the actual points
    *pval = (pCurve->m_Envelope.valEnd - pCurve->m_Envelope.valStart) * fltScalingY + pCurve->m_Envelope.valStart;
    LeaveCriticalSection(&m_ParamsCriticalSection);
    return hr;
}

HRESULT CParamsManager::GetParamInt(DWORD dwParamIndex, REFERENCE_TIME rt, long *pval)
{
    HRESULT hr = E_POINTER;
    if (pval)
    {
        float fVal;
        hr = GetParamFloat(dwParamIndex, rt, &fVal);
        if (SUCCEEDED(hr))
        {
            *pval = (long) (fVal + 1/2);    // Round.
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// IMediaParams

HRESULT CParamsManager::GetParam(DWORD dwParamIndex, MP_DATA *pValue)
{
    V_INAME(CParams::GetParam);
    V_PTR_WRITE(pValue, MP_DATA);
    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);

    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    // if no points, then neutral value
    CCurveItem *pCurve = pList->GetHead();
    if (pCurve)
    {
        *pValue = pCurve->m_Envelope.valEnd;
    }
    else
    {
        *pValue = pInfo->MParamInfo.mpdNeutralValue;
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);
    return S_OK;
}

HRESULT CParamsManager::SetParam(DWORD dwParamIndex, MP_DATA value)
{
    V_INAME(CParams::SetParam);

    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    // If we've already got a list, just force the most recent curve item to this value.
    // Otherwise, create a node and add it.
    CCurveItem *pCurve = pList->GetHead();
    if (!pCurve)
    {
        pCurve = new CCurveItem;
        if (pCurve)
        {
            pCurve->m_Envelope.rtStart =    0x8000000000000000; // Max negative.
            pCurve->m_Envelope.rtEnd =      0x7FFFFFFFFFFFFFFF; // Max positive.
            pCurve->m_Envelope.flags = 0;
            pList->AddHead(pCurve);
        }
        else
        {
            LeaveCriticalSection(&m_ParamsCriticalSection);
            return E_OUTOFMEMORY;
        }
    }
    pCurve->m_Envelope.valStart = value;
    pCurve->m_Envelope.valEnd = value;
    pCurve->m_Envelope.iCurve = MP_CURVE_JUMP;
    LeaveCriticalSection(&m_ParamsCriticalSection);

    return S_OK;
}

HRESULT CParamsManager::AddEnvelope(
    DWORD dwParamIndex,
    DWORD cPoints,
    MP_ENVELOPE_SEGMENT *ppEnvelope)
{
    V_INAME(CParams::AddEnvelope);
    V_PTR_READ(ppEnvelope, *ppEnvelope);

    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    if (!m_pParamInfos)
        return DMUS_E_NOT_INIT;

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;

    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];

    DWORD dwCount;
    for (dwCount = 0; dwCount < cPoints; dwCount++)
    {
        CCurveItem *pCurve = new CCurveItem;
        if (!pCurve)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        pCurve->m_Envelope = ppEnvelope[dwCount];
        pCurve->m_Envelope.valEnd = ValRange(pCurve->m_Envelope.valEnd,
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pCurve->m_Envelope.valStart = ValRange(pCurve->m_Envelope.valStart,
            pInfo->MParamInfo.mpdMinValue, pInfo->MParamInfo.mpdMaxValue);
        pList->AddHead(pCurve);
    }

    LeaveCriticalSection(&m_ParamsCriticalSection);

    return hr;
}

HRESULT CParamsManager::FlushEnvelope(
    DWORD dwParamIndex,
    REFERENCE_TIME refTimeStart,
    REFERENCE_TIME refTimeEnd)
{
    if (dwParamIndex >= m_cParams)
        return E_INVALIDARG;

    if (!m_pParamInfos)
        return DMUS_E_NOT_INIT;

    if (refTimeStart >= refTimeEnd)
        return E_INVALIDARG;

    EnterCriticalSection(&m_ParamsCriticalSection);
    m_fDirty = TRUE;
    CCurveList *pList = &m_pCurveLists[dwParamIndex];
    ParamInfo *pInfo = &m_pParamInfos[dwParamIndex];
    CCurveList TempList;
    CCurveItem *pCurve;
    while (pCurve = pList->RemoveHead())
    {
        if ((pCurve->m_Envelope.rtStart >= refTimeStart) &&
            (pCurve->m_Envelope.rtEnd <= refTimeEnd))
        {
            delete pCurve;
        }
        else
        {
            TempList.AddHead(pCurve);
        }
    }
    while (pCurve = TempList.RemoveHead())
    {
        pList->AddHead(pCurve);
    }
    LeaveCriticalSection(&m_ParamsCriticalSection);

    return S_OK;
}

HRESULT CParamsManager::SetTimeFormat(
    GUID guidTimeFormat,
    MP_TIMEDATA mpTimeData)
{
    if (guidTimeFormat == GUID_TIME_REFERENCE)
    {
        m_fMusicTime = FALSE;
    }
    else if (guidTimeFormat == GUID_TIME_MUSIC)
    {
        m_fMusicTime = TRUE;
    }
    else
    {
        return E_INVALIDARG;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\timeshift.h ===
#ifndef _TIMESHIFT_TOOL_
#define _TIMESHIFT_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CTimeShiftTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicTimeShiftTool

{
public:
	CTimeShiftTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicTimeShiftTool
    STDMETHODIMP SetTimeUnit(DWORD dwTimeUnit) ;
	STDMETHODIMP SetRange(DWORD dwRange) ;
	STDMETHODIMP SetOffset(long lOffset) ;
    STDMETHODIMP GetTimeUnit(DWORD * pdwTimeUnit) ;
	STDMETHODIMP GetRange(DWORD * pdwRange);
	STDMETHODIMP GetOffset(long * plOffset);
};

#endif // _TIMESHIFT_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprop_i.c ===
#include <toolprops_i.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\timeshift.cpp ===
// TimeShift.cpp : Implementation of CTimeShiftTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "timeshift.h"
#include "toolhelp.h"


CTimeShiftTool::CTimeShiftTool()
{
    ParamInfo Params[DMUS_TIMESHIFT_PARAMCOUNT] = 
    {
        { DMUS_TIMESHIFT_TIMEUNIT, MPT_ENUM,MP_CAPS_ALL, DMUS_TIME_UNIT_MTIME,DMUS_TIME_UNIT_1,DMUS_TIME_UNIT_GRID,
            L"",L"Resolution Units",L"Music Clicks,Grid,Beat,Bar,64th note triplets,64th notes,32nd note triplets,32nd notes,16th note triplets,16th notes,8th note triplets,8th notes,Quarter note triplets,Quarter notes,Half note triplets,Half notes,Whole note triplets,Whole notes" },
        { DMUS_TIMESHIFT_RANGE, MPT_INT,MP_CAPS_ALL,0,200,0,
            L"Clicks",L"Shift",NULL},        // Time shift - default to 0 (no change)
        { DMUS_TIMESHIFT_OFFSET, MPT_INT,MP_CAPS_ALL,-200,200,0,
            L"Clicks",L"Random Range",NULL},        // Randmomize - default to 0 (no change)
    };
    InitParams(DMUS_TIMESHIFT_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CTimeShiftTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CTimeShiftTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CTimeShiftTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicTimeShiftTool)
	{
		*ppv = static_cast<IDirectMusicTimeShiftTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CTimeShiftTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicTimeShiftTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CTimeShiftTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CTimeShiftTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_TIMESHIFT_CHUNK))
	{
        DMUS_IO_TIMESHIFT_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_TIMESHIFT_TIMEUNIT,(float) Header.dwTimeUnit);
            SetParam(DMUS_TIMESHIFT_RANGE,(float) Header.dwRange);
            SetParam(DMUS_TIMESHIFT_OFFSET,(float) Header.lOffset);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CTimeShiftTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_TIMESHIFT_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_TIMESHIFT_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_TIMESHIFT_HEADER Header;
        GetParamInt(DMUS_TIMESHIFT_TIMEUNIT,MAX_REF_TIME,(long *) &Header.dwTimeUnit);
        GetParamInt(DMUS_TIMESHIFT_RANGE,MAX_REF_TIME,(long *)&Header.dwRange);
        GetParamInt(DMUS_TIMESHIFT_OFFSET,MAX_REF_TIME,&Header.lOffset);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CTimeShiftTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_TIMESHIFT_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CTimeShiftTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_TimeShiftPage;

	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CTimeShiftTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // Only adjust the timing of notes. 
    if( pPMsg->dwType == DMUS_PMSGT_NOTE ) 
    {
        REFERENCE_TIME rtTime;
        if (m_fMusicTime) rtTime = pPMsg->mtTime;
        else rtTime = pPMsg->rtTime;
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        IDirectMusicPerformance8 *pPerf8;   // We'll need the DX8 interface to access ClonePMsg.
        if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **)&pPerf8)))
        {
            long lOffset;
            DWORD dwRange;
            long lTimeUnit;
            GetParamInt(DMUS_TIMESHIFT_TIMEUNIT,rtTime,&lTimeUnit);
            GetParamInt(DMUS_TIMESHIFT_RANGE,rtTime,(long *)&dwRange);
            GetParamInt(DMUS_TIMESHIFT_OFFSET,rtTime,&lOffset);
            DMUS_TIMESIGNATURE TimeSig;
            if (SUCCEEDED(pPerf8->GetParamEx(GUID_TimeSignature,pNote->dwVirtualTrackID,pNote->dwGroupID,DMUS_SEG_ANYTRACK,pNote->mtTime,NULL,&TimeSig)))
            {
                long lResolution = CToolHelper::TimeUnitToTicks(lTimeUnit,&TimeSig);
                if (lResolution < 1) lResolution = 1;
                if (dwRange)
                {
                    dwRange *= lResolution;
                    pNote->mtTime += (rand() % (dwRange << 1)) - dwRange;
                    pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
                if (lOffset)
                {
                    lOffset *= lResolution;
                    pNote->mtTime += lOffset;
                    pNote->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
            }
            pPerf8->Release();
        }   
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CTimeShiftTool::Clone( IDirectMusicTool ** ppTool)

{
    CTimeShiftTool *pNew = new CTimeShiftTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CTimeShiftTool::SetTimeUnit(DWORD dwTimeUnit) 
{
    return SetParam(DMUS_TIMESHIFT_TIMEUNIT,(float) dwTimeUnit);
}

STDMETHODIMP CTimeShiftTool::SetRange( DWORD dwRange) 
{
    return SetParam(DMUS_TIMESHIFT_RANGE,(float)dwRange);
}

STDMETHODIMP CTimeShiftTool::SetOffset( long lOffset)
{
    return SetParam(DMUS_TIMESHIFT_OFFSET,(float)lOffset);
}

STDMETHODIMP CTimeShiftTool::GetTimeUnit(DWORD * pdwTimeUnit) 
{
    return GetParamInt(DMUS_TIMESHIFT_TIMEUNIT,MAX_REF_TIME,(long *) pdwTimeUnit);
}

STDMETHODIMP CTimeShiftTool::GetRange(DWORD *pdwRange) 
{
    return GetParamInt(DMUS_TIMESHIFT_RANGE,MAX_REF_TIME, (long *) pdwRange);
}

STDMETHODIMP CTimeShiftTool::GetOffset(long *plOffset) 
{
    return GetParamInt(DMUS_TIMESHIFT_OFFSET,MAX_REF_TIME, plOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolhelp.cpp ===
// ToolHelp.cpp : Global functions.
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "toolhelp.h"

long CToolHelper::m_slMIDIToDB[128] = {       // Global array used to convert MIDI to dB. 
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034, 
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710, 
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968, 
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449, 
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050, 
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726, 
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453, 
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217, 
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010, 
    -985, -961, -938, -914, -891, -869, -846, -824, 
    -802, -781, -759, -738, -718, -697, -677, -657, 
    -637, -617, -598, -579, -560, -541, -522, -504, 
    -486, -468, -450, -432, -415, -397, -380, -363, 
    -347, -330, -313, -297, -281, -265, -249, -233, 
    -218, -202, -187, -172, -157, -142, -127, -113, 
    -98, -84, -69, -55, -41, -27, -13, 0
};


long CToolHelper::m_slDBToMIDI[97] = {        // Global array used to convert db to MIDI.
    127, 119, 113, 106, 100, 95, 89, 84, 80, 75, 
    71, 67, 63, 60, 56, 53, 50, 47, 45, 42, 
    40, 37, 35, 33, 31, 30, 28, 26, 25, 23, 
    22, 21, 20, 19, 17, 16, 15, 15, 14, 13, 
    12, 11, 11, 10, 10, 9, 8, 8, 8, 7, 
    7, 6, 6, 6, 5, 5, 5, 4, 4, 4, 
    4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 
    2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0
};

long CToolHelper::m_slResTypes[DMUS_TIME_UNIT_COUNT] = 
{ 1,    // DMUS_TIME_UNIT_MS
  1,    // DMUS_TIME_UNIT_MTIME 
  384,  // DMUS_TIME_UNIT_GRID
  768,  // DMUS_TIME_UNIT_BEAT
  3072, // DMUS_TIME_UNIT_BAR
  32,   // DMUS_TIME_UNIT_64T
  48,   // DMUS_TIME_UNIT_64
  64,   // DMUS_TIME_UNIT_32T  
  96,   // DMUS_TIME_UNIT_32 
  128,  // DMUS_TIME_UNIT_16T     
  192,  // DMUS_TIME_UNIT_16     
  256,  // DMUS_TIME_UNIT_8T    
  384,  // DMUS_TIME_UNIT_8         
  512,  // DMUS_TIME_UNIT_4T  
  768,  // DMUS_TIME_UNIT_4         
  1024, // DMUS_TIME_UNIT_2T   
  1536, // DMUS_TIME_UNIT_2   
  2048, // DMUS_TIME_UNIT_1T
  3072  // DMUS_TIME_UNIT_1
};


BYTE CToolHelper::VolumeToMidi(long lVolume)

{
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = m_slDBToMIDI[lVolume];
    lResult += ((m_slDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

long CToolHelper::MidiToVolume(BYTE bMidi)

{
    if (bMidi > 127) bMidi = 127;
    return m_slMIDIToDB[bMidi];
}

long CToolHelper::TimeUnitToTicks(long lTimeUnit,DMUS_TIMESIGNATURE *pTimeSig) 
{ 
    long lTicks;
    if (lTimeUnit > DMUS_TIME_UNIT_BAR)
    {
        lTicks = m_slResTypes[lTimeUnit];
    }
    else if ((lTimeUnit >= DMUS_TIME_UNIT_GRID) && pTimeSig)
    {
        DWORD dwBeat = (4 * 768) / pTimeSig->bBeat;
        if (lTimeUnit == DMUS_TIME_UNIT_BEAT)
        {
            lTicks = dwBeat;
        }
        else if (lTimeUnit == DMUS_TIME_UNIT_GRID)
        {
            lTicks = (dwBeat / pTimeSig->wGridsPerBeat);
        }
        else 
        {
            lTicks = (dwBeat * pTimeSig->bBeatsPerMeasure);
        }
    }
    else lTicks = 0;
    return lTicks;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\tools.h ===
#ifndef _TOOLS_H_
#define _TOOLS_H_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

/*  Time unit types. This is used by various tools to define the format for units of time. */

#define DMUS_TIME_UNIT_MS        0   /* Milliseconds. */
#define DMUS_TIME_UNIT_MTIME     1   /* Music Time. */
#define DMUS_TIME_UNIT_GRID      2   /* Grid size in current time signature. */
#define DMUS_TIME_UNIT_BEAT      3   /* Beat size in current time signature. */
#define DMUS_TIME_UNIT_BAR       4   /* Measure size in current time signature. */
#define DMUS_TIME_UNIT_64T       5   /* 64th note triplet. */
#define DMUS_TIME_UNIT_64        6   /* 64th note. */
#define DMUS_TIME_UNIT_32T       7   /* 32nd note triplet. */
#define DMUS_TIME_UNIT_32        8   /* 32nd note. */
#define DMUS_TIME_UNIT_16T       9   /* 16th note triplet. */
#define DMUS_TIME_UNIT_16        10  /* 16th note. */
#define DMUS_TIME_UNIT_8T        11  /* 8th note tripplet. */
#define DMUS_TIME_UNIT_8         12  /* 8th note. */
#define DMUS_TIME_UNIT_4T        13  /* Quarter note triplet. */
#define DMUS_TIME_UNIT_4         14  /* Quarter note. */
#define DMUS_TIME_UNIT_2T        15  /* Half note triplet. */
#define DMUS_TIME_UNIT_2         16  /* Half note. */
#define DMUS_TIME_UNIT_1T        17  /* Whole note triplet. */
#define DMUS_TIME_UNIT_1         18  /* Whole note. */

#define DMUS_TIME_UNIT_COUNT     19  /* Number of time unit types. */


interface IDirectMusicEchoTool;
#ifndef __cplusplus 
typedef interface IDirectMusicEchoTool IDirectMusicEchoTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicEchoTool
DECLARE_INTERFACE_(IDirectMusicEchoTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicEchoTool */
    STDMETHOD(SetRepeat)            (THIS_ DWORD dwRepeat) PURE;
    STDMETHOD(SetDecay)             (THIS_ DWORD dwDecay) PURE;
    STDMETHOD(SetTimeUnit)          (THIS_ DWORD dwTimeUnit) PURE;
    STDMETHOD(SetDelay)             (THIS_ DWORD dwDelay) PURE;
    STDMETHOD(SetGroupOffset)       (THIS_ DWORD dwGroupOffset) PURE;
    STDMETHOD(SetType)              (THIS_ DWORD dwType) PURE;

    STDMETHOD(GetRepeat)            (THIS_ DWORD * pdwRepeat) PURE;
    STDMETHOD(GetDecay)             (THIS_ DWORD * pdwDecay) PURE;
    STDMETHOD(GetTimeUnit)          (THIS_ DWORD * pdwTimeUnit) PURE;
    STDMETHOD(GetDelay)             (THIS_ DWORD * pdwDelay) PURE;
    STDMETHOD(GetGroupOffset)       (THIS_ DWORD * pdwGroupOffset) PURE;
    STDMETHOD(GetType)              (THIS_ DWORD * pdwType) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_ECHO_REPEAT        0   /* How many times to repeat. */
#define DMUS_ECHO_DECAY         1   /* Decay, in decibels, between repeats. */
#define DMUS_ECHO_TIMEUNIT      2   /* Time unit used for converting the delay into music time. */
#define DMUS_ECHO_DELAY         3   /* Duration of time between echoes, in music time. */
#define DMUS_ECHO_GROUPOFFSET   4   /* Offset to add to PChannel in multiples of 16 for routing each echo to a separate output Pchannel. */
#define DMUS_ECHO_TYPE          5   /* Type of echo. (See DMUS_ECHOT_ values.) */

#define DMUS_ECHO_PARAMCOUNT    6   /* Number of parameters (above.) */

/*  Echo types. */

#define DMUS_ECHOT_FALLING      0   /* Regular echo, decreases in velocity with each one. */
#define DMUS_ECHOT_FALLING_CLIP 1   /* Regular echo, truncate notes lengths to just under decay time. */
#define DMUS_ECHOT_RISING       2   /* Echo starts quiet, increases to full velocity. */
#define DMUS_ECHOT_RISING_CLIP  3   /* Rising echo, truncate the lengths. */

#define FOURCC_ECHO_CHUNK        mmioFOURCC('e','c','h','o')

typedef struct _DMUS_IO_ECHO_HEADER
{
    DWORD   dwRepeat;       /* How many times to repeat. */
    DWORD   dwDecay;        /* Decay, in decibels, between repeats. */
    DWORD   dwTimeUnit;     /* Time format used for dwDelay. */
    DWORD   dwDelay;        /* Duration of time between echoes, in units defined by dwTimeUnit. */
    DWORD   dwGroupOffset;  /* Offset to add to PChannel for routing each echo. */
    DWORD   dwType;         /* Type of echo. (See DMUS_ECHOT_ values.) */
} DMUS_IO_ECHO_HEADER;

interface IDirectMusicTransposeTool;
#ifndef __cplusplus 
typedef interface IDirectMusicTransposeTool IDirectMusicTransposeTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicTransposeTool
DECLARE_INTERFACE_(IDirectMusicTransposeTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicTransposeTool */
    STDMETHOD(SetTranspose)         (THIS_ long lTranspose) PURE;
    STDMETHOD(SetType)              (THIS_ DWORD dwType) PURE;

    STDMETHOD(GetTranspose)         (THIS_ long * plTranspose) PURE;
    STDMETHOD(GetType)              (THIS_ DWORD * pdwType) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_TRANSPOSE_AMOUNT   0   /* How far up or down to transpose. */
#define DMUS_TRANSPOSE_TYPE     1   /* Transpose style (linear vs in scale.) */

#define DMUS_TRANSPOSE_PARAMCOUNT    2   /* Number of parameters (above.) */

/*  Transposition types. */

#define DMUS_TRANSPOSET_LINEAR  0   /* Transpose in linear increments. */
#define DMUS_TRANSPOSET_SCALE   1   /* Transpose in scale. */

#define FOURCC_TRANSPOSE_CHUNK        mmioFOURCC('t','r','a','n')

typedef struct _DMUS_IO_TRANSPOSE_HEADER
{
    long    lTranspose;     /* Transpose amount. */
    DWORD   dwType;         /* Type of echo. (See DMUS_ECHOT_ values.) */
} DMUS_IO_TRANSPOSE_HEADER;


interface IDirectMusicDurationTool;
#ifndef __cplusplus 
typedef interface IDirectMusicDurationTool IDirectMusicDurationTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicDurationTool
DECLARE_INTERFACE_(IDirectMusicDurationTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDurationTool */
    STDMETHOD(SetScale)             (THIS_ float flScale) PURE;

    STDMETHOD(GetScale)             (THIS_ float * pflScale) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_DURATION_SCALE    0   /* Duration multiplier. */

#define DMUS_DURATION_PARAMCOUNT    1   /* Number of parameters (above.) */

#define FOURCC_DURATION_CHUNK        mmioFOURCC('d','u','r','a')

typedef struct _DMUS_IO_DURATION_HEADER
{
    float   flScale;                /* Duration multiplier. */
} DMUS_IO_DURATION_HEADER;


interface IDirectMusicQuantizeTool;
#ifndef __cplusplus 
typedef interface IDirectMusicQuantizeTool IDirectMusicQuantizeTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicQuantizeTool
DECLARE_INTERFACE_(IDirectMusicQuantizeTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicQuantizeTool */
    STDMETHOD(SetStrength)          (THIS_ DWORD dwStrength) PURE;
    STDMETHOD(SetTimeUnit)          (THIS_ DWORD dwTimeUnit) PURE;
    STDMETHOD(SetResolution)        (THIS_ DWORD dwResolution) PURE;
    STDMETHOD(SetType)              (THIS_ DWORD dwType) PURE;

    STDMETHOD(GetStrength)          (THIS_ DWORD * pdwStrength) PURE;
    STDMETHOD(GetTimeUnit)          (THIS_ DWORD * pdwTimeUnit) PURE;
    STDMETHOD(GetResolution)        (THIS_ DWORD * pdwResolution) PURE;
    STDMETHOD(GetType)              (THIS_ DWORD * pdwType) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_QUANTIZE_STRENGTH    0   /* Strength of quantization (0 to 1.) */
#define DMUS_QUANTIZE_TIMEUNIT    1   /* Unit of time used to calculate resolution. */
#define DMUS_QUANTIZE_RESOLUTION  2   /* Quantization resolution in time format defined by dwTimeUnit. */
#define DMUS_QUANTIZE_TYPE        3   /* Flags for quantize start and/or duration. */

#define DMUS_QUANTIZE_PARAMCOUNT  4   /* Number of parameters (above.) */

/*  Quantize types. */

#define DMUS_QUANTIZET_START      0   /* Quantize just start time. */
#define DMUS_QUANTIZET_LENGTH     1   /* Quantize just duration. */
#define DMUS_QUANTIZET_ALL        2   /* Quantize start and duration. */

#define FOURCC_QUANTIZE_CHUNK        mmioFOURCC('q','u','n','t')

typedef struct _DMUS_IO_QUANTIZE_HEADER
{
    DWORD   dwStrength;               /* Quantize multiplier. */
    DWORD   dwTimeUnit;               /* Unit of time used to calculate resolution. */
    DWORD   dwResolution;             /* Quantization resolution in time format defined by dwTimeUnit. */
    DWORD   dwType;                   /* Flags for quantize start and/or duration. */
} DMUS_IO_QUANTIZE_HEADER;


interface IDirectMusicTimeShiftTool;
#ifndef __cplusplus 
typedef interface IDirectMusicTimeShiftTool IDirectMusicTimeShiftTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicTimeShiftTool
DECLARE_INTERFACE_(IDirectMusicTimeShiftTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicTimeShiftTool */
    STDMETHOD(SetTimeUnit)          (THIS_ DWORD dwTimeUnit) PURE;
    STDMETHOD(SetRange)             (THIS_ DWORD dwRange) PURE;
    STDMETHOD(SetOffset)            (THIS_ long lOffset) PURE;

    STDMETHOD(GetTimeUnit)          (THIS_ DWORD * pdwTimeUnit) PURE;
    STDMETHOD(GetRange)             (THIS_ DWORD * pdwRange) PURE;
    STDMETHOD(GetOffset)            (THIS_ long * plOffset) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_TIMESHIFT_TIMEUNIT    0   /* Units for time offset and random range */
#define DMUS_TIMESHIFT_RANGE       1   /* Range for random time offset */
#define DMUS_TIMESHIFT_OFFSET      2   /* Straight offset to add to the note's time. */

#define DMUS_TIMESHIFT_PARAMCOUNT  3   /* Number of parameters (above.) */

#define FOURCC_TIMESHIFT_CHUNK        mmioFOURCC('t','i','m','s')

typedef struct _DMUS_IO_TIMESHIFT_HEADER
{
    DWORD   dwTimeUnit;            /* Unit of time used to calculate resolution. */
    DWORD   dwRange;               /* Range for random time offset */
    long    lOffset;               /* Straight offset to add to the note's time. */
} DMUS_IO_TIMESHIFT_HEADER;


interface IDirectMusicSwingTool;
#ifndef __cplusplus 
typedef interface IDirectMusicSwingTool IDirectMusicSwingTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicSwingTool
DECLARE_INTERFACE_(IDirectMusicSwingTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSwingTool */
    STDMETHOD(SetStrength)          (THIS_ DWORD dwStrength) PURE;

    STDMETHOD(GetStrength)          (THIS_ DWORD * pdwStrength) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_SWING_STRENGTH    0   /* Strength of swing (0 to 100%) */

#define DMUS_SWING_PARAMCOUNT  1   /* Number of parameters (above.) */

#define FOURCC_SWING_CHUNK        mmioFOURCC('q','u','n','t')

typedef struct _DMUS_IO_SWING_HEADER
{
    DWORD   dwStrength;               /* Swing multiplier. */
} DMUS_IO_SWING_HEADER;

interface IDirectMusicVelocityTool;
#ifndef __cplusplus 
typedef interface IDirectMusicVelocityTool IIDirectMusicVelocityTool;
#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicVelocityTool
DECLARE_INTERFACE_(IDirectMusicVelocityTool, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicVelocityTool */
    STDMETHOD(SetStrength)          (THIS_ long lStrength) PURE;
    STDMETHOD(SetLowLimit)          (THIS_ long lVelocityOut) PURE;
    STDMETHOD(SetHighLimit)         (THIS_ long lVelocityOut) PURE;
    STDMETHOD(SetCurveStart)        (THIS_ long lVelocityIn) PURE;
    STDMETHOD(SetCurveEnd)          (THIS_ long lVelocityIn) PURE;

    STDMETHOD(GetStrength)          (THIS_ long * plStrength) PURE;
    STDMETHOD(GetLowLimit)          (THIS_ long * plVelocityOut) PURE;
    STDMETHOD(GetHighLimit)         (THIS_ long * plVelocityOut) PURE;
    STDMETHOD(GetCurveStart)        (THIS_ long * plVelocityIn) PURE;
    STDMETHOD(GetCurveEnd)          (THIS_ long * plVelocityIn) PURE;
};

/*  IMediaParams parameter control */

#define DMUS_VELOCITY_STRENGTH    0   /* Strength of velocity modifier (0 to 100%) */
#define DMUS_VELOCITY_LOWLIMIT    1   /* Minimum value for output velocity */
#define DMUS_VELOCITY_HIGHLIMIT   2   /* Maximum value for output velocity */
#define DMUS_VELOCITY_CURVESTART  3   /* Velocity curve starts at low limit and this input velocity */
#define DMUS_VELOCITY_CURVEEND    4   /* Velocity curve ends at this input velocity and high limit */

#define DMUS_VELOCITY_PARAMCOUNT  5   /* Number of parameters (above.) */

#define FOURCC_VELOCITY_CHUNK        mmioFOURCC('v','e','l','o')

typedef struct _DMUS_IO_VELOCITY_HEADER
{
    long    lStrength;                /* Strength of transformation. */
    long    lLowLimit;                /* Minimum value for output velocity */
    long    lHighLimit;               /* Maximum value for output velocity */
    long    lCurveStart;              /* Velocity curve starts at low limit and this input velocity */
    long    lCurveEnd;                /* Velocity curve ends at this input velocity and high limit */
} DMUS_IO_VELOCITY_HEADER;


/* Class IDs for tools. */

DEFINE_GUID(CLSID_DirectMusicEchoTool, 0x64e49fa4, 0xbacf, 0x11d2, 0x87, 0x2c, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTransposeTool, 0xbb8d0702, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicSwingTool, 0xbb8d0703, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicQuantizeTool, 0xbb8d0704, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicVelocityTool, 0xbb8d0705, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicDurationTool, 0xbb8d0706, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicTimeShiftTool, 0xbb8d0707, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicMuteTool, 0xbb8d0708, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(CLSID_DirectMusicChordSequenceTool, 0xbb8d0709, 0x9c43, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);



/* Interface IDs for tools. */

DEFINE_GUID(IID_IDirectMusicEchoTool, 0x81f60d22, 0x9d10, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);
DEFINE_GUID(IID_IDirectMusicTransposeTool,0x173803f4, 0x4fd5, 0x4ba1, 0x9e, 0x50, 0xdd, 0x5f, 0x56, 0x69, 0xd2, 0x25);
DEFINE_GUID(IID_IDirectMusicDurationTool,0xc6897cfb, 0x9a43, 0x420f, 0xb6, 0xdb, 0xdd, 0x32, 0xc1, 0x82, 0xe8, 0x33);
DEFINE_GUID(IID_IDirectMusicQuantizeTool,0x652e5667, 0x210d, 0x4d06, 0x83, 0x2a, 0xbc, 0x17, 0x92, 0x7e, 0x51, 0x42);
DEFINE_GUID(IID_IDirectMusicTimeShiftTool,0xc39abaf0, 0xc4f0, 0x4c6b, 0x83, 0x4a, 0xcf, 0x21, 0x7c, 0xbe, 0x95, 0x6d);
DEFINE_GUID(IID_IDirectMusicSwingTool,0xd876ffee, 0x3a6f, 0x43db, 0xa3, 0x5c, 0x68, 0x7b, 0x38, 0x6a, 0x71, 0x65);
DEFINE_GUID(IID_IDirectMusicVelocityTool,0xb15eb722, 0xfb50, 0x4e1f, 0xb2, 0x1, 0xa6, 0x99, 0xe0, 0x47, 0x79, 0x54);
DEFINE_GUID(IID_IDirectMusicMuteTool,0x20cc9511, 0x5802, 0x49a0, 0xba, 0x91, 0x8b, 0x29, 0xb0, 0xf7, 0x22, 0xab);
DEFINE_GUID(IID_IDirectMusicChordSequenceTool,0xc32c1b34, 0xe604, 0x48c1, 0xba, 0x8c, 0x7b, 0x50, 0x10, 0x17, 0xbd, 0x68);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif // _TOOLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\transpose.h ===
#ifndef _TRANSPOSE_TOOL_
#define _TRANSPOSE_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CTransposeTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicTransposeTool

{
public:
	CTransposeTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    virtual STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);
    
// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicTransposeTool
	STDMETHODIMP SetTranspose(long lTranspose) ;
	STDMETHODIMP SetType(DWORD dwType) ;
	STDMETHODIMP GetTranspose(long * plTranspose) ;
	STDMETHODIMP GetType(DWORD * pdwType) ;
private:
    static DMUS_CHORD_KEY m_gDefaultChord;
};

#endif // _TRANSPOSE_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\transpose.cpp ===
// Transpose.cpp : Implementation of CTransposeTool
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "transpose.h"
#include "toolhelp.h"

// We keep a default chord of C7 in the scale of C, in case there is no chord track
// at the time an in scale transposition is requested.

DMUS_CHORD_KEY CTransposeTool::m_gDefaultChord;

CTransposeTool::CTransposeTool()
{
    ParamInfo Params[DMUS_TRANSPOSE_PARAMCOUNT] = 
    {
        { DMUS_TRANSPOSE_AMOUNT, MPT_INT,MP_CAPS_ALL,-24,24,0,
            L"Intervals",L"Transpose",NULL},        // Tranpose - none by default
        { DMUS_TRANSPOSE_TYPE, MPT_ENUM,MP_CAPS_ALL,
            DMUS_TRANSPOSET_LINEAR,DMUS_TRANSPOSET_SCALE,DMUS_TRANSPOSET_SCALE,
            L"",L"Type",L"Linear,In Scale"} // Type - transpose in scale by default
    };
    InitParams(DMUS_TRANSPOSE_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
    wcscpy(m_gDefaultChord.wszName, L"M7");
    m_gDefaultChord.wMeasure = 0;
    m_gDefaultChord.bBeat = 0;
    m_gDefaultChord.bSubChordCount = 1;
    m_gDefaultChord.bKey = 12;
    m_gDefaultChord.dwScale = 0xab5ab5; // default scale is C Major
    m_gDefaultChord.bFlags = 0;
    for (int n = 0; n < DMUS_MAXSUBCHORD; n++)
    {
        m_gDefaultChord.SubChordList[n].dwChordPattern = 0x891; // default chord is major 7
        m_gDefaultChord.SubChordList[n].dwScalePattern = 0xab5ab5; // default scale is C Major
        m_gDefaultChord.SubChordList[n].dwInversionPoints = 0xffffff;
        m_gDefaultChord.SubChordList[n].dwLevels = 0xffffffff;
        m_gDefaultChord.SubChordList[n].bChordRoot = 12; // 2C
        m_gDefaultChord.SubChordList[n].bScaleRoot = 0;
    }
}

STDMETHODIMP_(ULONG) CTransposeTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CTransposeTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CTransposeTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicTransposeTool)
	{
		*ppv = static_cast<IDirectMusicTransposeTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CTransposeTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicTransposeTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CTransposeTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CTransposeTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_TRANSPOSE_CHUNK))
	{
        DMUS_IO_TRANSPOSE_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_TRANSPOSE_AMOUNT,(float) Header.lTranspose);
            SetParam(DMUS_TRANSPOSE_TYPE,(float) Header.dwType);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CTransposeTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_TRANSPOSE_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_TRANSPOSE_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_TRANSPOSE_HEADER Header;
        GetParamInt(DMUS_TRANSPOSE_AMOUNT,MAX_REF_TIME,(long *) &Header.lTranspose);
        GetParamInt(DMUS_TRANSPOSE_TYPE,MAX_REF_TIME,(long *) &Header.dwType);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CTransposeTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_TRANSPOSE_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CTransposeTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_TransposePage;
	return NOERROR;
}

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CTransposeTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // Only transpose notes that are not on the drum pChannel.
    if( (pPMsg->dwType == DMUS_PMSGT_NOTE ) && ((pPMsg->dwPChannel & 0xF) != 0x9))
    {
        // We need to know the time format so we can call GetParamInt() to read control parameters.
        REFERENCE_TIME rtTime;
        if (m_fMusicTime) rtTime = pPMsg->mtTime;
        else rtTime = pPMsg->rtTime;
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        long lTranspose, lType;
        long lNote = pNote->bMidiValue;
        
        GetParamInt(DMUS_TRANSPOSE_AMOUNT,rtTime,&lTranspose);
        GetParamInt(DMUS_TRANSPOSE_TYPE,rtTime,&lType);
        if (lType == DMUS_TRANSPOSET_LINEAR)
        {
            lNote += lTranspose;
            while (lNote < 0) lNote += 12;
            while (lNote > 127) lNote -= 12;
            pNote->bMidiValue = (BYTE) lNote;
        }
        else
        {
            IDirectMusicPerformance8 *pPerf8;
            if (SUCCEEDED(pPerf->QueryInterface(IID_IDirectMusicPerformance8,(void **) &pPerf8)))
            {
                DMUS_CHORD_KEY Chord;
                DMUS_CHORD_KEY *pChord = &Chord;
                if (FAILED(pPerf8->GetParamEx(GUID_ChordParam,pNote->dwVirtualTrackID,
                                   pNote->dwGroupID,0,pNote->mtTime - pNote->nOffset, NULL, pChord)))
                {
                    // Couldn't find an active scale, use major scale instead.
                    pChord = &m_gDefaultChord;
                }
                WORD wVal;
                // First, use the current chord & scale to convert the note's midi value into scale position.
                if (SUCCEEDED(pPerf->MIDIToMusic(pNote->bMidiValue ,pChord,DMUS_PLAYMODE_PEDALPOINT,pNote->bSubChordLevel,&wVal)))
                {
                    // Scale position is octave position * 7 plus chord position * 2 plus the scale position.
                    long lScalePosition = (((wVal & 0xF000) >> 12) * 7) + (((wVal & 0xF00) >> 8) * 2) + ((wVal & 0xF0) >> 4);
                    // Now that we are looking at scale position, we can add the transposition.
                    lScalePosition += lTranspose;
                    // Make sure we don't wrap around.
                    while (lScalePosition < 0) lScalePosition += 7;
                    // A high MIDI value of 127 translates to scale position 74.
                    while (lScalePosition > 74) lScalePosition -= 7;
                    wVal &= 0x000F; // Keep only the accidental. 
                    // Now, insert the values back in. Start with chord.
                    wVal |= ((lScalePosition / 7) << 12);
                    // Then, scale position.
                    wVal |= ((lScalePosition % 7) << 4);
                    pPerf->MusicToMIDI(wVal,pChord,DMUS_PLAYMODE_PEDALPOINT,
                        pNote->bSubChordLevel,&pNote->bMidiValue);
                }
                pPerf8->Release();
            }
        }
    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CTransposeTool::Clone( IDirectMusicTool ** ppTool)

{
    CTransposeTool *pNew = new CTransposeTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CTransposeTool::SetTranspose(long lTranpose) 
{
    return SetParam(DMUS_TRANSPOSE_AMOUNT,(float) lTranpose);
}

STDMETHODIMP CTransposeTool::SetType(DWORD dwType) 
{
    return SetParam(DMUS_TRANSPOSE_TYPE,(float) dwType);
}

#define MAX_REF_TIME    0x7FFFFFFFFFFFFFFF

STDMETHODIMP CTransposeTool::GetTranspose(long * plTranspose) 
{
    return GetParamInt(DMUS_TRANSPOSE_AMOUNT,MAX_REF_TIME, plTranspose);
}

STDMETHODIMP CTransposeTool::GetType(DWORD * pdwType) 
{
    return GetParamInt(DMUS_TRANSPOSE_TYPE,MAX_REF_TIME,(long *) pdwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolhelp.h ===
#ifndef _TOOL_HELP_
#define _TOOL_HELP_

#include "dmusici.h"
#include "tools.h"

// Global class that provides various useful methods.

class CToolHelper 
{
public:
    BYTE VolumeToMidi(long lVolume);
    long MidiToVolume(BYTE bMidi);
    long TimeUnitToTicks(long lTimeUnit,DMUS_TIMESIGNATURE *pTimeSig);
private:
    static long m_slMIDIToDB[128];   // Array for converting MIDI to centibel volume.
    static long m_slDBToMIDI[97];    // For converting volume to MIDI.
    static long m_slResTypes[DMUS_TIME_UNIT_COUNT]; // Array for converting time units into ticks.
};

class CMusicVal
{
public:
    CMusicVal(WORD wMusicVal);
    WORD GetValue();
	void operator+=(CMusicVal Val);
    void operator+=(short nScale);  // Most common transposition would be by scale.
	void operator-=(CMusicVal Val);
	CMusicVal operator+(CMusicVal Val) const;
	CMusicVal operator-(CMusicVal Val) const;
private:
    void CleanUp();
    short       m_sOctave;
    short       m_sChord;
    short       m_sScale;
    short       m_sAccidental;
};

/*inline void CMusicVal::operator +

inline void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
_AFXWIN_INLINE void CPoint::operator+=(POINT point)
	{ x += point.x; y += point.y; }
_AFXWIN_INLINE void CPoint::operator-=(POINT point)
	{ x -= point.x; y -= point.y; }
_AFXWIN_INLINE CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
_AFXWIN_INLINE CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
*/
inline CMusicVal::CMusicVal(WORD wMusicVal)

{
    m_sAccidental = wMusicVal & 0xF;
    if (wMusicVal & 0x8) // Negative?
    {
        m_sAccidental |= 0xFFF0;    // Yes, extend sign bit.
    }
    m_sScale = (wMusicVal & 0xF0) >> 4;
    m_sChord = (wMusicVal & 0xF00) >> 8;
    m_sOctave = wMusicVal >> 12;
    if (m_sOctave > 14) // We count the top two octaves as negative.
    {
        m_sOctave -= 16;
    }
}

inline WORD CMusicVal::GetValue()

{
    CleanUp();
    return (WORD) ((m_sOctave << 12) | (m_sChord << 8) | (m_sScale << 4) | (m_sAccidental & 0xF));
}

inline void CMusicVal::CleanUp()

{
    while (m_sAccidental < -8)
    {
        // This should never happen, but it does, do approximate math.
        m_sAccidental += 2;
        m_sScale -= 1;
    }
    while (m_sAccidental > 7)
    {
        // Likewise, this should not happen, so resulting math isn't perfect.
        m_sAccidental -= 2;
        m_sScale += 1;
    }
    while (m_sScale < 0)
    {
        m_sScale += 2;
        m_sChord -= 1;
    }
    while (m_sScale > 7)
    {
        m_sScale -= 2;
        m_sChord += 1;
    }
    while (m_sChord < 0)
    {
        m_sChord += 4;
        m_sOctave -= 1;
    }
    while (m_sChord > 4)
    {
        m_sChord -= 4;
        m_sOctave += 1;
    }
    while (m_sOctave < -2)
    {
        m_sOctave++;
    }
    while (m_sOctave >= 14)
    {
        m_sOctave--;
    }
}

inline void CMusicVal::operator+=(CMusicVal Val)

{ 
    m_sOctave += Val.m_sOctave;
    m_sChord += Val.m_sChord;
    m_sScale += Val.m_sScale;
    m_sAccidental  += Val.m_sAccidental;
}

inline void CMusicVal::operator+=(short nScale)

{ 
    m_sScale += nScale;
}


#endif // _TOOL_HELP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\durationpage.cpp ===
// DurationPage.cpp : Implementation of CDurationPage
#include "stdafx.h"
#include "ToolProps.h"
#include "DurationPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDurationPage

CDurationPage::CDurationPage() 
{
	m_dwTitleID = IDS_TITLEDurationPage;
	m_dwHelpFileID = IDS_HELPFILEDurationPage;
	m_dwDocStringID = IDS_DOCSTRINGDurationPage;
    m_pDuration = NULL;
}

CDurationPage::~CDurationPage()

{
    if (m_pDuration)
    {
        m_pDuration->Release();
    }
}

STDMETHODIMP CDurationPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicDurationTool,(void **) &m_pDuration);
}


STDMETHODIMP CDurationPage::Apply(void)

{
    m_pDuration->SetScale(m_ctScale.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CDurationPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pDuration)
    {
        m_ctScale.Init(GetDlgItem(IDC_SCALE),GetDlgItem(IDC_SCALE_DISPLAY),0,2.0,false);

        float fScale;
        m_pDuration->GetScale(&fScale);
        m_ctScale.SetValue(fScale);
    }
	return 1;
}

LRESULT CDurationPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctScale.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CDurationPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctScale.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\durationpage.h ===
// DurationPage.h : Declaration of the CDurationPage

#ifndef __DURATIONPAGE_H_
#define __DURATIONPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DurationPage;

/////////////////////////////////////////////////////////////////////////////
// CDurationPage
class ATL_NO_VTABLE CDurationPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDurationPage, &CLSID_DurationPage>,
	public IPropertyPageImpl<CDurationPage>,
	public CDialogImpl<CDurationPage>
{
public:
	CDurationPage();
    virtual ~CDurationPage();

	enum {IDD = IDD_DURATIONPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DURATIONPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDurationPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDurationPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CDurationPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicDurationTool *  m_pDuration;
    CSliderValue                m_ctScale;
};

#endif //__DURATIONPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\controlhelp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CSliderValue.
//

#include "stdafx.h"
#include "ControlHelp.h"
#include <commctrl.h>

//////////////////////////////////////////////////////////////////////////////
// CSliderValue

const short g_sMaxContinuousTicks = 100;
const int g_iMaxCharBuffer = 50; // # characters big enough to hold -FLT_MAX with room to spare

CSliderValue::CSliderValue()
  : m_fInit(false)
{
}

void CSliderValue::SetRange(float fMin, float fMax)

{
    if (m_fInit)
    {
        m_fMin = fMin;
        m_fMax = fMax;

        short sMin;
        short sMax;
        short sTicks = 4; // Lots of ticks become less useful as guides.  Use quarters for fine-grained sliders.
        if (m_fDiscrete) 
        {
            sMin = static_cast<short>(fMin);
            sMax = static_cast<short>(fMax);
            if (sMax - sMin <= 10)
                sTicks = sMax - sMin;
        }
        else
        {
            sMin = 0;
            sMax = g_sMaxContinuousTicks;
        }
    
        SendMessage(m_hwndSlider, TBM_SETRANGE, TRUE, MAKELONG(sMin, sMax));
        SendMessage(m_hwndSlider, TBM_SETTICFREQ, (sMax - sMin) / sTicks, 0);
    }
}

void CSliderValue::Init(
        HWND        hwndSlider,
        HWND        hwndEdit,
        float       fMin, 
        float       fMax, 
        bool        fDiscrete)
{
    if (m_fInit)
        return;

    m_hwndSlider = hwndSlider;
    m_hwndEdit = hwndEdit;
    m_fDiscrete = fDiscrete;
    m_fInit = true;
    SetRange(fMin,fMax);
}

void CSliderValue::SetValue(float fPos)
{
    if (!m_fInit)
        return;

    UpdateEditBox(fPos);
    UpdateSlider();
}

float CSliderValue::GetValue()
{
    if (!m_fInit)
        return 0;

    LRESULT lrLen = SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);
    if (lrLen >= g_iMaxCharBuffer)
        return 0;

    char szText[g_iMaxCharBuffer] = "";
    SendMessage(m_hwndEdit, WM_GETTEXT, g_iMaxCharBuffer, reinterpret_cast<LPARAM>(szText));

    float fVal = static_cast<float>(m_fDiscrete ? atoi(szText) : atof(szText));

    if (fVal < m_fMin) fVal = m_fMin;
    if (fVal > m_fMax) fVal = m_fMax;
    return fVal;
}

float CSliderValue::GetSliderValue()
{
    short sPos = static_cast<short>(SendMessage(m_hwndSlider, TBM_GETPOS, 0, 0));
    if (m_fDiscrete)
    {
        return sPos;
    }

    float fRet = (m_fMax - m_fMin) * sPos / g_sMaxContinuousTicks + m_fMin;
    return fRet;
}

LRESULT CSliderValue::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    switch (uMsg)
    {
    case WM_HSCROLL:
        if (bHandled = (reinterpret_cast<HWND>(lParam) == m_hwndSlider && LOWORD(wParam) >= TB_LINEUP && LOWORD(wParam) <= TB_ENDTRACK))
            UpdateEditBox(GetSliderValue());
        break;

    case WM_COMMAND:
        if (bHandled = (HIWORD(wParam) == EN_KILLFOCUS && reinterpret_cast<HWND>(lParam) == m_hwndEdit))
            UpdateSlider();
        break;

    default:
        bHandled = FALSE;
        break;
    }

    return 0;
}

void CSliderValue::UpdateEditBox(float fPos)
{
    char szText[g_iMaxCharBuffer] = "";

    if (m_fDiscrete)
    {
        short sPos = static_cast<short>(fPos);
        sprintf(szText, "%hd", sPos);
    }
    else
    {
        sprintf(szText, "%.3hf", fPos);
    }

    SendMessage(m_hwndEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(szText));
}

void CSliderValue::UpdateSlider()
{
    float fVal = GetValue();
    short sPos = static_cast<short>(m_fDiscrete ? fVal : g_sMaxContinuousTicks * ((fVal - m_fMin) / (m_fMax - m_fMin)));
    SendMessage(m_hwndSlider, TBM_SETPOS, TRUE, sPos);
    UpdateEditBox(fVal); // this resets the input box back to the set float value in case the input was invalid
}

CComboHelp::CComboHelp()
{
    m_hwndCombo = NULL;
    m_fInit = FALSE;
}

void CComboHelp::Init(HWND hwndCombo, int nID, char *pStrings[], DWORD cbStrings)
{
    DWORD dwIndex;
    m_hwndCombo = hwndCombo;
    m_nID = nID;
    for (dwIndex = 0; dwIndex < cbStrings; dwIndex++)
    {
        SendMessage( hwndCombo,CB_ADDSTRING,0,(LPARAM)pStrings[dwIndex]);
    }
    m_fInit = TRUE;
}

void CComboHelp::SetValue(DWORD dwValue)
{
    SendMessage(m_hwndCombo,CB_SETCURSEL,dwValue,0);
}

DWORD CComboHelp::GetValue()
{
    return SendMessage( m_hwndCombo,CB_GETCURSEL,0,0);
}

LRESULT CComboHelp::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    switch (uMsg)
    {
    case WM_COMMAND:
        bHandled = ((HIWORD(wParam) == CBN_SELCHANGE) && (LOWORD(wParam) == m_nID));
        break;
    default:
        bHandled = FALSE;
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\velocity.h ===
#ifndef _VELOCITY_TOOL_
#define _VELOCITY_TOOL_

#include "basetool.h"
#include "tools.h"
#include "param.h"
#include "toolhelp.h"
#include "..\dmtoolprp\toolprops.h"

class CVelocityTool : 
    public CBaseTool , 
    public CParamsManager, 
    public CToolHelper, 
    public IPersistStream, 
    public ISpecifyPropertyPages,
    public IDirectMusicVelocityTool

{
public:
	CVelocityTool();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv) ;
    STDMETHODIMP_(ULONG) AddRef() ;
    STDMETHODIMP_(ULONG) Release() ;

// IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID);

// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

// ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

// IDirectMusicTool
//	STDMETHODIMP Init(IDirectMusicGraph* pGraph) ;
//	STDMETHODIMP GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
//	STDMETHODIMP GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
//	STDMETHODIMP GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
//	STDMETHODIMP Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;

// IDirectMusicTool8
    STDMETHODIMP Clone( IDirectMusicTool ** ppTool) ;

// IDirectMusicVelocityTool
	STDMETHODIMP SetStrength(long lStrength) ;
    STDMETHODIMP SetLowLimit(long lVelocityOut) ;
    STDMETHODIMP SetHighLimit(long lVelocityOut) ;
    STDMETHODIMP SetCurveStart(long lVelocityIn) ;
    STDMETHODIMP SetCurveEnd(long lVelocityIn) ;

	STDMETHODIMP GetStrength(long * plStrength) ;
    STDMETHODIMP GetLowLimit(long * plVelocityOut) ;
    STDMETHODIMP GetHighLimit(long * plVelocityOut) ;
    STDMETHODIMP GetCurveStart(long * plVelocityIn) ;
    STDMETHODIMP GetCurveEnd(long * plVelocityIn) ;

protected:	
};

#endif // _VELOCITY_TOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\controlhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CSliderValue.
//

#pragma once

class CSliderValue
{
public:
    CSliderValue();
    void Init(HWND hwndSlider, HWND hwndEdit, float fMin, float fMax, bool fDiscrete);
    void SetRange(float fMin, float fMax);
    void SetValue(float fPos);
    float GetValue();

    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    bool                m_fInit;
    HWND                m_hwndSlider;
    HWND                m_hwndEdit;
    float               m_fMin;
    float               m_fMax;
    bool                m_fDiscrete;

private:
    float GetSliderValue();
    void UpdateEditBox(float fPos);
    void UpdateSlider();
};

class CComboHelp
{
public:
    CComboHelp();
    void Init(HWND hwndCombo, int nID, char *pStrings[], DWORD cbStrings);
    void SetValue(DWORD dwValue);
    DWORD GetValue();
    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
private:
    bool                m_fInit;
    int                 m_nID;
    HWND                m_hwndCombo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\velocity.cpp ===
// Velocity.cpp : Implementation of CVelocityTool
//
// Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved
//

#include "dmusicc.h"
#include "dmusici.h"
#include "debug.h"
#include "velocity.h"
#include "toolhelp.h"

CVelocityTool::CVelocityTool()
{
    ParamInfo Params[DMUS_VELOCITY_PARAMCOUNT] = 
    {
        { DMUS_VELOCITY_STRENGTH, MPT_INT,MP_CAPS_ALL,0,100,100,
            L"Percent",L"Strength",NULL },            // Strength - 100% by default
        { DMUS_VELOCITY_LOWLIMIT, MPT_INT,MP_CAPS_ALL,1,127,1,
            L"Velocity",L"Lower Limit",NULL },        // Lower limit - 1 by default
        { DMUS_VELOCITY_HIGHLIMIT, MPT_INT,MP_CAPS_ALL,1,127,127,
            L"Velocity",L"Upper Limit",NULL },        // Upper limit - 127 by default
        { DMUS_VELOCITY_CURVESTART, MPT_INT,MP_CAPS_ALL,1,127,1,
            L"Velocity",L"Curve Start",NULL },        // Curve start - 1 by default
        { DMUS_VELOCITY_CURVEEND, MPT_INT,MP_CAPS_ALL,1,127,127,
            L"Velocity",L"Curve End",NULL },          // Curve End - 127 by default
    };
    InitParams(DMUS_VELOCITY_PARAMCOUNT,Params);
    m_fMusicTime = TRUE;        // override default setting.
}

STDMETHODIMP_(ULONG) CVelocityTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CVelocityTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CVelocityTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool || iid == IID_IDirectMusicTool8)
    {
        *ppv = static_cast<IDirectMusicTool8*>(this);
    } 
	else if(iid == IID_IPersistStream)
	{
		*ppv = static_cast<IPersistStream*>(this);
	}
    else if(iid == IID_IDirectMusicVelocityTool)
	{
		*ppv = static_cast<IDirectMusicVelocityTool*>(this);
	}
    else if(iid == IID_IMediaParams)
	{
		*ppv = static_cast<IMediaParams*>(this);
	}
    else if(iid == IID_IMediaParamInfo)
	{
		*ppv = static_cast<IMediaParamInfo*>(this);
	}
    else if(iid == IID_ISpecifyPropertyPages)
	{
		*ppv = static_cast<ISpecifyPropertyPages*>(this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

STDMETHODIMP CVelocityTool::GetClassID(CLSID* pClassID) 

{
    if (pClassID)
    {
	    *pClassID = CLSID_DirectMusicVelocityTool;
	    return S_OK;
    }
    return E_POINTER;
}


//////////////////////////////////////////////////////////////////////
// IPersistStream Methods:

STDMETHODIMP CVelocityTool::IsDirty() 

{
    if (m_fDirty) return S_OK;
    else return S_FALSE;
}


STDMETHODIMP CVelocityTool::Load(IStream* pStream)
{
	EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID;
    DWORD dwSize;

	HRESULT hr = pStream->Read(&dwChunkID, sizeof(dwChunkID), NULL);
	hr = pStream->Read(&dwSize, sizeof(dwSize), NULL);

	if(SUCCEEDED(hr) && (dwChunkID == FOURCC_VELOCITY_CHUNK))
	{
        DMUS_IO_VELOCITY_HEADER Header;
        memset(&Header,0,sizeof(Header));
		hr = pStream->Read(&Header, min(sizeof(Header),dwSize), NULL);
        if (SUCCEEDED(hr))
        {
            SetParam(DMUS_VELOCITY_STRENGTH,(float) Header.lStrength);
            SetParam(DMUS_VELOCITY_LOWLIMIT,(float) Header.lLowLimit);
            SetParam(DMUS_VELOCITY_HIGHLIMIT,(float) Header.lHighLimit);
            SetParam(DMUS_VELOCITY_CURVESTART,(float) Header.lCurveStart);
            SetParam(DMUS_VELOCITY_CURVEEND,(float) Header.lCurveEnd);
        }
    }
    m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);

	return hr;
}

STDMETHODIMP CVelocityTool::Save(IStream* pStream, BOOL fClearDirty) 

{
    EnterCriticalSection(&m_CrSec);
	DWORD dwChunkID = FOURCC_VELOCITY_CHUNK;
    DWORD dwSize = sizeof(DMUS_IO_VELOCITY_HEADER);

	HRESULT hr = pStream->Write(&dwChunkID, sizeof(dwChunkID), NULL);
    if (SUCCEEDED(hr))
    {
	    hr = pStream->Write(&dwSize, sizeof(dwSize), NULL);
    }
    if (SUCCEEDED(hr))
    {
        DMUS_IO_VELOCITY_HEADER Header;
        GetParamInt(DMUS_VELOCITY_STRENGTH,MAX_REF_TIME,&Header.lStrength);
        GetParamInt(DMUS_VELOCITY_LOWLIMIT,MAX_REF_TIME,&Header.lLowLimit);
        GetParamInt(DMUS_VELOCITY_HIGHLIMIT,MAX_REF_TIME,&Header.lHighLimit);
        GetParamInt(DMUS_VELOCITY_CURVESTART,MAX_REF_TIME,&Header.lCurveStart);
        GetParamInt(DMUS_VELOCITY_CURVEEND,MAX_REF_TIME,&Header.lCurveEnd);
		hr = pStream->Write(&Header, sizeof(Header),NULL);
    }
    if (fClearDirty) m_fDirty = FALSE;
	LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CVelocityTool::GetSizeMax(ULARGE_INTEGER* pcbSize) 

{
    if (pcbSize == NULL)
    {
        return E_POINTER;
    }
    pcbSize->QuadPart = sizeof(DMUS_IO_VELOCITY_HEADER) + 8; // Data plus RIFF header.
    return S_OK;
}

STDMETHODIMP CVelocityTool::GetPages(CAUUID * pPages)

{
	pPages->cElems = 1;
	pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
	if (pPages->pElems == NULL)
	    return E_OUTOFMEMORY;

	*(pPages->pElems) = CLSID_VelocityPage;
	return NOERROR;
}


/////////////////////////////////////////////////////////////////
// IDirectMusicTool

STDMETHODIMP CVelocityTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
    // returning S_FREE frees the message. If StampPMsg()
    // fails, there is no destination for this message so
    // free it.
    if(NULL == pPMsg->pGraph )
    {
        return DMUS_S_FREE;
    }
    if (FAILED(pPMsg->pGraph->StampPMsg(pPMsg))) 
    {
        return DMUS_S_FREE;
    }
    // We need to know the time format so we can call GetParamInt() to read control parameters.
    REFERENCE_TIME rtTime;
    if (m_fMusicTime) rtTime = pPMsg->mtTime;
    else rtTime = pPMsg->rtTime;
    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG *pNote = (DMUS_NOTE_PMSG *) pPMsg;
        long lStrength;
        long lLowLimit, lHighLimit, lCurveStart, lCurveEnd;
        GetParamInt(DMUS_VELOCITY_STRENGTH,rtTime,&lStrength);
        GetParamInt(DMUS_VELOCITY_LOWLIMIT,rtTime,&lLowLimit);
        GetParamInt(DMUS_VELOCITY_HIGHLIMIT,rtTime,&lHighLimit);
        GetParamInt(DMUS_VELOCITY_CURVESTART,rtTime,&lCurveStart);
        GetParamInt(DMUS_VELOCITY_CURVEEND,rtTime,&lCurveEnd);
        if (lCurveStart <= lCurveEnd)
        {
            long lNewVelocity;
            if (pNote->bVelocity <= lCurveStart)
            {
                lNewVelocity = lLowLimit;
            }
            else if (pNote->bVelocity >= lCurveEnd)
            {
                lNewVelocity = lHighLimit;
            }
            else
            {
                // For this case, compute the point on the line between (lCurveStart, lLowLimit) and (lCurveEnd, lHighLimit)
                lNewVelocity = lLowLimit + ((lHighLimit - lLowLimit) * (pNote->bVelocity - lCurveStart)) / (lCurveEnd - lCurveStart);
            }
            // Now, calculate the change we want to apply.
            lNewVelocity -= pNote->bVelocity;
            // Scale it to the amount we'll actually do.
            lNewVelocity = (lNewVelocity * lStrength) / 100;
            lNewVelocity += pNote->bVelocity;
            if (lNewVelocity < 1) lNewVelocity = 1;
            if (lNewVelocity > 127) lNewVelocity = 127;
            pNote->bVelocity = (BYTE) lNewVelocity;
        }

    }
    return DMUS_S_REQUEUE;
}

STDMETHODIMP CVelocityTool::Clone( IDirectMusicTool ** ppTool)

{
    CVelocityTool *pNew = new CVelocityTool;
    if (pNew)
    {
        HRESULT hr = pNew->CopyParamsFromSource(this);
        if (SUCCEEDED(hr))
        {
            *ppTool = (IDirectMusicTool *) pNew;
        }
        else
        {
            delete pNew;
        }
        return hr;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CVelocityTool::SetStrength(long lStrength) 
{
    return SetParam(DMUS_VELOCITY_STRENGTH,(float) lStrength);
}

STDMETHODIMP CVelocityTool::SetLowLimit(long lVelocityOut)
{
    return SetParam(DMUS_VELOCITY_LOWLIMIT,(float) lVelocityOut);
}

STDMETHODIMP CVelocityTool::SetHighLimit(long lVelocityOut)
{
    return SetParam(DMUS_VELOCITY_HIGHLIMIT,(float) lVelocityOut);
}

STDMETHODIMP CVelocityTool::SetCurveStart(long lVelocityIn)
{
    return SetParam(DMUS_VELOCITY_CURVESTART,(float) lVelocityIn);
}

STDMETHODIMP CVelocityTool::SetCurveEnd(long lVelocityIn)
{
    return SetParam(DMUS_VELOCITY_CURVEEND,(float) lVelocityIn);
}

STDMETHODIMP CVelocityTool::GetStrength(long * plStrength) 
{
    return GetParamInt(DMUS_VELOCITY_STRENGTH,MAX_REF_TIME,plStrength);
}

STDMETHODIMP CVelocityTool::GetLowLimit(long * plVelocityOut) 
{
    return GetParamInt(DMUS_VELOCITY_LOWLIMIT,MAX_REF_TIME,plVelocityOut);
}

STDMETHODIMP CVelocityTool::GetHighLimit(long * plVelocityOut) 
{
    return GetParamInt(DMUS_VELOCITY_HIGHLIMIT,MAX_REF_TIME,plVelocityOut);
}

STDMETHODIMP CVelocityTool::GetCurveStart(long * plVelocityIn) 
{
    return GetParamInt(DMUS_VELOCITY_CURVESTART,MAX_REF_TIME,plVelocityIn);
}

STDMETHODIMP CVelocityTool::GetCurveEnd(long * plVelocityIn) 
{
    return GetParamInt(DMUS_VELOCITY_CURVEEND,MAX_REF_TIME,plVelocityIn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\echopage.cpp ===
// EchoPage.cpp : Implementation of CEchoPage
#include "stdafx.h"
#include "ToolProps.h"
#include "EchoPage.h"


/////////////////////////////////////////////////////////////////////////////
// CEchoPage

CEchoPage::CEchoPage() 
{
	m_dwTitleID = IDS_TITLEEchoPage;
	m_dwHelpFileID = IDS_HELPFILEEchoPage;
	m_dwDocStringID = IDS_DOCSTRINGEchoPage;
    m_pEcho = NULL;
}

CEchoPage::~CEchoPage()

{
    if (m_pEcho)
    {
        m_pEcho->Release();
    }
}

STDMETHODIMP CEchoPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicEchoTool,(void **) &m_pEcho);
}


STDMETHODIMP CEchoPage::Apply(void)

{
    m_pEcho->SetRepeat((DWORD) m_ctRepeat.GetValue());
	m_pEcho->SetDecay((DWORD) m_ctDecay.GetValue());
    m_pEcho->SetDelay((DWORD) m_ctDelay.GetValue());
    m_pEcho->SetGroupOffset((DWORD) m_ctOffset.GetValue());
    m_pEcho->SetType(m_ctType.GetValue());
    m_pEcho->SetTimeUnit(m_ctTimeUnit.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

void CEchoPage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 2)
    {
        m_ctDelay.SetRange(0,1000);
    }
    else
    {
        m_ctDelay.SetRange(0,12);
    }
}

LRESULT CEchoPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pEcho)
    {
        static char *pTypes[4] = { "Falling","Falling, Truncated","Rising","Rising, Truncated"};
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT] = { 
            "Milliseconds","Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctRepeat.Init(GetDlgItem(IDC_REPEAT),GetDlgItem(IDC_REPEAT_DISPLAY),0,24,true);
        m_ctDelay.Init(GetDlgItem(IDC_DELAY),GetDlgItem(IDC_DELAY_DISPLAY),0,12,true);
        m_ctDecay.Init(GetDlgItem(IDC_DECAY),GetDlgItem(IDC_DECAY_DISPLAY),0,100,true);
        m_ctOffset.Init(GetDlgItem(IDC_OFFSET),GetDlgItem(IDC_OFFSET_DISPLAY),0,10,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,4);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT);

        DWORD dwValue;
        m_pEcho->GetType(&dwValue);
        m_ctType.SetValue(dwValue);
        m_pEcho->GetTimeUnit(&dwValue);
        m_ctTimeUnit.SetValue(dwValue);
        SetTimeUnitRange();
        m_pEcho->GetRepeat(&dwValue);
        m_ctRepeat.SetValue((float)dwValue);
        m_pEcho->GetDelay(&dwValue);
        m_ctDelay.SetValue((float)dwValue);
        m_pEcho->GetDecay(&dwValue);
        m_ctDecay.SetValue((float)dwValue);
        m_pEcho->GetGroupOffset(&dwValue);
        m_ctOffset.SetValue((float)dwValue);
    }
	return 1;
}

LRESULT CEchoPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRepeat.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDelay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDecay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CEchoPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRepeat.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDelay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDecay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\echopage.h ===
// EchoPage.h : Declaration of the CEchoPage

#ifndef __ECHOPAGE_H_
#define __ECHOPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_EchoPage;

/////////////////////////////////////////////////////////////////////////////
// CEchoPage
class ATL_NO_VTABLE CEchoPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEchoPage, &CLSID_EchoPage>,
	public IPropertyPageImpl<CEchoPage>,
	public CDialogImpl<CEchoPage>
{
public:
	CEchoPage();
    virtual ~CEchoPage();

	enum {IDD = IDD_ECHOPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_ECHOPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEchoPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CEchoPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CEchoPage>)
END_MSG_MAP()

// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//    LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicEchoTool *m_pEcho;
    CSliderValue          m_ctRepeat;
    CSliderValue          m_ctDecay;
    CSliderValue          m_ctDelay;
    CSliderValue          m_ctOffset;
    CComboHelp            m_ctTimeUnit;
    CComboHelp            m_ctType;
};

#endif //__ECHOPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\quantizepage.cpp ===
// QuantizePage.cpp : Implementation of CQuantizePage
#include "stdafx.h"
#include "ToolProps.h"
#include "QuantizePage.h"

/////////////////////////////////////////////////////////////////////////////
// CQuantizePage

CQuantizePage::CQuantizePage() 
{
	m_dwTitleID = IDS_TITLEQuantizePage;
	m_dwHelpFileID = IDS_HELPFILEQuantizePage;
	m_dwDocStringID = IDS_DOCSTRINGQuantizePage;
    m_pQuantize = NULL;
}

CQuantizePage::~CQuantizePage()

{
    if (m_pQuantize)
    {
        m_pQuantize->Release();
    }
}

STDMETHODIMP CQuantizePage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicQuantizeTool,(void **) &m_pQuantize);
}


STDMETHODIMP CQuantizePage::Apply(void)

{
    m_pQuantize->SetStrength((DWORD) m_ctStrength.GetValue());
	m_pQuantize->SetResolution((DWORD) m_ctResolution.GetValue());
    m_pQuantize->SetType(m_ctType.GetValue());
    m_pQuantize->SetTimeUnit(m_ctTimeUnit.GetValue()+1);
	m_bDirty = FALSE;
	return S_OK;
}

void CQuantizePage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 2)
    {
        m_ctResolution.SetRange(0,1000);
    }
    else
    {
        m_ctResolution.SetRange(0,12);
    }
}

LRESULT CQuantizePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pQuantize)
    {
        static char *pTypes[4] = { "Quantize Off","Quantize Start Time","Quantize Duration",
            "Quantize Start and Duration"};
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT-1] = { 
            "Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctStrength.Init(GetDlgItem(IDC_STRENGTH),GetDlgItem(IDC_STRENGTH_DISPLAY),0,120,true);
        m_ctResolution.Init(GetDlgItem(IDC_RESOLUTION),GetDlgItem(IDC_RESOLUTION_DISPLAY),0,12,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,4);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT-1);

        DWORD dwValue;
        m_pQuantize->GetType(&dwValue);
        m_ctType.SetValue(dwValue);
        m_pQuantize->GetTimeUnit(&dwValue);
        m_ctTimeUnit.SetValue(dwValue-1);
        SetTimeUnitRange();
        m_pQuantize->GetStrength(&dwValue);
        m_ctStrength.SetValue((float)dwValue);
        m_pQuantize->GetResolution(&dwValue);
        m_ctResolution.SetValue((float)dwValue);
    }
	return 1;
}

LRESULT CQuantizePage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctResolution.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CQuantizePage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctResolution.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\timeshiftpage.cpp ===
// TimeShiftPage.cpp : Implementation of CTimeShiftPage
#include "stdafx.h"
#include "ToolProps.h"
#include "TimeShiftPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTimeShiftPage

CTimeShiftPage::CTimeShiftPage() 
{
	m_dwTitleID = IDS_TITLETimeShiftPage;
	m_dwHelpFileID = IDS_HELPFILETimeShiftPage;
	m_dwDocStringID = IDS_DOCSTRINGTimeShiftPage;
    m_pTimeShift = NULL;
}

CTimeShiftPage::~CTimeShiftPage()

{
    if (m_pTimeShift)
    {
        m_pTimeShift->Release();
    }
}

STDMETHODIMP CTimeShiftPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicTimeShiftTool,(void **) &m_pTimeShift);
}


STDMETHODIMP CTimeShiftPage::Apply(void)

{
    m_pTimeShift->SetRange((DWORD)m_ctRange.GetValue());
    m_pTimeShift->SetOffset((long)m_ctOffset.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CTimeShiftPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pTimeShift)
    {
        m_ctRange.Init(GetDlgItem(IDC_RANGE),GetDlgItem(IDC_RANGE_DISPLAY),0,200,true);
        m_ctOffset.Init(GetDlgItem(IDC_OFFSET),GetDlgItem(IDC_OFFSET_DISPLAY),-200,200,true);

        long lValue;
        m_pTimeShift->GetRange((DWORD *)&lValue);
        m_ctRange.SetValue((float)lValue);
        m_pTimeShift->GetOffset(&lValue);
        m_ctOffset.SetValue((float)lValue);
    }
	return 1;
}

LRESULT CTimeShiftPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRange.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CTimeShiftPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRange.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ToolProps.rc
//
#define IDS_PROJNAME                    100
#define IDS_TITLEEchoPage               101
#define IDS_HELPFILEEchoPage            102
#define IDS_DOCSTRINGEchoPage           103
#define IDR_ECHOPAGE                    104
#define IDD_ECHOPAGE                    105
#define IDS_TITLETransposePage          106
#define IDS_HELPFILETransposePage       107
#define IDS_DOCSTRINGTransposePage      108
#define IDR_TRANSPOSEPAGE               109
#define IDD_TRANSPOSEPAGE               110
#define IDS_TITLEDurationPage           111
#define IDS_HELPFILEDurationPage        112
#define IDS_DOCSTRINGDurationPage       113
#define IDR_DURATIONPAGE                114
#define IDD_DURATIONPAGE                115
#define IDS_TITLEQuantizePage           116
#define IDS_HELPFILEQuantizePage        117
#define IDS_DOCSTRINGQuantizePage       118
#define IDR_QUANTIZEPAGE                119
#define IDD_QUANTIZEPAGE                120
#define IDS_TITLETimeShiftPage          121
#define IDS_HELPFILETimeShiftPage       122
#define IDS_DOCSTRINGTimeShiftPage      123
#define IDR_TIMESHIFTPAGE               124
#define IDD_TIMESHIFTPAGE               125
#define IDC_REPEAT                      201
#define IDC_REPEAT_DISPLAY              202
#define IDC_DECAY                       203
#define IDC_DECAY_DISPLAY               204
#define IDC_DELAY                       205
#define IDC_DELAY_DISPLAY               206
#define IDC_OFFSET                      207
#define IDC_OFFSET_DISPLAY              208
#define IDC_TIMEUNIT                    209
#define IDC_TYPE                        210
#define IDC_TRANSPOSE                   211
#define IDC_TRANSPOSE_DISPLAY           212
#define IDC_SCALE                       213
#define IDC_SCALE_DISPLAY               214
#define IDC_STRENGTH                    215
#define IDC_STRENGTH_DISPLAY            216
#define IDC_RESOLUTION                  217
#define IDC_RESOLUTION_DISPLAY          218
#define IDC_RANGE                       219
#define IDC_RANGE_DISPLAY               220

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         221
#define _APS_NEXT_SYMED_VALUE           126
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED_)
#define AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\quantizepage.h ===
// QuantizePage.h : Declaration of the CQuantizePage

#ifndef __QUANTIZEPAGE_H_
#define __QUANTIZEPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_QuantizePage;

/////////////////////////////////////////////////////////////////////////////
// CQuantizePage
class ATL_NO_VTABLE CQuantizePage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CQuantizePage, &CLSID_QuantizePage>,
	public IPropertyPageImpl<CQuantizePage>,
	public CDialogImpl<CQuantizePage>
{
public:
	CQuantizePage();
    virtual ~CQuantizePage();

	enum {IDD = IDD_QUANTIZEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_QUANTIZEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CQuantizePage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CQuantizePage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CQuantizePage>)
END_MSG_MAP()

// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicQuantizeTool *m_pQuantize;
    CSliderValue          m_ctStrength;
    CSliderValue          m_ctResolution;
    CComboHelp            m_ctTimeUnit;
    CComboHelp            m_ctType;
};

#endif //__QUANTIZEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\toolprops.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Apr 18 15:40:11 2000
 */
/* Compiler settings for C:\nt\multimedia\Directx\dmusic\dmtool\toolprops\ToolProps.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __ToolProps_h__
#define __ToolProps_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __EchoPage_FWD_DEFINED__
#define __EchoPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class EchoPage EchoPage;
#else
typedef struct EchoPage EchoPage;
#endif /* __cplusplus */

#endif 	/* __EchoPage_FWD_DEFINED__ */


#ifndef __TransposePage_FWD_DEFINED__
#define __TransposePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransposePage TransposePage;
#else
typedef struct TransposePage TransposePage;
#endif /* __cplusplus */

#endif 	/* __TransposePage_FWD_DEFINED__ */


#ifndef __DurationPage_FWD_DEFINED__
#define __DurationPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class DurationPage DurationPage;
#else
typedef struct DurationPage DurationPage;
#endif /* __cplusplus */

#endif 	/* __DurationPage_FWD_DEFINED__ */


#ifndef __QuantizePage_FWD_DEFINED__
#define __QuantizePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class QuantizePage QuantizePage;
#else
typedef struct QuantizePage QuantizePage;
#endif /* __cplusplus */

#endif 	/* __QuantizePage_FWD_DEFINED__ */


#ifndef __TimeShiftPage_FWD_DEFINED__
#define __TimeShiftPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TimeShiftPage TimeShiftPage;
#else
typedef struct TimeShiftPage TimeShiftPage;
#endif /* __cplusplus */

#endif 	/* __TimeShiftPage_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __TOOLPROPSLib_LIBRARY_DEFINED__
#define __TOOLPROPSLib_LIBRARY_DEFINED__

/* library TOOLPROPSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TOOLPROPSLib;

EXTERN_C const CLSID CLSID_EchoPage;

#ifdef __cplusplus

class DECLSPEC_UUID("5337AF8F-3827-44DD-9EE9-AB6E1AABB60F")
EchoPage;
#endif

EXTERN_C const CLSID CLSID_TransposePage;

#ifdef __cplusplus

class DECLSPEC_UUID("691BD8C2-2B07-4C92-A82E-92D858DE23D6")
TransposePage;
#endif

EXTERN_C const CLSID CLSID_DurationPage;

#ifdef __cplusplus

class DECLSPEC_UUID("79D9CAF8-DBDA-4560-A8B0-07E73A79FA6B")
DurationPage;
#endif

EXTERN_C const CLSID CLSID_QuantizePage;

#ifdef __cplusplus

class DECLSPEC_UUID("623286DC-67F8-4055-A9BE-F7A7176BD150")
QuantizePage;
#endif

EXTERN_C const CLSID CLSID_TimeShiftPage;

#ifdef __cplusplus

class DECLSPEC_UUID("7D3BDEE7-9557-4085-82EE-1B2F02CE4BA6")
TimeShiftPage;
#endif
#endif /* __TOOLPROPSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\timeshiftpage.h ===
// TimeShiftPage.h : Declaration of the CTimeShiftPage

#ifndef __TIMESHIFTPAGE_H_
#define __TIMESHIFTPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_TimeShiftPage;

/////////////////////////////////////////////////////////////////////////////
// CTimeShiftPage
class ATL_NO_VTABLE CTimeShiftPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTimeShiftPage, &CLSID_TimeShiftPage>,
	public IPropertyPageImpl<CTimeShiftPage>,
	public CDialogImpl<CTimeShiftPage>
{
public:
	CTimeShiftPage();
    virtual ~CTimeShiftPage();

	enum {IDD = IDD_TIMESHIFTPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_TIMESHIFTPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTimeShiftPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTimeShiftPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CTimeShiftPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicTimeShiftTool *  m_pTimeShift;
    CSliderValue                 m_ctRange;
    CSliderValue                 m_ctOffset;
};

#endif //__TIMESHIFTPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\toolprops.cpp ===
// ToolProps.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ToolPropsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ToolProps.h"

#include "ToolProps_i.c"
#include "EchoPage.h"
#include "TransposePage.h"
#include "DurationPage.h"
#include "QuantizePage.h"
#include "TimeShiftPage.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_EchoPage, CEchoPage)
OBJECT_ENTRY(CLSID_TransposePage, CTransposePage)
OBJECT_ENTRY(CLSID_DurationPage, CDurationPage)
OBJECT_ENTRY(CLSID_QuantizePage, CQuantizePage)
OBJECT_ENTRY(CLSID_TimeShiftPage, CTimeShiftPage)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TOOLPROPSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\transposepage.cpp ===
// TransposePage.cpp : Implementation of CTransposePage
#include "stdafx.h"
#include "ToolProps.h"
#include "TransposePage.h"


/////////////////////////////////////////////////////////////////////////////
// CTransposePage

CTransposePage::CTransposePage() 
{
	m_dwTitleID = IDS_TITLETransposePage;
	m_dwHelpFileID = IDS_HELPFILETransposePage;
	m_dwDocStringID = IDS_DOCSTRINGTransposePage;
    m_pTranspose = NULL;
}

CTransposePage::~CTransposePage()

{
    if (m_pTranspose)
    {
        m_pTranspose->Release();
    }
}

STDMETHODIMP CTransposePage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicTransposeTool,(void **) &m_pTranspose);
}


STDMETHODIMP CTransposePage::Apply(void)

{
    m_pTranspose->SetTranspose((long) m_ctTranspose.GetValue());
    m_pTranspose->SetType(m_ctType.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CTransposePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pTranspose)
    {
        static char *pTypes[2] = { "Linear","In Scale"};
        m_ctTranspose.Init(GetDlgItem(IDC_TRANSPOSE),GetDlgItem(IDC_TRANSPOSE_DISPLAY),-24,24,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,2);

        DWORD dwType;
        m_pTranspose->GetType(&dwType);
        m_ctType.SetValue(dwType);
        long lTranspose;
        m_pTranspose->GetTranspose(&lTranspose);
        m_ctTranspose.SetValue((float)lTranspose);
    }
	return 1;
}

LRESULT CTransposePage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctTranspose.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CTransposePage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctTranspose.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\controlhelp.cpp ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Implementation of CSliderValue.
//

#include "stdafx.h"
#include "ControlHelp.h"
#include <commctrl.h>
#include <stdio.h>

//////////////////////////////////////////////////////////////////////////////
// CSliderValue

const short g_sMaxContinuousTicks = 200;
const int g_iMaxCharBuffer = 50; // # characters big enough to hold -FLT_MAX with room to spare

CSliderValue::CSliderValue()
  : m_fInit(false)
{
}

void CSliderValue::SetRange(float fMin, float fMax)

{
    if (m_fInit)
    {
        m_fMin = fMin;
        m_fMax = fMax;

        short sMin;
        short sMax;
        short sTicks = 4; // Lots of ticks become less useful as guides.  Use quarters for fine-grained sliders.
        if (m_fDiscrete) 
        {
            sMin = static_cast<short>(fMin);
            sMax = static_cast<short>(fMax);
            if (sMax - sMin <= 10)
                sTicks = sMax - sMin;
        }
        else
        {
            sMin = 0;
            sMax = g_sMaxContinuousTicks;
        }
    
        SendMessage(m_hwndSlider, TBM_SETRANGE, TRUE, MAKELONG(sMin, sMax));
        SendMessage(m_hwndSlider, TBM_SETTICFREQ, (sMax - sMin) / sTicks, 0);
    }
}

void CSliderValue::Init(
        HWND        hwndSlider,
        HWND        hwndEdit,
        float       fMin, 
        float       fMax, 
        bool        fDiscrete)
{
    if (m_fInit)
        return;

    m_hwndSlider = hwndSlider;
    m_hwndEdit = hwndEdit;
    m_fDiscrete = fDiscrete;
    m_fInit = true;
    SetRange(fMin,fMax);
}

void CSliderValue::SetValue(float fPos)
{
    if (!m_fInit)
        return;

    UpdateEditBox(fPos);
    UpdateSlider();
}

float CSliderValue::GetValue()
{
    if (!m_fInit)
        return 0;

    LRESULT lrLen = SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);
    if (lrLen >= g_iMaxCharBuffer)
        return 0;

    char szText[g_iMaxCharBuffer] = "";
    SendMessage(m_hwndEdit, WM_GETTEXT, g_iMaxCharBuffer, reinterpret_cast<LPARAM>(szText));

    float fVal = static_cast<float>(m_fDiscrete ? atoi(szText) : atof(szText));

    if (fVal < m_fMin) fVal = m_fMin;
    if (fVal > m_fMax) fVal = m_fMax;
    return fVal;
}

float CSliderValue::GetSliderValue()
{
    short sPos = static_cast<short>(SendMessage(m_hwndSlider, TBM_GETPOS, 0, 0));
    if (m_fDiscrete)
    {
        return sPos;
    }

    float fRet = (m_fMax - m_fMin) * sPos / g_sMaxContinuousTicks + m_fMin;
    return fRet;
}

LRESULT CSliderValue::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    switch (uMsg)
    {
    case WM_HSCROLL:
        if (bHandled = (reinterpret_cast<HWND>(lParam) == m_hwndSlider && LOWORD(wParam) >= TB_LINEUP && LOWORD(wParam) <= TB_ENDTRACK))
            UpdateEditBox(GetSliderValue());
        break;

    case WM_COMMAND:
        if (bHandled = (HIWORD(wParam) == EN_KILLFOCUS && reinterpret_cast<HWND>(lParam) == m_hwndEdit))
            UpdateSlider();
        break;

    default:
        bHandled = FALSE;
        break;
    }

    return 0;
}

void CSliderValue::UpdateEditBox(float fPos)
{
    char szText[g_iMaxCharBuffer] = "";

    if (m_fDiscrete)
    {
        short sPos = static_cast<short>(fPos);
        sprintf(szText, "%hd", sPos);
    }
    else
    {
        sprintf(szText, "%.2hf", fPos);
    }

    SendMessage(m_hwndEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(szText));
}

void CSliderValue::UpdateSlider()
{
    float fVal = GetValue();
    short sPos = static_cast<short>(m_fDiscrete ? fVal : g_sMaxContinuousTicks * ((fVal - m_fMin) / (m_fMax - m_fMin)));
    SendMessage(m_hwndSlider, TBM_SETPOS, TRUE, sPos);
    UpdateEditBox(fVal); // this resets the input box back to the set float value in case the input was invalid
}

CComboHelp::CComboHelp()
{
    m_hwndCombo = NULL;
    m_fInit = FALSE;
}

void CComboHelp::Init(HWND hwndCombo, int nID, char *pStrings[], DWORD cbStrings)
{
    DWORD dwIndex;
    m_hwndCombo = hwndCombo;
    m_nID = nID;
    for (dwIndex = 0; dwIndex < cbStrings; dwIndex++)
    {
        SendMessage( hwndCombo,CB_ADDSTRING,0,(LPARAM)pStrings[dwIndex]);
    }
    m_fInit = TRUE;
}

void CComboHelp::SetValue(DWORD dwValue)
{
    SendMessage(m_hwndCombo,CB_SETCURSEL,dwValue,0);
}

DWORD CComboHelp::GetValue()
{
    return (DWORD) SendMessage( m_hwndCombo,CB_GETCURSEL,0,0);
}

LRESULT CComboHelp::MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_fInit)
        return FALSE;

    switch (uMsg)
    {
    case WM_COMMAND:
        bHandled = ((HIWORD(wParam) == CBN_SELCHANGE) && (LOWORD(wParam) == m_nID));
        break;
    default:
        bHandled = FALSE;
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\toolprops_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Apr 17 13:39:44 2000
 */
/* Compiler settings for C:\nt\multimedia\Directx\dmusic\dmtool\toolprops\ToolProps.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_TOOLPROPSLib = {0x2735B8F3,0xFF4A,0x4AF2,{0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32}};


const CLSID CLSID_EchoPage = {0x5337AF8F,0x3827,0x44DD,{0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F}};


const CLSID CLSID_TransposePage = {0x691BD8C2,0x2B07,0x4C92,{0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6}};


const CLSID CLSID_DurationPage = {0x79D9CAF8,0xDBDA,0x4560,{0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B}};


const CLSID CLSID_QuantizePage = {0x623286DC,0x67F8,0x4055,{0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\durationpage.cpp ===
// DurationPage.cpp : Implementation of CDurationPage
#include "stdafx.h"
#include "ToolProps.h"
#include "DurationPage.h"

/////////////////////////////////////////////////////////////////////////////
// CDurationPage

CDurationPage::CDurationPage() 
{
	m_dwTitleID = IDS_TITLEDurationPage;
	m_dwHelpFileID = IDS_HELPFILEDurationPage;
	m_dwDocStringID = IDS_DOCSTRINGDurationPage;
    m_pDuration = NULL;
}

CDurationPage::~CDurationPage()

{
    if (m_pDuration)
    {
        m_pDuration->Release();
    }
}

STDMETHODIMP CDurationPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicDurationTool,(void **) &m_pDuration);
}


STDMETHODIMP CDurationPage::Apply(void)

{
    m_pDuration->SetScale(m_ctScale.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CDurationPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pDuration)
    {
        m_ctScale.Init(GetDlgItem(IDC_SCALE),GetDlgItem(IDC_SCALE_DISPLAY),0,8.0,false);

        float fScale;
        m_pDuration->GetScale(&fScale);
        m_ctScale.SetValue(fScale);
    }
	return 1;
}

LRESULT CDurationPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctScale.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CDurationPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctScale.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\durationpage.h ===
// DurationPage.h : Declaration of the CDurationPage

#ifndef __DURATIONPAGE_H_
#define __DURATIONPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_DurationPage;

/////////////////////////////////////////////////////////////////////////////
// CDurationPage
class ATL_NO_VTABLE CDurationPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDurationPage, &CLSID_DurationPage>,
	public IPropertyPageImpl<CDurationPage>,
	public CDialogImpl<CDurationPage>
{
public:
	CDurationPage();
    virtual ~CDurationPage();

	enum {IDD = IDD_DURATIONPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DURATIONPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDurationPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDurationPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CDurationPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicDurationTool *  m_pDuration;
    CSliderValue                m_ctScale;
};

#endif //__DURATIONPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtool\toolprops\transposepage.h ===
// TransposePage.h : Declaration of the CTransposePage

#ifndef __TRANSPOSEPAGE_H_
#define __TRANSPOSEPAGE_H_

#include "resource.h"       // main symbols
#include "..\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_TransposePage;

/////////////////////////////////////////////////////////////////////////////
// CTransposePage
class ATL_NO_VTABLE CTransposePage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTransposePage, &CLSID_TransposePage>,
	public IPropertyPageImpl<CTransposePage>,
	public CDialogImpl<CTransposePage>
{
public:
	CTransposePage();
    virtual ~CTransposePage();

	enum {IDD = IDD_TRANSPOSEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_TRANSPOSEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTransposePage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTransposePage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CTransposePage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicTransposeTool * m_pTranspose;
    CSliderValue                m_ctTranspose;
    CComboHelp                  m_ctType;
};

#endif //__TRANSPOSEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\controlhelp.h ===
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Declaration of CSliderValue.
//

#pragma once

class CSliderValue
{
public:
    CSliderValue();
    void Init(HWND hwndSlider, HWND hwndEdit, float fMin, float fMax, bool fDiscrete);
    void SetRange(float fMin, float fMax);
    void SetValue(float fPos);
    float GetValue();

    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    bool                m_fInit;
    HWND                m_hwndSlider;
    HWND                m_hwndEdit;
    float               m_fMin;
    float               m_fMax;
    bool                m_fDiscrete;

public:
    float GetSliderValue();
    void UpdateEditBox(float fPos);
    void UpdateSlider();
};

class CComboHelp
{
public:
    CComboHelp();
    void Init(HWND hwndCombo, int nID, char *pStrings[], DWORD cbStrings);
    void SetValue(DWORD dwValue);
    DWORD GetValue();
    LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
private:
    bool                m_fInit;
    int                 m_nID;
    HWND                m_hwndCombo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED_)
#define AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B54A32F6_F277_470E_AC31_3ECE7AB2A3B4__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\echopage.cpp ===
// EchoPage.cpp : Implementation of CEchoPage
#include "stdafx.h"
#include "ToolProps.h"
#include "EchoPage.h"


/////////////////////////////////////////////////////////////////////////////
// CEchoPage

CEchoPage::CEchoPage() 
{
	m_dwTitleID = IDS_TITLEEchoPage;
	m_dwHelpFileID = IDS_HELPFILEEchoPage;
	m_dwDocStringID = IDS_DOCSTRINGEchoPage;
    m_pEcho = NULL;
}

CEchoPage::~CEchoPage()

{
    if (m_pEcho)
    {
        m_pEcho->Release();
    }
}

STDMETHODIMP CEchoPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicEchoTool,(void **) &m_pEcho);
}


STDMETHODIMP CEchoPage::Apply(void)

{
    m_pEcho->SetRepeat((DWORD) m_ctRepeat.GetValue());
	m_pEcho->SetDecay((DWORD) m_ctDecay.GetValue());
    m_pEcho->SetDelay((DWORD) m_ctDelay.GetValue());
    m_pEcho->SetGroupOffset((DWORD) m_ctOffset.GetValue());
    m_pEcho->SetType(m_ctType.GetValue());
    m_pEcho->SetTimeUnit(m_ctTimeUnit.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

void CEchoPage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 2)
    {
        m_ctDelay.SetRange(0,1000);
    }
    else
    {
        m_ctDelay.SetRange(0,12);
        m_ctDelay.UpdateSlider();
    }
}

LRESULT CEchoPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pEcho)
    {
        static char *pTypes[4] = { "Falling","Falling, Truncated","Rising","Rising, Truncated"};
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT] = { 
            "Milliseconds","Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctRepeat.Init(GetDlgItem(IDC_REPEAT),GetDlgItem(IDC_REPEAT_DISPLAY),0,24,true);
        m_ctDelay.Init(GetDlgItem(IDC_DELAY),GetDlgItem(IDC_DELAY_DISPLAY),0,12,true);
        m_ctDecay.Init(GetDlgItem(IDC_DECAY),GetDlgItem(IDC_DECAY_DISPLAY),0,100,true);
        m_ctOffset.Init(GetDlgItem(IDC_OFFSET),GetDlgItem(IDC_OFFSET_DISPLAY),0,10,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,4);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT);

        DWORD dwValue;
        m_pEcho->GetType(&dwValue);
        m_ctType.SetValue(dwValue);
        m_pEcho->GetTimeUnit(&dwValue);
        m_ctTimeUnit.SetValue(dwValue);
        SetTimeUnitRange();
        m_pEcho->GetRepeat(&dwValue);
        m_ctRepeat.SetValue((float)dwValue);
        m_pEcho->GetDelay(&dwValue);
        m_ctDelay.SetValue((float)dwValue);
        m_pEcho->GetDecay(&dwValue);
        m_ctDecay.SetValue((float)dwValue);
        m_pEcho->GetGroupOffset(&dwValue);
        m_ctOffset.SetValue((float)dwValue);
    }
	return 1;
}

LRESULT CEchoPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRepeat.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDelay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDecay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CEchoPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRepeat.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDelay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctDecay.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ToolProps.rc
//
#define IDS_PROJNAME                    100
#define IDS_TITLEEchoPage               101
#define IDS_HELPFILEEchoPage            102
#define IDS_DOCSTRINGEchoPage           103
#define IDR_ECHOPAGE                    104
#define IDD_ECHOPAGE                    105
#define IDS_TITLETransposePage          106
#define IDS_HELPFILETransposePage       107
#define IDS_DOCSTRINGTransposePage      108
#define IDR_TRANSPOSEPAGE               109
#define IDD_TRANSPOSEPAGE               110
#define IDS_TITLEDurationPage           111
#define IDS_HELPFILEDurationPage        112
#define IDS_DOCSTRINGDurationPage       113
#define IDR_DURATIONPAGE                114
#define IDD_DURATIONPAGE                115
#define IDS_TITLEQuantizePage           116
#define IDS_HELPFILEQuantizePage        117
#define IDS_DOCSTRINGQuantizePage       118
#define IDR_QUANTIZEPAGE                119
#define IDD_QUANTIZEPAGE                120
#define IDS_TITLETimeShiftPage          121
#define IDS_HELPFILETimeShiftPage       122
#define IDS_DOCSTRINGTimeShiftPage      123
#define IDR_TIMESHIFTPAGE               124
#define IDD_TIMESHIFTPAGE               125
#define IDS_TITLESwingPage              126
#define IDS_HELPFILESwingPage           127
#define IDS_DOCSTRINGSwingPage          128
#define IDR_SWINGPAGE                   129
#define IDD_SWINGPAGE                   130
#define IDS_TITLEVelocityPage           131
#define IDS_HELPFILEVelocityPage        132
#define IDS_DOCSTRINGVelocityPage       133
#define IDR_VELOCITYPAGE                134
#define IDD_VELOCITYPAGE                135
#define IDC_REPEAT                      201
#define IDC_REPEAT_DISPLAY              202
#define IDC_DECAY                       203
#define IDC_DECAY_DISPLAY               204
#define IDC_DELAY                       205
#define IDC_DELAY_DISPLAY               206
#define IDC_OFFSET                      207
#define IDC_OFFSET_DISPLAY              208
#define IDC_TIMEUNIT                    209
#define IDC_TYPE                        210
#define IDC_TRANSPOSE                   211
#define IDC_TRANSPOSE_DISPLAY           212
#define IDC_SCALE                       213
#define IDC_SCALE_DISPLAY               214
#define IDC_STRENGTH                    215
#define IDC_STRENGTH_DISPLAY            216
#define IDC_RESOLUTION                  217
#define IDC_LOWERLIMIT                  217
#define IDC_RESOLUTION_DISPLAY          218
#define IDC_LOWERLIMIT_DISPLAY          218
#define IDC_RANGE                       219
#define IDC_UPPERLIMIT                  219
#define IDC_RANGE_DISPLAY               220
#define IDC_UPPERLIMIT_DISPLAY          220
#define IDC_SWING                       221
#define IDC_CURVESTART                  221
#define IDC_SWING_DISPLAY               222
#define IDC_CURVESTART_DISPLAY          222
#define IDC_CURVEEND                    223
#define IDC_CURVEEND_DISPLAY            224
#define IDC_DISPLAY_CURVE               225

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         226
#define _APS_NEXT_SYMED_VALUE           136
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\swingpage.cpp ===
// SwingPage.cpp : Implementation of CSwingPage
#include "stdafx.h"
#include "ToolProps.h"
#include "SwingPage.h"

/////////////////////////////////////////////////////////////////////////////
// CSwingPage

CSwingPage::CSwingPage() 
{
	m_dwTitleID = IDS_TITLESwingPage;
	m_dwHelpFileID = IDS_HELPFILESwingPage;
	m_dwDocStringID = IDS_DOCSTRINGSwingPage;
    m_pSwing = NULL;
}

CSwingPage::~CSwingPage()

{
    if (m_pSwing)
    {
        m_pSwing->Release();
    }
}

STDMETHODIMP CSwingPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicSwingTool,(void **) &m_pSwing);
}


STDMETHODIMP CSwingPage::Apply(void)

{
    m_pSwing->SetStrength((DWORD)m_ctSwing.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CSwingPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pSwing)
    {
        m_ctSwing.Init(GetDlgItem(IDC_SWING),GetDlgItem(IDC_SWING_DISPLAY),0,100,true);

        DWORD dwSwing;
        m_pSwing->GetStrength(&dwSwing);
        m_ctSwing.SetValue((float)dwSwing);
    }
	return 1;
}

LRESULT CSwingPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctSwing.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CSwingPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctSwing.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\swingpage.h ===
// SwingPage.h : Declaration of the CSwingPage

#ifndef __SWINGPAGE_H_
#define __SWINGPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_SwingPage;

/////////////////////////////////////////////////////////////////////////////
// CSwingPage
class ATL_NO_VTABLE CSwingPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSwingPage, &CLSID_SwingPage>,
	public IPropertyPageImpl<CSwingPage>,
	public CDialogImpl<CSwingPage>
{
public:
	CSwingPage(); 
    virtual ~CSwingPage();

	enum {IDD = IDD_SWINGPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_SWINGPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSwingPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CSwingPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CSwingPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicSwingTool *     m_pSwing;
    CSliderValue                m_ctSwing;
};

#endif //__SWINGPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\quantizepage.cpp ===
// QuantizePage.cpp : Implementation of CQuantizePage
#include "stdafx.h"
#include "ToolProps.h"
#include "QuantizePage.h"

/////////////////////////////////////////////////////////////////////////////
// CQuantizePage

CQuantizePage::CQuantizePage() 
{
	m_dwTitleID = IDS_TITLEQuantizePage;
	m_dwHelpFileID = IDS_HELPFILEQuantizePage;
	m_dwDocStringID = IDS_DOCSTRINGQuantizePage;
    m_pQuantize = NULL;
}

CQuantizePage::~CQuantizePage()

{
    if (m_pQuantize)
    {
        m_pQuantize->Release();
    }
}

STDMETHODIMP CQuantizePage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicQuantizeTool,(void **) &m_pQuantize);
}


STDMETHODIMP CQuantizePage::Apply(void)

{
    m_pQuantize->SetStrength((DWORD) m_ctStrength.GetValue());
	m_pQuantize->SetResolution((DWORD) m_ctResolution.GetValue());
    m_pQuantize->SetType(m_ctType.GetValue());
    m_pQuantize->SetTimeUnit(m_ctTimeUnit.GetValue()+1);
	m_bDirty = FALSE;
	return S_OK;
}

void CQuantizePage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 1)
    {
        m_ctResolution.SetRange(0,1000);
    }
    else
    {
        m_ctResolution.SetRange(0,12);
    }
}

LRESULT CQuantizePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pQuantize)
    {
        static char *pTypes[3] = { "Quantize Start Time","Quantize Duration","Quantize Start and Duration"};
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT-1] = { 
            "Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctStrength.Init(GetDlgItem(IDC_STRENGTH),GetDlgItem(IDC_STRENGTH_DISPLAY),0,120,true);
        m_ctResolution.Init(GetDlgItem(IDC_RESOLUTION),GetDlgItem(IDC_RESOLUTION_DISPLAY),0,12,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,3);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT-1);

        DWORD dwValue;
        m_pQuantize->GetType(&dwValue);
        m_ctType.SetValue(dwValue);
        m_pQuantize->GetTimeUnit(&dwValue);
        m_ctTimeUnit.SetValue(dwValue-1);
        SetTimeUnitRange();
        m_pQuantize->GetStrength(&dwValue);
        m_ctStrength.SetValue((float)dwValue);
        m_pQuantize->GetResolution(&dwValue);
        m_ctResolution.SetValue((float)dwValue);
    }
	return 1;
}

LRESULT CQuantizePage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctResolution.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CQuantizePage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctResolution.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\quantizepage.h ===
// QuantizePage.h : Declaration of the CQuantizePage

#ifndef __QUANTIZEPAGE_H_
#define __QUANTIZEPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_QuantizePage;

/////////////////////////////////////////////////////////////////////////////
// CQuantizePage
class ATL_NO_VTABLE CQuantizePage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CQuantizePage, &CLSID_QuantizePage>,
	public IPropertyPageImpl<CQuantizePage>,
	public CDialogImpl<CQuantizePage>
{
public:
	CQuantizePage();
    virtual ~CQuantizePage();

	enum {IDD = IDD_QUANTIZEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_QUANTIZEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CQuantizePage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CQuantizePage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CQuantizePage>)
END_MSG_MAP()

// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicQuantizeTool *m_pQuantize;
    CSliderValue          m_ctStrength;
    CSliderValue          m_ctResolution;
    CComboHelp            m_ctTimeUnit;
    CComboHelp            m_ctType;
};

#endif //__QUANTIZEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\echopage.h ===
// EchoPage.h : Declaration of the CEchoPage

#ifndef __ECHOPAGE_H_
#define __ECHOPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_EchoPage;

/////////////////////////////////////////////////////////////////////////////
// CEchoPage
class ATL_NO_VTABLE CEchoPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEchoPage, &CLSID_EchoPage>,
	public IPropertyPageImpl<CEchoPage>,
	public CDialogImpl<CEchoPage>
{
public:
	CEchoPage();
    virtual ~CEchoPage();

	enum {IDD = IDD_ECHOPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_ECHOPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEchoPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CEchoPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CEchoPage>)
END_MSG_MAP()

// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//    LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicEchoTool *m_pEcho;
    CSliderValue          m_ctRepeat;
    CSliderValue          m_ctDecay;
    CSliderValue          m_ctDelay;
    CSliderValue          m_ctOffset;
    CComboHelp            m_ctTimeUnit;
    CComboHelp            m_ctType;
};

#endif //__ECHOPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\sources.inc ===
!ifndef DXROOT
DXROOT=$(BASEDIR)\multimedia\directx
!endif

!include $(DXROOT)\project.mk

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmtoolprp

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\toolprops.def
DLLENTRY=_DllMainCRTStartup

USE_MSVCRT=1
USE_MAPSYM=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

ATL_VER=30
USE_ATL=1

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\gdi32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\oleaut32.lib \
    $(BASEDIR)\public\sdk\lib\*\kernel32.lib    \
    $(BASEDIR)\public\sdk\lib\*\user32.lib      \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
    $(BASEDIR)\public\sdk\lib\*\uuid.lib

SOURCES=\
    ..\toolprops.idl                      \
    ..\ControlHelp.cpp                   \
    ..\DurationPage.cpp       \
    ..\EchoPage.cpp   \
    ..\QuantizePage.cpp   \
	..\SwingPage.cpp		\
    ..\TimeShiftPage.cpp         \
    ..\TransposePage.cpp      \
	..\VelocityPage.cpp   \
    ..\toolprops.cpp                      \
    ..\toolprops.rc                       \
    ..\StdAfx.cpp

NTTARGETFILE0 = buildidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\timeshiftpage.cpp ===
// TimeShiftPage.cpp : Implementation of CTimeShiftPage
#include "stdafx.h"
#include "ToolProps.h"
#include "TimeShiftPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTimeShiftPage

CTimeShiftPage::CTimeShiftPage() 
{
	m_dwTitleID = IDS_TITLETimeShiftPage;
	m_dwHelpFileID = IDS_HELPFILETimeShiftPage;
	m_dwDocStringID = IDS_DOCSTRINGTimeShiftPage;
    m_pTimeShift = NULL;
}

CTimeShiftPage::~CTimeShiftPage()

{
    if (m_pTimeShift)
    {
        m_pTimeShift->Release();
    }
}

STDMETHODIMP CTimeShiftPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicTimeShiftTool,(void **) &m_pTimeShift);
}


STDMETHODIMP CTimeShiftPage::Apply(void)

{
    m_pTimeShift->SetRange((DWORD)m_ctRange.GetValue());
    m_pTimeShift->SetTimeUnit(m_ctTimeUnit.GetValue()+1);
    m_pTimeShift->SetOffset((long)m_ctOffset.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

void CTimeShiftPage::SetTimeUnitRange()

{
    DWORD dwRes = m_ctTimeUnit.GetValue();
    if (dwRes < 1)
    {
        m_ctOffset.SetRange(-1000,1000);
        m_ctRange.SetRange(0,1000);
    }
    else
    {
        m_ctOffset.SetRange(-48,48);
        m_ctRange.SetRange(0,48);
        m_ctOffset.UpdateSlider();
        m_ctRange.UpdateSlider();
    }
}

LRESULT CTimeShiftPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pTimeShift)
    {
        static char *pTimeUnit[DMUS_TIME_UNIT_COUNT-1] = { 
            "Music Clicks","Grid", "Beat","Bar",
            "64th note triplets", "64th notes",
            "32nd note triplets",
            "32nd notes","16th note triplets","16th notes",
            "8th note triplets","8th notes","Quarter note triplets",
            "Quarter notes","Half note triplets","Half notes",
            "Whole note triplets", "Whole notes"
        };
        m_ctRange.Init(GetDlgItem(IDC_RANGE),GetDlgItem(IDC_RANGE_DISPLAY),0,200,true);
        m_ctOffset.Init(GetDlgItem(IDC_OFFSET),GetDlgItem(IDC_OFFSET_DISPLAY),-200,200,true);
        m_ctTimeUnit.Init(GetDlgItem(IDC_TIMEUNIT),IDC_TIMEUNIT,pTimeUnit,DMUS_TIME_UNIT_COUNT-1);

        long lValue;
        m_pTimeShift->GetTimeUnit((DWORD *)&lValue);
        m_ctTimeUnit.SetValue(lValue-1);
        SetTimeUnitRange();
        m_pTimeShift->GetRange((DWORD *)&lValue);
        m_ctRange.SetValue((float)lValue);
        m_pTimeShift->GetOffset(&lValue);
        m_ctOffset.SetValue((float)lValue);
    }
	return 1;
}

LRESULT CTimeShiftPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRange.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (!bHandled) 
    {
        lr = m_ctTimeUnit.MessageHandler(uMsg, wParam, lParam, bHandled);
        if (bHandled) 
        {
            SetTimeUnitRange();
        }
    }
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CTimeShiftPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctRange.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
	    lr = m_ctOffset.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\transposepage.h ===
// TransposePage.h : Declaration of the CTransposePage

#ifndef __TRANSPOSEPAGE_H_
#define __TRANSPOSEPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_TransposePage;

/////////////////////////////////////////////////////////////////////////////
// CTransposePage
class ATL_NO_VTABLE CTransposePage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTransposePage, &CLSID_TransposePage>,
	public IPropertyPageImpl<CTransposePage>,
	public CDialogImpl<CTransposePage>
{
public:
	CTransposePage();
    virtual ~CTransposePage();

	enum {IDD = IDD_TRANSPOSEPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_TRANSPOSEPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTransposePage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTransposePage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CTransposePage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicTransposeTool * m_pTranspose;
    CSliderValue                m_ctTranspose;
    CComboHelp                  m_ctType;
};

#endif //__TRANSPOSEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\velocitypage.cpp ===
// VelocityPage.cpp : Implementation of CVelocityPage
#include "stdafx.h"
#include "ToolProps.h"
#include "VelocityPage.h"

/////////////////////////////////////////////////////////////////////////////
// CVelocityPage

CVelocityPage::CVelocityPage() 
{
	m_dwTitleID = IDS_TITLEVelocityPage;
	m_dwHelpFileID = IDS_HELPFILEVelocityPage;
	m_dwDocStringID = IDS_DOCSTRINGVelocityPage;
    m_pVelocity = NULL;
}

CVelocityPage::~CVelocityPage()

{
    if (m_pVelocity)
    {
        m_pVelocity->Release();
    }
}

STDMETHODIMP CVelocityPage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicVelocityTool,(void **) &m_pVelocity);
}


STDMETHODIMP CVelocityPage::Apply(void)

{
    m_pVelocity->SetStrength((long) m_ctStrength.GetValue());
    m_pVelocity->SetLowLimit((long) m_ctLowLimit.GetValue());
    m_pVelocity->SetHighLimit((long) m_ctHighLimit.GetValue());
    m_pVelocity->SetCurveStart((long) m_ctCurveStart.GetValue());
    m_pVelocity->SetCurveEnd((long) m_ctCurveEnd.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CVelocityPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pVelocity)
    {
        m_ctStrength.Init(GetDlgItem(IDC_STRENGTH),GetDlgItem(IDC_STRENGTH_DISPLAY),0,100,true);
        m_ctLowLimit.Init(GetDlgItem(IDC_LOWERLIMIT),GetDlgItem(IDC_LOWERLIMIT_DISPLAY),1,127,true);
        m_ctHighLimit.Init(GetDlgItem(IDC_UPPERLIMIT),GetDlgItem(IDC_UPPERLIMIT_DISPLAY),1,127,true);
        m_ctCurveStart.Init(GetDlgItem(IDC_CURVESTART),GetDlgItem(IDC_CURVESTART_DISPLAY),1,127,true);
        m_ctCurveEnd.Init(GetDlgItem(IDC_CURVEEND),GetDlgItem(IDC_CURVEEND_DISPLAY),1,127,true);

        long lValue;
        m_pVelocity->GetStrength(&lValue);
        m_ctStrength.SetValue((float)lValue);
        m_pVelocity->GetLowLimit(&lValue);
        m_ctLowLimit.SetValue((float)lValue);
        m_pVelocity->GetHighLimit(&lValue);
        m_ctHighLimit.SetValue((float)lValue);
        m_pVelocity->GetCurveStart(&lValue);
        m_ctCurveStart.SetValue((float)lValue);
        m_pVelocity->GetCurveEnd(&lValue);
        m_ctCurveEnd.SetValue((float)lValue);

        HWND hWnd = GetDlgItem(IDC_DISPLAY_CURVE);
        ::GetWindowRect(hWnd,&m_rectDisplay);
        ::DestroyWindow(hWnd);
        ScreenToClient(&m_rectDisplay);
    }
	return 1;
}

void CVelocityPage::DrawCurve(HDC hDCIn)

{
    float fLowLimit = m_ctLowLimit.GetValue() * (m_rectDisplay.top - m_rectDisplay.bottom ) / 127;
    float fHighLimit = m_ctHighLimit.GetValue() * (m_rectDisplay.top - m_rectDisplay.bottom) / 127;
    float fCurveStart = m_ctCurveStart.GetValue() * (m_rectDisplay.right - m_rectDisplay.left) / 127;
    float fCurveEnd = m_ctCurveEnd.GetValue() * (m_rectDisplay.right - m_rectDisplay.left ) / 127;
    
    HDC hDC;
    if (!hDCIn)
    {
        hDC = ::GetDC(m_hWnd);
    }
    else
    {
        hDC = hDCIn;
    }
    if (hDC)
    {
        m_rectDisplay.bottom++;
        ::FillRect(hDC, &m_rectDisplay, (HBRUSH) (COLOR_GRADIENTACTIVECAPTION));
        m_rectDisplay.bottom--;
        HPEN hPen = CreatePen(PS_SOLID,1,RGB(0,0,0));
        if (hPen)
        {
            HPEN hOldPen = (HPEN) ::SelectObject(hDC,hPen);
            ::MoveToEx(hDC,m_rectDisplay.left,m_rectDisplay.bottom + (int) fLowLimit,NULL);
            ::LineTo(hDC,m_rectDisplay.left + (int) fCurveStart,m_rectDisplay.bottom + (int) fLowLimit);
            ::LineTo(hDC,m_rectDisplay.left + (int) fCurveEnd,m_rectDisplay.bottom + (int) fHighLimit);
            ::LineTo(hDC,m_rectDisplay.right,m_rectDisplay.bottom + (int) fHighLimit);
            ::DeleteObject(hPen);
        }
        if (!hDCIn)
        {
            ::ReleaseDC(m_hWnd,hDC);
        }
    }
}

LRESULT CVelocityPage::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
    PAINTSTRUCT Paint;
    HDC hDC = ::BeginPaint(m_hWnd,&Paint);
    if (hDC)
    {
        DrawCurve(hDC);
        ::EndPaint(m_hWnd,&Paint);
    }
    return true;
}

LRESULT CVelocityPage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
        lr = m_ctLowLimit.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctHighLimit.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctCurveStart.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctCurveEnd.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
    DrawCurve(NULL);
	return lr;
}


LRESULT CVelocityPage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctStrength.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
        lr = m_ctLowLimit.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctHighLimit.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctCurveStart.MessageHandler(uMsg, wParam, lParam, bHandled);
	if (!bHandled)
        lr = m_ctCurveEnd.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
    DrawCurve(NULL);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\transposepage.cpp ===
// TransposePage.cpp : Implementation of CTransposePage
#include "stdafx.h"
#include "ToolProps.h"
#include "TransposePage.h"

/////////////////////////////////////////////////////////////////////////////
// CTransposePage

CTransposePage::CTransposePage() 
{
	m_dwTitleID = IDS_TITLETransposePage;
	m_dwHelpFileID = IDS_HELPFILETransposePage;
	m_dwDocStringID = IDS_DOCSTRINGTransposePage;
    m_pTranspose = NULL;
}

CTransposePage::~CTransposePage()

{
    if (m_pTranspose)
    {
        m_pTranspose->Release();
    }
}

STDMETHODIMP CTransposePage::SetObjects(ULONG cObjects,IUnknown **ppUnk)

{
	if (cObjects < 1 || cObjects > 1)
	    return E_UNEXPECTED;
	return ppUnk[0]->QueryInterface(IID_IDirectMusicTransposeTool,(void **) &m_pTranspose);
}


STDMETHODIMP CTransposePage::Apply(void)

{
    m_pTranspose->SetTranspose((long) m_ctTranspose.GetValue());
    m_pTranspose->SetType(m_ctType.GetValue());
	m_bDirty = FALSE;
	return S_OK;
}

LRESULT CTransposePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	if (m_pTranspose)
    {
        static char *pTypes[2] = { "Linear","In Scale"};
        m_ctTranspose.Init(GetDlgItem(IDC_TRANSPOSE),GetDlgItem(IDC_TRANSPOSE_DISPLAY),-24,24,true);
        m_ctType.Init(GetDlgItem(IDC_TYPE),IDC_TYPE,pTypes,2);

        DWORD dwType;
        m_pTranspose->GetType(&dwType);
        m_ctType.SetValue(dwType);
        long lTranspose;
        m_pTranspose->GetTranspose(&lTranspose);
        m_ctTranspose.SetValue((float)lTranspose);
    }
	return 1;
}

LRESULT CTransposePage::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctTranspose.MessageHandler(uMsg, wParam,lParam, bHandled);
	if (!bHandled)
        lr = m_ctType.MessageHandler(uMsg, wParam, lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}


LRESULT CTransposePage::OnSlider(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled)

{
	LRESULT lr = m_ctTranspose.MessageHandler(uMsg, wParam,lParam, bHandled);
    if (bHandled)
        SetDirty(true);
	return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\toolprops.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sun May 21 19:29:49 2000
 */
/* Compiler settings for C:\nt\multimedia\Directx\dmusic\dmtoolprp\ToolProps.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __ToolProps_h__
#define __ToolProps_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __EchoPage_FWD_DEFINED__
#define __EchoPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class EchoPage EchoPage;
#else
typedef struct EchoPage EchoPage;
#endif /* __cplusplus */

#endif 	/* __EchoPage_FWD_DEFINED__ */


#ifndef __TransposePage_FWD_DEFINED__
#define __TransposePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransposePage TransposePage;
#else
typedef struct TransposePage TransposePage;
#endif /* __cplusplus */

#endif 	/* __TransposePage_FWD_DEFINED__ */


#ifndef __DurationPage_FWD_DEFINED__
#define __DurationPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class DurationPage DurationPage;
#else
typedef struct DurationPage DurationPage;
#endif /* __cplusplus */

#endif 	/* __DurationPage_FWD_DEFINED__ */


#ifndef __QuantizePage_FWD_DEFINED__
#define __QuantizePage_FWD_DEFINED__

#ifdef __cplusplus
typedef class QuantizePage QuantizePage;
#else
typedef struct QuantizePage QuantizePage;
#endif /* __cplusplus */

#endif 	/* __QuantizePage_FWD_DEFINED__ */


#ifndef __TimeShiftPage_FWD_DEFINED__
#define __TimeShiftPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class TimeShiftPage TimeShiftPage;
#else
typedef struct TimeShiftPage TimeShiftPage;
#endif /* __cplusplus */

#endif 	/* __TimeShiftPage_FWD_DEFINED__ */


#ifndef __SwingPage_FWD_DEFINED__
#define __SwingPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class SwingPage SwingPage;
#else
typedef struct SwingPage SwingPage;
#endif /* __cplusplus */

#endif 	/* __SwingPage_FWD_DEFINED__ */


#ifndef __VelocityPage_FWD_DEFINED__
#define __VelocityPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class VelocityPage VelocityPage;
#else
typedef struct VelocityPage VelocityPage;
#endif /* __cplusplus */

#endif 	/* __VelocityPage_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __TOOLPROPSLib_LIBRARY_DEFINED__
#define __TOOLPROPSLib_LIBRARY_DEFINED__

/* library TOOLPROPSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TOOLPROPSLib;

EXTERN_C const CLSID CLSID_EchoPage;

#ifdef __cplusplus

class DECLSPEC_UUID("5337AF8F-3827-44DD-9EE9-AB6E1AABB60F")
EchoPage;
#endif

EXTERN_C const CLSID CLSID_TransposePage;

#ifdef __cplusplus

class DECLSPEC_UUID("691BD8C2-2B07-4C92-A82E-92D858DE23D6")
TransposePage;
#endif

EXTERN_C const CLSID CLSID_DurationPage;

#ifdef __cplusplus

class DECLSPEC_UUID("79D9CAF8-DBDA-4560-A8B0-07E73A79FA6B")
DurationPage;
#endif

EXTERN_C const CLSID CLSID_QuantizePage;

#ifdef __cplusplus

class DECLSPEC_UUID("623286DC-67F8-4055-A9BE-F7A7176BD150")
QuantizePage;
#endif

EXTERN_C const CLSID CLSID_TimeShiftPage;

#ifdef __cplusplus

class DECLSPEC_UUID("7D3BDEE7-9557-4085-82EE-1B2F02CE4BA6")
TimeShiftPage;
#endif

EXTERN_C const CLSID CLSID_SwingPage;

#ifdef __cplusplus

class DECLSPEC_UUID("0B237E01-062A-4A40-8D43-4B5FCD49965A")
SwingPage;
#endif

EXTERN_C const CLSID CLSID_VelocityPage;

#ifdef __cplusplus

class DECLSPEC_UUID("30EC7213-64BE-4EF6-BB1B-463427EC864B")
VelocityPage;
#endif
#endif /* __TOOLPROPSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\timeshiftpage.h ===
// TimeShiftPage.h : Declaration of the CTimeShiftPage

#ifndef __TIMESHIFTPAGE_H_
#define __TIMESHIFTPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_TimeShiftPage;

/////////////////////////////////////////////////////////////////////////////
// CTimeShiftPage
class ATL_NO_VTABLE CTimeShiftPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTimeShiftPage, &CLSID_TimeShiftPage>,
	public IPropertyPageImpl<CTimeShiftPage>,
	public CDialogImpl<CTimeShiftPage>
{
public:
	CTimeShiftPage();
    virtual ~CTimeShiftPage();

	enum {IDD = IDD_TIMESHIFTPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_TIMESHIFTPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTimeShiftPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTimeShiftPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	CHAIN_MSG_MAP(IPropertyPageImpl<CTimeShiftPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    void SetTimeUnitRange();
    IDirectMusicTimeShiftTool *  m_pTimeShift;
    CComboHelp                   m_ctTimeUnit;
    CSliderValue                 m_ctRange;
    CSliderValue                 m_ctOffset;
};

#endif //__TIMESHIFTPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\toolprops.cpp ===
// ToolProps.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ToolPropsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ToolProps.h"

#include "ToolProps_i.c"
#include "EchoPage.h"
#include "TransposePage.h"
#include "DurationPage.h"
#include "QuantizePage.h"
#include "TimeShiftPage.h"
#include "SwingPage.h"
#include "VelocityPage.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_EchoPage, CEchoPage)
OBJECT_ENTRY(CLSID_TransposePage, CTransposePage)
OBJECT_ENTRY(CLSID_DurationPage, CDurationPage)
OBJECT_ENTRY(CLSID_QuantizePage, CQuantizePage)
OBJECT_ENTRY(CLSID_TimeShiftPage, CTimeShiftPage)
OBJECT_ENTRY(CLSID_SwingPage, CSwingPage)
OBJECT_ENTRY(CLSID_VelocityPage, CVelocityPage)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TOOLPROPSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\daytona\makefile.inc ===
buildidl : $(O)\toolprops.h

$(O)\toolprops.h : ..\toolprops.idl
    $(MIDL) \
    $(INCPATH0) \
    $(C_DEFINES) \
    -header $(O)\toolprops.h \
    -tlb     $O\toolprops.tlb \
    -iid     $O\toolprops_i.c  \
    -dlldata $(PROXY_DIR)\dlldata.c  \
    -proxy   $(PROXY_DIR)\toolprops_p.c  \
    ..\toolprops.idl
    copy $(O)\toolprops_i.c $(DXROOT)\dmusic\shared\toolprops_i.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\velocitypage.h ===
// VelocityPage.h : Declaration of the CVelocityPage

#ifndef __VELOCITYPAGE_H_
#define __VELOCITYPAGE_H_

#include "resource.h"       // main symbols
#include "..\dmtool\tools.h"
#include "ControlHelp.h"

EXTERN_C const CLSID CLSID_VelocityPage;

/////////////////////////////////////////////////////////////////////////////
// CVelocityPage
class ATL_NO_VTABLE CVelocityPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVelocityPage, &CLSID_VelocityPage>,
	public IPropertyPageImpl<CVelocityPage>,
	public CDialogImpl<CVelocityPage>
{
public:
	CVelocityPage();
    virtual ~CVelocityPage();

	enum {IDD = IDD_VELOCITYPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_VELOCITYPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVelocityPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CVelocityPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
	MESSAGE_HANDLER(WM_COMMAND, OnCommand);
	MESSAGE_HANDLER(WM_HSCROLL, OnSlider);
	MESSAGE_HANDLER(WM_PAINT, OnPaint);
	CHAIN_MSG_MAP(IPropertyPageImpl<CVelocityPage>)
END_MSG_MAP()
// Handler prototypes:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSlider(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    STDMETHOD(SetObjects)(ULONG cObjects,IUnknown **ppUnk);
	STDMETHOD(Apply)(void);
private:
    IDirectMusicVelocityTool *  m_pVelocity;
    CSliderValue                m_ctStrength;
    CSliderValue                m_ctLowLimit;
    CSliderValue                m_ctHighLimit;
    CSliderValue                m_ctCurveStart;
    CSliderValue                m_ctCurveEnd;
    RECT                        m_rectDisplay;
    void                        DrawCurve(HDC hDCIn);
};

#endif //__VELOCITYPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmtoolprp\win9x\makefile.inc ===
buildidl : $(O)\toolprops.h

$(O)\toolprops.h : ..\toolprops.idl
    $(MIDL) \
    $(INCPATH0) \
    $(C_DEFINES) \
    -header $(O)\toolprops.h \
    -tlb     $O\toolprops.tlb \
    -iid     $O\toolprops_i.c  \
    -dlldata $(PROXY_DIR)\dlldata.c  \
    -proxy   $(PROXY_DIR)\toolprops_p.c  \
    ..\toolprops.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMUSIC"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\des8.h ===
//------------------------------------------------------------------------------
//                                                                       
//   des8.h -- Design of DirectX 8 interfaces for DirectMusic 
//                                                                       
//   Copyright (c) 1998-1999 Microsoft Corporation
//                                                                       
//------------------------------------------------------------------------------
//
// Prototypes for new DirectX 8 interfaces for DirectMusic core
//
// This header discusses interfaces which manange wave playback between
// the wave object, the DirectMusic port, and a DirectMusic software synth.
// It does not address communication between the wave track and the wave 
// object or the software synth and DirectSound, or directly between the
// wave object and DirectSound.
//
// These interfaces are based on my understanding of our recent hallway
// discussions.
//
// Issues which need futher discussion are marked with XXX.
//
// 

//
// New schedule breakdown
//
// 1. Port (synth and WDM)
//    a. IDirectMusicPort::DownloadWave
//       Code is very similar for WDM or software synth
//       i.   Get needed information from WO and create IDirectSoundSource   0.5    
//       ii.  If oneshot, track and download header and wave data            3.5
//       iii. If streaming, download header                                  0.5
//
//    b. IDirectMusicPort::UnloadWave
//       i.   Arbitrate with device for 0 refcount of download               1.0
//
//    c. IDirectMusicPort::AllocVoice
//       i.   Allocate voice ID                                              0.5
//       ii.  If streaming, allocate preread samples and streaming buffers   2.5
//
//    d. Voice Service Thread
//       i.   Init and shutdown code at port create/destroy                  1.0
//       ii.  Call listed voices every ~100 ms                               0.5
//
//    e. CDirectMusicVoice::Service
//       i.   Communicate with device to determine each voice position       0.5
//       ii.  Calculate how much more wave data is needed                    1.0
//       iii. Fill wave data from IDirectSoundSource and send to device      1.0
//       iv.  Determine when playback is complete and stop voice             0.5
//
//    f. IDirectMusicVoice::Play
//       i.   Communicate request to device                                  0.3
//       ii.  Send down timestamped preread data                             0.3
//       iii. Insert into VST                                                0.3
//
//    g. IDirectMusicVoice::Stop
//       i.   Flag voice as stopped                                          0.5
//       ii.  Forward request to device                                      0.0
//
//    h. Setup and connection
//
//    i. Move sink code into DSound                                          3.0
//    
//      
                                                                           15.5
//
// Things to change
//
// * We will model the DownloadWave interface after the Download interface 
//   and will pass things down to the synth as such:
//
//   DLH + WAD -> Download header + Wave Articulation Data
//                                  (contains loop points and count, etc.)
//
//   DLH + DATA -> Download header + data
//   
// * For oneshot data we want to do download refcounting like we do for
//   regular DLS downloads. For streams we do not since the data that comes
//   down in each download is the next set of data for the device to play.
//
// Download waves first, then wave articulations
// Separate multichannel downloads
// Rotating buffers and refresh for streaming
//   

// New generic typedefs and #defines
//
typedef ULONGLONG SAMPLE_TIME;                  // Sample position w/in stream
typedef SAMPLESPOS *PSAMPLE_TIME;

#define DMUS_DOWNLOADINFO_WAVEARTICULATION  4   // Wave articulation data 
#define DMUS_DOWNLOADINFO_STREAMINGWAVE     5   // One chunk of a streaming
                                                // wave 
                                                
// This is built by the wave object from the 'smpl' chunk embedded in the
// wave file if there is one, else it is just defaults.
//                    
typedef struct _DMUS_WAVEART
{
    DWORD               cbSize;                 // As usual
    WSMPL               WSMP;                   // Wave sample as per DLS1
    WLOOP               WLOOP[1];               // If cSampleCount > 1    
} DMUS_WAVEART; 


//------------------------------------------------------------------------------
//
// IDirectSoundSource
//
// An IDirectSound source is the interface to what we've been calling the
// viewport object.
//
// 
//
interface IDirectSoundSource
{  
    // Init
    //
    // Gives the interface of the connected sink
    STDMETHOD(Init)
    (THIS_
        IDirectSoundSink *pSink                 // Connected sink
    );
    
    // GetFormat
    //
    // Returns the format the source is returning the wave data in
    //
    STDMETHOD(GetFormat)
        (THIS_
         LPWAVEFORMATEX *pwfx,                  // Wave format to fill in
         LPDWORD pcbwfx                         // Size of wave format,
                                                // returns actual size
        ) PURE;
                                                      
    // Seek
    //
    // Seek to the given sample position in the stream. May be inexact
    // due to accuracy settings of wave object. To account for this
    //          
    STDMETHOD(Seek)
        (THIS_
         SAMPLEPOS sp                           // New sample position         
        ) PURE;

    // Read
    //
    // Read the given amount of sample data into the provided buffer starting
    // from the read cursor. The read cursor is set with seek and advanced
    // with each successive call to Read.
    //
    STDMETHOD(Read)
        (THIS_
         LPVOID *ppvBuffer,                     // Array of pvBuffer's
         DWORD cpvBuffer,                       // and how many are passed in
         PSAMPLEPOS pcb                         // In: number of samples to read
                                                // Out: number of samples read
        ) PURE;    
        
    // GetSize
    //
    // Returns the size of the entire wave, in bytes, in the requested format
    //
    STDMETHOD(GetSize)
        (THIS_
         PULONG *pcb                            // Out: Bytes in stream
        ) PURE;
};

//------------------------------------------------------------------------------
//
// IDirectSoundSink
//
// An IDirectSound sink is the interface which feeds itself from one 
// IDirectSoundSource. It is based on the IDirectMusicSynthSink interface
// 
//
interface IDirectSoundSink
{
    // Init
    //
    // Sets up the source to render from
    //
    STDMETHOD(Init)
    (THIS_
        IDirectSoundSource *pSource             // The source from which we read
    ) PURE;
    
    // SetMasterClock
    //
    // Sets the master clock (reference time) to use
    //
    STDMETHOD(SetMasterClock)
    (THIS_
        IReferenceClock *pClock                 // Master timebase
    ) PURE;
    
    // GetLatencyClock
    //
    // Returns the clock which reads latency time, relative to 
    // the master clock
    //
    STDMETHOD(GetLatencyClock)
    (THIS_
        IReferenceClock **ppClock               // Returns latency clock
    ) PURE;
    
    // Activate
    //
    // Starts or stops rendering
    //
    STDMETHOD(Activate)
    (THIS_
        BOOL fEnable                            // Get ready or stop
    ) PURE;
    
    // SampleToRefTime
    //
    // Converts a sample position in the stream to
    // master clock time
    //
    STDMETHOD(SampleToRefTime)
    (THIS_
        SAMPLE_TIME sp,                         // Sample time in
        REFERENCE_TIME *prt                     // Reference time out
    ) PURE;
    
    // RefToSampleTime
    //
    // Converts a reference time to the nearest
    // sample
    //
    STDMETHOD(RefToSampleTime)
    (THIS_
        REFERENCE_TIME rt,                      // Reference time in
        SAMPLE_TIME *psp                        // Sample time out
    ) PURE;
};

//------------------------------------------------------------------------------
//
// IDirectSoundWave
//
// Public interface for the wave object
//
#define DSWCS_F_DEINTERLEAVED 0x00000001        // Multi-channel data as
                                                // multiple buffers

interface IDirectSoundWave
{
    // GetWaveArticulation
    //
    // Returns wave articulation data, either based on a 'smpl' chunk 
    // from the wave file or a default.
    //
    STDMETHOD(GetWaveArticulation)
    (THIS_
        WAVEARTICULATION *pArticulation         // Articulation to fill in
    ) PURE;
    
    // CreateSource
    //
    // Creates a new IDirectSoundSource to read wave data from
    // this wave
    //
    STDMEHTOD(CreateSource)
    (THIS_
        IDirectSoundSource **ppSource           // Created viewport object
        LPWAVEFORMATEX pwfex,                   // Desired format
        DWORD dwFlags                           // DSWCS_xxx
    ) PURE;
};

//------------------------------------------------------------------------------
//
// IDirectMusicPort8
//
// 
//

#define DMDLW_STREAM                            0x00000001

interface IDirectMusicPort8 extends IDirectMusicPort
{ 
    // DownloadWave
    //
    // Creates a downloaded wave object representing the wave on this
    // port. 
    //
    STDMETHOD(DownloadWave)
        (THIS_
         IDirectSoundWave *pWave,               // Wave object
         ULONGLONG rtStart,                     // Start position (stream only)
         DWORD dwFlags,                         // DMDLW_xxx
         IDirectSoundDownloadedWave **ppWave    // Returned downloaded wave
        ) PURE;
        
    // UnloadWave
    //
    // Releases the downloaded wave object as soon as there are no voices
    // left referencing it.
    //
    STDMETHOD(UnloadWave)
        (THIS_ 
         IDirectSoundDownloadedWave *pWave      // Wave to unload
        ) PURE;

    // AllocVoice
    //
    // Allocate one playback instance of the downloaded wave on this
    // port.
    //
    STDMETHOD(AllocVoice)
        (THIS_
         IDirectSoundDownloadedWave *pWave,     // Wave to play on this voice
         DWORD dwChannel,                       // Channel and channel group
         DWORD dwChannelGroup,                  //  this voice will play on
         SAMPLE_TIME stReadAhead,               // How much to read ahead
         IDirectMusicVoice **ppVoice            // Returned voice
        ) PURE;        
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// DownloadWave (normal use)
//   
// 1. Application calls GetObject to load segment which contains a wave track.
//    This causes GetObject to be called on all related waves, creating wave
//    objects for all of them. 
//
// 2. Wave track calls SetParam on each wave object to set up author-time 
//    parameters on the wave. This includes:
//    - One-shot versus stream-ness
//    - Readahead amount
//
// 3. Application calls SetParam(GUID_Download,...) to force download. As well
//    as downloading DLS instruments (band track), the wave track calls 
//    DownloadWave for every wave to download. (Note: are we using the same GUID
//    for download? It doesn't appear that SetParam on a segment is broadcast
//    too all tracks, but rather is sent to the first track that understands
//    the GUID, or the nth if an index is given. This would mean that 
//    the application would have to call SetParam twice with the same GUID 
//    and a different track index if there are both band and wave tracks 
//    in the segment??
//
//    Returned is an IDirectMusicDownloadedWave(DirectSound?) to track the wave.
//
//    The following happen during the DownloadWave method call:
//
// 4. The port queries the wave object for the stream-ness and readahead
//    properties. 
//
// XXX We decided that these things were per wave object, right? 
//     (As opposed to the viewport). And the wave object already knows them or 
//     is the right object to provide reasonable defaults. 
//
// 5. The port requests a viewport from the wave object in its native format.
//
// 6. The port allocates buffer space. The buffer must be big enough to handle
//    the entire wave in the case of the one shot, or at least big enough to
//    handle the readahead samples in the streaming case. The streaming buffer
//    may be allocated larger, however, if it is going to be used for the
//    entire streaming session. Buffer choice here may be affected by the
//    underlying port. 
//
//    I assume we are going to parallel the DLS architecture as much as 
//    possible here and are going to be able to trigger a downloaded wave
//    more than once at the same time. In that case the buffer would have
//    to be stored in the _voice_, not the DownloadedWave (except perhaps
//    for the readahead which should always be kept around). Is this 
//    duplication of effort if we're going to be caching in the wave
//    object as well?
//
// 7. If the wave is a one-shot, then the port will request the entire data
//    for the wave from the viewport and downloads it to the device. At this
//    point the viewport is released since the entire data for the wave is in
//    the synth. If the wave is streaming, then nothing is done at the device
//    level.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// UnloadWave
//
// This tells the port that the application is done with the wave as soon as
// there are no more voice references to it. Internally it just calls 
// Release() on the downloaded wave object. The dlwave object can then no longer
// be used to create voices. However, the dlwave will only really be released
// once all voices that currently use it are released.
//
// This is identical to calling Release() on the dlwave object directly
// (why does it exist?)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// AllocVoice
//
// Allocate a voice object to play back the a wave on a channel group
//
// This call is simple. All it does it ask the synth for a voice ID (which
// is just a cookie that only has meaning to the synth) and creates the voice
// object.
//
// At this point the download is bound to the channel, since MIDI articulations
// sent to the voice before playback begins will need to know that.
//
// The voice object addref's the downloaded wave object.
//

//------------------------------------------------------------------------------
//
// IDirectMusicVoice 
//
// One playback instance of a downloaded wave on a port
//
// Note that since we're already bound to a channel after the voice is
// created, we don't need any methods on the voice object for MIDI
// articulation. That can just go through the normal synth mechanism.
//
interface IDirectMusicVoice
{
public:
    // Play
    //
    STDMETHOD(Play)
        (_THIS
         REFERENCE_TIME rtStart,                // Time to play
         REFERENCE_TIME rtStartInWave           // XXX Move this
                                                // Where in stream to start         
        ) PURE;
    
    // Should stop be scheduled or immediate?
    //    
    STDMETHOD(Stop)
        (_THIS                                  
          REFERENCE_TIME rtStop,                // When to stop
        ) PURE;
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// QueryInterface(IID_IKsControl)
//
// All of the effects control should be in the DirectSound side now. 
// However, IKsControl can still be used as in 6.1 and 7 to determine
// synth caps.
// 
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// Play
//
// XXX I am not sure this is the right place to deal with preread. However, 
//     we can't deal with it at DownloadWave(), because we don't know at that
//     point where to start (the app may play the stream from different
//     starting points on different voice). We *could* do it at voice allocation
//     time; that would just mean that the stream start position is fixed for
//     a particular voice no matter how many times the voice is triggered.
//     This is an issue because preread may take some time if decompression is
//     taking place and the seek request is far into the wave; it may cause
//     problems with low-latency Play commands.
//
//     Note that I am delegating the quality versus efficiency flag to private
//     communication between the wave object and the wave track or application.
//
// 1. Call Play() on the synth voice ID associated with this voice. If the 
//    associated wave is a one-shot, this is all that needs to be done.
//
// 2. For a stream, no preread data has been allocated yet. Tell the wave
//    object to seek to the given position and preread. Give the preread data
//    to the device via StreamVoiceData().
//
// 3. If the associated wave is a stream, insert this voice into the voice
//    service list. This will cause push-pull arbiration to be done on the
//    voice until it finishes or Stop() is called.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// Stop
//
// 1. Call Stop() on the synth voice.
//
// 2. If the voice is streaming and not done, pull it from the voice service
//    thread.
//

//------------------------------------------------------------------------------
//
// IDirectMusicSynth8
//
// New methods on the synthesizer interface for managing wave playback.
// A parallel to these methods will be needed on a hardware synth, probably
// implemented as a property set.
//
interface IDirectMusicSynth8 extends IDirectMusicSynth
{ 
public:
    STDMETHOD(DownloadWave)
        (THIS_
         LPHANDLE pHandle,                  // Returned handle representing DL
         LPVOID pvData,                     // Initial data
                                            // XXX >1 channel -> buffers?
         LPBOOL pbFree,                     // Is port allowed to free data?
         BOOL bStream                       // This is preroll data for a stream                                        
        ) PURE;
        
    STDMETHOD(UnloadWave)               
        (THIS_ 
         HANDLE phDownload,                 // Handle from DownloadWave
         HRESULT (CALLBACK *pfnFreeHandle)(HANDLE,HANDLE), 
                                            // Callback to call when done
                                            
         HANDLE hUserData                   // User data to pass back in 
                                            // callback
        ) PURE; 
        
    STDMETHOD(PlayVoice)
        (THIS_
         REFERENCE_TIME rt,                 // Time to start playback
         DWORD dwVoiceId,                   // Voice ID allocated by port
         DWORD dwChannelGroup,              // Channel group and
         DWORD dwChannel,                   // channel to start voice on
         DWORD dwDLId                       // Download ID of the wave to play
                                            // (This will be of the wave 
                                            // articulation)
        ) PURE;
        
    STDMETHOD(StopVoice)
        (THIS_
         DWORD dwVoice,                     // Voice to stop
         REFERENCE_TIME rt                  // When to stop
        ) PURE;
        
    struct VOICE_POSITION
    {
        ULONGLONG   ullSample;              // Sample w/in wave
        DWORD       dwSamplesPerSec;        // Playback rate at current pitch
    };
    
    STDMETHOD(GetVoicePosition)
        (THIS_
         HANDLE ahVoice[],                  // Array of handles to get position
         DWORD cbVoice,                     // Elements in ahVoice and avp
         VOICE_POSITION avp[]               // Returned voice position
        ) PURE;
        
    STDMETHOD(StreamVoiceData)
        (THIS_
         HANDLE hVoice,                     // Which voice this data is for
         LPVOID pvData,                     // New sample data
         DWORD cSamples                     // Number of samples in pvData
        ) PURE;        
};
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// DownloadWave
//
// This could be the same as Download except that we need to deal with
// the streaming case.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// UnloadWave
//
// Works just like Unload. In the streaming case, the callback will be
// called after _all_ data in the stream is free. Note that if UnloadWave
// is called while the wave is still playing, this could be quite some
// time.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// PlayVoice
//
// Schedule the voice to be played. The synth already has the data 
// for a oneshot wave, so starting playback is very fast. If the data is
// to be streamed it is the caller's responsibility (i.e. the port) to 
// keep the stream fed via StreamVoiceData()
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// StopVoice 
//
// Just what it says.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// GetVoicePosition
//
// This call retrieves the position of a set of voices. For each voice, the
// current sample position relative to the start of the stream and the 
// average number of samples per second at the current pitch is returned. This
// gives the caller all the information it needs to stay ahead of the 
// voice playback. This call is intended for use on streaming voices.
//
// Note that the playback position is an implication that all data up to the
// point of that sample is done with and the buffer space can be freed. This
// allows recycling of buffers in a streaming wave.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// StreamVoiceData
//
// This call queues more data for a streaming voice. 
//
// XXX This implies that there will be a discontinuity in the memory used
// by the synth mixer. How do we deal with that?
//
//

//------------------------------------------------------------------------------
//
// General questions and discussion
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -               
//
// What can be underneath a DirectMusic port? 
//
// In 6.1 and 7 this was easy; either a SW synth on top of DSound 
// (synth port), or a kernel sw synth or hw synth (WDM port). (Not
// counting the dmusic16 code which will not be changing in 8).
//
// What are the scenarios we have now? Does it make sense (or is it even
// possible in light of backwards compat) to change what a port wraps?
// The two scenarios which match the existing ports are:
//
// Scenario: Software synthesizer on top of DirectSound as we have today.
// The hookup logic changes (we're talking n mono busses, etc.) but the 
// mechanics do not: the application can still just hand us a DirectSound
// object and we connect it to the bottom of the synthesizer. This still has
// to work with pre-8 applications making the same set of API calls they
// always did, but internally it can be totally different.
// XXX Did we ever expose the IDirectMusicSynthSink and methods for hooking
// it up? Can this change? (It has to...) I _think_ this was a DDK thing...
// The application can also create a DX8 DirectSound buffer with all the
// bells and whistles and have that work as well. We need some (DX8) specific
// mechanism for routing what goes out of the synth into the n mono inputs
// of the DirectSound buffer if it's more than just a legacy stereo buffer.
// 
//
// Scenario: We sit on top of a hardware or KM synth on top of *everything*
// else in kernel mode. We need private communication between DirectMusic,
// DirectSound, and SysAudio in order to hook this up, or we need to
// delegate the graph building tasks totally to DirectSound and have it
// deal exlusively with SysAudio connections. The latter is probably the
// way to go. In this case we fail if we cannot get a WDM driver under
// DirectSound to talk to, or if the DirectSound buffer is not totally in
// hardware. (This all argues for having DirectSound be able to instantiate
// the KM synth on top of the buffer rather than arbitrating with DirectMusic
// to do it). We need to define this interface ASAP.
// (Me, Dugan, Mohan, MikeM).
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dlsstrm.h ===
//
// dlsstrm.h
//
// Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
//


#ifndef DMSTRM_H
#define DMSTRM_H

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
    RIFFIO *    GetChunk() { return m_pChunk; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // #ifndef DLSSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmart.cpp ===
//
// dmart.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#include "dmusicc.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmart.h"
#include "dmcrchk.h"
#include "dls2.h"

#define FIVE_HERTZ  (-55791972)
#define MIN_TIME    (-783819269)    // Time cents for one ms.

// To support legacy articulation connection blocks
// Generic Destinations
#define CONN_DST_RESERVED          0x0002

// EG1 Destinations
#define CONN_DST_EG1_RESERVED      0x0208

// EG2 Destinations
#define CONN_DST_EG2_RESERVED      0x030c


CArticData::CArticData()

{
    m_ConnectionList.cbSize = sizeof(CONNECTIONLIST);
    m_ConnectionList.cConnections = 0;
    m_pConnections = NULL;
}

CArticData::~CArticData()

{
    if (m_pConnections) delete[] m_pConnections;
}

HRESULT CArticData::GenerateLevel1(DMUS_ARTICPARAMS *pParamStruct)

{
    if (pParamStruct)
    {
	    ZeroMemory(pParamStruct, sizeof(DMUS_ARTICPARAMS));
	    
        pParamStruct->LFO.pcFrequency = FIVE_HERTZ;
        pParamStruct->LFO.tcDelay = MIN_TIME;

	    pParamStruct->VolEG.tcAttack = MIN_TIME;
        pParamStruct->VolEG.tcDecay = MIN_TIME;
        pParamStruct->VolEG.ptSustain = 1000 << 16;
        pParamStruct->VolEG.tcRelease = MIN_TIME;
    
	    pParamStruct->PitchEG.tcAttack = MIN_TIME;
        pParamStruct->PitchEG.tcDecay = MIN_TIME;
        pParamStruct->PitchEG.ptSustain = 1000 << 16;
        pParamStruct->PitchEG.tcRelease = MIN_TIME;

        DWORD dwIndex;
        CONNECTION *pConnection;
		for (dwIndex = 0; dwIndex < m_ConnectionList.cConnections; dwIndex++)
		{
            pConnection = &m_pConnections[dwIndex];
			switch (pConnection->usSource)
			{
			case CONN_SRC_NONE :
				switch (pConnection->usDestination)
				{
				case CONN_DST_LFO_FREQUENCY :
					pParamStruct->LFO.pcFrequency =
						(PCENT) pConnection->lScale;
					break;
				case CONN_DST_LFO_STARTDELAY :
					pParamStruct->LFO.tcDelay =
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_ATTACKTIME :
					pParamStruct->VolEG.tcAttack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_DECAYTIME :
					pParamStruct->VolEG.tcDecay = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_RESERVED :
					pParamStruct->VolEG.ptSustain = 
						(PERCENT) pConnection->lScale << 16;
					break;
				case CONN_DST_EG1_SUSTAINLEVEL :
					pParamStruct->VolEG.ptSustain = 
						(PERCENT) pConnection->lScale;
					break;
				case CONN_DST_EG1_RELEASETIME :
					pParamStruct->VolEG.tcRelease = 
						(TCENT) pConnection->lScale; 
					break;
				case CONN_DST_EG2_ATTACKTIME :
					pParamStruct->PitchEG.tcAttack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_DECAYTIME :
					pParamStruct->PitchEG.tcDecay = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_RESERVED :
					pParamStruct->PitchEG.ptSustain = 
						(PERCENT) pConnection->lScale << 16;
					break;
				case CONN_DST_EG2_SUSTAINLEVEL :
					pParamStruct->PitchEG.ptSustain = 
						(PERCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_RELEASETIME :
					pParamStruct->PitchEG.tcRelease = 
						(TCENT) pConnection->lScale; 
					break;
				case CONN_DST_RESERVED :
					pParamStruct->Misc.ptDefaultPan = 
						(PERCENT) pConnection->lScale << 16;
					break;
				case CONN_DST_PAN :
					pParamStruct->Misc.ptDefaultPan = 
						(PERCENT) pConnection->lScale;
					break;
				}
				break;
			case CONN_SRC_LFO :
				switch (pConnection->usControl)
				{
				case CONN_SRC_NONE :
					switch (pConnection->usDestination)
					{
					case CONN_DST_ATTENUATION :
						pParamStruct->LFO.gcVolumeScale = 
							(GCENT) pConnection->lScale; 
						break;
					case CONN_DST_PITCH :
						pParamStruct->LFO.pcPitchScale = 
							(PCENT) pConnection->lScale; 
						break;
					}
					break;
				case CONN_SRC_CC1 :
					switch (pConnection->usDestination)
					{
					case CONN_DST_ATTENUATION :
						pParamStruct->LFO.gcMWToVolume = 
							(GCENT) pConnection->lScale; 
						break;
					case CONN_DST_PITCH :
						pParamStruct->LFO.pcMWToPitch = 
							(PCENT) pConnection->lScale; 
						break;
					}
					break;
				}
				break;
			case CONN_SRC_KEYONVELOCITY :
				switch (pConnection->usDestination)
				{
				case CONN_DST_EG1_ATTACKTIME :
					pParamStruct->VolEG.tcVel2Attack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_ATTACKTIME :
					pParamStruct->PitchEG.tcVel2Attack = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_ATTENUATION :
					break;
				}
				break;
			case CONN_SRC_KEYNUMBER :
				switch (pConnection->usDestination)
				{
				case CONN_DST_EG1_DECAYTIME :
					pParamStruct->VolEG.tcKey2Decay = 
						(TCENT) pConnection->lScale;
					break;
				case CONN_DST_EG2_DECAYTIME :
					pParamStruct->PitchEG.tcKey2Decay = 
						(TCENT) pConnection->lScale;
					break;
				}
				break;
			case CONN_SRC_EG2 :
				switch (pConnection->usDestination)
				{
				case CONN_DST_PITCH :
					pParamStruct->PitchEG.pcRange = 
						(PCENT) pConnection->lScale; 
					break;
				}
				break;
			}
		
		}
	}
    return S_OK;
}

DWORD CArticData::Size()

{
    if (m_pConnections)
    {
        return (m_ConnectionList.cConnections * sizeof CONNECTION) + sizeof CONNECTIONLIST;
    }
    return 0;
}

BOOL CArticData::Write(void * pv, DWORD* pdwCurrentOffset)

{
    if (m_pConnections)
    {
        CONNECTIONLIST *pList = (CONNECTIONLIST *) pv;
        CONNECTION *pConnection = (CONNECTION *) ((BYTE *)pv + sizeof(CONNECTIONLIST));
        *pList = m_ConnectionList;
        memcpy(pConnection,m_pConnections,m_ConnectionList.cConnections * sizeof CONNECTION);
        *pdwCurrentOffset += Size();
    }
    return TRUE;
}

HRESULT CArticData::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;

    CONNECTION *pOldConnections = m_pConnections;
    DWORD dwOldCount = m_ConnectionList.cConnections;

	hr = pParser->Read(&m_ConnectionList, sizeof(m_ConnectionList));
	if(SUCCEEDED(hr))
	{	
        DWORD dwSize = m_ConnectionList.cConnections * sizeof(CONNECTION);
        if (dwSize > (pParser->GetChunk()->cksize - sizeof(CONNECTIONLIST)))
        {
            return E_FAIL;  // corrupt file.
        }
        m_pConnections = new CONNECTION[m_ConnectionList.cConnections + dwOldCount];
        if (m_pConnections)
        {
		    hr = pParser->Read(m_pConnections,dwSize);
            if (SUCCEEDED(hr))
            {
                if (pOldConnections && dwOldCount)
                {
                    memcpy(&m_pConnections[m_ConnectionList.cConnections],
                        pOldConnections,dwOldCount * sizeof(CONNECTION));
                    m_ConnectionList.cConnections += dwOldCount;
                }
            }
            else
            {
                delete[] m_pConnections;
                m_pConnections = pOldConnections;
                m_ConnectionList.cConnections = dwOldCount;

            }
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
            
	return hr;
}



//////////////////////////////////////////////////////////////////////
// Class CArticulation

//////////////////////////////////////////////////////////////////////
// CArticulation::CArticulation

CArticulation::CArticulation() 

{ 
    m_dwCountExtChk = 0; 
    m_fDLS1 = TRUE;
    m_fNewFormat = FALSE;
    m_fCSInitialized = FALSE;
//    InitializeCriticalSection(&m_DMArtCriticalSection);
    m_fCSInitialized = TRUE;
}

CArticulation::~CArticulation()

{
    if (m_fCSInitialized)
    {
    	Cleanup();
//    	DeleteCriticalSection(&m_DMArtCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Load

HRESULT CArticulation::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;

	RIFFIO ck;

//	EnterCriticalSection(&m_DMArtCriticalSection);

    pParser->EnterList(&ck);
    while (pParser->NextChunk(&hr))
    {
		switch(ck.ckid)
		{
        case FOURCC_CDL :
            hr = m_Condition.Load(pParser);
            break;
        case FOURCC_ART2 :
        case FOURCC_ART1 : 
            hr = m_ArticData.Load(pParser);
            break;
		default:
			// If we get here we have an unknown chunk
			CExtensionChunk* pExtensionChunk = new CExtensionChunk;
			if(pExtensionChunk)
			{
				hr = pExtensionChunk->Load(pParser);

				if(SUCCEEDED(hr))
				{
					m_ExtensionChunkList.AddHead(pExtensionChunk);
					m_dwCountExtChk++;
				}
				else
				{
					delete pExtensionChunk;
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			} 
			break;
		}
	}
    pParser->LeaveList();
	
	if(FAILED(hr))
	{
		Cleanup();
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);
    
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Cleanup

void CArticulation::Cleanup()
{
//	EnterCriticalSection(&m_DMArtCriticalSection);

/*    if (m_pArticTree)
    {
        delete m_pArticTree;
        m_pArticTree = NULL;
    }*/

	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		m_dwCountExtChk--;
		delete pExtChk;
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);

	assert(m_dwCountExtChk == 0);
}

DWORD CArticulation::Count()
{
	// Return the number of Offset Table entries needed during a call to Write
    if (m_Condition.m_fOkayToDownload)
    {
        DWORD dwCount = m_dwCountExtChk + 1;
        if (m_Condition.m_fOkayToDownload && m_ArticData.Size()) dwCount++;
        return dwCount;
    }
    return 0;
}

void CArticulation::SetPort(CDirectMusicPortDownload *pPort,BOOL fNewFormat, BOOL fSupportsDLS2)

{
    m_fNewFormat = fNewFormat;
    if (fSupportsDLS2)
    {
        m_Condition.Evaluate(pPort);
    }
    else
    {
        m_Condition.m_fOkayToDownload = m_fDLS1;
    }
}

BOOL CArticulation::CheckForConditionals()

{
    return  m_Condition.HasChunk();
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Size

DWORD CArticulation::Size()
{
	DWORD dwSize = 0;
	DWORD dwCountExtChk = 0;
	
    if (!m_Condition.m_fOkayToDownload)
    {
        return 0;
    }

//    EnterCriticalSection(&m_DMArtCriticalSection);


    if (m_fNewFormat)
    {
	    dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
    }
    else
    {
        dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));
    }
	
    if (m_Condition.m_fOkayToDownload && m_ArticData.Size())
    {
        if (m_fNewFormat)
        {
            dwSize += CHUNK_ALIGN(m_ArticData.Size());
        }
        else
        {
		    dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
	    }
    }

	// Calculate the space need for Articulation's extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
		dwSize += pExtChk->Size();
		dwCountExtChk++;
	}

	// We want to validate the number of extension chunks
	if(m_dwCountExtChk != dwCountExtChk)
	{
		assert(false);
		dwSize = 0;
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);

	return dwSize;
}

//////////////////////////////////////////////////////////////////////
// CArticulation::Write

HRESULT CArticulation::Write(void* pv, 
							 DWORD* pdwCurOffset, 
							 DWORD* pDMWOffsetTable,
							 DWORD* pdwCurIndex,
                             DWORD dwNextArtIndex)
{
	assert(pv);
	assert(pdwCurOffset);
	assert(pDMWOffsetTable);
	assert(pdwCurIndex);
	
    HRESULT hr = S_OK;
	
    if (!m_Condition.m_fOkayToDownload)
    {
        return hr;        // This actually should never happen.
    }   

//	EnterCriticalSection(&m_DMArtCriticalSection);

    DWORD dwRelativeCurOffset = 0;

    ULONG *pulFirstExtCkIdx = NULL;
        
    if (m_fNewFormat)
    {     
    	DMUS_ARTICULATION2* pArt = (DMUS_ARTICULATION2 *)pv;
        dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
	    (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
        pArt->ulNextArtIdx = dwNextArtIndex;
        if (m_ArticData.Size())
        {
            pDMWOffsetTable[*pdwCurIndex] = *pdwCurOffset;
		    pArt->ulArtIdx = (*pdwCurIndex)++;
            DWORD dwOffsetStart = *pdwCurOffset; 
            m_ArticData.Write((BYTE *)pv + dwRelativeCurOffset,pdwCurOffset);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);	
        }
        else
	    {
		    pArt->ulArtIdx = 0;
	    }
        pulFirstExtCkIdx = &pArt->ulFirstExtCkIdx;
    }
    else
    {
        DMUS_ARTICULATION* pArt = (DMUS_ARTICULATION *)pv;
	    dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));
	        (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));

	    if(m_ArticData.Size())
	    {
		    pDMWOffsetTable[*pdwCurIndex] = *pdwCurOffset;
		    pArt->ulArt1Idx = (*pdwCurIndex)++;

            m_ArticData.GenerateLevel1((DMUS_ARTICPARAMS*)
                ((BYTE *)pv + dwRelativeCurOffset));
		    dwRelativeCurOffset += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
		    (*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
	    }
	    else
	    {
		    pArt->ulArt1Idx = 0;
	    }
        pulFirstExtCkIdx = &pArt->ulFirstExtCkIdx;
    }

	// Write extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	if(pExtChk)
	{
		DWORD dwCountExtChk = m_dwCountExtChk;
        DWORD dwIndexNextExtChk;
        *pulFirstExtCkIdx = dwIndexNextExtChk = *pdwCurIndex;
		for(; pExtChk && SUCCEEDED(hr) && dwCountExtChk > 0; pExtChk = pExtChk->GetNext())
		{
			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk++;    // Add one, since the extension chunks are all in a row.
			}

			pDMWOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset;            
			hr = pExtChk->Write(((BYTE *)pv + dwRelativeCurOffset), 
								pdwCurOffset,
								dwIndexNextExtChk);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);		
			dwCountExtChk--;
		}
	}
	else
	{
		// If no extension chunks set to zero
		*pulFirstExtCkIdx = 0;
	}

//	LeaveCriticalSection(&m_DMArtCriticalSection);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dlsstrm.cpp ===
//
// dlsstrm.cpp
// 
// Copyright (c) 1995-1999 Microsoft Corporation. All rights reserved.
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmart.h ===
//
// dmart.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#ifndef DMART_H
#define DMART_H

#include "dmextchk.h"

class CRiffParser;

class CArticData 
{
public:
	CArticData();
	~CArticData();
    HRESULT         Load(CRiffParser *pParser);
    HRESULT         GenerateLevel1(DMUS_ARTICPARAMS *pParamStuct);
inline DWORD        Size();
    BOOL            Write(void *pv,DWORD* pdwCurrentOffset);
private:
    CONNECTIONLIST  m_ConnectionList;
    CONNECTION *    m_pConnections;
};


class CArticulation : public AListItem
{
public:
	CArticulation();
	~CArticulation();
	CArticulation* GetNext(){return(CArticulation*)AListItem::GetNext();}

	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, 
				  DWORD* pdwCurrentOffset, 
				  DWORD* pDMWOffsetTable,
				  DWORD* pdwCurIndex,
                  DWORD dwNextArtIndex);
    void SetPort(CDirectMusicPortDownload *pPort,BOOL fNewFormat, BOOL fSupportsDLS2);
    BOOL CheckForConditionals();
	DWORD Size();
	DWORD Count();

private:
	void Cleanup();

//	CRITICAL_SECTION	m_DMArtCriticalSection;
    BOOL                m_fCSInitialized;
    CArticData          m_ArticData;            // Articulation chunk from file.
    CExtensionChunkList	m_ExtensionChunkList;   // Unknown additional data chunks.
	DWORD				m_dwCountExtChk;        // Number of extension chunks.
    CConditionChunk     m_Condition;            // Optional conditional chunk;
    BOOL                m_fNewFormat;           // True if the synth handles the INSTRUMENT2 format.
public:
    BOOL                m_fDLS1;                // True if DLS1 chunk.
};

class CArticulationList : public AList
{
public:
	CArticulationList(){}
	~CArticulationList()
	{
		while(!IsEmpty())
		{
			CArticulation* pArticulation = RemoveHead();
			delete pArticulation;
		}
	}

    CArticulation* GetHead(){return (CArticulation *)AList::GetHead();}
	CArticulation* GetItem(LONG lIndex){return (CArticulation*)AList::GetItem(lIndex);}
    CArticulation* RemoveHead(){return(CArticulation *)AList::RemoveHead();}
	void Remove(CArticulation* pArticulation){AList::Remove((AListItem *)pArticulation);}
	void AddTail(CArticulation* pArticulation){AList::AddTail((AListItem *)pArticulation);}
};

#endif // #ifndef DMART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmbuffer.cpp ===
// dmbuffer.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Implementation of IDirectMusicBuffer
//
// @doc EXTERNAL
//
//
#include <objbase.h>
#include "debug.h"

#include "dmusicp.h"
#include "validate.h"

const GUID guidZero = {0};

static BYTE bMessageLength[128] = 
{
    // Channel
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Note off 0x80-0x8f
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Note on 0x90-0x9f
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Key pressure 0xa0-0xaf
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Control Change 0xb0-0xbf
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,     // Patch change 0xc0-0xcf
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,     // Channel pressure 0xd0-0xdf
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // Pitch bend 0xe0-0xef

    // SysEx
    0,                                                  // 0xf0 SOX invalid in this context

    // System common
    2,                                                  // 0xf1 MTC quarter frame
    3,                                                  // 0xf2 SPP
    2,                                                  // 0xf3 Song select
    0,                                                  // 0xf4 Undefined
    0,                                                  // 0xf5 Undefined
    1,                                                  // 0xf6 Tune request
    0,                                                  // 0xf7 EOX invalid in this context

    // System realtime
    1,                                                  // 0xf8 Timing clock
    0,                                                  // 0xf9 Undefined
    1,                                                  // 0xfa Start
    1,                                                  // 0xfb Continue
    1,                                                  // 0xfc Start
    0,                                                  // 0xfd Undefined
    1,                                                  // 0xfe Active Sense
    1,                                                  // 0xff System Reset
};

//
// Constructor. Takes number of bytes
//
CDirectMusicBuffer::CDirectMusicBuffer(
                                       DMUS_BUFFERDESC &dmbd)
   : m_BufferDesc(dmbd)
{
    m_cRef = 1;
    m_pbContents = NULL;
}

// Destructor
// Clean up after ourselves
//
CDirectMusicBuffer::~CDirectMusicBuffer()
{
    if (m_pbContents) {
        delete[] m_pbContents;
    }
}

// Init
//
// Allocates the buffer; gives us a chance to return out of memory
//
HRESULT
CDirectMusicBuffer::Init()
{
    m_maxContents = DWORD_ROUNDUP(m_BufferDesc.cbBuffer);

    m_pbContents = new BYTE[m_maxContents];
    if (NULL == m_pbContents) {
        return E_OUTOFMEMORY;
    }

    m_cbContents = 0;
    m_idxRead = 0;
    m_totalTime = 0;

    if (m_BufferDesc.guidBufferFormat == KSDATAFORMAT_TYPE_MUSIC ||
        m_BufferDesc.guidBufferFormat == guidZero)
    {
        m_BufferDesc.guidBufferFormat = KSDATAFORMAT_SUBTYPE_MIDI;
    }
    
    return S_OK;
}

// @method HRESULT | IDirectMusicBuffer | GetRawBufferPtr | Returns a pointer to the buffer's contents.
//
// @comm
//
// Returns a pointer to the underlying buffer data structure.
// This method returns a pointer to the raw data of the buffer. The format of this data is implementation
// dependent. The lifetime of this data is the same as the lifetime of the buffer object; therefore, the
// returned pointer should not be held past the next call to the <m Release> method.
//
// @rdesc
//
// @flag S_OK | On success
// @flag E_POINTER | If the given <p ppData> pointer is invalid
//
STDMETHODIMP
CDirectMusicBuffer::GetRawBufferPtr(
    LPBYTE *ppData)         // @parm Receives a pointer to the buffer's data.
{
    V_INAME(IDirectMusicBuffer::GetRawBufferPointer);
    V_PTRPTR_WRITE(ppData);
    
    *ppData = m_pbContents;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetStartTime | Gets the start time of the data in the buffer.
//
// @comm
// Gets the start time of the data in the buffer.  The start time is relative to DirectMusic's master clock.
//
// @rdesc
//
// @flag S_OK | On success
// @flag DMUS_E_BUFFER_EMPTY | If there is no data in the buffer
// @flag E_POINTER | If the passed <p prt> pointer is invalid
// 
STDMETHODIMP
CDirectMusicBuffer::GetStartTime(
    LPREFERENCE_TIME prt)       // @parm Receives the start time.
{
    V_INAME(IDirectMusicBuffer::GetStartTime);
    V_PTR_WRITE(prt, REFERENCE_TIME);
    
    if (m_cbContents)
    {
        *prt = m_rtBase;
        return S_OK;
    }

    return DMUS_E_BUFFER_EMPTY;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetUsedBytes | Returns the amount of music data currently in the buffer.
//
// @comm
// Gets the number of bytes of data in the buffer.
//
// @rdesc
//
// @flag S_OK | On success
// @flag E_POINTER | If the given <p pcb> pointer is invalid.
//
STDMETHODIMP
CDirectMusicBuffer::GetUsedBytes(
    LPDWORD pcb)                // @parm Receives the number of used bytes.
{
    V_INAME(IDirectMusicBuffer::GetUsedBytes);
    V_PTR_WRITE(pcb, DWORD);
    
    *pcb = m_cbContents;
    
    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetMaxBytes | Returns the maximum number of bytes the buffer can hold.
//
// @comm
// Retrieves the maximum number of bytes that can be stored in the buffer.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | The given <p pcb> pointer was invalid.
//
STDMETHODIMP
CDirectMusicBuffer::GetMaxBytes(
    LPDWORD pcb)                // @parm Receives the maximum number of bytes the buffer can hold.
{
    V_INAME(IDirectMusicBuffer::GetMaxBytes);
    V_PTR_WRITE(pcb, DWORD);
    
    *pcb = m_maxContents;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetBufferFormat | Returns the GUID representing the buffer format.
//
// @comm
// Retrieves the GUID representing the format of the buffer. If the format was not specified, then KSDATAFORMAT_SUBTYPE_MIDI
// will be returned.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | The given <p pGuidFormat> pointer was invalid.
//
STDMETHODIMP
CDirectMusicBuffer::GetBufferFormat(
    LPGUID pGuidFormat)                // @parm Receives the GUID format of the buffer
{
    V_INAME(IDirectMusicBuffer::GetBufferFormat);
    V_PTR_WRITE(pGuidFormat, GUID);

    *pGuidFormat = m_BufferDesc.guidBufferFormat;
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | SetStartTime | Sets the start time of the buffer.
//
// @comm
// Sets the start time of the data in the buffer.  Times in DirectMusic
// are relative to master clock which can be retrieved and set with the
// <i IDirectMusic> interface. For more information about the master clock,
// see the description of <om IDirectMusic::SetMasterClock>.
//
// @rdesc
//
// @flag S_OK | On success
//
STDMETHODIMP
CDirectMusicBuffer::SetStartTime(
    REFERENCE_TIME rt)          // @parm The new start time for the buffer.
{
    m_rtBase = rt;
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | SetUsedBytes | Sets the number of bytes of data in the buffer.
//
// @comm
// This method allows an application to repack a buffer manually. Generally this should only be done
// if the data format in the buffer is different from the default format provided by DirectMusic. (i.e.
// in a format other than KSDATAFORMAT_SUBTYPE_MIDI).
//
// @rdesc
//
// @flag S_OK | On success
// @flag DMUS_E_BUFFER_FULL | If the specified number of bytes exceeds the maximum buffer size as returned by <m GetMaxBytes>.
//
STDMETHODIMP
CDirectMusicBuffer::SetUsedBytes(
    DWORD cb)                   // @parm The number of valid data bytes in the buffer
{
    if (cb > m_maxContents)
    {
        return DMUS_E_BUFFER_FULL;
    }
    
    m_cbContents = cb;
    
    return S_OK;
}

// CDirectMusicBuffer::QueryInterface
//
STDMETHODIMP
CDirectMusicBuffer::QueryInterface(const IID &iid,
                                   void **ppv)
{
    V_INAME(IDirectMusicBuffer::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicBuffer) {
        *ppv = static_cast<IDirectMusicBuffer*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CDirectMusicBuffer::AddRef
//
STDMETHODIMP_(ULONG)
CDirectMusicBuffer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicBuffer::Release
//
STDMETHODIMP_(ULONG)
CDirectMusicBuffer::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | Flush | Empties the buffer.
//
// @comm
// Discards all data in the buffer.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusicBuffer::Flush()
{
    m_cbContents = 0;
    m_totalTime = 0;
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | TotalTime | Returns the total time spanned by the data in the buffer.
//
// @comm
// As with all times in DirectMusic, the time is specified in 100 ns units.
// 
// @rdesc Returns one of the following
//
// @flag S_OK | On success.
// @flag E_POINTER | If the <p prtTime> pointer is invalid.
//
STDMETHODIMP
CDirectMusicBuffer::TotalTime(
                              LPREFERENCE_TIME prtTime)      // @parm Received the total time spanned by the buffer
{
    V_INAME(IDirectMusicBuffer::TotalTile);
    V_PTR_WRITE(prtTime, REFERENCE_TIME);
    
    *prtTime = m_totalTime;
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | PackStructured | Inserts a MIDI channel message event at the end of the buffer.
//
// @comm
// There must be at least 24 bytes free in the buffer to insert a channel message.
//
// Although buffers may overlap in time, events within a buffer may not. All events in a buffer must
// be packed in order of ascending time.
//
// @rdesc
//
// @flag S_OK | On success.
// @flag E_OUTOFMEMORY | If there is no room in the buffer for the event.
//
STDMETHODIMP
CDirectMusicBuffer::PackStructured(
                                   REFERENCE_TIME rt,   // @parm The absolute time of the event
                                   DWORD dwChannelGroup,// @parm The channel group of the event on the outgoing port
                                   DWORD dwMsg)         // @parm The channel message to pack 
{
    BYTE b0 = (BYTE)(dwMsg & 0x000000FF);
    BYTE bLength = (b0 & 0x80) ? bMessageLength[b0 & 0x7f] : 0;
    if (bLength == 0)
    {
        return DMUS_E_INVALID_EVENT;
    }

    DMUS_EVENTHEADER *pHeader = AllocEventHeader(rt, 
                                                 bLength, 
                                                 dwChannelGroup, 
                                                 DMUS_EVENT_STRUCTURED);
    if (pHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory((LPBYTE)(pHeader + 1), &dwMsg, bLength);

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | PackUnstructured | Inserts a MIDI channel message event at the end of the buffer.
//
// @comm
// There must be at least 16 bytes plus the quadword-aligned size of the message
// free in the buffer to insert a channel message.
//
// Although buffers may overlap in time, events within a buffer may not. All events in a buffer must
// be packed in order of ascending time.
// 
// @rdesc
//  
// @flag S_OK | On success.
// @flag E_OUTOFMEMORY | If there is no room in the buffer for the event.
// @flag E_POINTER | If the <p lpb> pointer is invalid.
//
//
STDMETHODIMP
CDirectMusicBuffer::PackUnstructured(
                              REFERENCE_TIME rt,    // @parm The absolute time of the event
                              DWORD dwChannelGroup, // @parm The channel group of the event on the outgoing port
                              DWORD cb,             // @parm The size in bytes of the event
                              LPBYTE lpb)           // @parm The next event must be played contigously
{
    V_INAME(IDirectMusicBuffer::PackSysEx);
    V_BUFPTR_READ(lpb, cb);

    DMUS_EVENTHEADER *pHeader = AllocEventHeader(rt, 
                                                 cb, 
                                                 dwChannelGroup,
                                                 0);
    if (pHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory((LPBYTE)(pHeader + 1), lpb, cb);
    
    
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | ResetReadPtr | Causes the next to GetNextEvent to return the first event in the buffer.
//
// @comm
// Moves the read pointer to the start of the data in the buffer.
//
// @rdesc
//
// @flag S_OK | On success
//
STDMETHODIMP
CDirectMusicBuffer::ResetReadPtr()
{
    m_idxRead = 0;
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicBuffer | GetNextEvent | Returns the next event in the buffer and advances the read pointer.
//
// @comm
// Any of the passed pointers may be NULL if the pointed-to item is not needed.
//
// The pointer returned in <p ppData> is only valid for the lifetime of the buffer object. It should only
// be held until the next call of the object's Release method.
//
// @rdesc
//
// @flag S_OK | On success
// @flag S_FALSE | If there are no more events in the buffer
// @flag E_POINTER | If any of the pointers is invalid
//
STDMETHODIMP
CDirectMusicBuffer::GetNextEvent(
                                 LPREFERENCE_TIME prt,      // @parm Receives the time of the event
                                 LPDWORD pdwChannelGroup,   // @parm Receives the channel group of the event
                                 LPDWORD pdwLength,         // @parm Receives the length in bytes of the event
                                 LPBYTE *ppData)            // @parm Receives a pointer to the event data
{
    V_INAME(IDirectMusicBuffer::GetNextEvent);
    V_PTR_WRITE_OPT(prt, REFERENCE_TIME);
    V_PTR_WRITE_OPT(pdwChannelGroup, DWORD);
    V_PTR_WRITE_OPT(pdwLength, DWORD);
    V_PTRPTR_WRITE_OPT(ppData);
            
    if (m_idxRead >= m_cbContents) {
        return S_FALSE;
    }

    LPDMUS_EVENTHEADER pHeader = (LPDMUS_EVENTHEADER)(m_pbContents + m_idxRead);
    m_idxRead += DMUS_EVENT_SIZE(pHeader->cbEvent);

    if (pdwLength) {
        *pdwLength = pHeader->cbEvent;
    }

    if (pdwChannelGroup) {
        *pdwChannelGroup = pHeader->dwChannelGroup;
    }

    if (prt) {
        *prt = m_rtBase + pHeader->rtDelta;
    }

    if (ppData) {
        *ppData = (LPBYTE)(pHeader + 1);
    }

    return S_OK;
}



DMUS_EVENTHEADER *
CDirectMusicBuffer::AllocEventHeader(
    REFERENCE_TIME rt,
    DWORD cbEvent,
    DWORD dwChannelGroup,
    DWORD dwFlags)
{
    DMUS_EVENTHEADER *pHeader;
    LPBYTE pbWalk = m_pbContents;
    DWORD  cbWalk = m_cbContents;

    // Add in header size and round up
    //
    DWORD cbNewEvent = DMUS_EVENT_SIZE(cbEvent);

    if (m_maxContents - m_cbContents < cbNewEvent)
    {
        return NULL;
    }

    if (m_cbContents == 0)
    {
        // Empty buffer
        //
        m_rtBase = rt;
        m_cbContents = cbNewEvent;
        pHeader = (DMUS_EVENTHEADER*)m_pbContents;
    }
    else if (rt >= m_rtBase + m_totalTime)
    {
        // At end of buffer
        //
        if (rt - m_rtBase > m_totalTime)
            m_totalTime = rt - m_rtBase;
        
        pHeader = (DMUS_EVENTHEADER*)(m_pbContents + m_cbContents);
        m_cbContents += cbNewEvent;
    }
    else if (rt < m_rtBase)
    {
        // New first event and have to adjust all the offsets.
        //
        REFERENCE_TIME rtDelta = m_rtBase - rt;

        while (cbWalk)
        {
            assert(cbWalk >= sizeof(DMUS_EVENTHEADER));

            DMUS_EVENTHEADER *pTmpHeader = (DMUS_EVENTHEADER*)pbWalk;
            DWORD cbTmpEvent = DMUS_EVENT_SIZE(pTmpHeader->cbEvent);
            assert(cbWalk >= cbTmpEvent);

            pTmpHeader->rtDelta += rtDelta;
            m_totalTime = pTmpHeader->rtDelta;

            cbWalk -= cbTmpEvent;
            pbWalk += cbTmpEvent;
        }        

        m_rtBase = rt;
        MoveMemory(m_pbContents + cbNewEvent, m_pbContents, m_cbContents);

        m_cbContents += cbNewEvent;
        pHeader = (DMUS_EVENTHEADER*)m_pbContents;
    }
    else
    {
        // Out of order event. Search until we find where it goes
        //
        for (;;)
        {
            assert(cbWalk >= sizeof(DMUS_EVENTHEADER));
            
            DMUS_EVENTHEADER *pTmpHeader = (DMUS_EVENTHEADER*)pbWalk;
            DWORD cbTmpEvent = DMUS_EVENT_SIZE(pTmpHeader->cbEvent);
            assert(cbWalk >= cbTmpEvent);

            if (m_rtBase + pTmpHeader->rtDelta > rt)
            {
                break;
            }

            cbWalk -= cbTmpEvent;
            pbWalk += cbTmpEvent;
        }        

        // pbWalk points to first byte to go *after* the new event, which will be the new
        // event's location. cbWalk is the number of bytes left in the buffer
        //
        MoveMemory(pbWalk + cbNewEvent, pbWalk, cbWalk);
        
        m_cbContents += cbNewEvent;
        pHeader = (DMUS_EVENTHEADER*)pbWalk;
    }

    pHeader->cbEvent            = cbEvent;
    pHeader->dwChannelGroup     = dwChannelGroup;
    pHeader->rtDelta            = rt - m_rtBase;
    pHeader->dwFlags            = dwFlags;

    return pHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmclock.cpp ===
//
// DMClock.CPP
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// Code for dealing with master clocks
//

#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "debug.h"
#include "validate.h"

const char cszClockMemory[] = "DirectMusicMasterClock";
const char cszClockMutex[]  = "DirectMusicMasterClockMutex";

// CMasterClock::CMasterClock
//
// All real initialization is done in Init
//
CMasterClock::CMasterClock()
{
    m_cRef = 0;
    m_cRefPrivate = 0;

    m_pMasterClock = NULL;
    m_hClockMemory = NULL;
    m_pClockMemory = NULL;
    m_hClockMutex  = NULL;
    m_pExtMasterClock = NULL;
    m_llExtOffset = 0;
    m_pSinkSync = NULL;
}

// CMasterClock::~CMasterClock
//
CMasterClock::~CMasterClock()
{
    Close();
}

// CMasterClock::Init
//
// Create Windows objects for shared memory and synchronization
// Create the list of clocks
//
HRESULT CMasterClock::Init()
{
    // Create a file mapping object for the shared master clock settings
    //
    m_hClockMemory = CreateFileMapping(INVALID_HANDLE_VALUE,    // Use paging file
                                       NULL,                    // Default security descriptor
                                       PAGE_READWRITE,
                                       0,                       // High DWORD of size
                                       sizeof(CLOCKSHARE),
                                       cszClockMemory);
    if (m_hClockMemory == NULL)
    {
        TraceI(0, "CreateFileMapping failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    // Was this the call that created the shared memory?
    //
    BOOL fFirst = (GetLastError() != ERROR_ALREADY_EXISTS);

    m_pClockMemory = (CLOCKSHARE*)MapViewOfFile(m_hClockMemory,
                                                FILE_MAP_WRITE,
                                                0, 0,                // Start mapping at the beginning
                                                0);                  // Map entire file
    if (m_pClockMemory == NULL)
    {
        TraceI(0, "MapViewOfFile failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    m_hClockMutex = CreateMutex(NULL,             // Default security descriptor
                                fFirst,           // Own mutex if we are first instance
                                cszClockMutex);
    if (m_hClockMutex == NULL)
    {
        TraceI(0, "CreateMutex failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    if (fFirst)
    {
        // We are the first instance and we own the mutex to modify the shared memory.
        //
        m_pClockMemory->guidClock = GUID_SysClock;
        m_pClockMemory->dwFlags = 0;

        ReleaseMutex(m_hClockMutex);
    }

    // Initialize list of possible clocks
    //
    UpdateClockList();

    return S_OK;
}

// CMasterClock::Close
//
// Release all resources.
//  Release master clock
//  Release list of enum'ed clocks
//  Release Windows objects for shared memory and synchronization
//
void CMasterClock::Close()
{
    CNode<CLOCKENTRY *> *pClockNode;
    CNode<CLOCKENTRY *> *pClockNext;

    // Clock wrapped by CMasterClock
    //
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pExtMasterClock)
    {
        m_pExtMasterClock->Release();
        m_pExtMasterClock = NULL;
    }

    if (m_pSinkSync)
    {
        m_pSinkSync->Release();
        m_pSinkSync = NULL;
    }

    // List of enum'ed clocks
    //
    for (pClockNode = m_lstClocks.GetListHead(); pClockNode; pClockNode = pClockNext)
    {
        pClockNext = pClockNode->pNext;

        delete pClockNode->data;
        m_lstClocks.RemoveNodeFromList(pClockNode);
    }

    // Everything else
    //
    if (m_hClockMutex)
    {
        CloseHandle(m_hClockMutex);
    }

    if (m_pClockMemory)
    {
        UnmapViewOfFile(m_pClockMemory);
    }

    if (m_hClockMemory)
    {
        CloseHandle(m_hClockMemory);
    }
}

// CMasterClock::UpdateClockList()
//
// Make sure the list of available clocks is up to date
//
HRESULT CMasterClock::UpdateClockList()
{
    HRESULT hr;

    CNode<CLOCKENTRY *> *pNode;
    CNode<CLOCKENTRY *> *pNext;

    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
    {
        pNode->data->fIsValid = FALSE;
    }

    // Add the system clock. This clock must *always* be there
    //
#if defined(USE_WDM_DRIVERS)
    hr = AddPcClocks(this);
#else
    hr = S_FALSE;
#endif

    if (FAILED(hr) || hr == S_FALSE)
    {
        AddSysClocks(this);
    }

    AddDsClocks(this);

    // Remove nodes which are no longer valid
    //
    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNext)
    {
        pNext = pNode->pNext;

        if (!pNode->data->fIsValid)
        {
            delete pNode->data;
            m_lstClocks.RemoveNodeFromList(pNode);
        }
    }

    return m_lstClocks.GetNodeCount() ? S_OK : S_FALSE;
}

// CMasterClock::AddClock
//
// Add the given clock to the list if it isn't there already
//
HRESULT CMasterClock::AddClock(
    PCLOCKENTRY pClock)
{
    CNode<CLOCKENTRY *> *pNode;

    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pClock->cc.guidClock == pNode->data->cc.guidClock)
        {
            pNode->data->fIsValid = TRUE;
            return S_OK;
        }
    }

    // No existing entry - need to create a new one
    //
    PCLOCKENTRY pNewClock = new CLOCKENTRY;
    if (NULL == pNewClock)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pNewClock, pClock, sizeof(CLOCKENTRY));
    pNewClock->fIsValid = TRUE;

    if (NULL == m_lstClocks.AddNodeToList(pNewClock))
    {
        delete pNewClock;
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

// CMasterClock::GetMasterClockInterface
//
// Retrieve the wrapped master clock. This should be the *only* way
// DirectMusic gets the master clock. It is responsible for creating
// the clock and updating the shared memory if the clock does not
// exist yet.
//
HRESULT CMasterClock::GetMasterClockInterface(IReferenceClock **ppClock)
{
    WaitForSingleObject(m_hClockMutex, INFINITE);

    if (m_pMasterClock == NULL)
    {
        // We don't have a wrapped clock yet
        //
        HRESULT hr = CreateMasterClock();
        if (FAILED(hr))
        {
            ReleaseMutex(m_hClockMutex);
            return hr;
        }

        // Now we do. This means it can no longer be changed.
        //
        m_pClockMemory->dwFlags |= CLOCKSHARE_F_LOCKED;
    }

    // We have the clock. We return an interface to *this* object, which is also
    // a clock and wraps the real one. This allows us to track releases.
    //
    *ppClock = (IReferenceClock*)this;
    AddRef();

    ReleaseMutex(m_hClockMutex);

    return S_OK;
}

// CMasterClock::CreateMasterClock
//
// Actually create the clock object.
//
// This method is private to CMasterClock and assumes the mutex is taken so it can
// access the shared memory.
//
HRESULT CMasterClock::CreateMasterClock()
{
    HRESULT hr;
    CNode<CLOCKENTRY *> *pNode;
    CLOCKENTRY *pClock;

    // Assume clock will not be found
    //
    hr = E_INVALIDARG;

    pClock = NULL;
    for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (m_pClockMemory->guidClock == pNode->data->cc.guidClock)
        {
            pClock = pNode->data;
            break;
        }
    }

    if (pClock)
    {
        hr = pClock->pfnGetInstance(&m_pMasterClock, this);
    }

    if (SUCCEEDED(hr))
    {
        if (FAILED(m_pMasterClock->QueryInterface(IID_IDirectSoundSinkSync, (void**)&m_pSinkSync)))
        {
            // This is OK, not all clocks support this
            //
            m_pSinkSync = NULL;
        }
    }

    return hr;
}

// CMasterClock::SyncToExternalClock
//
// Sync to an application-given master clock
//
void CMasterClock::SyncToExternalClock()
{
    HRESULT hr;

    assert(m_pExtMasterClock);
    assert(m_pMasterClock);

    REFERENCE_TIME rtSystem;
    hr = m_pMasterClock->GetTime(&rtSystem);

    REFERENCE_TIME rtExternal;
    if (SUCCEEDED(hr))
    {
        hr = m_pExtMasterClock->GetTime(&rtExternal);
    }

    if (SUCCEEDED(hr))
    {
        LONGLONG drift = (rtSystem + m_llExtOffset) - rtExternal;
        m_llExtOffset -= drift / 100;
    }
}

// CMasterClock::EnumMasterClock
//
// Traverse the list looking for the given node
//
HRESULT CMasterClock::EnumMasterClock(
    DWORD           dwIndex,
    LPDMUS_CLOCKINFO lpClockInfo,
    DWORD           dwVer)
{
    CNode<CLOCKENTRY *> *pNode;
    DWORD dwSize; // Used to preserve the dwSize parameter

    pNode = m_lstClocks.GetListHead();
    if (dwIndex == 0 || pNode == NULL)
    {
        UpdateClockList();
    }

    pNode = m_lstClocks.GetListHead();
    if (NULL == pNode)
    {
        return E_NOINTERFACE;
    }

    while (dwIndex-- && pNode)
    {
        pNode = pNode->pNext;
    }

    if (pNode == NULL)
    {
        return S_FALSE;
    }

    // Let's capture the dwSize parameter and preserve it past the memcopy.
    // if we dont' do this then the dwSize probably becomes the size of the
    // largerst strucure
    dwSize = lpClockInfo->dwSize;

    switch (dwVer)
    {
        case 7:
        default:
            memcpy(lpClockInfo, &pNode->data->cc, sizeof(DMUS_CLOCKINFO7));
            break;

        case 8:
            memcpy(lpClockInfo, &pNode->data->cc, sizeof(DMUS_CLOCKINFO8));
    }

    // Now restore the dwSize member
    lpClockInfo->dwSize = dwSize;

    return S_OK;
}


// CMasterClock::GetMasterClock
//
// Return the guid and/or interface to the master clock.
// The master clock may be created as a side effect of this call if one does not
// exist already.
//
HRESULT CMasterClock::GetMasterClock(
    LPGUID pguidClock,
    IReferenceClock **ppClock)
{
    HRESULT hr = S_OK;

    WaitForSingleObject(m_hClockMutex, INFINITE);

    if (pguidClock)
    {
        *pguidClock = m_pClockMemory->guidClock;
    }

    if (ppClock)
    {
        hr = GetMasterClockInterface(ppClock);
    }

    ReleaseMutex(m_hClockMutex);

    return hr;
}

// CMasterClock::SetMasterClock
//
// If the master clock can be updated (i.e. there are no open instances of it),
// then change the shared memory which indicates the GUID.
//
HRESULT CMasterClock::SetMasterClock(REFGUID rguidClock)
{
    HRESULT hr;
    CNode<CLOCKENTRY *> *pNode;
    CLOCKENTRY *pClock;

    WaitForSingleObject(m_hClockMutex, INFINITE);



    if (m_pClockMemory->dwFlags & CLOCKSHARE_F_LOCKED)
    {
        hr = DMUS_E_PORTS_OPEN;
    }
    else
    {
        // Assume clock will not be found
        //
        hr = E_INVALIDARG;

        pClock = NULL;
        for (pNode = m_lstClocks.GetListHead(); pNode; pNode = pNode->pNext)
        {
            if (rguidClock == pNode->data->cc.guidClock)
            {
                pClock = pNode->data;
                break;
            }
        }

        if (pClock)
        {
            // It exists! Save the GUID for later
            //
            m_pClockMemory->guidClock = rguidClock;
            hr = S_OK;
        }
    }

    ReleaseMutex(m_hClockMutex);

    return hr;
}

// CMasterClock::SetMasterClock
//
// This version takes an IReferenceClock and uses it to override the clock
// for this process.
//
// This clock is allowed to be jittery. What will actually happen is that the
// system master clock will be locked to this clock so that the master clock
// will be fine grained.
//
HRESULT CMasterClock::SetMasterClock(IReferenceClock *pClock)
{
    HRESULT hr = S_OK;

    WaitForSingleObject(m_hClockMutex, INFINITE);

    // We must have the default system clock first so we can sync it
    //
    if (pClock && m_pMasterClock == NULL)
    {
        // We don't have a wrapped clock yet
        //
        hr = CreateMasterClock();

        if (SUCCEEDED(hr))
        {
            // Now we do. This means it can no longer be changed.
            //
            m_pClockMemory->dwFlags |= CLOCKSHARE_F_LOCKED;
        }
    }

    // Now set up sync to this master clock
    //
    if (SUCCEEDED(hr))
    {
        if (pClock)
        {
            REFERENCE_TIME rtSystem;
            REFERENCE_TIME rtExternal;

            hr = m_pMasterClock->GetTime(&rtSystem);

            if (SUCCEEDED(hr))
            {
                hr = pClock->GetTime(&rtExternal);
            }

            if (SUCCEEDED(hr))
            {
                m_llExtOffset = rtExternal - rtSystem;
            }
        }
    }

    // If everything went well, switch over to the new clock
    //
    if (SUCCEEDED(hr))
    {
        if (m_pExtMasterClock)
        {
            m_pExtMasterClock->Release();
            m_pExtMasterClock = NULL;
        }

        m_pExtMasterClock = pClock;

        if (m_pExtMasterClock)
        {
            m_pExtMasterClock->AddRef();
        }
    }

    ReleaseMutex(m_hClockMutex);

    return S_OK;
}

// CMasterClock::AddRefPrivate
//
// Release a private reference to the master clock held by DirectMusic
//
LONG CMasterClock::AddRefPrivate()
{
    InterlockedIncrement(&m_cRefPrivate);
    return m_cRefPrivate;
}

// CMasterClock::ReleasePrivate
//
// Release a private reference to the master clock held by DirectMusic
//
LONG CMasterClock::ReleasePrivate()
{
    long cRefPrivate = InterlockedDecrement(&m_cRefPrivate);

    if (cRefPrivate == 0 && m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return cRefPrivate;
}

// CMasterClock::CreateDefaultMasterClock
//
// Creates a private instance of the hardware clock we're using. This is always
// the first entry in the clock list
//
HRESULT CMasterClock::CreateDefaultMasterClock(IReferenceClock **ppClock)
{
    HRESULT hr = S_OK;
    CLOCKENTRY *pClock;

    WaitForSingleObject(m_hClockMutex, INFINITE);

    if (m_lstClocks.GetListHead() == NULL)
    {
        UpdateClockList();
    }

    if (m_lstClocks.GetListHead() == NULL)
    {
        hr = E_NOINTERFACE;
    }

    if (SUCCEEDED(hr))
    {
        pClock = m_lstClocks.GetListHead()->data;
        hr = pClock->pfnGetInstance(ppClock, this);
    }

    ReleaseMutex(m_hClockMutex);

    return hr;
}

STDMETHODIMP CMasterClock::SetClockOffset(LONGLONG llOffset)
{
    if (m_pSinkSync)
    {
        return m_pSinkSync->SetClockOffset(llOffset);
    }
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// IReferenceClock interface
//
//

// CMasterClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CMasterClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if (iid == IID_IDirectSoundSinkSync)
    {
        // Only support this if the wrapped clock supports it
        //
        if (m_pSinkSync)
        {
            *ppv = static_cast<IDirectSoundSinkSync*>(this);
        }
        else
        {
            return E_NOINTERFACE;
        }
    }
    else
    {
        // Some master clocks expose private interfaces. Wrap them.
        //
        // Note that these interfaces acrue to the reference count of the wrapped
        // clock, not CMasterClock
        //
        if (m_pMasterClock)
        {
            return m_pMasterClock->QueryInterface(iid, ppv);
        }

        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

// CMasterClock::AddRef
//
STDMETHODIMP_(ULONG) CMasterClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CMasterClock::Release
//
// Since we are tracking a reference count for our wrapped clock, this
// gets a little strange. We have to release that object and change the
// shared memory on the last release, but we don't release ourselves (the
// wrapper object stays around for the life of this instance of DirectMusic).
//
STDMETHODIMP_(ULONG) CMasterClock::Release()
{
    WaitForSingleObject(m_hClockMutex, INFINITE);

    m_cRef--;
    if (m_cRef == 0)
    {
        // Last release! Get rid of the clock and mark the shared memory
        // as unlocked.
        //
        m_pMasterClock->Release();
        m_pMasterClock = NULL;

        m_pClockMemory->dwFlags &= ~CLOCKSHARE_F_LOCKED;
    }

    ReleaseMutex(m_hClockMutex);

    if (m_cRefPrivate == 0 && m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CMasterClock::GetTime
//
// This is possibly called directly by an app and thus needs parameter validation
//
STDMETHODIMP CMasterClock::GetTime(REFERENCE_TIME *pTime)
{
    V_INAME(IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    HRESULT hr = E_NOINTERFACE;

    if (m_pMasterClock)
    {
        REFERENCE_TIME rt = 0;

        hr = m_pMasterClock->GetTime(&rt);

        if (SUCCEEDED(hr) && m_pExtMasterClock)
        {
            SyncToExternalClock();
            rt += m_llExtOffset;
        }

        *pTime = rt;
    }

    return hr;
}

// CMasterClock::AdviseTime
//
// This is possibly called directly by an app and thus needs parameter validation
//
STDMETHODIMP CMasterClock::AdviseTime(REFERENCE_TIME baseTime,
                                           REFERENCE_TIME streamTime,
                                           HANDLE hEvent,
                                           DWORD * pdwAdviseCookie)
{
    V_INAME(IReferenceClock::AdviseTime);
    V_PTR_WRITE(pdwAdviseCookie, DWORD);

    if (m_pMasterClock)
    {
        return m_pMasterClock->AdviseTime(baseTime, streamTime, hEvent, pdwAdviseCookie);
    }

    return E_NOINTERFACE;
}

// CMasterClock::AdvisePeriodic
//
// This is possibly called directly by an app and thus needs parameter validation
//
STDMETHODIMP CMasterClock::AdvisePeriodic(REFERENCE_TIME startTime,
                                               REFERENCE_TIME periodTime,
                                               HANDLE hSemaphore,
                                               DWORD * pdwAdviseCookie)
{
    V_INAME(IReferenceClock::AdvisePeriodic);
    V_PTR_WRITE(pdwAdviseCookie, DWORD);

    if (m_pMasterClock)
    {
        return m_pMasterClock->AdvisePeriodic(startTime, periodTime, hSemaphore, pdwAdviseCookie);
    }

    return E_NOINTERFACE;
}

// CMasterClock::AdvisePeriodic
//
// This is possibly called directly by an app
//
STDMETHODIMP CMasterClock::Unadvise(DWORD dwAdviseCookie)
{
    if (m_pMasterClock)
    {
        return m_pMasterClock->Unadvise(dwAdviseCookie);
    }

    return E_NOINTERFACE;
}

// CMasterClock::GetParam
//
// Called by a client to request internal information from the clock
// implementation
//
STDMETHODIMP CMasterClock::GetParam(REFGUID rguidType, LPVOID pBuffer, DWORD cbSize)
{
    if (m_pMasterClock == NULL)
    {
        // Master clock must exist first
        //
        return E_NOINTERFACE;
    }

    IMasterClockPrivate *pPrivate;

    HRESULT hr = m_pMasterClock->QueryInterface(IID_IMasterClockPrivate, (void**)&pPrivate);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pPrivate->GetParam(rguidType, pBuffer, cbSize);

    pPrivate->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmcount.h ===
//
// dmcount.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn 
//

#ifndef DMCOUNT_H
#define DMCOUNT_H

class CWaveID : public AListItem
{
friend class CInstrObj;
friend class CWaveObj;

public:
	CWaveID(DWORD dwId) {m_dwId = dwId;} 
	~CWaveID() {}

	CWaveID* GetNext(){return(CWaveID*)AListItem::GetNext();}

private:
	DWORD	m_dwId;
};

class CWaveIDList : public AList
{
public:
	CWaveIDList(){}
	~CWaveIDList() 
	{
		while(!IsEmpty())
		{
			CWaveID* pWaveID = RemoveHead();
			delete pWaveID;
		}
	}

    CWaveID* GetHead(){return(CWaveID *)AList::GetHead();}
	CWaveID* GetItem(LONG lIndex){return(CWaveID*)AList::GetItem(lIndex);}
    CWaveID* RemoveHead(){return(CWaveID *)AList::RemoveHead();}
	void Remove(CWaveID* pWaveID){AList::Remove((AListItem *)pWaveID);}
	void AddTail(CWaveID* pWaveID){AList::AddTail((AListItem *)pWaveID);}
};

#endif // #ifndef DMCOUNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmcrchk.h ===
//
// dmcrchk.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.


#ifndef DMCRCHK_H
#define DMCRCHK_H

#define	DMC_FOUNDICOP (1 << 0)
#define	DMC_FOUNDINAM (1 << 1)
#define	DMC_LOADNAME  (1 << 2)

#include "dmusici.h"

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

class CRiffParser;

class CCopyright
{
friend class CCollection;
friend class CInstrObj;
friend class CWaveObj;

public:
	CCopyright(bool bLoadName = false) : 
	m_byFlags(0),
	m_pwzName(NULL),
	m_pDMCopyright(NULL), 
	m_dwExtraChunkData(0){if(bLoadName){m_byFlags |= DMC_LOADNAME;};}

	~CCopyright(){Cleanup();}

	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, DWORD* dwOffset);

	DWORD Size() {return CHUNK_ALIGN(sizeof(DMUS_COPYRIGHT) + m_dwExtraChunkData);}
	DWORD Count()
	{
		// Return the number of Offset Table entries needed during a call to Write
		return 1;
	}

private:
	void Cleanup()
	{
		delete [] (BYTE *)m_pDMCopyright;
		delete [] m_pwzName;
	}

private:
	BYTE			m_byFlags;
	WCHAR*			m_pwzName;
	DMUS_COPYRIGHT*	m_pDMCopyright;
	DWORD			m_dwExtraChunkData;
};


#endif // #ifndef DMCRCHK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmcrchk.cpp ===
//
// dmcrck.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay

#include "dmusicc.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmcrchk.h"

//////////////////////////////////////////////////////////////////////
// Class CCopyright

//////////////////////////////////////////////////////////////////////
// CCopyright::Load

HRESULT CCopyright::Load(CRiffParser *pParser)
{
	HRESULT hr = S_OK;
    RIFFIO ckNext;

    pParser->EnterList(&ckNext);
	while(pParser->NextChunk(&hr))
	{
		switch(ckNext.ckid)
		{
        case mmioFOURCC('I','C','O','P'):
			m_byFlags |= DMC_FOUNDICOP;
			// We want to make sure we only allocate extra bytes if the chunk size is 
			// greater then the DMUS_MIN_DATA_SIZE
			if(pParser->GetChunk()->cksize < DMUS_MIN_DATA_SIZE)
			{
				m_dwExtraChunkData = 0;
			}
			else
			{
				m_dwExtraChunkData = pParser->GetChunk()->cksize - DMUS_MIN_DATA_SIZE;
			}
			
			m_pDMCopyright  = (DMUS_COPYRIGHT*) 
				new BYTE[CHUNK_ALIGN(sizeof(DMUS_COPYRIGHT) + m_dwExtraChunkData)];

			if(m_pDMCopyright)
			{
				hr = pParser->Read(m_pDMCopyright->byCopyright, pParser->GetChunk()->cksize);
				m_pDMCopyright->cbSize = pParser->GetChunk()->cksize;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
			break;
		case mmioFOURCC('I','N','A','M'):
		    if(m_byFlags & DMC_LOADNAME)
		    {
			    m_pwzName = new WCHAR[DMUS_MAX_NAME];
			    if(m_pwzName)
			    {
				    char szName[DMUS_MAX_NAME];
				    hr = pParser->Read(szName,sizeof(szName));
				    if(SUCCEEDED(hr))
				    {
					    MultiByteToWideChar(CP_ACP, 0, szName, -1, m_pwzName, DMUS_MAX_NAME);
				    }
			    }
			    else
			    {
				    hr = E_OUTOFMEMORY;
			    }
		    }
            m_byFlags |= DMC_FOUNDINAM;
		    break;
	    }
    }
    pParser->LeaveList();
	if(FAILED(hr))
	{
		Cleanup();
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CCopyright::Write

HRESULT CCopyright::Write(void* pv, DWORD* dwCurOffset)
{
	// Argument validation
	assert(pv);
	assert(dwCurOffset);

	HRESULT hr = S_OK;

	CopyMemory(pv, (void *)m_pDMCopyright, Size());
	*dwCurOffset += Size();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmcollec.h ===
//
// dmcollec.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#ifndef DMCOLLEC_H
#define DMCOLLEC_H

#include "dmusici.h"
#include "dminstru.h"

class CCopyright;
class CRiffParser;

typedef struct _DMUS_WAVEOFFSET
{
	DWORD	dwId;
	DWORD	dwOffset;
} DMUS_WAVEOFFSET;

typedef struct _DMUS_PATCHENTRY
{
	ULONG	ulId;
	ULONG	ulPatch;
	ULONG	ulOffset;
} DMUS_PATCHENTRY;

class CCollection : public IDirectMusicCollection, public IPersistStream, public IDirectMusicObject
{
friend class CInstrObj;
friend class CWaveObj;
friend class CInstrument;

public:
	enum {DM_OFFSET_RIFFCHUNK_DATA = 8, 
		  DM_WAVELISTCHK_OFFSET_FROM_WAVE_TBL_BASE = 12, 
		  DM_WAVELISTCHK_OFFSET_FROM_WAVE_FORMTYPE = 8};
    
	// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
	STDMETHODIMP GetClassID(CLSID* pClassID) {return E_NOTIMPL;}

    // IPersistStream
	STDMETHODIMP IsDirty() {return S_FALSE;}
    STDMETHODIMP Load(IStream* pIStream);
    STDMETHODIMP Save(IStream* pIStream, BOOL fClearDirty) {return E_NOTIMPL;}
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicCollection
	STDMETHODIMP GetInstrument(DWORD dwPatch, IDirectMusicInstrument** pInstrument);
	STDMETHODIMP EnumInstrument(DWORD dwIndex, DWORD* pdwPatch, LPWSTR pName, DWORD cwchName);

	// Class
	CCollection();
    ~CCollection();

private:
	void Cleanup();
	HRESULT Parse(CRiffParser *pParser);
	HRESULT BuildInstrumentOffsetTable(CRiffParser *pParser);
	HRESULT BuildWaveOffsetTable(CRiffParser *pParser);

	HRESULT ExtractInstrument(DWORD& dwPatch, CInstrObj** pInstrObj);
	HRESULT ExtractWave(DWORD dwId, CWaveObj** ppWaveObj);
	
	HRESULT ValidateOffset(DWORD dwOffset)
	{
		if( (dwOffset < m_dwStartRiffChunk)  || 
		    (m_dwStartRiffChunk + m_dwSizeRiffChunk < m_dwStartRiffChunk) ||
		    (dwOffset > (m_dwStartRiffChunk + m_dwSizeRiffChunk - 1))
		  )
		{
			return DMUS_E_INVALIDOFFSET;
		}
	
		return S_OK;            
	}

    STDMETHODIMP FindInstrument(DWORD dwPatch, CInstrument** ppDMDLInst);
    STDMETHODIMP AddInstrument(CInstrument* pDMDLInst);
    STDMETHODIMP RemoveInstrument(CInstrument* pDMDLInst);

private:
    IStream *                       m_pStream;              // Stream used for reading the collection and pulling waves out for downloading.    
    DWORD                           m_dwSizeRiffChunk;			// Size of DLS chunk, for validation.
    DWORD                           m_dwStartRiffChunk;         // Start of DLS chunk in file (could be embedded in larger file.)
    DWORD							m_dwFirstInsId;
	ULONG							m_dwNumPatchTableEntries;
	DMUS_PATCHENTRY*				m_pPatchTable;
	DWORD							m_dwFirstWaveId;				
	DWORD                           m_dwWaveTableBaseAddress;		// Used to hold the start of waves within DLS file
	DMUS_WAVEOFFSET*				m_pWaveOffsetTable;	
    DWORD                           m_dwWaveOffsetTableSize;    // Used to verify that references are within range (check for bad wave links in file.)
	CCopyright*						m_pCopyright;
    WCHAR			                m_wszName[DMUS_MAX_NAME]; // Name of DLS collection.
	DLSVERSION						m_vVersion;					
	GUID							m_guidObject;
	bool							m_bLoaded;
	long							m_cRef;
    CInstrumentList                 m_InstList;
    CRITICAL_SECTION                m_CDMCollCriticalSection;
    BOOL                            m_fCSInitialized;
};

#endif // #ifndef DMCOLLEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmcollec.cpp ===
//
// dmcollec.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//
// @doc EXTERNAL
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include "debug.h"
#include <objbase.h>
#include "dmusicp.h"
#include "debug.h"
#include "dlsstrm.h"
#include "dmcrchk.h"
#include "dminsobj.h"
#include "dmcollec.h"
#include "validate.h"
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////
// Class CCollection

//////////////////////////////////////////////////////////////////////
// CCollection::CCollection

CCollection::CCollection() 
{
    m_pStream = NULL;
    m_dwSizeRiffChunk = 0;
    m_dwFirstInsId = 0;
    m_dwNumPatchTableEntries = 0;
    m_pPatchTable = NULL;
    m_dwFirstWaveId = 0;
    m_dwWaveTableBaseAddress = 0;
    m_pWaveOffsetTable = NULL;
    m_dwWaveOffsetTableSize = 0;
    m_pCopyright = NULL;
    m_guidObject = GUID_NULL;
    m_bLoaded = false;
    m_cRef = 1;
    m_fCSInitialized = FALSE;
    InterlockedIncrement(&g_cComponent);
    InitializeCriticalSection(&m_CDMCollCriticalSection);
    m_fCSInitialized = TRUE;
    ZeroMemory(&m_vVersion, sizeof(m_vVersion));
    m_wszName[0] = 0;
}
    
//////////////////////////////////////////////////////////////////////
// CCollection::~CCollection()

CCollection::~CCollection()
{
    if (m_fCSInitialized)
    {
        Cleanup();

        EnterCriticalSection(&m_CDMCollCriticalSection);

        if ((!m_InstList.IsEmpty()))
        {
#ifdef DBG
            assert(FALSE); // should never happen (as long as instruments keep a refcnt on us)
#endif // DBG
            while (!m_InstList.IsEmpty())
            {
                m_InstList.RemoveHead();
            }
        }

        LeaveCriticalSection(&m_CDMCollCriticalSection);

        DeleteCriticalSection(&m_CDMCollCriticalSection);
    }

    InterlockedDecrement(&g_cComponent);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CCollection::QueryInterface

STDMETHODIMP CCollection::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicCollection::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if(iid == IID_IUnknown || iid == IID_IDirectMusicCollection)
    {
        *ppv = static_cast<IDirectMusicCollection*>(this);
    } 
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if(iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IPersist)
    {
        *ppv = static_cast<IPersist*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CCollection::AddRef

STDMETHODIMP_(ULONG) CCollection::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CCollection::Release

STDMETHODIMP_(ULONG) CCollection::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

//////////////////////////////////////////////////////////////////////
// CCollection::Load

STDMETHODIMP CCollection::Load(IStream* pStream)
{
    // Argument validation
    V_INAME(CCollection::Load);
    V_PTR_READ(pStream, IStream);

    // If we have a previous DLS stream return with an error
    if(m_pStream)
    {
        return DMUS_E_ALREADY_LOADED;
    }
    pStream->AddRef();
    m_pStream = pStream;
    HRESULT hr = S_OK;
    RIFFIO ckMain;
    CRiffParser Parser(pStream);
    // Get the current position in the stream and save for validation.
    Parser.EnterList(&ckMain);  
    Parser.MarkPosition();
    // This should be the start of the data chunk, so add the size of the RIFF header.
    m_dwStartRiffChunk = (DWORD) ckMain.liPosition.QuadPart + 8;
    if (Parser.NextChunk(&hr))
    {
        // Now that we've read the header, store the size of the data to follow (which
        // should be the entire DLS collection if in fact this is FOURCC_DLS).
        // This will be used for validation later.
        m_dwSizeRiffChunk = ckMain.cksize;
        if (ckMain.fccType == FOURCC_DLS)
        {
            // We have a DLS Collection we now want to parse it
            hr = Parse(&Parser);
        }
        else
        {
            hr = DMUS_E_NOTADLSCOL;
        }
    }

    m_bLoaded = true;

    if(FAILED(hr))
    {
        // If not a DLS Collection or some other error release allocated resources
        Cleanup();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicObject

//////////////////////////////////////////////////////////////////////
// CCollection::GetDescriptor

STDMETHODIMP CCollection::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CCollection::GetDescriptor);
    // Deal with the fact that we wrote incorrect invalidation tests for DX7, and then
    // crafted the code to pass.
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }

    if(m_vVersion.dwVersionMS || m_vVersion.dwVersionLS)
    {
        pDesc->dwValidData |= DMUS_OBJ_VERSION;
        pDesc->vVersion.dwVersionMS = m_vVersion.dwVersionMS;
        pDesc->vVersion.dwVersionLS = m_vVersion.dwVersionLS;
    }

    if(m_pCopyright != NULL && 
       m_pCopyright->m_byFlags & DMC_FOUNDINAM)
    {
        if (m_pCopyright->m_pwzName)
        {
            pDesc->dwValidData |= DMUS_OBJ_NAME;
            StringCchCopyW(pDesc->wszName, DMUS_MAX_NAME, m_pCopyright->m_pwzName);
        }
    }

    if(m_guidObject != GUID_NULL)
    {
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
        pDesc->guidObject = m_guidObject;
    }

    if (m_wszName[0])
    {
        StringCchCopyW(pDesc->wszName, DMUS_MAX_NAME, m_wszName);
        pDesc->dwValidData |= DMUS_OBJ_NAME;
    }
    
    pDesc->guidClass = CLSID_DirectMusicCollection;
    pDesc->dwValidData |= DMUS_OBJ_CLASS;

    if(m_bLoaded)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CCollection::SetDescriptor

STDMETHODIMP CCollection::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CCollection::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
    }
    
    DWORD dwTemp = pDesc->dwValidData;

    if(pDesc->dwValidData == 0)
    {
        return S_OK;
    }

    if(pDesc->dwValidData & DMUS_OBJ_OBJECT)
    {
        m_guidObject = pDesc->guidObject;
    }

    if(pDesc->dwValidData & DMUS_OBJ_CLASS)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_CLASS;
    }

    if(pDesc->dwValidData & DMUS_OBJ_NAME)
    {
        StringCchCopyW(m_wszName, DMUS_MAX_NAME, pDesc->wszName);
    }

    if(pDesc->dwValidData & DMUS_OBJ_CATEGORY)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_CATEGORY;
    }

    if(pDesc->dwValidData & DMUS_OBJ_FILENAME)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_FILENAME;
    }

    if(pDesc->dwValidData & DMUS_OBJ_FULLPATH)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_FULLPATH;
    }

    if(pDesc->dwValidData & DMUS_OBJ_URL)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_URL;
    }

    if(pDesc->dwValidData & DMUS_OBJ_VERSION)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_VERSION;
    }
    
    if(pDesc->dwValidData & DMUS_OBJ_DATE)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_DATE;
    }

    if(pDesc->dwValidData & DMUS_OBJ_LOADED)
    {
        pDesc->dwValidData &= ~DMUS_OBJ_LOADED;
    }
    
    return dwTemp == pDesc->dwValidData ? S_OK : S_FALSE;
}

//////////////////////////////////////////////////////////////////////
// CCollection::ParseDescriptor

STDMETHODIMP CCollection::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
    // Argument validation
    V_INAME(CCollection::ParseDescriptor);
    V_PTR_READ(pStream, IStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    // This is needed to make up for regression issues.
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    CRiffParser Parser(pStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == FOURCC_DLS))
    {
        dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicCollection;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case FOURCC_DLID:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                dwValidData |= DMUS_OBJ_OBJECT;
                break;
            case FOURCC_VERS:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DLSVERSION) );
                dwValidData |= DMUS_OBJ_VERSION;
                break;
            case FOURCC_LIST:
                if (ckNext.fccType == mmioFOURCC('I','N','F','O'))
                {
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        if (ckUNFO.ckid == mmioFOURCC('I','N','A','M'))
                        {
                            char szName[DMUS_MAX_NAME];
                            hr = Parser.Read(szName, DMUS_MAX_NAME);
                            szName[DMUS_MAX_NAME-1] = '\0';
                            MultiByteToWideChar(CP_ACP, 0, szName, -1, pDesc->wszName, DMUS_MAX_NAME);
                            dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    Parser.LeaveList();          
                }
                break;
            }
        }
        Parser.LeaveList();
    }
    else
    {
        hr = DMUS_E_NOTADLSCOL;
    }
    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    return hr;
}

STDMETHODIMP CCollection::GetInstrument(
    DWORD dwPatch,                          // @parm Instrument patch number, including bank select and drum flag.
    IDirectMusicInstrument** ppInstrument)  // @parm Return value in pointer to <i IDirectMusicInstrument> interface.
{
    // Argument validation
    V_INAME(CCollection::GetInstrument);
    V_PTRPTR_WRITE(ppInstrument);

    // We use 0x7F to strip out the Drum Kit flag
    BYTE bMSB = (BYTE) ((dwPatch >> 16) & 0x7F);
    BYTE bLSB = (BYTE) (dwPatch >> 8);
    BYTE bInstrument = (BYTE) dwPatch;

    if (bMSB < 0 || bMSB > 127 ||
       bLSB < 0 || bLSB > 127 ||
       bInstrument < 0 || bInstrument > 127)
    {
        return DMUS_E_INVALIDPATCH;
    } 
    
    EnterCriticalSection(&m_CDMCollCriticalSection);

    HRESULT hr = E_FAIL;

    CInstrument* pDMInstrument = NULL;
    
    hr = FindInstrument(dwPatch, &pDMInstrument);
    
    if (!pDMInstrument && SUCCEEDED(hr))
    {
        try
        {
            pDMInstrument = new CInstrument();
        }
        catch( ... )
        {
            pDMInstrument = NULL;
        }

        if (pDMInstrument)
        {
            hr = pDMInstrument->Init(dwPatch, this);

            if (SUCCEEDED(hr))
            {
                hr = AddInstrument(pDMInstrument);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (FAILED(hr))
    {
        if (pDMInstrument)
        {
            pDMInstrument->Release();
        }
    }
    else
    {
        *ppInstrument = pDMInstrument;
    }

    LeaveCriticalSection(&m_CDMCollCriticalSection);

    return hr;
}

STDMETHODIMP CCollection::EnumInstrument(
    DWORD dwIndex,      // @parm Index into collection's list of instruments.
    DWORD* pdwPatch,    // @parm Pointer to DWORD variable to store patch number in.
    LPWSTR pwszName,        // @parm Address of the WCHAR buffer to receive the instrument name.
                        // NULL, if no name desired.
    DWORD dwNameLen)    // @parm Length of the instrument name buffer in WCHARs.
{
    // Argument validation
    V_INAME(IDirectMusicCollection::EnumInstrument);    
    V_PTR_WRITE(pdwPatch, DWORD);

    if(pwszName && (dwNameLen > 0))
    {
        V_BUFPTR_WRITE(pwszName, (sizeof(WCHAR) * dwNameLen));
    }

    if(dwIndex >= m_dwNumPatchTableEntries)
    {
        return S_FALSE;
    }

    HRESULT hr = S_OK;

    *pdwPatch = m_pPatchTable[dwIndex].ulPatch;

    if(pwszName && dwNameLen != 0)
    {
        pwszName[0] = '\0';

        LARGE_INTEGER li;
        li.QuadPart = m_pPatchTable[dwIndex].ulOffset;
        assert(m_pStream);
        // Seek to beginning of the instrument list chunk in DLS file
        hr = m_pStream->Seek(li,STREAM_SEEK_SET,NULL);
        RIFFIO ckMain;
        CRiffParser Parser(m_pStream);
        Parser.EnterList(&ckMain);
        if (Parser.NextChunk(&hr))
        {
            if ((ckMain.ckid == FOURCC_LIST) && (ckMain.fccType == FOURCC_INS))
            {
                RIFFIO ckInfo;
                Parser.EnterList(&ckInfo);
                while (Parser.NextChunk(&hr))
                {
                    if ((ckInfo.ckid == FOURCC_LIST) && (ckInfo.fccType == mmioFOURCC('I','N','F','O')))
                    {
                        RIFFIO ckName;
                        Parser.EnterList(&ckName);
                        while (Parser.NextChunk(&hr))
                        {
                            if (ckName.ckid == mmioFOURCC('I','N','A','M'))
                            {
                                char szName[DMUS_MAX_NAME];
                                hr = Parser.Read(szName, min(dwNameLen,DMUS_MAX_NAME));
                                szName[min(dwNameLen,DMUS_MAX_NAME)-1] = '\0';
                                MultiByteToWideChar(CP_ACP, 0, szName, -1, pwszName, dwNameLen);
                                break;
                            }
                        }
                        Parser.LeaveList();
                        break;
                    }
                }
                Parser.LeaveList();
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    
    return hr;
}
 
//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CCollection::Cleanup

void CCollection::Cleanup()
{
    if(m_pStream)
    {
        m_pStream->Release();
        m_pStream = NULL;
    }

    if(m_pPatchTable)
    {
        delete [] m_pPatchTable;
        m_pPatchTable = NULL;
        m_dwNumPatchTableEntries = 0;
    }
    
    delete[] m_pWaveOffsetTable;
    m_pWaveOffsetTable = NULL;

    delete m_pCopyright;
    m_pCopyright = NULL;

    m_bLoaded = false;
}

//////////////////////////////////////////////////////////////////////
// CCollection::Parse

HRESULT CCollection::Parse(CRiffParser *pParser)
{   
    RIFFIO ckNext;
    HRESULT hr = S_OK;
    BOOL fJustDidInfo = false; // Hack to work around bad file, which caused a regression.
                               // Here for DX7 compatibility.
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        fJustDidInfo = false;
        switch(ckNext.ckid)
        {
        case FOURCC_VERS:
            hr = pParser->Read(&m_vVersion, sizeof(DLSVERSION));
            break;
        case FOURCC_DLID:
            hr = pParser->Read(&m_guidObject, sizeof(GUID));
            break;
        case FOURCC_COLH:
            DLSHEADER dlsHeader;
            hr = pParser->Read(&dlsHeader, sizeof(DLSHEADER));
            if(SUCCEEDED(hr))
            {
                m_dwNumPatchTableEntries = dlsHeader.cInstruments;
                m_pPatchTable = new DMUS_PATCHENTRY[m_dwNumPatchTableEntries];
                if(m_pPatchTable == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            break;
        case FOURCC_PTBL:
            hr = BuildWaveOffsetTable(pParser);
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
                case mmioFOURCC('I','N','F','O'):
                    fJustDidInfo = true;
                    m_pCopyright = new CCopyright(true);
                    if(m_pCopyright)
                    {
                        hr = m_pCopyright->Load(pParser);
                        if((m_pCopyright->m_byFlags & DMC_FOUNDICOP) == 0 &&
                           (m_pCopyright->m_byFlags & DMC_FOUNDINAM) == 0)
                        {
                            delete m_pCopyright;
                            m_pCopyright = NULL;
                            break;
                        }
                        if (m_pCopyright->m_byFlags & DMC_FOUNDINAM)
                        {
                            if (m_pCopyright->m_pwzName)
                            {
                                 StringCchCopyW(m_wszName, DMUS_MAX_NAME, m_pCopyright->m_pwzName);
                            }
                        }
                    }
                    else
                    {
                        hr =  E_OUTOFMEMORY;
                    }
                    break;
                case FOURCC_WVPL:
                {           
                    pParser->MarkPosition();
                    // We need to store the start of the wave table. This should point to the first
                    // Wave in the file. So, we take our current position.
                    m_dwWaveTableBaseAddress = (DWORD) ckNext.liPosition.QuadPart; //DM_WAVELISTCHK_OFFSET_FROM_WAVE_TBL_BASE;
                    hr = ValidateOffset(m_dwWaveTableBaseAddress);
                    break;
                }
                case FOURCC_LINS :
                    hr = BuildInstrumentOffsetTable(pParser);
                    break;
            }
            break;
        }
    }
    if (FAILED(hr) && fJustDidInfo)
    {
        hr = S_OK;
    }
    pParser->LeaveList();

    // If we return an error Parse() is expecting the caller to call Cleanup
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::BuildInstrumentOffsetTable

HRESULT CCollection::BuildInstrumentOffsetTable(CRiffParser *pParser)
{
    CDirectMusicPort::GetDLIdP(&m_dwFirstInsId, m_dwNumPatchTableEntries);
    DWORD dwCurId = m_dwFirstInsId;
    DWORD dwIndex = 0;  
    RIFFIO ckNext;  
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if ((ckNext.ckid == FOURCC_LIST) && (ckNext.fccType == FOURCC_INS))
        {
            RIFFIO ck;
            pParser->MarkPosition();
            DWORD dwSavedPos = (DWORD) ckNext.liPosition.QuadPart - 12; 
            pParser->EnterList(&ck);
            while (pParser->NextChunk(&hr))
            {
                if (ck.ckid == FOURCC_INSH)
                {
                    DWORD dwPatch;
                    INSTHEADER instHeader;
                    hr = pParser->Read(&instHeader, sizeof(INSTHEADER));
                    if(SUCCEEDED(hr))
                    {
                        dwPatch = instHeader.Locale.ulInstrument;
                        dwPatch |= (instHeader.Locale.ulBank) << 8;
                        dwPatch |= (instHeader.Locale.ulBank & 0x80000000);
                        if (dwIndex < m_dwNumPatchTableEntries)
                        {
                            m_pPatchTable[dwIndex].ulId = dwCurId++;
                            m_pPatchTable[dwIndex].ulOffset = dwSavedPos;
                            m_pPatchTable[dwIndex++].ulPatch = dwPatch;
                        }
                        else hr = E_FAIL;
                    }
                }
            }
            pParser->LeaveList();
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr) && dwIndex != m_dwNumPatchTableEntries)
    {
        hr = E_FAIL;
    }

    // If we return an error BuildInstrumentOffsetTable() is expecting the caller to call Cleanup
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::BuildWaveOffsetTable

HRESULT CCollection::BuildWaveOffsetTable(CRiffParser *pParser)
{
    POOLCUE* pTablePoolCue = NULL;
    POOLTABLE pt;
    HRESULT hr = pParser->Read(&pt, sizeof(POOLTABLE));

    if(SUCCEEDED(hr))
    {
        pTablePoolCue = new POOLCUE[pt.cCues];
        
        if(pTablePoolCue == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pParser->Read(pTablePoolCue, pt.cCues * sizeof(POOLCUE));
            if(SUCCEEDED(hr))
            {
                CDirectMusicPort::GetDLIdP(&m_dwFirstWaveId, pt.cCues);
                m_pWaveOffsetTable = new DMUS_WAVEOFFSET[pt.cCues];
                m_dwWaveOffsetTableSize = pt.cCues;
                if(m_pWaveOffsetTable)
                {
                    for(DWORD i = 0; i < pt.cCues; i++)
                    {
                        m_pWaveOffsetTable[i].dwId = m_dwFirstWaveId + i;
                        m_pWaveOffsetTable[i].dwOffset = pTablePoolCue[i].ulOffset;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    
    if (pTablePoolCue)
    {
        delete [] pTablePoolCue;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::ExtractInstrument

HRESULT CCollection::ExtractInstrument(DWORD& dwPatch, CInstrObj** pInstrObj)
{
    // Argument validation - Debug
    assert(pInstrObj);

    // Bug 42673: If we create a collection and never call load on it m_pStream can be NULL
    // assert(m_pStream);
    if(m_pStream == NULL)
    {
        Trace(1, "ERROR: CCollection::ExtractInstrument failed. Collection is not loaded (stream is NULL)\n");
        return DMUS_E_NOT_LOADED;
    }

    HRESULT hr = E_FAIL;

    bool bFound = false;

    *pInstrObj = NULL;      

    for(DWORD dwIndex = 0; dwIndex < m_dwNumPatchTableEntries; dwIndex++)
    {
        if(dwPatch == m_pPatchTable[dwIndex].ulPatch)
        {
            bFound = true;
            hr = S_OK;
            break;
        }
    }
    
    if(bFound)
    {
        CInstrObj *pInstrument;
        try
        {
            pInstrument = new CInstrObj;
        }
        catch( ... )
        {
            pInstrument = NULL;
        }
        if(pInstrument)
        {
            LARGE_INTEGER li;
            li.QuadPart = m_pPatchTable[dwIndex].ulOffset;
            // Seek to beginning of the instrument list chunk in DLS file
            hr = m_pStream->Seek(li,STREAM_SEEK_SET,NULL);
            CRiffParser Parser(m_pStream);
            RIFFIO ckNext;
            Parser.EnterList(&ckNext);
            if (Parser.NextChunk(&hr))
            {
                if ((ckNext.ckid == FOURCC_LIST) && (ckNext.fccType == FOURCC_INS))
                {
                    hr = pInstrument->Load(m_pPatchTable[dwIndex].ulId, &Parser, this);
                    if(SUCCEEDED(hr))
                    {
                        hr = pInstrument->FixupWaveRefs();
                    }
                }
            }
            if(FAILED(hr))
            {
                delete pInstrument;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        } 
        if (SUCCEEDED(hr))
        {
            *pInstrObj = pInstrument;
        }
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////
// CCollection::ExtractWave

HRESULT CCollection::ExtractWave(DWORD dwId, CWaveObj** ppWaveObj)
{
    // Assumption validation - Debug
    assert(ppWaveObj);

#ifdef DBG
    if(dwId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE);
    }
#endif

    assert(m_pStream);

    HRESULT hr;
    DWORD dwOffset  = m_dwWaveTableBaseAddress
                      + m_pWaveOffsetTable[dwId - m_dwFirstWaveId].dwOffset; 
//                    - DM_WAVELISTCHK_OFFSET_FROM_WAVE_FORMTYPE;
    
    if (dwOffset < m_dwWaveTableBaseAddress) {
        hr = DMUS_E_INVALIDOFFSET;
    }
    else {
        hr = ValidateOffset(dwOffset);
    }

    if(FAILED(hr))
    {
        return hr;
    }

    LARGE_INTEGER li;
    li.QuadPart = dwOffset;
    // Seek to beginning of the wave list chunk in DLS file
    hr = m_pStream->Seek(li,STREAM_SEEK_SET,NULL);

    if(SUCCEEDED(hr))
    {
        try
        {
            *ppWaveObj = new CWaveObj;
        }
        catch( ... )
        {
            *ppWaveObj = NULL;
        }

        if(*ppWaveObj)
        {
            CRiffParser Parser(m_pStream);
            RIFFIO ckNext;
            Parser.EnterList(&ckNext);
            if (Parser.NextChunk(&hr))
            {
                if ((ckNext.ckid == FOURCC_LIST) && ((ckNext.fccType == FOURCC_wave) || (ckNext.fccType == mmioFOURCC('W', 'A', 'V', 'E'))))
                {
                    hr = (*ppWaveObj)->Load(dwId, &Parser, this);
                }
            }
            if(FAILED(hr))
            {
                delete *ppWaveObj;
                *ppWaveObj = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::FindInstrument

STDMETHODIMP
CCollection::FindInstrument(DWORD dwPatch,CInstrument** ppDMInst)
{
    assert(ppDMInst);

    HRESULT hr = S_FALSE;

    for (CInstrument* pDMInst = m_InstList.GetHead();
        pDMInst; pDMInst = pDMInst->GetNext())
    {
        if (pDMInst->m_dwOriginalPatch == dwPatch)
        {
            *ppDMInst = pDMInst;
            (*ppDMInst)->AddRef();
            hr = S_OK;
            break;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CCollection::AddInstrument

STDMETHODIMP
CCollection::AddInstrument(CInstrument* pDMInst)
{
    assert(pDMInst);

    m_InstList.AddTail(pDMInst);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CCollection::RemoveInstrument

STDMETHODIMP
CCollection::RemoveInstrument(CInstrument* pDMInst)
{
    assert(pDMInst);

    EnterCriticalSection(&m_CDMCollCriticalSection);
    m_InstList.Remove(pDMInst);
    LeaveCriticalSection(&m_CDMCollCriticalSection);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmdlinst.cpp ===
//
// dmdlinst.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//

#include "debug.h"
#include "dmusicc.h"
#include "dmdlinst.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Class CDownloadedInstrument

CDownloadedInstrument::~CDownloadedInstrument() 
{
    // If pDMDLInst->m_ppDownloadedBuffers == NULL we have been unloaded
    if(m_pPort && m_ppDownloadedBuffers != NULL)
    {
        Trace(0, "WARNING: DirectMusicDownloadedInstrument final release before unloaded!\n");
        m_cRef++; // This is ugly but it prevents a circular reference see Unload's implementation
        
        if (m_cDLRef >= 1)
        {
            // we need to remove ourselves from the port collection, or else we leave the port in an invalid state
            m_cDLRef = 1;

            if (FAILED(m_pPort->UnloadInstrument(this)))
            {
                TraceI(0, "~CDownloadedInstrument- UnloadInstrument failed\n");
            }
        }
    }

    if (m_ppDownloadedBuffers) delete [] m_ppDownloadedBuffers;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::QueryInterface

STDMETHODIMP CDownloadedInstrument::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownloadedInstrument::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if(iid == IID_IUnknown || iid == IID_IDirectMusicDownloadedInstrument)
    {
        *ppv = static_cast<IDirectMusicDownloadedInstrument*>(this);
    } 
    else if(iid == IID_IDirectMusicDownloadedInstrumentPrivate) 
    {
        *ppv = static_cast<IDirectMusicDownloadedInstrumentPrivate*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::AddRef

STDMETHODIMP_(ULONG) CDownloadedInstrument::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::Release

STDMETHODIMP_(ULONG) CDownloadedInstrument::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmdlinst.h ===
//
// dmdlinst.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//
// @doc EXTERNAL

#ifndef DMDLINST_H
#define DMDLINST_H

#include "alist.h"

// IDirectMusicDownloadedInstrumentPrivate
//

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrumentPrivate 
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrumentPrivate, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectMusicDownloadedInstrumentPrivate
    // No methods at this time
};

DEFINE_GUID(IID_IDirectMusicDownloadedInstrumentPrivate, 0x94feda0, 0xa3bb, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

/*
@interface IDirectMusicDownloadedInstrument | 
<i IDirectMusicDownloadedInstrument> is used to keep 
track of a downloaded instrument. It should be
used exactly twice:

First, when an instrument is downloaded via a call to 
<om IDirectMusicPort::DownloadInstrument>, 
<i IDirectMusicDownloadedInstrument> is returned apon
successful download. 

Second, when unloading the instrument via a call to
<om IDirectMusicPort::UnloadInstrument>.

Once the instrument has been unloaded, 
<i IDirectMusicDownloadedInstrument> becomes invalid.

@base public | IUnknown

@xref <i IDirectMusicCollection>, <i IDirectMusicPort>,
<i IDirectMusicInstrument>, 
<om IDirectMusicPort::DownloadInstrument>,
<om IDirectMusicPort::UnloadInstrument>

@ex Download the instrument, then unload it (fat lot of
good that will do us, but, hey, this is only a demo). 
Notice that
<p pDLInstrument> is never AddRef'd or Release'd. These are
automatically managed by the calls to Download and Unload. | 

    HRESULT myFickleDownload(   
        IDirectMusicInstrument* pInstrument,
        IDirectMusicPort *pPort,
        DWORD dwPatch)

    {
        HRESULT hr;
        IDirectMusicDownloadedInstrument * pDLInstrument;
        hr = pPort->DownloadInstrument(pInstrument, &pDLInstrument, NULL, 0);
        if (SUCCEEDED(hr))
        {
            pPort->UnloadInstrument(pDLInstrument);
        }
        return hr;
    }
*/


class CDownloadedInstrument : public IDirectMusicDownloadedInstrument,
    public IDirectMusicDownloadedInstrumentPrivate, public AListItem
{
friend class CDirectMusicPortDownload;

public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicDownloadedInstrument
    //
    // No methods at this time

private:
    friend class CDirectMusicPortDownload;

    CDownloadedInstrument() 
    {
        m_ppDownloadedBuffers = NULL;
        m_pPort = NULL;
        m_dwDLTotal = 0;
        m_dwDLSoFar = 0;
        m_cRef = 1;
        m_cDLRef = 0;
    }
    ~CDownloadedInstrument();

    CDownloadedInstrument* GetNext() {return (CDownloadedInstrument*)AListItem::GetNext();}

private:
    IDirectMusicDownload**   m_ppDownloadedBuffers;  // Array of downloaded buffers, starting with the instrument, 
                                                // and then one for each wave.
    IDirectMusicPort*        m_pPort;           // Port that this 
    DWORD                    m_dwDLTotal;       // Number of objects in the array pointed to by m_pDLList.
    DWORD                    m_dwDLSoFar;       // How many have been downloaded so far.
    long                     m_cRef;
    long                     m_cDLRef;
};

class CDLInstrumentList : public AList
{
private:
    friend class CDirectMusicPortDownload;

    CDLInstrumentList(){}
    ~CDLInstrumentList() 
    {
        while (!IsEmpty())
        {
            CDownloadedInstrument* pDMDLInst = RemoveHead();
            if (pDMDLInst)
            {
                pDMDLInst->Release();
            }
        }
    }

    CDownloadedInstrument* GetHead(){return (CDownloadedInstrument*)AList::GetHead();}
    CDownloadedInstrument* GetItem(LONG lIndex){return (CDownloadedInstrument*)AList::GetItem(lIndex);}
    CDownloadedInstrument* RemoveHead(){return (CDownloadedInstrument*)AList::RemoveHead();}
    void Remove(CDownloadedInstrument* pDMDLInst){AList::Remove((AListItem*)pDMDLInst);}
    void AddTail(CDownloadedInstrument* pDMDLInst){AList::AddTail((AListItem*)pDMDLInst);}
};

#endif // #ifndef DMDLINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmdload.h ===
//
// dmdload.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
// @doc EXTERNAL
//

#include "..\shared\validate.h"

#ifndef DMDLOAD_H
#define DMDLOAD_H

/*
@interface IDirectMusicDownload | 
The <i IDirectMusicDownload> interface represents
a contiguous memory chunk, used for downloading to a
DLS synth port. 

The <i IDirectMusicDownload> interface and its contained
memory chunk are always created with a call to
<om IDirectMusicPortDownload::AllocateBuffer>.
The memory can then be accessed via the one method
that <i IDirectMusicDownload> provides: 
<om IDirectMusicDownload::GetBuffer>.

@base public | IUnknown

@meth HRESULT | GetBuffer | Returns the memory segment and its size.

@xref <i IDirectMusic>, <i IDirectMusicPortDownload>,
<om IDirectMusicPortDownload::AllocateBuffer>

*/

// IDirectMusicDownloadPrivate
//
#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadPrivate 
DECLARE_INTERFACE_(IDirectMusicDownloadPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	// IDirectMusicDownloadPrivate
    STDMETHOD(SetBuffer)			(THIS_ void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize) PURE;
	STDMETHOD(GetBuffer)			(THIS_ void** ppvBuffer) PURE;
    STDMETHOD(GetHeader)            (THIS_ void** ppvHeader, DWORD* dwHeaderSize) PURE;
};

DEFINE_GUID(IID_IDirectMusicDownloadPrivate, 0x19e55e60, 0xa146, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

class CDownloadBuffer : public IDirectMusicDownload, public IDirectMusicDownloadPrivate, public AListItem
{
friend class CDirectMusicPort;
friend class CDirectMusicSynthPort;
friend class CDirectMusicPortDownload;
friend class CDLBufferList;
friend HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData);
friend void writewave(IDirectMusicDownload* pDMDownload);
friend void writeinstrument(IDirectMusicDownload* pDMDownload);

public:
    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDirectMusicDownload
    STDMETHODIMP GetBuffer(void** ppvBuffer, DWORD* pdwSize);

	// IDirectMusicDownloadPrivate
    STDMETHODIMP SetBuffer(void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize);
	STDMETHODIMP GetBuffer(void** ppvBuffer);
    STDMETHODIMP GetHeader(void** ppvHeader, DWORD *pdwHeaderSize);

private:	
    // Class
    CDownloadBuffer();
    ~CDownloadBuffer();

	CDownloadBuffer* GetNext(){return(CDownloadBuffer*)AListItem::GetNext();}

	long IncDownloadCount()
	{
		// Should never be less than zero
		assert(m_lDownloadCount >= 0);
		
		InterlockedIncrement(&m_lDownloadCount);
		
		return(m_lDownloadCount);
	}
	
	long DecDownloadCount()
	{
		InterlockedDecrement(&m_lDownloadCount);
		
		// Should never be less than zero		
		assert(m_lDownloadCount >= 0);
		
		return(m_lDownloadCount);
	}
	
	HRESULT IsDownloaded()
	{
		// Should never be less than zero
		assert(m_lDownloadCount >= 0);
		
		return(m_DLHandle ? S_OK : S_FALSE);
	}

private:
	HANDLE					m_DLHandle;
	DWORD					m_dwDLId;
	void*					m_pvBuffer;
    DWORD                   m_dwHeaderSize;
	DWORD					m_dwSize;
	long					m_lDownloadCount;
	long					m_cRef;
};

class CDLBufferList : public AList
{
friend class CDirectMusicPortDownload;
friend class CDownloadedInstrument;
friend class CDirectMusicSynthPort;
friend class CDirectMusicPort;

private:
	CDLBufferList(){}
	~CDLBufferList()
	{
		while(!IsEmpty())
		{
			CDownloadBuffer* pDownload = RemoveHead();
			delete pDownload;
		}
	}

    CDownloadBuffer* GetHead(){return (CDownloadBuffer *)AList::GetHead();}
	CDownloadBuffer* GetItem(LONG lIndex){return (CDownloadBuffer*)AList::GetItem(lIndex);}
    CDownloadBuffer* RemoveHead(){return(CDownloadBuffer *)AList::RemoveHead();}
	void Remove(CDownloadBuffer* pDownload){AList::Remove((AListItem *)pDownload);}
	void AddTail(CDownloadBuffer* pDownload){AList::AddTail((AListItem *)pDownload);}
};

#endif // #ifndef DMDLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmdsclk.cpp ===
//
// DMDSClk.CPP
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// DirectSound buffer tweaked master clock
//

#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "debug.h"
#include "validate.h"
#include "resource.h"

class CDsClock : public IReferenceClock, public IDirectSoundSinkSync
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie);
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // IDirectSoundSinkSync
    //
    STDMETHODIMP SetClockOffset(LONGLONG llClockOffset);

    // Class
    //
    CDsClock();
    ~CDsClock();
    HRESULT Init(CMasterClock *pMasterClock);

private:
    long m_cRef;
    IReferenceClock         *m_pHardwareClock;
    LONGLONG                m_llOffset;
};



static HRESULT CreateDsClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);

// AddDsClocks
//
HRESULT AddDsClocks(CMasterClock *pMasterClock)
{
    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce.cc);
    ce.cc.guidClock = GUID_DsClock;
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.cc.dwFlags = 0;
    ce.pfnGetInstance = CreateDsClock;

    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_DSOUNDCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription) / sizeof(ce.cc.wszDescription[0]));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}

static HRESULT CreateDsClock(IReferenceClock **ppClock, CMasterClock *pMasterClock)
{
    TraceI(3, "Creating Ds clock\n");

    CDsClock *pClock = new CDsClock();
    if (pClock == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pClock->Init(pMasterClock);
    if (FAILED(hr))
    {
        delete pClock;
        return hr;
    }

    hr = pClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
    pClock->Release();

    return hr;
}

CDsClock::CDsClock() :
    m_cRef(1),
    m_pHardwareClock(NULL),
    m_llOffset(0)
{
}

CDsClock::~CDsClock()
{
    RELEASE(m_pHardwareClock);
}

// CDsClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CDsClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if (iid == IID_IDirectSoundSinkSync)
    {
        *ppv = static_cast<IDirectSoundSinkSync*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

// CDsClock::AddRef
//
STDMETHODIMP_(ULONG) CDsClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CDsClock::Release
//
STDMETHODIMP_(ULONG) CDsClock::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDsClock::Init
//
HRESULT CDsClock::Init(CMasterClock *pMasterClock)
{
    // Get the 'real' clock
    //
    return pMasterClock->CreateDefaultMasterClock(&m_pHardwareClock);
}

// CDsClock::SetClockOffset
//
STDMETHODIMP
CDsClock::SetClockOffset(LONGLONG llOffset)
{
    m_llOffset += llOffset;

    return S_OK;
}

STDMETHODIMP
CDsClock::GetTime(REFERENCE_TIME *pTime)
{
    HRESULT hr;

    assert(m_pHardwareClock);

    hr = m_pHardwareClock->GetTime(pTime);

    if (SUCCEEDED(hr))
    {
        *pTime += m_llOffset;
    }

    return hr;
}

STDMETHODIMP
CDsClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDsClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDsClock::Unadvise(DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmdload.cpp ===
//
// dmdload.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn
//
// @doc EXTERNAL 
//

#include "debug.h"
#include <objbase.h>
#include "dmusicp.h"
#include "dmdload.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::CDownloadBuffer

CDownloadBuffer::CDownloadBuffer() : 
m_DLHandle(NULL),
m_dwDLId(0xFFFFFFFF),
m_pvBuffer(NULL),
m_dwSize(0),
m_lDownloadCount(0),
m_cRef(1)
{
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::~CDownloadBuffer

CDownloadBuffer::~CDownloadBuffer()
{
	// If assert fires we have not unloaded from a port; this is a problem
	// It should never happen since the download code will have a reference
	assert(m_lDownloadCount == 0);

	delete [] m_pvBuffer;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::QueryInterface

STDMETHODIMP CDownloadBuffer::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownload::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IDirectMusicDownload)
	{
        *ppv = static_cast<IDirectMusicDownload*>(this);
    } 
	else if(iid == IID_IDirectMusicDownloadPrivate)
	{
		*ppv = static_cast<IDirectMusicDownloadPrivate*>(this);
	}
	else
	{
        *ppv = NULL;
        return E_NOINTERFACE;
	}

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::AddRef

STDMETHODIMP_(ULONG) CDownloadBuffer::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::Release

STDMETHODIMP_(ULONG) CDownloadBuffer::Release()
{
    if(!InterlockedDecrement(&m_cRef))
	{
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicDownload

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetBuffer

/*

@method HRESULT | IDirectMusicDownload | GetBuffer | 
Returns a pointer to a buffer which contains
the data buffer managed by the <i IDirectMusicDownload>
inteface. Authoring tools 
that create instruments and download them
directly to the synthesizer use this method to access the
memory and write the instrument definition into it.  

@rdesc Returned codes include:

@flag S_OK | Success.
@flag DMUS_E_BUFFERNOTAVAILABLE | Buffer is not available, probably
because data has already been downloaded to DLS device. 
@flag E_POINTER | Invalid pointer.

@xref <i IDirectMusicDownload>, <i IDirectMusicPortDownload>, 
<om IDirectMusicPortDownload::GetBuffer>

*/

STDMETHODIMP CDownloadBuffer::GetBuffer(
    void** ppvBuffer,   // @parm Pointer to store address of data buffer in.
    DWORD* pdwSize)     // @parm Size of the returned buffer, in bytes.
{
	// Argument validation
	V_INAME(IDirectMusicDownload::GetBuffer);
	V_PTRPTR_WRITE(ppvBuffer);
	V_PTR_WRITE(pdwSize, DWORD);

	if(IsDownloaded() == S_OK)
	{
		return DMUS_E_BUFFERNOTAVAILABLE;
	}

	*ppvBuffer = ((LPBYTE)m_pvBuffer) + m_dwHeaderSize;
	*pdwSize = m_dwSize;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::SetBuffer

HRESULT CDownloadBuffer::SetBuffer(void* pvBuffer, DWORD dwHeaderSize, DWORD dwSize)
{
	// Assumption validation - Debug
	// We should never have a non-NULL pvBuffer and a size of zero
#ifdef DBG
	if(pvBuffer && dwSize == 0)
	{
		assert(false);
	}
#endif

	m_pvBuffer = pvBuffer;
    m_dwHeaderSize = dwHeaderSize;
	m_dwSize = dwSize;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetBuffer

HRESULT CDownloadBuffer::GetBuffer(void** ppvBuffer)
{
	// Argument validation - Debug
	assert(ppvBuffer);

	*ppvBuffer = ((LPBYTE)m_pvBuffer) + m_dwHeaderSize;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDownloadBuffer::GetHeader

HRESULT CDownloadBuffer::GetHeader(void** ppvHeader, DWORD *pdwHeaderSize)
{
	// Argument validation - Debug
	assert(ppvHeader);
    assert(pdwHeaderSize);

	*ppvHeader = m_pvBuffer;
    *pdwHeaderSize = m_dwHeaderSize;
    
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmeport.h ===
//
// dmeport.h
//
// Emulation for MME drivers on NT
//
// Copyright (c) 1997-2000 Microsoft Corporation
// 
#ifndef _DMEPORT_
#define _DMEPORT_

#include "..\shared\dmusiccp.h"

#define SYSEX_SIZE            4096
#define SYSEX_BUFFERS         8

typedef HRESULT (*PORTENUMCB)(
    LPVOID pInstance,          // @parm Callback instance data
    DMUS_PORTCAPS &dmpc,                              
    PORTTYPE pt,                              
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The Pin ID of the device or -1 if the device is a legacy device
    int idxNode,               // @parm The node ID of the device's synth node (unused for legacy)
    HKEY hkPortsRoot);         // @parm Where port information is stored in the registry


extern HRESULT EnumLegacyDevices(CDirectMusic *pDM, PORTENUMCB pCB);
extern HRESULT CreateCDirectMusicEmulatePort(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    DMUS_PORTPARAMS8 *pPortParams,
    IDirectMusicPort8 **pPort);
    
extern HRESULT MMRESULTToHRESULT(
    MMRESULT mmr);

struct QUEUED_SYSEX_EVENT : public QUEUED_EVENT
{
    BYTE            m_abRest[sizeof(MIDIHDR) + SYSEX_SIZE - sizeof(DWORD)];
};

#define EVENT_F_MIDIHDR 0x00000001  // This event starts with a MIDIHDR
    

#include "tpool.h"

#define THREAD_KILL_TIMEOUT         5000
#define THREAD_WORK_BUFFER_SIZE     4096

#define QWORD_ALIGN(x) (((x) + 7) & ~7)

#define MIDI_CHANNELS               16

// 10 ms in 100ns units
//
#define FIXED_LEGACY_LATENCY_OFFSET (10L * 10L * 1000L)

struct DMQUEUEDEVENT
{
    DMQUEUEDEVENT           *m_pNext;
    DMEVENT                 m_event;
    LPBYTE                  m_pbEvent;
};

class CEmulateLatencyClock : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
				    REFERENCE_TIME streamTime,
				    HANDLE hEvent,            
				    DWORD * pdwAdviseCookie); 

    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					REFERENCE_TIME periodTime,
					HANDLE hSemaphore,   
					DWORD * pdwAdviseCookie);

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CEmulateLatencyClock(IReferenceClock *pMasterClock);
    ~CEmulateLatencyClock();

    void Close();

private:
    long m_cRef;
    IReferenceClock *m_pMasterClock;
};

// Struct for holding a property item supported by the synth
//

class CDirectMusicEmulatePort;

typedef HRESULT (CDirectMusicEmulatePort::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};


class CDirectMusicEmulatePort : 
    public IDirectMusicPort8, 
    public IDirectMusicThru,
    public IDirectMusicPortPrivate, 
    public IKsControl
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);
	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument*,
                                            IDirectMusicDownloadedInstrument**,
                                            DMUS_NOTERANGE*,
                                            DWORD);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument*);
    
    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwNumChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwNumChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate);
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);
        
    // IDirectMusicThru
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, 
                             DWORD dwSourceChannel, 
                             DWORD dwDestinationChannelGroup,
                             DWORD dwDestinationChannel,
                             LPDIRECTMUSICPORT pDestinationPort);
    
    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IN  IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IN  IDirectSoundDownloadedWaveP *pWave,     
         IN  DWORD dwChannel,                       
         IN  DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,         
         OUT IDirectMusicVoiceP **ppVoice            
        );        
        
    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBusses,
         IN DWORD cBussCount
        );        

    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
       );        

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
       );        

    // IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();

    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd);

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop);
    
    STDMETHODIMP GetVoiceState(
        DWORD dwVoice[], 
        DWORD cbVoice,
        DMUS_VOICE_STATE VoiceState[]);
         
    STDMETHODIMP Refresh(
        DWORD dwDownloadID,
        DWORD dwFlags);
         
    // Class
    //
    CDirectMusicEmulatePort(PORTENTRY *pPE, CDirectMusic *pDM);
    virtual ~CDirectMusicEmulatePort();
    virtual HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    virtual HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer) PURE;

    
   

private:
    long                    m_cRef;
    IDirectMusicPortNotify  *m_pNotify;
    DMUS_PORTCAPS           m_dmpc;
    long                    m_lActivated;    

    CEmulateLatencyClock    *m_pLatencyClock;
    
protected:    
    CDirectMusic            *m_pDM;
    UINT                    m_id;
    IReferenceClock         *m_pMasterClock;

private:
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    
private:
    HRESULT InitializeClock();
    
protected:
    virtual HRESULT ActivateLegacyDevice(BOOL fActivate) PURE;
};

class CDirectMusicEmulateInPort : public CDirectMusicEmulatePort
{
    friend static VOID CALLBACK midiInProc(
        HMIDIIN             hMidiIn, 
        UINT                wMsg, 
        DWORD_PTR           dwInstance, 
        DWORD_PTR           dwParam1, 
        DWORD_PTR           dwParam2);

public:
    // Class
    //
    CDirectMusicEmulateInPort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicEmulateInPort();

    HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    DWORD InputWorker();
    STDMETHODIMP Close();
    HRESULT ActivateLegacyDevice(BOOL fActivate);
    
    // IDirectMusicPort
    //    
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);

    // IDirectMusicThru
    //
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, 
                             DWORD dwSourceChannel, 
                             DWORD dwDestinationChannelGroup,
                             DWORD dwDestinationChannel,
                             LPDIRECTMUSICPORT pDestinationPort);

private:
    HANDLE                  m_hAppEvent;

    EVENT_POOL              m_FreeEvents;        
    EVENT_QUEUE             m_ReadEvents;

    IDirectMusicBuffer      *m_pThruBuffer;
    LPDMUS_THRU_CHANNEL     m_pThruMap;

    
    CRITICAL_SECTION        m_csEventQueues;
    BOOL                    m_fCSInitialized;

    HMIDIIN                 m_hmi;
    REFERENCE_TIME          m_rtStart;

    BOOL                    m_fFlushing;
    LONG                    m_lPendingSysExBuffers;
    QUEUED_SYSEX_EVENT      m_SysExBuffers[SYSEX_BUFFERS];
    
    // Clock sync stuff
    //
    bool                    m_fSyncToMaster;        // Need to sync to master clock
    LONGLONG                m_lTimeOffset;          // Time difference
    LONGLONG                m_lBaseTimeOffset;      // Time difference when input is started
    IReferenceClock        *m_pPCClock;             // PortCls clock

private:
    HRESULT PostSysExBuffers();
    HRESULT FlushSysExBuffers();
    void Callback(UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    BOOL RecordShortEvent(DWORD_PTR dwMessage,  REFERENCE_TIME rtTime);
    BOOL RecordSysEx(DWORD_PTR dwMessage,  REFERENCE_TIME rtTime);
    void QueueEvent(QUEUED_EVENT *pEvent);
    void ThruEvent(DMEVENT *pEvent);

    // Clock sync stuff
    //
    void SyncClocks();
};

class CDirectMusicEmulateOutPort : public CDirectMusicEmulatePort
{
    friend static VOID CALLBACK midiOutProc(
        HMIDIOUT            hMidiOut, 
        UINT                wMsg, 
        DWORD_PTR           dwInstance, 
        DWORD_PTR           dwParam1, 
        DWORD_PTR           dwParam2);

    friend static VOID CALLBACK timerProc(
        UINT                    uTimerID, 
        UINT                    uMsg, 
        DWORD_PTR               dwUser, 
        DWORD_PTR               dw1, 
        DWORD_PTR               dw2);

public:
    CDirectMusicEmulateOutPort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicEmulateOutPort();

    HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    STDMETHODIMP Close();
    HRESULT ActivateLegacyDevice(BOOL fActivate);
    

private:
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    void Callback(UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    void Timer();
    void SetNextTimer();
    
private:
    HMIDIOUT                m_hmo;
    CRITICAL_SECTION        m_csPlayQueue;
    DMQUEUEDEVENT          *m_pPlayQueue;
    CPool<DMQUEUEDEVENT>    m_poolEvents;
    LONG                    m_lTimerId;
    BOOL                    m_fClosing;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmecport.cpp ===
//
// dmecport.cpp
//
// Emulated Capture port (NT)
//
// Copyright (c) 1997-2000 Microsoft Corporation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>

#include "debug.h"
#include "dmusicp.h"
#include "dmeport.h"

#define IS_STATUS_BYTE(x)     ((x) & 0x80)
#define IS_CHANNEL_MSG(x)     (((x) & 0xF0) != 0xF0)
#define IS_SYSEX(x)           ((x) == 0xF0)

static VOID CALLBACK midiInProc(
    HMIDIIN                 hMidiIn, 
    UINT                    wMsg, 
    DWORD_PTR               dwInstance, 
    DWORD_PTR               dwParam1,     
    DWORD_PTR               dwParam2);

static inline REFERENCE_TIME MsToRefTime(REFERENCE_TIME ms)
{
    return ms * 10 * 1000L;
}

static unsigned g_cbChanMsg[16] =
{
    0, 0, 0, 0, 0, 0, 0, 0, /* Running status */
    3, 3, 3, 3, 2, 2, 3, 0
};

static unsigned g_cbSysCommData[16] =
{
    1, 2, 3, 2, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1
};

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulateInPort::CDirectMusicEmulateInPort
//
//
CDirectMusicEmulateInPort::CDirectMusicEmulateInPort(
                                                 PORTENTRY *pPE,    
                                                 CDirectMusic *pDM) :
                                                 CDirectMusicEmulatePort(pPE, pDM)
                                                 ,m_pThruBuffer(NULL)
                                                 ,m_pThruMap(NULL)
                                                 ,m_fCSInitialized(FALSE)
                                                 ,m_hAppEvent(NULL)
                                                 ,m_hmi(NULL)
                                                 ,m_lPendingSysExBuffers(0)
                                                 ,m_fFlushing(FALSE)
                                                 ,m_fSyncToMaster(TRUE)
                                                 ,m_lTimeOffset(0)
                                                 ,m_lBaseTimeOffset(0)
                                                 ,m_pPCClock(NULL)
{
}

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulateInPort::~CDirectMusicEmulateInPort
//
//
CDirectMusicEmulateInPort::~CDirectMusicEmulateInPort()
{
    Close();    
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::Init
//
//
HRESULT CDirectMusicEmulateInPort::Init(
    LPDMUS_PORTPARAMS pPortParams)
{
    HRESULT         hr;

    hr = CDirectMusicEmulatePort::Init(pPortParams);
    if (FAILED(hr))
    {
        return hr;
    }

    // Allocate thru map for 16 channels, since we only have one channel group
    // Initialize to no thruing (destination port is NULL).
    //
    m_pThruMap = new DMUS_THRU_CHANNEL[MIDI_CHANNELS];
    HRESULT hrTemp = HRFromP(m_pThruMap);
    if (FAILED(hrTemp))
    {
    	return hrTemp;
    }
    
    ZeroMemory(m_pThruMap, MIDI_CHANNELS * sizeof(DMUS_THRU_CHANNEL));

    // Create thruing buffer
    //
    DMUS_BUFFERDESC dmbd;
    ZeroMemory(&dmbd, sizeof(dmbd));
    dmbd.dwSize = sizeof(dmbd);
    dmbd.cbBuffer = 4096;               // XXX Where should we get this???

    hrTemp = m_pDM->CreateMusicBuffer(&dmbd, &m_pThruBuffer, NULL);
    if (FAILED(hrTemp))
    {
        Trace(0, "Failed to create thruing buffer\n");
        return hrTemp;
    }

    // Initialize cs to protect event queues.
    //
    // Unfortunately this can throw an exception if out of memory.
    //
    _try 
    {
        InitializeCriticalSection(&m_csEventQueues);
    } 
    _except (EXCEPTION_EXECUTE_HANDLER) 
    {
        return E_OUTOFMEMORY;
    }
    
    m_fCSInitialized = TRUE;

    // If we have WDM ports, then the default master clock will be the
    // portcls clock.
    //
    hrTemp = m_pDM->GetMasterClockWrapperI()->CreateDefaultMasterClock(&m_pPCClock);
    if (FAILED(hrTemp))
    {
		Close();
		return hrTemp;
    }

    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;

    hrTemp = m_pMasterClock->GetTime(&rtMasterClock);
    if (FAILED(hrTemp))
    {
    	Close();
    	return hrTemp;
    }
    
    hrTemp = m_pPCClock->GetTime(&rtSlaveClock);
    if (FAILED(hrTemp))
    {
        Close();
        return hrTemp;
    }

    m_lTimeOffset = rtMasterClock - rtSlaveClock;

    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::Close
//
//
HRESULT CDirectMusicEmulateInPort::Close()
{
    if (m_hmi)
    {
        midiInReset(m_hmi);
        midiInClose(m_hmi);
        m_hmi = NULL;
    }

    if (m_pPCClock)
    {
        m_pPCClock->Release();
        m_pPCClock = NULL;
    }

    if (m_pThruMap)
    {
        for (int iChannel = 0; iChannel < 16; iChannel++)
        {
            if (m_pThruMap[iChannel].pDestinationPort == NULL)
            {
                continue;
            }

            m_pThruMap[iChannel].pDestinationPort->Release();
        }

        delete[] m_pThruMap;
        m_pThruMap = NULL;
    }

    if (m_pThruBuffer)
    {
        m_pThruBuffer->Release();
        m_pThruBuffer = NULL;
    }

    if (m_hAppEvent)
    {
        m_hAppEvent = NULL;
    }

    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_csEventQueues);
    }

    return CDirectMusicEmulatePort::Close();
}
    
//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::Read
//
//
STDMETHODIMP CDirectMusicEmulateInPort::Read(
    IDirectMusicBuffer *pIBuffer)
{
    HRESULT hr;
    
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    LPBYTE pbBuffer;
    hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD cbBuffer;
    hr = pIBuffer->GetMaxBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    TraceI(1, "Read: buffer size %u\n", cbBuffer);

    LPBYTE pbData = pbBuffer;

    // Since events are now buffered, we read them out of the local queue
    //
    //
    EnterCriticalSection(&m_csEventQueues);

    REFERENCE_TIME rtStart;

    if (m_ReadEvents.pFront)
    {
        rtStart = m_ReadEvents.pFront->e.rtDelta;
    }
    else
    {
        TraceI(2, "Read: No events queued\n");
    }

    while (m_ReadEvents.pFront)
    {               
        if (cbBuffer < sizeof(DMUS_EVENTHEADER) + sizeof(DWORD)) 
        {
            TraceI(2, "Read: No more room for events in buffer.\n");
            break;
        }

        QUEUED_EVENT *pQueuedEvent = m_ReadEvents.pFront;
        LPBYTE pbSrc;
        DWORD cbData;

        if (pQueuedEvent->e.dwFlags & EVENT_F_MIDIHDR)
        {
            LPMIDIHDR pmh = (LPMIDIHDR)&pQueuedEvent->e.abEvent[0];

            // Split up recorded sysex if needed.
            //
            cbData = pmh->dwBytesRecorded - pmh->dwOffset;
            DWORD cbQueuedEvent = QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cbData);

            if (cbQueuedEvent > cbBuffer) 
            {
                DWORD dwOverflow = QWORD_ALIGN(cbQueuedEvent - cbBuffer);

                cbData -= dwOverflow;
                cbQueuedEvent = QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cbData);
            }

            assert(cbQueuedEvent <= cbBuffer);
            assert(cbData <= pmh->dwBytesRecorded - pmh->dwOffset);

            pbSrc = (LPBYTE)(pmh->lpData + pmh->dwOffset);
            pmh->dwOffset += cbData;
        }
        else
        {
            cbData = pQueuedEvent->e.cbEvent;
            pbSrc = &pQueuedEvent->e.abEvent[0];
        }

        DMUS_EVENTHEADER *peh = (DMUS_EVENTHEADER*)pbData;

        peh->rtDelta = pQueuedEvent->e.rtDelta - rtStart;
        peh->cbEvent = cbData;
        peh->dwFlags = 0;
        peh->dwChannelGroup = 1;

        memcpy(pbData + sizeof(DMUS_EVENTHEADER), pbSrc, cbData);

        cbData = QWORD_ALIGN(cbData + sizeof(DMUS_EVENTHEADER));
        pbData += cbData;
        cbBuffer -= cbData;

        m_ReadEvents.pFront = pQueuedEvent->pNext;

        if (pQueuedEvent->e.dwFlags & EVENT_F_MIDIHDR)
        {
            LPMIDIHDR pmh = (LPMIDIHDR)&pQueuedEvent->e.abEvent[0];

            if (pmh->dwOffset = pmh->dwBytesRecorded)
            {
                InterlockedIncrement(&m_lPendingSysExBuffers);
                
                MMRESULT mmr = midiInAddBuffer(m_hmi, pmh, sizeof(*pmh));

                if (mmr)
                {
                    TraceI(0, "Failed to re-add sysex buffer! mmr=%d\n", mmr);
                    InterlockedDecrement(&m_lPendingSysExBuffers);
                }
            }
        }
        else
        {
            // This event came out of the pool
            //
            m_FreeEvents.Free(pQueuedEvent);
        }
    }

    if (m_ReadEvents.pFront == NULL)
    {
        m_ReadEvents.pRear = NULL;
    }

    LeaveCriticalSection(&m_csEventQueues);

    // Update the buffer header information to match the events just packed
    //
    TraceI(2, "Read: Leaving with %u bytes in buffer\n", (unsigned)(pbData - pbBuffer));
    pIBuffer->SetStartTime(rtStart);
    pIBuffer->SetUsedBytes((DWORD)(pbData - pbBuffer));

    return (pbData == pbBuffer) ? S_FALSE : S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::SetReadNotificationHandle
//
//
STDMETHODIMP CDirectMusicEmulateInPort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_hAppEvent = hEvent;

    return S_OK;    
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::ThruChannel
//
//
STDMETHODIMP CDirectMusicEmulateInPort::ThruChannel(
    DWORD               dwSourceChannelGroup, 
    DWORD               dwSourceChannel, 
    DWORD               dwDestinationChannelGroup,
    DWORD               dwDestinationChannel,
    LPDIRECTMUSICPORT   pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    // Channel group must not be zero (broadcast) but in range 1..NumChannelGroups]
    // (which for legacy is always 1)
    //
    if (dwSourceChannelGroup != 1 ||
        dwSourceChannel > 15)
    {
        return E_INVALIDARG;
    }
    
    // Given a port means enable thruing for this channel; NULL means
    // disable.
    //
    if (pDestinationPort)
    {
        // Enabling thruing on this channel. First look at the destination port.
        //
        DMUS_PORTCAPS dmpc;
        dmpc.dwSize = sizeof(dmpc);
        HRESULT hr = pDestinationPort->GetCaps(&dmpc);
        if (FAILED(hr))
        {
            TraceI(0, "ThruChannel: Destination port failed portcaps [%08X]\n", hr);
            return hr;
        }

        // Port must be an output port
        //
        if (dmpc.dwClass != DMUS_PC_OUTPUTCLASS)
        {
            return DMUS_E_PORT_NOT_RENDER;
        }

        // Channel group and channel must be in range.
        //
        if (dwDestinationChannel > 15 ||
            dwDestinationChannelGroup > dmpc.dwMaxChannelGroups) 
        {
            return E_INVALIDARG;
        }

        // Release existing port
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            // Reference to another port type, release it.
            // (NOTE: No need to turn off native dmusic16 thruing at this point,
            // that's handled in dmusic16).
            //
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
        }


        m_pThruMap[dwSourceChannel].dwDestinationChannel = dwDestinationChannel;
        m_pThruMap[dwSourceChannel].dwDestinationChannelGroup = dwDestinationChannelGroup;
        m_pThruMap[dwSourceChannel].pDestinationPort = pDestinationPort;

        pDestinationPort->AddRef();
    } 
    else
    {
        // Disabling thruing on this channel
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
            m_pThruMap[dwSourceChannel].pDestinationPort = NULL;
        }
    }

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::LegacyCaps
//
//
HRESULT CDirectMusicEmulateInPort::LegacyCaps(
    ULONG               ulId, 
    BOOL                fSet, 
    LPVOID              pbBuffer, 
    PULONG              pcbBuffer)
{
    if (fSet == KSPROPERTY_SUPPORT_SET)
    {
        return DMUS_E_SET_UNSUPPORTED;
    }

    MIDIINCAPS  mic;
    LPBYTE      pbData;
    ULONG       cbData;

    MMRESULT mmr = midiInGetDevCaps(m_id, &mic, sizeof(mic));
    if (mmr)
    {
        TraceI(0, "midiInGetDevCaps failed!\n");
        return MMRESULTToHRESULT(mmr);
    }

    pbData = (LPBYTE)&mic;
    cbData = sizeof(mic);

    ULONG cbToCopy = min(*pcbBuffer, cbData);
    CopyMemory(pbBuffer, pbData, cbToCopy);
    *pcbBuffer = cbToCopy;

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::ActivateLegacyDevice
//
//
HRESULT CDirectMusicEmulateInPort::ActivateLegacyDevice(
    BOOL fActivate)
{
    HRESULT hr = S_OK;
    MMRESULT mmr;

    if (fActivate)
    {
        // BUGBUG SysEx
        //
        TraceI(0, "Emulate in activate\n");
        assert(m_hmi == NULL);

        hr = MMRESULTToHRESULT(mmr = midiInOpen(
            &m_hmi,
            m_id,
            (DWORD_PTR)midiInProc,
            (DWORD_PTR)this,
            CALLBACK_FUNCTION));

        if (SUCCEEDED(hr))
        {
            hr = m_pMasterClock->GetTime(&m_rtStart);
        }

        if (SUCCEEDED(hr))
        {
            hr = PostSysExBuffers();
        }

        if (SUCCEEDED(hr))
        {    
            hr = MMRESULTToHRESULT(mmr = midiInStart(m_hmi));
        }

        if( SUCCEEDED(hr) && m_pPCClock != NULL )
        {
            REFERENCE_TIME rtMasterClock;
            REFERENCE_TIME rtSlaveClock;

            //protect the success code!
            HRESULT hrTemp = m_pMasterClock->GetTime(&rtMasterClock);
            if (SUCCEEDED(hrTemp))
            {
                hrTemp = m_pPCClock->GetTime(&rtSlaveClock);
            }


            if SUCCEEDED(hrTemp)
            {
                 m_lBaseTimeOffset = rtMasterClock - rtSlaveClock;
            }
            else
            {
                //since we've failed, let the failure code fall through
                hr = hrTemp;
            }
        }

        //If we have failed somewhere above, we need to 
        //release the midi-in handle.  the best way to do
        //that is to call this function and deactivate the
        //port!
        if (FAILED(hr))
        {
            HRESULT hrTemp = S_OK;
            hrTemp = ActivateLegacyDevice( FALSE );
        }
    }
    else
    {
        hr = FlushSysExBuffers();

        if (SUCCEEDED(hr))
        {
            hr = MMRESULTToHRESULT(midiInClose(m_hmi));
            m_hmi = NULL;
        }
    }

    return hr;
}    

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::PostSysExBuffers
//
// Initialize and send sysex buffers down to the midi in handle.
//
HRESULT CDirectMusicEmulateInPort::PostSysExBuffers()
{
    HRESULT hr;
    MMRESULT mmr;
    int nBuffer;

    // This will make sure we don't try to unprepare any buffers
    // filled with random garbage.
    //
    for (nBuffer = 0; nBuffer < SYSEX_BUFFERS; nBuffer++)
    {
        LPMIDIHDR pmh = (LPMIDIHDR)&m_SysExBuffers[nBuffer].e.abEvent[0];

        pmh->dwFlags = 0;
    }

    for (nBuffer = 0; nBuffer < SYSEX_BUFFERS; nBuffer++)
    {
        LPMIDIHDR pmh = (LPMIDIHDR)&m_SysExBuffers[nBuffer].e.abEvent[0];

        memset(pmh, 0, sizeof(*pmh));
        pmh->lpData         = (LPSTR)(pmh + 1);
        pmh->dwBufferLength = SYSEX_SIZE;
        pmh->dwUser         = (DWORD_PTR)&m_SysExBuffers[nBuffer];

        hr = MMRESULTToHRESULT(mmr = midiInPrepareHeader(m_hmi, pmh, sizeof(*pmh)));
        if (FAILED(hr))
        {
            return hr;   
        }

        InterlockedIncrement(&m_lPendingSysExBuffers);
        hr = MMRESULTToHRESULT(mmr = midiInAddBuffer(m_hmi, pmh, sizeof(*pmh)));
        if (FAILED(hr))
        {
            InterlockedDecrement(&m_lPendingSysExBuffers);
            return hr;
        }               
    }

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::FlushSysExBuffers
//
// Get all pending sysex buffers back
//
HRESULT CDirectMusicEmulateInPort::FlushSysExBuffers()
{
    MMRESULT mmr;
    int nBuffer;

    m_fFlushing = true;
    
    mmr = midiInReset(m_hmi);
    if (mmr)
    {
        TraceI(0, "midiInReset failed %d!\n", mmr);
        return MMRESULTToHRESULT(mmr);
    }

    LONG lMaxRetry = 500;           // ~ 5 seconds
    while (m_lPendingSysExBuffers)
    {
        TraceI(0, "%d pending sysex buffers\n", m_lPendingSysExBuffers);

        Sleep(10);

        if (!--lMaxRetry) 
        {
            TraceI(0, "Waited too long for sysex to flush from WinMM, continuing anyway.\n");
            break;
        }
    }

    for (nBuffer = 0; nBuffer < SYSEX_BUFFERS; nBuffer++)
    {
        LPMIDIHDR pmh = (LPMIDIHDR)&m_SysExBuffers[nBuffer].e.abEvent[0];

        if (pmh->dwFlags & MHDR_PREPARED)
        {
            midiInUnprepareHeader(m_hmi, pmh, sizeof(*pmh));
        }
    }       

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::Callback()
//
// Process a message from the MIDI API's
//
void CDirectMusicEmulateInPort::Callback(UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    REFERENCE_TIME rt;

    // dwParam1 == timestamp
    // dwParam2 == data 
    //
    rt = m_rtStart + MsToRefTime(dwParam2);

    SyncClocks();
    //SlaveToMaster(&rt);
    rt += m_lTimeOffset - m_lBaseTimeOffset;

    switch (wMsg)
    {
    case MIM_DATA:
        RecordShortEvent(dwParam1, rt);        
        break;
    
    case MIM_LONGDATA:
        RecordSysEx(dwParam1, rt);        
        break;
    }
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::RecordShortEvent
//
// Record a short message (channel messsage or system message).
//// Queue the incoming data as quickly as possible.
//
// Returns TRUE if the data was successfully recorded; FALSE otherwise.
//
BOOL CDirectMusicEmulateInPort::RecordShortEvent(
    DWORD_PTR               dwMessage,           
    REFERENCE_TIME          rtTime)              
{
    QUEUED_EVENT           *pEvent;
    LPBYTE                  pb;
    BYTE                    b;


    pEvent = m_FreeEvents.Alloc();
    if (pEvent == NULL)
    {
        return FALSE;
    }

    pEvent->e.dwChannelGroup = 1;
    pEvent->e.dwFlags = 0;

    // Now we have to parse and rebuild the channel message.
    //
    // NOTE: Endian specific code ahead
    //
    pb = (LPBYTE)&dwMessage;

    assert(!IS_SYSEX(*pb));         /* This should *always* be in MIM_LONGDATA */
    assert(IS_STATUS_BYTE(*pb));    /* API guarantees no running status */

    // Copying over all the bytes is harmless (we have a DWORD in both
    // source and dest) and is faster than checking to see if we have to.
    // 
    b = pEvent->e.abEvent[0] = *pb++;
    pEvent->e.abEvent[1] = *pb++;
    pEvent->e.abEvent[2] = *pb++;

    if (IS_CHANNEL_MSG(b))
    {
        // 8x, 9x, Ax, Bx, Cx, Dx, Ex 
        // 0x..7x invalid, that would need running status 
        // Fx handled below   
        
        pEvent->e.cbEvent = g_cbChanMsg[(b >> 4) & 0x0F];

        // This is also our criteria for thruing
        //
        //ThruClientList(poh, dwMessage);
    }
    else
    {
        // F1..FF 
        // F0 is sysex, should never see it here 
        pEvent->e.cbEvent = g_cbSysCommData[b & 0x0F];
    }

    pEvent->e.rtDelta = rtTime;
    
    ThruEvent(&pEvent->e);

    // ThruEvent mucks with the time.
    //
    pEvent->e.rtDelta = rtTime;

    QueueEvent(pEvent);

    return TRUE;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::RecordSysEx
//
// Record a sysex event
//
// Returns TRUE if the data was successfully recorded; FALSE otherwise.
//
BOOL CDirectMusicEmulateInPort::RecordSysEx(
    DWORD_PTR               dwMessage,           
    REFERENCE_TIME          rtTime)              
{
    LPMIDIHDR pmh = (LPMIDIHDR)dwMessage;
    QUEUED_SYSEX_EVENT *pEvent = (QUEUED_SYSEX_EVENT *)pmh->dwUser;

    if (!m_fFlushing)
    {
        // Used to walk the data
        pmh->dwOffset = 0;
        
        pEvent->e.dwChannelGroup = 1;
        pEvent->e.dwFlags = EVENT_F_MIDIHDR;
        pEvent->e.cbEvent = pmh->dwBytesRecorded;
        pEvent->e.rtDelta = rtTime;
    
        QueueEvent(pEvent);
    }
    
    InterlockedDecrement(&m_lPendingSysExBuffers);    

    return TRUE;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::QueueEvent
//
// Queue a recorded event in the proper order in the read queue.
//
void CDirectMusicEmulateInPort::QueueEvent(QUEUED_EVENT *pEvent)
{

    EnterCriticalSection(&m_csEventQueues);

    if (m_ReadEvents.pRear)
    {
        m_ReadEvents.pRear->pNext = pEvent;
    }
    else
    {
        m_ReadEvents.pFront = pEvent;
    }

    m_ReadEvents.pRear = pEvent;
    pEvent->pNext = NULL;

    if (m_hAppEvent)
    {
        try
        {
            SetEvent(m_hAppEvent);
        } 
        catch (...)
        {
            Trace(0, "Capture: Application notify event handle prematurely free'd!\n");
        }
    }

    LeaveCriticalSection(&m_csEventQueues);
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::ThruEvent
//
//
void CDirectMusicEmulateInPort::ThruEvent(
    DMEVENT *pEvent)
{
    // Since we know we only have one event and we already have it in the right format,
    // just slam it into the thru buffer. We only have to do this because we might modify 
    // it.
    //
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);

    // First see if the event is thruable
    //
    if (pEvent->cbEvent > 3 || ((pEvent->abEvent[0] & 0xF0) == 0xF0))
    {
        // SysEx of some description
        return;
    }

    // Note: legacy driver assures no running status
    //
    DWORD dwSourceChannel = (DWORD)(pEvent->abEvent[0] & 0x0F);

    DMUS_THRU_CHANNEL *pThru = &m_pThruMap[dwSourceChannel];
    if (pThru->pDestinationPort == NULL ||
        pThru->fThruInWin16)
    {
        return;
    }

    if (FAILED(m_pThruBuffer->GetRawBufferPtr(&pbData)))
    {
        TraceI(0, "Thru: GetRawBufferPtr\n");
        return;
    }

    if (FAILED(m_pThruBuffer->GetMaxBytes(&cbData)))
    {
        TraceI(0, "Thru: GetMaxBytes\n");
        return;
    }

    if (cbEvent > cbData)
    {
        TraceI(0, "Thru: cbData %u  cbEvent %u\n", cbData, cbEvent);
        return;
    }
    
    if (FAILED(m_pThruBuffer->SetStartTime(pEvent->rtDelta)) ||
        FAILED(m_pThruBuffer->SetUsedBytes(cbEvent)))
    {
        TraceI(0, "Thru: buffer setup failed\n");
    }

    pEvent->rtDelta = 50000;
    CopyMemory(pbData, pEvent, cbEvent);

    pEvent = (DMEVENT*)pbData;
    pEvent->dwChannelGroup = pThru->dwDestinationChannelGroup;
    pEvent->abEvent[0] = (BYTE)((pEvent->abEvent[0] & 0xF0) | pThru->dwDestinationChannel);

    pThru->pDestinationPort->PlayBuffer(m_pThruBuffer);
}

static VOID CALLBACK midiInProc(
    HMIDIIN                 hMidiIn, 
    UINT                    wMsg, 
    DWORD_PTR               dwInstance, 
    DWORD_PTR               dwParam1,     
    DWORD_PTR               dwParam2)
{
    CDirectMusicEmulateInPort *pPort = (CDirectMusicEmulateInPort*)dwInstance;

    pPort->Callback(wMsg, dwParam1, dwParam2);    
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateInPort::SyncClocks
//
//
void CDirectMusicEmulateInPort::SyncClocks()
{
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;
    LONGLONG drift;

    if (m_fSyncToMaster
	&&	m_pPCClock)
    {
        hr = m_pMasterClock->GetTime(&rtMasterClock);

        if (SUCCEEDED(hr))
        {
            hr = m_pPCClock->GetTime(&rtSlaveClock);
        }
    
        if (SUCCEEDED(hr))
        {
            drift = (rtSlaveClock + m_lTimeOffset) - rtMasterClock;

            // Work-around 46782 for DX8 release:
            // If drift is greater than 10ms, jump to the new offset value instead
            // of drifting there slowly.
            if( drift > 10000 * 10
            ||  drift < 10000 * -10 )
            {
                m_lTimeOffset -= drift;
            }
            else
            {
                m_lTimeOffset -= drift / 100;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmdll.cpp ===
//
// dmdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Dll entry points as well IDirectMusicFactory & 
// IDirectMusicCollectionFactory implementations
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include "debug.h"
#include "debug.h"

#include "oledll.h"

#include "dmusicp.h"
#include "dmcollec.h"
#include "dminstru.h"
#include "dswave.h"
#include "dmvoice.h"
#include "verinfo.h"

//////////////////////////////////////////////////////////////////////
// Globals

// Version information for our class
//
TCHAR g_szFriendlyName[]    = TEXT("DirectMusic");
TCHAR g_szVerIndProgID[]    = TEXT("Microsoft.DirectMusic");
TCHAR g_szProgID[]          = TEXT("Microsoft.DirectMusic.1");

TCHAR g_szCollFriendlyName[]    = TEXT("DirectMusicCollection");
TCHAR g_szCollVerIndProgID[]    = TEXT("Microsoft.DirectMusicCollection");
TCHAR g_szCollProgID[]          = TEXT("Microsoft.DirectMusicCollection.1");

// Thunk helper dll
const char g_szDM32[]      = "DMusic32.dll";
const char g_szKsUser[]    = "KsUser.dll";

// Dll's hModule
//
HMODULE g_hModule = NULL;
HMODULE g_hModuleDM32 = NULL;
HMODULE g_hModuleKsUser = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

// Flags DMI_F_xxx from dmusicp.h
//
DWORD g_fFlags;

static char const g_szDoEmulation[] = "DoEmulation";

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::QueryInterface

HRESULT __stdcall
CDirectMusicFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(IDirectMusicFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::AddRef

ULONG __stdcall
CDirectMusicFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::Release

ULONG __stdcall
CDirectMusicFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::CreateInstance

HRESULT __stdcall
CDirectMusicFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

//
// Removed since we depend on dsound timebomb
//
#if 0
	#pragma message( "Remove time bomb for final!" )
    SYSTEMTIME  st;

    GetSystemTime( &st );

   if ((st.wYear > DX_EXPIRE_YEAR) || 
      ((st.wYear == DX_EXPIRE_YEAR) && (st.wMonth > DX_EXPIRE_MONTH)) ||
      ((st.wYear == DX_EXPIRE_YEAR) && (st.wMonth == DX_EXPIRE_MONTH) && (st.wDay > DX_EXPIRE_DAY)))
   {
        if (0 == MessageBox(NULL, DX_EXPIRE_TEXT,
                            "Microsoft DirectMusic", MB_OK))
        {
            Trace(-1, DX_EXPIRE_TEXT "\n");
            *ppv = NULL;
        }

        return E_FAIL;
    }
#endif

    CDirectMusic *pDM = new CDirectMusic;
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pDM->Init();
    if (!SUCCEEDED(hr)) {
        delete pDM;
        return hr;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicFactory::LockServer

HRESULT __stdcall
CDirectMusicFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::QueryInterface

STDMETHODIMP CDirectMusicCollectionFactory::QueryInterface(const IID &iid,
														   void **ppv)
{
    V_INAME(IDirectMusicCollectionFactory::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


	if(iid == IID_IUnknown || iid == IID_IClassFactory) 
	{
        *ppv = static_cast<IClassFactory*>(this);
    } 
	else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::AddRef

STDMETHODIMP_(ULONG) CDirectMusicCollectionFactory::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::Release

STDMETHODIMP_(ULONG) CDirectMusicCollectionFactory::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
	{
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::CreateInstance

STDMETHODIMP CDirectMusicCollectionFactory::CreateInstance(IUnknown* pUnknownOuter,
														   const IID& iid,
														   void** ppv)
{
    // Argument validation - Debug
    assert(pUnknownOuter == NULL);

	if(pUnknownOuter) 
    {
         return CLASS_E_NOAGGREGATION;
    }

    CCollection *pDMC;
    try
    {
        pDMC = new CCollection;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if(pDMC == NULL) 
	{
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pDMC->QueryInterface(iid, ppv);
    
    pDMC->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicCollectionFactory::LockServer

STDMETHODIMP CDirectMusicCollectionFactory::LockServer(BOOL bLock)
{
    if(bLock) 
	{
        InterlockedIncrement(&g_cLock);
    } 
	else 
	{
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;

    if(clsid == CLSID_DirectMusic)
    {

		pIUnknown = static_cast<IUnknown*> (new CDirectMusicFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicCollection) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicCollectionFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
    pIUnknown->Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusic,
                     g_szFriendlyName,
                     g_szVerIndProgID,
                     g_szProgID);

    UnregisterServer(CLSID_DirectMusicCollection,
                     g_szCollFriendlyName,
                     g_szCollVerIndProgID,
                     g_szCollProgID);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusic,
                   g_szFriendlyName,
                   g_szVerIndProgID,
                   g_szProgID);

	RegisterServer(g_hModule,
				   CLSID_DirectMusicCollection,
				   g_szCollFriendlyName,
				   g_szCollVerIndProgID,
				   g_szCollProgID);
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// LoadDmusic32 - Load if not already loaded
BOOL LoadDmusic32()
{
    if (g_hModuleDM32)
    {
        return TRUE;
    }

    g_hModuleDM32 = (HMODULE)LoadLibrary(g_szDM32);
    if (NULL == g_hModuleDM32)
    {
        Trace(-1, "Could not LoadLibrary Dmusic32.dll. WinMM devices will not be enumerated.\n");
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
// LoadKsUser - Load if not already loaded
BOOL LoadKsUser()
{
    if (g_hModuleKsUser)
    {
        return TRUE;
    }

    g_hModuleKsUser = (HMODULE)LoadLibrary(g_szKsUser);
    if (NULL == g_hModuleKsUser)
    {
        Trace(-1, "Could not LoadLibrary KSUser.dll. WDM devices will not be enumerated.\n");
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    OSVERSIONINFO osvi;
    static int nReferenceCount = 0;
    static BOOL fCSInitialized = FALSE;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(0, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

                osvi.dwOSVersionInfoSize = sizeof(osvi);
                GetVersionEx(&osvi);
                if (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
                {
                    TraceI(0, "Running on Win9x\n");
                    g_fFlags |= DMI_F_WIN9X;
                }

                try 
                {
				    InitializeCriticalSection(&CDirectMusicPortDownload::sDMDLCriticalSection);
                    InitializeCriticalSection(&CDirectSoundWave::sDSWaveCritSect);
                    InitializeCriticalSection(&CDirectMusicVoice::m_csVST);
                }
                catch( ... )
                {
                    return FALSE;
                }
                fCSInitialized = TRUE;
            }

            break;

        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                if (fCSInitialized)
                {
				    DeleteCriticalSection(&CDirectMusicPortDownload::sDMDLCriticalSection);
                    DeleteCriticalSection(&CDirectSoundWave::sDSWaveCritSect);
                    DeleteCriticalSection(&CDirectMusicVoice::m_csVST);
                    fCSInitialized = FALSE;
                }

                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }
            break;
            
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmeport.cpp ===
//
// dmeport.cpp
//
// Emulation for MME drivers on NT
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Open device
// PlayBuffer
// Activate
// Close: Close device
// InputWorkerDataReady
// Take out share stuff
//
// 
#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>
#include <string.h>

#include "debug.h"
#include "dmusicp.h"
#include "dmeport.h"
#include "resource.h"

//
// Registry location of legacy driver port definitions
const char cszPortsRoot[] = REGSTR_PATH_PRIVATEPROPERTIES "\\Midi\\Ports";

// String to tag emulated ports
// 
static WCHAR wszEmulated[128];

#define MAXCCH(x) (sizeof(x) / sizeof(x[0]))

//------------------------------------------------------------------------------
//
// EnumLegacyDevices
//
// Update the port list with legacy devices enumerated via 
// the WinMM MIDI API.
//
//
HRESULT EnumLegacyDevices(
    LPVOID              pInstance,
    PORTENUMCB          cb)                          
{
    MIDIOUTCAPS         moc;
    MIDIINCAPS          mic;
    int                 idxDev;
    int                 cDev;
    UINT                cAdded;
    HRESULT             hr;
    HKEY                hkPortsRoot;
    DMUS_PORTCAPS       dmpc;

    if (wszEmulated[0] == 0)
    {
        char    sz[128];
        int     cch;

        cch = LoadString(g_hModule,
                         IDS_EMULATED,
                         sz,
                         sizeof(sz));
        if (cch)
        {
            MultiByteToWideChar(
                CP_OEMCP,
                0,
                sz,
                -1,
                wszEmulated,
                MAXCCH(wszEmulated));
        }
    }

    // Initialize caps with stuff that doesn't change
    //
    ZeroMemory(&dmpc, sizeof(dmpc));
    dmpc.dwSize = sizeof(dmpc);
    dmpc.dwMaxChannelGroups = 1;


    // Try to open the port registry key. We will continue even if this fails and use
    // non-persistent GUID's.
    //
    if (RegCreateKey(HKEY_LOCAL_MACHINE, cszPortsRoot, &hkPortsRoot))
    {
        hkPortsRoot = NULL;
    }

    cAdded = 0;
    
    // MIDI output devices
    //
    // Starts at -1 == MIDI mapper
    //
    cDev = (int)midiOutGetNumDevs();
    for (idxDev = -1; idxDev < cDev; ++idxDev)
    {
        if (midiOutGetDevCaps((UINT)idxDev, &moc, sizeof(moc)))
        {
            continue;
        }

        WCHAR wsz[128];

        MultiByteToWideChar(
            CP_OEMCP,
            0,
            moc.szPname,
            -1,
            wsz,
            MAXCCH(wsz));

        wcscat(wsz, wszEmulated);

        wcsncpy(dmpc.wszDescription, wsz, MAXCCH(dmpc.wszDescription) - 1);
        dmpc.wszDescription[MAXCCH(dmpc.wszDescription) - 1] = 0;

        dmpc.dwClass = DMUS_PC_OUTPUTCLASS;
        dmpc.dwType  = DMUS_PORT_WINMM_DRIVER;
        dmpc.dwFlags = DMUS_PC_SHAREABLE;

        if (moc.wTechnology == MOD_MIDIPORT)
        {
            dmpc.dwFlags |= DMUS_PC_EXTERNAL;
        }
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,
                   -1,          
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    // MIDI input devices
    //
    // NOTE: Starts at 0, no input mapper
    //
    cDev = (int)midiInGetNumDevs();
    for (idxDev = 0; idxDev < cDev; ++idxDev)
    {
        if (midiInGetDevCaps((UINT)idxDev, &mic, sizeof(mic)))
        {
            continue;
        }
                   
        WCHAR wsz[128];

        MultiByteToWideChar(
            CP_OEMCP,
            0,
            mic.szPname,
            -1,
            wsz,
            MAXCCH(wsz));

        wcscat(wsz, wszEmulated);

        wcsncpy(dmpc.wszDescription, wsz, MAXCCH(dmpc.wszDescription) - 1);
        dmpc.wszDescription[MAXCCH(dmpc.wszDescription) - 1] = 0;

        
        dmpc.dwClass = DMUS_PC_INPUTCLASS;
        dmpc.dwFlags = DMUS_PC_EXTERNAL;
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,        // PinID -1 flags as legacy device
                   -1,
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    if (hkPortsRoot)
    {
        RegCloseKey(hkPortsRoot);
    }

    return cAdded ? S_OK : S_FALSE;
}

//------------------------------------------------------------------------------
//
// CreateCDirectMusicEmulatePort
//
//
HRESULT CreateCDirectMusicEmulatePort(
    PORTENTRY                   *pPE,
    CDirectMusic                *pDM,
    DMUS_PORTPARAMS8            *pPortParams,
    IDirectMusicPort8           **pPort)
{
    HRESULT hr;

    *pPort = NULL;
    
    CDirectMusicEmulatePort *pEPort;
    
    if (pPE->pc.dwClass == DMUS_PC_OUTPUTCLASS)
    {
        pEPort = new CDirectMusicEmulateOutPort(pPE, pDM);
    }
    else
    {
        pEPort = new CDirectMusicEmulateInPort(pPE, pDM);
    }
    if (NULL == pEPort)
    {
        return E_OUTOFMEMORY;
    }

    hr = pEPort->Init(pPortParams);
    if (!SUCCEEDED(hr))
    {
        delete pEPort;
        return hr;
    }
    
    *pPort = pEPort;
    
    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::CDirectMusicEmulatePort
//
//
CDirectMusicEmulatePort::CDirectMusicEmulatePort(
                                                 PORTENTRY *pPE,    
                                                 CDirectMusic *pDM) :
                                                 m_cRef(1)
                                                 ,m_id(pPE->idxDevice)
                                                 ,m_pDM(pDM)
                                                 ,m_pLatencyClock(NULL)
                                                 ,m_pMasterClock(NULL)
                                                 ,m_lActivated(0)
                                                 ,m_dmpc(pPE->pc)
{
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::~CDirectMusicEmulatePort
//
//
CDirectMusicEmulatePort::~CDirectMusicEmulatePort()
{
    Close();
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Init
//
//

// Flags we recognize 
//
#define DMUS_ALL_FLAGS (DMUS_PORTPARAMS_VOICES |            \
                        DMUS_PORTPARAMS_CHANNELGROUPS |     \
                        DMUS_PORTPARAMS_AUDIOCHANNELS |     \
                        DMUS_PORTPARAMS_SAMPLERATE |        \
                        DMUS_PORTPARAMS_EFFECTS |           \
                        DMUS_PORTPARAMS_SHARE)

// Of those, which do we actually look at?
//
#define DMUS_SUP_FLAGS (DMUS_PORTPARAMS_CHANNELGROUPS)

HRESULT CDirectMusicEmulatePort::Init(
    LPDMUS_PORTPARAMS   pPortParams)
{
    HRESULT             hr;
    BOOL                fChangedParms;

    // Get, but don't hold onto, the notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (FAILED(hr))
    {
        return hr;
    }
    m_pNotify->Release();

    // Munge the portparams to match what we support.
    //
    fChangedParms = FALSE;
    if (pPortParams->dwValidParams & ~DMUS_ALL_FLAGS) 
    {
        Trace(0, "Undefined flags in port parameters: %08X\n", pPortParams->dwValidParams & ~DMUS_ALL_FLAGS);
        // Flags set we don't recognize.
        //
        pPortParams->dwValidParams &= DMUS_ALL_FLAGS;
        fChangedParms = TRUE;
    }

    // We recognize these flags but don't support them.
    //
    if (pPortParams->dwValidParams & ~DMUS_SUP_FLAGS)
    {
        pPortParams->dwValidParams &= DMUS_SUP_FLAGS;
        fChangedParms = TRUE;
    }

    // Channel groups better be one.
    //
    if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
    {
        if (pPortParams->dwChannelGroups != 1)
        {
            pPortParams->dwChannelGroups = 1;
            fChangedParms = TRUE;
        }
    }
    else
    {
        pPortParams->dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
        pPortParams->dwChannelGroups = 1;
    }

    // Set up the master clock and our latency clock
    //
    hr = InitializeClock();
    if (FAILED(hr))
    {
        return hr;
    }

    return fChangedParms ? S_FALSE : S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::InititalizeClock
//
//
HRESULT CDirectMusicEmulatePort::InitializeClock()
{
    HRESULT             hr;
    GUID                guidMasterClock;

    hr = m_pDM->GetMasterClock(&guidMasterClock, &m_pMasterClock);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pLatencyClock = new CEmulateLatencyClock(m_pMasterClock);

    if (NULL == m_pLatencyClock)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::QueryInterface
//
//
STDMETHODIMP CDirectMusicEmulatePort::QueryInterface(
    const IID       &iid,
    void            **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPort8)
    {
        *ppv = static_cast<IDirectMusicPort8*>(this);
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicThru)
    {
        *ppv = static_cast<IDirectMusicThru*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::AddRef
//
//
STDMETHODIMP_(ULONG) CDirectMusicEmulatePort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Release
//
//
STDMETHODIMP_(ULONG) CDirectMusicEmulatePort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        if (m_pNotify)
        {
            m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        }
        
        delete this;
        return 0;
    }

    return m_cRef;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Compact
//
//
STDMETHODIMP CDirectMusicEmulatePort::Compact()
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetCaps
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &m_dmpc, sizeof(DMUS_PORTCAPS));

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::DeviceIoControl
//
//
STDMETHODIMP CDirectMusicEmulatePort::DeviceIoControl(
    DWORD           dwIoControlCode, 
    LPVOID          lpInBuffer, 
    DWORD           nInBufferSize, 
    LPVOID          lpOutBuffer, 
    DWORD           nOutBufferSize, 
    LPDWORD         lpBytesReturned, 
    LPOVERLAPPED    lpOverlapped)
{
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetNumChannelGroups
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetNumChannelGroups(
    DWORD           dwNumChannelGroups)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (dwNumChannelGroups != 1)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::PlayBuffer 
//
//
STDMETHODIMP CDirectMusicEmulatePort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetNumChannelGroups
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetNumChannelGroups(
    LPDWORD     pdwChannelGroups)
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *pdwChannelGroups = 1;
    
    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Read
//
//
STDMETHODIMP CDirectMusicEmulatePort::Read(
    IDirectMusicBuffer *pIBuffer)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetReadNotificationHandle
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::DownloadInstrument 
//
//
STDMETHODIMP CDirectMusicEmulatePort::DownloadInstrument(
    IDirectMusicInstrument              *pInstrument,
    IDirectMusicDownloadedInstrument    **pDownloadedInstrument,
    DMUS_NOTERANGE                      *pRange,
    DWORD                               dw)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::UnloadInstrument 
//
//
STDMETHODIMP CDirectMusicEmulatePort::UnloadInstrument(
    IDirectMusicDownloadedInstrument *pDownloadedInstrument)
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetLatencyClock
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetLatencyClock(
    IReferenceClock **ppClock)
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_pLatencyClock->AddRef();
    *ppClock = m_pLatencyClock;
    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetRunningStats
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Activate
//
//
STDMETHODIMP CDirectMusicEmulatePort::Activate(
    BOOL    fActivate)
{
	V_INAME(IDirectMusicPort::Activate);
    
    HRESULT hr;
	
	if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1)) 
        {
            Trace(0, "Activate: Already active\n");
            // Already activated
            //
            return S_FALSE;
        }    

        hr = ActivateLegacyDevice(TRUE);
        if (FAILED(hr))
        {
            Trace(0, "Activate: Activate Failed with 0x%08X\n", hr);
            InterlockedExchange(&m_lActivated, 0);
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0)
        {
            Trace(0, "Activate: Already inactive\n");
            // Already deactivated
            //
            return S_FALSE;
        }

        hr = ActivateLegacyDevice(FALSE);
        if (FAILED(hr))
        {
            Trace(0, "Activate: Deactivate Failed with 0x%08X\n", hr);
            InterlockedExchange(&m_lActivated, 1);
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetChannelPriority
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    return E_NOTIMPL;
}
    
//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetChannelPriority
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    return E_NOTIMPL;
}    


//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Close
//
//
STDMETHODIMP CDirectMusicEmulatePort::Close()
{
    Activate(FALSE);

    if (m_pLatencyClock)
    {
        m_pLatencyClock->Close();
        m_pLatencyClock->Release();
        m_pLatencyClock = NULL;
    }

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    m_pDM = NULL;
    m_pNotify = NULL;

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::StartVoice
//
//
STDMETHODIMP CDirectMusicEmulatePort::StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}    

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::StopVoice
//
//
STDMETHODIMP CDirectMusicEmulatePort::StopVoice(
     DWORD dwVoiceID,
     REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetVoiceState
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetVoiceState(   
     DWORD dwVoice[], 
     DWORD cbVoice,
     DMUS_VOICE_STATE VoiceState[])
{
    return E_NOTIMPL;
}
    
//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::Refresh
//
//
STDMETHODIMP CDirectMusicEmulatePort::Refresh(
     DWORD dwDownloadID,
     DWORD dwFlags)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::ThruChannel
//
//
STDMETHODIMP CDirectMusicEmulatePort::ThruChannel(
    DWORD               dwSourceChannelGroup, 
    DWORD               dwSourceChannel, 
    DWORD               dwDestinationChannelGroup,
    DWORD               dwDestinationChannel,
    LPDIRECTMUSICPORT   pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetDirectSound
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetDirectSound(
    LPDIRECTSOUND           pDirectSound, 
    LPDIRECTSOUNDBUFFER     pDirectSoundBuffer)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetFormat
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetFormat(
    LPWAVEFORMATEX  pWaveFormatEx, 
    LPDWORD         pdwWaveFormatExSize, 
    LPDWORD         pdwBufferSize)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::DownloadWave
//
//
STDMETHODIMP CDirectMusicEmulatePort::DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint)    
{                                   
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::UnloadWave
//
//
STDMETHODIMP CDirectMusicEmulatePort::UnloadWave(
    IN  IDirectSoundDownloadedWaveP *pWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pWave);

    return E_NOTIMPL;
}

            
//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::AllocVoice
//
//
STDMETHODIMP CDirectMusicEmulatePort::AllocVoice(
	 IDirectSoundDownloadedWaveP *pWave,     
	 DWORD dwChannel,                       
	 DWORD dwChannelGroup,                  
	 REFERENCE_TIME rtStart,                     
	 SAMPLE_TIME stLoopStart,
	 SAMPLE_TIME stLoopEnd,         
	 IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}        

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::AssignChannelToBuses
//
//
STDMETHODIMP CDirectMusicEmulatePort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    return E_NOTIMPL;
}        

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::SetSink
//
//
STDMETHODIMP CDirectMusicEmulatePort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    return E_NOTIMPL;
}        

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::GetSink
//
//
STDMETHODIMP CDirectMusicEmulatePort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    return E_NOTIMPL;
}        

GENERICPROPERTY CDirectMusicEmulatePort::m_aProperty[] = 
{      
    { &GUID_DMUS_PROP_LegacyCaps,           // Set
      0,                                    // Item
      KSPROPERTY_SUPPORT_GET,               // KS support flags
      GENPROP_F_FNHANDLER,                  // GENPROP flags
      NULL, 0,                              // static data and size
      CDirectMusicEmulatePort::LegacyCaps   // Handler
    }
};

const int CDirectMusicEmulatePort::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulatePort::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CDirectMusicEmulatePort::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid && 
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }

    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::KsProperty
//
//
STDMETHODIMP CDirectMusicEmulatePort::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;
    if ((dwFlags == 0) || (dwFlags == (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET)))
    {
    }

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_GET, pvPropertyData, pulBytesReturned);
            }
    
            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_SET, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;
            

        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;    
            *pulBytesReturned = sizeof(DWORD);
            
            return S_OK;
    }

    Trace(-1, "%s: Flags must contain one of\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::KsMethod
//
//
STDMETHODIMP CDirectMusicEmulatePort::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::KsEvent
//
//
STDMETHODIMP CDirectMusicEmulatePort::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    return DMUS_E_UNKNOWN_PROPERTY;
}


//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::CEmulateLatencyClock
//
//
CEmulateLatencyClock::CEmulateLatencyClock(IReferenceClock *pMasterClock) :
   m_cRef(1),
   m_pMasterClock(pMasterClock)
{
    pMasterClock->AddRef();
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::~CEmulateLatencyClock
//
//
CEmulateLatencyClock::~CEmulateLatencyClock()
{
    Close();
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::QueryInterface
//
//
STDMETHODIMP CEmulateLatencyClock::QueryInterface(
    const IID &iid,
    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::AddRef
//
//
STDMETHODIMP_(ULONG) CEmulateLatencyClock::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::Release
//
//
STDMETHODIMP_(ULONG) CEmulateLatencyClock::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::GetTime
//
//
STDMETHODIMP
CEmulateLatencyClock::GetTime(REFERENCE_TIME *pTime)
{
    REFERENCE_TIME rt;

    V_INAME(IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    if (!m_pMasterClock)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }
    
    HRESULT hr = m_pMasterClock->GetTime(&rt);

    rt += 3 * FIXED_LEGACY_LATENCY_OFFSET;          // Default : 10 ms
    *pTime = rt;

    return hr;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::AdviseTime
//
//
STDMETHODIMP CEmulateLatencyClock::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::AdvisePeriodic
//
//
STDMETHODIMP CEmulateLatencyClock::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::Unadvise
//
//
STDMETHODIMP CEmulateLatencyClock::Unadvise(
    DWORD dwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

//------------------------------------------------------------------------------
//
// CEmulateLatencyClock::Close
//
//
void CEmulateLatencyClock::Close()
{
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulatePort::MMRESULTToHRESULT
//
//
HRESULT MMRESULTToHRESULT(
    MMRESULT mmr)
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_ALLOCATED:
        return DMUS_E_DEVICE_IN_USE;

    case MIDIERR_BADOPENMODE:
        return DMUS_E_ALREADYOPEN;

    case MMSYSERR_NOMEM:
        return E_OUTOFMEMORY;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmerport.cpp ===
//
// dmerport.cpp
//
// Emulated Render port (NT)
//
// Copyright (c) 1997-1999 Microsoft Corporation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>

#include "debug.h"
#include "dmusicp.h"
#include "dmeport.h"

static VOID CALLBACK midiOutProc(
    HMIDIOUT                hMidiOut, 
    UINT                    wMsg, 
    DWORD_PTR               dwInstance, 
    DWORD_PTR               dwParam1,     
    DWORD_PTR               dwParam2);

static VOID CALLBACK timerProc(
    UINT                    uTimerID, 
    UINT                    uMsg, 
    DWORD_PTR               dwUser, 
    DWORD_PTR               dw1, 
    DWORD_PTR               dw2);

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulateOutPort::CDirectMusicEmulateOutPort
//
//
CDirectMusicEmulateOutPort::CDirectMusicEmulateOutPort(
                                                 PORTENTRY *pPE,    
                                                 CDirectMusic *pDM) :
                                                 CDirectMusicEmulatePort(pPE, pDM),
                                                 m_hmo(NULL),
                                                 m_pPlayQueue(NULL),
                                                 m_lTimerId(0),
                                                 m_fClosing(FALSE)
{
}

//------------------------------------------------------------------------------
// 
// CDirectMusicEmulateOutPort::~CDirectMusicEmulateOutPort
//
//
CDirectMusicEmulateOutPort::~CDirectMusicEmulateOutPort()
{
    Close();    
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::Init
//
//
HRESULT CDirectMusicEmulateOutPort::Init(
    LPDMUS_PORTPARAMS pPortParams)
{
    HRESULT         hr;

    hr = CDirectMusicEmulatePort::Init(pPortParams);
    if (FAILED(hr))
    {
        return hr;
    }

    try 
    {
        InitializeCriticalSection(&m_csPlayQueue);
    }
    catch(...)
    {
        return E_OUTOFMEMORY;
    }

    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::Close
//
//
HRESULT CDirectMusicEmulateOutPort::Close()
{
    m_fClosing = TRUE;
    if (m_lTimerId)
    {
        timeKillEvent(m_lTimerId);
        m_lTimerId = 0;
    }

    DeleteCriticalSection(&m_csPlayQueue);

    return CDirectMusicEmulatePort::Close();
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::LegacyCaps
//
//
HRESULT CDirectMusicEmulateOutPort::LegacyCaps(
    ULONG               ulId, 
    BOOL                fSet, 
    LPVOID              pbBuffer, 
    PULONG              pcbBuffer)
{
    if (fSet == KSPROPERTY_SUPPORT_SET)
    {
        return DMUS_E_SET_UNSUPPORTED;
    }

    MIDIOUTCAPS moc;
    LPBYTE      pbData;
    ULONG       cbData;

    MMRESULT mmr = midiOutGetDevCaps(m_id, &moc, sizeof(moc));
    if (mmr)
    {
        TraceI(0, "midiOutGetDevCaps failed!\n");
        return MMRESULTToHRESULT(mmr);
    }

    pbData = (LPBYTE)&moc;
    cbData = sizeof(moc);

    ULONG cbToCopy = min(*pcbBuffer, cbData);
    CopyMemory(pbBuffer, pbData, cbToCopy);
    *pcbBuffer = cbToCopy;

    return S_OK;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::ActivateLegacyDevice
//
//
HRESULT CDirectMusicEmulateOutPort::ActivateLegacyDevice(
    BOOL fActivate)
{
    MMRESULT mmr;

    if (fActivate)
    {
        TraceI(0, "Emulate out activate\n");
        assert(m_hmo == NULL);
        mmr = midiOutOpen(
            &m_hmo,
            m_id,
            (DWORD_PTR)midiOutProc,
            (DWORD_PTR)this,
            CALLBACK_FUNCTION);
        timeBeginPeriod(5);
    }
    else
    {
        TraceI(0, "Emulate out deactivate\n");
        if (m_lTimerId)
        {
            timeKillEvent(m_lTimerId);
            m_lTimerId = 0;
        }
        assert(m_hmo);
        mmr = midiOutClose(m_hmo);
        m_hmo = NULL;
        timeEndPeriod(5);
    }
    
    if (mmr) 
    {
        TraceI(0, "Emulate out activate(%d) returned mmr %d\n", 
            fActivate, mmr);
    }       

    return MMRESULTToHRESULT(mmr);
}    

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::PlayBuffer 
//
//
STDMETHODIMP CDirectMusicEmulateOutPort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    LPBYTE                  pbBuffer;
    DWORD                   cbBuffer;
    REFERENCE_TIME          rtStart;
    MMRESULT                mmr;

    if (!m_hmo)
    {
        return DMUS_E_SYNTHINACTIVE;
    }

    // Get buffer parameters
    // 
    HRESULT hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }
    
    hr = pIBuffer->GetUsedBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetStartTime(&rtStart);
    if (FAILED(hr))
    {
        return hr;
    }

    // Walk buffer and insert events
    //
    EnterCriticalSection(&m_csPlayQueue);

    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMEVENT)) 
        {
            hr = E_INVALIDARG;
            break;
        }

        DMEVENT *pev = (DMEVENT*)pbBuffer;
        DWORD cbEvent = DMUS_EVENT_SIZE(pev->cbEvent);
        if (cbEvent > cbBuffer)
        {
            hr = E_INVALIDARG;
            break;
        }
        
        pbBuffer += cbEvent;
        cbBuffer -= cbEvent;
        
        // We only play events on channel group 1 (0 is broadcast, so we
        // play that as well).
        //
        if (pev->dwChannelGroup > 1)
        {
            continue;
        }

        // Allocate an event to queue
        //
        DMQUEUEDEVENT *pqe = m_poolEvents.Alloc();
        if (pqe == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pqe->m_event = *pev;
        pqe->m_event.rtDelta += rtStart;

        if (pev->cbEvent > sizeof(pqe->m_event.abEvent)) 
        {
            pqe->m_pbEvent = new BYTE[sizeof(MIDIHDR) + pev->cbEvent];
            if (pqe->m_pbEvent == NULL)
            {
                m_poolEvents.Free(pqe);
                hr = E_OUTOFMEMORY;
                break;
            }
            LPMIDIHDR pmh = (LPMIDIHDR)pqe->m_pbEvent;

            memset(pmh, 0, sizeof(*pmh));
            pmh->lpData             = (LPSTR)(pmh + 1);
            pmh->dwBufferLength     = pev->cbEvent;
            pmh->dwBytesRecorded    = pev->cbEvent;
            pmh->dwUser             = (DWORD_PTR)pqe;

            memcpy(pmh->lpData, pev->abEvent, pev->cbEvent);
                
            LeaveCriticalSection(&m_csPlayQueue);
            mmr = midiOutPrepareHeader(m_hmo, pmh, sizeof(*pmh));
            EnterCriticalSection(&m_csPlayQueue);
            
            if (mmr)
            {
                delete[] pqe->m_pbEvent;
                pqe->m_pbEvent = pqe->m_event.abEvent;
                m_poolEvents.Free(pqe);
                
                hr = MMRESULTToHRESULT(mmr);
                break;
            }
        }
        else
        {
            pqe->m_pbEvent = pqe->m_event.abEvent;
        }

        // Queue the event
        //
        DMQUEUEDEVENT *pPrev;        
        DMQUEUEDEVENT *pCurr;

        for (pPrev = NULL, pCurr = m_pPlayQueue; pCurr; pPrev = pCurr, pCurr = pCurr->m_pNext) 
        {
            if (pqe->m_event.rtDelta < pCurr->m_event.rtDelta)
            {
                break;
            }
        }

        if (pPrev) 
        {
            pPrev->m_pNext = pqe;
        }        
        else
        {
            m_pPlayQueue = pqe;
        }

        pqe->m_pNext = pCurr;

        TraceI(4, "Enqueued at %I64d\n", pqe->m_event.rtDelta);

        REFERENCE_TIME rt = 0;
        for (pqe = m_pPlayQueue; pqe; pqe = pqe->m_pNext) {
            if (pqe->m_event.rtDelta < rt) {
                TraceI(0, "Queue out of order!\n");
            }
            rt = pqe->m_event.rtDelta;
        }
                
    }
    
    LeaveCriticalSection(&m_csPlayQueue);

    SetNextTimer();

    return hr;
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::Callback
//
//
void CDirectMusicEmulateOutPort::Callback(
    UINT                    wMsg,   
    DWORD_PTR               dwParam1, 
    DWORD_PTR               dwParam2)
{
    if (wMsg == MOM_DONE)
    {
        EnterCriticalSection(&m_csPlayQueue);
        
        midiOutUnprepareHeader(m_hmo, (MIDIHDR*)dwParam1, sizeof(MIDIHDR));
        
        DMQUEUEDEVENT *pqe =(DMQUEUEDEVENT*)((LPMIDIHDR)dwParam1)->dwUser;
        
        delete[] pqe->m_pbEvent;
        pqe->m_pbEvent = pqe->m_event.abEvent;
        m_poolEvents.Free(pqe);
        
        LeaveCriticalSection(&m_csPlayQueue);
    }
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::Timer
//
//
void CDirectMusicEmulateOutPort::Timer()
{
    REFERENCE_TIME          rtNow;
    MMRESULT                mmr;
    bool                    fFree;

    if (m_fClosing)
    {
        TraceI(2, "Timer: Closing.\n");
        return;
    }

    HRESULT hr = m_pMasterClock->GetTime(&rtNow);
    if (FAILED(hr))
    {
        TraceI(1, "Timer: SetNextTimer() because this one failed to read the time.\n");
        SetNextTimer();
        return;
    }

    EnterCriticalSection(&m_csPlayQueue);
    TraceI(0, "Timer thread: it is now %I64d\n", rtNow);
    if (m_pPlayQueue)
        TraceI(0, "Timer thread: queue head %I64d\n", m_pPlayQueue->m_event.rtDelta);

    while (m_pPlayQueue && m_pPlayQueue->m_event.rtDelta <= rtNow)
    {
        DMQUEUEDEVENT *pqe = m_pPlayQueue;
        m_pPlayQueue = m_pPlayQueue->m_pNext;

        DWORD dwLate = (DWORD)((rtNow - pqe->m_event.rtDelta) / (10 * 1000));
        
        if (pqe->m_event.cbEvent <= sizeof(pqe->m_event.abEvent))
        {
            mmr = midiOutShortMsg(m_hmo, *(LPDWORD)pqe->m_event.abEvent);
            if (mmr) 
            {
                break;
            }                
            fFree = true;
        }
        else
        {
            LPMIDIHDR pmh = (LPMIDIHDR)pqe->m_pbEvent;
            
            LeaveCriticalSection(&m_csPlayQueue);
            mmr = midiOutLongMsg(m_hmo, pmh, sizeof(*pmh));
            EnterCriticalSection(&m_csPlayQueue);
            if (mmr)
            {
                break;
            }
            
            fFree = false;                               
        }

        if (fFree)
        {
            m_poolEvents.Free(pqe);
        }
    }

    LeaveCriticalSection(&m_csPlayQueue);

    SetNextTimer();
}

//------------------------------------------------------------------------------
//
// CDirectMusicEmulateOutPort::SetNextTimer
//
//
void CDirectMusicEmulateOutPort::SetNextTimer()
{
    REFERENCE_TIME rtNow;
    REFERENCE_TIME rtDelta;
    HRESULT hr = m_pMasterClock->GetTime(&rtNow);

    if (FAILED(hr))
    {
        TraceI(1, "SetNextTimer: GetTime failed\n");
        return;
    }

    EnterCriticalSection(&m_csPlayQueue);

    if (m_pPlayQueue == NULL || m_fClosing)
    {
        TraceI(2, "SetNextTimer: Nothing queued or closing.\n");
        LeaveCriticalSection(&m_csPlayQueue);
        return;
    }
    else
    {
        rtDelta = m_pPlayQueue->m_event.rtDelta - rtNow;   
    }

    LeaveCriticalSection(&m_csPlayQueue);
    
    
 

    if (m_lTimerId)
    {
        TraceI(2, "SetNextTimer: Reset old timer\n");

        timeKillEvent(m_lTimerId);
        m_lTimerId = 0;
    }

    LONG msDelta = (DWORD)(rtDelta / (10 * 1000));

    if (msDelta < 5) 
    {
        TraceI(2, "SetNextTimer: delta bumped -> 5 ms\n");
        msDelta = 5;
    }

    m_lTimerId = timeSetEvent(msDelta, 5, timerProc, (DWORD_PTR)this, TIME_ONESHOT | TIME_CALLBACK_FUNCTION | TIME_KILL_SYNCHRONOUS);
    if (!m_lTimerId)
    {
        TraceI(1, "timeSetEvent failed!\n");
    }

    TraceI(4, "SetNextTimer in %d ms\n", msDelta);
}

//------------------------------------------------------------------------------
//
// midiOutProc
//
//
static VOID CALLBACK midiOutProc(
    HMIDIOUT                hMidiOut, 
    UINT                    wMsg, 
    DWORD_PTR               dwInstance, 
    DWORD_PTR               dwParam1, 
    DWORD_PTR               dwParam2)
{
    ((CDirectMusicEmulateOutPort*)dwInstance)->Callback(wMsg, dwParam1, dwParam2);
}

//------------------------------------------------------------------------------
//
// timerProc
//
//
static VOID CALLBACK timerProc(
    UINT                    uTimerID, 
    UINT                    uMsg, 
    DWORD_PTR               dwUser, 
    DWORD_PTR               dw1, 
    DWORD_PTR               dw2)
{
    ((CDirectMusicEmulateOutPort*)dwUser)->Timer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dminsobj.h ===
//
// dminsobj.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//

#ifndef DMINSOBJ_H
#define DMINSOBJ_H

#include "dmregion.h"
#include "dmextchk.h"
#include "dmcount.h"

class CCopyright;
class CArticulation;
class CRiffParser;

class CInstrObj : public AListItem      
{       
friend class CCollection;
friend class CInstrument;
friend class CDirectMusicPortDownload;

private:
	CInstrObj();
	~CInstrObj();

	CInstrObj* GetNext(){return (CInstrObj*)AListItem::GetNext();}
	HRESULT Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent);
	HRESULT Size(DWORD* pdwSize);
	HRESULT Write(void* pvoid);
    void SetPort(CDirectMusicPortDownload *pPort,BOOL fAllowDLS2);
    void CheckForConditionals();

	void Cleanup();
	HRESULT BuildRegionList(CRiffParser *pParser);
	HRESULT ExtractRegion(CRiffParser *pParser, BOOL fDLS1);
	HRESULT BuildWaveIDList();
	HRESULT	GetWaveCount(DWORD* pdwCount);
	HRESULT GetWaveIDs(DWORD* pdwWaveIds);
	HRESULT FixupWaveRefs();

private:
//	CRITICAL_SECTION		m_DMInsCriticalSection;
    BOOL                    m_fCSInitialized;
	DWORD                   m_dwPatch;
	CRegionList				m_RegionList;
//	DWORD					m_dwCountRegion;
	CArticulationList		m_ArticulationList;
	CCopyright*				m_pCopyright;
	CExtensionChunkList		m_ExtensionChunkList;
	DWORD					m_dwCountExtChk;
	DWORD					m_dwId;
	
	// Weak reference since we live in a CInstrument which has 
	// a reference to the collection
	CCollection*	        m_pParent;										

	CWaveIDList				m_WaveIDList;   // List of WaveIDs, one for each wave that this instrument references.
	DWORD                   m_dwNumOffsetTableEntries;
	DWORD					m_dwSize;       // Size required to download instrument to current port.
    CDirectMusicPortDownload * m_pPort;     // Used to track which port condition chunks, etc, are valid for.
    BOOL                    m_fNewFormat;   // Indicates the current port handles INSTRUMENT2 chunks. 
    BOOL                    m_fHasConditionals; // Indicates the instrument has conditional chunks.
#ifdef DBG
	bool					m_bLoaded;
#endif
};      

#endif // #ifndef DMINSOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmextchk.cpp ===
//
// dmextchk.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation.  All rights reserved.
//

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmextchk.h"
#include "dls2.h"
#include "dmportdl.h"

//////////////////////////////////////////////////////////////////////
// Class CExtensionChunk

//////////////////////////////////////////////////////////////////////
// CExtensionChunk::Load

HRESULT CExtensionChunk::Load(CRiffParser *pParser)
{
    HRESULT hr = S_OK;

    DWORD cbRead = 0;
    RIFFIO *pChunk = pParser->GetChunk();

    if(pChunk->cksize < DMUS_MIN_DATA_SIZE)
    {
        m_dwExtraChunkData = 0;
    }
    else
    {
        m_dwExtraChunkData = pChunk->cksize - DMUS_MIN_DATA_SIZE;
    }

    m_pExtensionChunk = (DMUS_EXTENSIONCHUNK*)
        new BYTE[CHUNK_ALIGN(sizeof(DMUS_EXTENSIONCHUNK) + m_dwExtraChunkData)];

    if(m_pExtensionChunk)
    {
        m_pExtensionChunk->cbSize = pChunk->cksize;
        m_pExtensionChunk->ulNextExtCkIdx = 0; // We will set this member to its final value later
        m_pExtensionChunk->ExtCkID = pChunk->ckid;

        hr = pParser->Read(m_pExtensionChunk->byExtCk, pChunk->cksize);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if(FAILED(hr))
    {
        Cleanup();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CExtensionChunk::Write

HRESULT CExtensionChunk::Write(void* pv, DWORD* pdwCurOffset, DWORD dwIndexNextExtChk)
{
    // Argument validation - Debug
    assert(pv);
    assert(pdwCurOffset);

    HRESULT hr = S_OK;

    CopyMemory(pv, (void *)m_pExtensionChunk, Size());
    *pdwCurOffset += Size();
    ((DMUS_EXTENSIONCHUNK*)pv)->ulNextExtCkIdx = dwIndexNextExtChk;

    return hr;
}

BOOL CStack::Push(long lData)

{
    if (m_dwIndex >= STACK_DEPTH) return FALSE;
    m_lStack[m_dwIndex++] = lData;
    return TRUE;
}

long CStack::Pop()

{
    if (m_dwIndex > 0)
    {
        return m_lStack[--m_dwIndex];
    }
    return 0;
}

BOOL CConditionChunk::Evaluate(CDirectMusicPortDownload *pPort)

{
    long lLength = m_dwLength;
    if ( lLength )
    {
        CStack  Stack;
        BOOL fResult = FALSE;
        BYTE *pData = m_bExpression;
        while (lLength > 0)
        {
            USHORT usToken;
            long lTemp;
            long lOpA, lOpB;
            GUID dlsid;
            memcpy(&usToken,pData,sizeof(USHORT));
            pData += sizeof(USHORT);
            lLength -= sizeof(USHORT);
            if ((usToken > 0) && (usToken < DLS_CDL_NOT))
            {
                lOpA = Stack.Pop();
                lOpB = Stack.Pop();
                switch (usToken)
                {
                case DLS_CDL_AND :
                    lTemp = lOpA & lOpB;
                    break;
                case DLS_CDL_OR :
                    lTemp = lOpA | lOpB;
                    break;
                case DLS_CDL_XOR :
                    lTemp = lOpA ^ lOpB;
                    break;
                case DLS_CDL_ADD :
                    lTemp = lOpA + lOpB;
                    break;
                case DLS_CDL_SUBTRACT :
                    lTemp = lOpA - lOpB;
                    break;
                case DLS_CDL_MULTIPLY :
                    lTemp = lOpA * lOpB;
                    break;
                case DLS_CDL_DIVIDE :
                    if (lOpB) lTemp = lOpA / lOpB;
                    else lTemp = 0;
                    break;
                case DLS_CDL_LOGICAL_AND :
                    lTemp = lOpA && lOpB;
                    break;
                case DLS_CDL_LOGICAL_OR :
                    lTemp = lOpA || lOpB;
                    break;
                case DLS_CDL_LT :
                    lTemp = lOpA < lOpB;
                    break;
                case DLS_CDL_LE :
                    lTemp = lOpA <= lOpB;
                    break;
                case DLS_CDL_GT :
                    lTemp = lOpA > lOpB;
                    break;
                case DLS_CDL_GE :
                    lTemp = lOpA >= lOpB;
                    break;
                case DLS_CDL_EQ :
                    lTemp = lOpA == lOpB;
                    break;
                }
                Stack.Push(lTemp);
            }
            else if (usToken == DLS_CDL_NOT)
            {
                Stack.Push(!Stack.Pop());
            }
            else if (usToken == DLS_CDL_CONST)
            {
                memcpy(&lTemp,pData,sizeof(long));
                pData += sizeof(long);
                lLength -= sizeof(long);
                Stack.Push(lTemp);
            }
            else if (usToken == DLS_CDL_QUERY)
            {
                memcpy(&dlsid,pData,sizeof(DLSID));
                pData += sizeof(DLSID);
                lLength -= sizeof(DLSID);
                pPort->QueryDLSFeature(dlsid,&lTemp);
                Stack.Push(lTemp);
            }
            else if (usToken == DLS_CDL_QUERYSUPPORTED)
            {
                memcpy(&dlsid,pData,sizeof(DLSID));
                pData += sizeof(DLSID);
                lLength -= sizeof(DLSID);
                Stack.Push(SUCCEEDED(pPort->QueryDLSFeature(dlsid,&lTemp)));
            }
        }
        return (m_fOkayToDownload = (BOOL) Stack.Pop());
    }
    return (m_fOkayToDownload = TRUE);
}

HRESULT CConditionChunk::Load(CRiffParser *pParser)
{
    HRESULT hr = S_OK;

    if (m_bExpression)
    {
        delete m_bExpression;
        m_bExpression = NULL;
        m_dwLength = 0;
    }
    RIFFIO *pChunk = pParser->GetChunk();
    m_bExpression = new BYTE[pChunk->cksize];
    if (m_bExpression)
    {
        m_dwLength = pChunk->cksize;
        hr = pParser->Read(m_bExpression, pChunk->cksize);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmextchk.h ===
//
// dmextchk.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay

#ifndef DMEXTCHK_H
#define DMEXTCHK_H

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

class CRiffParser;
class CExtensionChunk : public AListItem
{
public:
	CExtensionChunk() : m_pExtensionChunk(NULL), m_dwExtraChunkData(0){}
	~CExtensionChunk() {Cleanup();}

	CExtensionChunk* GetNext(){return(CExtensionChunk*)AListItem::GetNext();}
	
	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, DWORD* pdwOffset, DWORD dwIdxNextExtChk);
	
	DWORD Size(){return CHUNK_ALIGN(sizeof(DMUS_EXTENSIONCHUNK) + m_dwExtraChunkData);}
	DWORD Count()
	{
		// Return the number of Offset Table entries needed during a call to Write
		return 1;
	}

private:
	void Cleanup()
	{	
		delete [] (BYTE *)m_pExtensionChunk;
	} 

private:
	DMUS_EXTENSIONCHUNK* m_pExtensionChunk;
	DWORD m_dwExtraChunkData;
};

class CDirectMusicPortDownload;

class CExtensionChunkList : public AList
{
friend class CCollection;
friend class CInstrObj;
friend class CWaveObj;
friend class CRegion;
friend class CArticulation;

private:
	CExtensionChunkList(){}
	~CExtensionChunkList()
	{
		while(!IsEmpty())
		{
			CExtensionChunk* pExtensionChunk = RemoveHead();
			delete pExtensionChunk;
		}
	}

    CExtensionChunk* GetHead(){return (CExtensionChunk *)AList::GetHead();}
	CExtensionChunk* GetItem(LONG lIndex){return (CExtensionChunk*)AList::GetItem(lIndex);}
    CExtensionChunk* RemoveHead(){return(CExtensionChunk *)AList::RemoveHead();}
	void Remove(CExtensionChunk* pExtensionChunk){AList::Remove((AListItem *)pExtensionChunk);}
	void AddTail(CExtensionChunk* pExtensionChunk){AList::AddTail((AListItem *)pExtensionChunk);}
};


#define STACK_DEPTH 20

class CStack {
public:
    CStack() { m_dwIndex = 0; }
    BOOL        Push(long lData);
    long        Pop();
private:
    DWORD       m_dwIndex;
    long        m_lStack[STACK_DEPTH];
};

class CConditionChunk {
public:
                CConditionChunk()
                {
                    m_bExpression = NULL;
                    m_dwLength = 0;
                    m_fOkayToDownload = TRUE;
                }
                ~CConditionChunk()
                {
                    if (m_bExpression) delete m_bExpression;
                }
    BOOL        Evaluate(CDirectMusicPortDownload *pPort);
    HRESULT     Load(CRiffParser *pParser);
    BOOL        HasChunk() 
                {
                    return m_dwLength;
                }
    BOOL        m_fOkayToDownload; // Result of evaluation.
private:
    BYTE *      m_bExpression;  // Expression in binary form, copied from file.
    DWORD       m_dwLength;     // Length of binary expression chunk.
};


#endif // #ifndef DMEXTCHK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dminsobj.cpp ===
//
// dminsobj.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation. All rights reserved.
//

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "alist.h"
#include "dmart.h"
#include "debug.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmcollec.h"
#include "dmcrchk.h"
#include "dmportdl.h"
#include "dminsobj.h"
#include "dls2.h"

#pragma warning(disable:4530)


//////////////////////////////////////////////////////////////////////
// Class CInstrObj

//////////////////////////////////////////////////////////////////////
// CInstrObj::CInstrObj

CInstrObj::CInstrObj()
{
    m_fCSInitialized = FALSE;
//  InitializeCriticalSection(&m_DMInsCriticalSection);
    m_fCSInitialized = TRUE;

    m_fHasConditionals = TRUE;  // Set to true just in case.
    m_dwPatch = 0;
    m_pCopyright = NULL;
    m_dwCountExtChk = 0;
    m_dwId = 0;
    m_pParent = NULL;
    m_dwNumOffsetTableEntries = 0;
    m_dwSize = 0;
    m_pPort = NULL;
#ifdef DBG
    m_bLoaded = false;
#endif
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::~CInstrObj

CInstrObj::~CInstrObj()
{
    if (m_fCSInitialized)
    {
        Cleanup();
        // DeleteCriticalSection(&m_DMInsCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::Load

HRESULT CInstrObj::Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent)
{
    if(dwId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE); // We want to make it known if we get here
        return DMUS_E_INVALID_DOWNLOADID;
    }

    HRESULT hr = S_OK;

    // Argument validation - Debug
    assert(pParent);

    RIFFIO ckNext;
//  EnterCriticalSection(&m_DMInsCriticalSection);
    pParser->EnterList(&ckNext);
    m_dwId = dwId;
    m_pParent = pParent; // We reference no need to Addref
    BOOL fDLS1;
    while (pParser->NextChunk(&hr))
    {
        fDLS1 = FALSE;
        switch(ckNext.ckid)
        {
            case FOURCC_DLID:
                break;

            case FOURCC_INSH :
            {
                INSTHEADER instHeader;
                hr = pParser->Read(&instHeader,sizeof(INSTHEADER));
                m_dwPatch = instHeader.Locale.ulInstrument;
                m_dwPatch |= (instHeader.Locale.ulBank) << 8;
                m_dwPatch |= (instHeader.Locale.ulBank & 0x80000000);
                break;
            }
            case FOURCC_LIST :
                switch (ckNext.fccType)
                {
                    case FOURCC_LRGN :
                        hr = BuildRegionList(pParser);
                        break;

                    case mmioFOURCC('I','N','F','O') :
                        m_pCopyright = new CCopyright   ;
                        if(m_pCopyright)
                        {
                            hr = m_pCopyright->Load(pParser);
                            if((m_pCopyright->m_byFlags & DMC_FOUNDICOP) == 0)
                            {
                                delete m_pCopyright;
                                m_pCopyright = NULL;
                            }
                        }
                        else
                        {
                            hr =  E_OUTOFMEMORY;
                        }
                        break;

                    case FOURCC_LART :
                        fDLS1 = TRUE;
                    case FOURCC_LAR2 :
                        CArticulation *pArticulation;

                        try
                        {
                            pArticulation = new CArticulation;
                        }
                        catch( ... )
                        {
                            pArticulation = NULL;
                        }

                        if(pArticulation)
                        {
                            pArticulation->m_fDLS1 = fDLS1;
                            hr = pArticulation->Load(pParser);
                            m_ArticulationList.AddHead(pArticulation);
                            // Note: If the load failed, this will get deleted in the destructor of the instrument.
                        }
                        else
                        {
                            hr =  E_OUTOFMEMORY;
                        }

                        break;

                    default:
                        // If we get here we have an unknown chunk
                        CExtensionChunk* pExtensionChunk = new CExtensionChunk;
                        if(pExtensionChunk)
                        {
                            hr = pExtensionChunk->Load(pParser);
                            m_ExtensionChunkList.AddHead(pExtensionChunk);
                            m_dwCountExtChk++;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        break;
                }
                break;

            default:
                // If we get here we have an unknown chunk
                CExtensionChunk* pExtensionChunk = new CExtensionChunk;
                if(pExtensionChunk)
                {
                    hr = pExtensionChunk->Load(pParser);
                    m_ExtensionChunkList.AddHead(pExtensionChunk);
                    m_dwCountExtChk++;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                break;
        }

    }
    pParser->LeaveList();

    if(FAILED(hr))
    {
        Cleanup();
    }

#ifdef DBG
    if(SUCCEEDED(hr))
    {
        m_bLoaded = true;
    }
#endif

    CheckForConditionals();

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::Cleanup

void CInstrObj::Cleanup()
{
//  EnterCriticalSection(&m_DMInsCriticalSection);

    while(!m_RegionList.IsEmpty())
    {
        CRegion* pRegion = m_RegionList.RemoveHead();
        delete pRegion;
    }

    while(!m_ArticulationList.IsEmpty())
    {
        CArticulation* pArticulation = m_ArticulationList.RemoveHead();
        delete pArticulation;
    }

    delete m_pCopyright;
    m_pCopyright = NULL;

    while(!m_ExtensionChunkList.IsEmpty())
    {
        CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
        m_dwCountExtChk--;
        delete pExtChk;
    }

    // If asserts fire we did not cleanup all of our regions and extension chunks
    assert(!m_dwCountExtChk);

    // Weak reference since we live in a CInstrument which has
    // a strong reference to the collection
    m_pParent = NULL;

    while(!m_WaveIDList.IsEmpty())
    {
        CWaveID* pWaveID = m_WaveIDList.RemoveHead();
        delete pWaveID;
    }

#ifdef DBG
    m_bLoaded = false;
#endif

//  LeaveCriticalSection(&m_DMInsCriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::BuildRegionList

HRESULT CInstrObj::BuildRegionList(CRiffParser *pParser)
{
    HRESULT hr = S_OK;

    RIFFIO ckNext;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if (ckNext.ckid == FOURCC_LIST)
        {
            if (ckNext.fccType == FOURCC_RGN)
            {
                hr = ExtractRegion(pParser, TRUE);
            }
            else if (ckNext.fccType == FOURCC_RGN2)
            {
                hr = ExtractRegion(pParser, FALSE);
            }
        }
    }
    pParser->LeaveList();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::ExtractRegion

HRESULT CInstrObj::ExtractRegion(CRiffParser *pParser, BOOL fDLS1)
{
    HRESULT hr = S_OK;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    CRegion* pRegion;

    try
    {
        pRegion = new CRegion;
    }
    catch( ... )
    {
        pRegion = NULL;
    }

    if(pRegion)
    {
        pRegion->m_fDLS1 = fDLS1;
        hr = pRegion->Load(pParser);

        if(SUCCEEDED(hr))
        {
            m_RegionList.AddHead(pRegion);
        }
        else
        {
            delete pRegion;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::BuildWaveIDList

HRESULT CInstrObj::BuildWaveIDList()
{
    // Assumption validation - Debug
#ifdef DBG
    assert(m_bLoaded);
#endif

    HRESULT hr = S_OK;
    CWaveIDList TempList;
    CWaveID* pWaveID;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    CRegion* pRegion = m_RegionList.GetHead();
    for(; pRegion && SUCCEEDED(hr); pRegion = pRegion->GetNext())
    {
        bool bFound = false;
        DWORD dwId = pRegion->GetWaveId();
        pWaveID = TempList.GetHead();
        for(; pWaveID && !bFound; pWaveID = pWaveID->GetNext())
        {
            if(dwId == pWaveID->m_dwId)
            {
                bFound = true;
            }
        }

        if(!bFound)
        {
            pWaveID = new CWaveID(dwId);
            if(pWaveID)
            {
                TempList.AddHead(pWaveID);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if(FAILED(hr))
    {
        while(!m_WaveIDList.IsEmpty())
        {
            pWaveID = TempList.RemoveHead();
            delete pWaveID;
        }
    }

    // Reverse list so it is in same order as region list.

    while (pWaveID = TempList.RemoveHead())
    {
        m_WaveIDList.AddHead(pWaveID);
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::GetWaveCount

HRESULT CInstrObj::GetWaveCount(DWORD* pdwCount)
{
    // Assumption validation - Debug
#ifdef DBG
    assert(m_bLoaded);
#endif
    assert(pdwCount);

    HRESULT hr = S_OK;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    if(m_WaveIDList.IsEmpty())
    {
        hr = BuildWaveIDList();
    }

    *pdwCount = m_WaveIDList.GetCount();

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::GetWaveIDs

HRESULT CInstrObj::GetWaveIDs(DWORD* pdwWaveIds)
{
    // Assumption validation - Debug
    assert(pdwWaveIds);

#ifdef DBG
    assert(m_bLoaded);
#endif

//  EnterCriticalSection(&m_DMInsCriticalSection);

    HRESULT hr = S_OK;

    if(m_WaveIDList.IsEmpty())
    {
        hr = BuildWaveIDList();
    }

    if(FAILED(hr))
    {
//      LeaveCriticalSection(&m_DMInsCriticalSection);
        return hr;
    }

    CWaveID* pWaveID = m_WaveIDList.GetHead();
    for(int i = 0; pWaveID; pWaveID = pWaveID->GetNext(), i++)
    {
        pdwWaveIds[i] = pWaveID->m_dwId;
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

void CInstrObj::SetPort(CDirectMusicPortDownload *pPort,BOOL fAllowDLS2)

{
    if (m_pPort != pPort) // Make sure we have our settings for the current port.
    {
        m_dwSize = 0;     // Force the size to be recomputed (since conditional chunks can cause a change in size.)
        m_pPort = pPort;
        BOOL fSupportsDLS2 = FALSE;
        pPort->QueryDLSFeature(GUID_DMUS_PROP_INSTRUMENT2,(long *) &m_fNewFormat);
        if (m_fNewFormat)
        {
            pPort->QueryDLSFeature(GUID_DMUS_PROP_DLS2,(long *) &fSupportsDLS2);
            fSupportsDLS2 = fSupportsDLS2 && fAllowDLS2;
        }
        CArticulation *pArticulation = m_ArticulationList.GetHead();
        for (;pArticulation;pArticulation = pArticulation->GetNext())
        {
            pArticulation->SetPort(pPort,m_fNewFormat,fSupportsDLS2);
        }
        CRegion* pRegion = m_RegionList.GetHead();
        for(; pRegion; pRegion = pRegion->GetNext())
        {
            pRegion->SetPort(pPort,m_fNewFormat,fSupportsDLS2);
        }
    }
}

void CInstrObj::CheckForConditionals()

{
    m_fHasConditionals = FALSE;
    CArticulation *pArticulation = m_ArticulationList.GetHead();
    for (;pArticulation;pArticulation = pArticulation->GetNext())
    {
        m_fHasConditionals = m_fHasConditionals || pArticulation->CheckForConditionals();
    }
    CRegion* pRegion = m_RegionList.GetHead();
    for(; pRegion; pRegion = pRegion->GetNext())
    {
        m_fHasConditionals = m_fHasConditionals || pRegion->CheckForConditionals();
    }
}


//////////////////////////////////////////////////////////////////////
// CInstrObj::Size

HRESULT CInstrObj::Size(DWORD* pdwSize)
{
    // Assumption validation - Debug
    assert(pdwSize);
#ifdef DBG
    assert(m_bLoaded);
#endif

    // If we have already calculated the size we do not need to do it again
    if(m_dwSize)
    {
        *pdwSize = m_dwSize;
        return S_OK;
    }

    HRESULT hr = S_OK;

    m_dwSize = 0;
    m_dwNumOffsetTableEntries = 0;

    DWORD dwCountExtChk = 0;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    // Calculate the space needed for DMUS_DOWNLOADINFO
    m_dwSize += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

    // Calculate the space needed for DMUS_INSTRUMENT
    m_dwSize += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));
    m_dwNumOffsetTableEntries++;

    // Calculate the space needed for Instrument's extension chunks
    CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
    for(; pExtChk; pExtChk = pExtChk->GetNext())
    {
        m_dwSize += pExtChk->Size();
        m_dwNumOffsetTableEntries += pExtChk->Count();
        dwCountExtChk++;
    }

    // We want to validate the number of extension chunks
    if(m_dwCountExtChk == dwCountExtChk)
    {
        // Calculate the space needed for Instrument's copyright
        if(m_pCopyright)
        {
            m_dwSize += m_pCopyright->Size();
            m_dwNumOffsetTableEntries += m_pCopyright->Count();
        }
        // If instrument does not have one use collection's
        else if(m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
        {
            m_dwSize += m_pParent->m_pCopyright->Size();
            m_dwNumOffsetTableEntries += m_pParent->m_pCopyright->Count();
        }

        // Calculate the space needed for Instrument's Articulation
        CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation)
        {
            while (pArticulation && (pArticulation->Count() == 0))
            {
                pArticulation = pArticulation->GetNext();
            }
            if (pArticulation)
            {
                m_dwSize += pArticulation->Size();
                m_dwNumOffsetTableEntries += pArticulation->Count();
                if (m_fNewFormat)
                {
                    pArticulation = pArticulation->GetNext();
                }
                else break;
            }
        }

        // Calculate the space needed for Instrument's regions
        CRegion* pRegion = m_RegionList.GetHead();
        for(; pRegion; pRegion = pRegion->GetNext())
        {
            m_dwSize += pRegion->Size();
            m_dwNumOffsetTableEntries += pRegion->Count();
        }

        // Calculate the space needed for offset table
        m_dwSize += CHUNK_ALIGN(m_dwNumOffsetTableEntries * sizeof(ULONG));
    }
    else
    {
        hr = E_FAIL;
    }

    // If everything went well, we have the size
    if(SUCCEEDED(hr))
    {
        *pdwSize = m_dwSize;
    }
    else
    {
        m_dwSize = 0;
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::Write

HRESULT CInstrObj::Write(void* pvoid)
{
    // Assumption validation - Debug
    assert(pvoid);
#ifdef DBG
    assert(m_bLoaded);
#endif

    DWORD dwSize = 0;
    Size(&dwSize);

    HRESULT hr = S_OK;

//  EnterCriticalSection(&m_DMInsCriticalSection);

    DWORD dwCurIndex = 0;   // Used to determine what index to store offset in Offset Table
    DWORD dwCurOffset = 0;  // Offset relative to beginning of passed in memory

    // Write DMUS_DOWNLOADINFO
    DMUS_DOWNLOADINFO *pDLInfo = (DMUS_DOWNLOADINFO *) pvoid;
    if (m_fNewFormat)
    {
        pDLInfo->dwDLType = DMUS_DOWNLOADINFO_INSTRUMENT2;
    }
    else
    {
        pDLInfo->dwDLType = DMUS_DOWNLOADINFO_INSTRUMENT;
    }
    pDLInfo->dwDLId = m_dwId;
    pDLInfo->dwNumOffsetTableEntries = m_dwNumOffsetTableEntries;
    pDLInfo->cbSize = dwSize;

    dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

    DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvoid) + dwCurOffset);

    // Increment pass the DMUS_OFFSETTABLE structure; we will fill the other members in later
    dwCurOffset += CHUNK_ALIGN(m_dwNumOffsetTableEntries * sizeof(DWORD));

    // First entry in ulOffsetTable is the address of the first object.
    pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
    dwCurIndex++;


    // Write Instrument MIDI address
    DMUS_INSTRUMENT* pDMInstrument = (DMUS_INSTRUMENT*)(((BYTE *)pvoid) + dwCurOffset);

    pDMInstrument->ulPatch = m_dwPatch;
    pDMInstrument->ulFlags = 0;

    // Set if a GM instrument
    if(m_pParent->m_guidObject == GUID_DefaultGMCollection)
    {
        pDMInstrument->ulFlags |= DMUS_INSTRUMENT_GM_INSTRUMENT;
    }

    // Increment pass the DMUS_INSTRUMENT structure; we will fill the other members in later
    dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));

    // Write regions
    pDMInstrument->ulFirstRegionIdx = 0;
    CRegion* pRegion = m_RegionList.GetHead();
    while (pRegion && (pRegion->Count() == 0))
    {
        pRegion = pRegion->GetNext();
    }
    while (pRegion)
    {
        DWORD dwNextRegionIndex = 0;
        CRegion *pNextRegion = pRegion->GetNext();
        // Make sure the next chunk can also be downloaded.
        while (pNextRegion && (pNextRegion->Count() == 0))
        {
            pNextRegion = pNextRegion->GetNext();
        }
        if (pNextRegion)
        {
            dwNextRegionIndex = dwCurIndex + pRegion->Count();
        }
        if (pDMInstrument->ulFirstRegionIdx == 0)
        {
            pDMInstrument->ulFirstRegionIdx = dwCurIndex;
        }

        pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
        hr = pRegion->Write(((BYTE *)pvoid + dwCurOffset),
                            &dwCurOffset,
                            pDMOffsetTable->ulOffsetTable,
                            &dwCurIndex,
                            dwNextRegionIndex);
        if (FAILED(hr)) break;
        pRegion = pNextRegion;
    }

    if(SUCCEEDED(hr))
    {
        // Write extension chunks
        CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
        if(pExtChk)
        {
            DWORD dwCountExtChk = m_dwCountExtChk;
            DWORD dwIndexNextExtChk;
            pDMInstrument->ulFirstExtCkIdx = dwIndexNextExtChk = dwCurIndex;

            for(; pExtChk && SUCCEEDED(hr) && dwCountExtChk > 0; pExtChk = pExtChk->GetNext())
            {
                if(dwCountExtChk == 1)
                {
                    dwIndexNextExtChk = 0;
                }
                else
                {
                    dwIndexNextExtChk = dwCurIndex + 1;
                }

                pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
                hr = pExtChk->Write(((BYTE *)pvoid + dwCurOffset),
                                    &dwCurOffset,
                                    dwIndexNextExtChk);

                dwCountExtChk--;
            }
        }
        else
        {
            // If no extension chunks set to zero
            pDMInstrument->ulFirstExtCkIdx = 0;
        }
    }

    if(SUCCEEDED(hr))
    {
        // Write copyright information
        if(m_pCopyright)
        {
            pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
            pDMInstrument->ulCopyrightIdx = dwCurIndex;
            hr = m_pCopyright->Write(((BYTE *)pvoid + dwCurOffset),
                                     &dwCurOffset);
            dwCurIndex++;
        }
        // If instrument does not have one use collection's
        else if(m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
        {
            pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
            pDMInstrument->ulCopyrightIdx = dwCurIndex;
            hr = m_pParent->m_pCopyright->Write((BYTE *)pvoid + dwCurOffset, &dwCurOffset);
            dwCurIndex++;
        }
        else
        {
            pDMInstrument->ulCopyrightIdx = 0;
        }
    }

    if(SUCCEEDED(hr))
    {
        pDMInstrument->ulGlobalArtIdx = 0;
        // Write global articulation if we have one
        CArticulation *pArticulation = m_ArticulationList.GetHead();
        // Scan past articulation chunks that will not be downloaded.
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        while (pArticulation)
        {
            DWORD dwNextArtIndex = 0;
            CArticulation *pNextArt = NULL;
            if (m_fNewFormat)
            {
                pNextArt = pArticulation->GetNext();
                // Make sure the next chunk can also be downloaded.
                while (pNextArt && (pNextArt->Count() == 0))
                {
                    pNextArt = pNextArt->GetNext();
                }
                if (pNextArt)
                {
                    dwNextArtIndex = dwCurIndex + pArticulation->Count();
                }
            }
            if (pDMInstrument->ulGlobalArtIdx == 0)
            {
                pDMInstrument->ulGlobalArtIdx = dwCurIndex;
            }
            pDMOffsetTable->ulOffsetTable[dwCurIndex++] = dwCurOffset;
            hr = pArticulation->Write(((BYTE *)pvoid + dwCurOffset),
                                        &dwCurOffset,
                                        pDMOffsetTable->ulOffsetTable,
                                        &dwCurIndex,
                                        dwNextArtIndex);
            pArticulation = pNextArt;
            if (FAILED(hr)) break;
        }

    }

    if(FAILED(hr))
    {
        // If we fail we want to cleanup the contents of passed in buffer
        ZeroMemory(pvoid, dwSize);
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrObj::FixupWaveRefs

HRESULT CInstrObj::FixupWaveRefs()
{

//  EnterCriticalSection(&m_DMInsCriticalSection);

    CRegion* pRegion = m_RegionList.GetHead();

    for(; pRegion; pRegion = pRegion->GetNext())
    {
        if (pRegion->m_WaveLink.ulTableIndex < m_pParent->m_dwWaveOffsetTableSize)
        {
            pRegion->m_WaveLink.ulTableIndex = m_pParent->m_pWaveOffsetTable[pRegion->m_WaveLink.ulTableIndex].dwId;
        }
        else
        {
            Trace(1,"Error: Bad DLS file has out of range wavelink.\n");
            return DMUS_E_BADWAVELINK;
        }
    }

//  LeaveCriticalSection(&m_DMInsCriticalSection);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmksclk.cpp ===
//
// DMKSClk.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrapper for using a KS clock as the DirectMusic master clock
//
// 
//
#include <objbase.h>
#include <winerror.h>
#include "dmusicp.h"
#include "debug.h"
#include "resource.h"

// Since we only allocate one of these clocks in the entire system,
// this stuff is global.
//

// We have to be able to get the process id of someone with a handle to
// the clock. Since the original creator might go away before other users,
// we store the process id of everyone who uses the clock. This implies
// a max limit on concurrent processes using it.
//
#define MAX_CLOCK_SHARERS   64              // Max processes who can access clock   
                                            // at once.
typedef struct KSCLOCKSHARE
{
    LONG                cRef;               // Count of processes using handle

    struct 
    {
        HANDLE          hKsClock;           // This user's handle and
        DWORD           dwProcessId;        // process id
    } aUsers[MAX_CLOCK_SHARERS];

} *PKSCLOCKSHARE;

class CKsClock : public IReferenceClock, public IMasterClockPrivate
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // IMasterClockPrivate
    STDMETHODIMP GetParam(REFGUID rguidType, LPVOID pBuffer, DWORD cbSize);

    // Class
    //
    CKsClock();
    ~CKsClock();
    HRESULT Init();

private:
    long m_cRef;

    HRESULT CreateKsClockShared();
    void    DeleteKsClockShared();
    HRESULT CreateKsClockHandle();
    HRESULT DuplicateKsClockHandle();

private:
    static const char m_cszKsClockMemory[];       // Name of shared memory object
    static const char m_cszKsClockMutex[];        // Name of mutex protecting shared memory

    static LONG m_lSharedMemoryInitialized;       // Has this process initialized shared memory?
    static HANDLE m_hFileMapping;                 // File mapping handle for shared memory
    static PKSCLOCKSHARE m_pShared;               // Pointer to shared memory
    static HANDLE m_hKsClockMutex;                // Mutex for shared memory access
    static HANDLE m_hClock;                       // Clock handle in this process
};

static HRESULT CreateKsClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);

const char       CKsClock::m_cszKsClockMemory[] = "DirectMusicKsClock";
const char       CKsClock::m_cszKsClockMutex[]  = "DirectMusicKsClockMutex";

LONG             CKsClock::m_lSharedMemoryInitialized = 0;
HANDLE           CKsClock::m_hFileMapping = NULL;         
PKSCLOCKSHARE    CKsClock::m_pShared = NULL;        
HANDLE           CKsClock::m_hKsClockMutex = NULL;
HANDLE           CKsClock::m_hClock;                

#ifdef DEAD_CODE

// AddKsClocks
//
// Add Ks clock to the list of clocks.
//
HRESULT AddKsClocks(CMasterClock *pMasterClock)
{
    HANDLE hClock;

    // Make sure we can create a default Ks clock
    //
    if (!OpenDefaultDevice(KSCATEGORY_CLOCK, &hClock))
    {
        TraceI(0, "Could not create Ks clock\n");
        return S_FALSE;
    }

    CloseHandle(hClock);

    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce);
    ce.cc.guidClock = GUID_SysClock;         
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.dwFlags = DMUS_CLOCKF_GLOBAL;
    ce.pfnGetInstance = CreateKsClock;

    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_SYSTEMCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}
#endif

// CreateKsClock
//
// Return an IReferenceClock based on the one Ks clock in the system
//
static HRESULT CreateKsClock(IReferenceClock **ppClock)
{
    HRESULT hr;

    TraceI(0, "Creating KS clock\n");

    CKsClock *pClock = new CKsClock();

    hr = pClock->Init();
    if (FAILED(hr))
    {
        delete pClock;
        return hr;
    }

    hr = pClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
    pClock->Release();

    return hr;
}

// CKsClock::CKsClock()
//
// 
CKsClock::CKsClock() : 
    m_cRef(1)
{
}

// CKsClock::~CKsClock()
//
// 
CKsClock::~CKsClock()
{
    if (InterlockedDecrement(&m_lSharedMemoryInitialized) == 0)
    {
        DeleteKsClockShared();        
    }
}

// CKsClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CKsClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if (iid == IID_IMasterClockPrivate)
    {
        *ppv = static_cast<IMasterClockPrivate*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

// CKsClock::AddRef
// 
STDMETHODIMP_(ULONG) CKsClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CKsClock::Release
//
STDMETHODIMP_(ULONG) CKsClock::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CKsClock::Init
//
HRESULT CKsClock::Init()
{
    HRESULT hr;

    if (InterlockedIncrement(&m_lSharedMemoryInitialized) == 1)
    {
        hr = CreateKsClockShared();
        if (FAILED(hr))
        {
            return hr;
        }    
    }

    return S_OK;
}

// CKsClock::CreateKsClockShared
//
// Initialize the shared memory object in this process.
// Make sure a handle to the Ks clock exists in this process.
//
HRESULT CKsClock::CreateKsClockShared()
{
    HRESULT hr;
    DWORD dwErr;

    // Create and take the mutex up front. This is neccesary to guarantee that if 
    // we are the first process in the system to create this object, then we do 
    // initialization before anyone else can access the shared memory object.
    //
    m_hKsClockMutex = CreateMutex(NULL,             // Default security descriptor
                                  FALSE,            // Own mutex if we are first instance
                                  m_cszKsClockMutex);
    if (m_hKsClockMutex == NULL)
    {
        TraceI(0, "CreateMutex failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    WaitForSingleObject(m_hKsClockMutex, INFINITE);

    // Create the file mapping and view of the shared memory, noticing if we are the first 
    // object to create it.
    //
    m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,    // Use paging file
                                       NULL,                    // Default security descriptor
                                       PAGE_READWRITE,  
                                       0,                       // High DWORD of size
                                       sizeof(KSCLOCKSHARE),
                                       m_cszKsClockMemory);
    dwErr = GetLastError();
    if (m_hFileMapping == NULL)
    {
        ReleaseMutex(m_hKsClockMutex);
        
        return HRESULT_FROM_WIN32(dwErr);
    }    

    BOOL fFirst = (dwErr != ERROR_ALREADY_EXISTS);

    m_pShared = (PKSCLOCKSHARE)MapViewOfFile(m_hFileMapping,
                                             FILE_MAP_WRITE,
                                             0, 0,                // Start mapping at the beginning
                                             0);                  // Map entire file
    if (m_pShared == NULL)
    {
        TraceI(0, "MapViewOfFile failed! [%d]\n", GetLastError());

        ReleaseMutex(m_hKsClockMutex);
        return E_OUTOFMEMORY;
    }

    // Initialize the refernce count if we are the first process, and increment
    // it in any case. (Note we're still in the mutex, so we don't need 
    // InterlockedIncrement.
    //
    if (fFirst)
    {
        m_pShared->cRef = 0;
        ZeroMemory(m_pShared->aUsers, sizeof(m_pShared->aUsers));
    }
    ++m_pShared->cRef;

    // If the clock handle doesn't exist yet, create it; else duplicate it. 
    //
    if (m_pShared->cRef == 1)
    {
        hr = CreateKsClockHandle();
    }
    else
    {
        hr = DuplicateKsClockHandle();
    }

    // Release the mutex and return success or failure.
    //
    ReleaseMutex(m_hKsClockMutex);

    return hr;
}

// CKsClock::DeleteKsClockShared
//
// The last instance of CKsClock in this process is being deleted. 
//
void CKsClock::DeleteKsClockShared()
{
    // If the mutex was never created, then none of the other objects could have
    // been created.
    //
    if (m_hKsClockMutex)
    {
        WaitForSingleObject(m_hKsClockMutex, INFINITE);

        if (m_pShared)
        {
            for (int i = 0; i < MAX_CLOCK_SHARERS; i++)
            {
                if (m_pShared->aUsers[i].dwProcessId == GetCurrentProcessId())
                {
                    m_pShared->aUsers[i].dwProcessId = 0;
                    m_pShared->aUsers[i].hKsClock = NULL;

                    break;
                }
            }
        }

        if (m_hClock)
        {
            CloseHandle(m_hClock);
            m_hClock = NULL;
        }        

        if (m_pShared)
        {
            UnmapViewOfFile(m_pShared);
            m_pShared = NULL;
        }

        if (m_hFileMapping)
        {
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
                
        ReleaseMutex(m_hKsClockMutex);
        CloseHandle(m_hKsClockMutex);                            
    }
}

// CKsClock::CreateKsClockHandle
//
// Create the first and only Ks clock handle in the system
//
HRESULT CKsClock::CreateKsClockHandle()
{
    // Attempt to open the clock
    //
    if (!OpenDefaultDevice(KSCATEGORY_CLOCK, &m_hClock))
    {
        m_hClock = NULL;

        TraceI(0, "Could not create Ks clock\n");
        return E_FAIL;
    }

    KSPROPERTY      ksp;
    KSSTATE			state;

    ksp.Set    = KSPROPSETID_Clock;
    ksp.Id     = KSPROPERTY_CLOCK_STATE;
    ksp.Flags  = KSPROPERTY_TYPE_SET;

	state      = KSSTATE_RUN;

    if (!Property(m_hClock,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(state), 
                  &state,
                  NULL))
    {
        CloseHandle(m_hClock);
        m_hClock = NULL;
        TraceI(0, "Could not set clock into run state\n");
        return E_FAIL;
    }

    // Successful clock open. Since we're creating, we know we're the first
    // instance of the clock and therefore the users array is empty.
    //
    m_pShared->aUsers[0].hKsClock = m_hClock;
    m_pShared->aUsers[0].dwProcessId = GetCurrentProcessId();    

    return S_OK;
}

// CKsClock::DuplicateKsClockHandle
//
// There is already a Ks clock in the system. Duplicate the handle in this process
// context.
//
HRESULT CKsClock::DuplicateKsClockHandle()
{
    // Find another user of the clock; also, find a slot in the users array for
    // this process
    //
    int iEmptySlot = -1;
    int iOtherProcess = -1;
    HANDLE hClock = NULL;

    for (int i = 0; 
         (i < MAX_CLOCK_SHARERS) && (iEmptySlot == -1 || !hClock); 
         i++)
    {
        if (m_pShared->aUsers[i].dwProcessId == 0 && iEmptySlot == -1)
        {
            iEmptySlot = i;
            continue;
        }

        if (hClock)
        {
            continue;
        }            

        HANDLE hOtherProcess = OpenProcess(PROCESS_DUP_HANDLE, 
                                           FALSE,
                                           m_pShared->aUsers[i].dwProcessId);
        if (hOtherProcess == NULL)
        {
            TraceI(0, "OpenProcess: %d\n", GetLastError());
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hKsClock = NULL;
            continue;
        }

        BOOL fSuccess = DuplicateHandle(hOtherProcess,
                                        m_pShared->aUsers[i].hKsClock,
                                        GetCurrentProcess(),
                                        &hClock,
                                        GENERIC_READ|GENERIC_WRITE,
                                        FALSE,
                                        0);
        if (!fSuccess)
        {
            TraceI(0, "DuplicateHandle: %d\n", GetLastError());
        }

        CloseHandle(hOtherProcess);

        if (!fSuccess)
        {
            // Other process exists, but could not duplicate handle
            //
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hKsClock = NULL;

            hClock = NULL;
        }
    }

    assert(iEmptySlot != -1);
    assert(hClock);

    m_hClock = hClock;

    m_pShared->aUsers[iEmptySlot].dwProcessId = GetCurrentProcessId();
    m_pShared->aUsers[iEmptySlot].hKsClock = hClock;

    return S_OK;
}

STDMETHODIMP 
CKsClock::GetTime(REFERENCE_TIME *pTime)
{
    KSPROPERTY ksp;

    ksp.Set   = KSPROPSETID_Clock;
    ksp.Id    = KSPROPERTY_CLOCK_TIME;
    ksp.Flags = KSPROPERTY_TYPE_GET;

    if (!Property(m_hClock,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(*pTime),
                  pTime,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    return S_OK;
}

STDMETHODIMP 
CKsClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CKsClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CKsClock::Unadvise(DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}

//
// CKsClock::GetParam (IMasterClockPrivate)
//
// This method is used internally by the port to get the user mode handle of the Ks clock
// we're using. The handle is then downloaded to kernel mode where it is referenced as a
// file object and used by the filters as the timebase as well.
//
STDMETHODIMP 
CKsClock::GetParam(REFGUID rguidType, LPVOID pBuffer, DWORD cbSize)
{
    if (rguidType == GUID_KsClockHandle)
    {
        if (cbSize != sizeof(HANDLE))
        {
            return E_INVALIDARG;
        }

        *(LPHANDLE)pBuffer = m_hClock;
        return S_OK;
    }

    return DMUS_E_TYPE_UNSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dminstru.cpp ===
//
// dminstru.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation. All rights reserved.
//
// @doc EXTERNAL
//

#include "debug.h"
#include "dmusicp.h"
#include "dmusicc.h"

#include "alist.h"
#include "debug.h"
#include "dmcollec.h"
#include "dmportdl.h"
#include "dminstru.h"
#include "dminsobj.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Class CInstrument

//////////////////////////////////////////////////////////////////////
// CInstrument::CInstrument

CInstrument::CInstrument() :
m_dwOriginalPatch(0),
m_dwPatch(0),
m_pParentCollection(NULL),
m_pInstrObj(NULL),
m_bInited(false),
m_dwId(-1),
m_cRef(1)
{
    InitializeCriticalSection(&m_DMICriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
}

//////////////////////////////////////////////////////////////////////
// CInstrument::~CInstrument

CInstrument::~CInstrument()
{
    Cleanup();
    DeleteCriticalSection(&m_DMICriticalSection);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CInstrument::QueryInterface

STDMETHODIMP CInstrument::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicInstrument::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if(iid == IID_IUnknown || iid == IID_IDirectMusicInstrument)
    {
        *ppv = static_cast<IDirectMusicInstrument*>(this);
    }
    else if(iid == IID_IDirectMusicInstrumentPrivate)
    {
        *ppv = static_cast<IDirectMusicInstrumentPrivate*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::AddRef

STDMETHODIMP_(ULONG) CInstrument::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CInstrument::Release

STDMETHODIMP_(ULONG) CInstrument::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        if(m_pParentCollection)
        {
            m_pParentCollection->RemoveInstrument(this);
        }

        if(!m_cRef) // remotely possible that collection bumped before we were removed
        {
            delete this;
            return 0;
        }
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicInstrument

//////////////////////////////////////////////////////////////////////
// CInstrument::GetPatch

/*

@method:(EXTERNAL) HRESULT | IDirectMusicInstrument | GetPatch |
Gets the MIDI patch number from the instrument. The MIDI
patch number is an address composed of the MSB and LSB
bank selects, and program change number. An optional flag
bit indicates that the instrument is a drum, rather than
melodic, instrument.

@comm The patch number returned in <p dwPatch> describes the
full patch address, including the MIDI parameters for MSB and LSB
bank select. MSB is shifted left 16 bits and LSB is shifted
8 bits. Program change is stored in the bottom 8 bits.

In addition, the high bit (0x80000000)
must be set if the instrument is
specifically a drum kit, intended to be played on MIDI
channel 10.
Note that this a special tag for DLS Level 1,
since DLS Level 1 always plays drums on MIDI channel 10.
However, future versions of DLS will probably do away with
the differentiation of drums verses melodic isntruments.
All channels will support drums and the format differences
between drums and melodic instruments will go away.

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | Invalid pointer in <p pdwPatch>.


@xref <i IDirectMusicCollection>,
<i IDirectMusicInstrument>,
<om IDirectMusicInstrument::SetPatch>,
<om IDirectMusicCollection::GetInstrument>
*/

STDMETHODIMP CInstrument::GetPatch(
    DWORD* pdwPatch)    // @parm Returned patch number.
{
    if(!m_bInited)
    {
        return DMUS_E_NOT_INIT;
    }

    // Argument validation
    V_INAME(IDirectMusicInstrument::GetPatch);
    V_PTR_WRITE(pdwPatch, DWORD);

    *pdwPatch = m_dwPatch;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::SetPatch
/*
@method:(EXTERNAL) HRESULT | IDirectMusicInstrument | SetPatch |
Sets the MIDI patch number for the instrument. Although
each instrument in a DLS collection has a predefined
patch number, the patch number
can be reassigned once the instrument
has been pulled from the <i IDirectMusicCollection>
via a call to <om IDirectMusicCollection::GetInstrument>.

@rdesc Returns one of the following

@flag S_OK | Success
@flag DMUS_E_INVALIDPATCH | Invalid MIDI address in <p dwPatch>.

@xref <i IDirectMusicCollection>,
<i IDirectMusicInstrument>,
<om IDirectMusicInstrument::GetPatch>,
<om IDirectMusicCollection::GetInstrument>

@ex The following example gets an instrument from a collection,
remaps its
MSB bank select to a different bank, then downloads the
instrument. |

    HRESULT myRemappedDownload(
        IDirectMusicCollection *pCollection,
        IDirectMusicPort *pPort,
        IDirectMusicDownloadedInstrument **ppDLInstrument,
        BYTE bMSB,       // Requested MIDI MSB for patch bank select.
        DWORD dwPatch)   // Requested patch.

    {
        HRESULT hr;
        IDirectMusicInstrument* pInstrument;
        hr = pCollection->GetInstrument(dwPatch, &pInstrument);
        if (SUCCEEDED(hr))
        {
            dwPatch &= 0xFF00FFFF;  // Clear MSB.
            dwPatch |= bMSB << 16;  // Stick in new MSB value.
            pInstrument->SetPatch(dwPatch);
            hr = pPort->DownloadInstrument(pInstrument, ppDLInstrument, NULL, 0);
            pInstrument->Release();
        }
        return hr;
    }
*/

STDMETHODIMP CInstrument::SetPatch(
    DWORD dwPatch)  // @parm New patch number to assign to instrument.
{
    // Argument validation - Runtime
    if(!m_bInited)
    {
        return DMUS_E_NOT_INIT;
    }

    // We use 0x7F to strip out the Drum Kit flag
    BYTE bMSB = (BYTE) ((dwPatch >> 16) & 0x7F);
    BYTE bLSB = (BYTE) (dwPatch >> 8);
    BYTE bInstrument = (BYTE) dwPatch;

    if(bMSB < 0 || bMSB > 127 ||
       bLSB < 0 || bLSB > 127 ||
       bInstrument < 0 || bInstrument > 127)
    {
        return DMUS_E_INVALIDPATCH;
    }

    m_dwPatch = dwPatch;
    CDirectMusicPort::GetDLIdP(&m_dwId, 1);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CInstrument::Cleanup

void CInstrument::Cleanup()
{
    EnterCriticalSection(&m_DMICriticalSection);

    while(!m_WaveObjList.IsEmpty())
    {
        CWaveObj* pWaveObj = m_WaveObjList.RemoveHead();
        if(pWaveObj)
        {
            delete pWaveObj;
        }
    }

    if(m_pInstrObj)
    {
        delete m_pInstrObj;
    }

    if(m_pParentCollection)
    {
        m_pParentCollection->Release();
        m_pParentCollection = NULL;
    }

    m_bInited = false;

    LeaveCriticalSection(&m_DMICriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CInstrument::Init

HRESULT CInstrument::Init(DWORD dwPatch, CCollection* pParentCollection)
{
    // Argument validation - Debug
    assert(pParentCollection);

    m_dwOriginalPatch = m_dwPatch = dwPatch;
    m_pParentCollection = pParentCollection;
    m_pParentCollection->AddRef();

    HRESULT hr = pParentCollection->ExtractInstrument(dwPatch, &m_pInstrObj);

    if(FAILED(hr) || hr == S_FALSE)
    {
        Cleanup();
        return DMUS_E_INVALIDPATCH;
    }

    m_bInited = true;

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWaveCount

HRESULT CInstrument::GetWaveCount(DWORD* pdwCount)
{
    // Assumption validation - Debug
    assert(m_pInstrObj);
    assert(pdwCount);

    return(m_pInstrObj->GetWaveCount(pdwCount));
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWaveIDs

HRESULT CInstrument::GetWaveDLIDs(DWORD* pdwIds)
{
    assert(m_pInstrObj);
    assert(pdwIds);

    return(m_pInstrObj->GetWaveIDs(pdwIds));
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWaveSize

HRESULT CInstrument::GetWaveSize(DWORD dwId, DWORD* pdwSize, DWORD* pdwSampleSize)
{
    assert(pdwSize);

    if(dwId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE); // We want to make it known if we get here
        return DMUS_E_INVALID_DOWNLOADID;
    }

    EnterCriticalSection(&m_DMICriticalSection);

    HRESULT hr = E_FAIL;
    bool bFound = false;

    CWaveObj* pWaveObj = m_WaveObjList.GetHead();

    for(; pWaveObj; pWaveObj = pWaveObj->GetNext())
    {
        if(dwId == pWaveObj->m_dwId)
        {
            bFound = true;
            hr = S_OK;
            break;
        }
    }

    if(!bFound)
    {
        hr = m_pParentCollection->ExtractWave(dwId, &pWaveObj);
        if(SUCCEEDED(hr))
        {
            m_WaveObjList.AddHead(pWaveObj);
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = pWaveObj->Size(pdwSize,pdwSampleSize);
    }

    LeaveCriticalSection(&m_DMICriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetWave

HRESULT CInstrument::GetWave(DWORD dwWId, IDirectMusicDownload* pIDMDownload)
{
    assert(pIDMDownload);

    if(dwWId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE); // We want to make it known if we get here
        return DMUS_E_INVALID_DOWNLOADID;
    }

    EnterCriticalSection(&m_DMICriticalSection);

    HRESULT hr = E_FAIL;
    bool bFound = false;

    CWaveObj* pWaveObj = m_WaveObjList.GetHead();

    for(; pWaveObj; pWaveObj = pWaveObj->GetNext())
    {
        if(dwWId == pWaveObj->m_dwId)
        {
            bFound = true;
            hr = S_OK;
            break;
        }
    }

    if(!bFound)
    {
        hr = m_pParentCollection->ExtractWave(dwWId, &pWaveObj);
        if(SUCCEEDED(hr))
        {
            m_WaveObjList.AddHead(pWaveObj);
        }
    }

    void* pvoid = NULL;
    DWORD dwBufSize = 0;
    DWORD dwWaveSize = 0;
    DWORD dwSampleSize = 0;

    if(SUCCEEDED(hr))
    {
        hr = pIDMDownload->GetBuffer(&pvoid, &dwBufSize);

        if(SUCCEEDED(hr))
        {
            hr = pWaveObj->Size(&dwWaveSize,&dwSampleSize);

            if(FAILED(hr) || dwWaveSize > dwBufSize)
            {
                hr =  DMUS_E_INSUFFICIENTBUFFER;
            }
            else
            {
                hr = pWaveObj->Write((BYTE *)pvoid);
            }
        }
    }

    LeaveCriticalSection(&m_DMICriticalSection);

    return hr;
}

void CInstrument::SetPort(CDirectMusicPortDownload *pPort, BOOL fAllowDLS2)
{
    assert(m_pInstrObj);
    m_pInstrObj->SetPort(pPort,fAllowDLS2);
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetInstrumentSize

HRESULT CInstrument::GetInstrumentSize(DWORD* pdwSize)
{
    assert(m_pInstrObj);
    assert(pdwSize);

    return(m_pInstrObj->Size(pdwSize));
}

//////////////////////////////////////////////////////////////////////
// CInstrument::GetInstrument

HRESULT CInstrument::GetInstrument(IDirectMusicDownload* pIDMDownload)
{
    assert(m_pInstrObj);
    assert(pIDMDownload);

    void* pvoid = NULL;
    DWORD dwBufSize = 0;
    DWORD dwInstSize = 0;

    HRESULT hr = pIDMDownload->GetBuffer(&pvoid, &dwBufSize);

    if(SUCCEEDED(hr))
    {
        hr = m_pInstrObj->Size(&dwInstSize);

        if(FAILED(hr) || dwInstSize > dwBufSize)
        {
            hr = DMUS_E_INSUFFICIENTBUFFER;
        }
        else
        {
            hr = m_pInstrObj->Write((BYTE *)pvoid);

            // We need to adjust dwDLId if the m_dwPatch was changed with a call to SetPatch
            // as well as adjust the ulPatch to reflect the patch set with SetPatch
            if(SUCCEEDED(hr))
            {
                DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)
                    (((BYTE *)pvoid) + (DWORD) CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)));
                DMUS_INSTRUMENT* pDMInstrument = (DMUS_INSTRUMENT *)
                    (((BYTE *)pvoid) + pDMOffsetTable->ulOffsetTable[0]);

                if(m_dwPatch != pDMInstrument->ulPatch)
                {
                    assert(m_dwId != -1);
                    ((DMUS_DOWNLOADINFO*)pvoid)->dwDLId = m_dwId;
                    pDMInstrument->ulPatch = m_dwPatch;
                }
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmport.cpp ===
//
// dmport.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: CDirectMusicPort : Implements the WDM version of IDirectMusicPort.
//
// @doc EXTERNAL
//
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include <mmsystem.h>
#include <regstr.h>

#include "debug.h"
#include "dmusicp.h"
#include "dminstru.h"
#include "dmdlinst.h"
#include "validate.h"

#pragma warning(disable:4200)

static const GUID guidZero;

#ifdef DBG
extern void _TraceIGuid(int iLevel, GUID *pGUID);
#define TraceIGuid _TraceIGuid
#else
#define TraceIGuid(x,y)
#endif

#define POSTED_STREAM_READ_IRPS     (60)
#define BYTES_PER_READ_IRP          (QWORD_ALIGN(2 * QWORD_ALIGN(sizeof(DMEVENT) + sizeof(DWORD)) - 1))

typedef struct
{
    KSSTREAM_HEADER     kssh;
    OVERLAPPED          overlapped;
    char                buffer[BYTES_PER_READ_IRP];
} READ_IRP;

// @globalv:(INTERNAL) Registry location of WDM driver port definitions
//
// @comm This might need to change
//
const char cszWDMPortsRoot[] = REGSTR_PATH_PRIVATEPROPERTIES "\\Midi\\WDMPort";

HRESULT EnumerateSADDevice(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    LPSTR               pInstIdPrefDev,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               *plEnumeratedPorts);

HRESULT EnumerateSADDevicePin(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               idxPin,
    BOOL                fOnPrefDev,
    LPWSTR              wszDescription,
    LPSTR               psrtInstanceId,
    ULONG               *plEnumeratedPorts,
    LPWSTR              szDIName);

static DWORD WINAPI FreeWDMHandle(LPVOID lpThreadParameter);
static DWORD WINAPI CaptureThread(LPVOID lpThreadParameter);

//////////////////////////////////////////////////////////////////////
// EnumerateWDMDevices
//
HRESULT EnumerateWDMDevices(CDirectMusic *pDirectMusic)
{
    HANDLE          hSysAudio;
    HKEY            hkPortsRoot;
    ULONG           cTotalDevices;
    ULONG           idxDevice;
    LPSTR           pInstIdPrefDev = NULL;
    ULONG           lEnumeratedPorts;

    // Determine the instance ID of the preferred wave audio device
    //  pInstIDPrefDev will allocate a string buffer
    if (!InstanceIdOfPreferredAudioDevice(&pInstIdPrefDev))
    {
        TraceI(0, "Could not determine a preferred wave audio device\n");

        if (pInstIdPrefDev!= NULL) delete[] pInstIdPrefDev;
        pInstIdPrefDev = NULL;

    }
    else
    {
        TraceI(1, "Preferred device [%s]\n", pInstIdPrefDev);
    }

    // Open or create the reg key to store WDM driver linkages
    //
    if (RegCreateKey(HKEY_LOCAL_MACHINE,
                     cszWDMPortsRoot,
                     &hkPortsRoot))
    {
        hkPortsRoot = NULL;
    }

    // Description of standard streaming interface driver must support to be
    // enumerated
    //

    // If we can't open SysAudio, we can't enum any WDM devices
    //
    if (!OpenDefaultDevice(KSCATEGORY_SYSAUDIO, &hSysAudio))
    {
        return S_FALSE;
    }

    // Figure out how many devices there are and walk the list of them.
    //
    if (!GetSysAudioDeviceCount(hSysAudio, &cTotalDevices))
    {
        return S_FALSE;
    }

    // Enumerate and get info on each SAD device
    //

    lEnumeratedPorts = 0;
    for (idxDevice = 0; idxDevice < cTotalDevices; ++idxDevice)
    {
        EnumerateSADDevice(pDirectMusic,
                           hkPortsRoot,
                           pInstIdPrefDev,
                           hSysAudio,
                           idxDevice,
                           &lEnumeratedPorts);
    }

    TraceI(1, "EnumerateWDMDevices: Added %lu ports\n", lEnumeratedPorts);

    if (hkPortsRoot)
    {
        RegCloseKey(hkPortsRoot);
    }

    CloseHandle(hSysAudio);

    //Deallocate pInstIdPrefDev
    if (pInstIdPrefDev != NULL) delete[] pInstIdPrefDev;

    return lEnumeratedPorts ? S_OK : S_FALSE;
}

HRESULT EnumerateSADDevice(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    LPSTR               pInstIdPrefDev,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               *plEnumeratedPorts)
{
    LPSTR               pstrInstanceId = NULL;

    ULONG               cPins;
    ULONG               idxPin;
    WCHAR               wszDIName[256];
    CHAR                szDIName[256];
    WCHAR               wszDescription[DMUS_MAX_DESCRIPTION];
    BOOL                fOnPrefDev;

    // Set SysAudio to talk to us about this device number
    //
    if (!SetSysAudioDevice(hSysAudio, idxDevice))
    {
        TraceI(0, "EnumerateSADDevice: Failed to set device to %d\n", idxDevice);
        return S_FALSE;
    }

    if (!GetDeviceFriendlyName(hSysAudio, idxDevice, wszDescription, ELES(wszDescription)))
    {
        TraceI(0, "AddWDMDevices: Failed to get friendly name!\n");
        return S_FALSE;
    }

    char sz[256];
    wcstombs(sz, wszDescription, sizeof(sz));
    TraceI(1, "Looking at [%s]\n", sz);

    fOnPrefDev = FALSE;
    if (!GetDeviceInterfaceName(hSysAudio, idxDevice, wszDIName, ELES(wszDIName)))
    {
        TraceI(0, "No interface name for device.\n");
        return S_FALSE;
    }

    wcstombs(szDIName, wszDIName, sizeof(szDIName));
    if (!DINameToInstanceId(szDIName, &pstrInstanceId))
    {
        TraceI(0, "Could not determine instance ID\n");
        return S_FALSE;
    }
    TraceI(1, "DIName [%s]\nInstId [%s]\n",
        szDIName,
        pstrInstanceId);

    if (pInstIdPrefDev)
    {
        if (!_stricmp(pstrInstanceId, pInstIdPrefDev))
        {
            TraceI(1, "This filter is on the preferred audio device\n");
            fOnPrefDev = TRUE;
        }
    }

    HRESULT hr = S_FALSE;
    // Get the number of pin types on this device
    //
    if (GetNumPinTypes(hSysAudio, &cPins))
    {
        for (idxPin = 0; idxPin < cPins; idxPin++)
        {
            hr = EnumerateSADDevicePin(pDirectMusic,
                                       hkPortsRoot,
                                       hSysAudio,
                                       idxDevice,
                                       idxPin,
                                       fOnPrefDev,
                                       wszDescription,
                                       pstrInstanceId,
                                       plEnumeratedPorts,
                                       wszDIName);
        }
    }
    else
    {
        TraceI(0, "AddWDMDevices: Failed to get number of pin types for device %d\n", idxDevice);
    }

    delete[] pstrInstanceId;

    return hr;
}

HRESULT EnumerateSADDevicePin(
    CDirectMusic        *pDirectMusic,
    HKEY                hkPortsRoot,
    HANDLE              hSysAudio,
    ULONG               idxDevice,
    ULONG               idxPin,
    BOOL                fOnPrefDev,
    LPWSTR              wszDescription,
    LPSTR               pstrInstanceId,
    ULONG               *plEnumeratedPorts,
    LPWSTR              wszDIName)
{
    ULONG               idxNode;
    KSPIN_DATAFLOW      dataflow;
    SYNTHCAPS           caps;
    DMUS_PORTCAPS       dmpc;

    // First make sure this pin speaks standard KS streaming. If not, we can't use it.
    //
    if (!PinSupportsInterface(hSysAudio, idxPin, KSINTERFACESETID_Standard, KSINTERFACE_STANDARD_STREAMING))
    {
        TraceI(1, "EnumerateSADDevicePin: Pin %d does not support standard streaming\n", idxPin);
        return S_FALSE;
    }

    // Supports standard streaming, now make sure it supports synth format.
    //
    if (!PinSupportsDataRange(hSysAudio, idxPin, KSDATAFORMAT_TYPE_MUSIC, KSDATAFORMAT_SUBTYPE_DIRECTMUSIC))
    {
        TraceI(1, "EnumerateSADDevicePin: Pin %d does not support DirectMusic data range\n", idxPin);
        return S_FALSE;
    }

    // Get the data flow direction
    //
    if (!PinGetDataFlow(hSysAudio, idxPin, &dataflow))
    {
        TraceI(0, "EnumerateSADDevicePin: PinGetDataFlow failed!\n");
        return S_FALSE;
    }

    // Find the synth caps node
    //
    idxNode = FindGuidNode(hSysAudio, idxPin, KSNODETYPE_DMSYNTH_CAPS);
    if (idxNode == -1)
    {
        if ((idxNode = FindGuidNode(hSysAudio, idxPin, KSCATEGORY_SYNTHESIZER)) == -1)
        {
            TraceI(1, "EnumerateSADDevicePin: Pin %d has no reachable synthcaps or synth node.\n", idxPin);
            return S_FALSE;
        }
    }

    // Get the caps
    //
    ZeroMemory(&caps, sizeof(caps));
    if (!GetFilterCaps(hSysAudio, idxNode, &caps))
    {
        TraceI(0, "EnumerateSADDevicePin: Pin %d with synth node failed caps!\n", idxPin);
        return S_FALSE;
    }

    TraceI(2, "Pin %d works for %s\n",
             idxPin,
             (dataflow == KSPIN_DATAFLOW_OUT) ? "capture" : "render");

    ZeroMemory(&dmpc, sizeof(dmpc));
    dmpc.dwSize = sizeof(dmpc);

    dmpc.dwClass                = dataflow == KSPIN_DATAFLOW_OUT ? DMUS_PC_INPUTCLASS : DMUS_PC_OUTPUTCLASS;
    dmpc.dwType                 = DMUS_PORT_KERNEL_MODE;

    wcscpy(dmpc.wszDescription, wszDescription);

    dmpc.guidPort               = caps.Guid;
    dmpc.dwFlags                = caps.Flags;
    dmpc.dwMemorySize           = caps.MemorySize;
    dmpc.dwMaxChannelGroups     = caps.MaxChannelGroups;
    dmpc.dwMaxVoices            = caps.MaxVoices;
    dmpc.dwMaxAudioChannels     = caps.MaxAudioChannels;
    dmpc.dwEffectFlags          = caps.EffectFlags;


    PORTENTRY *pPort = NULL;

    // We may have to fixup the guids

    pPort = pDirectMusic->GetPortByGUID(dmpc.guidPort);

    while(pPort != NULL)
    {
        //The port is in the list

        //Is this port the same as another one?
        if (wcscmp(wszDIName,pPort->wszDIName)==0 && idxPin == pPort->idxPin)
        {
            // The GUID and DeviceID and the PIN# Match
            // This is great, lets get outta the loop
            pPort = NULL;
        }
        else
        {
            //The GUID is in use by another device
            //We need to increment the guid and try again
            dmpc.guidPort.Data1++;

            //Get the new port.
            pPort = pDirectMusic->GetPortByGUID(dmpc.guidPort);
        }

    }

    pDirectMusic->AddDevice(dmpc,
                  ptWDMDevice,
                  idxDevice,
                  idxPin,
                  idxNode,
                  (caps.Flags & SYNTH_PC_SOFTWARESYNTH) ? FALSE : fOnPrefDev,
                  hkPortsRoot,
                  wszDIName,
                  pstrInstanceId);
    ++*plEnumeratedPorts;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CreateCDirectMusicPort
//
HRESULT
CreateCDirectMusicPort(
                       PORTENTRY *pPE,
                       CDirectMusic *pDM,
                       LPDMUS_PORTPARAMS pPortParams,
                       IDirectMusicPort **ppPort)
{
    HRESULT hr = S_OK;
    CDirectMusicPort *pPort = NULL;

    try
    {
        pPort = new CDirectMusicPort(pPE, pDM);
    } catch(...)
    {
    }

    if (pPort == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = pPort->Init(pPortParams);
    }

    if (SUCCEEDED(hr))
    {
        *ppPort = static_cast<IDirectMusicPort*>(pPort);
    }
    else
    {
        delete pPort;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::CDirectMusicPort

CDirectMusicPort::CDirectMusicPort(PORTENTRY *pPE,
                                   CDirectMusic *pDM) :
m_cRef(1),
m_pDM(pDM),
m_hUnloadThread(NULL),
m_phUnloadEventList(NULL),
m_hCaptureWake(NULL),
m_phNewUnloadEventList(NULL),
m_hCopiedEventList(NULL),
m_dwNumEvents(0),
m_dwNumEventsAllocated(256),
m_fHasActivated(FALSE),
m_pDirectSound(NULL),
m_lActivated(0),
m_pMasterClock(NULL),
m_fShutdownThread(FALSE),
m_pThruMap(NULL),
m_pThruBuffer(NULL),
m_dwChannelGroups(0),
m_fDirectSoundSet(FALSE),
m_hCaptureThread(NULL),
m_fSyncToMaster(TRUE),
m_lTimeOffset(0),
m_pPCClock(NULL)
{
    InterlockedIncrement(&g_cComponent);

    m_fPortCSInitialized = FALSE;
    m_fQueueCSInitialized = FALSE;

    InitializeCriticalSection(&m_DMPortCriticalSection);
    m_fPortCSInitialized = TRUE;

    InitializeCriticalSection(&m_csEventQueues);
    m_fQueueCSInitialized = TRUE;

    InitializeCriticalSection(&m_OverlappedCriticalSection);

    // Note: on pre-Blackcomb OS's, InitializeCriticalSection can raise an exception;
    // if it ever pops in stress, we should add an exception handler and retry loop.

    OverlappedStructs *pOverlappedStructs = new OverlappedStructs;
    if( pOverlappedStructs )
    {
        if( NULL != m_lstOverlappedStructs.AddNodeToList( pOverlappedStructs ) )
        {
            ZeroMemory( pOverlappedStructs->aOverlappedIO, sizeof( OVERLAPPED ) * OVERLAPPED_ARRAY_SIZE );
            ZeroMemory( pOverlappedStructs->afOverlappedInUse, sizeof( BOOL ) * OVERLAPPED_ARRAY_SIZE );
            ZeroMemory( pOverlappedStructs->apOverlappedBuffer, sizeof( BYTE * ) * OVERLAPPED_ARRAY_SIZE );
        }
        else
        {
            delete pOverlappedStructs;

            // Don't need to fail - we'll just try to create a new one when PlayBuffer() is called
        }
    }

    m_hPin = INVALID_HANDLE_VALUE;
    m_hSysAudio = INVALID_HANDLE_VALUE;

    m_fIsOutput = (pPE->pc.dwClass == DMUS_PC_OUTPUTCLASS) ? TRUE : FALSE;

    // XXX Can these change? Think about FrankYe's PnP stuff
    //

    dmpc = pPE->pc;
    m_pNotify = NULL;
    m_pClock = NULL;

    m_guidPort = pPE->pc.guidPort;
    m_fAudioDest = pPE->fAudioDest;

    m_fCanDownload = (pPE->pc.dwFlags & DMUS_PC_DLS) ||
                     (pPE->pc.dwFlags & DMUS_PC_DLS2);

    if (!m_fAudioDest)
    {
        m_idxDev = pPE->idxDevice;
        m_idxPin = pPE->idxPin;
        m_idxSynthNode = pPE->idxNode;
    }
    else
    {
        PORTDEST *pChosenDest = NULL;

        CNode<PORTDEST*> *pNode;

        for (pNode = pPE->lstDestinations.GetListHead(); pNode; pNode=pNode->pNext)
        {
            // Choose either first or default
            //
            if (pChosenDest == NULL || pNode->data->fOnPrefDev)
            {
                pChosenDest = pNode->data;
            }
        }

        //So what happens if fOnPrefDev never returns true?
        assert(pChosenDest);

        m_idxDev = pChosenDest->idxDevice;
        m_idxPin = pChosenDest->idxPin;
        m_idxSynthNode = pChosenDest->idxNode;
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::~CDirectMusicPort

CDirectMusicPort::~CDirectMusicPort()
{
    if (m_fPortCSInitialized && m_fQueueCSInitialized)
    {
        Close();

#ifdef DBG
        EnterCriticalSection(&m_DMPortCriticalSection);

        // This list should be empty when we get here
        CDownloadBuffer* pDownload = m_UnloadedList.GetHead();
        if(pDownload)
        {
            assert(false);
        }

        LeaveCriticalSection(&m_DMPortCriticalSection);
#endif
    }

    if (m_fPortCSInitialized)  DeleteCriticalSection(&m_DMPortCriticalSection);
    if (m_fQueueCSInitialized) DeleteCriticalSection(&m_csEventQueues);

    DeleteCriticalSection(&m_OverlappedCriticalSection);

    // Cleanup the array of overlapped structures
    CNode<OverlappedStructs *> *pOverlappedNode, *pOverlappedNext;
    for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNext)
    {
        pOverlappedNext = pOverlappedNode->pNext;

        delete pOverlappedNode->data;
        m_lstOverlappedStructs.RemoveNodeFromList(pOverlappedNode);
    }

    InterlockedDecrement(&g_cComponent);
}

struct KS_PORTPARAMS
{
    KSNODEPROPERTY      ksnp;
    SYNTH_PORTPARAMS    spp;
};

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Init
//
HRESULT
CDirectMusicPort::Init(LPDMUS_PORTPARAMS pPortParams)
{
    HRESULT hr = E_FAIL;
    BOOL fValidParamChanged = FALSE;

    // Allocate thru map for 16 channels, since we only have one channel group
    // Initialize to no thruing (destination port is NULL).
    //
    m_pThruMap = new DMUS_THRU_CHANNEL[MIDI_CHANNELS];
    if (m_pThruMap == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DMUS_BUFFERDESC dmbd;
    ZeroMemory(&dmbd, sizeof(dmbd));
    dmbd.dwSize = sizeof(dmbd);
    dmbd.cbBuffer = 4096;               // XXX Where should we get this???

    hr = m_pDM->CreateMusicBuffer(&dmbd, &m_pThruBuffer, NULL);
    if (FAILED(hr))
    {
        TraceI(0, "Failed to create thruing buffer\n");
        return hr;
    }

    ZeroMemory(m_pThruMap, MIDI_CHANNELS * sizeof(DMUS_THRU_CHANNEL));

    // Get a handle to SysAudio
    //
    if (!OpenDefaultDevice(KSCATEGORY_SYSAUDIO, &m_hSysAudio))
    {
        TraceI(0, "CDirectMusicPort::Init failed to open SysAudio\n");
        return E_FAIL;
    }

    if (!SetSysAudioDevice(m_hSysAudio, m_idxDev))
    {
        TraceI(0, "Failed to set device on SysAudio\n");
        goto Cleanup;
    }

    if (!CreateVirtualSource(m_hSysAudio, &m_ulVirtualSourceIndex))
    {
        TraceI(0, "Failed to create virtual source\n");
        goto Cleanup;
    }

    hr = CreatePin(m_hSysAudio, m_idxPin, &m_hPin);
    if (FAILED(hr))
    {
        TraceI(0, "Failed to create pin: %x\n", hr);
        goto Cleanup;
    }

    if (!AttachVirtualSource(m_hPin, m_ulVirtualSourceIndex))
    {
        TraceI(0, "Failed to attach virtual source\n");
        goto Cleanup;
    }

    // Set port params
    //
    if (pPortParams)
    {
        KS_PORTPARAMS kspp;

        ZeroMemory(&kspp, sizeof(kspp));
        kspp.ksnp.Property.Set    = KSPROPSETID_Synth;
        kspp.ksnp.Property.Id     = KSPROPERTY_SYNTH_PORTPARAMETERS;
        kspp.ksnp.Property.Flags  = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
        kspp.ksnp.NodeId          = m_idxSynthNode;
        kspp.ksnp.Reserved        = 0;
        kspp.spp.ValidParams      = pPortParams->dwValidParams;
        kspp.spp.Voices           = pPortParams->dwVoices;
        kspp.spp.ChannelGroups    = pPortParams->dwChannelGroups;
        kspp.spp.AudioChannels    = pPortParams->dwAudioChannels;
        kspp.spp.SampleRate       = pPortParams->dwSampleRate;
        kspp.spp.EffectsFlags     = pPortParams->dwEffectFlags;
        kspp.spp.Share            = pPortParams->fShare;

        assert
        (
            DMUS_PORTPARAMS_VOICES == SYNTH_PORTPARAMS_VOICES &&
            DMUS_PORTPARAMS_CHANNELGROUPS == SYNTH_PORTPARAMS_CHANNELGROUPS &&
            DMUS_PORTPARAMS_AUDIOCHANNELS == SYNTH_PORTPARAMS_AUDIOCHANNELS &&
            DMUS_PORTPARAMS_SAMPLERATE == SYNTH_PORTPARAMS_SAMPLERATE &&
            DMUS_PORTPARAMS_EFFECTS == SYNTH_PORTPARAMS_EFFECTS &&
            DMUS_PORTPARAMS_SHARE == SYNTH_PORTPARAMS_SHARE
        );

        SYNTH_PORTPARAMS spp;
        if (!Property(m_hPin,
                      sizeof(kspp),
                      (PKSIDENTIFIER)&kspp,
                      sizeof(spp),
                      &spp,
                      NULL))
        {
            hr = WIN32ERRORtoHRESULT(GetLastError());
            goto Cleanup;
        }

        if ((pPortParams->dwValidParams != spp.ValidParams) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_VOICES) &&
             (pPortParams->dwVoices != spp.Voices)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS) &&
             (pPortParams->dwChannelGroups != spp.ChannelGroups)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS) &&
             (pPortParams->dwAudioChannels != spp.AudioChannels)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE) &&
             (pPortParams->dwSampleRate != spp.SampleRate)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_EFFECTS) &&
             (pPortParams->dwEffectFlags != spp.EffectsFlags)) ||
            ((pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE) &&
             (pPortParams->fShare != (BOOL) spp.Share)))
        {
            fValidParamChanged = TRUE;

            pPortParams->dwValidParams  = spp.ValidParams;
            pPortParams->dwVoices       = spp.Voices;
            pPortParams->dwChannelGroups= spp.ChannelGroups;
            pPortParams->dwAudioChannels= spp.AudioChannels;
            pPortParams->dwSampleRate   = spp.SampleRate;
            pPortParams->dwEffectFlags  = spp.EffectsFlags;
            pPortParams->fShare         = (BOOL) spp.Share;
        }

        TraceI(0, "dmport: create: fValidParamChanged %d\n",
            (int)fValidParamChanged);

        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            m_dwChannelGroups = pPortParams->dwChannelGroups;
        }
        else if (FAILED(GetNumChannelGroups(&m_dwChannelGroups)))
        {
            m_dwChannelGroups = 1;
        }

        if (m_fIsOutput)
        {
            InitChannelPriorities(1, m_dwChannelGroups);
        }
    }

    // create latency clock
    //
    m_pClock = new CPortLatencyClock(m_hPin, m_idxSynthNode, this);
    if (!m_pClock)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Get our notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    m_pNotify->Release();

    if (m_fIsOutput)
    {
        // Render only
        //
        // set volume boost default (zero)
        //

        KSNODEPROPERTY ksnp;
        LONG lVolume;

        ksnp.Property.Set   = KSPROPSETID_Synth;
        ksnp.Property.Id    = KSPROPERTY_SYNTH_VOLUMEBOOST;
        ksnp.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
        ksnp.NodeId         = m_idxSynthNode;
        ksnp.Reserved       = 0;

        lVolume = 0;

        if (!Property(m_hPin,
                      sizeof(ksnp),
                      (PKSIDENTIFIER)&ksnp,
                      sizeof(lVolume),
                      &lVolume,
                      NULL))
        {
            if (!(dmpc.dwFlags & DMUS_PC_EXTERNAL))
            {
                hr = WIN32ERRORtoHRESULT(GetLastError());
                TraceI(0, "Could not set default volume boost %08X\n", hr);
                goto Cleanup;
            }
        }

        // Initialize download. This creates all the events needed for asynchronously
        // dealing with unload.
        //
        hr = InitializeDownloadObjects();
    }
    else
    {
        // Capture only
        //
        // Set up the thread to post multiple IRP's to the pin and queue the data
        // when it gets to user mode.
        //
        hr = InitializeCapture();
    }

    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = m_pDM->GetMasterClock(NULL, &m_pMasterClock);
    if (FAILED(hr))
    {
        TraceI(0, "Failed to get master clock\n");
        goto Cleanup;
    }

#if 0
    // We need to get the handle from the master clock and pass it down to the
    // pin so the timebase will be the same.
    //
    IMasterClockPrivate *pPrivate;

    hr = m_pMasterClock->QueryInterface(IID_IMasterClockPrivate, (void**)&pPrivate);
    if (FAILED(hr))
    {
        TraceI(0, "Master clock is not a Ks clock -- cannot instantiate WDM port!\n");
        goto Cleanup;
    }

    HANDLE hClock;
    hr = pPrivate->GetParam(GUID_KsClockHandle, &hClock, sizeof(hClock));
    pPrivate->Release();

    if (FAILED(hr))
    {
        TraceI(0, "Could not get handle of Ks clock\n");
        goto Cleanup;
    }
#endif  // WIN95

    PinSetState(KSSTATE_STOP);

#if 0

    KSPROPERTY ksp;

    ksp.Set =   KSPROPSETID_Stream;
    ksp.Id =    KSPROPERTY_STREAM_MASTERCLOCK;
    ksp.Flags = KSPROPERTY_TYPE_SET;

    if (!Property(m_hPin,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(HANDLE),
                  &hClock,
                  NULL))
    {
        hr = WIN32ERRORtoHRESULT(GetLastError());
        TraceI(0, "Could not set the master clock handle on the kernel pin %08X\n", hr);
        goto Cleanup;
    }
#endif

    PinSetState(KSSTATE_PAUSE);

    TraceI(2, "CDirectMusicPort::Init() Pin %p\n", m_hPin);

    // If we have WDM ports, then the default master clock will be the
    // portcls clock.
    //
    hr = m_pDM->GetMasterClockWrapperI()->CreateDefaultMasterClock(&m_pPCClock);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;

    hr = m_pMasterClock->GetTime(&rtMasterClock);
    if (SUCCEEDED(hr))
    {
        hr = m_pPCClock->GetTime(&rtSlaveClock);
    }

    if (FAILED(hr))
    {
        goto Cleanup;
    }

    m_lTimeOffset = rtMasterClock - rtSlaveClock;


    if (fValidParamChanged)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    if (FAILED(hr))
    {
        Close();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
//
// InitializeDownloadObjects
//
// Create the events to handle asynchronous download notification and
// start the download thread.
//
HRESULT
CDirectMusicPort::InitializeDownloadObjects()
{
    m_phUnloadEventList = new HANDLE[m_dwNumEventsAllocated];
    if (m_phUnloadEventList == NULL)
    {
        TraceI(0, "Failed to alloc memory for unload event list\n");
        return E_OUTOFMEMORY;
    }

    // Used to Kill the unload thread
    m_phUnloadEventList[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_phUnloadEventList[0] == NULL)
    {
        TraceI(0, "Failed to create kill event\n");
        return E_FAIL;
    }
    m_dwNumEvents++;

    // Used to Wake unload thread
    m_phUnloadEventList[1] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_phUnloadEventList[1] == NULL)
    {
        TraceI(0, "Failed to create wake event\n");
        return E_FAIL;
    }
    m_dwNumEvents++;


    // Used for asynchronously sending down events

    m_phUnloadEventList[2] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_phUnloadEventList[2] == NULL)
    {
        TraceI(0, "Failed to create overlapped struct event\n");
        return E_FAIL;
    }
    m_dwNumEvents++;

    // Now, use the same event for all the OVERLAPPED structures
    EnterCriticalSection( &m_OverlappedCriticalSection );
    CNode<OverlappedStructs *> *pOverlappedNode;
    for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNode->pNext)
    {
        OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
        if( pOverlappedStructs )
        {
            for( int iEvent = 0; iEvent < OVERLAPPED_ARRAY_SIZE; iEvent++ )
            {
                pOverlappedStructs->aOverlappedIO[iEvent].hEvent = m_phUnloadEventList[2];
            }
        }
    }
    LeaveCriticalSection( &m_OverlappedCriticalSection );


    m_hCopiedEventList = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(m_hCopiedEventList == NULL)
    {
        TraceI(0, "Failed to create copy event\n");
        return E_FAIL;
    }

    DWORD dwThreadId;

    m_hUnloadThread = CreateThread(NULL, 0, ::FreeWDMHandle, this, 0, &dwThreadId);
    if(m_hUnloadThread == NULL)
    {
        TraceI(0, "Failed to create unload thread\n");
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
// InitializeCapture
//
HRESULT
CDirectMusicPort::InitializeCapture()
{
    DWORD dwError;
    DWORD dwThreadId;

    m_hCaptureWake = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hCaptureWake == NULL)
    {
        dwError = GetLastError();
        TraceI(0, "Failed to create capture thread wakeup event %d\n", dwError);
        return WIN32ERRORtoHRESULT(dwError);
    }

    m_hCaptureThread = CreateThread(NULL, 0, ::CaptureThread, this, 0, &dwThreadId);
    if (m_hCaptureThread == NULL)
    {
        dwError = GetLastError();
        TraceI(0, "Failed to create capture thread %d\n", dwError);
        return WIN32ERRORtoHRESULT(dwError);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::QueryInterface

STDMETHODIMP
CDirectMusicPort::QueryInterface(const IID &iid,
                                 void **ppv)
{
    V_INAME(IDirectMusicPort::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPortP)
    {
        *ppv = static_cast<IDirectMusicPortP*>(this);
    }
    else if (iid == IID_IDirectMusicPortDownload)
    {
        *ppv = static_cast<IDirectMusicPortDownload*>(this);
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicThru)
    {
        *ppv = static_cast<IDirectMusicThru*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }


    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::AddRef

STDMETHODIMP_(ULONG)
CDirectMusicPort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Release

STDMETHODIMP_(ULONG)
CDirectMusicPort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {

        if (m_pNotify)
        {
            m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        }

        delete this;
        return 0;
    }

    return m_cRef;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | Compact | Compacts downloaded DLS data to create a large chunk of contiguous sample memory.
//
// @comm
// The IDirectMusicPort::Compact method is used to instruct the hardware
// or driver to compact DLS/wavetable memory, thus making the largest
// possible contiguous chunk of memory available for new instruments to
// be downloaded.  This method is only valid for an output port that
// supports wavetable synthesis.  This call is passed directly to the
// driver, which handles compacting of the memory whether it is on the
// card or in host memory.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusicPort::Compact()
{
    KSNODEPROPERTY      ksnp;

    // Compact takes no parameters
    //
    ksnp.Property.Set     = KSPROPSETID_Synth_Dls;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_DLS_COMPACT;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  0,
                  NULL,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetCaps | Gets the capabilities of the port.
//
// @comm
// The IDirectMusicPort::GetCaps method retrieves the port's capabilities.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p pPortCaps> pointer is invalid.
// @flag E_INVALIDARG | If the <p PortCaps> struct pointed to is not the correct size.
//
STDMETHODIMP
CDirectMusicPort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)          // @parm Pointer to the <t DMUS_PORTCAPS> structure to receive the capabilities of the port.
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &dmpc, sizeof(DMUS_PORTCAPS));
    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | DeviceIoControl | Performs a DeviceIoControl on the underlying
// file handle implementing the port.
//
// @comm
// This method wraps a call to the system DeviceIoControl API on the file handle implementing
// the port. This method is only supported on ports implemented by a WDM filter graph. In the
// case of a WDM filter graph, the file handle used will be the topmost pin in the graph.
//
// DirectMusic reserves the right to refuse to perform defined KS operations on a pin which
// might collide with operations it is performing on the filter graph. User defined operations,
// however, will never be blocked.
//
// For more information on the semantics of the DeviceIoControl call, see the Win32 API documentation.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If any of the passed pointers were invalid.
// @flag E_NOTIMPL | If the port is not a WDM port.
// @flag E_INVALIDARG | If the specified IO control code is not allowed (such as IOCTL_KS_PROPERTY).
//
// Other return codes as defined by the system DeviceIoControl API call or the underlying driver responding
// to the call.
//
STDMETHODIMP
CDirectMusicPort::DeviceIoControl(
    DWORD dwIoControlCode,              // @parm Control code of operation to perform
    LPVOID lpInBuffer,                  // @parm Pointer to buffer to supply input data
    DWORD nInBufferSize,                // @parm Size of input buffer
    LPVOID lpOutBuffer,                 // @parm Pointer to buffer to receive output buffer
    DWORD nOutBufferSize,               // @parm Size of output buffer
    LPDWORD lpBytesReturned,            // @parm Pointer to variable to receive output byte count
    LPOVERLAPPED lpOverlapped)          // @parm Pointer to overlapped structure for asynrchronous operation
{
    V_INAME(IDirectMusicPort::DeviceIoControl);
    V_BUFPTR_READ_OPT(lpInBuffer, nInBufferSize);
    V_BUFPTR_WRITE_OPT(lpOutBuffer, nOutBufferSize);
    V_PTR_WRITE(lpBytesReturned, DWORD);
    V_PTR_WRITE(lpOverlapped, OVERLAPPED);

    BOOL fResult;

    if (dwIoControlCode == IOCTL_KS_PROPERTY)
    {
        TraceI(0, "DeviceIoControl: Use IKsControl to set or get property items.");
        return E_INVALIDARG;
    }

    fResult = ::DeviceIoControl(m_hPin,
                                dwIoControlCode,
                                lpInBuffer,
                                nInBufferSize,
                                lpOutBuffer,
                                nOutBufferSize,
                                lpBytesReturned,
                                lpOverlapped);

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | SetNumChannelGroups | Sets the number of channel groups requested for this port.
//
// @comm
// The IDirectMusicPort::SetNumChannelGroups method changes the number
// of channel groups that the application needs on the port.  If the
// number of requested channel groups could not be allocated,
// E_INVALIDARG is returned.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_INVALIDARG | If the requested number of channel groups could not be allocated
//
STDMETHODIMP
CDirectMusicPort::SetNumChannelGroups(
    DWORD dwChannelGroups)      // @parm The number of channel groups on this port that the application wants to allocate.
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_CHANNELGROUPS;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  sizeof(DWORD),
                  &dwChannelGroups,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    DWORD dwActualChannelGroups = 0;
    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_CHANNELGROUPS;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(ksnp),
                   (PKSIDENTIFIER)&ksnp,
                   sizeof(DWORD),
                   &dwActualChannelGroups,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    if( dwActualChannelGroups != dwChannelGroups )
    {
        return E_INVALIDARG;
    }

    if (m_fIsOutput && (dwChannelGroups > m_dwChannelGroups))
    {
        InitChannelPriorities(m_dwChannelGroups + 1, dwChannelGroups);
    }

    m_dwChannelGroups = dwChannelGroups;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetNumChannelGroups | Gets the number of channel groups used  for this port.
//
// @comm
// The IDirectMusicPort::GetNumChannelGroups method get the number
// of channel groups that the application is using on the port.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the passed pointer is invalid
//
STDMETHODIMP
CDirectMusicPort::GetNumChannelGroups(
    LPDWORD pdwChannelGroups)      // @parm Contains the number of channel groups currently in use by this port on return
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_CHANNELGROUPS;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(ksnp),
                   (PKSIDENTIFIER)&ksnp,
                   sizeof(DWORD),
                   pdwChannelGroups,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | PlayBuffer | Queues a DirectMusicBuffer object for playback.
//
// @comm
// The IDirectMusicPort::PlayBuffer method is used to queue a
// buffer for playback by the port.  The buffer is only in use by the
// system for the duration of this method and is free to be reused after
// this method returns.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p pIBuffer> pointer is invalid.
// @flag E_NOTIMPL | If the port is not an output port.
//
STDMETHODIMP
CDirectMusicPort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)               // @parm A pointer to an <i IDirectMusicBuffer> interface representing the
                                                // object which should be added to the port's playback queue.
{
    DWORD cbData;
    LPBYTE pbData;
    REFERENCE_TIME rtStart;
    HRESULT hr;

    V_INAME(IDirectMusicPort::PlayBuffer);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    if (!m_lActivated)
    {
        return DMUS_E_SYNTHINACTIVE;
    }

    hr = pIBuffer->GetUsedBytes(&cbData);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetRawBufferPtr(&pbData);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetStartTime(&rtStart);
    if (FAILED(hr))
    {
        return hr;
    }

    SyncClocks();
    MasterToSlave(&rtStart);

    KSSTREAM_HEADER kssh;
    ULONG cbRet;

    kssh.Size               = sizeof(KSSTREAM_HEADER);
    kssh.TypeSpecificFlags  = 0;

    kssh.PresentationTime.Time        = rtStart;
    kssh.PresentationTime.Numerator   = 1;
    kssh.PresentationTime.Denominator = 1;

    kssh.Duration     = 0;
    kssh.FrameExtent  = cbData;
    kssh.DataUsed     = cbData;
    // Assigned to a temporary buffer later on
    //kssh.Data         = pbData;
    kssh.Data         = 0;
    kssh.OptionsFlags = 0;

    // Try and find an available OVERLAPPED structure
    int iOverlapped;
    OverlappedStructs *pOverlappedStructsToUse = NULL;
    EnterCriticalSection( &m_OverlappedCriticalSection );

    // Iterate through the list of overlapped structure arrays
    CNode<OverlappedStructs *> *pOverlappedNode;
    for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode && !pOverlappedStructsToUse; pOverlappedNode = pOverlappedNode->pNext)
    {
        // get a pointer to each array
        OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
        if( pOverlappedStructs )
        {
            // Iterate through the array
            for( iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
            {
                if( !pOverlappedStructs->afOverlappedInUse[iOverlapped] )
                {
                    // Found a free one - exit the loop
                    pOverlappedStructsToUse = pOverlappedStructs;
                    break;
                }
            }
        }
    }

    // Didn't find a free one
    if( !pOverlappedStructsToUse )
    {
        TraceI(0, "PlayBuffer: Failed to find a free OVERLAPPED structure - trying to free one\n");

        // Iterate through the list of overlapped structure arrays
        for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode && !pOverlappedStructsToUse; pOverlappedNode = pOverlappedNode->pNext)
        {
            // get a pointer to each array
            OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
            if( pOverlappedStructs )
            {
                // Iterate through the array
                for( iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
                {
                    if( HasOverlappedIoCompleted( &(pOverlappedStructs->aOverlappedIO[iOverlapped]) ) )
                    {
                        // Found a completed one - exit the loop and re-use it
                        pOverlappedStructs->aOverlappedIO[iOverlapped].Internal = 0;
                        pOverlappedStructs->aOverlappedIO[iOverlapped].InternalHigh = 0;
                        pOverlappedStructs->aOverlappedIO[iOverlapped].Offset = 0;
                        pOverlappedStructs->aOverlappedIO[iOverlapped].OffsetHigh = 0;
                        delete pOverlappedStructs->apOverlappedBuffer[iOverlapped];
                        pOverlappedStructs->apOverlappedBuffer[iOverlapped] = NULL;
                        pOverlappedStructs->afOverlappedInUse[iOverlapped] = FALSE;

                        pOverlappedStructsToUse = pOverlappedStructs;
                        break;
                    }
                }
            }
        }

        // Still didn't find a free one
        if( !pOverlappedStructsToUse )
        {
            TraceI(0, "PlayBuffer: All OVERLAPPED structures in use - creating new ones\n");

            // Create a new structure with another 200 OVERLAPPED structures
            OverlappedStructs *pOverlappedStructs = new OverlappedStructs;
            if( pOverlappedStructs )
            {
                // If we could allocate the memory, add it to the list
                if( NULL != m_lstOverlappedStructs.AddNodeToList( pOverlappedStructs ) )
                {
                    // Initialize the array of structures
                    ZeroMemory( pOverlappedStructs->aOverlappedIO, sizeof( OVERLAPPED ) * OVERLAPPED_ARRAY_SIZE );
                    ZeroMemory( pOverlappedStructs->afOverlappedInUse, sizeof( BOOL ) * OVERLAPPED_ARRAY_SIZE );
                    ZeroMemory( pOverlappedStructs->apOverlappedBuffer, sizeof( BYTE * ) * OVERLAPPED_ARRAY_SIZE );
                    for( int iEvent = 0; iEvent < OVERLAPPED_ARRAY_SIZE; iEvent++ )
                    {
                        pOverlappedStructs->aOverlappedIO[iEvent].hEvent = m_phUnloadEventList[2];
                    }

                    // Now, flag to use the first item in the new structure
                    pOverlappedStructsToUse = pOverlappedStructs;
                    iOverlapped = 0;
                }
                else
                {
                    // Out of memory - fail
                    delete pOverlappedStructs;
                    LeaveCriticalSection( &m_OverlappedCriticalSection );
                    return E_OUTOFMEMORY;
                }
            }
            else
            {
                // Out of memory - fail
                LeaveCriticalSection( &m_OverlappedCriticalSection );
                return E_OUTOFMEMORY;
            }
        }
    }

    // Try and allocate a buffer to store the memory in while the driver is using it
    pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped] = new BYTE[cbData];
    if( NULL == pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped] )
    {
        // Out of memory - fail
        LeaveCriticalSection( &m_OverlappedCriticalSection );
        return E_OUTOFMEMORY;
    }
    CopyMemory(pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped], pbData, cbData);

    // Set the KS Stream to use the just-allocated buffer
    kssh.Data         = pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped];

    // Mark the OVERLAPPED structure as in use
    pOverlappedStructsToUse->afOverlappedInUse[iOverlapped] = TRUE;

    BOOL fResult;
    fResult = ::DeviceIoControl(m_hPin,
                                IOCTL_KS_WRITE_STREAM,
                                &kssh,
                                sizeof(KSSTREAM_HEADER),
                                &kssh,
                                sizeof(KSSTREAM_HEADER),
                                &cbRet,
                                &(pOverlappedStructsToUse->aOverlappedIO[iOverlapped]));

    // If we failed
    if( !fResult )
    {
        // Get the error code
        DWORD dwErrorCode = GetLastError();

        // If we're just pending
        if( ERROR_IO_PENDING == dwErrorCode )
        {
            // That's expected - return S_OK
            hr = S_OK;
        }
        else
        {
            // Other error - convert to a HRESULT
            hr = WIN32ERRORtoHRESULT( dwErrorCode );

            // Mark the OVERLAPPED structure as free
            pOverlappedStructsToUse->afOverlappedInUse[iOverlapped] = FALSE;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].Internal = 0;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].InternalHigh = 0;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].Offset = 0;
            pOverlappedStructsToUse->aOverlappedIO[iOverlapped].OffsetHigh = 0;

            // Free the memory we allocated
            delete pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped];
            pOverlappedStructsToUse->apOverlappedBuffer[iOverlapped] = NULL;
        }
    }
    else
    {
        // We succeeded - return S_OK
        hr = S_OK;
    }

    LeaveCriticalSection( &m_OverlappedCriticalSection );

    return hr;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | SetReadNotificationHandle | Sets an event to pulse when music data has been captured.
//
// @comm
// The IDirectMusicPort::SetReadNotificationHandle method sets the event
// notification status. This method specifies an event that is to be set
// when MIDI messages are available to be read with the
// <om IDirectMusicPort::Read> method. The event will be pulsed whenever new
// data is available.  To turn off event notification, call
// SetEventNotification with a NULL value for the hEvent parameter.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusicPort::SetReadNotificationHandle(
    HANDLE hEvent)              // @parm  An event handle returned from the Window's CreateEvent call.  It identifies the
                                // event that is to be notified when data is available to be read.
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    m_hAppEvent = hEvent;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | Read | Reads captured music data into a DirectMusicBuffer.
//
// @comm
//
// The IDirectMusicPort::Read method fills the buffer object with
// incoming MIDI data.  Read should be called with new buffer objects
// until no more data is available to be read.  When there is no more
// data to read, the method returns S_FALSE.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p pIBuffer> pointer is invalid.
// @flag E_NOTIMPL | If the port is not an input port.


STDMETHODIMP
CDirectMusicPort::Read(
    IDirectMusicBuffer *pIBuffer)                          // @parm A buffer that will be filled with incoming MIDI data
{
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }


    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    LPBYTE pbBuffer;
    HRESULT hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD cbBuffer;
    hr = pIBuffer->GetMaxBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    TraceI(1, "Read: buffer size %u\n", cbBuffer);

    LPBYTE pbData = pbBuffer;

    // Since events are now buffered, we read them out of the local queue
    //
    //
    EnterCriticalSection(&m_csEventQueues);

    REFERENCE_TIME rtStart= 0;

    if (m_ReadEvents.pFront)
    {
        rtStart = m_ReadEvents.pFront->e.rtDelta;
    }
    else
    {
        TraceI(2, "Read: No events queued\n");
    }

    while (m_ReadEvents.pFront)
    {
        QUEUED_EVENT *pQueuedEvent = m_ReadEvents.pFront;

        DWORD cbQueuedEvent = DMUS_EVENT_SIZE(pQueuedEvent->e.cbEvent);
        TraceI(2, "Read: cbEvent %u  cbQueuedEvent %u\n",
            pQueuedEvent->e.cbEvent,
            cbQueuedEvent);

        if (cbQueuedEvent > cbBuffer)
        {
            TraceI(2, "Read: No more room for events in buffer.\n");
            break;
        }

        TraceI(2, "Read: Got an event!\n");

        pQueuedEvent->e.rtDelta -= rtStart;

        CopyMemory(pbData,
                   &pQueuedEvent->e,
                   sizeof(DMEVENT) - sizeof(DWORD) + pQueuedEvent->e.cbEvent);

        pbData += cbQueuedEvent;
        cbBuffer -= cbQueuedEvent;

        m_ReadEvents.pFront = pQueuedEvent->pNext;

        if (pQueuedEvent->e.cbEvent <= sizeof(DWORD))
        {
            // This event came out of the pool
            //
            m_FreeEvents.Free(pQueuedEvent);
        }
        else
        {
            // This event was allocated via new char[]
            //
            char *pOriginalMemory = (char*)pQueuedEvent;
            delete[] pOriginalMemory;
        }
    }

    if (m_ReadEvents.pFront == NULL)
    {
        m_ReadEvents.pRear = NULL;
    }

    LeaveCriticalSection(&m_csEventQueues);

    // Update the buffer header information to match the events just packed
    //
    TraceI(2, "Read: Leaving with %u bytes in buffer\n", (unsigned)(pbData - pbBuffer));
    pIBuffer->SetStartTime(rtStart);
    pIBuffer->SetUsedBytes((DWORD)(pbData - pbBuffer));

    return (pbData == pbBuffer) ? S_FALSE : S_OK;
}
/*
@struct DMUS_NOTERANGE | Contains a range of notes. An array of
<t DMUS_NOTERANGE> structures is used as an optional parameter
by <om IDirectMusicPort::DownloadInstrument> to
determine which regions within the DLS instrument to download.

@field DWORD | dwSize | Contains the total size in bytes of the structure
@field DWORD | dwLowNote | Sets the low note for the range within the
<i IDirectMusicInstrument> to download.
@field DWORD | dwHighNote | Sets the high note for the range within the
<i IDirectMusicInstrument> to download.

@xref <om IDirectMusicPort::DownloadInstrument>,
<om IDirectMusicPerformance::DownloadInstrument>
*/

/*
@method:(EXTERNAL) HRESULT | IDirectMusicPort | DownloadInstrument |
Downloads an <i IDirectMusicInstrument> to the port.

<om IDirectMusicPort::DownloadInstrument> pulls the
instrument data from <p pInstrument>
and sends it to the synthesizer.

The instrument is parsed and converted into a series of
instrument articulation and wave memory chunks. In addition, if
the waves are compressed, the download operation decompresses the
waves and write the uncompressed data into the memory chunks.

The optional <p pNoteRanges> parameter allows the caller to
economize on allocated memory. When specificed, only the wave and
articulation data for the required ranges of notes are downloaded.

The address of an <i IDirectMusicDownloadedInstrument> interface pointer,
which is later used to unload the instrument, is returned.

@rdesc Returns one of the following:
@flag S_OK | The operation completed successfully.
@flag E_POINTER | If any of the pointers is invalid
@flag E_NOTIMPL | If the port does not support DLS.

@xref <i IDirectMusic>,
<i IDirectMusicPort>,
<om IDirectMusicSynth::Download>,
<om IDirectMusicBand::Download>,
<om IDirectMusicPerformance::DownloadInstrument>
*/
STDMETHODIMP
CDirectMusicPort::DownloadInstrument(
    IDirectMusicInstrument* pInstrument,                        // @parm Contains a pointer to an <i IDirectMusicInstrument> object
                                                                // from which <om IDirectMusicPort::Download> extracts the necessary
                                                                // instrument data to be downloaded.

    IDirectMusicDownloadedInstrument** ppDownloadedInstrument,  // @parm Address of the <i IDirectMusicDownloadedInstrument> interface pointer.
                                                                // This interface pointer is later used to unload the instrument with a call
                                                                // to <om IDirectMusicPort::Unload>.

    DMUS_NOTERANGE* pNoteRanges,                                // @parm An optional pointer to an array of <t DMUS_NOTERANGE>
                                                                // structures. Each <t DMUS_NOTERANGE> structure in the array specifies a
                                                                // contiguous range of MIDI notes to which the instrument must
                                                                // respond. An instrument region will be downloaded only if at least one
                                                                // note in that region is specified in the <t DMUS_NOTERANGE> structures.  If
                                                                // none of the notes contained within a specific instrument region is
                                                                // included in any of the <t DMUS_NOTERANGE> structures, then that region and
                                                                // its associated wave data will not be downloaded. This allows for the
                                                                // more efficient usage of the device's resources as well as improved
                                                                // efficiency of downloads.
                                                                // However, if the entire instrument is desired (and that is usually the
                                                                // case,) <p pNoteRanges> can be set
                                                                // to NULL.

    DWORD dwNumNoteRanges)                                      // @parm The number of <t DMUS_NOTERANGE> structures in the array pointed to by
                                                                // <p pNoteRanges>. If this value is set to 0, <p pNoteRanges> is
                                                                // ignored and all regions and wave data for the instrument are downloaded.
{
    V_INAME(IDirectMusicPort::DownloadInstrument);
    V_INTERFACE(pInstrument);
    V_PTRPTR_WRITE(ppDownloadedInstrument);
    V_BUFPTR_READ(pNoteRanges, (dwNumNoteRanges * sizeof(DMUS_NOTERANGE)));

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fCanDownload)
    {
        return E_NOTIMPL;
    }

    return CDirectMusicPortDownload::DownloadP(pInstrument,
                                               ppDownloadedInstrument,
                                               pNoteRanges,
                                               dwNumNoteRanges,
                                               TRUE);
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicPort | UnloadInstrument |
Unloads an instrument
previously downloaded with <om IDirectMusicPort::Download>. Once an
instrument has been unloaded it is no longer available to process
MIDI messages.

@rdesc Returns one of the following
@flag S_OK | The operation completed successfully.
@flag E_POINTER | If the <p pDownloadedInstrument> pointer is invalid.
@flag E_NOTIMPL | If the port does not support DLS.

@xref <i IDirectMusic>,
<i IDirectMusicPort>,
<om IDirectMusicSynth::Unload>,
<om IDirectMusicBand::Unload>,
<om IDirectMusicPerformance::UnloadInstrument>
*/

STDMETHODIMP
CDirectMusicPort::UnloadInstrument(
    IDirectMusicDownloadedInstrument* pDownloadedInstrument)    // @parm Pointer to an <i IDirectMusicDownloadedInstrument> interface.
                                                                // This interface pointer was obtained by a call to
                                                                // <om IDirectMusicPort::DownloadInstrument>.
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fCanDownload)
    {
        return E_NOTIMPL;
    }

    return CDirectMusicPortDownload::UnloadP(pDownloadedInstrument);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Download

typedef struct
{
    KSNODEPROPERTY  ksnp;
    SYNTH_BUFFER    dlsBuffer;
} KSPROPERTY_DOWNLOAD;

STDMETHODIMP
CDirectMusicPort::Download(IDirectMusicDownload* pIDMDownload)
{
    V_INAME(IDirectMusicPort::Download);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    EnterCriticalSection(&m_DMDLCriticalSection);

    // If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate
    // pIDMDownload is of type CDownloadBuffer.
    IDirectMusicDownloadPrivate* pDMDLP = NULL;
    HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

    if(SUCCEEDED(hr))
    {
        pDMDLP->Release();

        hr = ((CDownloadBuffer *)pIDMDownload)->IsDownloaded();
        if(hr != S_FALSE)
        {
            LeaveCriticalSection(&m_DMDLCriticalSection);
            return DMUS_E_ALREADY_DOWNLOADED;
        }

        void* pvBuffer = NULL;
        DWORD dwSize;
        hr = ((CDownloadBuffer *)pIDMDownload)->GetBuffer(&pvBuffer, &dwSize);

        if(pvBuffer == NULL)
        {
            hr = DMUS_E_BUFFERNOTSET;
        }

        if(SUCCEEDED(hr))
        {
            KSPROPERTY_DOWNLOAD kspDownload;
            SYNTHDOWNLOAD sd;
            ULONG ulBytesReturned;

            ZeroMemory(&kspDownload, sizeof(kspDownload));
            kspDownload.ksnp.Property.Set    = KSPROPSETID_Synth_Dls;
            kspDownload.ksnp.Property.Id     = KSPROPERTY_SYNTH_DLS_DOWNLOAD;
            kspDownload.ksnp.Property.Flags  = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
            kspDownload.ksnp.NodeId          = m_idxSynthNode;
            kspDownload.ksnp.Reserved        = 0;

            kspDownload.dlsBuffer.BufferSize    = dwSize;
            kspDownload.dlsBuffer.BufferAddress = pvBuffer;

            if (!Property(m_hPin,
                          sizeof(kspDownload),
                          (PKSIDENTIFIER)&kspDownload,
                          sizeof(sd),
                          &sd,
                          &ulBytesReturned))
            {
                hr = WIN32ERRORtoHRESULT(GetLastError());
            }
            else if (ulBytesReturned < sizeof(sd))
            {
                hr = DMUS_E_DRIVER_FAILED;
            }
            else
            {
                hr = S_OK;
            }

            if(SUCCEEDED(hr))
            {
                ((CDownloadBuffer *)pIDMDownload)->m_DLHandle = sd.DownloadHandle;

                // AddRef() before we add it to the list.
                pIDMDownload->AddRef();
                DWORD dwID = ((DMUS_DOWNLOADINFO*)pvBuffer)->dwDLId;
                ((CDownloadBuffer *)pIDMDownload)->m_dwDLId = dwID;
                m_DLBufferList[dwID % DLB_HASH_SIZE].AddHead((CDownloadBuffer*)pIDMDownload);

                ((CDownloadBuffer*)pIDMDownload)->IncDownloadCount();

                if(sd.Free)
                {
                    pvBuffer = NULL;
                    DWORD dw;
                    ((CDownloadBuffer *)pIDMDownload)->GetHeader(&pvBuffer, &dw);
                    ((CDownloadBuffer *)pIDMDownload)->SetBuffer(NULL, 0, 0);
                    delete [] pvBuffer;
                }
                else
                {
                    // If we do not free buffer we need to AddRef()
                    // We do not want buffer to go away until the IDirectMusicPort is
                    // finished with it.
                    pIDMDownload->AddRef();
                }
            }
            else if(FAILED(hr))
            {
                ((CDownloadBuffer *)pIDMDownload)->m_DLHandle = NULL;
            }
        }
    }

    LeaveCriticalSection(&m_DMDLCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Unload

STDMETHODIMP
CDirectMusicPort::Unload(IDirectMusicDownload* pIDMDownload)
{
    V_INAME(IDirectMusicPort::Unload);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    EnterCriticalSection(&m_DMDLCriticalSection);

    // If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate
    // pIDMDownload is of type CDownloadBuffer.
    IDirectMusicDownloadPrivate* pDMDLP = NULL;
    HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

    if(SUCCEEDED(hr))
    {
        pDMDLP->Release();

        if (((CDownloadBuffer *)pIDMDownload)->IsDownloaded() == S_OK)
        {
            if(((CDownloadBuffer *)pIDMDownload)->DecDownloadCount() == 0)
            {
                m_DLBufferList[((CDownloadBuffer *)pIDMDownload)->m_dwDLId % DLB_HASH_SIZE].Remove((CDownloadBuffer *)pIDMDownload);

#if 0
                if(m_dwNumEvents < m_dwNumEventsAllocated)
                {
                    m_phUnloadEventList[m_dwNumEvents] = CreateEvent(NULL, TRUE, FALSE, NULL);
                    m_dwNumEvents++;
                }
                else
                {
                    // Allocate more handles
                }
#endif

                KSNODEPROPERTY ksnp;

                ksnp.Property.Set = KSPROPSETID_Synth_Dls;
                ksnp.Property.Id = KSPROPERTY_SYNTH_DLS_UNLOAD;
                ksnp.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
                ksnp.NodeId = m_idxSynthNode;
                ksnp.Reserved = 0;

                HANDLE hDLHandle = ((CDownloadBuffer *)pIDMDownload)->m_DLHandle;

#if 0
                if (!PropertyAsync(m_hPin,
                                   sizeof(ksnp),
                                   (PKSIDENTIFIER)&ksnp,
                                   sizeof(HANDLE),
                                   &hDLHandle,
                                   NULL,
                                   &(((CDownloadBuffer *)pIDMDownload)->m_DLHandle))) // XXX DLHandle is not currently event handle!!!
                {
                    hr = WIN32ERRORtoHRESULT(GetLastError());
                }
                else
                {
                    void* pBuffer = NULL;
                    ((CDownloadBuffer*)pIDMDownload)->GetBuffer(&pBuffer);

                    if(pBuffer == NULL && WaitForSingleObject((((CDownloadBuffer *)pIDMDownload)->m_DLHandle), 0) == WAIT_OBJECT_0)
                    {
                        pIDMDownload->Release();
                    }
                    else
                    {
                        m_UnloadedList.AddTail((CDownloadBuffer*)pIDMDownload);
                    }

                    hr = S_OK;
                }
#else
                if (!Property(m_hPin,
                              sizeof(ksnp),
                              (PKSIDENTIFIER)&ksnp,
                              sizeof(HANDLE),
                              &hDLHandle,
                              NULL))
                {
                    hr = WIN32ERRORtoHRESULT(GetLastError());
                }
                else
                {
                    pIDMDownload->Release();
                    hr = S_OK;
                }
#endif
            }
        }
        else
        {
            TraceI(0, "CDirectMusicPort::Unload- not downloaded\n");
        }
    }

    LeaveCriticalSection(&m_DMDLCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetAppend

STDMETHODIMP
CDirectMusicPort::GetAppend(DWORD* pdwAppend)
{
    V_INAME(IDirectMusicPort::GetAppend);
    V_PTR_WRITE(pdwAppend, DWORD);

    if(!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY ksnp;

    ksnp.Property.Set = KSPROPSETID_Synth_Dls;
    ksnp.Property.Id = KSPROPERTY_SYNTH_DLS_APPEND;
    ksnp.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId = m_idxSynthNode;
    ksnp.Reserved = 0;

    ULONG ulBytesReturned;
    if((!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                   sizeof(DWORD),
                   pdwAppend,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetLatencyClock | Gets an <i IReferenceClock> which returns the port's latency clock.
//
// @comm
// The IDirectMusicPort::GetLatencyClock is used to get an
// IReferenceClock interface pointer to the port's latency clock.  The
// latency clock specifies the nearest time in the future at which an
// event can be played on time.  The latency clock is based on the
// DirectMusic master clock, which is set with
// <om IDirectMusic::SetMasterClock>.
//
// In accordance with COM rules, GetLatencyClock performs an AddRef on the
// returned interface. Therefore the application must call Release on the returned
// interface at some point.
//
// @rdesc
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If the <p ppClock> pointer is invalid
//
STDMETHODIMP
CDirectMusicPort::GetLatencyClock(
    IReferenceClock **ppClock)              // @parm Address of the latency clock's <i IReferenceClock> interface pointer.
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_pClock->AddRef();
    *ppClock = m_pClock;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusicPort | GetRunningStats | Gets detailed statistics about the performance of a software synthesizer.
//
// @comm
//
// The IDirectMusicPort::GetRunningStats method fills in a
// <t DMUS_SYNTHSTATS> structure with the current information about the state
// of the port's synthesizer.  See the <t DMUS_SYNTHSTATS> structure for
// details on the type of data that is reported with regards to the
// synthesizer's current status.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | The given <p pStats> pointer was invalid.
// @flag E_INVALIDARG | The given <p pStats> struct was not the correct size.
// @flag E_NOTIMPL | If the port is not a software synthesizer.
//
STDMETHODIMP
CDirectMusicPort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)                                // @parm Pointer to the <t DMUS_SYNTHSTATS> structure to receive
                                                            // running statistics of the synthesizer.
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    if(!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    KSNODEPROPERTY ksnp;

    ksnp.Property.Set = KSPROPSETID_Synth;
    ksnp.Property.Id = KSPROPERTY_SYNTH_RUNNINGSTATS;
    ksnp.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId = m_idxSynthNode;
    ksnp.Reserved = 0;

    ULONG ulBytesReturned;

    SYNTH_STATS stats;

    if((!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  sizeof(stats),
                  &stats,
                  &ulBytesReturned)) ||
        (ulBytesReturned < sizeof(stats)))
    {
        TraceI(1, "GetRunningStats: GetLastError() %d\n", GetLastError());
        return E_NOTIMPL;
    }

    pStats->dwValidStats    = stats.ValidStats;
    pStats->dwVoices        = stats.Voices;
    pStats->dwTotalCPU      = stats.TotalCPU;
    pStats->dwCPUPerVoice   = stats.CPUPerVoice;
    pStats->dwLostNotes     = stats.LostNotes;
    pStats->dwFreeMemory    = stats.FreeMemory;
    pStats->lPeakVolume     = stats.PeakVolume;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Activate

STDMETHODIMP
CDirectMusicPort::Activate(
    BOOL fActivate)
{
    V_INAME(IDirectMusicPort::Activate);


    if (fActivate)
    {
        if (m_fAudioDest && !m_fDirectSoundSet)
        {
            BOOL fGotDSound = FALSE;

            // Note: If any of this fails, will fall back to preferred
            // device set up at port create.
            //
            LPDIRECTSOUND pDSound;
            if (FAILED(m_pDM->GetDirectSoundI(&pDSound)))
            {
                TraceI(0, "Failed to get DSound from DirectMusic object!\n");
            }
            else
            {
                if (SUCCEEDED(SetDirectSoundI(pDSound, NULL, FALSE)))
                {
                    fGotDSound = TRUE;
                }
                else
                {
                    TraceI(0, "Failed to set DSound on port!\n");
                }

                m_pDM->ReleaseDirectSoundI();
            }
        }

        if (InterlockedExchange(&m_lActivated, 1))
        {
            return S_FALSE;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0)
        {
            return S_FALSE;
        }
    }


    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    BOOL fResult = PinSetState(fActivate ? KSSTATE_RUN : KSSTATE_ACQUIRE);

    if (fResult && fActivate)
    {
        m_fHasActivated = TRUE;
    }

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::SetChannelPriority

typedef struct
{
    KSNODEPROPERTY              ksnp;
    SYNTHVOICEPRIORITY_INSTANCE vpi;
} KSPROPERTY_VOICEPRIORITY;

STDMETHODIMP
CDirectMusicPort::SetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    DWORD dwPriority)
{
    KSPROPERTY_VOICEPRIORITY kvp;

    ZeroMemory(&kvp, sizeof(kvp));
    kvp.ksnp.Property.Set    = KSPROPSETID_Synth;
    kvp.ksnp.Property.Id     = KSPROPERTY_SYNTH_VOICEPRIORITY;
    kvp.ksnp.Property.Flags  = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    kvp.ksnp.NodeId          = m_idxSynthNode;
    kvp.ksnp.Reserved        = 0;

    kvp.vpi.ChannelGroup = dwChannelGroup;
    kvp.vpi.Channel      = dwChannel;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(kvp),
                   (PKSIDENTIFIER)&kvp,
                   sizeof(DWORD),
                   &dwPriority,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetChannelPriority

STDMETHODIMP
CDirectMusicPort::GetChannelPriority(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwPriority)
{
    V_INAME(IDirectMusicPort::GetChannelPriority);
    V_PTR_WRITE(pdwPriority, DWORD);

    KSPROPERTY_VOICEPRIORITY kvp;

    ZeroMemory(&kvp, sizeof(kvp));
    kvp.ksnp.Property.Set    = KSPROPSETID_Synth;
    kvp.ksnp.Property.Id     = KSPROPERTY_SYNTH_VOICEPRIORITY;
    kvp.ksnp.Property.Flags  = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    kvp.ksnp.NodeId          = m_idxSynthNode;
    kvp.ksnp.Reserved        = 0;

    kvp.vpi.ChannelGroup = dwChannelGroup;
    kvp.vpi.Channel      = dwChannel;

    ULONG ulBytesReturned;
    if ((!Property(m_hPin,
                   sizeof(kvp),
                   (PKSIDENTIFIER)&kvp,
                   sizeof(DWORD),
                   pdwPriority,
                   &ulBytesReturned)) ||
        (ulBytesReturned != sizeof(DWORD)))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::SetDirectSound

STDMETHODIMP
CDirectMusicPort::SetDirectSound(
    LPDIRECTSOUND pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    if (m_fHasActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    if (pDirectSoundBuffer && !pDirectSound)
    {
        return E_INVALIDARG;
    }

    return SetDirectSoundI(pDirectSound, pDirectSoundBuffer, TRUE);
}

HRESULT
CDirectMusicPort::SetDirectSoundI(
    LPDIRECTSOUND pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer,
    BOOL fSetByUser)
{
    LPSTR pstrInterface = NULL;
    HRESULT hr = DirectSoundDevice(pDirectSound, &pstrInterface);
    if (FAILED(hr))
    {
        return hr;
    }

    PORTENTRY *pPort = m_pDM->GetPortByGUID(m_guidPort);

    LPSTR pstrInstanceId = NULL;

    if ((pPort == NULL) ||
        (!(pPort->fAudioDest)) ||
        (!DINameToInstanceId(pstrInterface, &pstrInstanceId)))
    {
        delete[] pstrInterface;
        return DMUS_E_DRIVER_FAILED;
    }

    // We don't need this anymore
    delete[] pstrInterface;

    CNode<PORTDEST *> *pNode;
    PORTDEST *pDest;

    for (pNode = pPort->lstDestinations.GetListHead();
         pNode;
         pNode = pNode->pNext)
    {
        pDest = pNode->data;

        if (!_stricmp(pDest->pstrInstanceId, pstrInstanceId))
        {
            m_idxDev = pDest->idxDevice;
            m_idxPin = pDest->idxPin;
            m_idxSynthNode = pDest->idxNode;

            delete[] pstrInstanceId;

            if (!m_fDirectSoundSet && fSetByUser)
            {
                m_fDirectSoundSet = TRUE;
            }

            return pDirectSoundBuffer ? DMUS_S_NOBUFFERCONTROL  : S_OK;
        }
    }

    delete[] pstrInstanceId;
    return DMUS_E_DRIVER_FAILED;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetFormat

STDMETHODIMP
CDirectMusicPort::GetFormat(
    LPWAVEFORMATEX pwfex,
    LPDWORD pdwwfex,
    LPDWORD pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    BOOL fSizeQuery = (pwfex == NULL);

    // kernel mode drivers don't use the buffer size parameter
    //

    if (pcbBuffer != NULL)
    {
        *pcbBuffer = 0;
    }

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth_Dls;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_DLS_WAVEFORMAT;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    ksnp.NodeId           = m_idxSynthNode;
    ksnp.Reserved         = 0;

    // If we're doing a size query, use a WAVEFORMATEX on the stack
    //
    if (fSizeQuery)
    {
        WAVEFORMATEX wfex;

        DWORD cb = sizeof(WAVEFORMATEX);
        if (!Property(m_hPin,
                      sizeof(ksnp),
                      (PKSIDENTIFIER)&ksnp,
                      cb,
                      &wfex,
                      &cb))
        {
            DWORD dwError = GetLastError();

            if (dwError != ERROR_INSUFFICIENT_BUFFER)
            {
                return WIN32ERRORtoHRESULT(dwError);
            }
        }

        // ERROR_INSUFFICIENT_BUFFER or success (the format fit in our wfex).
        // We should have back the amount of space the driver needed for
        // the format.
        //
        *pdwwfex = cb;
        return S_OK;
    }

    assert(pwfex);

    // Not a size query, just fill the user's wfex buffer
    //
    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  *pdwwfex,
                  pwfex,
                  pdwwfex))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    return S_OK;
}

// CDirectMusicPort::DownloadWave
//
STDMETHODIMP
CDirectMusicPort::DownloadWave(
    IDirectSoundWave *pWave,
    IDirectSoundDownloadedWaveP **ppWave,
    REFERENCE_TIME rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

// CDirectMusicPort::UnloadWave
//
STDMETHODIMP
CDirectMusicPort::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    return E_NOTIMPL;
}


// CDirectMusicPort::AllocVoice
//
STDMETHODIMP
CDirectMusicPort::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,
    DWORD dwChannel,
    DWORD dwChannelGroup,
    REFERENCE_TIME rtStart,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,
    IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}

// CDirectMusicPort::SetSink
//
STDMETHODIMP
CDirectMusicPort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    V_INAME(IDirectMusicPort::SetSink);
    V_INTERFACE(pSinkConnect);

    return E_NOTIMPL;
}

// CDirectMusicPort::GetSink
//
STDMETHODIMP
CDirectMusicPort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    V_INAME(IDirectMusicPort::SetSink);
    V_PTRPTR_WRITE(ppSinkConnect);

    return E_NOTIMPL;
}

// CDirectMusicPort::AssignChannelToBuses
//
STDMETHODIMP
CDirectMusicPort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    return E_NOTIMPL;
}

// CDirectMusicPort::ThruChannel
//
STDMETHODIMP
CDirectMusicPort::ThruChannel(
    DWORD dwSourceChannelGroup,
    DWORD dwSourceChannel,
    DWORD dwDestinationChannelGroup,
    DWORD dwDestinationChannel,
    LPDIRECTMUSICPORT pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    // Channel group must not be zero (broadcast) but in range 1..NumChannelGroups]
    // (which for legacy is always 1)
    //
    // XXX Fix this!
    //
    if (dwSourceChannelGroup != 1 ||
        dwSourceChannel > 15)
    {
        TraceI(0, "ThruChannel: dwSourceChannelGroup %d is invalid\n", dwSourceChannelGroup);
        return E_INVALIDARG;
    }

    // Given a port means enable thruing for this channel; NULL means
    // disable.
    //
    if (pDestinationPort)
    {
        // Enabling thruing on this channel. First look at the destination port.
        //
        DMUS_PORTCAPS dmpc;
        dmpc.dwSize = sizeof(dmpc);
        HRESULT hr = pDestinationPort->GetCaps(&dmpc);
        if (FAILED(hr))
        {
            TraceI(0, "ThruChannel: Destination port failed portcaps [%08X]\n", hr);
            return hr;
        }

        // Port must be an output port
        //
        if (dmpc.dwClass != DMUS_PC_OUTPUTCLASS)
        {
            return DMUS_E_PORT_NOT_RENDER;
        }

        // Channel group and channel must be in range.
        //
        if (dwDestinationChannel > 15 ||
            dwDestinationChannelGroup > dmpc.dwMaxChannelGroups)
        {
            TraceI(0, "ThruChannel: dwDestinationChannelGroup %d is invalid -or- \n", dwDestinationChannelGroup);
            TraceI(0, "ThruChannel: dwDestinationChannel %d is invalid\n", dwDestinationChannel);
            TraceI(0, "ThruChannel: Destination has %d channel groups\n", dmpc.dwMaxChannelGroups);

            return E_INVALIDARG;
        }

        // Release existing port
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            // Reference to another port type, release it.
            // (NOTE: No need to turn off native dmusic16 thruing at this point,
            // that's handled in dmusic16).
            //
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
        }


        m_pThruMap[dwSourceChannel].dwDestinationChannel = dwDestinationChannel;
        m_pThruMap[dwSourceChannel].dwDestinationChannelGroup = dwDestinationChannelGroup;
        m_pThruMap[dwSourceChannel].pDestinationPort = pDestinationPort;
        m_pThruMap[dwSourceChannel].fThruInWin16 = FALSE;

        TraceI(2, "ThruChannel: From (%u,%u) -> (%u,%u,%p)\n",
            dwSourceChannelGroup,
            dwSourceChannel,
            dwDestinationChannelGroup,
            dwDestinationChannel,
            pDestinationPort);

        pDestinationPort->AddRef();
    }
    else
    {
        // Disabling thruing on this channel
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
            m_pThruMap[dwSourceChannel].pDestinationPort = NULL;
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::Close

STDMETHODIMP
CDirectMusicPort::Close()
{
    if (m_hPin != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hPin);
        m_hPin = INVALID_HANDLE_VALUE;
    }

    if (m_hSysAudio != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hSysAudio);
        m_hSysAudio = INVALID_HANDLE_VALUE;
    }

    if (m_hCaptureThread != NULL)
    {
        m_fShutdownThread = TRUE;
        SetEvent(m_hCaptureWake);
        if (WaitForSingleObject(m_hCaptureThread, 5000) == WAIT_TIMEOUT)
        {
            TraceI(0, "Capture thread refused to die.\n");
        }

        CloseHandle(m_hCaptureThread);
        m_hCaptureThread = NULL;
    }

    if (m_hCopiedEventList != NULL)
    {
        CloseHandle(m_hCopiedEventList);
        m_hCopiedEventList = NULL;
    }

    if (m_phUnloadEventList)
    {
        BOOL bStatus = SetEvent(m_phUnloadEventList[0]);

#ifdef DBG
        if(!bStatus)
        {
            TraceI(0, "Failed to SetEvent used to notify unload thread to terminate\n");
        }
#endif

        if (m_hUnloadThread)
        {
            WaitForSingleObject(m_hUnloadThread, INFINITE);
        }

        // Clean up the OVERLAPPED array

        // Continue waiting until all overlapped IO has completed
        BOOL fContinue = TRUE;
        while( fContinue )
        {
            // First clear the event and fContinue flag
            ResetEvent( m_phUnloadEventList[2] );
            fContinue = FALSE;

            // Check if any IO has not yet completed
            EnterCriticalSection( &m_OverlappedCriticalSection );

            // Iterate through the list of overlapped structure arrays
            CNode<OverlappedStructs *> *pOverlappedNode;
            for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNode->pNext)
            {
                // get a pointer to each array
                OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
                if( pOverlappedStructs )
                {
                    // Iterate through the array
                    for( int iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
                    {
                        // Only look at the structures that are in use
                        if( pOverlappedStructs->afOverlappedInUse[iOverlapped] )
                        {
                            if( HasOverlappedIoCompleted( &(pOverlappedStructs->aOverlappedIO[iOverlapped]) ) )
                            {
                                // Found a completed one - clean it up
                                pOverlappedStructs->aOverlappedIO[iOverlapped].Internal = 0;
                                pOverlappedStructs->aOverlappedIO[iOverlapped].InternalHigh = 0;
                                pOverlappedStructs->aOverlappedIO[iOverlapped].Offset = 0;
                                pOverlappedStructs->aOverlappedIO[iOverlapped].OffsetHigh = 0;
                                delete pOverlappedStructs->apOverlappedBuffer[iOverlapped];
                                pOverlappedStructs->apOverlappedBuffer[iOverlapped] = NULL;

                                // Flag the structure as available
                                pOverlappedStructs->afOverlappedInUse[iOverlapped] = FALSE;
                            }
                            else
                            {
                                // Still waiting for the IO to complete
                                fContinue = TRUE;
                            }
                        }
                    }
                }
            }

            LeaveCriticalSection( &m_OverlappedCriticalSection );

            // If continuing, wait until the event is signaled
            if( fContinue )
            {
                if (WaitForSingleObject(m_phUnloadEventList[2], 1000) == WAIT_TIMEOUT)
                {
                    TraceI(0, "Close: overlapped IO is taking very long to complete.\n");
                }
            }
        }

        // Cleanup all allocated events
        for(DWORD dwCount = 0; dwCount < m_dwNumEvents; dwCount++)
        {
            if(m_phUnloadEventList[dwCount])
            {
                CloseHandle(m_phUnloadEventList[dwCount]);
                m_phUnloadEventList[dwCount] = NULL;
            }
        }

        delete [] m_phUnloadEventList;
        m_phUnloadEventList = NULL;
    }

    if (m_hUnloadThread)
    {
        CloseHandle(m_hUnloadThread);
        m_hUnloadThread = NULL;
    }

    if (m_phNewUnloadEventList)
    {
        delete [] m_phNewUnloadEventList;
        m_phNewUnloadEventList = NULL;
    }

    if (m_pClock)
    {
        m_pClock->Release();
        m_pClock = NULL;
    }

    if (m_pPCClock)
    {
        m_pPCClock->Release();
        m_pPCClock = NULL;
    }

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pThruMap)
    {
        delete[] m_pThruMap;
        m_pThruMap = NULL;
    }

    if (m_pThruBuffer)
    {
        m_pThruBuffer->Release();
        m_pThruBuffer = NULL;
    }

    m_pDM = NULL;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::StartVoice
//
STDMETHODIMP CDirectMusicPort::StartVoice(
     DWORD dwVoiceId,
     DWORD dwChannel,
     DWORD dwChannelGroup,
     REFERENCE_TIME rtStart,
     DWORD dwDLId,
     LONG prPitch,
     LONG vrVolume,
     SAMPLE_TIME stVoiceStart,
     SAMPLE_TIME stLoopStart,
     SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::StopVoice
//
STDMETHODIMP CDirectMusicPort::StopVoice(
     DWORD dwVoiceId,
     REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::GetVoiceState
//
STDMETHODIMP CDirectMusicPort::GetVoiceState(
    DWORD dwVoice[],
    DWORD cbVoice,
    DMUS_VOICE_STATE dwVoiceState[])
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSynthPort::Refresh
//
STDMETHODIMP CDirectMusicPort::Refresh(
    DWORD dwDownloadId,
    DWORD dwFlags)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return E_NOTIMPL;
}

/*
@method:(EXTERNAL) HRESULT | IKsControl | KsProperty | Get or set the value of a property.

This method forwards a property request to the port. A property request consists of a property set
and id to set or get, and associated data. In some cases instance data is required to specify which
instance of a property should should be accessed.

The operation performed and property to be accessed are specicified by a <c KSPROPERTY> structure. This
structure contains Set and Id members which specify the property item to access. The Flags field may contain
exactly one of the following flags to specify the operation:

@flag KSPROPERTY_TYPE_GET | To retrieve the given property item's value
@flag KSPROPERTY_TYPE_SET | To store the given property item's valud
@flag KSPROPERTY_TYPE_BASICSUPPORT | To determine the type of support available for the property set

For KSPROPERTY_TYPE_BASICSUPPORT, the data returned in <p *pvPropertyData> will be a DWORD containing these same
flags indicating which operations are possible.

@ex The following code uses KsProperty to determine if the port supports General MIDI in hardware:

    BOOL IsGMSupported(IDirectMusicPort *pPort)
    {
        HRESULT     hr;
        IKsControl  *pControl;
        KSPROPERTY  ksp;
        DWORD       dwIsSupported;
        ULONG       cb;
        BOOL        fIsSupported;

        hr = pPort->QueryInterface(IID_IKsControl, (void**)&pControl);
        if (FAILED(hr))
        {
            // Port does not support properties, assume no GM support
            //
            return FALSE;
        }

        // Ask about GM
        //
        ksp.Set   = GUID_DMUS_PROP_GM_Hardware;
        ksp.Id    = 0;                            // Per dmusicc.h, item 0 is support, which returns a DWORD boolean
        ksp.Flags = KSPROPERTY_TYPE_GET;          // Retrieve the value

        hr = pControl->KsProperty(&ksp,
                                  sizeof(ksp),    // If there was instance data, it would immediately follow ksp and
                                                  // the length would reflect this.
                                  &dwIsSupported,
                                  sizeof(dwIsSupported),
                                  &cb);

        fIsSupported = FALSE;
        if (SUCCEEDED(hr) || cb >= sizeof(dwIsSupported)
        {
            // Set is supported
            //
            fIsSupported = (BOOL)(dwIsSupported ? TRUE : FALSE);
        }

         pControl->Release();

        return fIsSupported;
    }

@rdesc

@flag S_OK | The operation completed successfully.
@flag E_POINTER | If any pointer parameter invalid
@flag DMUS_E_UNKNOWN_PROPERTY  | If the specified property set or item is unsupported by this port.


*/
STDMETHODIMP
CDirectMusicPort::KsProperty(
        IN PKSPROPERTY  pProperty,              // @parm The property item and operation to perform. If this property contains
                                                // instance data, then that data should reside in memory immediately
                                                // following the KSPROPERTY structure.
        IN ULONG        ulPropertyLength,       // @parm The length of the memory pointed to by <p pProperty>, including any
                                                // instance data.
        IN OUT LPVOID   pvPropertyData,         // @parm For a set operation, a memory buffer containing data representing
                                                // the new value of the property. For a get operation, a memory buffer big
                                                // enough to hold the value of the property. For a basic support query,
                                                // a pointer to a buffer at least the size of a DWORD.
        IN ULONG        ulDataLength,           // @parm The length of the buffer pointed to by <p pvPropertyData>.
        OUT PULONG      pulBytesReturned)       // @parm On a get or basic support call, the number of bytes returned in
                                                // <p pvPropertyData> by the port.
{
    LONG lVolume;

    V_INAME(DirectMusicPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pProperty, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);


    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (ulPropertyLength < sizeof(KSPROPERTY))
    {
        return E_INVALIDARG;
    }

    //Check that the buffer isn't NULL
    //
    if (pvPropertyData == NULL)
    {
        return E_POINTER;
    }

    // Don't let callers touch property sets we use
    //
    if (pProperty->Set == KSPROPSETID_Synth)
    {
        if (pProperty->Id != KSPROPERTY_SYNTH_VOLUME)
        {
            return DMUS_E_UNKNOWN_PROPERTY;
        }
        else if (ulDataLength != sizeof(LONG))
        {
            return E_INVALIDARG;
        }
        else if (pProperty->Flags & KSPROPERTY_TYPE_SET)
        {
            lVolume = *(LONG*)pvPropertyData;

            // Clamp to -200..+20 db
            //
            if (lVolume < -20000)
            {
                lVolume = -20000;
                pvPropertyData = &lVolume;
            }
            else if (lVolume > 2000)
            {
                lVolume = 2000;
                pvPropertyData = &lVolume;
            }
        }
    }
    else if (pProperty->Set == KSPROPSETID_Synth_Dls)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    // We already have a properly formatted struct; send it down.
    //
    BOOL fResult;
    fResult = SyncIoctl(m_hPin,
                        IOCTL_KS_PROPERTY,
                        pProperty,
                        ulPropertyLength,
                        pvPropertyData,
                        ulDataLength,
                        pulBytesReturned);

    if (!fResult)
    {
        // try topology node
        PKSNODEPROPERTY pksnp = (PKSNODEPROPERTY)new BYTE[sizeof(KSNODEPROPERTY) - sizeof(KSPROPERTY) + ulPropertyLength];
        if (pksnp == NULL)
        {
            return E_OUTOFMEMORY;
        }
        memcpy(&pksnp->Property, pProperty, sizeof(KSPROPERTY));
        pksnp->Property.Flags |= KSPROPERTY_TYPE_TOPOLOGY;
        pksnp->NodeId   = m_idxSynthNode;
        pksnp->Reserved = 0;

        fResult = SyncIoctl(m_hPin,
                            IOCTL_KS_PROPERTY,
                            pksnp,
                            sizeof(KSNODEPROPERTY) - sizeof(KSPROPERTY) + ulPropertyLength,
                            pvPropertyData,
                            ulDataLength,
                            pulBytesReturned);

        delete [] pksnp;
    }

#ifdef DBG
    if (!fResult)
    {
        TraceI(1, "DeviceIoControl: %08X\n", GetLastError());

        TraceI(1, "KS Item: ");
        TraceIGuid(1, &pProperty->Set);
        TraceI(1, "\t#%d\n", pProperty->Id);
        TraceI(1, "\tFlags: %08X\n", pProperty->Flags);
    }
#endif // DBG

    if (!fResult)
    {
        DWORD dwError = GetLastError();

        if (dwError)
        {
            return WIN32ERRORtoHRESULT(dwError);
        }
        else
        {
            return E_NOINTERFACE;
        }
    }

    return S_OK;
}

/*
@method:(EXTERNAL) HRESULT | IKsControl | KsEvent | Enable or disable firing of the given event.

@comm

Currently DirectMusic does not contain support for events.

*/
STDMETHODIMP
CDirectMusicPort::KsEvent(
        IN PKSEVENT     pEvent,
        IN ULONG        ulEventLength,
        IN OUT LPVOID   pvEventData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // We already have a properly formatted struct; send it down.
    //
    BOOL fResult;
    fResult = SyncIoctl(m_hPin,
                        IOCTL_KS_ENABLE_EVENT,  // XXX Fix this!!!
                        pEvent,
                        ulEventLength,
                        pvEventData,
                        ulDataLength,
                        pulBytesReturned);

    if (!fResult)
    {
        // NYI: try topology node
    }

#ifdef DBG
    if (!fResult)
    {
        TraceI(0, "DeviceIoControl: %08X\n", GetLastError());
    }
#endif // DBG

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}


/*
@method:(EXTERNAL) HRESULT | IKsControl | Method | Calls the specified Ks method.

@comm

Currently DirectMusic does not contain support for methods.

*/
STDMETHODIMP
CDirectMusicPort::KsMethod(
        IN PKSMETHOD    pMethod,
        IN ULONG        ulMethodLength,
        IN OUT LPVOID   pvMethodData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicPort::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulMethodLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // We already have a properly formatted struct; send it down.
    //
    BOOL fResult;
    fResult = SyncIoctl(m_hPin,
                        IOCTL_KS_METHOD,
                        pMethod,
                        ulMethodLength,
                        pvMethodData,
                        ulDataLength,
                        pulBytesReturned);

    if (!fResult)
    {
        // NYI: try topology node
    }

#ifdef DBG
    if (!fResult)
    {
        TraceI(0, "DeviceIoControl: %08X\n", GetLastError());
    }
#endif // DBG

    return fResult ? S_OK : WIN32ERRORtoHRESULT(GetLastError());
}
//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::PinSetState

BOOL CDirectMusicPort::PinSetState(KSSTATE DeviceState)
{
    KSPROPERTY      ksp;

    ksp.Set    = KSPROPSETID_Connection;
    ksp.Id     = KSPROPERTY_CONNECTION_STATE;
    ksp.Flags  = KSPROPERTY_TYPE_SET;

    return Property(m_hPin,
                    sizeof(KSPROPERTY),
                    &ksp,
                    sizeof(DeviceState),
                    &DeviceState,
                    NULL);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::FreeWDMHandle

void CDirectMusicPort::FreeWDMHandle()
{
    while(1)
    {
        // If the unload list has been cleaned up on us, exit the
        // thread. This can happen under really heavy load (like
        // stress) when downloads are being unloaded right at
        // port release time
        //
        DWORD dwIndex;
        try
        {
            // Fix 43266: Make sure both of these are non-zero before calling
            // WaitForMultipleObjects
            if( NULL != m_phUnloadEventList
            &&  0 != m_dwNumEvents )
            {
                dwIndex = WaitForMultipleObjects(m_dwNumEvents,
                                                 m_phUnloadEventList,
                                                 FALSE,
                                                 INFINITE);
            }
            else
            {
                return;
            }
        }
        catch (...)
        {
            return;
        }

        if(dwIndex == 0 || dwIndex == WAIT_FAILED)
        {
            // If first event is signaled or error it is time to die.
            return;
        }
        else if(dwIndex == 1)
        {
            // If second event is signaled we need to changes the objects
            // we are waiting on.
            continue;

        }
        else if(dwIndex == 2 )
        {
            // If third event is signaled, we need to check which
            // OVERLAPPED structures are in use

            // But, first clear the event
            ResetEvent( m_phUnloadEventList[2] );

            EnterCriticalSection( &m_OverlappedCriticalSection );

            // Iterate through the list of overlapped structure arrays
            CNode<OverlappedStructs *> *pOverlappedNode;
            for (pOverlappedNode = m_lstOverlappedStructs.GetListHead(); pOverlappedNode; pOverlappedNode = pOverlappedNode->pNext)
            {
                // get a pointer to each array
                OverlappedStructs *pOverlappedStructs = pOverlappedNode->data;
                if( pOverlappedStructs )
                {
                    // Iterate through the array
                    for( int iOverlapped = 0; iOverlapped < OVERLAPPED_ARRAY_SIZE; iOverlapped++ )
                    {
                        if( pOverlappedStructs->afOverlappedInUse[iOverlapped]
                        &&  HasOverlappedIoCompleted( &(pOverlappedStructs->aOverlappedIO[iOverlapped]) ) )
                        {
                            // Found a completed one - clean it up
                            pOverlappedStructs->aOverlappedIO[iOverlapped].Internal = 0;
                            pOverlappedStructs->aOverlappedIO[iOverlapped].InternalHigh = 0;
                            pOverlappedStructs->aOverlappedIO[iOverlapped].Offset = 0;
                            pOverlappedStructs->aOverlappedIO[iOverlapped].OffsetHigh = 0;
                            delete pOverlappedStructs->apOverlappedBuffer[iOverlapped];
                            pOverlappedStructs->apOverlappedBuffer[iOverlapped] = NULL;

                            // Flag the structure as available
                            pOverlappedStructs->afOverlappedInUse[iOverlapped] = FALSE;
                        }
                    }
                }
            }

            LeaveCriticalSection( &m_OverlappedCriticalSection );
        }
        else if(dwIndex == 3)
        {
            // If fourth event is signaled we need to change our event list
            if(m_phNewUnloadEventList)
            {
                CopyMemory(m_phNewUnloadEventList, m_phUnloadEventList, (sizeof(HANDLE) * m_dwNumEvents));
                delete [] m_phUnloadEventList;
                m_phUnloadEventList = m_phNewUnloadEventList;
                m_phNewUnloadEventList = NULL;
                PulseEvent(m_hCopiedEventList);
            }
            else
            {
                // We should never get here
                assert(false);
                PulseEvent(m_hCopiedEventList);
            }
        }
        else
        {
            assert(dwIndex > 3);
            for(DWORD i = 0; i < m_dwNumEvents; i++)
            {
                DWORD dwState = WaitForSingleObject(m_phUnloadEventList[i], 0);
                if(dwState == WAIT_OBJECT_0)
                {
                    CDownloadBuffer* pDownload = m_UnloadedList.GetHead();
                    for( ; pDownload; pDownload = pDownload->GetNext())
                    {
                        if(m_phUnloadEventList[i] == (((CDownloadBuffer *)pDownload)->m_DLHandle))
                        {
                            void* pvBuffer = NULL;
                            DWORD dw;
                            HRESULT hr = ((CDownloadBuffer *)pDownload)->GetHeader(&pvBuffer, &dw);

                            if(SUCCEEDED(hr))
                            {
                                hr = ((CDownloadBuffer *)pDownload)->SetBuffer(NULL, 0, 0);
                                if(SUCCEEDED(hr))
                                {
                                    delete [] pvBuffer;
                                    pDownload->Release();
                                }
                            }
                            break;
                        }
                    }
                }
#ifdef DBG
                else if(dwState == WAIT_FAILED)
                {
                    assert(false);
                    return;
                }
                else if(dwState == WAIT_ABANDONED)
                {
                    // We should never get here
                    assert(false);
                }
#endif
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////
// FreeWDMHandle

static DWORD WINAPI FreeWDMHandle(LPVOID lpThreadParameter)
{
    ((CDirectMusicPort *)lpThreadParameter)->FreeWDMHandle();

    return 0;
}

//////////////////////////////////////////////////////////////////////
//
// CaptureThread
//
void CDirectMusicPort::CaptureThread()
{
    READ_IRP    irp[POSTED_STREAM_READ_IRPS];
    READ_IRP    *pirp;

    assert(POSTED_STREAM_READ_IRPS + 1 < MAXIMUM_WAIT_OBJECTS);
    HANDLE      aWaitHandles[POSTED_STREAM_READ_IRPS + 1];
    HANDLE      *pWaitHandles;

    ULONG       cbRet;

    // Create events. If this fails, don't go any farther
    //
    ZeroMemory(irp, sizeof(irp));

    for (pirp = &irp[0], pWaitHandles = &aWaitHandles[0];
         pirp <= &irp[POSTED_STREAM_READ_IRPS-1];
         pirp++, pWaitHandles++)
    {
        *pWaitHandles = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (*pWaitHandles == NULL)
        {
            TraceI(0, "Failed to CreateEvent in CaptureThread\n");

            int idx = (int) (pWaitHandles - aWaitHandles);

            pWaitHandles = aWaitHandles;
            while (idx--)
            {
                CloseHandle(*pWaitHandles++);
                return;
            }
        }

        pirp->overlapped.hEvent = *pWaitHandles;
    }

    // Initialize IRP's
    //
    for (pirp = &irp[0]; pirp <= &irp[POSTED_STREAM_READ_IRPS-1]; pirp++)
    {
        pirp->kssh.Size = sizeof(KSSTREAM_HEADER);

        pirp->kssh.PresentationTime.Numerator   = 1;
        pirp->kssh.PresentationTime.Denominator = 1;

        pirp->kssh.FrameExtent  = BYTES_PER_READ_IRP;
        pirp->kssh.Data         = &pirp->buffer[0];

        TraceI(2, "About to DeviceIoControl\n");
        if (!::DeviceIoControl(m_hPin,
                               IOCTL_KS_READ_STREAM,
                               NULL, 0,
                               &pirp->kssh, sizeof(pirp->kssh),
                               &cbRet,
                               &pirp->overlapped))
        {
#ifdef DBG
            DWORD dwError = GetLastError();
            if (dwError != ERROR_IO_PENDING)
            {
                TraceI(0, "CaptureThread: Warning: AsyncIoctl failed %d\n", dwError);
            }
#endif
        }
    }

    // Last event is the thread wakeup event
    //
    aWaitHandles[POSTED_STREAM_READ_IRPS] = m_hCaptureWake;

    // Process events and shove them into the read queue
    //
    for(;;)
    {
        WaitForMultipleObjects(POSTED_STREAM_READ_IRPS + 1,
                               &aWaitHandles[0],
                               FALSE,               // Wake on any, not all
                               INFINITE);

        // First see if the thread is dying. If so, get out of here.
        //
        if (m_fShutdownThread)
        {
            for (pWaitHandles = &aWaitHandles[0];
                 pWaitHandles <= &aWaitHandles[POSTED_STREAM_READ_IRPS-1];
                 pWaitHandles++)
            {
                CloseHandle(*pWaitHandles);
            }

            return;
        }

        // Still alive. Process any queued data.
        //
        for (pirp = &irp[0]; pirp <= &irp[POSTED_STREAM_READ_IRPS-1]; pirp++)
        {
            if (WaitForSingleObject(pirp->overlapped.hEvent, 0) != WAIT_OBJECT_0)
            {
                continue;
            }

            assert(pirp->kssh.PresentationTime.Numerator == pirp->kssh.PresentationTime.Denominator);
            if (pirp->kssh.DataUsed)
            {
                InputWorkerDataReady(pirp->kssh.PresentationTime.Time,
                                     (LPBYTE)pirp->kssh.Data,
                                     pirp->kssh.DataUsed);
                if (m_hAppEvent)
                {
                    try
                    {
                        SetEvent(m_hAppEvent);
                    }
                    catch (...)
                    {
                        Trace(0, "Capture: Application notify event handle prematurely free'd!\n");
                    }
                }
            }

            ResetEvent(pirp->overlapped.hEvent);
            pirp->kssh.DataUsed = 0;
            pirp->kssh.OptionsFlags = 0;

            if (!::DeviceIoControl(m_hPin,
                                   IOCTL_KS_READ_STREAM,
                                   NULL, 0,
                                   &pirp->kssh, sizeof(pirp->kssh),
                                   &cbRet,
                                   &pirp->overlapped))
            {
                if (GetLastError() != ERROR_IO_PENDING)
                {
                    TraceI(0, "CaptureThread: Warning: AsyncIoctl repost failed %d\n", GetLastError());
                }
            }
        }
    }
}

// CDirectMusicPort::InputWorkerDataReady()
//
// The input worker thread has been notified that there is data available.
// Read any pending events from the 16-bit DLL, perform needed thruing, and
// save the data in a queue so we can repackage it on the read request
// from the client.
//
void CDirectMusicPort::InputWorkerDataReady(REFERENCE_TIME rtStart, LPBYTE pbData, ULONG cbData)
{
    DMEVENT *pEvent;
    DWORD cbRounded;

    TraceI(2, "Enter InputWorkerDataReady()\n");

    SyncClocks();
    SlaveToMaster(&rtStart);

    for(;;)
    {
        if (cbData == 0)
        {
            return;
        }

        // Copy temporary buffer as events into queue
        //
        while (cbData)
        {
            pEvent = (DMEVENT*)pbData;
            cbRounded = DMUS_EVENT_SIZE(pEvent->cbEvent);

            TraceI(2, "cbData %u  cbRounded %u\n", cbData, cbRounded);

            if (cbRounded > cbData)
            {
                TraceI(0, "InputWorkerDataReady: Event ran off end of buffer\n");
                break;
            }

            cbData -= cbRounded;
            pbData += cbRounded;

            EnterCriticalSection(&m_csEventQueues);

            QUEUED_EVENT *pQueuedEvent;
            int cbEvent;


            if (pEvent->cbEvent <= sizeof(DWORD))
            {
                // Channel message or other really small event, take from
                // free pool.
                //
                pQueuedEvent = m_FreeEvents.Alloc();
                cbEvent = sizeof(DMEVENT);

                TraceI(4, "Queue [%02X %02X %02X %02X]\n",
                    pEvent->abEvent[0],
                    pEvent->abEvent[1],
                    pEvent->abEvent[2],
                    pEvent->abEvent[3]);
            }
            else
            {
                // SysEx or other long event, just allocate it
                //
                cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);
                pQueuedEvent = (QUEUED_EVENT*)new char[QUEUED_EVENT_SIZE(pEvent->cbEvent)];
            }

            if (pQueuedEvent)
            {

                CopyMemory(&pQueuedEvent->e, pEvent, cbEvent);

                // rtDelta is the absolute time of the event while it's in our queue
                //
                pQueuedEvent->e.rtDelta += rtStart;
                ThruEvent(&pQueuedEvent->e);


                if (m_ReadEvents.pFront)
                {
                    m_ReadEvents.pRear->pNext = pQueuedEvent;
                }
                else
                {
                    m_ReadEvents.pFront = pQueuedEvent;
                }

                m_ReadEvents.pRear = pQueuedEvent;
                pQueuedEvent->pNext = NULL;
            }
            else
            {
                TraceI(1, "InputWorker: Failed to allocate event; dropping\n");
            }
            LeaveCriticalSection(&m_csEventQueues);
        }
    }
    TraceI(2, "Leave InputWorkerDataReady()\n");
}

void CDirectMusicPort::ThruEvent(
    DMEVENT *pEvent)
{
    // Since we know we only have one event and we already have it in the right format,
    // just slam it into the thru buffer. We only have to do this because we might modify
    // it.
    //
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);

    // First see if the event is thruable
    //
    if (pEvent->cbEvent > 3 || ((pEvent->abEvent[0] & 0xF0) == 0xF0))
    {
        // SysEx of some description
        return;
    }

    DWORD dwSourceChannel = (DWORD)(pEvent->abEvent[0] & 0x0F);

    DMUS_THRU_CHANNEL *pThru = &m_pThruMap[dwSourceChannel];
    if (pThru->pDestinationPort == NULL ||
        pThru->fThruInWin16)
    {
        return;
    }

    if (FAILED(m_pThruBuffer->GetRawBufferPtr(&pbData)))
    {
        TraceI(0, "Thru: GetRawBufferPtr\n");
        return;
    }

    if (FAILED(m_pThruBuffer->GetMaxBytes(&cbData)))
    {
        TraceI(0, "Thru: GetMaxBytes\n");
        return;
    }

    if (cbEvent > cbData)
    {
        TraceI(0, "Thru: cbData %u  cbEvent %u\n", cbData, cbEvent);
        return;
    }

    if (FAILED(m_pThruBuffer->SetStartTime(pEvent->rtDelta)) ||
        FAILED(m_pThruBuffer->SetUsedBytes(cbEvent)))
    {
        TraceI(0, "Thru: buffer setup failed\n");
    }

    CopyMemory(pbData, pEvent, cbEvent);

    pEvent = (DMEVENT*)pbData;
    pEvent->rtDelta = 5 * 10000;
    pEvent->dwChannelGroup = pThru->dwDestinationChannelGroup;
    pEvent->abEvent[0] = (BYTE)((pEvent->abEvent[0] & 0xF0) | pThru->dwDestinationChannel);

    pThru->pDestinationPort->PlayBuffer(m_pThruBuffer);
}


//////////////////////////////////////////////////////////////////////
//
// CaptureThread
//
static DWORD WINAPI CaptureThread(LPVOID lpThreadParameter)
{
    ((CDirectMusicPort *)lpThreadParameter)->CaptureThread();

    return 0;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPort::InitChannelPriorities

static DWORD adwChannelPriorities[16] =
{
    DAUD_CHAN1_DEF_VOICE_PRIORITY,
    DAUD_CHAN2_DEF_VOICE_PRIORITY,
    DAUD_CHAN3_DEF_VOICE_PRIORITY,
    DAUD_CHAN4_DEF_VOICE_PRIORITY,
    DAUD_CHAN5_DEF_VOICE_PRIORITY,
    DAUD_CHAN6_DEF_VOICE_PRIORITY,
    DAUD_CHAN7_DEF_VOICE_PRIORITY,
    DAUD_CHAN8_DEF_VOICE_PRIORITY,
    DAUD_CHAN9_DEF_VOICE_PRIORITY,
    DAUD_CHAN10_DEF_VOICE_PRIORITY,
    DAUD_CHAN11_DEF_VOICE_PRIORITY,
    DAUD_CHAN12_DEF_VOICE_PRIORITY,
    DAUD_CHAN13_DEF_VOICE_PRIORITY,
    DAUD_CHAN14_DEF_VOICE_PRIORITY,
    DAUD_CHAN15_DEF_VOICE_PRIORITY,
    DAUD_CHAN16_DEF_VOICE_PRIORITY
};

void CDirectMusicPort::InitChannelPriorities(
    UINT uLowCG,
    UINT uHighCG)
{
    while (uLowCG <= uHighCG)
    {
        for (UINT uChannel = 0; uChannel < 16; uChannel++)
        {
            SetChannelPriority(uLowCG, uChannel, adwChannelPriorities[uChannel]);
        }

        uLowCG++;
    }
}

HRESULT WIN32ERRORtoHRESULT(DWORD dwError)
{
    HRESULT                 hr;

    switch(dwError)
    {
        case ERROR_SUCCESS:
            hr = S_OK;
            break;

        case ERROR_INVALID_FUNCTION:
        case ERROR_BAD_COMMAND:
        case ERROR_INVALID_DATA:
        case ERROR_INVALID_PARAMETER:
        case ERROR_INSUFFICIENT_BUFFER:
        case ERROR_NOACCESS:
        case ERROR_INVALID_FLAGS:
            hr = E_INVALIDARG;
            break;

        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_OUTOFMEMORY:
        case ERROR_NO_SYSTEM_RESOURCES:
        case ERROR_NONPAGED_SYSTEM_RESOURCES:
        case ERROR_PAGED_SYSTEM_RESOURCES:
            hr = E_OUTOFMEMORY;
            break;

        case ERROR_NOT_SUPPORTED:
        case ERROR_CALL_NOT_IMPLEMENTED:
        case ERROR_PROC_NOT_FOUND:
        case ERROR_NOT_FOUND:
            hr = E_NOTIMPL;
            break;

        default:
            hr = E_FAIL;
            break;
    }

    return hr;
}


void CDirectMusicPort::MasterToSlave(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt -= m_lTimeOffset;
    }
}

void CDirectMusicPort::SlaveToMaster(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt += m_lTimeOffset;
    }
}

void CDirectMusicPort::SyncClocks()
{
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;
    LONGLONG drift;

    if (m_fSyncToMaster)
    {
        hr = m_pMasterClock->GetTime(&rtMasterClock);

        if (SUCCEEDED(hr))
        {
            hr = m_pPCClock->GetTime(&rtSlaveClock);
        }

        if (SUCCEEDED(hr))
        {
            drift = (rtSlaveClock + m_lTimeOffset) - rtMasterClock;

            // Work-around 46782 for DX8 release:
            // If drift is greater than 10ms, jump to the new offset value instead
            // of drifting there slowly.
            if( drift > 10000 * 10
            ||  drift < 10000 * -10 )
            {
                m_lTimeOffset -= drift;
            }
            else
            {
                m_lTimeOffset -= drift / 100;
            }
        }
    }
}

// CPortLatencyClock
//
CPortLatencyClock::CPortLatencyClock(
    HANDLE hPin,
    ULONG ulNodeId,
    CDirectMusicPort *pPort) : m_cRef(1), m_hPin(hPin), m_ulNodeId(ulNodeId), m_pPort(pPort)
{
}

// CPortLatencyClock::~CPortLatencyClock
//
CPortLatencyClock::~CPortLatencyClock()
{
}

// CPortLatencyClock::QueryInterface
//
STDMETHODIMP
CPortLatencyClock::QueryInterface(const IID &iid,
                                  void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
    }
    else if (iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

// CPortLatencyClock::AddRef
//
STDMETHODIMP_(ULONG)
CPortLatencyClock::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CPortLatencyClock::Release
//
STDMETHODIMP_(ULONG)
CPortLatencyClock::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CPortLatencyClock::GetTime
//
STDMETHODIMP
CPortLatencyClock::GetTime(
    REFERENCE_TIME *pTime)
{
    V_INAME(IDirectMusicPort:IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    assert(sizeof(REFERENCE_TIME) == sizeof(ULONGLONG));

    KSNODEPROPERTY      ksnp;

    ksnp.Property.Set     = KSPROPSETID_Synth;
    ksnp.Property.Id      = KSPROPERTY_SYNTH_LATENCYCLOCK;
    ksnp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksnp.NodeId           = m_ulNodeId;
    ksnp.Reserved         = 0;

    ULONG ulBytesReturned;
    if (!Property(m_hPin,
                  sizeof(ksnp),
                  (PKSIDENTIFIER)&ksnp,
                  sizeof(REFERENCE_TIME),
                  pTime,
                  &ulBytesReturned))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }

    if (ulBytesReturned < sizeof(REFERENCE_TIME))
    {
        return DMUS_E_DRIVER_FAILED;
    }

    if( m_pPort )
    {
        m_pPort->SlaveToMaster( pTime );
    }

    return S_OK;
}

// CPortLatencyClock::AdviseTime
//
STDMETHODIMP
CPortLatencyClock::AdviseTime(
    REFERENCE_TIME baseTime,
    REFERENCE_TIME streamTime,
    HANDLE hEvent,
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

// CPortLatencyClock::AdvisePeriodic
//
STDMETHODIMP
CPortLatencyClock::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

// CPortLatencyClock::Unadvise
//
STDMETHODIMP
CPortLatencyClock::Unadvise(
    DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmportdl.cpp ===
//
// dmportdl.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
//

#include "debug.h"
#include "dmusicp.h"
#include "dminstru.h"
#include "dminsobj.h"
#include "dmdlinst.h"
#include "dmportdl.h"
#include "dswave.h"
#include "validate.h"
#include "dmvoice.h"
#include <limits.h>

DWORD CDirectMusicPortDownload::sNextDLId = 0;
CRITICAL_SECTION CDirectMusicPortDownload::sDMDLCriticalSection;

 
#ifdef DMUS_GEN_INS_DATA
void writewave(IDirectMusicDownload* pDMDownload, DWORD dwId);
void writeinstrument(IDirectMusicDownload* pDMDownload, DWORD dwId);
#endif

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::CDirectMusicPortDownload

CDirectMusicPortDownload::CDirectMusicPortDownload() :
m_cRef(1),
m_fNewFormat(NEWFORMAT_NOT_RETRIEVED),
m_dwAppend(APPEND_NOT_RETRIEVED)
{
    m_fDMDLCSinitialized = m_fCDMDLCSinitialized = FALSE;

    InitializeCriticalSection(&m_DMDLCriticalSection);
    m_fDMDLCSinitialized = TRUE;

    InitializeCriticalSection(&m_CDMDLCriticalSection);
    m_fCDMDLCSinitialized = TRUE;

    // Note: on pre-Blackcomb OS's, InitializeCriticalSection can raise an exception;
    // if it ever pops in stress, we should add an exception handler and retry loop.
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::~CDirectMusicPortDownload

CDirectMusicPortDownload::~CDirectMusicPortDownload()
{
    DWORD dwIndex;
#ifdef DBG
    BOOL fAssert = TRUE;
#endif
    if (m_fDMDLCSinitialized && m_fCDMDLCSinitialized)
    {    
#ifdef DBG
        EnterCriticalSection(&m_CDMDLCriticalSection);
        if (!m_DLInstrumentList.IsEmpty())
        {
            Trace(0, "ERROR: IDirectMusicDownloadedInstrument objects not unloaded before port final release!\n");
            fAssert = FALSE;
        }
        LeaveCriticalSection(&m_CDMDLCriticalSection);

        EnterCriticalSection(&m_DMDLCriticalSection);

        for (dwIndex = 0; dwIndex < DLB_HASH_SIZE; dwIndex++)
        {
            if (!m_DLBufferList[dwIndex].IsEmpty())
            {
                if (fAssert)
                {
                    assert(FALSE);
                    break;
                }
            }
        }
        LeaveCriticalSection(&m_DMDLCriticalSection);
    #endif // DBG

        // remove any bad list items before they are illegally destroyed in list dtor
        EnterCriticalSection(&m_CDMDLCriticalSection);
        if (!m_DLInstrumentList.IsEmpty())
        {
            m_DLInstrumentList.RemoveAll();
        }
        LeaveCriticalSection(&m_CDMDLCriticalSection);

        EnterCriticalSection(&m_DMDLCriticalSection);
        for (dwIndex = 0; dwIndex < DLB_HASH_SIZE; dwIndex++)
        {
            if (!m_DLBufferList[dwIndex].IsEmpty())
            {
                m_DLBufferList[dwIndex].RemoveAll();
            }
        }
        LeaveCriticalSection(&m_DMDLCriticalSection);
    }

    if (m_fDMDLCSinitialized)
    {
        DeleteCriticalSection(&m_DMDLCriticalSection);
    }

    if (m_fCDMDLCSinitialized)
    {
        DeleteCriticalSection(&m_CDMDLCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::QueryInterface

STDMETHODIMP CDirectMusicPortDownload::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusicDownload::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);


    if(iid == IID_IUnknown || iid == IID_IDirectMusicPortDownload) 
    {
        *ppv = static_cast<IDirectMusicPortDownload*>(this);
    } 
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AddRef

STDMETHODIMP_(ULONG) CDirectMusicPortDownload::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::Release

STDMETHODIMP_(ULONG) CDirectMusicPortDownload::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicPortDownload

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AllocateBuffer

STDMETHODIMP 
CDirectMusicPortDownload::AllocateBuffer(
    DWORD dwSize,
    IDirectMusicDownload** ppIDMDownload) 
{
    // Argument validation
    V_INAME(CDirectMusicPortDownload::AllocateBuffer);
    V_PTRPTR_WRITE(ppIDMDownload);

    if(dwSize <= 0)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;

    CDownloadBuffer* pdmdl = NULL;
    BYTE* pbuf = new BYTE[dwSize + sizeof(KSNODEPROPERTY)];

    if(pbuf)
    {
        pdmdl = new CDownloadBuffer;
        if(pdmdl)
        {
            hr = pdmdl->SetBuffer(pbuf, sizeof(KSNODEPROPERTY), dwSize);
            if(SUCCEEDED(hr))
            {
                *ppIDMDownload = (IDirectMusicDownload*)pdmdl;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if(FAILED(hr))
    {
        if (pdmdl) delete pdmdl;
        if (pbuf) delete [] pbuf;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetBuffer

STDMETHODIMP 
CDirectMusicPortDownload::GetBuffer(
    DWORD dwDLId,
    IDirectMusicDownload** ppIDMDownload)
{
    // Argument validation
    V_INAME(CDirectMusicPortDownload::GetBuffer);
    V_PTRPTR_WRITE(ppIDMDownload);

    if(dwDLId >= CDirectMusicPortDownload::sNextDLId)
    {
        return DMUS_E_INVALID_DOWNLOADID;
    }

    return GetBufferInternal(dwDLId,ppIDMDownload);
}

STDMETHODIMP 
CDirectMusicPortDownload::GetBufferInternal(
    DWORD dwDLId,IDirectMusicDownload** ppIDMDownload)
{
    EnterCriticalSection(&m_DMDLCriticalSection);

    bool bFound = false;    
    
    // Check the download list
    CDownloadBuffer* pDownload = m_DLBufferList[dwDLId % DLB_HASH_SIZE].GetHead();

    for( ; pDownload; pDownload = pDownload->GetNext())
    {
        if(dwDLId == pDownload->m_dwDLId)
        {
            *ppIDMDownload = pDownload;
            (*ppIDMDownload)->AddRef();
            bFound = true;
            break;
        }
    }

    LeaveCriticalSection(&m_DMDLCriticalSection);

    return bFound ? S_OK : DMUS_E_NOT_DOWNLOADED_TO_PORT;   
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::Download

STDMETHODIMP CDirectMusicPortDownload::Download(IDirectMusicDownload* pIDMDownload)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::Unload

STDMETHODIMP CDirectMusicPortDownload::Unload(IDirectMusicDownload* pIDMDownload)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetAppend

STDMETHODIMP CDirectMusicPortDownload::GetAppend(DWORD* pdwAppend)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetDLId

STDMETHODIMP CDirectMusicPortDownload::GetDLId(
    DWORD* pdwStartDLId,
    DWORD dwCount)
{
    // Argument validation
    V_INAME(CDirectMusicPortDownload::GetDLId);
    V_PTR_WRITE(pdwStartDLId, DWORD);

    if(dwCount <= 0 || (sNextDLId + dwCount) > ULONG_MAX)
    {
        return E_INVALIDARG;
    }

    GetDLIdP(pdwStartDLId, dwCount);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetDLIdP

void CDirectMusicPortDownload::GetDLIdP(DWORD* pdwStartDLId, DWORD dwCount)
{
    assert(pdwStartDLId);

    EnterCriticalSection(&sDMDLCriticalSection);
    
    *pdwStartDLId = sNextDLId;
    
    sNextDLId += dwCount;
    
    LeaveCriticalSection(&sDMDLCriticalSection);
}

//////////////////////////////////////////////////////////////////////
// Internal

void CDirectMusicPortDownload::ClearDLSFeatures()

{
    m_DLSFeatureList.Clear();
}

STDMETHODIMP
CDirectMusicPortDownload::QueryDLSFeature(REFGUID rguidID, long *plResult)

{
    *plResult = 0;      // Set to 0, which is the default for when the GUID is not supported.
    CDLSFeature *pFeature = m_DLSFeatureList.GetHead();
    for (;pFeature;pFeature = pFeature->GetNext())
    {
        if (rguidID == pFeature->m_guidID)
        {
            *plResult = pFeature->m_lResult;
            return pFeature->m_hr;
        }
    }
    IKsControl *pControl;
    HRESULT hr = QueryInterface(IID_IKsControl, (void**)&pControl);
    if (SUCCEEDED(hr))
    {
        KSPROPERTY ksp;
        ULONG cb;

        ZeroMemory(&ksp, sizeof(ksp));
        ksp.Set   = rguidID;
        ksp.Id    = 0;
        ksp.Flags = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                             sizeof(ksp),
                             (LPVOID)plResult,
                             sizeof(*plResult),
                             &cb);
        pControl->Release();
        pFeature = new CDLSFeature;
        if (pFeature)
        {
            pFeature->m_hr = hr;
            pFeature->m_guidID = rguidID;
            pFeature->m_lResult = *plResult;
            m_DLSFeatureList.AddHead(pFeature);
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::DownloadP

STDMETHODIMP
CDirectMusicPortDownload::DownloadP(IDirectMusicInstrument* pInstrument,
                                    IDirectMusicDownloadedInstrument** ppDownloadedInstrument,
                                    DMUS_NOTERANGE* pNoteRanges,
                                    DWORD dwNumNoteRanges,
                                    BOOL fVersion2)
{
#ifdef DBG
    // Argument validation
    // We only want to do this in a DEBUG build since whoever calls us needs to do 
    // the RELEASE build validation
    V_INAME(IDirectMusicPortDownload::DownloadP);
    V_PTR_READ(pInstrument, IDirectMusicInstrument); 
    V_PTRPTR_WRITE(ppDownloadedInstrument);
    V_BUFPTR_READ(pNoteRanges, (dwNumNoteRanges * sizeof(DMUS_NOTERANGE)));
#endif

    // If you can QI pInstrument for private interface IDirectMusicInstrumentPrivate 
    // pInstrument is of type CInstrument.
    IDirectMusicInstrumentPrivate* pDMIP = NULL;
    HRESULT hr = pInstrument->QueryInterface(IID_IDirectMusicInstrumentPrivate, (void **)&pDMIP);

    if (FAILED(hr))
    {
        return hr;
    }

    pDMIP->Release();

    EnterCriticalSection(&m_CDMDLCriticalSection);

    hr = GetCachedAppend(&m_dwAppend);
    if (FAILED(hr))
    {
        LeaveCriticalSection(&m_CDMDLCriticalSection);
        return hr;
    }

    if (m_fNewFormat == NEWFORMAT_NOT_RETRIEVED)
    {
        QueryDLSFeature(GUID_DMUS_PROP_INSTRUMENT2,(long *) &m_fNewFormat);
    }

    CInstrument *pCInstrument = (CInstrument *)pInstrument;

    // Get number of waves in an instrument
    DWORD dwCount;
    hr = pCInstrument->GetWaveCount(&dwCount);

    // Get Download ID's for each wave in instrument
    DWORD* pdwWaveIds = NULL;   
    if (SUCCEEDED(hr))
    {
        pdwWaveIds = new DWORD[dwCount];
        if (pdwWaveIds)
        {
            hr = pCInstrument->GetWaveDLIDs(pdwWaveIds);
        }
        else
        {
            hr = E_OUTOFMEMORY;             
        }
    }

    // Get DownloadedInstrument object
    CDownloadedInstrument* pDMDLInst = NULL;
    IDirectMusicPort* pIDMPort = NULL;
    DWORD dwDLId = pCInstrument->GetInstrumentDLID();
    BOOL fInstrumentNeedsDownload = FALSE;
    if (SUCCEEDED(hr))
    {
        hr = QueryInterface(IID_IDirectMusicPort, (void **)&pIDMPort);
        
        if (SUCCEEDED(hr))
        {
            hr = FindDownloadedInstrument(dwDLId, &pDMDLInst);

            if (!pDMDLInst && SUCCEEDED(hr))
            {
                fInstrumentNeedsDownload = TRUE;
                pDMDLInst = new CDownloadedInstrument;

                if (pDMDLInst)
                {       
                    // Allocate an IDirectMusicDownload pointer for each wave and one for the instrument
                    pDMDLInst->m_ppDownloadedBuffers = new IDirectMusicDownload*[dwCount + 1];
                    if (pDMDLInst->m_ppDownloadedBuffers)
                    {
                        pDMDLInst->m_dwDLTotal = dwCount + 1;
                        memset(pDMDLInst->m_ppDownloadedBuffers, 0, pDMDLInst->m_dwDLTotal * sizeof(IDirectMusicDownload*));
                        pDMDLInst->m_pPort = pIDMPort;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        pDMDLInst->Release(); 
                        pDMDLInst = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // don't let DMDLInst hold a refcnt on the port so we can final-release the port if the app
            //  misses a DMDLInst release
            pIDMPort->Release(); pIDMPort = NULL;
        }
    }
    
    DWORD dwSize;
    
    // Download the data for each wave if necessary
    if (SUCCEEDED(hr))
    {
        // First, make sure all conditional chunks are evaluated properly for this port.
        pCInstrument->SetPort(this, fVersion2);
        // All waves are already down?
        if (pDMDLInst->m_dwDLSoFar < dwCount) 
        {
            // Find out which waves need to be downloaded. 
            DWORD* pdwWaveRefs = NULL;  

            pdwWaveRefs = new DWORD[dwCount];
            if (pdwWaveRefs)
            {
                DWORD dwWaveIndex;
                hr = GetWaveRefs(&pDMDLInst->m_ppDownloadedBuffers[1], 
                    pdwWaveRefs, pdwWaveIds, dwCount, 
                    pCInstrument, pNoteRanges, dwNumNoteRanges);
                for(dwWaveIndex = 0; dwWaveIndex < dwCount && SUCCEEDED(hr); dwWaveIndex++)
                {
                    if (!pdwWaveRefs[dwWaveIndex] || pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1])
                    {
                        continue;
                    }
            
                    // Determine if we need to download the wave
                    IDirectMusicDownload* pDMDownload = NULL;

                    hr = GetBufferInternal(pdwWaveIds[dwWaveIndex], &pDMDownload);

                    // If NULL not downloaded so we need to download
                    if (pDMDownload == NULL && hr == DMUS_E_NOT_DOWNLOADED_TO_PORT)
                    {
				        DWORD dwSampleSize;	// Bit size of wave data.
                        hr = pCInstrument->GetWaveSize(pdwWaveIds[dwWaveIndex], &dwSize, &dwSampleSize);
                        if (SUCCEEDED(hr))
                        {
                            dwSize += (m_dwAppend * (dwSampleSize / 8));

                            hr = AllocateBuffer(dwSize, &pDMDownload);
                            if (SUCCEEDED(hr))
                            {
                                hr = pCInstrument->GetWave(pdwWaveIds[dwWaveIndex], pDMDownload);
#ifdef DMUS_GEN_INS_DATA
                                if (SUCCEEDED(hr))
                                {
                                    writewave(pDMDownload, pdwWaveIds[dwWaveIndex]);
                                }
#endif
                            }

                            if (SUCCEEDED(hr))
                            {
                                hr = Download(pDMDownload);
                            }

                            if (SUCCEEDED(hr))
                            {
                                pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] = pDMDownload;
                                pDMDLInst->m_dwDLSoFar++;  
                                fInstrumentNeedsDownload = TRUE;
                            }

                            if (FAILED(hr) && pDMDownload != NULL)
                            {
                                pDMDownload->Release();
                                pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] = NULL;
                            }
                        }
                    }
                    else if (SUCCEEDED(hr))
                    {
                        if (pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] == NULL)
                        {
                            ((CDownloadBuffer*)pDMDownload)->IncDownloadCount();
                            pDMDLInst->m_ppDownloadedBuffers[dwWaveIndex + 1] = pDMDownload;
                            pDMDLInst->m_dwDLSoFar++;
                        }
                        else
                        {
                            pDMDownload->Release(); // for being found
                            pDMDownload = NULL;
                        }
                    }
                }
                delete [] pdwWaveRefs;
            }
            else
            {
                hr = E_OUTOFMEMORY;             
            }
        }
    }

    // Download instrument data
    if (SUCCEEDED(hr))
    {
        // Determine if we need to downloaded the instrument
        if (fInstrumentNeedsDownload)
        {
            // First, get the old download, if it exists (this should be the case
            // when an instrument needs to be updated because more waves were downloaded.)
            IDirectMusicDownload* pDMOldDownload = NULL;
            GetBufferInternal(dwDLId, &pDMOldDownload);

            hr = pCInstrument->GetInstrumentSize(&dwSize);
        
            IDirectMusicDownload* pDMNewDownload = NULL;
        
            if (SUCCEEDED(hr))
            {
                hr = AllocateBuffer(dwSize, &pDMNewDownload);
                if (SUCCEEDED(hr))
                {
                    hr = pCInstrument->GetInstrument(pDMNewDownload);
#ifdef DMUS_GEN_INS_DATA                        
                    if (SUCCEEDED(hr))
                    {
                        writeinstrument(pDMNewDownload, dwDLId);
                    }
#endif
                }
            
                if (SUCCEEDED(hr))
                {
                    hr = Download(pDMNewDownload);
                }
            
                if (SUCCEEDED(hr))
                {
                    pDMDLInst->m_ppDownloadedBuffers[0] = pDMNewDownload;
                }

                if (FAILED(hr) && pDMNewDownload != NULL)
                {
                    pDMNewDownload->Release();
                    pDMDLInst->m_ppDownloadedBuffers[0] = NULL;
                }
            }
        
            if (pDMOldDownload)
            {
                Unload(pDMOldDownload);
                pDMOldDownload->Release(); // for being found
                pDMOldDownload->Release(); // to destroy
                pDMOldDownload = NULL;
            }
        }
    }

    delete [] pdwWaveIds;

    if (FAILED(hr))
    {
        if (pDMDLInst)
        {
            if (!pDMDLInst->m_cDLRef)
            {
                CDownloadBuffer* pDMDL = NULL;

                for(DWORD i = 0; i < pDMDLInst->m_dwDLTotal; i++)
                {   
                    pDMDL = (CDownloadBuffer*)(pDMDLInst->m_ppDownloadedBuffers[i]);
        
                    if(pDMDL)
                    {
                        Unload((IDirectMusicDownload*)pDMDL);
                        pDMDL->Release();
                    }
                }   

                delete [] (pDMDLInst->m_ppDownloadedBuffers);
                pDMDLInst->m_ppDownloadedBuffers = NULL;
            }

            pDMDLInst->Release();
        }
    }
    else
    {
        if (!pDMDLInst->m_cDLRef)
        {
            hr = AddDownloadedInstrument(pDMDLInst);
        }

        pDMDLInst->m_cDLRef++;
        *ppDownloadedInstrument = pDMDLInst;
    }

    LeaveCriticalSection(&m_CDMDLCriticalSection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::UnloadP

STDMETHODIMP
CDirectMusicPortDownload::UnloadP(IDirectMusicDownloadedInstrument* pDownloadedInstrument)
{
#ifdef DBG
    // Argument validation
    // We only want to do this in a DEBUG build since whoever calls us needs to do 
    // the RELEASE build validation
    V_INAME(IDirectMusicPortDownload::UnloadP);
    V_PTR_READ(pDownloadedInstrument, IDirectMusicDownloadedInstrument); 
#endif

    // If you can QI pDownloadedInstrument for private interface IDirectMusicDownloadedInstrumentPrivate 
    // pDownloadedInstrument is of type CDownloadedInstrument.
    IDirectMusicDownloadedInstrumentPrivate* pDMDIP = NULL;
    HRESULT hr = pDownloadedInstrument->QueryInterface(IID_IDirectMusicDownloadedInstrumentPrivate, (void **)&pDMDIP);

    if(FAILED(hr))
    {
        return hr;
    }

    pDMDIP->Release();

    CDownloadedInstrument* pDMDLInst = (CDownloadedInstrument *)pDownloadedInstrument;

    IDirectMusicPort* pIDMP = NULL;
        
    QueryInterface(IID_IDirectMusicPort, (void **)&pIDMP);
    
    // Make sure we are downloaded to this port and that we have not been previously unloaded
    // If pDMDLInst->m_ppDownloadedBuffers == NULL we may have been downloadeded to this port but are no longer
    if(pDMDLInst->m_pPort != pIDMP || pDMDLInst->m_ppDownloadedBuffers == NULL)
    {
        pIDMP->Release();
        return DMUS_E_NOT_DOWNLOADED_TO_PORT;
    }
    
    pIDMP->Release();

    EnterCriticalSection(&m_CDMDLCriticalSection);

    if (pDMDLInst->m_cDLRef && --pDMDLInst->m_cDLRef == 0)
    {
        CDownloadBuffer* pDMDL = NULL;

        for(DWORD i = 0; i < pDMDLInst->m_dwDLTotal; i++)
        {   
            pDMDL = (CDownloadBuffer*)(pDMDLInst->m_ppDownloadedBuffers[i]);
        
            if(pDMDL)
            {
                Unload((IDirectMusicDownload*)pDMDL);
                pDMDL->Release();
            }
        }   

        delete [] (pDMDLInst->m_ppDownloadedBuffers);
        pDMDLInst->m_ppDownloadedBuffers = NULL;
        RemoveDownloadedInstrument(pDMDLInst);
    }
    else
    {
        hr = S_FALSE;
    }

    LeaveCriticalSection(&m_CDMDLCriticalSection);

    return hr;
}



//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetWaveRefs

STDMETHODIMP
CDirectMusicPortDownload::GetWaveRefs(IDirectMusicDownload* ppDownloadedBuffers[],
                                      DWORD* pdwWaveRefs,
                                      DWORD* pdwWaveIds,
                                      DWORD dwNumWaves,
                                      CInstrument* pCInstrument,
                                      DMUS_NOTERANGE* pNoteRanges,
                                      DWORD dwNumNoteRanges)
{
    assert(pdwWaveRefs);
    assert(ppDownloadedBuffers);
    assert(pCInstrument);
    assert(dwNumNoteRanges ? (pNoteRanges != NULL) : TRUE);

    memset(pdwWaveRefs, 0, dwNumWaves * sizeof(DWORD));

    // Get number of waves in an instrument
    DWORD dwCount;
    if (FAILED(pCInstrument->GetWaveCount(&dwCount)))
    {
        return E_UNEXPECTED;
    }

    if (dwCount != dwNumWaves)
    {
        return E_INVALIDARG;
    }

    CInstrObj *pInstObj = pCInstrument->m_pInstrObj;
    
    if (pInstObj)
    {
        if (pInstObj->m_fHasConditionals || dwNumNoteRanges)
        {
            CRegion *pRegion = pInstObj->m_RegionList.GetHead();
            DWORD dwWaveIdx;
            for (dwWaveIdx = 0; dwWaveIdx < dwNumWaves; dwWaveIdx++)
            {
                // Check if the wave is already downloaded.
                if (!ppDownloadedBuffers[dwWaveIdx])
                {
                    // We always scan forward through the regions, since they are in the same order as the array.
                    for (;pRegion;pRegion = pRegion->GetNext())
                    {
                        // Does this region point to the next wave? If not, it must be a duplicate.
                        if (pRegion->m_WaveLink.ulTableIndex == pdwWaveIds[dwWaveIdx])
                        {
                            // Conditional chunk allow download?
                            if (pRegion->m_Condition.m_fOkayToDownload)
                            {
                                // Verify against note ranges.
                                if (dwNumNoteRanges)
                                {
                                    DWORD dwLowNote = DWORD(pRegion->m_RgnHeader.RangeKey.usLow);
                                    DWORD dwHighNote = DWORD(pRegion->m_RgnHeader.RangeKey.usHigh);

                                    for (DWORD dwNRIdx = 0; dwNRIdx < dwNumNoteRanges; dwNRIdx++)
                                    {
                                        if (dwHighNote < pNoteRanges[dwNRIdx].dwLowNote ||
                                            dwLowNote > pNoteRanges[dwNRIdx].dwHighNote)
                                        {
                                            continue;
                                        }
                                        else
                                        {
                                            pdwWaveRefs[dwWaveIdx]++;
                                            break;
                                        }
                                    }
                                }
                                else
                                {
                                    pdwWaveRefs[dwWaveIdx]++;
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwNumWaves; dwIndex++)
            {
                if (!ppDownloadedBuffers[dwIndex])
                {
                    pdwWaveRefs[dwIndex]++;
                }
            }
        }
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::FindDownloadedInstrument

STDMETHODIMP
CDirectMusicPortDownload::FindDownloadedInstrument(DWORD dwId,
                                                   CDownloadedInstrument** ppDMDLInst)
{
    assert(ppDMDLInst);

    HRESULT hr = S_FALSE;

    for (CDownloadedInstrument* pDMDLInst = m_DLInstrumentList.GetHead();
        pDMDLInst; pDMDLInst = pDMDLInst->GetNext())
    {
        IDirectMusicDownload* pDMDownload = pDMDLInst->m_ppDownloadedBuffers[0];
        
        if (pDMDownload && ((CDownloadBuffer*)pDMDownload)->m_dwDLId == dwId)
        {
            *ppDMDLInst = pDMDLInst;
            (*ppDMDLInst)->AddRef();
            hr = S_OK;
            break;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AddDownloadedInstrument

STDMETHODIMP
CDirectMusicPortDownload::AddDownloadedInstrument(CDownloadedInstrument* pDMDLInst)
{
    assert(pDMDLInst);

    m_DLInstrumentList.AddTail(pDMDLInst);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::RemoveDownloadedInstrument

STDMETHODIMP
CDirectMusicPortDownload::RemoveDownloadedInstrument(CDownloadedInstrument* pDMDLInst)
{
    assert(pDMDLInst);

    m_DLInstrumentList.Remove(pDMDLInst);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::FreeBuffer

STDMETHODIMP
CDirectMusicPortDownload::FreeBuffer(IDirectMusicDownload* pIDMDownload)                                       
{
    // Argument validation
    assert(pIDMDownload);

    void* pvBuffer = NULL; 

    // If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
    // pIDMDownload is of type CDownloadBuffer.
    IDirectMusicDownloadPrivate* pDMDLP = NULL;
    HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

    if(SUCCEEDED(hr))
    {
        pDMDLP->Release();
        
        hr = ((CDownloadBuffer*)pIDMDownload)->IsDownloaded();
        
        if(hr != S_FALSE)
        {
            return DMUS_E_BUFFERNOTAVAILABLE;
        }

        DWORD dwSize;
        hr = ((CDownloadBuffer*)pIDMDownload)->GetHeader(&pvBuffer, &dwSize);
    }

    if(SUCCEEDED(hr))
    {
        hr = ((CDownloadBuffer*)pIDMDownload)->SetBuffer(NULL, 0, 0);
        delete [] pvBuffer;
    }

    return hr;
}

#ifdef DMUS_GEN_INS_DATA
void writewave(IDirectMusicDownload* pDMDownload, DWORD dwId)
{
    DWORD dwSize = 0;
    void* pvBuffer = NULL;
    HRESULT hr = pDMDownload->GetBufferInternal(&pvBuffer, &dwSize);

    HANDLE hfw = NULL;
    if(SUCCEEDED(hr))
    {
        char filename[1024];
        wsprintf(filename, "%s%d%s", "d:\\InstrumentData\\wavedata", dwId, ".dat");
        hfw = CreateFile(filename,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    }

    if(pvBuffer && hfw != INVALID_HANDLE_VALUE)
    {

        DWORD w;
        BOOL b = WriteFile(hfw, 
                           ((BYTE *)pvBuffer),
                           dwSize,
                           &w,
                           NULL);
    }

    CloseHandle(hfw);
}

void writeinstrument(IDirectMusicDownload* pDMDownload, DWORD dwId)
{
    DWORD dwSize = 0;
    void* pvBuffer = NULL;
    HANDLE hfi = NULL;
    HRESULT hr = pDMDownload->GetBufferinternal(&pvBuffer, &dwSize);
    
    if(SUCCEEDED(hr))
    {
        char filename[1024];
        wsprintf(filename, "%s%d%s", "d:\\InstrumentData\\instrumentdata", dwId, ".dat");
        hfi = CreateFile(filename,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    }

    if(pvBuffer && hfi != INVALID_HANDLE_VALUE)
    {

        DWORD w;
        BOOL b = WriteFile(hfi, 
                           ((BYTE *)pvBuffer),
                           dwSize,
                           &w,
                           NULL);
    }
    
    CloseHandle(hfi);
}
#endif // #ifdef DMUS_GEN_INS_DATA

//#############################################################################
//
// Wave object support after this
//
//
//#############################################################################

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::DownloadWaveP
//
// This function supports the DownloadWave method on IDirectMusicPort.
// It is not related directly to DLS functionality, but rather to
// downloading oneshot and streaming waves from an IDirectSoundWave.
//
// rtStart is not the starting time on the master clock, but rather
// the offset within the stream (if this is a stream).
//

STDMETHODIMP 
CDirectMusicPortDownload::DownloadWaveP(IDirectSoundWave *pIDSWave,               
                                        IDirectSoundDownloadedWaveP **ppWave,
                                        REFERENCE_TIME rtStartHint)
{
    HRESULT                     hr = S_OK;
    CDirectSoundWave            *pDSWave = NULL;
    BOOL                        fIsStreaming = FALSE;
    BOOL                        fUseNoPreRoll = FALSE;
    REFERENCE_TIME              rtReadAhead = 0;
    DWORD                       dwFlags = 0;

    hr = pIDSWave->GetStreamingParms(&dwFlags, &rtReadAhead);
    fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
    fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;

    EnterCriticalSection(&m_CDMDLCriticalSection);
    
    // See if there is already a CDirectSoundWave object
    // wrapping this interface
    //
    if (SUCCEEDED(hr))
    {
        TraceI(2, "DownloadWaveP: Got interface %p\n", pIDSWave);
        
        // We want to download streaming waves everytime
        if(fIsStreaming == FALSE)
        {
            pDSWave = CDirectSoundWave::GetMatchingDSWave(pIDSWave);
        }
    
        if (pDSWave == NULL) 
        {
            TraceI(2, "Hmmmm. nope, haven't seen that before.\n");
            // This object has not been seen before. Wrap it.
            //
            pDSWave = new CDirectSoundWave(
                pIDSWave, 
                fIsStreaming ? true : false,
                rtReadAhead,
                fUseNoPreRoll ? true : false,
                rtStartHint);
            hr = HRFromP(pDSWave);

            if (SUCCEEDED(hr))
            {
                hr = pDSWave->Init(this);
                if (FAILED(hr))
                {
                    delete pDSWave;
                    pDSWave = NULL;
                }
            }
        }
        else 
        {
            TraceI(2, "Found download %p\n", pDSWave);
        }
    }

    // Download wave data if needed. This will do nothing on streaming waves.
    //
    if (SUCCEEDED(hr))
    {
        hr = pDSWave->Download();
    }

    if (SUCCEEDED(hr))
    {
        assert(pDSWave);
        hr = pDSWave->QueryInterface(IID_IDirectSoundDownloadedWaveP, (void**)ppWave);
    }

    if (FAILED(hr) && pDSWave)
    {
        // Something failed, unload anything we downloaded.
        //
        pDSWave->Unload();
    }

    RELEASE(pDSWave);

    LeaveCriticalSection(&m_CDMDLCriticalSection);

    return hr;
}    

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::UnloadWaveP
//
STDMETHODIMP
CDirectMusicPortDownload::UnloadWaveP(IDirectSoundDownloadedWaveP *pWave)
{
    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(pWave);

    // XXX Stop playing voices?
    //
    HRESULT hr = pDSWave->Unload();
	if (SUCCEEDED(hr))
	{
		hr = pDSWave->Release();
	}
    
    return hr;    
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::AllocVoice
//
// Voice management is neccessarily very tied to download management,
// so it makes sense for the download manager to dole out voices.
// 
// Methods on IDirectMusicPortPrivate are used to contain the port-
// specific code to do things like play.
//
STDMETHODIMP
CDirectMusicPortDownload::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,          // Wave to play on this voice
    DWORD dwChannel,                            // Channel and channel group
    DWORD dwChannelGroup,                       //  this voice will play on
    REFERENCE_TIME rtStart,                     // Where to start (stream only)
    SAMPLE_TIME stLoopStart,                    // Loop start and end
    SAMPLE_TIME stLoopEnd,                      //  (one shot only)
    IDirectMusicVoiceP **ppVoice                 // Returned voice
)
{
    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(pWave);

    HRESULT hr;
    CDirectMusicVoice *pVoice;

    IDirectMusicPort *pPort;
    hr = QueryInterface(IID_IDirectMusicPort, (void**)&pPort);

    if (SUCCEEDED(hr))
    {
        pVoice = new CDirectMusicVoice(
            this, 
            pWave,
            dwChannel,
            dwChannelGroup,
            rtStart, 
            pDSWave->GetReadAhead(),
            stLoopStart,
            stLoopEnd);

        hr = HRFromP(pVoice);

        pPort->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = pVoice->Init();
    }

    if (SUCCEEDED(hr))
    {
        *ppVoice = static_cast<IDirectMusicVoiceP*>(pVoice);
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicPortDownload::GetCachedAppend
//
STDMETHODIMP
CDirectMusicPortDownload::GetCachedAppend(DWORD *pdw)
{
    HRESULT                 hr = S_OK;

    if (m_dwAppend == APPEND_NOT_RETRIEVED)
    {
        hr = GetAppend(&m_dwAppend);
    }

    *pdw = m_dwAppend;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dminstru.h ===
//
// dminstru.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn 
//
// @doc EXTERNAL
//

#ifndef DMINSTRU_H
#define DMINSTRU_H

class CCollection;
class CInstrObj;

#include "alist.h"
#include "dmwavobj.h"
#include "dminsobj.h"

// IDirectMusicInstrumentPrivate
//

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrumentPrivate 
DECLARE_INTERFACE_(IDirectMusicInstrumentPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	// IDirectMusicInstrumentPrivate
	// No methods at this time
};

DEFINE_GUID(IID_IDirectMusicInstrumentPrivate, 0xbcb20080, 0xa40c, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

/*
@interface IDirectMusicInstrument | 
<i IDirectMusicInstrument> manages downloading
an individual instrument from a DLS collection 
(<i IDirectMusicCollection>.)

@comm 
The only way to create an <i IDirectMusicInstrument> for
downloading is to first open an <i IDirectMusicCollection>,
then call <om IDirectMusicCollection::GetInstrument>
to get the requested instrument.

To download an instrument, pass it to <om IDirectMusicPort::Download>,
which, if successful, returns a pointer to an
<i IDirectMusicDownloadedInstrument> interface. 
The <i IDirectMusicDownloadedInstrument> interface is
used only to unload the instrument.

@base public | IUnknown

@meth HRESULT | GetPatch | Returns the patch number of the instrument.
@meth HRESULT | SetPatch | Assign a new patch number to the instrument.

@xref <i IDirectMusicCollection>, <i IDirectMusicPort>,
<i IDirectMusicDownloadedInstrument>, 
<om IDirectMusicCollection::GetInstrument>,
<om IDirectMusicPort::DownloadInstrument>,
<om IDirectMusicPerformance::DownloadInstrument>

@ex Access an instrument from a collection and download it. In addition,
set a range of notes within the instrument to download. This is not
required, but it can improve efficiency because only the waves needed
to render the specified range are downloaded to the synth. | 

	HRESULT myDownload(
		IDirectMusicCollection *pCollection,		// DLS collection.
		IDirectMusicPort *pPort,					// Port to download to.
		IDirectMusicDownloadedInstrument **ppDLInstrument, // Returned.
		DWORD dwPatch,								// Requested instrument.				
		DWORD dwLowNote,							// Low note of range.
		DWORD dwHighNote)							// High note of range.

	{
		HRESULT hr;
		IDirectMusicInstrument* pInstrument;
		hr = pCollection->GetInstrument(dwPatch, &pInstrument);
		if (SUCCEEDED(hr))
		{
			DMUS_NOTERANGE NoteRange[1]; // Optional note range.
			NoteRange[0].dwLowNote = dwLowNote;
			NoteRange[0].dwHighNote = dwHighNote;
			hr = pPort->DownloadInstrument(pInstrument, ppDLInstrument, NoteRange, 1);
			pInstrument->Release();
		}
		return hr;
	}
*/


class CInstrument : public IDirectMusicInstrument, public IDirectMusicInstrumentPrivate, public AListItem
{
friend class CCollection;
friend class CDirectMusicPortDownload;

public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDirectMusicInstrument
	STDMETHODIMP GetPatch(DWORD* pdwPatch);
	STDMETHODIMP SetPatch(DWORD dwPatch);

private:
    // Class
    //
    CInstrument();
    ~CInstrument();

    CInstrument* GetNext() {return (CInstrument*)AListItem::GetNext();}

	HRESULT Init(DWORD dwPatch, 
				 CCollection* pParentCollection);

	HRESULT GetWaveCount(DWORD* pdwCount);
	HRESULT GetWaveDLIDs(DWORD* pdwIds);
	HRESULT GetWaveSize(DWORD dwId, DWORD* pdwSize, DWORD * pdwSampleSize);
	HRESULT GetWave(DWORD dwDLId, IDirectMusicDownload* pIDMDownload);
    void SetPort(CDirectMusicPortDownload *pPort, BOOL fAllowDLS2);
	HRESULT GetInstrumentSize(DWORD* pdwSize);
	HRESULT GetInstrument(IDirectMusicDownload* pIDMDownload);
	
	DWORD GetInstrumentDLID()
	{
		if(m_dwId != -1)
		{
			return m_dwId;
		}
		else
		{
			return m_pInstrObj->m_dwId;		
		}
	}
	
	void Cleanup();


private:
	CRITICAL_SECTION				m_DMICriticalSection;
	DWORD                           m_dwOriginalPatch;
    DWORD                           m_dwPatch;
	CCollection*			        m_pParentCollection;
	CInstrObj*						m_pInstrObj;
	CWaveObjList					m_WaveObjList;
	bool							m_bInited;
	DWORD							m_dwId;
	long							m_cRef;
};

class CInstrumentList : public AList
{
friend class CCollection;

private:
    CInstrumentList(){}
    ~CInstrumentList() 
    {
        while (!IsEmpty())
        {
            CInstrument* pInstrument = RemoveHead();
            if (pInstrument)
            {
                pInstrument->Release();
            }
        }
    }

    CInstrument* GetHead(){return (CInstrument*)AList::GetHead();}
    CInstrument* GetItem(LONG lIndex){return (CInstrument*)AList::GetItem(lIndex);}
    CInstrument* RemoveHead(){return (CInstrument*)AList::RemoveHead();}
    void Remove(CInstrument* pInstrument){AList::Remove((AListItem*)pInstrument);}
    void AddTail(CInstrument* pInstrument){AList::AddTail((AListItem*)pInstrument);}
};

#endif // #ifndef DMINSTRU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmregion.cpp ===
//
// dmregion.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include "dmusicp.h"
#include "alist.h"
#include "dlsstrm.h"
#include "debug.h"
#include "dmart.h"
#include "debug.h"
#include "dmcollec.h"
#include "dmregion.h"
#include "dls2.h"

//////////////////////////////////////////////////////////////////////
// Class CRegion

//////////////////////////////////////////////////////////////////////
// CRegion::CRegion

CRegion::CRegion()
{
    m_dwCountExtChk = 0;
    m_fDLS1 = TRUE;
    m_fNewFormat = FALSE;
    m_fCSInitialized = FALSE;
//	InitializeCriticalSection(&m_DMRegionCriticalSection);
    m_fCSInitialized = TRUE;
	
	ZeroMemory(&m_RgnHeader, sizeof(m_RgnHeader));
	ZeroMemory(&m_WaveLink, sizeof(m_WaveLink));
	ZeroMemory(&m_WSMP, sizeof(m_WSMP));
	ZeroMemory(&m_WLOOP, sizeof(m_WLOOP));
}

//////////////////////////////////////////////////////////////////////
// CRegion::~CRegion

CRegion::~CRegion() 
{
    if (m_fCSInitialized)
    {
    	Cleanup();
//	    DeleteCriticalSection(&m_DMRegionCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CRegion::Load

HRESULT CRegion::Load(CRiffParser *pParser)
{
    HRESULT hr = S_OK;

	RIFFIO ckNext;
    BOOL fDLS1;

//	EnterCriticalSection(&m_DMRegionCriticalSection);
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        fDLS1 = FALSE;
		switch(ckNext.ckid)
		{
        case FOURCC_CDL :
            hr = m_Condition.Load(pParser);
            break;
		case FOURCC_RGNH :
			hr = pParser->Read(&m_RgnHeader,sizeof(RGNHEADER));
			break;
		case FOURCC_WSMP :
			hr = pParser->Read(&m_WSMP, sizeof(WSMPL));
			if(m_WSMP.cSampleLoops)
			{
				hr = pParser->Read(m_WLOOP, sizeof(WLOOP));
			}
			break;
		case FOURCC_WLNK :
			hr = pParser->Read(&m_WaveLink,sizeof(WAVELINK));
			break;
		case FOURCC_LIST :
			switch (ckNext.fccType)
			{
            case FOURCC_LART :
                fDLS1 = TRUE;
            case FOURCC_LAR2 :
                CArticulation *pArticulation;
                                       
                try
                {
                    pArticulation = new CArticulation;
                }
                catch( ... )
                {
                    pArticulation = NULL;
                }

				if(pArticulation)
				{
                    pArticulation->m_fDLS1 = fDLS1;
					hr = pArticulation->Load(pParser);
                    m_ArticulationList.AddHead(pArticulation); 
				}
				else
				{
					hr =  E_OUTOFMEMORY;
				}
				
				break;

    		default:
				// If we get here we have an unknown chunk
				CExtensionChunk* pExtensionChunk = new CExtensionChunk;
				if(pExtensionChunk)
				{
					hr = pExtensionChunk->Load(pParser);
                    m_ExtensionChunkList.AddHead(pExtensionChunk);								
					m_dwCountExtChk++;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
				break;
			}
			break;

		default:
			// If we get here we have an unknown chunk
			CExtensionChunk* pExtensionChunk = new CExtensionChunk;
			if(pExtensionChunk)
			{
				hr = pExtensionChunk->Load(pParser);
                m_ExtensionChunkList.AddHead(pExtensionChunk);								
				m_dwCountExtChk++;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
			break;
		}
	}
    pParser->LeaveList();
	if(FAILED(hr))
	{
		Cleanup();
	}
//	LeaveCriticalSection(&m_DMRegionCriticalSection);

	return hr; 
}	

//////////////////////////////////////////////////////////////////////
// CRegion::Cleanup

void CRegion::Cleanup()
{
//	EnterCriticalSection(&m_DMRegionCriticalSection);
	
    while(!m_ArticulationList.IsEmpty())
	{
		CArticulation* pArticulation = m_ArticulationList.RemoveHead();
		delete pArticulation;
	}

	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		delete pExtChk;
	}
	
//	LeaveCriticalSection(&m_DMRegionCriticalSection);
}

DWORD CRegion::Count()

{
	// Return the number of Offset Table entries needed during a call to Write
    if (m_Condition.m_fOkayToDownload)
    {
        DWORD dwCount = m_dwCountExtChk + 1;
        CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation)
        {
            while (pArticulation && (pArticulation->Count() == 0))
            {
                pArticulation = pArticulation->GetNext();
            }
            if (pArticulation)
            {
                dwCount += pArticulation->Count();
                if (m_fNewFormat)
                {
                    pArticulation = pArticulation->GetNext();
                }
                else
                {
                    break;
                }
            }
        }
        return dwCount;
    }
    return 0;
}


void CRegion::SetPort(CDirectMusicPortDownload *pPort, BOOL fNewFormat, BOOL fSupportsDLS2)

{
    m_fNewFormat = fNewFormat;
    if (fSupportsDLS2)
    {
        m_Condition.Evaluate(pPort);
    }
    else
    {
        m_Condition.m_fOkayToDownload = m_fDLS1;
    }
    if (m_Condition.m_fOkayToDownload)
    {
 	    CArticulation *pArticulation = m_ArticulationList.GetHead();
        for (;pArticulation;pArticulation = pArticulation->GetNext())
        {
            pArticulation->SetPort(pPort,fNewFormat,fSupportsDLS2);
	    }
    }
}

BOOL CRegion::CheckForConditionals()

{
    BOOL fHasConditionals = FALSE;
 	CArticulation *pArticulation = m_ArticulationList.GetHead();
    for (;pArticulation;pArticulation = pArticulation->GetNext())
    {
        fHasConditionals = fHasConditionals || pArticulation->CheckForConditionals();
	}
    return fHasConditionals || !m_fDLS1 || m_Condition.HasChunk();
}

//////////////////////////////////////////////////////////////////////
// CRegion::Size

DWORD CRegion::Size()
{
	DWORD dwSize = 0;
	DWORD dwCountExtChk = 0;

    if (!m_Condition.m_fOkayToDownload)
    {
        return 0;
    }

//    EnterCriticalSection(&m_DMRegionCriticalSection);

	dwSize += CHUNK_ALIGN(sizeof(DMUS_REGION));

	// Calculate the space need for Region's articulation
	CArticulation *pArticulation = m_ArticulationList.GetHead();
    while (pArticulation)
    {
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        if (pArticulation)
        {
		    dwSize += pArticulation->Size();
            if (m_fNewFormat)
            {
                pArticulation = pArticulation->GetNext();
            }
            else
            {
                break;
            }
        }
	}

	// Calculate the space need for Region's extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
		dwSize += pExtChk->Size();
		dwCountExtChk++;
	}

	// We want to validate the number of extension chunks
	if(m_dwCountExtChk != dwCountExtChk)
	{
		assert(false);
		dwSize = 0;
	}

//	LeaveCriticalSection(&m_DMRegionCriticalSection);
	
	return dwSize;
}

//////////////////////////////////////////////////////////////////////
// CRegion::Write

HRESULT CRegion::Write(void* pv, 
					   DWORD* pdwCurOffset, 
					   DWORD* pDMIOffsetTable, 
					   DWORD* pdwCurIndex, 
					   DWORD dwIndexNextRegion)
{
	HRESULT hr = S_OK;

	// Argument validation - Debug
	assert(pv);
	assert(pdwCurOffset);
	assert(pDMIOffsetTable);
	assert(pdwCurIndex);

    if (!m_Condition.m_fOkayToDownload)
    {
        return S_OK;
    }

//    EnterCriticalSection(&m_DMRegionCriticalSection);

	CopyMemory(pv, (void *)&m_RgnHeader, sizeof(RGNHEADER));
	
	((DMUS_REGION*)pv)->WaveLink = m_WaveLink;
	((DMUS_REGION*)pv)->WSMP = m_WSMP;
	((DMUS_REGION*)pv)->WLOOP[0] = m_WLOOP[0];
	((DMUS_REGION*)pv)->ulNextRegionIdx = dwIndexNextRegion;

	*pdwCurOffset += CHUNK_ALIGN(sizeof(DMUS_REGION));
	DWORD dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_REGION));
	
	// Write extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	if(pExtChk)
	{
		DWORD dwCountExtChk = m_dwCountExtChk;
		DWORD dwIndexNextExtChk;
		((DMUS_REGION*)pv)->ulFirstExtCkIdx = dwIndexNextExtChk = *pdwCurIndex;
		
		for(; pExtChk && SUCCEEDED(hr) && dwCountExtChk > 0; pExtChk = pExtChk->GetNext())
		{
			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk = dwIndexNextExtChk + 1;
			}
			
			pDMIOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset; 
			hr = pExtChk->Write(((BYTE *)pv + dwRelativeCurOffset), 
								pdwCurOffset,
								dwIndexNextExtChk);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);
			dwCountExtChk--;
		}
	}
	else
	{
		// If no extension chunks set to zero
		((DMUS_REGION*)pv)->ulFirstExtCkIdx = 0;
	}
	
	if(SUCCEEDED(hr))
	{
        ((DMUS_REGION*)pv)->ulRegionArtIdx = 0;
		// Write region articulation if we have one
		CArticulation *pArticulation = m_ArticulationList.GetHead();
        while (pArticulation && (pArticulation->Count() == 0))
        {
            pArticulation = pArticulation->GetNext();
        }
        while (pArticulation)
		{
            DWORD dwNextArtIndex = 0;
            CArticulation *pNextArt = NULL;
            if (m_fNewFormat)
            {
                pNextArt = pArticulation->GetNext();
                while (pNextArt && (pNextArt->Count() == 0))
                {
                    pNextArt = pNextArt->GetNext();
                }
                if (pNextArt)
                {
                    dwNextArtIndex = *pdwCurIndex + pArticulation->Count();
                }
            }
            if (((DMUS_REGION*)pv)->ulRegionArtIdx == 0)
            {
                ((DMUS_REGION*)pv)->ulRegionArtIdx = *pdwCurIndex;
            }
			pDMIOffsetTable[(*pdwCurIndex)++] = *pdwCurOffset;
            // Store current position to calculate new dwRelativeCurOffset.
            DWORD dwOffsetStart = *pdwCurOffset; 
            hr = pArticulation->Write(((BYTE *)pv + dwRelativeCurOffset),
										pdwCurOffset,
										pDMIOffsetTable,
										pdwCurIndex,
                                        dwNextArtIndex);
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);
            pArticulation = pNextArt;
		}
	}

//	LeaveCriticalSection(&m_DMRegionCriticalSection);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmpcclk.cpp ===
//
// DMPcClk.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrapper for using clock from portclass as the DirectMusic master clock
// (Win9x only)
// 
//
#include <objbase.h>
#include <winerror.h>
#include <setupapi.h>
#include "dmusicp.h"
#include "suwrap.h"
#include "debug.h"
#include "resource.h"

// Since we only allocate one of these clocks in the entire system,
// this stuff is global.
//

// We have to be able to get the process id of someone with a handle to
// the clock. Since the original creator might go away before other users,
// we store the process id of everyone who uses the clock. This implies
// a max limit on concurrent processes using it.
//
#define MAX_CLOCK_SHARERS   64              // Max processes who can access clock   
                                            // at once.
typedef struct PCCLOCKSHARE
{
    LONG                cRef;               // Count of processes using handle

    struct 
    {
        HANDLE          hPcClock;           // This user's handle and
        DWORD           dwProcessId;        // process id
    } aUsers[MAX_CLOCK_SHARERS];

} *PPCCLOCKSHARE;

class CPcClock : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CPcClock();
    ~CPcClock();
    HRESULT Init();

private:
    long m_cRef;

    HRESULT CreatePcClockShared();
    void    DeletePcClockShared();
    HRESULT CreatePcClockHandle();
    HRESULT DuplicatePcClockHandle();

private:
    static const char m_cszPcClockMemory[];       // Name of shared memory object
    static const char m_cszPcClockMutex[];        // Name of mutex protecting shared memory

    static LONG m_lSharedMemoryInitialized;       // Has this process initialized shared memory?
    static HANDLE m_hFileMapping;                 // File mapping handle for shared memory
    static PPCCLOCKSHARE m_pShared;               // Pointer to shared memory
    static HANDLE m_hPcClockMutex;                // Mutex for shared memory access
    static HANDLE m_hClock;                       // Clock handle in this process
};

HRESULT CreatePcClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);
static BOOL LookForPortClock(PHANDLE phClock);

const char       CPcClock::m_cszPcClockMemory[] = "DirectMusiCPcClock";
const char       CPcClock::m_cszPcClockMutex[]  = "DirectMusiCPcClockMutex";

LONG             CPcClock::m_lSharedMemoryInitialized = 0;
HANDLE           CPcClock::m_hFileMapping = NULL;         
PPCCLOCKSHARE    CPcClock::m_pShared = NULL;        
HANDLE           CPcClock::m_hPcClockMutex = NULL;
HANDLE           CPcClock::m_hClock;                


// AddPcClocPc
//
// Add Pc clock to the list of clocPc.
//
HRESULT AddPcClocks(CMasterClock *pMasterClock)
{
    HANDLE hClock;

    // Make sure we can create a default Pc clock
    //
    DWORD ms = timeGetTime();
    if (!LookForPortClock(&hClock))
    {
        TraceI(1, "Could not create Pc clock\n");
        return S_FALSE;
    }
    TraceI(3, "LookForPortClock took %d\n", timeGetTime() - ms);

    CloseHandle(hClock);

    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce.cc);
    ce.cc.guidClock = GUID_SysClock;         
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.cc.dwFlags = DMUS_CLOCKF_GLOBAL;
    ce.pfnGetInstance = CreatePcClock;

    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_SYSTEMCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription) / sizeof(ce.cc.wszDescription[0]));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}

// CreatePcClock
//
// Return an IReferenceClock based on the one Pc clock in the system
//
HRESULT CreatePcClock(IReferenceClock **ppClock, CMasterClock *pMasterClock)
{
    TraceI(3, "Creating Pc clock\n");

    CPcClock *pClock = new CPcClock;

    if (pClock == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pClock->Init();
    if (FAILED(hr))
    {
        delete pClock;
        return hr;
    }

    hr = pClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
    pClock->Release();

    return hr;
}

// CPcClock::CPcClock()
//
// 
CPcClock::CPcClock() : 
    m_cRef(1)
{
}

// CPcClock::~CPcClock()
//
// 
CPcClock::~CPcClock()
{
    if (InterlockedDecrement(&m_lSharedMemoryInitialized) == 0)
    {
        DeletePcClockShared();        
    }
}

// CPcClock::QueryInterface
//
// Standard COM implementation
//
STDMETHODIMP CPcClock::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

// CPcClock::AddRef
// 
STDMETHODIMP_(ULONG) CPcClock::AddRef()
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

// CPcClock::Release
//
STDMETHODIMP_(ULONG) CPcClock::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CPcClock::Init
//
HRESULT CPcClock::Init()
{
    HRESULT hr;

    if (InterlockedIncrement(&m_lSharedMemoryInitialized) == 1)
    {
        hr = CreatePcClockShared();
        if (FAILED(hr))
        {
            return hr;
        }    
    }

    return S_OK;
}

// CPcClock::CreatePcClocPchared
//
// Initialize the shared memory object in this process.
// Make sure a handle to the Pc clock exists in this process.
//
HRESULT CPcClock::CreatePcClockShared()
{
    HRESULT hr;
    DWORD dwErr;

    // Create and take the mutex up front. This is neccesary to guarantee that if 
    // we are the first process in the system to create this object, then we do 
    // initialization before anyone else can access the shared memory object.
    //
    m_hPcClockMutex = CreateMutex(NULL,             // Default security descriptor
                                  FALSE,            // Own mutex if we are first instance
                                  m_cszPcClockMutex);
    if (m_hPcClockMutex == NULL)
    {
        TraceI(0, "CreateMutex failed! [%d]\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    WaitForSingleObject(m_hPcClockMutex, INFINITE);

    // Create the file mapping and view of the shared memory, noticing if we are the first 
    // object to create it.
    //
    m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,    // Use paging file
                                       NULL,                    // Default security descriptor
                                       PAGE_READWRITE,  
                                       0,                       // High DWORD of size
                                       sizeof(PCCLOCKSHARE),
                                       m_cszPcClockMemory);
    dwErr = GetLastError();
    if (m_hFileMapping == NULL)
    {
        ReleaseMutex(m_hPcClockMutex);
        
        return HRESULT_FROM_WIN32(dwErr);
    }    

    BOOL fFirst = (dwErr != ERROR_ALREADY_EXISTS);

    m_pShared = (PPCCLOCKSHARE)MapViewOfFile(m_hFileMapping,
                                             FILE_MAP_WRITE,
                                             0, 0,                // Start mapping at the beginning
                                             0);                  // Map entire file
    if (m_pShared == NULL)
    {
        TraceI(0, "MapViewOfFile failed! [%d]\n", GetLastError());

        ReleaseMutex(m_hPcClockMutex);
        return E_OUTOFMEMORY;
    }

    // Initialize the refernce count if we are the first process, and increment
    // it in any case. (Note we're still in the mutex, so we don't need 
    // InterlockedIncrement.
    //
    if (fFirst)
    {
        m_pShared->cRef = 0;
        ZeroMemory(m_pShared->aUsers, sizeof(m_pShared->aUsers));
    }
    ++m_pShared->cRef;

    // If the clock handle doesn't exist yet, create it; else duplicate it. 
    //
    if (m_pShared->cRef == 1)
    {
        hr = CreatePcClockHandle();
    }
    else
    {
        hr = DuplicatePcClockHandle();
    }

    // Release the mutex and return success or failure.
    //
    ReleaseMutex(m_hPcClockMutex);

    return hr;
}

// CPcClock::DeletePcClocPchared
//
// The last instance of CPcClock in this process is being deleted. 
//
void CPcClock::DeletePcClockShared()
{
    // If the mutex was never created, then none of the other objects could have
    // been created.
    //
    if (m_hPcClockMutex)
    {
        WaitForSingleObject(m_hPcClockMutex, INFINITE);

        if (m_pShared)
        {
            for (int i = 0; i < MAX_CLOCK_SHARERS; i++)
            {
                if (m_pShared->aUsers[i].dwProcessId == GetCurrentProcessId())
                {
                    m_pShared->aUsers[i].dwProcessId = 0;
                    m_pShared->aUsers[i].hPcClock = NULL;

                    break;
                }
            }
        }

        if (m_hClock)
        {
            CloseHandle(m_hClock);
            m_hClock = NULL;
        }        

        if (m_pShared)
        {
            UnmapViewOfFile(m_pShared);
            m_pShared = NULL;
        }

        if (m_hFileMapping)
        {
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
                
        ReleaseMutex(m_hPcClockMutex);
        CloseHandle(m_hPcClockMutex);                            
    }
}

// CPcClock::CreatePcClockHandle
//
// Create the first and only Pc clock handle in the system
//
HRESULT CPcClock::CreatePcClockHandle()
{
    // Attempt to open the clock
    //
    if (!LookForPortClock(&m_hClock))
    {
        TraceI(0, "Could not create Pc clock\n");
        return S_FALSE;
    }

    // Successful clock open. Since we're creating, we know we're the first
    // instance of the clock and therefore the users array is empty.
    //
    m_pShared->aUsers[0].hPcClock = m_hClock;
    m_pShared->aUsers[0].dwProcessId = GetCurrentProcessId();    

    return S_OK;
}

// CPcClock::DuplicatePcClockHandle
//
// There is already a Pc clock in the system. Duplicate the handle in this process
// context.
//
HRESULT CPcClock::DuplicatePcClockHandle()
{
    // Find another user of the clock; also, find a slot in the users array for
    // this process
    //
    int iEmptySlot = -1;
    int iOtherProcess = -1;
    HANDLE hClock = NULL;

    for (int i = 0; 
         (i < MAX_CLOCK_SHARERS) && (iEmptySlot == -1 || !hClock); 
         i++)
    {
        if (m_pShared->aUsers[i].dwProcessId == 0 && iEmptySlot == -1)
        {
            iEmptySlot = i;
            continue;
        }

        if (hClock)
        {
            continue;
        }            

        HANDLE hOtherProcess = OpenProcess(PROCESS_DUP_HANDLE, 
                                           FALSE,
                                           m_pShared->aUsers[i].dwProcessId);
        if (hOtherProcess == NULL)
        {
            TraceI(0, "OpenProcess: %d\n", GetLastError());
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hPcClock = NULL;
            continue;
        }

        BOOL fSuccess = DuplicateHandle(hOtherProcess,
                                        m_pShared->aUsers[i].hPcClock,
                                        GetCurrentProcess(),
                                        &hClock,
                                        GENERIC_READ|GENERIC_WRITE,
                                        FALSE,
                                        0);
        if (!fSuccess)
        {
            TraceI(0, "DuplicateHandle: %d\n", GetLastError());
        }

        CloseHandle(hOtherProcess);

        if (!fSuccess)
        {
            // Other process exists, but could not duplicate handle
            //
            m_pShared->aUsers[i].dwProcessId = 0;
            m_pShared->aUsers[i].hPcClock = NULL;

            hClock = NULL;
        }
    }

    assert(iEmptySlot != -1);
    assert(hClock);

    m_hClock = hClock;

    m_pShared->aUsers[iEmptySlot].dwProcessId = GetCurrentProcessId();
    m_pShared->aUsers[iEmptySlot].hPcClock = hClock;

    return S_OK;
}

STDMETHODIMP 
CPcClock::GetTime(REFERENCE_TIME *pTime)
{
    KSPROPERTY ksp;

    ZeroMemory(&ksp, sizeof(ksp));
    ksp.Set   = KSPROPSETID_SynthClock;
    ksp.Id    = KSPROPERTY_SYNTH_MASTERCLOCK;
    ksp.Flags = KSPROPERTY_TYPE_GET;


    if (!Property(m_hClock,
                  sizeof(ksp),
                  (PKSIDENTIFIER)&ksp,
                  sizeof(*pTime),
                  pTime,
                  NULL))
    {
        return WIN32ERRORtoHRESULT(GetLastError());
    }           
    
    return S_OK;
}

STDMETHODIMP 
CPcClock::AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CPcClock::AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CPcClock::Unadvise(DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}


static BOOL    
LookForPortClock(PHANDLE phClock)
{
    SetupAPI suwrap;
    HANDLE hFilter = INVALID_HANDLE_VALUE;

    if (!suwrap.IsValid()) 
    {
        return FALSE;
    }

    *phClock = (HANDLE)NULL;

	GUID *pClassGuid = const_cast<GUID*>(&KSCATEGORY_AUDIO);
	HDEVINFO hDevInfo = suwrap.SetupDiGetClassDevs(pClassGuid,
											NULL,
											NULL,
											DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
	if (hDevInfo == NULL || hDevInfo == INVALID_HANDLE_VALUE)
	{
		TraceI(0, "Could not open SetupDiGetClassDevs\n");
        return FALSE;
	}

	SP_DEVICE_INTERFACE_DATA DevInterfaceData;
	DevInterfaceData.cbSize = sizeof(DevInterfaceData);

	BYTE rgbStorage[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + _MAX_PATH];
	SP_DEVICE_INTERFACE_DETAIL_DATA * pDevInterfaceDetails = (SP_DEVICE_INTERFACE_DETAIL_DATA *)rgbStorage;
	pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

    int iDevice = 0;

	while (suwrap.SetupDiEnumDeviceInterfaces(hDevInfo, NULL, pClassGuid, iDevice++, &DevInterfaceData))
    {
		if (suwrap.SetupDiGetDeviceInterfaceDetail(hDevInfo, 
		                                    &DevInterfaceData, 
		                                    pDevInterfaceDetails,
 										    sizeof(rgbStorage), 
 										    NULL, 
 										    NULL))
        {
            // Have to convert this since there's no CreateFileW on Win9x.
            //
            hFilter = CreateFile(pDevInterfaceDetails->DevicePath,
                                        GENERIC_READ | GENERIC_WRITE, 
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                        NULL);
            if (hFilter == NULL || hFilter == INVALID_HANDLE_VALUE)
            {
                continue;
            }

            KSPROPERTY ksp;

            ZeroMemory(&ksp, sizeof(ksp));
            ksp.Set   = KSPROPSETID_SynthClock;
            ksp.Id    = KSPROPERTY_SYNTH_MASTERCLOCK;
            ksp.Flags = KSPROPERTY_TYPE_GET;

            REFERENCE_TIME rt;

            if (!Property(
                hFilter,
                sizeof(ksp),
                (PKSIDENTIFIER)&ksp,
                sizeof(rt),
                &rt,
                NULL))
            {
                CloseHandle(hFilter);
                hFilter = INVALID_HANDLE_VALUE;
                continue;
            }
            
            break;
        }
    }

    suwrap.SetupDiDestroyDeviceInfoList(hDevInfo);

    if (hFilter != INVALID_HANDLE_VALUE)
    {
        *phClock = hFilter;
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmportdl.h ===
//
// dmportdl.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// @doc EXTERNAL
//

#ifndef DMPORTDL_H
#define DMPORTDL_H 

#include "dmusicc.h"
#include "dmdlinst.h"
#include "dmdload.h"
////#include "dmdlwave.h"
#include "..\shared\dmusiccp.h"

class CDLSFeature : public AListItem
{
public:
	CDLSFeature*    GetNext(){return(CDLSFeature*)AListItem::GetNext();}
    GUID    m_guidID;       // GUID for query.
    long    m_lResult;      // Data returned by query.
    HRESULT m_hr;           // Indicates whether the synth supported the Query.
};

class CDLSFeatureList : public AList
{
public:
    ~CDLSFeatureList() { Clear(); }
    void Clear()
	{
		while(!IsEmpty())
		{
			CDLSFeature* pFeature = RemoveHead();
			delete pFeature;
		}
	}
    CDLSFeature* GetHead(){return (CDLSFeature *)AList::GetHead();}
    CDLSFeature* RemoveHead(){return(CDLSFeature *)AList::RemoveHead();}
	void Remove(CDLSFeature* pFeature){AList::Remove((AListItem *)pFeature);}
};

#define DLB_HASH_SIZE   31  // Hash table for download buffer lists.

class CDirectSoundWave;

class CDirectMusicPortDownload : public IDirectMusicPortDownload
{
friend class CCollection;
friend class CInstrument;
friend class CInstrObj;
friend class CConditionChunk;
friend class CDirectMusicDownloadedWave;
friend class CDirectMusicVoice;
friend class CDirectSoundWaveDownload;

public:
    CDirectMusicPortDownload();
    virtual ~CDirectMusicPortDownload();

    STDMETHODIMP GetDLId(DWORD* pdwStartDLId, DWORD dwCount);
    
    STDMETHOD(Refresh)(
        THIS_
        DWORD dwDLId,
        DWORD dwFlags) PURE;

    static void GetDLIdP(DWORD* pdwStartDLId, DWORD dwCount);
        
protected:
    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPortDownload
    STDMETHODIMP GetBuffer(DWORD dwId, IDirectMusicDownload** ppIDMDownload);
    STDMETHODIMP AllocateBuffer(DWORD dwSize, IDirectMusicDownload** ppIDMDownload);
    STDMETHODIMP FreeBuffer(IDirectMusicDownload* pIDMDownload);
    STDMETHODIMP Download(IDirectMusicDownload* pIDMDownload);
    STDMETHODIMP Unload(IDirectMusicDownload* pIDMDownload);
    STDMETHODIMP GetAppend(DWORD* pdwAppend);

    
    // Class
    STDMETHODIMP DownloadP(IDirectMusicInstrument* pInstrument,
                           IDirectMusicDownloadedInstrument** ppDownloadedInstrument,
                           DMUS_NOTERANGE* NoteRanges,
                           DWORD dwNumNoteRanges,
                           BOOL fVersion2);
    STDMETHODIMP UnloadP(IDirectMusicDownloadedInstrument* pDownloadedInstrument);
    
    STDMETHODIMP DownloadWaveP(IDirectSoundWave *pWave,               
                               IDirectSoundDownloadedWaveP **ppWave,
                               REFERENCE_TIME rtStartHint);
                               
    STDMETHODIMP UnloadWaveP(IDirectSoundDownloadedWaveP *pWave);                               

    STDMETHODIMP AllocVoice(
        IDirectSoundDownloadedWaveP *pWave,          // Wave to play on this voice
        DWORD dwChannel,                            // Channel and channel group
        DWORD dwChannelGroup,                       //  this voice will play on
        REFERENCE_TIME rtStart,
        SAMPLE_TIME stLoopStart,
        SAMPLE_TIME stLoopEnd,                                                        
        IDirectMusicVoiceP **ppVoice);               // Returned voice
        
    STDMETHODIMP GetCachedAppend(                                            
        DWORD *pdw);                                // DWORD to receive append        
        
        
private:  
    STDMETHODIMP GetBufferInternal(DWORD dwDLId,IDirectMusicDownload** ppIDMDownload);
    STDMETHODIMP QueryDLSFeature(REFGUID rguidID, long * plResult);
    void ClearDLSFeatures();
    STDMETHODIMP GetWaveRefs(IDirectMusicDownload* ppDownloadedBuffers[],
                             DWORD* pdwWaveRefs,
                             DWORD* pdwWaveIds,
                             DWORD dwNumWaves,
                             CInstrument* pCInstrument,
                             DMUS_NOTERANGE* NoteRanges,
                             DWORD dwNumNoteRanges);
    STDMETHODIMP FindDownloadedInstrument(DWORD dwId, CDownloadedInstrument** ppDMDLInst);
    STDMETHODIMP AddDownloadedInstrument(CDownloadedInstrument* pDMDLInst);
    STDMETHODIMP RemoveDownloadedInstrument(CDownloadedInstrument* pDMDLInst);
    
    STDMETHODIMP FindDownloadedWaveObject(IDirectSoundWave *pWave,
                                          CDirectMusicDownloadedWave **ppDLWave);
                                          
    STDMETHODIMP AddDownloadedWaveObject(CDirectMusicDownloadedWave *pDLWave);                                          

    STDMETHODIMP RemoveDownloadedWaveObject(CDirectMusicDownloadedWave *pDLWave);
    
    STDMETHODIMP AllocWaveArticulation(IDirectSoundWave *pWave, IDirectMusicDownload **ppDownload);
    
public:
    static CRITICAL_SECTION sDMDLCriticalSection;
    static DWORD sNextDLId;

protected:
    CDLSFeatureList             m_DLSFeatureList;       // Cached list of DLS queries, built and then freed during each download.
    CDLInstrumentList			m_DLInstrumentList;     // Linked list of downloaded instruments,
                                                        // each represented by an IDirectMusicDownloadedInstrument
                                                        // interface. 
    CDLBufferList	            m_DLBufferList[DLB_HASH_SIZE];         // Linked list of downloaded buffers, each
                                                        // represented by an IDirectMusicDownload interface.
    CRITICAL_SECTION			m_DMDLCriticalSection;  // For the interface
    BOOL                        m_fDMDLCSinitialized;    
    DWORD						m_dwAppend;             // Append in samples, as required by synth.
    DWORD                       m_fNewFormat;           // Set if the synth handles DMUS_INSTRUMENT2 chunks.
    long						m_cRef;
    
    // Additions to track downloaded wave objects
    //
//    CDMDLWaveList               m_DLWaveList;           // Holds all wave obj interfaces downloaded to this port

private:    
    CRITICAL_SECTION m_CDMDLCriticalSection; // for the class
    BOOL             m_fCDMDLCSinitialized;};

#define APPEND_NOT_RETRIEVED	0xFFFFFFFF
#define NEWFORMAT_NOT_RETRIEVED 0xFFFFFFFF

#endif // #ifndef DMPORTDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmregion.h ===
//
// dmregion.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay

#ifndef DMREGION_H
#define DMREGION_H

#include "dmextchk.h"
#include "dmart.h"

class CRiffParser;

class CRegion : public AListItem
{
friend CInstrObj;

public:
	CRegion(); 
	~CRegion();

	CRegion* GetNext(){return(CRegion*)AListItem::GetNext();}
	HRESULT Load(CRiffParser *pParser);
	HRESULT Write(void* pv, DWORD* pdwCurOffset, DWORD* pDMIOffsetTable, 
        DWORD* pdwCurIndex, DWORD dwIndexNextRegion);
    void SetPort(CDirectMusicPortDownload *pPort,BOOL fNewFormat, BOOL fSupportsDLS2);
    BOOL CheckForConditionals();
	DWORD Size();
	DWORD Count();

	DWORD GetWaveId() {return(m_WaveLink.ulTableIndex);};
private:
	void Cleanup();

private:
//    CRITICAL_SECTION	m_DMRegionCriticalSection;
    BOOL                m_fCSInitialized;
public:
	RGNHEADER			m_RgnHeader;
	WAVELINK			m_WaveLink;
	WSMPL				m_WSMP;
	WLOOP				m_WLOOP[1];
    CConditionChunk     m_Condition;            // Optional conditional chunk;
private:
	CArticulationList	m_ArticulationList;
	CExtensionChunkList m_ExtensionChunkList;
	DWORD				m_dwCountExtChk;
    BOOL                m_fNewFormat;           // Port can handle new format.
    BOOL                m_fDLS1;                // This is a DLS1 region.
};

class CRegionList : public AList
{
friend class CInstrObj;
friend class CCDirectMusicPortDownload;

public:
	CRegionList(){}
	~CRegionList() 
	{
		while(!IsEmpty())
		{
			CRegion* pRegion = RemoveHead();
			delete pRegion;
		}
	}

    CRegion* GetHead(){return(CRegion *)AList::GetHead();}
	CRegion* GetItem(LONG lIndex){return(CRegion*)AList::GetItem(lIndex);}
    CRegion* RemoveHead(){return(CRegion *)AList::RemoveHead();}
	void Remove(CRegion* pRegion){AList::Remove((AListItem *)pRegion);}
	void AddTail(CRegion* pRegion){AList::AddTail((AListItem *)pRegion);}
};

#endif // #ifndef DMREGION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmsport.cpp ===
//
// dmsport.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort implementation; code common to DX7 and DX8 style ports.
// 
#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "validate.h"
#include "debug.h"
#include "dmvoice.h"

#include "dmsport7.h"
#include "dmsport8.h"

const GUID guidZero = {0};

HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData);

////////////////////////////////////////////////////////////////////////////////
//
// CreateCDirectMusicSynthPort
//
// Determine which type of port (DX7 or DX8) is being created and which
// types the requested synth supports. Create the highest level of 
// port possible.
//
HRESULT 
CreateCDirectMusicSynthPort(
    PORTENTRY               *pe, 
    CDirectMusic            *pDM, 
    UINT                    uVersion,
    DMUS_PORTPARAMS         *pPortParams,
    IDirectMusicPort        **ppPort)
{
    HRESULT hr = S_OK;

    // Determine what type of connection we can get. We can only
    // do DX-8 if we've been asked for it and the synth supports
    // it.
    //
    IDirectMusicSynth *pSynth = NULL;
    IDirectMusicSynth8 *pSynth8 = NULL;

    bool fAudioPathSet = false;
    bool fAudioPath = false;

    if (uVersion >= 8 && (pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES))
    {
        fAudioPathSet = true;                
        fAudioPath = (pPortParams->dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH) ? true : false;
    }

    if (!fAudioPath)
    {
        // Specifically requested old style interface.
        //
        uVersion = 7;
    }

    if (uVersion >= 8) 
    {
        // Asked for DX-8 interfaces.
        //
        hr = CoCreateInstance(
            pe->pc.guidPort,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDirectMusicSynth8,
            (void**)&pSynth8);

        // If creation failed for some legitimate reason, return.
        // If E_NOINTERFACE then we can try to fall back on DX-7.
        //
        if (FAILED(hr) && hr != E_NOINTERFACE)
        {
            return hr;
        }
    }
       
    if (uVersion < 8 || hr == E_NOINTERFACE)
    {
        // Asked for DX-7 interfaces or we couldn't get DX-8 interfaces.
        //
        hr = CoCreateInstance(
            pe->pc.guidPort,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDirectMusicSynth,
            (void**)&pSynth);

        // If synth doesn't support that, we have nothing to fall back
        // onto.
        //
        if (FAILED(hr)) 
        {
            return hr;
        }
    }

    // Create and initialize the correct type of port.
    //        
    if (pSynth)
    {
        assert(!pSynth8);
    
        CDirectMusicSynthPort7 *pPort7 = new CDirectMusicSynthPort7(pe, pDM, pSynth);

        if (pPort7 == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pPort7->Initialize(pPortParams);
        }

        if (SUCCEEDED(hr))
        {
            *ppPort = static_cast<IDirectMusicPort*>(pPort7);
            (*ppPort)->AddRef();
        }

        RELEASE(pPort7);
        RELEASE(pSynth);

        if (SUCCEEDED(hr) && fAudioPath)
        {
            // They asked for an audio path but ended up without it
            //
            pPortParams->dwFeatures &= ~DMUS_PORT_FEATURE_AUDIOPATH;
            hr = S_FALSE;
        }
    }
    else if (pSynth8)
    {
        assert(!pSynth);

        CDirectMusicSynthPort8 *pPort8 = new CDirectMusicSynthPort8(pe, pDM, pSynth8);

        if (pPort8 == NULL) 
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pPort8->Initialize(pPortParams);
        }

        if (SUCCEEDED(hr))
        {
            *ppPort = static_cast<IDirectMusicPort*>(pPort8);
            (*ppPort)->AddRef();
        }

        RELEASE(pPort8);
        RELEASE(pSynth8);
    }
    else
    {
        assert(false);
    }

    return hr;
}   

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::CDirectMusicSynthPort
//
CDirectMusicSynthPort::CDirectMusicSynthPort(
    PORTENTRY           *pPE,
    CDirectMusic        *pDM,
    IDirectMusicSynth   *pSynth)
{
    m_cRef                  = 1;
    
    m_pDM                   = pDM;
    m_pSynth                = pSynth;
    m_dmpc                  = pPE->pc;

    m_pNotify               = NULL;
    m_pSynthPropSet         = NULL;
    m_pSinkPropSet          = NULL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::~CDirectMusicSynthPort
//
CDirectMusicSynthPort::~CDirectMusicSynthPort()
{
    Close();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::QueryInterface
//
STDMETHODIMP
CDirectMusicSynthPort::QueryInterface(const IID &iid,
                                        void **ppv)
{
    V_INAME(IDirectMusicPort::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPortP)
    {
        *ppv = static_cast<IDirectMusicPortP*>(this);
    }
    else if (iid == IID_IDirectMusicPortDownload)
    {
        *ppv = static_cast<IDirectMusicPortDownload*>(this);		
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::AddRef
//
STDMETHODIMP_(ULONG)
CDirectMusicSynthPort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Release
//
STDMETHODIMP_(ULONG)
CDirectMusicSynthPort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Initialize
//
// Initialization common to all versions
//
HRESULT
CDirectMusicSynthPort::Initialize(
    DMUS_PORTPARAMS *pPortParams)
{
    HRESULT hr;

    // Get our notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (SUCCEEDED(hr))
    {
        // HACK HACK: Don't hold a refcount against DirectMusic
        //
        m_pNotify->Release();
    }
    else
    {
        TraceI(1, "Failed to get IDirectMusicPortNotify\n");
    }

    // Save off property set handler
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->QueryInterface(
            IID_IKsControl, 
            (void**)&m_pSynthPropSet);
        if (FAILED(hr)) 
        {
            TraceI(1, "NOTE: Synth has no property set\n");
              
            // This is a warning, not an error
            //
            hr = S_OK;
        }
    }

    // Cache number of channel groups
    //
    if (SUCCEEDED(hr))
    {
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            m_dwChannelGroups = pPortParams->dwChannelGroups;
        }
        else
        {
            m_dwChannelGroups = 1;
        }

        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES)
        {
            m_dwFeatures = pPortParams->dwFeatures;
        }
        else
        {
            m_dwFeatures = 0;
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Close
//
STDMETHODIMP CDirectMusicSynthPort::Close()
{
    if (m_pNotify)
    {   
        m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        m_pNotify = NULL;
    }

    RELEASE(m_pSynthPropSet);
    RELEASE(m_pSinkPropSet);

    m_pDM = NULL;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::InitChannelPriorities 
//
//
static DWORD adwChannelPriorities[16] =
{
    DAUD_CHAN1_DEF_VOICE_PRIORITY,
    DAUD_CHAN2_DEF_VOICE_PRIORITY,
    DAUD_CHAN3_DEF_VOICE_PRIORITY,
    DAUD_CHAN4_DEF_VOICE_PRIORITY,
    DAUD_CHAN5_DEF_VOICE_PRIORITY,
    DAUD_CHAN6_DEF_VOICE_PRIORITY,
    DAUD_CHAN7_DEF_VOICE_PRIORITY,
    DAUD_CHAN8_DEF_VOICE_PRIORITY,
    DAUD_CHAN9_DEF_VOICE_PRIORITY,
    DAUD_CHAN10_DEF_VOICE_PRIORITY,
    DAUD_CHAN11_DEF_VOICE_PRIORITY,
    DAUD_CHAN12_DEF_VOICE_PRIORITY,
    DAUD_CHAN13_DEF_VOICE_PRIORITY,
    DAUD_CHAN14_DEF_VOICE_PRIORITY,
    DAUD_CHAN15_DEF_VOICE_PRIORITY,
    DAUD_CHAN16_DEF_VOICE_PRIORITY
};

void CDirectMusicSynthPort::InitChannelPriorities(
    UINT uLowCG,
    UINT uHighCG)
{
    while (uLowCG <= uHighCG)
    {
        for (UINT uChannel = 0; uChannel < 16; uChannel++)
        {
            m_pSynth->SetChannelPriority(uLowCG, uChannel, adwChannelPriorities[uChannel]);        
        }

        uLowCG++;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetSinkKsControl 
//
//
void CDirectMusicSynthPort::SetSinkKsControl(
    IKsControl *pSinkKsControl)
{
    RELEASE(m_pSinkPropSet);

    m_pSinkPropSet = pSinkKsControl;
    if (m_pSinkPropSet) 
    {
        m_pSinkPropSet->AddRef();
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::InitializeVolumeBoost
//
//
void CDirectMusicSynthPort::InitializeVolumeBoost()
{
    HRESULT hr;

    if (m_pSynthPropSet)
    {
    	// set volume boost
        //
    	KSPROPERTY ksp;
    	ULONG cb;
        ULONG lVolume = 0;          // zero boost by default

    	ZeroMemory(&ksp, sizeof(ksp));
    	ksp.Set   = KSPROPSETID_Synth;
    	ksp.Id    = KSPROPERTY_SYNTH_VOLUMEBOOST;
    	ksp.Flags = KSPROPERTY_TYPE_SET;

    	hr = m_pSynthPropSet->KsProperty(&ksp,
    		     				        sizeof(ksp),
    			     			        (LPVOID)&lVolume,
    				     		        sizeof(lVolume),
    					     	        &cb);
        if (FAILED(hr))
        {
            TraceI(2, "NOTE: Set volume boost failed %08X\n", hr);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Compact
//
STDMETHODIMP CDirectMusicSynthPort::Compact()
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetCaps
//
STDMETHODIMP CDirectMusicSynthPort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &m_dmpc, sizeof(DMUS_PORTCAPS));
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::DeviceIoControl
//
STDMETHODIMP CDirectMusicSynthPort::DeviceIoControl(
    DWORD           dwIoControlCode, 
    LPVOID          lpInBuffer, 
    DWORD           nInBufferSize, 
    LPVOID          lpOutBuffer, 
    DWORD           nOutBufferSize, 
    LPDWORD         lpBytesReturned, 
    LPOVERLAPPED    lpOverlapped)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetNumChannelGroups
//
STDMETHODIMP CDirectMusicSynthPort::SetNumChannelGroups(
    DWORD dwChannelGroups)      
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    HRESULT hr = m_pSynth->SetNumChannelGroups(dwChannelGroups);

    if (FAILED(hr))
    {
        return hr;
    }

    if (dwChannelGroups > m_dwChannelGroups)
    {
        InitChannelPriorities(m_dwChannelGroups + 1, dwChannelGroups);
    }
    
    m_dwChannelGroups = dwChannelGroups;

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetNumChannelGroups
//
STDMETHODIMP CDirectMusicSynthPort::GetNumChannelGroups(
    LPDWORD pdwChannelGroups)      
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *pdwChannelGroups = m_dwChannelGroups;
    
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::PlayBuffer
//
STDMETHODIMP CDirectMusicSynthPort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    HRESULT hr;
    REFERENCE_TIME rt;
    DWORD cb;
    LPBYTE lpb;

    V_INAME(IDirectMusicPort::PlayBuffer);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    hr = pIBuffer->GetStartTime(&rt);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetUsedBytes(&cb);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pIBuffer->GetRawBufferPtr(&lpb);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }
    
    return m_pSynth->PlayBuffer(rt, lpb, cb);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetEventNotification
//
STDMETHODIMP CDirectMusicSynthPort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Read
//
STDMETHODIMP CDirectMusicSynthPort::Read(
	IDirectMusicBuffer *pIBuffer)                          
{
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);
    
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::DownloadInstrument
//
STDMETHODIMP CDirectMusicSynthPort::DownloadInstrument(
    IDirectMusicInstrument* pInstrument,
    IDirectMusicDownloadedInstrument** ppDownloadedInstrument,
    DMUS_NOTERANGE* pNoteRanges,
    DWORD dwNumNoteRanges)
{
    V_INAME(IDirectMusicPort::DownloadInstrument);
    V_INTERFACE(pInstrument);
	V_PTRPTR_WRITE(ppDownloadedInstrument);
	V_BUFPTR_READ(pNoteRanges, (dwNumNoteRanges * sizeof(DMUS_NOTERANGE)));

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	return CDirectMusicPortDownload::DownloadP(pInstrument,
											   ppDownloadedInstrument,
											   pNoteRanges,
											   dwNumNoteRanges,
                                               TRUE);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::UnloadInstrument
//
STDMETHODIMP CDirectMusicSynthPort::UnloadInstrument(
    IDirectMusicDownloadedInstrument* pDownloadedInstrument)
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	return CDirectMusicPortDownload::UnloadP(pDownloadedInstrument);
}

//////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Download
//
STDMETHODIMP CDirectMusicSynthPort::Download(
	IDirectMusicDownload* pIDMDownload)	
{
    V_INAME(IDirectMusicPort::Download);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	EnterCriticalSection(&m_DMDLCriticalSection);

	// If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
	// pIDMDownload is of type CDownloadBuffer.
	IDirectMusicDownloadPrivate* pDMDLP = NULL;
	HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

	if(SUCCEEDED(hr))
	{
		pDMDLP->Release();		

		hr = ((CDownloadBuffer *)pIDMDownload)->IsDownloaded();
		if(hr != S_FALSE)
		{
			LeaveCriticalSection(&m_DMDLCriticalSection);
			return DMUS_E_ALREADY_DOWNLOADED;
		}

		void* pvBuffer = NULL;

		hr = ((CDownloadBuffer *)pIDMDownload)->GetBuffer(&pvBuffer);

		if(pvBuffer == NULL)
		{
			hr = DMUS_E_BUFFERNOTSET;
		}

        if (SUCCEEDED(hr) && !(m_dwFeatures & DMUS_PORT_FEATURE_STREAMING))
        {
            DMUS_DOWNLOADINFO *pdl = (DMUS_DOWNLOADINFO*)pvBuffer;

            if (pdl->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE)
            {
                // That feature is disabled, pretend we don't understand
                //
                hr = DMUS_E_UNKNOWNDOWNLOAD;
            }
        }

		BOOL bFree = false;
		if(SUCCEEDED(hr))
		{
			hr = m_pSynth->Download(&(((CDownloadBuffer *)pIDMDownload)->m_DLHandle),
									pvBuffer, 
									&bFree);

			if(SUCCEEDED(hr))
			{
				// AddRef() before we add it to the list.
				pIDMDownload->AddRef();
                DWORD dwID = ((DMUS_DOWNLOADINFO*)pvBuffer)->dwDLId;
				((CDownloadBuffer *)pIDMDownload)->m_dwDLId = dwID;
				m_DLBufferList[dwID % DLB_HASH_SIZE].AddHead((CDownloadBuffer*)pIDMDownload);
				((CDownloadBuffer*)pIDMDownload)->IncDownloadCount();

				if(bFree)
				{
					pvBuffer = NULL;
                    DWORD dw;
					((CDownloadBuffer *)pIDMDownload)->GetHeader(&pvBuffer, &dw);
					((CDownloadBuffer *)pIDMDownload)->SetBuffer(NULL, 0, 0);
					delete [] pvBuffer;
				}
				else
				{
					// If we do not free buffer we need to AddRef()
					// We do not want buffer to go away until the IDirectMusicPort is 
					// finished with it.
					pIDMDownload->AddRef();
				}
			}
			else if(FAILED(hr))
			{
				((CDownloadBuffer *)pIDMDownload)->m_DLHandle = NULL;
			}
		}
	}
	
	LeaveCriticalSection(&m_DMDLCriticalSection);

	return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Unload
//
STDMETHODIMP CDirectMusicSynthPort::Unload(
	IDirectMusicDownload* pIDMDownload)	
{
    V_INAME(IDirectMusicPort::Unload);
    V_INTERFACE(pIDMDownload);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

	EnterCriticalSection(&m_DMDLCriticalSection);


	// If you can QI pIDMDownload for private interface IDirectMusicDownloadPrivate 
	// pIDMDownload is of type CDownloadBuffer.
	IDirectMusicDownloadPrivate* pDMDLP = NULL;
	HRESULT hr = pIDMDownload->QueryInterface(IID_IDirectMusicDownloadPrivate, (void **)&pDMDLP);

	if(SUCCEEDED(hr))
	{
		pDMDLP->Release();

        if (((CDownloadBuffer *)pIDMDownload)->IsDownloaded() == S_OK)
        {
		    if(((CDownloadBuffer *)pIDMDownload)->DecDownloadCount() == 0)
		    {
			    m_DLBufferList[((CDownloadBuffer *)pIDMDownload)->m_dwDLId % DLB_HASH_SIZE].Remove(
                    (CDownloadBuffer *)pIDMDownload);
			    pIDMDownload->Release();
			    hr = m_pSynth->Unload(((CDownloadBuffer *)pIDMDownload)->m_DLHandle, FreeHandle, (HANDLE)pIDMDownload);
		    }
        }
        else
        {
            TraceI(0, "CDirectMusicSynthPort::Unload- not downloaded\n");
        }
	}

	LeaveCriticalSection(&m_DMDLCriticalSection);
	
	return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetAppend
//
STDMETHODIMP CDirectMusicSynthPort::GetAppend(
    DWORD* pdwAppend)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    V_INAME(IDirectMusicPort::GetAppend);
    V_PTR_WRITE(pdwAppend, DWORD);

    return m_pSynth->GetAppend(pdwAppend);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetLatencyClock
//
STDMETHODIMP CDirectMusicSynthPort::GetLatencyClock(
    IReferenceClock **ppClock)
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetLatencyClock(ppClock);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetRunningStats
//
STDMETHODIMP CDirectMusicSynthPort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetRunningStats(pStats);
}

#if 0
// XXX Different

#endif

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort::SetChannelPriority
//
STDMETHODIMP CDirectMusicSynthPort::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->SetChannelPriority(dwChannelGroup, dwChannel, dwPriority);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort::GetChannelPriority
//
STDMETHODIMP CDirectMusicSynthPort::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    V_INAME(IDirectMusicPort::GetChannelPriority);
    V_PTR_WRITE(pdwPriority, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetChannelPriority(dwChannelGroup, dwChannel, pdwPriority);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort::SetDirectSound
//
// XXX What does this mean in terms of DX8?
// XXX This can probably become pure virtual
//
STDMETHODIMP
CDirectMusicSynthPort::SetDirectSound(
    LPDIRECTSOUND pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetFormat
//
// XXX What does pcbBuffer mean in terms of DX8?
// XXX This can probably become pure virtual
//
STDMETHODIMP CDirectMusicSynthPort::GetFormat(
    LPWAVEFORMATEX  pwfex,
    LPDWORD         pdwwfex,
    LPDWORD         pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::DownloadWave
//
STDMETHODIMP CDirectMusicSynthPort::DownloadWave(
    IDirectSoundWave *pWave,          
    IDirectSoundDownloadedWaveP **ppWave,
    REFERENCE_TIME rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::UnloadWave
//
STDMETHODIMP CDirectMusicSynthPort::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::AllocVoice
//
STDMETHODIMP 
CDirectMusicSynthPort::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,     
    DWORD dwChannel,                       
    DWORD dwChannelGroup,                  
    REFERENCE_TIME rtStart,                     
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,         
    IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::AssignChannelToBuses
//
STDMETHODIMP 
CDirectMusicSynthPort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    V_INAME(IDirectMusicPort::AssignChannelToBuses);
    V_BUFPTR_WRITE(pdwBuses, sizeof(DWORD) * cBusCount);

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::StartVoice
//
STDMETHODIMP CDirectMusicSynthPort::StartVoice(          
    DWORD dwVoiceId,
    DWORD dwChannel,
    DWORD dwChannelGroup,
    REFERENCE_TIME rtStart,
    DWORD dwDLId,
    LONG prPitch,
    LONG vrVolume,
    SAMPLE_TIME stVoiceStart,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::StopVoice
//
STDMETHODIMP CDirectMusicSynthPort::StopVoice(          
    DWORD dwVoiceId,
    REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetVoiceState
//
STDMETHODIMP CDirectMusicSynthPort::GetVoiceState(
    DWORD dwVoice[], 
    DWORD cbVoice,
    DMUS_VOICE_STATE VoiceState[]) 
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::Refresh
//
STDMETHODIMP CDirectMusicSynthPort::Refresh(
    DWORD dwDownloadId,
    DWORD dwFlags)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::SetSink
//
STDMETHODIMP CDirectMusicSynthPort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetSink
//
STDMETHODIMP CDirectMusicSynthPort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::KsProperty
//
STDMETHODIMP CDirectMusicSynthPort::KsProperty(
        IN PKSPROPERTY  pProperty,
        IN ULONG        ulPropertyLength,
        IN OUT LPVOID   pvPropertyData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    LONG lVolume;

    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pProperty, ulPropertyLength);

    // pvPropertyData is not optional on a SET operation
    //
    if (pProperty->Flags & KSPROPERTY_TYPE_SET)
    {
        V_BUFPTR_WRITE(pvPropertyData, ulDataLength);
    } 
    else 
    {
        V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    }
    
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    HRESULT hr = DMUS_E_UNKNOWN_PROPERTY;

    // Don't let callers touch property sets we use
    //
    if (pProperty->Set == KSPROPSETID_Synth) 
    {
        if (pProperty->Id != KSPROPERTY_SYNTH_VOLUME)
        {
            return DMUS_E_UNKNOWN_PROPERTY;
        }
        else if (ulDataLength != sizeof(LONG))
        {
            return E_INVALIDARG;
        }
        else if (pProperty->Flags & KSPROPERTY_TYPE_SET)
        {
            lVolume = *(LONG*)pvPropertyData;

            // Clamp to -200..+20 db
            //
            if (lVolume < -20000) 
            {
                lVolume = -20000;
                pvPropertyData = &lVolume;
            }
            else if (lVolume > 2000)
            {
                lVolume = 2000;
                pvPropertyData = &lVolume;
            }
        }
    }
    else if (pProperty->Set == KSPROPSETID_Synth_Dls)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }


    if (m_pSynthPropSet)
    {
        hr = m_pSynthPropSet->KsProperty(pProperty, 
                                         ulPropertyLength,
                                         pvPropertyData,
                                         ulDataLength,
                                         pulBytesReturned);
    }

    if (hr == DMUS_E_UNKNOWN_PROPERTY && m_pSinkPropSet) 
    {
        hr = m_pSinkPropSet->KsProperty(pProperty, 
                                        ulPropertyLength,
                                        pvPropertyData,
                                        ulDataLength,
                                        pulBytesReturned);
    }
    
    return hr;        
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::KsMethod
//
STDMETHODIMP CDirectMusicSynthPort::KsMethod(
        IN PKSMETHOD    pMethod,
        IN ULONG        ulMethodLength,
        IN OUT LPVOID   pvMethodData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // If they don't support it, then it's unknown
    //
    HRESULT hr = DMUS_E_UNKNOWN_PROPERTY;
    if (m_pSynthPropSet)
    {
        hr = m_pSynthPropSet->KsMethod(pMethod, 
                                       ulMethodLength,
                                       pvMethodData,
                                       ulDataLength,
                                       pulBytesReturned);
    }

    if (hr == DMUS_E_UNKNOWN_PROPERTY && m_pSinkPropSet) 
    {
        hr = m_pSinkPropSet->KsMethod(pMethod, 
                                      ulMethodLength,
                                      pvMethodData,
                                      ulDataLength,
                                      pulBytesReturned);
    }
    
    return hr;        
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::KsEvent
//
STDMETHODIMP CDirectMusicSynthPort::KsEvent(
        IN PKSEVENT     pEvent,
        IN ULONG        ulEventLength,
        IN OUT LPVOID   pvEventData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    HRESULT hr = DMUS_E_UNKNOWN_PROPERTY;

    if (m_pSynthPropSet)
    {
        hr = m_pSynthPropSet->KsEvent(pEvent, 
                                      ulEventLength,
                                      pvEventData,
                                      ulDataLength,
                                      pulBytesReturned);
    }

    if (hr == DMUS_E_UNKNOWN_PROPERTY && m_pSinkPropSet) 
    {
        hr = m_pSinkPropSet->KsEvent(pEvent, 
                                     ulEventLength,
                                     pvEventData,
                                     ulDataLength,
                                     pulBytesReturned);
    }
    
    return hr;        
}

////////////////////////////////////////////////////////////////////////////////
//
// FreeHandle - Callback function used by Synth
//
HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData)
{
    DWORD dw;
	void* pvBuffer = NULL;
	HRESULT hr = ((CDownloadBuffer *)hUserData)->GetHeader(&pvBuffer, &dw);
	
	if(SUCCEEDED(hr))
	{
		hr = ((CDownloadBuffer *)hUserData)->SetBuffer(NULL, 0, 0);
		delete [] pvBuffer;
	}

	((CDownloadBuffer *)hUserData)->Release();

	return hr;
}

#if 0
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort::GetCachedFormat
//
HRESULT CDirectMusicSynthPort::GetCachedFormat(LPWAVEFORMATEX *ppwfex)
{
    HRESULT hr;

    if (m_pwfex == NULL) 
    {
        DWORD cbWaveFormat;

        hr = m_pSynth->GetFormat(NULL, &cbWaveFormat);
        if (FAILED(hr))
        {
            TraceI(0, "DownloadWave: Synth failed GetFormat size query %08X\n", hr);
            return hr;
        }

        m_pwfex = (LPWAVEFORMATEX)(new BYTE[cbWaveFormat]);
        if (m_pwfex == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr = m_pSynth->GetFormat(m_pwfex, &cbWaveFormat);
        if (FAILED(hr)) 
        {
            delete[] m_pwfex;
            m_pwfex =  NULL;

            TraceI(0, "DownloadWave: Synth failed GetFormat %08X\n", hr);
            return hr;
        }
    }

    *ppwfex = m_pwfex;

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmsport7.h ===
//
// dmsport7.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort7 implementation; code specific to DX-7 style ports
// 
#ifndef _DMSPORT7_H_
#define _DMSPORT7_H_

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7
//
class CDirectMusicSynthPort7 : public CDirectMusicSynthPort
{
public:
    CDirectMusicSynthPort7(
        PORTENTRY           *pe,
        CDirectMusic        *pDM,
        IDirectMusicSynth   *pSynth);

    ~CDirectMusicSynthPort7();

    HRESULT Initialize(
        DMUS_PORTPARAMS *pPortParams);   

    // Overridden public methods
    //
    STDMETHODIMP Close();

    STDMETHODIMP Activate(
        BOOL fActivate);

    STDMETHODIMP KsProperty(
        IN PKSPROPERTY  pProperty,
        IN ULONG        ulPropertyLength,
        IN OUT LPVOID   pvPropertyData,
        IN ULONG        ulDataLength,
        OUT PULONG      pulBytesReturned);

    STDMETHODIMP GetFormat(
        LPWAVEFORMATEX  pwfex,
        LPDWORD         pdwwfex,
        LPDWORD         pcbBuffer);

    STDMETHODIMP SetDirectSound(
        LPDIRECTSOUND       pDirectSound,
        LPDIRECTSOUNDBUFFER pDirectSoundBuffer);

private:
    void CacheSinkUsesDSound();

private:
    IDirectMusicSynth       *m_pSynth;              // 6.1/7.0 Synth 
    IDirectMusicSynthSink   *m_pSink;               //  and sink 
    bool                    m_fSinkUsesDSound;      // Does sink use dsound?
    bool                    m_fUsingDirectMusicDSound;
                                                    // Using default dsound
    LPDIRECTSOUND           m_pDirectSound;         // Directsound object and
    LPDIRECTSOUNDBUFFER     m_pDirectSoundBuffer;   //  buffer
    LPWAVEFORMATEX          m_pwfex;                // Cached wave format
    long                    m_lActivated;           // Is port active?
    bool                    m_fHasActivated;        // Has it ever activated?
};

#endif // _DMSPORT7_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmsysclk.cpp ===
//
// dmsysclk.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// @doc EXTERNAL
//
//
#include <objbase.h>
#include "dmusicp.h"
#include "debug.h"
#include "resource.h"

// RDTSC: Pentium instruction to read the cycle clock (increments once per clock cycle)
//
#define RDTSC _asm _emit 0x0f _asm _emit 0x31

#define MS_CALIBRATE    (100)           // How long to calibate the Pentium clock against timeGetTime?
#define REFTIME_PER_MS  (10 * 1000)     // 10 100-ns units per millisecond

// Registry constant to dispable Pentium clock
//
static const char cszUsePentiumClock[] = "UsePentiumClock";

// Only determine which clock to use once
//
typedef enum
{
    SYSCLOCK_UNKNOWN,
    SYSCLOCK_WINMM,
    SYSCLOCK_PENTIMER
} SYSCLOCK_T;

static SYSCLOCK_T gSysClock = SYSCLOCK_UNKNOWN;
static DWORD gdwCycPer100ns;

static HRESULT CreateSysClock(IReferenceClock **ppClock, CMasterClock *pMasterClock);
static void ProbeClock();

// Class implmentations, private to dmsysclk.cpp
//
class CReferenceClockWinmm : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    CReferenceClockWinmm();

private:
    long m_cRef;
};

#ifdef _X86_
class CReferenceClockPentium : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime, REFERENCE_TIME streamTime, HANDLE hEvent, DWORD * pdwAdviseCookie); 
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime, REFERENCE_TIME periodTime, HANDLE hSemaphore, DWORD * pdwAdviseCookie);
    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    CReferenceClockPentium(DWORD dwDivisor);

private:
    long m_cRef;
    DWORD m_dwDivisor;
};
#endif

// AddSysClocks
//
// Add system clock to the list of clocks.
//
HRESULT AddSysClocks(CMasterClock *pMasterClock)
{
    if (gSysClock == SYSCLOCK_UNKNOWN)
    {
        ProbeClock();
    }

    CLOCKENTRY ce;

    ZeroMemory(&ce, sizeof(ce));
    ce.cc.dwSize = sizeof(ce);
    ce.cc.guidClock = GUID_SysClock;
    ce.cc.ctType = DMUS_CLOCK_SYSTEM;
    ce.cc.dwFlags = DMUS_CLOCKF_GLOBAL;
    ce.pfnGetInstance = CreateSysClock;

    int cch;
    int cchMax = sizeof(ce.cc.wszDescription) / sizeof(WCHAR);

    char sz[sizeof(ce.cc.wszDescription) / sizeof(WCHAR)];
    cch = LoadString(g_hModule,
                     IDS_SYSTEMCLOCK,
                     sz,
                     sizeof(sz));
    if (cch)
    {
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            sz,
            -1,
            ce.cc.wszDescription,
            sizeof(ce.cc.wszDescription) / sizeof(ce.cc.wszDescription[0]));
    }
    else
    {
        *ce.cc.wszDescription = 0;
    }

    return pMasterClock->AddClock(&ce);
}


// CreateSysClock
//
// Determine clock parameters if need be and create the appropriate type
// of system clock for this system.
//
HRESULT CreateSysClock(IReferenceClock **ppClock, CMasterClock *pMasterClock)
{
    HRESULT hr;

    switch (gSysClock)
    {
        case SYSCLOCK_WINMM:
        {
            TraceI(2, "Creating SysClock [WinMM]\n");
            CReferenceClockWinmm *pWinmmClock = new CReferenceClockWinmm;

            if (!pWinmmClock)
            {
                return E_OUTOFMEMORY;
            }

            hr = pWinmmClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
            pWinmmClock->Release();
            break;
        }
        
#ifdef _X86_
        case SYSCLOCK_PENTIMER:
        {
            TraceI(2, "Creating SysClock [PentTimer]\n");
            CReferenceClockPentium *pPentiumClock = new CReferenceClockPentium(gdwCycPer100ns);

            if (!pPentiumClock)
            {
                return E_OUTOFMEMORY;
            }

            hr = pPentiumClock->QueryInterface(IID_IReferenceClock, (void**)ppClock);
            pPentiumClock->Release();
            break;
        };
#endif

        case SYSCLOCK_UNKNOWN:
            TraceI(2, "CreateSysClock: Attempt to create w/o AddClock first??\n");
            return E_FAIL;
            break; 

        default:
            TraceI(0, "CreateSysClock: Unknown system clock type %d\n", (int)gSysClock);
            hr = E_FAIL;
            break;
    }

    return hr;
}

// ProbeClock
//
// Determine what type of clock to use. If we're on a Pentium (better be, it's required)
// then use the Pentium clock. This requires calibration.
//
// Otherwise fall back on timeGetTime. 
//
// Non-Intel compiles just default to setting the timeGetTime clock.
//
static void ProbeClock()
{
    int bIsPentium;


    // This code determines if we're running on a Pentium or better.
    //
    bIsPentium = 0;

#ifdef _X86_
    // First make sure this feature isn't disabled in the registry
    //

    HKEY hk;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue;
    BOOL fUsePentium;

    // Default to use Pentium clock if not specified
    //
    fUsePentium = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   REGSTR_PATH_DMUS_DEFAULTS,
                   &hk) == ERROR_SUCCESS)
    {
        cbValue = sizeof(dwValue);
        if (RegQueryValueEx(hk,
                            cszUsePentiumClock,
                            NULL,               // Reserved
                            &dwType,
                            (LPBYTE)&dwValue,
                            &cbValue) == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            cbValue == sizeof(DWORD))
        {
            fUsePentium = dwValue ? TRUE : FALSE;
        }

        RegCloseKey(hk);
    }

    // Only test for Pentium if allowed by the registry.
    //
    if (fUsePentium)
    {
        _asm 
        {
            pushfd                      // Store original EFLAGS on stack
            pop     eax                 // Get original EFLAGS in EAX
            mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
            xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
            push    eax                 // Save new EFLAGS value on stack
            popfd                       // Replace current EFLAGS value
            pushfd                      // Store new EFLAGS on stack
            pop     eax                 // Get new EFLAGS in EAX
            xor     eax, ecx            // Can we toggle ID bit?
            jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
            inc     dword ptr [bIsPentium]
Done:
        }
    }

#endif

    TraceI(2, "ProbeClock: bIsPentium %d\n", bIsPentium);

    if (!bIsPentium)
    {
        TraceI(2, "Using timeGetTime() as the system clock\n");
        gSysClock = SYSCLOCK_WINMM;
        return;        
    }

#ifdef _X86_
    TraceI(2, "Using the Pentium chip clock as the system clock\n");
    gSysClock = SYSCLOCK_PENTIMER;


    // If we have a Pentium, then we need to calibrate
    //
    _int64 cycStart;
    _int64 cycEnd;
    DWORD  msStart;
    DWORD  msEnd;

    // On NT, need this to make timeGetTime read with a reasonable accuracy
    //
    timeBeginPeriod(1);

    // Start as close to the start of a millisecond boundary as
    // possible.
    //
    msStart = timeGetTime() + 1;
    while (timeGetTime() < msStart)
        ;

    // Read the Pentium clock at that time
    //
    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycStart], eax
        mov     dword ptr [cycStart+4], edx
    }

    // Wait for the number of milliseconds until end of calibration
    // Again, we're trying to get the time right when the timer switches
    // to msEnd.
    //
    msEnd = msStart + MS_CALIBRATE;
    
    while (timeGetTime() < msEnd)
        ;

    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycEnd], eax
        mov     dword ptr [cycEnd+4], edx
    }

    // Done with the time critical part
    //
    timeEndPeriod(1);

    // We now know how many clock cycles per MS_CALIBRATE milliseconds. Use that
    // to figure out how many clock cycles per 100ns for IReferenceClock.
    //
    _int64 cycDelta = cycEnd - cycStart;
    
    gdwCycPer100ns = (DWORD)(cycDelta / (REFTIME_PER_MS * MS_CALIBRATE));

    TraceI(2, "ClockProbe: Processor clocked at %u Mhz\n", ((cycDelta / MS_CALIBRATE) + 500) / 1000);
#endif // _X86_
}


//////////////////////////////////////////////////////////////////////////////
//
// IReferenceClock wrapper for timeGetTime()
//
CReferenceClockWinmm::CReferenceClockWinmm() : m_cRef(1)
{
}

STDMETHODIMP
CReferenceClockWinmm::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CReferenceClockWinmm::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CReferenceClockWinmm::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CReferenceClockWinmm::GetTime(
    REFERENCE_TIME *pTime)
{
    *pTime = ((ULONGLONG)timeGetTime()) * (10L * 1000L);
    return S_OK;
}

STDMETHODIMP
CReferenceClockWinmm::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockWinmm::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockWinmm::Unadvise(
    DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}

#ifdef _X86_
//////////////////////////////////////////////////////////////////////////////
//
// IReferenceClock wrapper for Pentium clock
//
CReferenceClockPentium::CReferenceClockPentium(DWORD dwDivisor) : m_cRef(1)
{
    m_dwDivisor = dwDivisor;
}

STDMETHODIMP
CReferenceClockPentium::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(IReferenceClock::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CReferenceClockPentium::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CReferenceClockPentium::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CReferenceClockPentium::GetTime(
    REFERENCE_TIME *pTime)
{
    _int64 cycNow;

    _asm
    {
        RDTSC                       // Get the time in EDX:EAX
        mov     dword ptr [cycNow], eax
        mov     dword ptr [cycNow+4], edx
    }

    cycNow /= m_dwDivisor;

    *pTime = (DWORD)cycNow;

    return S_OK;
}

STDMETHODIMP
CReferenceClockPentium::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockPentium::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CReferenceClockPentium::Unadvise(
    DWORD dwAdviseCookie)
{
    return E_NOTIMPL;
}
#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmsport7.cpp ===
//
// dmsport7.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort7 implementation; code specific to DX-7 style ports
// 
#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "validate.h"
#include "debug.h"
#include "dmvoice.h"
#include "dmsport7.h"
#include "..\shared\dmusiccp.h" // For class ids.

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::CDirectMusicSynthPort7
//
//
CDirectMusicSynthPort7::CDirectMusicSynthPort7(
    PORTENTRY           *pe,
    CDirectMusic        *pDM,
    IDirectMusicSynth   *pSynth) :

        CDirectMusicSynthPort(pe, pDM, pSynth)
{
    m_pSynth = pSynth;
    m_pSynth->AddRef();

    m_pSink                     = NULL;
    m_fSinkUsesDSound           = false;
    m_fUsingDirectMusicDSound   = false;    
    m_pDirectSound              = NULL;
    m_pDirectSoundBuffer        = NULL;
    m_pwfex                     = NULL;
    m_lActivated                = 0;
    m_fHasActivated             = false;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::CDirectMusicSynthPort7
//
//
CDirectMusicSynthPort7::~CDirectMusicSynthPort7()
{
    Close();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::Initialize
//
//
HRESULT CDirectMusicSynthPort7::Initialize(
    DMUS_PORTPARAMS *pPortParams)
{
    HRESULT             hrOpen;

    HRESULT             hr = CDirectMusicSynthPort::Initialize(pPortParams);
	IReferenceClock*    pClock = NULL;

    // Create the sink
    //
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_DirectMusicSynthSink,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDirectMusicSynthSink,
                              (LPVOID*)&m_pSink);
        if (FAILED(hr))
        {
            TraceI(1, "CoCreateInstance sink %08X\n", hr);
        }
    }

    // Give the sink's IKsControl to the base class. This needs to be
    // done here since the sink is a different type between 7 and 8.
    //
    if (SUCCEEDED(hr))
    {
        IKsControl *pKsControl = NULL;

        HRESULT hrTemp = m_pSink->QueryInterface(
            IID_IKsControl, 
            (void**)&pKsControl);
        if (FAILED(hrTemp))
        {
            TraceI(2, "NOTE: Sink has no property set interface.\n");
        }

        SetSinkKsControl(pKsControl);
        RELEASE(pKsControl);
    }

    // Get the master clock and give it to the synth and sink
    //
    if (SUCCEEDED(hr))
    {	
	    hr = m_pDM->GetMasterClock(NULL, &pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to GetMasterClock %08X\n", hr);
        }
    }

    if (SUCCEEDED(hr)) 
    {
        hr = m_pSynth->SetMasterClock(pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to SetMasterClock on synth %08X\n", hr);
        }
    }        

    if (SUCCEEDED(hr)) 
    {
        hr = m_pSink->SetMasterClock(pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to SetMasterClock on sink %08X\n", hr);
        }
    }        

    // Connect sink to synth
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->SetSynthSink(m_pSink);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to SetSink on synth %08X\n", hr);
        }
    }

    // Open the synth. We have to be careful to save the return code because
    // if S_FALSE is returned here it must be returned to the caller.
    //
    if (SUCCEEDED(hr))
    {
    	hrOpen = m_pSynth->Open(pPortParams);
        if (FAILED(hrOpen))
        {
            hr = hrOpen;
            TraceI(1, "Failed to open synth %08lX\n", hr);
        }
    }

    // Initialize channel priorities and volume boost
    //
    if (SUCCEEDED(hr))
    {
        InitChannelPriorities(1, m_dwChannelGroups);
        InitializeVolumeBoost();
    }

    CacheSinkUsesDSound();

    RELEASE(pClock);

    return SUCCEEDED(hr) ? hrOpen : hr;
}       

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::Close
//
STDMETHODIMP CDirectMusicSynthPort7::Close()
{
    if (m_pSynth)
    {
        m_pSynth->Activate(FALSE);
        m_pSynth->Close();

        RELEASE(m_pSynth);
    }

    RELEASE(m_pSink);
    RELEASE(m_pDirectSoundBuffer);
    RELEASE(m_pDirectSound);

    delete[] m_pwfex;
    m_pwfex = NULL;

    CDirectMusicSynthPort::Close();

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::Activate
//
STDMETHODIMP CDirectMusicSynthPort7::Activate(
    BOOL fActivate)
{
    HRESULT hr;

	V_INAME(IDirectMusicPort::Activate);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1))
        {
            return S_FALSE;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0) 
        {
            return S_FALSE;
        }
    }
	
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (m_fSinkUsesDSound)
        {
            if (m_pDirectSound == NULL)
            {
                m_fUsingDirectMusicDSound = true;

                hr = m_pDM->GetDirectSoundI(&m_pDirectSound);
                if (FAILED(hr))
                {
                    m_pDirectSound = NULL;
                    m_fUsingDirectMusicDSound = false;
                    m_lActivated = 0;
                    return hr;
                }
            }

            hr = m_pSink->SetDirectSound(m_pDirectSound, m_pDirectSoundBuffer);
            if (FAILED(hr))
            {
                if (m_fUsingDirectMusicDSound)
                {
                    m_pDM->ReleaseDirectSoundI();
                    m_pDirectSound = NULL;
                }
                m_fUsingDirectMusicDSound = false;
                m_lActivated = 0;
                return hr;
            }
        }
    }

    hr = m_pSynth->Activate(fActivate);
    if (FAILED(hr))
    {
        // Flip back activate state -- operation failed
        //
        m_lActivated = fActivate ? 0 : 1;

        return hr;
    }

    // XXX Reset activation flags???
    //
    if (fActivate)
    {
        m_fHasActivated = true;
    }
    else
    {
        if (m_fSinkUsesDSound)
        {
            m_pSink->SetDirectSound(NULL, NULL);        
            if (m_fUsingDirectMusicDSound)
            {
                m_pDM->ReleaseDirectSoundI();
                m_pDirectSound = NULL;
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::KsProperty
//
STDMETHODIMP CDirectMusicSynthPort7::KsProperty(
    IN PKSPROPERTY  pProperty,
    IN ULONG        ulPropertyLength,
    IN OUT LPVOID   pvPropertyData,
    IN ULONG        ulDataLength,
    OUT PULONG      pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pProperty, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (pProperty->Set == GUID_DMUS_PROP_SetSynthSink &&
        pProperty->Id == 0)
    {
        if (pProperty->Flags & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if (ulDataLength < sizeof(ULONG))
            {
                return E_INVALIDARG;
            }
            else
            {
                *PULONG(pvPropertyData) = KSPROPERTY_TYPE_BASICSUPPORT |
                                          KSPROPERTY_TYPE_SET;
                *pulBytesReturned = sizeof(ULONG);
                return S_OK;
            }
        }
        else if (pProperty->Flags & KSPROPERTY_TYPE_GET)
        {
            return DMUS_E_GET_UNSUPPORTED;
        }

        // Trying to set a sink. Take care of it in the port
        //
        if (m_fHasActivated)
        {
            return DMUS_E_ALREADY_ACTIVATED;
        }

        if (ulDataLength != sizeof(LPUNKNOWN))
        {
            return E_INVALIDARG;
        }
            
        LPUNKNOWN pUnknown = *(LPUNKNOWN*)pvPropertyData;
        V_INTERFACE(pUnknown);

        IDirectMusicSynthSink *pSink;

        HRESULT hr;        
        hr = pUnknown->QueryInterface(IID_IDirectMusicSynthSink, (void**)&pSink);
        if (FAILED(hr))
        {
            return hr;
        }

        m_pSink->Release();
        m_pSink = pSink;
        m_pSink->AddRef();

        // Give synth sink master clock
        //
        IReferenceClock* pClock;
        
        hr = m_pDM->GetMasterClock(NULL, &pClock);

        if (FAILED(hr))
        {
            TraceI(1, "Failed to create master clock\n");
            return hr;
        }
        
        hr = m_pSink->SetMasterClock(pClock);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to set master clock on sink\n");
            return hr;
        }
        else
        {
            TraceI(1, "(KsProperty) Sink succeeded set master clock\n");
        }

        pClock->Release();

        hr = m_pSynth->SetSynthSink(m_pSink);
        if (FAILED(hr))
        {
            TraceI(1, "Failed to set sink on synth\n");
            return hr;
        }

        // Recache the sink property set interface
        //
        IKsControl *pKsControl = NULL;
        hr = m_pSink->QueryInterface(IID_IKsControl, (void**)&pKsControl);
        if (FAILED(hr))
        {
            TraceI(0, "Warning: Sink does not support IKsControl\n");
            pKsControl = NULL;
        }

        SetSinkKsControl(pKsControl);

        CacheSinkUsesDSound();

        return S_OK;
    }

    // All other properties run through the default handlers
    //
    return CDirectMusicSynthPort::KsProperty(
        pProperty,
        ulPropertyLength,
        pvPropertyData,
        ulDataLength,
        pulBytesReturned);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::GetFormat
//
STDMETHODIMP CDirectMusicSynthPort7::GetFormat(
    LPWAVEFORMATEX  pwfex,
    LPDWORD         pdwwfex,
    LPDWORD         pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    HRESULT hr = m_pSynth->GetFormat(pwfex, pdwwfex);
    if (FAILED(hr))
    {
        return hr;
    }

    //only get the buffer size if pcbBuffer is valid
    if (pcbBuffer != NULL)
    {
        hr = m_pSink->GetDesiredBufferSize(pcbBuffer);
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicPort7::SetDirectSound
//
STDMETHODIMP CDirectMusicSynthPort7::SetDirectSound(
    LPDIRECTSOUND       pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_INTERFACE_OPT(pDirectSoundBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_lActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    if (pDirectSoundBuffer && !pDirectSound)
    {
        return E_INVALIDARG;
    }

    if (m_pDirectSound)
    {
        if (m_fUsingDirectMusicDSound)
        {
            ((CDirectMusic*)m_pDM)->ReleaseDirectSoundI();
            m_pDirectSound = NULL;
        }
        else
        {
            m_pDirectSound->Release();
        }
    }

    if (m_pDirectSoundBuffer)
    {
        m_pDirectSoundBuffer->Release();
    }

    m_pDirectSound = pDirectSound;
    m_pDirectSoundBuffer = pDirectSoundBuffer;

    if (m_pDirectSound)
    {
        m_pDirectSound->AddRef();
    }

    if (m_pDirectSoundBuffer)
    {
        m_pDirectSoundBuffer->AddRef();
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort7::CacheSinkUsesDSound
//
void CDirectMusicSynthPort7::CacheSinkUsesDSound()
{
    m_fSinkUsesDSound = false;

    if (m_pSinkPropSet) 
    {
        HRESULT hr;
        KSPROPERTY ksp;
        ULONG ulUsesDSound;
        ULONG cb;

    	ZeroMemory(&ksp, sizeof(ksp));
    	ksp.Set   = GUID_DMUS_PROP_SinkUsesDSound;
    	ksp.Id    = 0;
    	ksp.Flags = KSPROPERTY_TYPE_GET;

        hr = m_pSinkPropSet->KsProperty(&ksp,
    				       	            sizeof(ksp),
    						            (LPVOID)&ulUsesDSound,
    						            sizeof(ulUsesDSound),
    						            &cb);
        if (SUCCEEDED(hr) && ulUsesDSound)
        {
            TraceI(2, "This synth sink uses DirectSound\n");
            m_fSinkUsesDSound = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmsport8.h ===
//
// dmsport8.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort8 implementation; code specific to DX-8 style ports
// 

#ifndef _DMSPORT8_H_
#define _DMSPORT8_H_

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8
//
class CDirectMusicSynthPort8 : public CDirectMusicSynthPort
{
public:
    CDirectMusicSynthPort8(
        PORTENTRY           *pe,
        CDirectMusic        *pDM,
        IDirectMusicSynth8  *pSynth);

    ~CDirectMusicSynthPort8();

    HRESULT Initialize(
        DMUS_PORTPARAMS *pPortParams);   

    // Overridden public methods
    //
    STDMETHODIMP Close();

    STDMETHODIMP Activate(
        BOOL fActivate);
        
    STDMETHODIMP SetDirectSound(
        LPDIRECTSOUND       pDirectSound,
        LPDIRECTSOUNDBUFFER pDirectSoundBuffer);

    STDMETHODIMP DownloadWave(
        IDirectSoundWave *pWave,               
        IDirectSoundDownloadedWaveP **ppWave,
        REFERENCE_TIME rtStartHint);

    STDMETHODIMP UnloadWave(
        IDirectSoundDownloadedWaveP *pDownloadedWave);

    STDMETHODIMP AllocVoice(
        IDirectSoundDownloadedWaveP  *pWave,     
        DWORD                       dwChannel,                       
        DWORD                       dwChannelGroup,                  
        REFERENCE_TIME              rtStart,                     
        SAMPLE_TIME                 stLoopStart,
        SAMPLE_TIME                 stLoopEnd,
        IDirectMusicVoiceP           **ppVoice);

    STDMETHODIMP AssignChannelToBuses(
        DWORD       dwChannelGroup,
        DWORD       dwChannel,
        LPDWORD     pdwBuses,
        DWORD       cBusCount);

    STDMETHODIMP StartVoice(          
        DWORD               dwVoiceId,
        DWORD               dwChannel,
        DWORD               dwChannelGroup,
        REFERENCE_TIME      rtStart,
        DWORD               dwDLId,
        LONG                prPitch,
        LONG                vrVolume,
        SAMPLE_TIME         stStartVoice,
        SAMPLE_TIME         stLoopStart,
        SAMPLE_TIME         stLoopEnd);

    STDMETHODIMP StopVoice(          
        DWORD               dwVoiceId,
        REFERENCE_TIME      rtStop);

    STDMETHODIMP GetVoiceState(
        DWORD               dwVoice[], 
        DWORD               cbVoice,
        DMUS_VOICE_STATE    VoiceState[]);

    STDMETHODIMP Refresh(
        DWORD   dwDownloadId,
        DWORD   dwFlags);

    STDMETHODIMP SetSink(
        LPDIRECTSOUNDCONNECT pSinkConnect);
        
    STDMETHODIMP GetSink(
        LPDIRECTSOUNDCONNECT* ppSinkConnect);

    STDMETHODIMP GetFormat(
        LPWAVEFORMATEX  pwfex,
        LPDWORD         pdwwfex,
        LPDWORD         pcbBuffer);
	
private:
    IDirectMusicSynth8     *m_pSynth;               // 8.0 Synth 
    bool                    m_fUsingDirectMusicDSound;
                                                    // Using default dsound
    LPDIRECTSOUND8          m_pDirectSound;         // Directsound object
    LPDIRECTSOUNDCONNECT    m_pSinkConnect;         // DirectSound sink
    LPDIRECTSOUNDBUFFER     m_pdsb[4];              // Sink buffers
    LPDIRECTSOUNDSOURCE     m_pSource;              // Synth's source
    
    static WAVEFORMATEX     s_wfexDefault;          // Default format
    
    bool                    m_fVSTStarted;          // Has voice service thread
                                                    //  been started?
    DWORD                   m_dwChannelGroups;      // How many channel groups
    
    LONG                    m_lActivated;           // Is port active?
    bool                    m_fHasActivated;        // Has ever activated?
    DWORD                   m_dwSampleRate;         // Sample rate for synth
    
private:
    HRESULT AllocDefaultSink();
    HRESULT CreateAndConnectDefaultSink();
};



#endif // _DMSPORT8_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmsport8.cpp ===
//
// dmsport8.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// CDirectMusicSynthPort8 implementation; code specific to DX-8 style ports
// 
#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>

#include "dmusicp.h"
#include "validate.h"
#include "debug.h"
#include "dmvoice.h"
#include "dmsport8.h"
#include "dsoundp.h"    // For IDirectSoundConnect

static const DWORD g_dwDefaultSampleRate = 22050;

WAVEFORMATEX CDirectMusicSynthPort8::s_wfexDefault = 
{
    WAVE_FORMAT_PCM,            // wFormatTag
    1,                          // nChannels
    g_dwDefaultSampleRate,      // nSamplesPerSec
    g_dwDefaultSampleRate * 2,  // nAvgBytesPerSec
    2,                          // nBlockAlign
    8 * 2,                      // wBitsPerSample
    0                           // cbSize
};

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::CDirectMusicSynthPort8
//
//
CDirectMusicSynthPort8::CDirectMusicSynthPort8(
    PORTENTRY           *pe,
    CDirectMusic        *pDM,
    IDirectMusicSynth8  *pSynth) :

        CDirectMusicSynthPort(pe, pDM, static_cast<IDirectMusicSynth*>(pSynth))
{
    m_pSynth = pSynth;
    m_pSynth->AddRef();

    m_fUsingDirectMusicDSound   = false;
    m_pDirectSound              = NULL;
    m_pSinkConnect              = NULL;
    m_fVSTStarted               = false;
    m_pSource                   = NULL;
    m_lActivated                = 0;
    m_fHasActivated             = false;
    m_dwSampleRate              = g_dwDefaultSampleRate;

    memset(m_pdsb, 0, sizeof(m_pdsb));

}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::CDirectMusicSynthPort8
//
//
CDirectMusicSynthPort8::~CDirectMusicSynthPort8()
{
    Close();
}
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Initialize
//
//
HRESULT CDirectMusicSynthPort8::Initialize(
    DMUS_PORTPARAMS     *pPortParams)
{
    HRESULT hr      = CDirectMusicSynthPort::Initialize(pPortParams);
    HRESULT hrOpen  = S_OK;

    if (m_pSynth == NULL) 
    {
        // XXX error code
        //
        return E_FAIL;
    }

    // We need DirectSound before connection now
    //
    LPDIRECTSOUND pDirectSound;

    hr = ((CDirectMusic*)m_pDM)->GetDirectSoundI(&pDirectSound);

    // Make sure we have DirectSound 8.
    //
    if (SUCCEEDED(hr))
    {
        hr = pDirectSound->QueryInterface(IID_IDirectSound8, (void**)&m_pDirectSound);
        RELEASE(pDirectSound);
    }

    if (SUCCEEDED(hr))
    {
        // Override default sample rate
        //
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE)
        {
            m_dwSampleRate = pPortParams->dwSampleRate;
        }
    }

    // Create and hand out the master clock
    //
	IReferenceClock* pClock = NULL;

    if (SUCCEEDED(hr))
    {
	    hr = m_pDM->GetMasterClock(NULL, &pClock);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->SetMasterClock(pClock);
        RELEASE(pClock);
    }

    // Start the voice service thread
    //
    if (SUCCEEDED(hr))
    {
        hr = CDirectMusicVoice::StartVoiceServiceThread((IDirectMusicPort*)this);
    }

    if (SUCCEEDED(hr))
    {
        m_fVSTStarted = true;
    }

    // Open the synth. We have to be careful to save the return code because
    // if S_FALSE is returned here it must be returned to the caller.
    //
    if (SUCCEEDED(hr))
    {
    	hrOpen = m_pSynth->Open(pPortParams);
        if (FAILED(hrOpen))
        {
            hr = hrOpen;
            TraceI(1, "Failed to open synth %08lX\n", hr);
        }
    }

    // Set up channel priorities and volume boost
    // 
    if (SUCCEEDED(hr))
    {    
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
        {
            m_dwChannelGroups = pPortParams->dwChannelGroups;
        }
        else
        {
            m_dwChannelGroups = 1;
        }

        InitChannelPriorities(1, m_dwChannelGroups);
        InitializeVolumeBoost();
    }

    // Save source so we can connect to it later
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->QueryInterface(IID_IDirectSoundSource, (void**)&m_pSource);
    }

    if (FAILED(hr))
    {
        Close();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Close
//
STDMETHODIMP CDirectMusicSynthPort8::Close()
{
    // Stop voice service thread
    //
    if (m_fVSTStarted)
    {
        CDirectMusicVoice::StopVoiceServiceThread((IDirectMusicPort*)this);
        m_fVSTStarted = FALSE;
    }
    
    // Turn off and close
    //
    if (m_pSynth) 
    {
        m_pSynth->Activate(false);
        m_pSynth->Close();
        RELEASE(m_pSynth);
    }

    // Force synth and sink to disassociate
    //
    if (m_pSinkConnect)
    {
        m_pSinkConnect->RemoveSource(m_pSource);
    }

    if (m_pSource) 
    {
        m_pSource->SetSink(NULL);            
    }

    // Release everything
    //
    RELEASE(m_pdsb[0]);
    RELEASE(m_pdsb[1]);
    RELEASE(m_pdsb[2]);
    RELEASE(m_pdsb[3]);

    RELEASE(m_pSinkConnect);
    RELEASE(m_pSource);
    RELEASE(m_pDirectSound);

    return CDirectMusicSynthPort::Close();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Activate
//
// XXX Write me
//
STDMETHODIMP CDirectMusicSynthPort8::Activate(
    BOOL fActivate)
{
    HRESULT hr = S_OK;

	V_INAME(IDirectMusicPort::Activate);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1))
        {
            return S_FALSE;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0) 
        {
            return S_FALSE;
        }
    }
	
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate && !m_pSinkConnect)
    {
        hr = CreateAndConnectDefaultSink();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pSynth->Activate(fActivate);
    }

    if (SUCCEEDED(hr))
    {
        m_fHasActivated = true;
    }
    else
    {
        // Flip back activate state -- operation failed
        //
        m_lActivated = fActivate ? 0 : 1;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::SetDirectSound
//
STDMETHODIMP CDirectMusicSynthPort8::SetDirectSound(
    LPDIRECTSOUND       pDirectSound,
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    V_INAME(IDirectMusicPort::SetDirectSound);
    V_INTERFACE(pDirectSound);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_lActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    if (pDirectSoundBuffer)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    IDirectSound8 *pDirectSound8;

    // Make sure we have an IDirectSound8, and as a side effect AddRef
    //
    hr = pDirectSound->QueryInterface(IID_IDirectSound8, (void**)&pDirectSound8);
    
    if (SUCCEEDED(hr))
    {
        RELEASE(m_pDirectSound);
        m_pDirectSound = pDirectSound8;
    }
        
    return hr;        
}
       
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::DownloadWave
//
STDMETHODIMP CDirectMusicSynthPort8::DownloadWave(
    IDirectSoundWave            *pWave,               
    IDirectSoundDownloadedWaveP  **ppWave,
    REFERENCE_TIME              rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    TraceI(1, "DownloadWave %08X\n", pWave);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }
	return CDirectMusicPortDownload::DownloadWaveP(pWave,
                                                   ppWave,
                                                   rtStartHint);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::UnloadWave
//
STDMETHODIMP CDirectMusicSynthPort8::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return CDirectMusicPortDownload::UnloadWaveP(pDownloadedWave);
}

            
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::AllocVoice
//
STDMETHODIMP CDirectMusicSynthPort8::AllocVoice(
    IDirectSoundDownloadedWaveP  *pWave,     
    DWORD                       dwChannel,                       
    DWORD                       dwChannelGroup,                  
    REFERENCE_TIME              rtStart,                     
    SAMPLE_TIME                 stLoopStart,
    SAMPLE_TIME                 stLoopEnd,         
    IDirectMusicVoiceP           **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return CDirectMusicPortDownload::AllocVoice(
        pWave,
        dwChannel,
        dwChannelGroup,
        rtStart,
        stLoopStart,
        stLoopEnd,
        ppVoice);
}        

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::AssignChannelToBuses
//
STDMETHODIMP CDirectMusicSynthPort8::AssignChannelToBuses(
    DWORD       dwChannelGroup,
    DWORD       dwChannel,
    LPDWORD     pdwBuses,
    DWORD       cBusCount)
{
    V_INAME(IDirectMusicPort::AssignChannelToBuses);
    V_BUFPTR_WRITE(pdwBuses, sizeof(DWORD) * cBusCount);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->AssignChannelToBuses(
        dwChannelGroup,
        dwChannel,
        pdwBuses,
        cBusCount);
}        


////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::StartVoice
//
STDMETHODIMP CDirectMusicSynthPort8::StartVoice(          
    DWORD               dwVoiceId,
    DWORD               dwChannel,
    DWORD               dwChannelGroup,
    REFERENCE_TIME      rtStart,
    DWORD               dwDLId,
    LONG                prPitch,
    LONG                vrVolume,
    SAMPLE_TIME         stVoiceStart, 
    SAMPLE_TIME         stLoopStart,
    SAMPLE_TIME         stLoopEnd)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    // XXX make cg/c order consistent
    // XXX make API names consistent
    //
    return m_pSynth->PlayVoice(rtStart,
                               dwVoiceId,
                               dwChannelGroup,
                               dwChannel,
                               dwDLId,
                               prPitch, 
                               vrVolume,
                               stVoiceStart,
                               stLoopStart,
                               stLoopEnd);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::StopVoice
//
STDMETHODIMP CDirectMusicSynthPort8::StopVoice(          
    DWORD               dwVoiceId,
    REFERENCE_TIME      rtStop)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->StopVoice(rtStop,
                               dwVoiceId);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::GetVoiceState
//
STDMETHODIMP CDirectMusicSynthPort8::GetVoiceState(
    DWORD               dwVoice[], 
    DWORD               cbVoice,
    DMUS_VOICE_STATE    VoiceState[])
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->GetVoiceState(dwVoice, cbVoice, VoiceState);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::Refresh
//
STDMETHODIMP CDirectMusicSynthPort8::Refresh(
    DWORD   dwDownloadId,
    DWORD   dwFlags)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    return m_pSynth->Refresh(dwDownloadId, dwFlags);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::SetSink
//
STDMETHODIMP CDirectMusicSynthPort8::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    V_INAME(IDirectMusicPort::SetSink);
    V_INTERFACE(pSinkConnect);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fHasActivated)
    {
        return DMUS_E_ALREADY_ACTIVATED;
    }

    // Do this in the order which permits the easiest backing out.
    HRESULT hr = pSinkConnect->AddSource(m_pSource);

    if (SUCCEEDED(hr))
    {
        hr = m_pSource->SetSink(pSinkConnect);
        if (FAILED(hr))
        {
            pSinkConnect->RemoveSource(m_pSource);
        }
    }
    
    if (SUCCEEDED(hr))
    {
        if (m_pSinkConnect)
        {
            m_pSinkConnect->RemoveSource(m_pSource);

            // This does nothing if the sink is already not ours.

            RELEASE(m_pdsb[0]);
            RELEASE(m_pdsb[1]);
            RELEASE(m_pdsb[2]);
            RELEASE(m_pdsb[3]);
        
            RELEASE(m_pSinkConnect);
        }

        pSinkConnect->AddRef();
        m_pSinkConnect = pSinkConnect;
    }


    // We've got the connection to the sink, let's set KSControl on the Sink
    if (SUCCEEDED(hr))
    {
        IKsControl *pKsControl = NULL;
        hr = m_pSinkConnect->QueryInterface(IID_IKsControl, (void**)&pKsControl);
        if (FAILED(hr))
        {
            TraceI(0, "Warning: Sink does not support IKsControl\n");
            pKsControl = NULL;
        }

        SetSinkKsControl(pKsControl);

        //The SetSinkKsControl does an AddRef() so we can release!
        RELEASE(pKsControl);
    }

    
    return hr;    
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::GetSink
//
STDMETHODIMP CDirectMusicSynthPort8::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    V_INAME(IDirectMusicPort::GetSink);
    V_PTRPTR_WRITE(ppSinkConnect);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *ppSinkConnect = m_pSinkConnect;
    m_pSinkConnect->AddRef();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::GetFormat
//
STDMETHODIMP CDirectMusicSynthPort8::GetFormat(
    LPWAVEFORMATEX  pwfex,
    LPDWORD         pdwwfex,
    LPDWORD         pcbBuffer)
{
    V_INAME(IDirectMusicPort::GetFormat);
    V_PTR_WRITE(pdwwfex, DWORD);
    V_BUFPTR_WRITE_OPT(pwfex, *pdwwfex);
    V_PTR_WRITE_OPT(pcbBuffer, DWORD);

    HRESULT hr = m_pSynth->GetFormat(pwfex, pdwwfex);
    if (FAILED(hr))
    {
        return hr;
    }

    //>>>>>>>>>>>> NEED A MEMTHOD IN SYNTH 
    if ((pcbBuffer != NULL) && (pwfex != NULL))
    {
        *pcbBuffer = 2/*DSBUFFER_LENGTH_SEC*/ * pwfex->nAvgBytesPerSec;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::CreateAndConnectDefaultSink
//
// INTERNAL
//
//
HRESULT CDirectMusicSynthPort8::CreateAndConnectDefaultSink()
{
    HRESULT             hr;

    hr = AllocDefaultSink();

    // Give the sink's IKsControl to the base class. This needs to be
    // done here since the sink is a different type between 7 and 8.
    //
    if (SUCCEEDED(hr))
    {
        IKsControl *pKsControl = NULL;

        HRESULT hrTemp = m_pSinkConnect->QueryInterface(
            IID_IKsControl, 
            (void**)&pKsControl);
        if (FAILED(hrTemp))
        {
            TraceI(2, "NOTE: Sink has no property set interface.\n");
        }

        SetSinkKsControl(pKsControl);
        RELEASE(pKsControl);
    }

    // Connect the two together
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pSource->SetSink(m_pSinkConnect);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pSinkConnect->AddSource(m_pSource);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicSynthPort8::AllocDefaultSink
//
// INTERNAL
//
// Try to allocate a default sink and buses, releasing any current sink.
//
// Caller guarantees the port has never been activated. 
//
HRESULT CDirectMusicSynthPort8::AllocDefaultSink()
{
    IDirectSoundConnect *pSinkConnect = NULL;
	IReferenceClock     *pClock = NULL;
    IDirectSoundBuffer  *pdsb[4];
	WAVEFORMATEX        wfex;

    assert(!m_fHasActivated);

    memset(pdsb, 0, sizeof(pdsb));

    // Create a sink
    //

	// initialize with default
	wfex = s_wfexDefault; 

	//XXX 
	//>>>> NOTE:PETCHEY
	// We should also able to create a mono sink 
	// pPortParams->dwAudioChannels
    wfex.nSamplesPerSec  = m_dwSampleRate;
    wfex.nAvgBytesPerSec = wfex.nSamplesPerSec * wfex.nChannels * (wfex.wBitsPerSample/8);              // 

    IDirectSoundPrivate* pDSPrivate;
    HRESULT hr = m_pDirectSound->QueryInterface(IID_IDirectSoundPrivate, (void**)&pDSPrivate);

    if (SUCCEEDED(hr))
    {
        hr = pDSPrivate->AllocSink(&wfex, &pSinkConnect);
        pDSPrivate->Release();
    }

    // Standard bus connections
    //  
    DSBUFFERDESC dsbd;
	DWORD dwbus;

    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;

		dwbus = DSBUSID_LEFT;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[0]);
    }

    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;

		dwbus = DSBUSID_RIGHT;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[1]);
    }
    
    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;

      //XXX Set up effect

		dwbus = DSBUSID_REVERB_SEND;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[2]);
    }
    
    if (SUCCEEDED(hr))
    {
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_GLOBALFOCUS;
        dsbd.lpwfxFormat = &wfex;
        
      //XXX Set up effect

		dwbus = DSBUSID_CHORUS_SEND;

        hr = pSinkConnect->CreateSoundBuffer(&dsbd, &dwbus, 1, GUID_NULL, &pdsb[3]);
    }

    // Master clock
    //
    if (SUCCEEDED(hr))
    {
	    hr = m_pDM->GetMasterClock(NULL, &pClock);
    }

    if (SUCCEEDED(hr))
    {
        hr = pSinkConnect->SetMasterClock(pClock);
        RELEASE(pClock);
    }

    // If we got this far then we are going to replace any existing sink
    // with the new one
    //
    if (SUCCEEDED(hr))
    {
		if (m_pSinkConnect && m_pSource)
		{
	        m_pSinkConnect->RemoveSource(m_pSource);
		}
        
        RELEASE(m_pdsb[0]);
        RELEASE(m_pdsb[1]);
        RELEASE(m_pdsb[2]);
        RELEASE(m_pdsb[3]);
    
        RELEASE(m_pSinkConnect);

        assert(sizeof(m_pdsb) == sizeof(pdsb));
        memcpy(m_pdsb, pdsb, sizeof(m_pdsb));

        m_pSinkConnect = pSinkConnect;
    }

    if (FAILED(hr))
    {
        RELEASE(pdsb[0]);
        RELEASE(pdsb[1]);
        RELEASE(pdsb[2]);
        RELEASE(pdsb[3]);
    
        RELEASE(pSinkConnect);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmusic.cpp ===
//
// DMusic.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
// @module DirectMusic | DirectMusic core services
//
// Provides the code DirectMusic services for delivering time-stamped data and managing
// DLS collections.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#define INITGUID
#include <objbase.h>
#include "debug.h"
#include <mmsystem.h>
#include "dlsstrm.h"
#include <regstr.h>
#include "oledll.h"

#include "dmusicp.h"
#include "..\dmusic32\dmusic32.h"
#include "debug.h"
#include "dmdlinst.h"
#include "dminstru.h"
#include "validate.h"
#include "dmusprop.h"

#include <string.h>

#ifdef UNICODE
#error This module cannot compile with UNICODE defined.
#endif



// @globalv:(INTERNAL) Registry key for description of synth
//
const char cszDescription[] = "Description";
const WCHAR cwszDescription[] = L"Description";

// @globalv:(INTERNAL) Format string for output ports under the legacy subtree
const char cszPortOut[] = "%s\\Out";
const WCHAR cwszPortOut[] = L"%s\\Out";

// @globalv:(INTERNAL) Format string for input ports under the legacy subtree
const char cszPortIn[] = "%s\\In";
const WCHAR cwszPortIn[] = L"%s\\In";

// @globalv:(INTERNAL) Key for the DirectMusic GUID anywhere in the registry
const char cszGUID[]   = "DMPortGUID";

// @globalv:(INTERNAL) Value for storing default output port
//
const char cszDefaultOutputPort[] = "DefaultOutputPort";

// @globalv:(INTERNAL) Value for turning off hw acceleration
//
const char cszDisableHWAcceleration[] = "DisableHWAcceleration";

//
//
const char cszDefaultToKernelSynth[] = "DefaultToMsKernelSynth";

// @globalv:(INTERNAL) Filename of the sysaudio device from Ring 3
const char cszSADName[] = "\\\\.\\sysaudio";

// @globalv:(INTERNAL) Entry point into Dmusic32.dll for enumeration of legacy devices
const char cszEnumLegacyDevices[] = "EnumLegacyDevices";

// @globalv:(INTERNAL) Entry point into Dmusic32.dll for creation of emulated port
const char cszCreateEmulatePort[] = "CreateCDirectMusicEmulatePort";

const GUID guidZero = {0};
static const int CLSID_STRING_SIZE = 39;

LONG CDirectMusic::m_lInstanceCount = 0;


// @doc EXTERNAL



// @mfunc:(INTERNAL) Constructor for <c CDirectMusic>
//
// @comm Just increments the global count of components.
//
CDirectMusic::CDirectMusic() :
    m_cRef(1),
    m_fDirectSound(0),
    m_cRefDirectSound(0),
    m_pDirectSound(NULL),
    m_fCreatedDirectSound(FALSE),
    m_nVersion(7)
{
    TraceI(2, "CDirectMusic::CDirectMusic()\n");
    InterlockedIncrement(&g_cComponent);
    InterlockedIncrement(&m_lInstanceCount);
}


// @mfunc:(INTERNAL) Destructor for <c CDirectMusic>
//
// @comm Decrements the global component counter and frees the port list.
//
CDirectMusic::~CDirectMusic()
{
    CNode<PORTENTRY *> *pNode;
    CNode<PORTENTRY *> *pNext;
    CNode<PORTDEST *> *pDest;
    CNode<PORTDEST *> *pNextDest;

    TraceI(2, "CDirectMusic::~CDirectMusic\n");

    InterlockedDecrement(&g_cComponent);
    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNext)
    {
        for (pDest = pNode->data->lstDestinations.GetListHead(); pDest; pDest = pNextDest)
        {
            pNextDest = pDest->pNext;
            delete[] pDest->data->pstrInstanceId;
            delete pDest->data;

            pNode->data->lstDestinations.RemoveNodeFromList(pDest);
            pDest = pNextDest;
        }

        pNext = pNode->pNext;
        delete pNode->data;
        m_lstDevices.RemoveNodeFromList(pNode);
    }

    /*CNode<IDirectMusicPort *> *pOpenNode;
    CNode<IDirectMusicPort *> *pOpenNext;

    // HACK HACK Close unreleased ports at exit HACK HACK
    //
    for (pOpenNode = m_lstOpenPorts.GetListHead(); pOpenNode; pOpenNode = pOpenNext)
    {
        pOpenNext = pOpenNode->pNext;
        IDirectMusicPort *pPort = pOpenNode->data;

        IDirectMusicPortPrivate *pPrivate;
        HRESULT hr = pPort->QueryInterface(IID_IDirectMusicPortPrivate, (LPVOID*)&pPrivate);

        if (SUCCEEDED(hr))
        {
            pPrivate->Close();
            pPrivate->Release();
        }

        m_lstOpenPorts.RemoveNodeFromList(pOpenNode);
    }*/

    if (m_pMasterClock)
    {
        m_pMasterClock->ReleasePrivate();
    }

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
    }

    if (InterlockedDecrement(&m_lInstanceCount) == 0 && g_hModuleKsUser)
    {
        HMODULE h = g_hModuleKsUser;
        g_hModuleKsUser  = NULL;

        FreeLibrary(h);
    }
}

// CDirectMusic::QueryInterface
//
//
STDMETHODIMP CDirectMusic::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(IDirectMusic::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusic || iid == IID_IDirectMusic2)
    {
        *ppv = static_cast<IDirectMusic*>(this);
    }
    else if (iid == IID_IDirectMusic8)
    {
        *ppv = static_cast<IDirectMusic8*>(this);
        m_nVersion = 8;
    }
    else if (iid == IID_IDirectMusicPortNotify)
    {
        *ppv = static_cast<IDirectMusicPortNotify*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CDirectMusic::AddRef
//
//
STDMETHODIMP_(ULONG) CDirectMusic::AddRef()
{
//    DebugBreak();
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusic::Release
//
//
STDMETHODIMP_(ULONG) CDirectMusic::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        if (m_lstOpenPorts.GetNodeCount() == 0)
        {
            delete this;
            return 0;
        }
    }

    return m_cRef;
}


// @mfunc:(INTERNAL) Initialization.
//
// Enumerate the WDM and legacy devices into the port list.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag E_NOINTERFACE | If there were no ports detected
// @flag E_OUTOFMEMORY | If there was insufficient memory to create the list
//
HRESULT CDirectMusic::Init()
{
    HRESULT hr = S_OK;

    m_pMasterClock = new CMasterClock;
    if (m_pMasterClock == NULL)
    {
        return E_OUTOFMEMORY;
    }

    m_pMasterClock->AddRefPrivate();

    hr = m_pMasterClock->Init();
    if (FAILED(hr))
    {
        TraceI(0, "Could not initialize clock stuff [%08X]\n", hr);
        return hr;
    }

    // Cache default port behavior
    //
    m_fDefaultToKernelSwSynth = FALSE;
    m_fDisableHWAcceleration = FALSE;

    HKEY hk;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      REGSTR_PATH_DIRECTMUSIC,
                      0L,
                      KEY_READ,
                      &hk))
    {
        DWORD dw;
        DWORD dwValue;

        DWORD cb = sizeof(dwValue);

        if (!RegQueryValueExA(
            hk,
            cszDefaultToKernelSynth,
            NULL,
            &dw,
            (LPBYTE)&dwValue,
            &cb))
        {
            if (dwValue)
            {
                Trace(0, "Default port set to Microsoft kernel synth by registry key\n");
                m_fDefaultToKernelSwSynth = TRUE;
            }
        }

        cb = sizeof(dwValue);

        if (!RegQueryValueExA(
            hk,
            cszDisableHWAcceleration,
            NULL,
            &dw,
            (LPBYTE)&dwValue,
            &cb))
        {
            if (dwValue)
            {
                Trace(0, "Hardware acceleration and kernel synthesizers disabled by registry key\n");
                m_fDisableHWAcceleration = TRUE;
            }
        }

        RegCloseKey(hk);
    }


    return hr == S_OK ? S_OK : E_NOINTERFACE;
}

// @mfunc:(INTERNAL) Update the port list.
//
// Enumerate the WDM and legacy devices into the port list.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no ports detected
// @flag E_OUTOFMEMORY | If there was insufficient memory to create the list
//
HRESULT CDirectMusic::UpdatePortList()
{
    CNode<PORTENTRY *> *pNode;
    CNode<PORTENTRY *> *pNext;
    CNode<PORTDEST *> *pDest;
    CNode<PORTDEST *> *pNextDest;
    HRESULT hr;

    TraceI(2, "UpdatePortList()\n");

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        pNode->data->fIsValid = FALSE;
    }

    // Only look for WDM devices if KS is around.
    //
    if (LoadKsUser())
    {
        TraceI(2, "Adding WDM devices\n");

        hr = AddWDMDevices();
        if (!SUCCEEDED(hr))
        {
            return hr;
        }
    }

    hr = AddLegacyDevices();
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = AddSoftwareSynths();
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNext)
    {
        pNext = pNode->pNext;

        // Validate data
        if(pNode->data == NULL)
        {
            return DMUS_E_NOT_INIT;
        }

        if (!pNode->data->fIsValid)
        {
            for (pDest = pNode->data->lstDestinations.GetListHead(); pDest; pDest = pNextDest)
            {
                pNextDest = pDest->pNext;

                if(pNextDest == NULL)
                {
                    return DMUS_E_NOT_INIT;
                }

                if(pNextDest->data == NULL)
                {
                    return DMUS_E_NOT_INIT;
                }

                delete[] pNextDest->data->pstrInstanceId;
                delete pNextDest->data;

                pNode->data->lstDestinations.RemoveNodeFromList(pDest);
                pDest = pNextDest;
            }

            delete pNode->data;
            m_lstDevices.RemoveNodeFromList(pNode);
        }
    }

    TraceI(1, "UpdatePortList() end: %d devices\n", m_lstDevices.GetNodeCount());

    return m_lstDevices.GetNodeCount() ? S_OK : S_FALSE;
}


// @mfunc:(INTERNAL) Update the port list with WDM devices enumerated via the
// System Audio Device (SAD).
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no devices found
// @flag E_OUTOFMEMORY | If there was insufficient memory to build the port list
//
// @comm This must be implemented.
//
const GUID guidMusicFormat = KSDATAFORMAT_TYPE_MUSIC;
const GUID guidMIDIFormat  = KSDATAFORMAT_SUBTYPE_DIRECTMUSIC;

HRESULT CDirectMusic::AddWDMDevices()
{
#ifdef USE_WDM_DRIVERS
    return EnumerateWDMDevices(this);
#else
    return S_FALSE;
#endif
}

static HRESULT AddDeviceCallback(
    VOID *pInstance,           // @parm 'this' pointer
    DMUS_PORTCAPS &dmpc,       // @parm The already filled in portcaps
    PORTTYPE pt,               // @parm The port type
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The Pin ID of the device or -1 if the device is a legacy device
    int idxNode,               // @parm The Node ID of the synthesizer node; ignored if this is a legacy device
    HKEY hkPortsRoot)          // @parm Where port information is stored in the registry
{
    CDirectMusic *pdm = (CDirectMusic*)pInstance;

    //This should never be called to add a WDM device
    assert(pt != ptWDMDevice);

    return pdm->AddDevice(dmpc,
                          pt,
                          idxDev,
                          idxPin,
                          idxNode,
                          FALSE,        // Legacy device is never the preferred device
                          hkPortsRoot,
                          NULL,
                          NULL);
}


// @mfunc:(INTERNAL) Update the port list with legacy devices enumerated via
// the WinMM MIDI API.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no devices found
// @flag E_OUTOFMEMORY | If there was insufficient memory to build the port list
//
// @comm This function needs to update the list rather than just add.
//
HRESULT CDirectMusic::AddLegacyDevices()
{
#ifdef WINNT
    return EnumLegacyDevices(this, AddDeviceCallback);
#else
    if ((!(g_fFlags & DMI_F_WIN9X)) ||
        (!LoadDmusic32()))
    {
        return S_FALSE;
    }

    PENUMLEGACYDEVICES peld = (PENUMLEGACYDEVICES)GetProcAddress(g_hModuleDM32,
                                                                 cszEnumLegacyDevices);

    if (NULL == peld)
    {
        TraceI(0, "Could not get EnumLegacyDevice entry point from DMusic32.dll!");
        return S_FALSE;
    }

    return (*peld)(this, AddDeviceCallback);
#endif
}

// @mfunc:(INTERNAL) Add software synthesizers from the registry.
//
//
HRESULT CDirectMusic::AddSoftwareSynths()
{
    HKEY hk;
    DWORD idxSynth;
    char szSynthGUID[256];
    HRESULT hr;
    CLSID clsid;
    DMUS_PORTCAPS dmpc;
    IDirectMusicSynth *pSynth;

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      REGSTR_PATH_SOFTWARESYNTHS,
                      0L,
                      KEY_READ,
                      &hk))
    {
        for (idxSynth = 0; !RegEnumKey(hk, idxSynth, szSynthGUID, sizeof(szSynthGUID)); ++idxSynth)
        {
            hr = StrToCLSID(szSynthGUID, clsid, sizeof(szSynthGUID));
            if (!SUCCEEDED(hr))
            {
                continue;
            }

            // Create a synth instance
            //
            hr = CoCreateInstance(clsid,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDirectMusicSynth,
                                  (LPVOID*)&pSynth);
            if (FAILED(hr))
            {
                TraceI(1, "Enum: Failed creation of synth %s hr=%08lX\n", szSynthGUID, hr);
                continue;
            }

            ZeroMemory(&dmpc, sizeof(dmpc));
            dmpc.dwSize = sizeof(dmpc);
            dmpc.guidPort = clsid;
            dmpc.dwType = DMUS_PORT_USER_MODE_SYNTH;

            hr = pSynth->GetPortCaps(&dmpc);
            if (FAILED(hr))
            {
                TraceI(1, "Enum: Synth %s returned %08lX for GetPortCaps\n", szSynthGUID, hr);
                pSynth->Release();
                continue;
            }

            if (dmpc.guidPort != clsid)
            {
                TraceI(0, "Enum: WARNING: Synth %s changed its CLSID!\n", szSynthGUID);
            }

            AddDevice(dmpc,
                      ptSoftwareSynth,
                      -1,
                      -1,
                      -1,
                      FALSE,
                      NULL,
                      NULL,
                      NULL);

            pSynth->Release();
        }

        RegCloseKey(hk);
    }

    return S_OK;
}


// @mfunc:(INTERNAL) Add one device to the master device list, possibly updating an existing
// entry.
//
// @rdesc One of the following
// @flag S_OK | On success
//
HRESULT CDirectMusic::AddDevice(
    DMUS_PORTCAPS &dmpc,       // @parm Already filled in port caps
    PORTTYPE pt,               // @parm The port type
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The pin # if this is a WDM device
    int idxNode,               // @parm The node # of the synth node if this is a WDM device
    BOOL fPrefDev,             // @parm This is on the preferred device
    HKEY hkPortsRoot,          // @parm Where port information is stored in the registry
    LPWSTR wszDIName,          // @parm The Device Interface name if this is a WDM Device.
    LPSTR pstrInstanceId)      // @parm The InstanceID if the device is a WDM device.
{
    CNode<PORTENTRY *> *pPortNode;
    PORTENTRY *pPort;
    BOOL fFound;
    HKEY hkPort;
    char szRegKey[sizeof(cszPortOut) + DMUS_MAX_DESCRIPTION + 1];
    WCHAR wszRegKey[sizeof(cszPortOut) + DMUS_MAX_DESCRIPTION + 1];
    DWORD cb;
    DWORD dw;
    BOOL fGotGUID;
    HRESULT hr;
    char sz[256];
    BOOL fGotRegKey;

    // First find out if this device is already in the list
    //
#ifdef DEBUG
    SafeWToA(sz, dmpc.wszDescription);

    TraceI(1, "AddDevice: Adding [%s] index %d class %d\n",
           sz,
           idxDev,
           dmpc.dwClass);
#endif

    for (pPortNode = m_lstDevices.GetListHead(), fFound = FALSE; pPortNode && !fFound; pPortNode = pPortNode->pNext)
    {
        pPort = pPortNode->data;

        if (pPort->type != pt || pPort->pc.dwClass != dmpc.dwClass)
        {
            continue;
        }

        switch(pt)
        {
            case ptWDMDevice:
                if (dmpc.guidPort == pPort->pc.guidPort)
                {
                    fFound = TRUE;
                }
                break;

            case ptLegacyDevice:
                if (!_wcsicmp(dmpc.wszDescription, pPort->pc.wszDescription))
                {
                    fFound = TRUE;
                }
                break;

            case ptSoftwareSynth:
                if (dmpc.guidPort == pPort->pc.guidPort)
                {
                    fFound = TRUE;
                }
                break;

            default:
                assert(FALSE);
        }
    }

    if (fFound)
    {
        // Already have an entry - just update the device index
        //
        TraceI(1, "AddDevice: Reusing entry\n");
        pPort->idxDevice = idxDev;
        pPort->idxPin = idxPin;
        pPort->fIsValid = TRUE;
        pPort->fPrefDev = fPrefDev;

        return S_OK;
    }

    // No existing entry - need to create a new one plus a GUID.
    //
    pPort = new PORTENTRY;
    if (NULL == pPort)
    {
        return E_OUTOFMEMORY;
    }

    //clean up the junk in the wszDIName member
    ZeroMemory(pPort->wszDIName,256 * sizeof(WCHAR));

    CopyMemory(&pPort->pc, &dmpc, sizeof(DMUS_PORTCAPS));

    fGotGUID = (dmpc.guidPort != guidZero) ? TRUE : FALSE;

    if (hkPortsRoot)
    {
        if (g_fFlags & DMI_F_WIN9X)
        {
            SafeWToA(sz, dmpc.wszDescription);
            wsprintfA(szRegKey,
                      dmpc.dwClass == DMUS_PC_INPUTCLASS ? cszPortIn : cszPortOut,
                      sz);
            fGotRegKey = !RegCreateKeyA(hkPortsRoot, szRegKey, &hkPort);
        }
        else
        {
            wsprintfW(wszRegKey,
                      dmpc.dwClass == DMUS_PC_INPUTCLASS ? cwszPortIn : cwszPortOut,
                      dmpc.wszDescription);
            fGotRegKey = !RegCreateKeyW(hkPortsRoot, wszRegKey, &hkPort);
        }

        if (fGotRegKey)
        {
            cb = sizeof(pPort->pc.guidPort);
            if (fGotGUID)
            {
                RegSetValueExA(hkPort, cszGUID, 0, REG_BINARY, (LPBYTE)&pPort->pc.guidPort, sizeof(pPort->pc.guidPort));
            }
            else if (RegQueryValueExA(hkPort, cszGUID, NULL, &dw, (LPBYTE)&pPort->pc.guidPort, &cb))
            {
                // No GUID yet for this device - create one
                //
                hr = UuidCreate(&pPort->pc.guidPort);
                if (SUCCEEDED(hr))
                {
                    TraceI(1, "AddDevice: Setting GUID in registry\n");
                    RegSetValueExA(hkPort, cszGUID, 0, REG_BINARY, (LPBYTE)&pPort->pc.guidPort, sizeof(pPort->pc.guidPort));
                    fGotGUID = TRUE;
                }
            }
            else
            {
                TraceI(1, "AddDevice: Pulled GUID from registry\n");
                fGotGUID = TRUE;
            }

            RegCloseKey(hkPort);
        }
    }

    if (!fGotGUID)
    {
        // Some registry call failed - get a one-time guid anyway
        //
        hr = UuidCreate(&pPort->pc.guidPort);
        if (SUCCEEDED(hr))
        {
            TraceI(1, "AddDevice: Registry failed, getting dynamic GUID\n");
            fGotGUID = TRUE;
        }
    }

    if (!fGotGUID)
    {
        TraceI(0, "AddDevice: Ignoring [%s]; could not get GUID!\n", dmpc.wszDescription);
        // Something really strange is failing
        //
        delete pPort;
        return E_OUTOFMEMORY;
    }

    TraceI(1, "AddDevice: Adding new list entry.\n");
    // We have an entry and a GUID, add other fields and put in the list
    //
    pPort->type = pt;
    pPort->fIsValid = TRUE;
    pPort->idxDevice = idxDev;
    pPort->idxPin = idxPin;
    pPort->idxNode = idxNode;
    pPort->fPrefDev = fPrefDev;
    pPort->fAudioDest = FALSE;

    //if we get a Device Interface name, copy it
    if (wszDIName != NULL)
    {
        wcscpy(pPort->wszDIName,wszDIName);
    }

    if (NULL == m_lstDevices.AddNodeToList(pPort))
    {
        delete pPort;
        return E_OUTOFMEMORY;
    }

    //One final piece of work.
    //If the device we added was a WDM device -- we need to check that the
    //destination port is up to date.

    if (pt == ptWDMDevice)
    {
        pPort->fAudioDest = TRUE;

        CNode<PORTDEST *> *pDestNode = NULL;
        PORTDEST *pDest = NULL;
        fFound = FALSE;

        for (pDestNode = pPort->lstDestinations.GetListHead(), fFound = FALSE;
             pDestNode && !fFound;
             pDestNode = pDestNode->pNext)
        {
            pDest = pDestNode->data;
            if (!strcmp(pDest->pstrInstanceId, pstrInstanceId))
            {
                fFound = TRUE;
            }
        }

        if (!fFound)
        {
            pDest = new PORTDEST;

            if (NULL == pDest) {
                return E_OUTOFMEMORY;
            }

            pDest->idxDevice = idxDev;
            pDest->idxPin = idxPin;
            pDest->idxNode = idxNode;
            pDest->fOnPrefDev = fPrefDev;

            pDest->pstrInstanceId = new char[strlen(pstrInstanceId) + 1];
            if (NULL == pDest->pstrInstanceId)
            {
                delete pDest;
                return E_OUTOFMEMORY;
            }
            strcpy(pDest->pstrInstanceId, pstrInstanceId);

            if (NULL == pPort->lstDestinations.AddNodeToList(pDest))
            {
                delete[] pDest->pstrInstanceId;
                delete pDest;
                return E_OUTOFMEMORY;
            }

            TraceI(1, "  This synth instance is on instance id %s\n", pstrInstanceId);
        }
    }

    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusic | EnumPort | Enumerates the available ports.
//
// @comm
//
// The IDirectMusic::EnumPort method enumerates and retrieves the
// capabilities of each DirectMusic port on the system.  Each time it is
// called, EnumPort returns information about a single port.
// Applications should not rely on or store the index number of a port.
// Rebooting, as well as adding and removing ports could cause the index
// number of a port to change.  The GUID identifying the port, however,
// does not change.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag S_FALSE | Invalid index number
// @flag E_POINTER | If the pPortCaps parameter was invalid
// @flag E_NOINTERFACE | If there were no ports to enumerate
// @flag E_INVALIDARG | If the <p lpPortCaps> struct is not the correct size
//
STDMETHODIMP CDirectMusic::EnumPort(
    DWORD dwIndex,                        // @parm Specifies the index of the port for which the capabilities are to be returned.
                                        // This parameter should be zero on the first call and then incremented by one in each
                                        // subsequent call until S_FALSE is returned.
    LPDMUS_PORTCAPS lpPortCaps)            // @parm Pointer to the <c DMUS_PORTCAPS>a structure to receive the capabilities of the port.
{

    CNode<PORTENTRY *> *pNode;

    V_INAME(IDirectMusic::EnumPort);
    V_STRUCTPTR_READ(lpPortCaps, DMUS_PORTCAPS);

    pNode = m_lstDevices.GetListHead();
    if (dwIndex == 0 || pNode == NULL)
    {
        UpdatePortList();
    }

    pNode = m_lstDevices.GetListHead();
    if (NULL == pNode)
    {
        return E_NOINTERFACE;
    }

    while (dwIndex-- && pNode)
    {
        pNode = pNode->pNext;
    }

    if (pNode == NULL)
    {
        return S_FALSE;
    }

    *lpPortCaps = pNode->data->pc;

    return S_OK;
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | CreateMusicBuffer | Creates a buffer which holds music data for input or output.
//
// @comm
//
// The IDirectMusic::CreateMusicBuffer method creates a
// DirectMusicBuffer object.  This buffer is then filled with music
// events to be sequenced or passed to IDirectMusicPort::Read to be
// filled with incoming music event.
//
//
// @rdesc Returns one of the following
//
// @flag S_OK | On success
// @flag E_POINTER | If any of the passed pointers is invalid.
// @flag E_INVALIDARG | If any of the other arguments is invalid
//
//
STDMETHODIMP CDirectMusic::CreateMusicBuffer(
    LPDMUS_BUFFERDESC pBufferDesc,           // @parm Address of the <c DMUS_BUFFERDESC> structure that contains
                                            // the description of the music buffer to be created.
    LPDIRECTMUSICBUFFER *ppBuffer,          // @parm Address of the IDirectMusicBuffer interface pointer if successful.
    LPUNKNOWN pUnkOuter)                    // @parm Address of the controlling object's IUnknown interface for COM
                                            // aggregation, or NULL if the interface is not aggregated. Most callers will pass NULL.
{
    V_INAME(IDirectMusic::CreateMusicBuffer);
    V_STRUCTPTR_READ(pBufferDesc, DMUS_BUFFERDESC);
    V_PTRPTR_WRITE(ppBuffer);
    V_PUNKOUTER_NOAGG(pUnkOuter);

    *ppBuffer = NULL;

    CDirectMusicBuffer *pBuffer = new CDirectMusicBuffer(*pBufferDesc);
    if (NULL == pBuffer)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pBuffer->Init();
    if (!SUCCEEDED(hr))
    {
        delete pBuffer;
        return hr;
    }

    *ppBuffer = pBuffer;

    return S_OK;
}

/*
 @method:(EXTERNAL) HRESULT | IDirectMusic | CreatePort | Creates a port to a hardware or software device for music input or output

 @comm

The IDirectMusic::CreatePort method is used to create a port object
for a particular DirectMusic port based on the GUID obtained through
the <om IDirectMusic::EnumPort> call.

The <p pPortParams> structure specifies parameters for the newly created port. If all parameters could not
be obtained, then the passed <p pPortParams> structure will be changed as follows to match the available
parameters of the port.

On entry, the dwValidParams field of the structure indicates which fields in the structure are valid. CreatePort
will never set flags in this field that the application did not set before the call. However, if the requested port
does not support a requested feature at all, then a flag may be cleared in dwValidParams, indicating that the
given field was ignored. In this case S_FALSE will be returned from the method instead of S_OK.

If the port supports a specified parameter, but the given value for the parameter is out of range, then the
parameter value in <p pPortParams> will be changed. In this case, the flag in dwValidParams will remain set, but
S_FALSE will be returned to indicate that the struct has been changed.

@ex For example, to request reverb and determine if it was obtained, an application might execute the following code:

    DMUS_PORTPARAMS params;
    ZeroMemory(&params, sizeof(params));
    params.dwSize = sizeof(params);
    params.dwValidParams = DMUS_PORTPARAMS_REVERB;
    params.fReverb = TRUE;

    HRESULT hr = pDirectMusic->CreatePort(guidPort, NULL, &params, &port, NULL);
    if (SUCCEEDED(hr))
    {
        fGotReverb = TRUE;

        if (hr == S_FALSE)
        {
            if (!(params.dwValidParams & DMUS_PORPARAMS_REVERB))
            {
                // Device does not know what reverb is
                //
                fGotReverb = FALSE;
            }
            else if (!params.fReverb)
            {
                // Device understands reverb, but could not allocate it
                //
                fGotReverb = FALSE;
            }
        }
    }


@rdesc Returns one of the following

@flag S_OK | On success
@flag S_FALSE | If the port was created, but some requested paramter is not available
@flag E_POINTER | If any of the passed pointers is invalid
@flag E_INVALIDARG | If the <p lpPortParams> struct is not the correct size
*/
STDMETHODIMP CDirectMusic::CreatePort(
    REFGUID rguidPort,              // @parm Reference to (C++) or address of (C) the GUID that identifies the
                                    // port for which the IDirectMusicPort interface is to be created.  This
                                    // parameter must be a GUID returned by <om IDirectMusic::EnumPort>.  If it
                                    // is GUID_NULL, then the returned port will be the port specified in
                                    // the registry.
                                    //

    LPDMUS_PORTPARAMS pPortParams,   // @parm The <c DMUS_PORTPARAMS> struct which contains open parameters for the port.

    LPDIRECTMUSICPORT *ppPort,      // @parm Address of the <i IDirectMusicPort> interface pointer if successful.

    LPUNKNOWN pUnkOuter)            // @parm Address of the controlling object's IUnknown interface for COM
                                    // aggregation, or NULL if the interface is not aggregated. Most callers will pass NULL.
{
    HRESULT                         hr;
    HRESULT                         hrInit;
#ifndef WINNT
    PCREATECDIRECTMUSICEMULATEPORT  pcdmep;
#endif
    DWORD                           dwParamsVer;

    V_INAME(IDirectMusic::CreatePort);
    V_PTRPTR_WRITE(ppPort);
    V_PUNKOUTER_NOAGG(pUnkOuter);
    V_REFGUID(rguidPort);

    V_STRUCTPTR_WRITE_VER(pPortParams, dwParamsVer);
    V_STRUCTPTR_WRITE_VER_CASE(DMUS_PORTPARAMS, 7);
    V_STRUCTPTR_WRITE_VER_CASE(DMUS_PORTPARAMS, 8);
    V_STRUCTPTR_WRITE_VER_END(DMUS_PORTPARAMS, pPortParams);

    GUID guid;

    if (!m_fDirectSound)
    {
        return DMUS_E_DSOUND_NOT_SET;
    }

    // First check for default port
    //
    if (rguidPort == GUID_NULL)
    {
        GetDefaultPortI(&guid);
    }
    else
    {
        guid = rguidPort;
    }

    *ppPort = NULL;

    // Find DMPORTCAP entry if there is one.
    //
    CNode<PORTENTRY *> *pNode;
    PORTENTRY *pCap = NULL;

    // If they used a cached GUID w/o calling EnumPort first, make sure we have
    // the list of ports up to date.
    //
    if (!m_lstDevices.GetListHead())
    {
        UpdatePortList();
    }

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pNode->data->pc.guidPort == guid)
        {
            pCap = pNode->data;
            break;
        }
    }

    if (!pCap)
    {
        return E_NOINTERFACE;
    }

    // Now create the correct port implementation
    //
    switch(pCap->type)
    {
#ifdef USE_WDM_DRIVERS
        case ptWDMDevice:
            hrInit = CreateCDirectMusicPort(pCap, this, pPortParams, ppPort);
            break;
#endif

        case ptLegacyDevice:
#ifdef WINNT
            hrInit = CreateCDirectMusicEmulatePort(pCap, this, pPortParams, ppPort);
#else
            TraceI(1, "Create legacy device\n");
            if ((!(g_fFlags & DMI_F_WIN9X)) ||
                (!LoadDmusic32()))
            {
                return E_NOINTERFACE;
            }

            pcdmep =
                (PCREATECDIRECTMUSICEMULATEPORT)GetProcAddress(g_hModuleDM32,
                                                               cszCreateEmulatePort);

            if (NULL == pcdmep)
            {
                TraceI(0, "Could not get CreateCDirectMusicEmulatePort from DMusic32.dll");
                return E_NOINTERFACE;
            }

            hrInit = (*pcdmep)(pCap, this, pPortParams, ppPort);
#endif
            break;

        case ptSoftwareSynth:
            TraceI(1, "Create software synth\n");

            hrInit = CreateCDirectMusicSynthPort(
                pCap,
                this,
                dwParamsVer,
                pPortParams,
                ppPort);

            break;

        default:
            TraceI(0, "Attempt to create a port with an unknown type %u\n", pCap->type);
            return E_NOINTERFACE;
    }

    if (FAILED(hrInit))
    {
        return hrInit;
    }

    // Only synth supports dwFeatures
    //
    if (pCap->type != ptSoftwareSynth && dwParamsVer >= 8)
    {
        DMUS_PORTPARAMS8 *pp8 = (DMUS_PORTPARAMS8*)pPortParams;

        if ((pp8->dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
            (pp8->dwFeatures != 0))
        {
            pp8->dwFeatures = 0;
            hrInit = S_FALSE;
        }
    }

    // Add port to the list of open ports
    //
    m_lstOpenPorts.AddNodeToList(*ppPort);

    // Set default volume setting
    //
    IKsControl *pControl;
    hr = (*ppPort)->QueryInterface(IID_IKsControl, (void**)&pControl);
    if (SUCCEEDED(hr))
    {
        KSPROPERTY ksp;
        LONG lVolume = 0;
        ULONG cb;

        ZeroMemory(&ksp, sizeof(ksp));
        ksp.Set   = KSPROPSETID_Synth;
        ksp.Id    = KSPROPERTY_SYNTH_VOLUME;
        ksp.Flags = KSPROPERTY_TYPE_SET;

        pControl->KsProperty(&ksp,
                             sizeof(ksp),
                             (LPVOID)&lVolume,
                             sizeof(lVolume),
                             &cb);
        pControl->Release();
    }

    // Possibly return S_FALSE if port initialization was not able to get all paramters
    //
    return hrInit;
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | SetDirectSound | Sets the default DirectSound for
// audio output.
//
// @comm
//
// This method must be called once and only once per instance of DirectMusic. The specified DirectSound
// will be the default used for rendering audio on all ports. This default can be overridden using
// the <om IDirectMusicPort::SetDirectSound> method.
//
// @rdesc Returns one of the following
// @flag S_OK | On success
// @flag E_POINTER | If pguidPort does not point to valid memory
//
STDMETHODIMP CDirectMusic::SetDirectSound(
    LPDIRECTSOUND pDirectSound,             // @parm Points to the DirectSound interface to use.
                                            // If this parameter is NULL, then SetDirectSound will
                                            // create a DirectSound to use. If a DirectSound interface
                                            // is provided, then the caller is responsible for
                                            // managing the DirectSound cooperative level.
    HWND hwnd)                              // @parm If <p pDirectSound> is NULL, then this parameter
                                            // will be used as the hwnd for DirectSound focus managment.
                                            // If the parameter is NULL, then the current foreground
                                            // window will be set as the focus window.
{
    V_INAME(IDirectMusic::SetDirectSound);
    V_INTERFACE_OPT(pDirectSound);
    V_HWND_OPT(hwnd);

    if (m_cRefDirectSound)
    {
        return DMUS_E_DSOUND_ALREADY_SET;
    }

    m_fDirectSound = 1;

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
    }

    if (pDirectSound)
    {
        pDirectSound->AddRef();
    }

    m_pDirectSound = pDirectSound;

    m_hWnd = hwnd;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// SetExternalMasterClock
//
// Let the caller specify their own IReferenceClock, overriding the default
// system one.
//
STDMETHODIMP CDirectMusic::SetExternalMasterClock(
    IReferenceClock *pClock)
{
    V_INAME(IDirectMusic::SetEsternalMasterClock);
    V_INTERFACE(pClock);

    return m_pMasterClock->SetMasterClock(pClock);
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | GetDefaultPort | Get the default output port
//
// @comm
//
// The IDirectMusic::GetDefaultPort method is used to determine what what port will be created if
// GUID_DMUS_DefaultPort is passed to <om IDirectMusic::CreatePort>.
//
// If the port specified in the registry does not
// exist, then the default output port will be the Microsoft Software Synthesizer. Otherwise,
// the port specified by the last call to SetDefaultPort will be returned. This setting is
// persistent across sessions.
//
// @rdesc Returns one of the following
// @flag S_OK | On success
// @flag E_POINTER | If pguidPort does not point to valid memory
//
STDMETHODIMP CDirectMusic::GetDefaultPort(
    LPGUID pguidPort)        // @parm Points to a GUID which will contain the default port GUID on success
{
    V_INAME(IDirectMusic::GetDefaultPort);
    V_PTR_WRITE(pguidPort, GUID);

    GetDefaultPortI(pguidPort);
    return S_OK;
}

// @method:(INTERNAL) HRESULT | CDirectMusic | GetDefaultPortI | Internal implementation of
// <om IDirectMusic::GetDefaultPort>.
//
// Internal implementation without parameter validation so <om IDirectMusic::CreatePort> can
// share the same code.
//
// This function cannot fail; it will just return CLSID_DirectMusicSynth on any error.
//
void CDirectMusic::GetDefaultPortI(
    GUID *pguidPort)
{
    CNode<PORTENTRY *> *pNode;
    BOOL fGotKernelSynth;

    // If they used a cached GUID w/o calling EnumPort first, make sure we have
    // the list of ports up to date.
    //
    if (!m_lstDevices.GetListHead())
    {
        UpdatePortList();
    }

    // If hardware acceleration is disabled, revert to 6.1 behavior -
    // just use our UM software synth
    //
    // If we have DX8, we must have an audio path synth. Since we have no
    // HW acceleration yet, this means forcing our SW Synth.
    //
    if (m_fDisableHWAcceleration || (m_nVersion >= 8))
    {
        *pguidPort = CLSID_DirectMusicSynth;
        return;
    }

    fGotKernelSynth = FALSE;
    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pNode->data->fPrefDev &&
            (pNode->data->pc.dwFlags & DMUS_PC_DLS))
        {
            *pguidPort = pNode->data->pc.guidPort;
            return;
        }

        if (pNode->data->pc.guidPort == GUID_WDMSynth &&
            m_fDefaultToKernelSwSynth)
        {
           fGotKernelSynth = TRUE;
        }
    }

    *pguidPort = fGotKernelSynth ? GUID_WDMSynth : CLSID_DirectMusicSynth;
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | Activate |
// Activates or deactivates all output ports created from this interface.
//
// @comm
//
// The IDirectMusic::Activate method tells DirectMusic when the ports
// allocated by the application should be enabled or disabled.
// Applications should call Activate(FALSE) when they lose input focus
// if they do not need to play music in the background.  This will allow
// another application that may have the input focus to have access to
// these port resources.  Once the application has input focus again, it
// should call Activate(TRUE) to enable all of its allocated ports.
// When the DirectMusic object is first created, its default state is
// set to active.  The state of any ports created with
// <om IDirectMusic::CreatePort> will reflect the current state of the
// DirectMusic object.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully
//
STDMETHODIMP
CDirectMusic::Activate(
    BOOL fActivate)                 // @parm Informs DirectMusic whether the allocated ports should be activated or deactivated.
                                    // @flag TRUE | Activate all port objects created with this instance of DirectMusic.
                                    // @flag FALSE | Deactivate all of the port objects created with this instance of DirectMusic.

{
    CNode<IDirectMusicPort*> *pNode;
    HRESULT hr = S_OK;
    HRESULT hrFirst = S_OK;

    for (pNode = m_lstOpenPorts.GetListHead(); pNode; pNode = pNode->pNext)
    {
        hr = pNode->data->Activate(fActivate);

        //record the first failure
        if (FAILED(hr) & SUCCEEDED(hrFirst))
        {
            hrFirst = hr;
        }

    }

    //if we are a post 7 version we'll return the hr of the
    //first failure.  If there were no failurs than we will
    //return S_OK.  Pre 7 versions, we'll return S_OK always.
    if (m_nVersion >= 8)
        return hrFirst;
    else
        return S_OK;
}


STDMETHODIMP
CDirectMusic::NotifyFinalRelease(
    IDirectMusicPort *pPort)
{
    CNode<IDirectMusicPort *> *pNode;

    TraceI(2, "CDirectMusic::NotifyFinalRelease\n");

    for (pNode = m_lstOpenPorts.GetListHead(); pNode; pNode = pNode->pNext)
    {
        if (pNode->data == pPort)
        {
            // NOTE: We DON'T Release here, because the matching Release to the port create AddRef
            // was the application Release which caused the port to turn around and call THIS function.
            //
            m_lstOpenPorts.RemoveNodeFromList(pNode);

            // If the last port just went away and DirectMusic was held open
            // by the ports, delete it
            //
            if (m_lstOpenPorts.GetNodeCount() == 0 && m_cRef == 0)
            {
                delete this;
            }

            return S_OK;
        }
    }

    TraceI(0, "CDirectMusic::NotifyFinalRelease(%p) - port not in list!", pPort);
    return E_INVALIDARG;
}




// @method:(EXTERNAL) HRESULT | IDirectMusic | EnumMasterClock | Enumerates the possible time sources for DirectMusic.
//
// @comm
//
// The IDirectMusic::EnumMasterClock method is used to enumerate and get
// the description of the clocks that DirectMusic can use as the master
// clock.  Each time it is called, this method retrieves information
// about a single clock.  Applications should not rely or store the
// index number of a clock.  Rebooting, as well as adding and removing
// hardware could cause the index number of a clock to change.
//
// The master clock is a high-resolution timer that is shared by all
// processes, devices, and applications that are using DirectMusic. The
// clock is used to synchronize all music playback in the system.  It is
// a standard <i IReferenceClock> that stores time as a 64-bit integer in
// increments of 100 nanoseconds. The <om IReferenceClock::GetTime> method
// returns the current time. The master clock must derive from a
// continuously running hardware source, usually the system crystal, but
// optionally a crystal on a hardware I/O device, for example the
// crystal used by a wave card for audio playback. All DirectMusic ports
// synchronize to this master clock.
//
// This sample code shows how to use this method. Similar code can be used to wrap
// the <om IDirectMusic::EnumPorts> method.
//
// DWORD idx;
// HRESULT hr;
// DMUS_CLOCKCAPS dmcc;
//
// for (;;)
// {
//     hr = pDirectMusic->EnumMasterClock(idx, &dmcc);
//     if (FAILED(hr))
//     {
//         // Something went wrong
//         break;
//     }
//
//     if (hr == S_FALSE)
//     {
//         // End of enumeration
//         break;
//     }
//
//     // Use dmcc
// }
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully
// @flag S_FALSE | Invalid index number
// @flag E_POINTER | If the pClockInfo pointer is invalid
// @flag E_INVALIDARG | If the <p lpClockInfo> struct is not the correct size
//
STDMETHODIMP
CDirectMusic::EnumMasterClock(
    DWORD           dwIndex,              // @parm Specifies the index of the clock for which the description is
                                        // to be returned.  This parameter should be zero on the first call
                                        // and then incremented by one in each subsequent call until S_FALSE is returned.
    LPDMUS_CLOCKINFO lpClockInfo)        // @parm Pointer to the <c DMUS_CLOCKINFO> structure to receive the description of the clock.
{
    DWORD dwVer;

    V_INAME(IDirectMusic::EnumMasterClock);

    V_STRUCTPTR_READ_VER(lpClockInfo, dwVer);
    V_STRUCTPTR_READ_VER_CASE(DMUS_CLOCKINFO, 7);
    V_STRUCTPTR_READ_VER_CASE(DMUS_CLOCKINFO, 8);
    V_STRUCTPTR_READ_VER_END(DMUS_CLOCKINFO, lpClockInfo);

    return m_pMasterClock->EnumMasterClock(dwIndex, lpClockInfo, dwVer);
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | GetMasterClock | Returns the GUID of and an <i IReferenceClock> interface to the current master clock.
//
// @comm
//
// The IDirectMusic::GetMasterClock method returns the GUID and/or the
// address of the <i IReferenceClock> interface pointer for the clock that
// is currently set as the DirectMusic master clock.  If a null pointer
// is passed for either of the pointer parameters below, this method
// assumes that that pointer value is not desired.  The <i IReferenceClock>
// interface pointer must be released once the application has finished
// using the interface.  See <om IDirectMusic::EnumMasterClock> for more
// information about the master clock.
//
// @rdesc Returns one of the following
//
// @flag S_OK | The operation completed successfully.
// @flag E_POINTER | If either pointer was invalid
//
STDMETHODIMP
CDirectMusic::GetMasterClock(
    LPGUID pguidClock,               // @parm Pointer to the memory to be filled in with the master clock's GUID.
    IReferenceClock **ppClock)      // @parm Address of the <i IReferenceClock> interface pointer for this clock.
{
    V_INAME(IDirectMusic::GetMasterClock);
    V_PTR_WRITE_OPT(pguidClock, GUID);
    V_PTRPTR_WRITE_OPT(ppClock);

    return m_pMasterClock->GetMasterClock(pguidClock, ppClock);
}

// @method:(EXTERNAL) HRESULT | IDirectMusic | SetMasterClock | Sets the global DirectMusic master clock.
//
// @comm
//
// The IDirectMusic::SetMasterClock sets the DirectMusic master clock to
// a specific clock based on a given GUID obtained through the
// <om IDirectMusic::EnumMasterClock> call.  There is only one master clock
// for all DirectMusic applications.  If another running application is
// also using DirectMusic, it will not be possible to change the master
// clock until that application is shut down.  See
// <om IDirectMusic::EnumMasterClock> for more information about the master
// clock.
//
// Most applications will not need to call SetMasterClock. It should not be called
// unless there is a compelling reason, such as a need to have very tight synchornization
// with a hardware timebase other than the system clock.
//
// @rdesc Returns one of the following
// @flag S_OK | The operation completed successfully.
//
STDMETHODIMP
CDirectMusic::SetMasterClock(
    REFGUID rguidClock)     // @parm Reference to (C++) or address of (C) the GUID that identifies the clock to
                            // set as the master clock for DirectMusic.  This parameter must be a GUID returned
                            // by <om IDirectMusic::EnumMasterClock>.
{
    V_INAME(IDirectMusic::SetMasterClock);
    V_REFGUID(rguidClock);

    return m_pMasterClock->SetMasterClock(rguidClock);

}

HRESULT CDirectMusic::GetDirectSoundI(
    LPDIRECTSOUND *ppDirectSound)
{
    if (InterlockedIncrement(&m_cRefDirectSound) == 1)
    {
        m_fCreatedDirectSound = FALSE;

        // If one is already created or given to us, use it
        //
        if (m_pDirectSound == NULL)
        {
            // No interface yet, create it
            //
            LPDIRECTSOUND8 pds = NULL;
            HRESULT hr = DirectSoundCreate8(NULL,
                                           &pds,
                                           NULL);
            if (FAILED(hr))
            {
                TraceI(0, "SetDirectSound: CreateDirectSound failed! %08X\n", hr);
                InterlockedDecrement(&m_cRefDirectSound);
                return hr;
            }

            hr = pds->QueryInterface(IID_IDirectSound, (void**)&m_pDirectSound);
            pds->Release();
            if (FAILED(hr))
            {
                TraceI(0, "SetDirectSound: CreateDirectSound failed! %08X\n", hr);
                InterlockedDecrement(&m_cRefDirectSound);
                return hr;
            }


            HWND hWnd = m_hWnd;

            if (!hWnd)
            {
                hWnd = GetForegroundWindow();

                if (!hWnd)
                {
                    hWnd = GetDesktopWindow();
                }
            }

            assert(hWnd);

            hr = m_pDirectSound->SetCooperativeLevel(
                hWnd,
                DSSCL_PRIORITY);

            if (FAILED(hr))
            {
                TraceI(0, "SetDirectSound: SetCooperativeLevel (DSCCL_PRIORITY) failed!\n");
                m_pDirectSound->Release();
                m_pDirectSound = NULL;

                InterlockedDecrement(&m_cRefDirectSound);
                return hr;
            }

            m_fCreatedDirectSound = TRUE;
        }
    }

    m_pDirectSound->AddRef();
    *ppDirectSound = m_pDirectSound;

    return S_OK;
}

void CDirectMusic::ReleaseDirectSoundI()
{
    if (m_pDirectSound == NULL)
    {
        // Hitting this assert means a port released one too many times
        //
        assert(m_pDirectSound);
        return;
    }

    // Release reference held by port
    //
    m_pDirectSound->Release();

    if (InterlockedDecrement(&m_cRefDirectSound) == 0 && m_fCreatedDirectSound)
    {
        // This was the last reference. If we created the DirectSound, release it
        //
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }
}

// CDirectMusic::GetPortByGUID
//
PORTENTRY *CDirectMusic::GetPortByGUID(GUID guid)
{
    CNode<PORTENTRY *> *pNode;
    PORTENTRY *pPort;

    for (pNode = m_lstDevices.GetListHead(); pNode; pNode = pNode->pNext)
    {
        pPort = pNode->data;

        if (pPort->pc.guidPort == guid)
        {
            return pPort;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmusicp.h ===
//
// DMusicP.H
//
// Private include for Dmusic.DLL
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//

#ifndef _DMUSICP_
#define _DMUSICP_

#include "tlist.h"
#include "alist.h"
#include "debug.h"
#include <devioctl.h>

#include "mmsystem.h"
#include "dsoundp.h"         // DSound must be before KS*.h

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "dmksctrl.h"

#include "dmusicc.h"
#include "dmusici.h"
#include "dmusics.h"
#include "..\shared\dmusiccp.h"

#include "dmdload.h"
#include "dmportdl.h"

#include <stddef.h>
#include "dmusprop.h"
#include "tpool.h"

#define RELEASE(x) { if (x) (x)->Release(); (x) = NULL; }

#define HRFromP(x) ((x) ? S_OK : E_OUTOFMEMORY)

extern char g_szFriendlyName[];             // Module friendly name
extern char g_szVerIndProgID[];             // and program ID w/ version
extern char g_szProgID[];                   // Just program ID
extern HMODULE g_hModule;                   // DLL module handle (dmusic.dll)
extern HMODULE g_hModuleDM32;               // dmusic32.dll module handle if loaded
extern HMODULE g_hModuleKsUser;             // ksuser.dll module handle if loaded
extern long g_cComponent;                   // Component count for server locking
extern long g_cLock;                        // Lock count for server locking
extern DWORD g_fFlags;                      // DMI_F_XXX flags

#define DMI_F_WIN9X     0x00000001          // Running on Win9x

#define DWORD_ROUNDUP(x) (((x) + 3) & ~3)
#define QWORD_ROUNDUP(x) (((x) + 7) & ~7)

// Array elements in X
//
#define ELES(x)          (sizeof(x) / sizeof((x)[0]))

#define SafeAToW(w,a) \
                      { mbstowcs(w, a, ELES(w) - 1); (w)[ ELES(w) - 1] = L'\0'; }

#define SafeWToA(a,w) \
                      { wcstombs(a, w, ELES(a) - 1); (a)[ ELES(a) - 1] = '\0'; }

// Driver message for NT. Determines the number of ports on a driver
//
#ifndef DRV_QUERYDRVENTRY
#define DRV_QUERYDRVENTRY (0x0801)
#endif

// For selector tiling, the tile info is 16 bits of sel[0] and 16 bits of count
#define TILE_SEL0(x)  (((DWORD)((x) & 0xffff0000)) >> 16)
#define TILE_P1616(x) ((DWORD)((x) & 0xffff0000))
#define TILE_COUNT(x) ((x) & 0x0000ffff)

// Where are things in our registry?
#define REGSTR_PATH_DIRECTMUSIC  	"Software\\Microsoft\\DirectMusic"
#define REGSTR_PATH_DMUS_DEFAULTS	REGSTR_PATH_DIRECTMUSIC "\\Defaults"


// @struct PORTENTRY | Entry in the linked list of ports
typedef enum
{
    ptWDMDevice,
    ptLegacyDevice,
    ptSoftwareSynth
} PORTTYPE;

typedef struct tagPORTDEST
{
    ULONG   idxDevice;
    ULONG   idxPin;
    ULONG   idxNode;
    LPSTR   pstrInstanceId;
    BOOL    fOnPrefDev;
} PORTDEST;

typedef struct tagPORTENTRY PORTENTRY;
struct tagPORTENTRY
{
    PORTTYPE type;       // @field What type of port is this?
    

    BOOL fIsValid;       // @field TRUE if this entry is still an active driver after
                         // rebuilding the port list.
    
    ULONG idxDevice;     // @field If the port is a legacy driver, contains the device ID.
    ULONG idxPin;        
    ULONG idxNode;
    
    BOOL fPrefDev;       // @field TRUE if this is a preferred device
    
                         // Filter and pin to open through SysAudio
    int nSysAudioDevInstance;
    int nFilterPin;

    DMUS_PORTCAPS pc;    // @field Contains the port capabilities which will be returned to the application
                         // upon enumeration of the device.
                         
    BOOL fAudioDest;     // @field True if this port can be connected to multiple audio
                         // destinations (WDM transform filter; i.e. kernel SW synth)

    CList<PORTDEST *> lstDestinations;

    WCHAR wszDIName[256]; //@field contains the DeviceName for WDM devices
};

class CMasterClock;
typedef struct tagCLOCKENTRY CLOCKENTRY;
typedef struct tagCLOCKENTRY *PCLOCKENTRY;

struct tagCLOCKENTRY
{
    BOOL fIsValid;
    DMUS_CLOCKINFO cc;
    HRESULT (*pfnGetInstance)(IReferenceClock **ppClock, CMasterClock *pMasterClock);
};

// This structure is held in shared memory. All instances of DirectMusic use it to ensure that
// the same master clock is in place.
//
#define CLOCKSHARE_F_LOCKED         0x00000001      // If clock is locked; i.e. cannot change

typedef struct tagCLOCKSHARE CLOCKSHARE;
struct tagCLOCKSHARE
{
    GUID        guidClock;          // Current master clock
    DWORD       dwFlags;            // CLOCKSHARE_F_xxx
};

// Private interface to get parameters associated with specific master clocks
//
#undef  INTERFACE
#define INTERFACE  IMasterClockPrivate
DECLARE_INTERFACE_(IMasterClockPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    // IDirectMusicKsClockPrivate
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, LPVOID pBuffer, DWORD cbSize) PURE;
};

// This class wraps the master clock and handles all the problems associated with only
// one instance per system.
//
class CMasterClock : public IReferenceClock, public IDirectSoundSinkSync, IMasterClockPrivate
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
	        			    REFERENCE_TIME streamTime,
			        	    HANDLE hEvent,            
				            DWORD * pdwAdviseCookie); 

    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					            REFERENCE_TIME periodTime,
					            HANDLE hSemaphore,   
					            DWORD * pdwAdviseCookie);

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);
    STDMETHODIMP GetParam(REFGUID rguidType, 
                          LPVOID pBuffer, 
                          DWORD cbSize);
                          
    // IDirectSoundSyncSink
    //
    STDMETHODIMP SetClockOffset(LONGLONG llOffset);                         
    
    
    // Used by DirectMusic for communication with the
    // implementation
    //
    CMasterClock();
    ~CMasterClock();
    HRESULT Init();
    HRESULT GetMasterClockInterface(IReferenceClock **ppClock);
    
    HRESULT EnumMasterClock(DWORD dwIndex, LPDMUS_CLOCKINFO lpClockInfo, DWORD dwVer);
    HRESULT GetMasterClock(LPGUID pguidClock, IReferenceClock **ppClock);
    HRESULT SetMasterClock(REFGUID rguidClock);
    HRESULT SetMasterClock(IReferenceClock *pClock);
   
    LONG AddRefPrivate();
    LONG ReleasePrivate();
    
    HRESULT AddClock(PCLOCKENTRY pClock);
    
    // For clocks (Dsound clock) which need a clean clock to sync on
    //
    HRESULT CreateDefaultMasterClock(IReferenceClock **ppReferenceClock);


private:
    void Close();
    HRESULT UpdateClockList();
    void SyncToExternalClock();
    HRESULT CreateMasterClock();
    

private:
    LONG m_cRef;            // Ref count of wrapped clock
    LONG m_cRefPrivate;     // Ref count of CMasterClock object
    
    CList<CLOCKENTRY *>   m_lstClocks;
        
    GUID                  m_guidMasterClock;
    IReferenceClock      *m_pMasterClock;
    IDirectSoundSinkSync *m_pSinkSync;
    HANDLE                m_hClockMemory;
    HANDLE                m_hClockMutex;
    CLOCKSHARE           *m_pClockMemory;
    
    IReferenceClock      *m_pExtMasterClock;
    LONGLONG              m_llExtOffset;
};


// Helper functions for clocks
//
HRESULT AddSysClocks(CMasterClock *);
HRESULT AddDsClocks(CMasterClock *);
HRESULT AddPcClocks(CMasterClock *);
#ifdef DEAD_CODE
HRESULT AddKsClocks(CMasterClock *);
#endif

//HRESULT CreateSysClock(IReferenceClock **ppClock);

// IDirectMusicPortNotify
//
// A port uses this (private) interface from IDirectMusic to notify IDirectMusic when it goes away.
// 
#undef  INTERFACE
#define INTERFACE  IDirectMusicPortNotify
DECLARE_INTERFACE_(IDirectMusicPortNotify, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectMusicPortNotify
    STDMETHOD(NotifyFinalRelease)   (THIS_ IDirectMusicPort *pPort) PURE;
};

#define MIDI_CHANNELS               16

// DMEVENT as buffered by IDirectMusicBuffer
//
#include <pshpack4.h>
struct DMEVENT : public DMUS_EVENTHEADER
{
    BYTE        abEvent[sizeof(DWORD)];
};
#include <poppack.h>

// Encapsulated for queueing
//
struct QUEUED_EVENT
{
    QUEUED_EVENT    *pNext;
    DMEVENT         e;
};

#define QUEUED_EVENT_SIZE(cbEvent)  (DMUS_EVENT_SIZE(cbEvent) + sizeof(QUEUED_EVENT) - sizeof(DMEVENT))

// Free pool of 4-byte events
//
typedef CPool<QUEUED_EVENT> EVENT_POOL;

class EVENT_QUEUE
{
public:
    EVENT_QUEUE() { pFront = pRear = NULL; }
    
    QUEUED_EVENT    *pFront;
    QUEUED_EVENT    *pRear;
};

// How long to wait for the capture thread to die
//
#define THREAD_KILL_TIMEOUT         5000

// How big is the capture thread's work buffer?
//
#define THREAD_WORK_BUFFER_SIZE     4096

#define QWORD_ALIGN(x) (((x) + 7) & ~7)

typedef struct _DMUS_THRU_CHANNEL *LPDMUS_THRU_CHANNEL;
typedef struct _DMUS_THRU_CHANNEL
{
    DWORD               dwDestinationChannel;
    DWORD               dwDestinationChannelGroup;
    IDirectMusicPort    *pDestinationPort;
    BOOL                fThruInWin16;
} DMUS_THRU_CHANNEL;



// IDirectMusicPortPrivate
//
// A port implements this interface to expose methods to DirectMusic which are not exposed to the
// outside world
//
#undef  INTERFACE
#define INTERFACE  IDirectMusicPortPrivate
DECLARE_INTERFACE_(IDirectMusicPortPrivate, IUnknown)
{
	// IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectMusicPortPrivate
    STDMETHOD(Close)                (THIS_) PURE;
    
    // Voice management
    //
    STDMETHOD(StartVoice)          
        (THIS_
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG veVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd
        ) PURE;

    STDMETHOD(StopVoice)          
        (THIS_
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop
        ) PURE;
        
    STDMETHOD(GetVoiceState)     
        (THIS_ DWORD dwVoice[], 
         DWORD cbVoice,
         DMUS_VOICE_STATE dwVoiceState[] 
        ) PURE;
        
    STDMETHOD(Refresh)
        (THIS_ DWORD dwDownloadID,
         DWORD dwFlags
        ) PURE;        
};

// @class Implementation of IDirectMusic
//
class CDirectMusic : public IDirectMusic8, public IDirectMusicPortNotify {
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusic
    //
    STDMETHODIMP EnumPort(DWORD dwIdx, LPDMUS_PORTCAPS lpPortCaps);
    STDMETHODIMP CreateMusicBuffer(LPDMUS_BUFFERDESC pBufferDesc, LPDIRECTMUSICBUFFER *ppBuffer, LPUNKNOWN pUnkOuter);
    STDMETHODIMP CreatePort(REFGUID ruidPort, LPDMUS_PORTPARAMS pPortParams, LPDIRECTMUSICPORT *ppPort, LPUNKNOWN pUnkOuter);
    STDMETHODIMP EnumMasterClock(DWORD dwIndex, LPDMUS_CLOCKINFO lpClockInfo);
    // NOTE: This is a GUID* rather than REFGUID so they can pass NULL if they don't care
    //
    STDMETHODIMP GetMasterClock(GUID *guidClock, IReferenceClock **ppReferenceClock);
    STDMETHODIMP SetMasterClock(REFGUID guidClock);
    STDMETHODIMP Activate(BOOL fEnable);
	STDMETHODIMP GetDefaultPort(GUID *guidPort);
	STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, HWND hwnd);
    STDMETHODIMP SetExternalMasterClock(IReferenceClock *pClock);
    

    // IDirectMusicPortNotify
    //
    STDMETHODIMP NotifyFinalRelease(IDirectMusicPort *pPort);
    

    // Class
    //
    CDirectMusic();
    ~CDirectMusic();
    HRESULT Init();
    HRESULT UpdatePortList();
    HRESULT AddWDMDevices();
    HRESULT AddLegacyDevices();
    HRESULT AddSoftwareSynths();
    HRESULT AddDevice(DMUS_PORTCAPS &dmpc, 
                      PORTTYPE pt, 
                      int idxDev, 
                      int idxPin, 
                      int idxNode, 
                      BOOL fIsPreferred, 
                      HKEY hkPortsRoot, 
                      LPWSTR wszDIName, 
                      LPSTR pstrInstanceId);
    HRESULT InitClockList();
    HRESULT UpdateClockList();
    HRESULT AddClock(DMUS_CLOCKINFO &dmcc);
	void GetDefaultPortI(GUID *pguidPort);

    HRESULT GetDirectSoundI(LPDIRECTSOUND *ppDirectSound);
    void ReleaseDirectSoundI();
    PORTENTRY *GetPortByGUID(GUID guid);
    
    inline CMasterClock *GetMasterClockWrapperI()
    { return m_pMasterClock; }
    
private:
    long m_cRef;                                // Reference count
    
    CList<PORTENTRY *> m_lstDevices;            // Enumerated ports
    CList<IDirectMusicPort *> m_lstOpenPorts;   // Open ports

    CMasterClock *m_pMasterClock;               // Current master clock

    long m_fDirectSound;                        // Has SetDirectSound been called?  
    BOOL m_fCreatedDirectSound;                 // True if DirectMusic was the one that created DirectSound  
    long m_cRefDirectSound;                     // Internal refs against DirectSound
    LPDIRECTSOUND m_pDirectSound;               // The DirectSound object, either from app or created
    HWND m_hWnd;                                // hWnd for DirectSound focus management    
    BOOL m_fDefaultToKernelSwSynth;             // (Reg) Default to kernel synth
    BOOL m_fDisableHWAcceleration;              // (Reg) Don't use any kernel devices
    BOOL m_nVersion;                            // DX Version QI'd for

    static LONG m_lInstanceCount;               // How many are there?
};

// WDM port
//
extern HRESULT
CreateCDirectMusicPort(
                       PORTENTRY *pPE, 
                       CDirectMusic *pDM, 
                       LPDMUS_PORTPARAMS pPortParams,
                       IDirectMusicPort **ppPort);

#define OVERLAPPED_ARRAY_SIZE 200

struct OverlappedStructs
{
    OVERLAPPED  aOverlappedIO[OVERLAPPED_ARRAY_SIZE];// Array of overlapped structures
    BOOL        afOverlappedInUse[OVERLAPPED_ARRAY_SIZE];// Array of flags set when correspondin overlapped structure is in use
    BYTE       *apOverlappedBuffer[OVERLAPPED_ARRAY_SIZE];// Array of buffers that store the events we sent down
};

class CPortLatencyClock;
class CDirectMusicPort : 
    public CDirectMusicPortDownload, 
    public IDirectMusicThru,
    public IDirectMusicPort, 
    public IDirectMusicPortP, 
    public IDirectMusicPortPrivate, 
    public IKsControl
{
friend DWORD WINAPI FreeWDMHandle(LPVOID);
friend DWORD WINAPI CaptureThread(LPVOID);

friend class CPortLatencyClock;
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);
	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInstrument,
	    							IDirectMusicDownloadedInstrument** pDownloadedInstrument,
									DMUS_NOTERANGE* NoteRanges,
									DWORD dwNumNoteRanges);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument* pDownloadedInstrument);

    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate);
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);
    
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, DWORD dwSourceChannel, DWORD dwDestinationChannelGroup, DWORD dwDestinationChannel, LPDIRECTMUSICPORT pDestinationPort);

    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IN  IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IN  IDirectSoundDownloadedWaveP *pWave,     
         IN  DWORD dwChannel,                       
         IN  DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,         
         OUT IDirectMusicVoiceP **ppVoice            
        );        
        
    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBusses,
         IN DWORD cBussCount
        );        

    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
       );        

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
       );        

    // IKsControl
    //
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    // Override two methods from CDirectMusicPortDownload
	virtual STDMETHODIMP Download(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP Unload(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();
    
    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd);

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop);
    
    STDMETHODIMP GetVoiceState(
        DWORD dwVoice[], 
        DWORD cbVoice,
        DMUS_VOICE_STATE dwVoicePos[]);
         
    STDMETHODIMP Refresh(
        DWORD dwDownloadID,
        DWORD dwFlags);
        
    // Class
    //
    CDirectMusicPort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicPort();
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

private:
    // General port stuff
    //
    long                    m_cRef;                 // Reference count
	CDirectMusic            *m_pDM;                 // Owning DirectMusic object
    BOOL                    m_fIsOutput;            // Capture or render port
    IDirectMusicPortNotify  *m_pNotify;             // Notification interface on destruction
    DMUS_PORTCAPS           dmpc;                   // Caps as given to EnumPort
    BOOL                    m_fHasActivated;        // Has this port ever been activated?
    LONG                    m_lActivated;           // Activation count
    LPDIRECTSOUND           m_pDirectSound;         // DirectSound object for destination
    DWORD                   m_dwChannelGroups;      // Channel groups allocated
    GUID                    m_guidPort;             // GUID associated with port
    BOOL                    m_fAudioDest;           // There was a destination found 
    BOOL                    m_fDirectSoundSet;      // DirectSound object was set by app
    BOOL                    m_fCanDownload;         // This port supports downloads
    
    // WDM stuff
    //
    DWORD                   m_idxDev;               // SysAudio: Device number
    DWORD                   m_idxPin;               // SysAudio: Pin number
    DWORD                   m_idxSynthNode;         // SysAudio: Node number of synth node
    HANDLE                  m_hSysAudio;            // Handle to sysaudio instance
    HANDLE                  m_hPin;                 // Handle to pin
    ULONG                   m_ulVirtualSourceIndex; // Virtual source index for volume
    CList<OverlappedStructs *> m_lstOverlappedStructs;// List of arrays of overlapped structures and flags
    CRITICAL_SECTION        m_OverlappedCriticalSection;// Overlapped structure access critical section
    
    // Clock stuff
    //
    IReferenceClock         *m_pMasterClock;        // Master clock wrapped by this port
    CPortLatencyClock       *m_pClock;              // Implementation of latency clock
    
    // DLS download tracking stuff
    //
	HANDLE                  m_hUnloadThread;        // Thread for unloading async downloads
	HANDLE                  *m_phUnloadEventList;   // Event array of async downloads
	HANDLE                  *m_phNewUnloadEventList;// ??? Wobert - investigate 
	HANDLE                  m_hCopiedEventList;     // ???
	DWORD                   m_dwNumEvents;          // ???
	DWORD                   m_dwNumEventsAllocated; // ???
	CDLBufferList           m_UnloadedList;         // ???
    
	CRITICAL_SECTION        m_DMPortCriticalSection;// Port critical section
    BOOL                    m_fPortCSInitialized;   // Critical section initialized properly
    
    // Capture stuff
    //
    HANDLE                  m_hCaptureWake;         // Wake capture thread up to die
    HANDLE                  m_hCaptureThread;       // Capture thread handle
    BOOL                    m_fShutdownThread;      // Flag capture thread to die
    EVENT_POOL              m_FreeEvents;           // Free 4-byte events for capture thread
    EVENT_QUEUE             m_ReadEvents;           // Events captured, waiting to be read
    CRITICAL_SECTION        m_csEventQueues;        // CS protects event queues
    BOOL                    m_fQueueCSInitialized;  // CS properly initialized
    HANDLE                  m_hAppEvent;            // Application event to kick on new capture data
    
    // Thruing stuff
    //
    IDirectMusicBuffer      *m_pThruBuffer;         // Temp buffer to use for thruing 
    LPDMUS_THRU_CHANNEL     m_pThruMap;             // Thruing channel/mute map
    
    // Clock sync stuff
    //
    bool                    m_fSyncToMaster;        // Need to sync to master clock
    LONGLONG                m_lTimeOffset;          // Time difference
    IReferenceClock        *m_pPCClock;             // PortCls clock
    
private:
    BOOL PinSetState(KSSTATE DeviceState);
    HRESULT InitializeDownloadObjects();
    HRESULT InitializeCapture();
	void FreeWDMHandle();
    void CaptureThread();
    void InputWorkerDataReady(REFERENCE_TIME rtStart, LPBYTE pbData, ULONG cbData);
    void ThruEvent(DMEVENT *pEvent);
    void InitChannelPriorities(UINT uLoCG, UINT uHighCG);
    HRESULT SetDirectSoundI(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer,
        BOOL fSetByUser);
    void MasterToSlave(REFERENCE_TIME *);
    void SlaveToMaster(REFERENCE_TIME *);
    void SyncClocks();
};

class CPortLatencyClock : public IReferenceClock
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    virtual STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    virtual STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
				    REFERENCE_TIME streamTime,
				    HANDLE hEvent,            
				    DWORD * pdwAdviseCookie); 

    virtual STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					REFERENCE_TIME periodTime,
					HANDLE hSemaphore,   
					DWORD * pdwAdviseCookie);

    virtual STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CPortLatencyClock(HANDLE hPin, ULONG ulNodeId, CDirectMusicPort *port);
    ~CPortLatencyClock();

private:
    long m_cRef;                   
    HANDLE m_hPin;                  
    ULONG m_ulNodeId;
    CDirectMusicPort *m_pPort;
};

// Synth port
//
extern HRESULT 
CreateCDirectMusicSynthPort(
    PORTENTRY               *pe, 
    CDirectMusic            *pDM, 
    UINT                    uVersion,
    DMUS_PORTPARAMS         *pPortParams,
    IDirectMusicPort        **ppPort);
class CDirectMusicSynthPort : 
    public CDirectMusicPortDownload, 
    public IDirectMusicPort, 
    public IDirectMusicPortP, 
    public IDirectMusicPortPrivate, 
    public IKsControl
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);

	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInstrument,
							 			    IDirectMusicDownloadedInstrument** pDownloadedInstrument,
											DMUS_NOTERANGE* NoteRanges,
											DWORD dwNumNoteRanges);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument* pDownloadedInstrument);

    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate) PURE;
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);

    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IDirectSoundDownloadedWaveP *pWave,     
         DWORD dwChannel,                       
         DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,         
         IDirectMusicVoiceP **ppVoice            
        );        

    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBusses,
         IN DWORD cBussCount
        );        
        
    // IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
       );        

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
       );        

    virtual STDMETHODIMP Download(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP Unload(IDirectMusicDownload* pIDMDownload);
	virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();

    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart, 
         DWORD dwDLId,
         LONG prPitch,
         LONG vrVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd);

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop);
    
    STDMETHODIMP GetVoiceState(
        DWORD dwVoice[], 
        DWORD cbVoice,
        DMUS_VOICE_STATE dwVoiceState[]);

    STDMETHODIMP Refresh(
        DWORD dwDownloadID,
        DWORD dwFlags);

    // Class
    //
    static HRESULT CreateSynthPort(
        PORTENTRY               *pe, 
        CDirectMusic            *pDM, 
        UINT                    uVersion,
        DMUS_PORTPARAMS         *pPortParams,
        CDirectMusicSynthPort   **ppPort);
    
    CDirectMusicSynthPort(
        PORTENTRY               *pPE, 
        CDirectMusic            *pDM,
        IDirectMusicSynth       *pSynth);
        
    virtual ~CDirectMusicSynthPort();
    
protected:    
    HRESULT Initialize(LPDMUS_PORTPARAMS pPortParams);
    void InitChannelPriorities(UINT uLoCG, UINT uHighCG);
    void InitializeVolumeBoost();
    void SetSinkKsControl(IKsControl *pSinkKsControl);
    
protected:
    long                        m_cRef;             // COM reference count
    CDirectMusic                *m_pDM;             // Owning DirectMusic object
    IDirectMusicPortNotify      *m_pNotify;         // Notification interface
    IKsControl                  *m_pSynthPropSet;   // Synth property set
    IKsControl                  *m_pSinkPropSet;    //  and sink property set
    IDirectMusicSynth           *m_pSynth;          // Base level synth iface
    DWORD                       m_dwChannelGroups;  // Cached #channel groups
    DMUS_PORTCAPS               m_dmpc;
    DWORD                       m_dwFeatures;       // Features from portparams
};


// IDirectMusicBuffer implementation.
//
// Common to emulation/WDM.
//
class CDirectMusicBuffer : public IDirectMusicBuffer
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicBuffer
    //
    virtual STDMETHODIMP Flush();
    virtual STDMETHODIMP TotalTime(LPREFERENCE_TIME pdwTime);
    virtual STDMETHODIMP PackStructured(REFERENCE_TIME rt, DWORD dwChannelGroup, DWORD dwMsg);
    virtual STDMETHODIMP PackUnstructured(REFERENCE_TIME rt, DWORD dwChannelGroup, DWORD cb, LPBYTE lpb);
    virtual STDMETHODIMP ResetReadPtr();
    virtual STDMETHODIMP GetNextEvent(LPREFERENCE_TIME, LPDWORD, LPDWORD, LPBYTE *);
    
    virtual STDMETHODIMP GetRawBufferPtr(LPBYTE *);
    virtual STDMETHODIMP GetStartTime(LPREFERENCE_TIME);
    virtual STDMETHODIMP GetUsedBytes(LPDWORD);
    virtual STDMETHODIMP GetMaxBytes(LPDWORD);
    virtual STDMETHODIMP GetBufferFormat(LPGUID pGuidFormat);

    virtual STDMETHODIMP SetStartTime(REFERENCE_TIME);
    virtual STDMETHODIMP SetUsedBytes(DWORD);
    
    
    // Class
    //
    CDirectMusicBuffer(DMUS_BUFFERDESC &dmbd);
    ~CDirectMusicBuffer();
    HRESULT Init();
    DMUS_EVENTHEADER *AllocEventHeader(REFERENCE_TIME rt, DWORD cbEvent, DWORD dwChannelGroup, DWORD dwFlags);

private:
    long m_cRef;
    REFERENCE_TIME m_rtBase;
    REFERENCE_TIME m_totalTime;
    LPBYTE m_pbContents;
    DWORD m_maxContents;
    DWORD m_cbContents;
    DWORD m_idxRead;
    DMUS_BUFFERDESC m_BufferDesc;

    DWORD m_nEvents;
};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicFactory() : m_cRef(1) {}

    // Destructor
    // ~CMathFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicCollectionFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
	CDirectMusicCollectionFactory() : m_cRef(0) {AddRef();}

	// Destructor
	 ~CDirectMusicCollectionFactory() {} 

private:
	long m_cRef;
};


#ifdef USE_WDM_DRIVERS
// Enumeration of WDM devices
//
HRESULT EnumerateWDMDevices(CDirectMusic *pDirectMusic);
#endif


// Helper functions for dealing with SysAudio
//
BOOL OpenDefaultDevice(REFGUID rguidCategory, HANDLE *pHandle);
BOOL GetSysAudioProperty(HANDLE hFileObject, ULONG PropertyId, ULONG DeviceIndex, ULONG cbProperty, PVOID pProperty);
BOOL SetSysAudioProperty(HANDLE hFileObject, ULONG PropertyId, ULONG cbProperty, PVOID pProperty);
BOOL GetPinProperty(HANDLE pFileObject, ULONG PropertyId, ULONG PinId, ULONG cbProperty, PVOID pProperty);
BOOL SetPinProperty(HANDLE pFileObject, ULONG PropertyId, ULONG PinId, ULONG cbProperty, PVOID pProperty);
BOOL GetPinPropertyEx(HANDLE hFileObject, ULONG PropertyId, ULONG PinId, PVOID *ppProperty);
BOOL IsEqualInterface(const KSPIN_INTERFACE *pInterface1, const KSPIN_INTERFACE *pInterface2);
HRESULT CreatePin(HANDLE handleFilter, ULONG ulPinId, HANDLE *pHandle);
BOOL GetSizedProperty(HANDLE handle, ULONG ulPropSize, PKSPROPERTY pKsProperty, PVOID* ppvBuffer, PULONG pulBytesReturned);
BOOL Property(HANDLE handle, ULONG ulPropSize, PKSPROPERTY pKsProperty, ULONG ulBufferSize, PVOID pvBuffer, PULONG pulBytesReturned);
BOOL SyncIoctl(HANDLE handle, ULONG ulIoctl, PVOID pvInBuffer, ULONG ulInSize, PVOID   pvOutBuffer, ULONG ulOutSize, PULONG pulBytesReturned);

BOOL GetSysAudioDeviceCount(HANDLE hSysAudio, PULONG pulDeviceCount);
BOOL SetSysAudioDevice(HANDLE hSysAudio, ULONG idxDevice);
BOOL CreateVirtualSource(HANDLE hSysAudio, PULONG pulSourceIndex);
BOOL AttachVirtualSource(HANDLE hPin, ULONG ulSourceIndex);
int  FindGuidNode(HANDLE hSysAudio, ULONG ulPinId, REFGUID rguid);
BOOL GetFilterCaps(HANDLE hSysAudio, ULONG idxNode, PSYNTHCAPS pcaps);
BOOL GetNumPinTypes(HANDLE hSysAudio, PULONG pulPinTypes);
BOOL PinSupportsInterface(HANDLE hSysAudio, ULONG ulPinId, REFGUID rguidInterface, ULONG ulId);
BOOL PinSupportsDataRange(HANDLE hSysAudio, ULONG ulPinId, REFGUID rguidFormat, REFGUID rguidSubformat);
BOOL PinGetDataFlow(HANDLE hSysAudio, ULONG ulPinId, PKSPIN_DATAFLOW pkspdf);
BOOL GetDeviceFriendlyName(HANDLE hSysAudio, ULONG ulDeviceIndex, PWCHAR pwch, ULONG cbwch);
BOOL GetDeviceInterfaceName(HANDLE hSysAudio, ULONG ulDeviceIndex, PWCHAR pwch, ULONG cbwch);
BOOL DINameToInstanceId(char *pstrDIName, char **ppInstanceId);
BOOL InstanceIdOfPreferredAudioDevice(char **ppInstanceId);

// Helper functions for dealing with DirectSound
//
HRESULT DirectSoundDevice(LPDIRECTSOUND pDirectSound, LPSTR *pstrInterface);

HRESULT WIN32ERRORtoHRESULT(DWORD dwError);

// Helper functions from DMDLL.CPP
//
BOOL LoadDmusic32(void);
BOOL LoadKsUser(void);

DEFINE_GUID(GUID_Mapper,					 0x58d58418, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_SysClock,					 0x58d58419, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortNotify,		 0x58d5841a, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortPrivate,	 0x58d5841c, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_KsClock,					 0x58d5841d, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IMasterClockPrivate,         0x58d5841e, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_KsClockHandle,              0x58d5841f, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_WDMSynth,                   0x490a03e8, 0x742f, 0x11d2, 0x8f, 0x8a, 0x00, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(GUID_DsClock,                    0x58d58420, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_ExtClock,                   0x58d58421, 0x71b4, 0x11d1, 0xa7, 0x4c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);


#if 0
// List o' unused UUID's
58d58422-71b4-11d1-a74c-0000f875ac12
58d58423-71b4-11d1-a74c-0000f875ac12
58d58424-71b4-11d1-a74c-0000f875ac12
58d58425-71b4-11d1-a74c-0000f875ac12
58d58426-71b4-11d1-a74c-0000f875ac12
58d58427-71b4-11d1-a74c-0000f875ac12
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmvoice.h ===
//
// dmvoice.h
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Support for IDirectMusicVoice
//
//
#ifndef _DMVOICE_H_
#define _DMVOICE_H_

class CDirectMusicVoice;
class CVSTClient;

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoiceList
//
// Type-safe wrapper for AList of CDirectMusicVoice's
//
class CDirectMusicVoiceList : public AList
{
public:
    inline CDirectMusicVoice *GetHead();
    inline void AddTail(CDirectMusicVoice *pdmv);
    inline void Remove(CDirectMusicVoice *pdmv);
};

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClientList
//
// Type-safe wrapper for AList of CVSTClient's
//
class CVSTClientList : public AList
{
public:
    inline CVSTClient *GetHead();
    inline void AddTail(CVSTClient *pc);
    inline void Remove(CVSTClient *pc);
};

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient
//
// Tracks one client (port) of the voice service thread.
//
class CVSTClient : public AListItem
{
public:
    // NOTE: No reference count to avoid circular count
    // Port will free its client before shutdown
    //
    CVSTClient(IDirectMusicPort *pPort);
    ~CVSTClient();
    
    HRESULT BuildVoiceIdList();
    
    HRESULT GetVoiceState(DMUS_VOICE_STATE **ppsp);
    
    inline CDirectMusicVoice *GetVoiceListHead() 
    { return static_cast<CDirectMusicVoice*>(m_VoiceList.GetHead()); }
    
    inline void AddTail(CDirectMusicVoice *pVoice)
    { m_VoiceList.AddTail(pVoice); }
    
    inline void Remove(CDirectMusicVoice *pVoice)
    { m_VoiceList.Remove(pVoice); }
    
    inline IDirectMusicPort *GetPort() const 
    { return m_pPort; }
    
    inline CVSTClient *GetNext()
    { return static_cast<CVSTClient*>(AListItem::GetNext()); }
    
private:
    IDirectMusicPort       *m_pPort;            // Client pointer
    CDirectMusicVoiceList   m_VoiceList;        // List of playing voices
    DWORD                  *m_pdwVoiceIds;      // Voice IDs of this client
    DMUS_VOICE_STATE       *m_pspVoices;        // Queried sample position
    LONG                    m_cVoiceIds;        // How many voice ID's
    LONG                    m_cVoiceIdsAlloc;   // How many slots allocated
    
    static const UINT       m_cAllocSize;       // Allocation block size
};

// Base class for IDirectMusicVoice. Contains the functionality for
// being in the voice service list.
//
class CDirectMusicVoice : public IDirectMusicVoiceP, public AListItem
{
public:
   
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IDirectMusicVoice
    //
    STDMETHODIMP Play
        (THIS_
         REFERENCE_TIME rtStart,                // Time to play
         LONG prPitch,                          // Initial pitch
         LONG veVolume                          // Initial volume
        );
    
    STDMETHODIMP Stop
        (THIS_
          REFERENCE_TIME rtStop                 // When to stop
        );
    
    // Class
    //        
    CDirectMusicVoice(
        CDirectMusicPortDownload *pPortDL,
        IDirectSoundDownloadedWaveP *pWave,
        DWORD dwChannel,
        DWORD dwChannelGroup,
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtReadAhead,
        SAMPLE_TIME stLoopStart,
        SAMPLE_TIME stLoopEnd);    
    ~CDirectMusicVoice();        

    HRESULT Init();        
    
    inline DWORD GetVoiceId() const
    { return m_dwVoiceId; } 
        
    inline CDirectMusicVoice *GetNext() 
    { return static_cast<CDirectMusicVoice*>(AListItem::GetNext()); }
    
    
    static DWORD m_dwNextVoiceId;                      // Global: Next voice ID
    
    static inline DWORD AllocVoiceId(DWORD nIDs)
    {
        EnterCriticalSection(&m_csVST);
            DWORD dwID = m_dwNextVoiceId;
            m_dwNextVoiceId += nIDs;
        LeaveCriticalSection(&m_csVST);

        return dwID;
    }
    
    static HRESULT StartVoiceServiceThread(IDirectMusicPort *pPort);
    static HRESULT StopVoiceServiceThread(IDirectMusicPort *pPort);
    static inline void UpdateVoiceServiceThread()
    { assert(m_hVSTWakeUp); SetEvent(m_hVSTWakeUp); }

private:
    LONG                        m_cRef;             // Reference count
    DWORD                       m_dwVoiceId;        // Voice id
    DWORD                       m_dwDLId;           // Download ID to trigger
    IDirectMusicPort            *m_pPort;           // What port attached to
    CDirectMusicPortDownload    *m_pPortDL;         //  and its download
    IDirectMusicPortPrivate     *m_pPortPrivate;    //  its private interface
    IDirectSoundDownloadedWaveP *m_pDSDLWave;       // Downloaded wave
    DWORD                       m_dwChannel;        // Channel and channel group
    DWORD                       m_dwChannelGroup;   //  to play on
    SAMPLE_TIME                 m_stStart;          // Starting point
    SAMPLE_TIME                 m_stReadAhead;      // Read ahead (buffer length)
    DWORD                       m_msReadAhead;      // Read ahead in milliseconds
    SAMPLE_TIME                 m_stLoopStart;      // Loop points
    SAMPLE_TIME                 m_stLoopEnd;

    CDirectSoundWaveDownload    *m_pDSWD;           // Download instance    
    DWORD                       m_nChannels;        // Channels in wave
    bool                        m_fIsPlaying;       // Is this voice playing?       
                                                    // (streaming voices)
    bool                        m_fRunning;         // Has streamed voice started playing?
    bool                        m_fIsStreaming;     // Cached from owning wave                                                    
    
    // Voice service thread
    //
    friend DWORD WINAPI VoiceServiceThreadThk(LPVOID);
    static void VoiceServiceThread();
    
    static LONG                 m_cRefVST;          // Voice Service Thread 
                                                    // refcount (1 per open port)
    static HANDLE               m_hVSTWakeUp;       // Wake up for any reason
    static HANDLE               m_hVSTThread;       // Thread handle
    static DWORD                m_dwVSTThreadId;    //  and id                                                        
    static bool                 m_fVSTStopping;     // Time to kill the VST
    static CVSTClientList       m_ClientList;       // List of open ports which
                                                    //  want VST services
    
public:    
    static CRITICAL_SECTION     m_csVST;            // VST Critical section
    
private:
    // Override GetNext list operator
    //    
    static void ServiceVoiceQueue(bool *pfRecalcTimeout);
    static DWORD VoiceQueueMinReadahead();
    static CVSTClient *FindClientByPort(IDirectMusicPort *pPort);
};

inline CDirectMusicVoice *CDirectMusicVoiceList::GetHead()
{ return (CDirectMusicVoice*)AList::GetHead(); }

inline void CDirectMusicVoiceList::AddTail(CDirectMusicVoice *pdmv)
{ AList::AddTail(static_cast<AListItem*>(pdmv)); }

inline void CDirectMusicVoiceList::Remove(CDirectMusicVoice *pdmv)
{ AList::Remove(static_cast<AListItem*>(pdmv)); }

inline CVSTClient *CVSTClientList::GetHead()
{ return static_cast<CVSTClient*>(AList::GetHead()); }

inline void CVSTClientList::AddTail(CVSTClient *pc)
{ AList::AddTail(static_cast<AListItem*>(pc)); }

inline void CVSTClientList::Remove(CVSTClient *pc)
{ AList::Remove(static_cast<AListItem*>(pc)); }

#endif // _DMVOICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmvoice.cpp ===
//
// dmvoice.cpp
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
//

#include <windows.h>

#include "debug.h"
#include "dmusicp.h"
#include "validate.h"
#include "dmvoice.h"
#include "dswave.h"

// Class global: next available voice ID
//
DWORD CDirectMusicVoice::m_dwNextVoiceId = 1;

// Class global Voice Service Thread 
//
LONG CDirectMusicVoice::m_cRefVST           = 0;
HANDLE CDirectMusicVoice::m_hVSTWakeUp      = (HANDLE)NULL;
HANDLE CDirectMusicVoice::m_hVSTThread      = (HANDLE)NULL;
DWORD CDirectMusicVoice::m_dwVSTThreadId    = 0;
bool CDirectMusicVoice::m_fVSTStopping      = false;
CVSTClientList CDirectMusicVoice::m_ClientList;
CRITICAL_SECTION CDirectMusicVoice::m_csVST; 

DWORD WINAPI VoiceServiceThreadThk(LPVOID lpParameter);

//#############################################################################
//
// CDirectMusicVoice
//
//#############################################################################

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::QueryInterface
//
//
STDMETHODIMP CDirectMusicVoice::QueryInterface(
    const IID &iid,
    void **ppv) 
{
    V_INAME(IDirectMusicVoice::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicVoiceP)
    {
        *ppv = static_cast<IDirectMusicVoiceP*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::AddRef
//
//
STDMETHODIMP_(ULONG) CDirectMusicVoice::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Release
//
//
STDMETHODIMP_(ULONG) CDirectMusicVoice::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::CDirectMusicVoice
//
//
CDirectMusicVoice::CDirectMusicVoice(
    CDirectMusicPortDownload *pPortDL,
    IDirectSoundDownloadedWaveP *pWave,
    DWORD dwChannel,
    DWORD dwChannelGroup,
    REFERENCE_TIME rtStart,
    REFERENCE_TIME rtReadAhead,
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd) :
    m_cRef(1)
{
    assert(pPortDL);
    assert(pWave);

    HRESULT hr = pPortDL->QueryInterface(IID_IDirectMusicPort, (void**)&m_pPort);
    assert(SUCCEEDED(hr));
    
    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(pWave);

    m_nChannels         = pDSWave->GetNumChannels();
    m_dwVoiceId         = AllocVoiceId(m_nChannels);
    m_pPortDL           = pPortDL;
    m_pDSDLWave         = pWave;
    m_dwChannel         = dwChannel;
    m_dwChannelGroup    = dwChannelGroup;
    m_stStart           = pDSWave->RefToSampleTime(rtStart);
    m_stReadAhead       = pDSWave->RefToSampleTime(rtReadAhead);
    m_stLoopStart       = stLoopStart;
    m_stLoopEnd         = stLoopEnd;


    // HACKHACK make sure we fit into streaming buffers
    //
    SAMPLE_TIME stStream = pDSWave->GetStreamSize();
    
    if (stStream < 4 * m_stReadAhead)
    {
        m_stReadAhead = stStream / 4;
    }

    // rtReadAhead must fit in 32-bits worth of milliseconds (49 days)
    //
    m_msReadAhead       = (DWORD)(rtReadAhead / (10 * 1000));

    m_pDSWD             = NULL;

    //m_pPort->AddRef();
    m_pDSDLWave->AddRef();

    m_pPortPrivate      = NULL;

    m_fIsPlaying        = false;
    m_fIsStreaming      = pDSWave->IsStreaming();

    if (m_fIsStreaming)
    {
        m_stLoopStart = 0;
        m_stLoopEnd = 0;
    }
}
        
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Init
//
//
HRESULT CDirectMusicVoice::Init()
{
    HRESULT hr = S_OK;

    CDirectSoundWave *pDSWave = (CDirectSoundWave*)m_pDSDLWave;

    m_fRunning = false; // Have not started running yet.
    if (m_fIsStreaming)
    {
        TraceI(2, "Voice doing streaming init\n");
        m_pDSWD = new CDirectSoundWaveDownload(
            static_cast<CDirectSoundWave*>(m_pDSDLWave),
            m_pPortDL,
            m_stStart,
            m_stReadAhead);
        
        hr = HRFromP(m_pDSWD);

        if (SUCCEEDED(hr))
        {
            // We download only the required wave data
            // So set the start time to 0
            m_stStart = 0;
            hr = m_pDSWD->Init();
        }

        if (SUCCEEDED(hr))
        {
             hr = m_pDSWD->Download();
        }

        if (SUCCEEDED(hr))
        {
            m_dwDLId = m_pDSWD->GetDLId();
        }
    }
    else
    {   
        // One-shot case
        //
        m_dwDLId = pDSWave->GetDLId();
        TraceI(2, "Got download ID %d from pDSWave %d\n", m_dwDLId);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pPort->QueryInterface(
            IID_IDirectMusicPortPrivate, 
            (void**)&m_pPortPrivate);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::~CDirectMusicVoice
//
//
CDirectMusicVoice::~CDirectMusicVoice()
{
    if(m_pDSWD)
    {
        // Voice is going away so unload the downloaded wave
        m_pDSWD->Unload();
        delete m_pDSWD;
    }

    RELEASE(m_pPortPrivate);
    RELEASE(m_pPort);
    RELEASE(m_pDSDLWave);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Play
//
//
STDMETHODIMP CDirectMusicVoice::Play(
    REFERENCE_TIME rtStart,
    LONG prPitch,
    LONG vrVolume)
{
    HRESULT                 hr = S_OK;
    CVSTClient             *pClient = FindClientByPort(m_pPort);

    TraceI(2, "Starting voice %d [%p] using DLID %d\n", m_dwVoiceId, this, m_dwDLId);

    CDirectSoundWave *pDSWave = static_cast<CDirectSoundWave*>(m_pDSDLWave);

    //Check that FindClientByPort returned a clinet
    if (pClient == NULL)
    {
    	hr = E_FAIL;
    	return hr;
    }

    if (m_fIsStreaming)
    {
        EnterCriticalSection(&m_csVST);
    
        if (m_fIsPlaying) 
        {
            // XXX Error code
            //
            hr = E_INVALIDARG;
        }            
        else
        {
            // Add this voice to the proper client list.
            // This will cause the thread to be kicked to update
            // its wakeup interval.
            //
            if (pClient == NULL) 
            {
                TraceI(0, "Play: Port voice is to be played on has disappeared!\n");
                hr = E_FAIL;
            }                                    
            else
            {
                pClient->AddTail(this);
                hr = pClient->BuildVoiceIdList();
                if (FAILED(hr))
                {
                    pClient->Remove(this);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        UpdateVoiceServiceThread();

        DWORD i;

        for (i = 0; SUCCEEDED(hr) && i < m_nChannels; i++) 
        {
            // Voice ID's and wave articulation download ID's are 
            // allocated sequentially, one per channel
            //
            hr = m_pPortPrivate->StartVoice(
                m_dwVoiceId + i,
                m_dwChannel,
                m_dwChannelGroup,
                rtStart,
                m_dwDLId + i,
                prPitch,
                vrVolume,
                m_stStart,
                m_stLoopStart,
                m_stLoopEnd);
        }
        if (FAILED(hr))
        {
            for (i = 0; i < m_nChannels; i++) 
            {
                m_pPortPrivate->StopVoice(
                    m_dwVoiceId + i,
                    rtStart + 1);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // NOTE: We should still be in the critical section whenever this
        // is changed since the VST will change it as well.
        //
        m_fIsPlaying = true;
    }

    if (m_fIsStreaming)
    {
        if (FAILED(hr))
        {
            pClient->Remove(this);
        }

        LeaveCriticalSection(&m_csVST);
    }

    return hr;
}
    
////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::Stop
//
//
STDMETHODIMP CDirectMusicVoice::Stop(
    REFERENCE_TIME rtStop)
{
    HRESULT                 hr = S_OK;

    if (m_fIsStreaming)
    {
        EnterCriticalSection(&m_csVST);
    
        if (!m_fIsPlaying)
        {
            // XXX Error code
            //
            hr = E_INVALIDARG;
        }
        else
        {
            CVSTClient *pClient = FindClientByPort(m_pPort);
            if (pClient == NULL) 
            {
                TraceI(0, "Play: Port voice is to be stopped on has disappeared!\n");
                hr = E_FAIL;
            }                                    
            else
            {
                pClient->Remove(this);
                pClient->BuildVoiceIdList();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        UpdateVoiceServiceThread();

        DWORD i;

        for (i = 0; i < m_nChannels; i++)
        {
            HRESULT hrTemp;

            hrTemp = m_pPortPrivate->StopVoice(
                m_dwVoiceId + i,
                rtStop);

            if (FAILED(hrTemp))
            {
                hr = hrTemp;
            }
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // NOTE: We should still be in the critical section whenever this
        // is changed since the VST will change it as well.
        //
        m_fIsPlaying = false;
    }

    if (m_fIsStreaming)
    {
        LeaveCriticalSection(&m_csVST);
    }

    return hr;                
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::StartVoiceServiceThread
//
//
HRESULT CDirectMusicVoice::StartVoiceServiceThread(
    IDirectMusicPort *pPort)
{
    HRESULT                 hr = S_OK;
    DWORD                   dwError;
    CVSTClient              *pClient = NULL;
    bool                    fShutdownOnFail = false;
    
    EnterCriticalSection(&m_csVST);

    pClient = new CVSTClient(pPort);
    hr = HRFromP(pClient);

    if (SUCCEEDED(hr) && ++m_cRefVST == 1) 
    {
        // This is the first time a port has requested the service thread,
        // so start it for real.
        //
        fShutdownOnFail = true;

        m_hVSTWakeUp = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hVSTWakeUp == (HANDLE)NULL)
        {
            dwError = GetLastError();
            TraceI(0, "VoiceServiceThread: CreateEvent failed %d\n", dwError);

            hr = WIN32ERRORtoHRESULT(dwError);
        }

        m_fVSTStopping = false;
        if (SUCCEEDED(hr))
        {
            m_hVSTThread = CreateThread(
                NULL,               // Attributes
                0,                  // Stack size
                ::VoiceServiceThreadThk,
                0,
                0,                  // Flags
                &m_dwVSTThreadId);
            if (m_hVSTThread == (HANDLE)NULL)
            {
                dwError = GetLastError();
                TraceI(0, "VoiceServiceThread: CreateThread failed %d\n", dwError);

                hr = WIN32ERRORtoHRESULT(GetLastError());
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        m_ClientList.AddTail(pClient);        
    }

    if (FAILED(hr))
    {
        if (fShutdownOnFail)
        {
            if (m_hVSTWakeUp) 
            {
                CloseHandle(m_hVSTWakeUp);
                m_hVSTWakeUp = NULL;
            }

            assert(!m_hVSTThread);
        
            m_cRefVST = 0;        
        }

        delete pClient;
    }

    LeaveCriticalSection(&m_csVST);
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::StopVoiceServiceThread
//
//
HRESULT CDirectMusicVoice::StopVoiceServiceThread(IDirectMusicPort *pPort)
{
    HRESULT                 hr = S_OK;

    EnterCriticalSection(&m_csVST);

    CVSTClient *pClient = FindClientByPort(pPort);

    if (pClient == NULL) 
    {
        TraceI(0, "Port %p tried to stop the voice service thread without starting it\n", pPort);
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        // XXX Clean up still playing voices 
        //
        m_ClientList.Remove(pClient);
        delete pClient;
    }

    if (SUCCEEDED(hr) && --m_cRefVST == 0)
    {
        // Last user is releasing. Try to shut down the thread.
        //
        assert(m_hVSTWakeUp);
        assert(m_hVSTThread);

        TraceI(2, "Killing Voice Service Thread\n");
        m_fVSTStopping = true;
        SetEvent(m_hVSTWakeUp);

        if (WaitForSingleObject(m_hVSTThread, 5000) == WAIT_TIMEOUT)
        {
            TraceI(0, "Voice Service Thread refused to die!\n");
        }   

        CloseHandle(m_hVSTWakeUp);
        CloseHandle(m_hVSTThread);
    }

    LeaveCriticalSection(&m_csVST);
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::VoiceServiceThread
//
//
DWORD WINAPI VoiceServiceThreadThk(LPVOID lpParameter)
{
    CDirectMusicVoice::VoiceServiceThread();
    return 0;
}

void CDirectMusicVoice::VoiceServiceThread()
{
    DWORD                   dwTimeout = 500;    // Force it to recalculate the timeout after 500ms.
    DWORD                   dwWFSO;
    bool                    fService;
    bool                    fRecalcTimeout;

    for(;;)
    {
        dwWFSO = WaitForSingleObject(m_hVSTWakeUp, dwTimeout);
        if (m_fVSTStopping) 
        {
            break;
        }

        fService = false;
        fRecalcTimeout = false;
        switch(dwWFSO)
        {
            // If the timeout was hit, it's time to service voices.
            //
            case WAIT_TIMEOUT:
                fService = true;
                break;
        
            // If the event was triggered, we've received a request to 
            // either die (m_fVSTStopping will be set) or the voice list
            // changed, so we're supposed to recalculate the wakeup time.
            //
            case WAIT_OBJECT_0:
                if (!m_fVSTStopping) 
                {
                    fRecalcTimeout = true;  // Need to recalculate time out.
                    fService = true;        // Make sure any buffer refilling that
                                            // needs to be done is taken care of.
                }
                break;

            // These two should never happen.
            //            
            case WAIT_FAILED:
                TraceI(1, "VST: WaitForSingleObject failed %d; rewaiting.\n",
                    GetLastError());
                continue;
                
            default:
                TraceI(0, "VST: WaitForSingleObject: Unexpected return %d\n", 
                    dwWFSO);                
                continue;
        }

        EnterCriticalSection(&m_csVST);
        
        if (fService)
        {
            // If voices stop, then we should recalc the timeout.
            //
            ServiceVoiceQueue(&fRecalcTimeout);
        }                        

        if (fRecalcTimeout)
        {
            dwTimeout = (VoiceQueueMinReadahead() / 2);
        }
        LeaveCriticalSection(&m_csVST);
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::ServiceVoiceQueue
//
// Called from VoiceServiceThread() to walk the queue and see which voices
// need servicing. Assumes caller has the voice service critical section.
//
//
void CDirectMusicVoice::ServiceVoiceQueue(bool *pfRecalcTimeout)
{
    HRESULT                 hr;
    DMUS_VOICE_STATE       *psp;
    CDirectMusicVoice      *pVoice;

    for (CVSTClient *pClient = m_ClientList.GetHead(); pClient; pClient = pClient->GetNext()) 
    {
        hr = pClient->GetVoiceState(&psp);
        if (FAILED(hr))
        {
            continue;
        }

        // The DMUS_VOICE_STATE array returned by GetVoicePosition lines up
        // with the order of voices in the CVSTClient's voice list
        //
        bool fClientVoiceListChanged = false;

        for (pVoice = pClient->GetVoiceListHead();
             pVoice;
             pVoice = pVoice->GetNext(), psp++)
        {
            if (psp->bExists)
            {
                hr = pVoice->m_pDSWD->RefreshThroughSample(psp->spPosition);
                if (FAILED(hr))
                {
                    TraceI(0, "VST: RefreshThroughSample failed %08X\n", hr);
                    continue;
                }
                pVoice->m_fRunning = true; // Now that we've started writing data, 
                                           // psp->bExists failing will safely mean synth terminated it,
                                           // as opposed to not started yet.
            }
            
            // S_FALSE indicates that the end of data has been reached
            // on this voice. Also kill it if the synth has terminated
            // it.
            //
            if (hr == S_FALSE || (!psp->bExists && pVoice->m_fRunning))
            {
                pVoice->Stop(0);
                pVoice->m_fIsPlaying = false;
                fClientVoiceListChanged = true;
            }
        }

        // If anything changed in this client's voice list,
        // update it now.
        //
        if (!fClientVoiceListChanged)
        {
            continue;
        }

        // Something's changed, recalc the wakeup time before going
        // back to sleep
        //
        *pfRecalcTimeout = true;

        // Yank out the voices which have completed.
        //
        for (pVoice = pClient->GetVoiceListHead(); pVoice; )
        {
            // Voice is still playing, do nothing
            //
            if (pVoice->m_fIsPlaying)
            {
                pVoice = pVoice->GetNext();
                continue;
            }

            // Just finished, remove from list
            //
            CDirectMusicVoice *pNext = pVoice->GetNext();
            pClient->Remove(pVoice);
            pVoice = pNext;
        }

        // This call cannot fail because the only way it can is to run out of
        // memory, and memory allocation is not done when the list shrinks.
        //
        pClient->BuildVoiceIdList();
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::VoiceQueueMinReadahead
//
// Called from VoiceServiceThread() to walk the queue and determine the
// minimum readahead in milliseconds. Assumes caller has the voice service
// critical section.
//
DWORD CDirectMusicVoice::VoiceQueueMinReadahead()
{
    DWORD                   dwMin = INFINITE;
    for (CVSTClient *pClient = m_ClientList.GetHead(); pClient; pClient = pClient->GetNext()) 
    {
        for (CDirectMusicVoice *pVoice = pClient->GetVoiceListHead(); pVoice; pVoice = pVoice->GetNext())
        {
            dwMin = min(dwMin, pVoice->m_msReadAhead);            
        }
    }

    return dwMin;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectMusicVoice::FindClientByPort
//
// Given a port pointer, find the matching CVSTClient if there is one.
//
CVSTClient *CDirectMusicVoice::FindClientByPort(IDirectMusicPort *pPort)
{
    CVSTClient *pCurr = m_ClientList.GetHead();

    while (pCurr)
    {
		IDirectMusicPort *pCurrPort = pCurr->GetPort();

        if (pCurrPort == pPort)
        {   
            break;
        }

        pCurr = pCurr->GetNext();
    }

    return pCurr;
}

//#############################################################################
//
// CVSTClient
//
//#############################################################################

const UINT CVSTClient::m_cAllocSize = 32;

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::CVSTClient
//
//
CVSTClient::CVSTClient(IDirectMusicPort *pPort)
{
    m_pPort = pPort;

    m_pdwVoiceIds = NULL;
    m_pspVoices   = NULL;
    m_cVoiceIdsAlloc = 0;
}

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::~CVSTClient
//
//
CVSTClient::~CVSTClient()
{
    delete[] m_pdwVoiceIds;
    delete[] m_pspVoices;
}

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::BuildVoiceIdList
//
// Build the voice ID array, and make sure it and the sample position array 
// are big enough for all voices. These arrays are used to call into the
// synth to figure out how far each voice has rendered.
//
// The caller must have taken the voice service thread critical section.
//
// This method guarantees that on failure, the existing list will not be
// touched.
//
HRESULT CVSTClient::BuildVoiceIdList()
{
    // To minimize allocations, the arrays are allocated in chunks and never
    // shrink. (The amount of memory here is extremely small... 12 bytes per 
    // voice).
    //
    if (m_VoiceList.GetCount() > m_cVoiceIdsAlloc)
    {
        LONG cNewAlloc = ((m_VoiceList.GetCount() / m_cAllocSize) + 1) * m_cAllocSize;

        DWORD *pdw = new DWORD[cNewAlloc];
        DMUS_VOICE_STATE *psp = new DMUS_VOICE_STATE[cNewAlloc];

        // Check allocation
        if (pdw == NULL || psp == NULL) 
        {
        	delete[] pdw;
        	delete[] psp;
            return E_OUTOFMEMORY;
        }

        memset(pdw, 0, cNewAlloc * sizeof(DWORD));
        memset(psp, 0, cNewAlloc * sizeof(SAMPLE_POSITION));

        m_cVoiceIdsAlloc = cNewAlloc;

        delete[] m_pdwVoiceIds;
        delete[] m_pspVoices;
        
        m_pdwVoiceIds = pdw;
        m_pspVoices = psp;
    }

    // We know there's enough space now. Walk the voice list and
    // fill in the voice Id's.
    //
    // This assumes that the list order will not change and that 
    // the array is kept in sync with the list.
    //
    DWORD *pdwIds = m_pdwVoiceIds;

    CDirectMusicVoice *pVoice = GetVoiceListHead();
    for (; pVoice; pVoice = pVoice->GetNext())
    {
        *pdwIds++ = pVoice->GetVoiceId();
    }

    m_cVoiceIds = m_VoiceList.GetCount();

    return S_OK;  
}

////////////////////////////////////////////////////////////////////////////////
//
// CVSTClient::GetVoiceState
//
// Wraps the port GetVoiceState call with the voice list the CVSTClient 
// maintains.
//
HRESULT CVSTClient::GetVoiceState(DMUS_VOICE_STATE **ppsp)
{
    HRESULT                 hr;
    IDirectMusicPortPrivate *pPrivate;

    if (m_pdwVoiceIds)
    {

        hr = m_pPort->QueryInterface(IID_IDirectMusicPortPrivate, (void**)&pPrivate);

        if (SUCCEEDED(hr))
        {
            hr = pPrivate->GetVoiceState(
                m_pdwVoiceIds,
                m_cVoiceIds,
                m_pspVoices);
            pPrivate->Release();
        }

        if (SUCCEEDED(hr))
        {
            *ppsp = m_pspVoices;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmwavobj.h ===
//
// dmwavobj.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//

#ifndef DMWAVOBJ_H
#define DMWAVOBJ_H

#include "dmextchk.h"

// Windows Media Audio codec Format Tags
#define MSAUDIO_FORMAT_TAG	352	// V1
#define WMAUDIO_FORMAT_TAG	353	// V2

// Key required for Windows Media Audio codecs
#define MSAUDIO_DEC_KEY "1A0F78F0-EC8A-11d2-BBBE-006008320064"


class CCopyright;
class CRiffParser;

class CWaveObj : public AListItem      
{       
friend class CCollection;
friend class CInstrument;
friend class CWaveObjList;

private:
	CWaveObj();
	~CWaveObj();

	CWaveObj* GetNext(){return (CWaveObj*)AListItem::GetNext();}
	HRESULT Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent);

	void Cleanup();
	HRESULT Size(DWORD* pdwSize, DWORD * pdwSampleSize);
	HRESULT Write(void* pvoid);

	HRESULT GetData(BYTE* pdwBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead);
	HRESULT ReadData(IStream* pStream, BYTE* pdwBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead);
	HRESULT ReadCompressedData(IStream* pStream, BYTE* pdwBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead);
	HRESULT CanDecompress();
	HRESULT CalcDataSize(DWORD *pdwSize);
	HRESULT DecompressWave(WAVEFORMATEX *pwfxSrc, 
						   WAVEFORMATEX *pwfxDst, 
						   BYTE *pbCompressedBuffer,
						   BYTE *pbDecompressBuffer,
						   DWORD dwSizeCompressed, 
						   DWORD dwSizeDecompressed);

	HRESULT AllocWMAudioFormat(const WAVEFORMATEX* pwfxSrc, WAVEFORMATEX** ppwfxWMAudioWave);
	
private:
	CRITICAL_SECTION			m_DMWaveCriticalSection;
    BOOL                        m_fCSInitialized;
	BOOL                        m_fReadDecompressionFormat;
	WAVEFORMATEX				m_WaveFormatRead;
	WAVEFORMATEX				m_WaveFormatWrite;
	WAVEFORMATEX                m_WaveFormatDecompress;
	BYTE*						m_pExtractWaveFormatData;
	CExtensionChunkList			m_ExtensionChunkList;
	CCopyright*					m_pCopyright;
	DWORD                       m_dwDataOffset;
	DWORD						m_dwDataSizeWrite;      // Calculated size of wave buffer.
    DWORD                       m_dwDataSizeAfterACM;   // Actual size after decompression.
	DWORD						m_dwDataSizeRead;
	DWORD						m_dwId;

	CCollection*		        m_pParent;

	DWORD						m_cbSizeOffsetTable;
	DWORD						m_dwCountExtChk;
	DWORD						m_dwSize;
	bool						m_bLoaded;
    DWORD                       m_dwDecompressedStart;
};      

class CWaveObjList : public AList
{
friend class CInstrument;
	
private:
	CWaveObjList(){}
	~CWaveObjList() 
	{
		while(!IsEmpty())
		{
			CWaveObj* pWaveObj = RemoveHead();
			delete pWaveObj;
		}
	}

    CWaveObj *GetHead(){return (CWaveObj *)AList::GetHead();}
	CWaveObj *GetItem(LONG lIndex){return (CWaveObj*)AList::GetItem(lIndex);}
    CWaveObj *RemoveHead(){return (CWaveObj *)AList::RemoveHead();}
	void Remove(CWaveObj *pWaveObj){AList::Remove((AListItem *)pWaveObj);}
	void AddTail(CWaveObj *pWaveObj){AList::AddTail((AListItem *)pWaveObj);}
};

#endif // #ifndef DMWAVOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dmwavobj.cpp ===
//
// dmwaveobj.cpp
// 
// Copyright (c) 1997-2001 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn with parts 
// based on code written by Todor Fay
//
#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "alist.h"
#include "debug.h"
#include "dlsstrm.h"
#include <mmreg.h>
#include <msacm.h>
#include "debug.h"
#include "dmcollec.h"
#include "dmcrchk.h"
#include "dmwavobj.h"
#include "dmportdl.h"

//////////////////////////////////////////////////////////////////////
// Class CWaveObj
 
//////////////////////////////////////////////////////////////////////
// CWaveObj::CWaveObj

CWaveObj::CWaveObj() :
m_pExtractWaveFormatData(NULL),
m_pCopyright(NULL),
m_dwDataOffset(0),
m_dwDataSizeWrite(0),
m_dwDataSizeRead(0),
m_dwId(0),
m_pParent(NULL),
m_cbSizeOffsetTable(0),
m_dwCountExtChk(0),
m_dwSize(0),
m_fCSInitialized(FALSE),
m_fReadDecompressionFormat(FALSE),
m_dwDecompressedStart(0)
#ifdef DBG
,m_bLoaded(false)
#endif
{
	InitializeCriticalSection(&m_DMWaveCriticalSection);
    m_fCSInitialized = TRUE;
	ZeroMemory(&m_WaveFormatRead, sizeof(m_WaveFormatRead));
	ZeroMemory(&m_WaveFormatWrite, sizeof(m_WaveFormatWrite));
}

//////////////////////////////////////////////////////////////////////
// CWavebj::~CWavebj

CWaveObj::~CWaveObj()
{
    if (m_fCSInitialized)
    {
    	Cleanup();
	    DeleteCriticalSection(&m_DMWaveCriticalSection);
    }
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Load

HRESULT CWaveObj::Load(DWORD dwId, CRiffParser *pParser, CCollection* pParent)
{
    // Argument validation
    assert(pParent);

#ifdef DBG
    if(dwId >= CDirectMusicPortDownload::sNextDLId)
    {
        assert(FALSE);
    }
#endif

    m_dwId = dwId;
    m_pParent = pParent;
    m_pParent->AddRef();

    HRESULT hr = S_OK;
    
    RIFFIO ck;
    EnterCriticalSection(&m_DMWaveCriticalSection);
    
    pParser->EnterList(&ck);
    while (pParser->NextChunk(&hr))
    {
        switch(ck.ckid)
        {
            case mmioFOURCC('w','a','v','u') :
            {
                // Read the flag which indiactes Runtime or Designtime File
                bool bTemp = false;;
                hr = pParser->Read(&bTemp, sizeof(bool));
                if(SUCCEEDED(hr))
                {
                    // Read the flag that indicates compression
                    hr = pParser->Read(&bTemp, sizeof(bool));
                    if(SUCCEEDED(hr))
                    {
                        // this is a compressed wave file
                        if(bTemp == true)
                        {
                            hr = pParser->Read(&m_WaveFormatDecompress, sizeof(WAVEFORMATEX));

                            if(FAILED(hr))
                            {
                                hr = E_FAIL;
                                m_fReadDecompressionFormat = FALSE;
                            }
                            else
                            {
                                m_WaveFormatDecompress.nAvgBytesPerSec = m_WaveFormatDecompress.nSamplesPerSec * m_WaveFormatDecompress.nBlockAlign;
                                m_fReadDecompressionFormat = TRUE;
                            }

                            // Read the actual start of the decompressed data
                            // This is important for MP3 and WMA codecs that insert silence in the beginning
                            if(ck.cksize > 2 + sizeof(WAVEFORMATEX))
                            {
                                m_dwDecompressedStart = 0;
                                hr = pParser->Read(&m_dwDecompressedStart, sizeof(DWORD));
                                if(FAILED(hr))
                                {
                                    hr = E_FAIL;
                                    m_fReadDecompressionFormat = FALSE;
                                }
                            }
                        }
                    }
                }

                break;
            }

            case FOURCC_LIST :
                switch(ck.fccType)
                {
                case mmioFOURCC('I','N','F','O') :
                    m_pCopyright = new CCopyright;
                    if(m_pCopyright)
                    {
                        hr = m_pCopyright->Load(pParser);
                        if((m_pCopyright->m_byFlags & DMC_FOUNDICOP) == 0)
                        {
                            delete m_pCopyright;
                            m_pCopyright = NULL;
                        }
                    }
                    else
                    {
                        hr =  E_OUTOFMEMORY;
                    }
                    break;
                default :
                    // If we get here we have an unknown chunk
                    CExtensionChunk* pExtensionChunk = new CExtensionChunk;
                    if(pExtensionChunk)
                    {
                        hr = pExtensionChunk->Load(pParser);
                        m_ExtensionChunkList.AddHead(pExtensionChunk);
                        m_dwCountExtChk++;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    break;
                }
                break;

            case mmioFOURCC('f','m','t',' ') :
                hr = pParser->Read(&m_WaveFormatRead, sizeof(WAVEFORMATEX));
                if(SUCCEEDED(hr))
                {
                    if(m_WaveFormatRead.wFormatTag != WAVE_FORMAT_PCM)
                    {
                        if(m_WaveFormatRead.cbSize)
                        {
                            m_pExtractWaveFormatData = new BYTE[m_WaveFormatRead.cbSize];
                            if(m_pExtractWaveFormatData)
                            {
                                hr = pParser->Read(m_pExtractWaveFormatData, m_WaveFormatRead.cbSize);
                            }
                        }
                        if(SUCCEEDED(hr))
                        {
                            hr = CanDecompress();
                        }
                    }
                    else
                    {
                        // If WAVE_FORMAT_PCM this member should be zero
                        m_WaveFormatRead.cbSize = 0;
                        CopyMemory(&m_WaveFormatWrite, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
                    }
                }
                break;
            case mmioFOURCC('d','a','t','a') : {
                pParser->MarkPosition();
                m_dwDataOffset = (DWORD) ck.liPosition.QuadPart;
                m_dwDataSizeRead = ck.cksize;
                DWORD dwTotalOffset = m_dwDataOffset + m_dwDataSizeRead;
                if (dwTotalOffset < m_dwDataOffset) {
                    hr = DMUS_E_INVALIDOFFSET; // overflow
                }
                else {
                    hr = m_pParent->ValidateOffset(dwTotalOffset);
                }
                break;
            }

            default :
                // If we get here we have an unknown chunk
                CExtensionChunk* pExtensionChunk = new CExtensionChunk;
                if(pExtensionChunk)
                {
                    hr = pExtensionChunk->Load(pParser);
                    m_ExtensionChunkList.AddHead(pExtensionChunk);
                    m_dwCountExtChk++;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                break;
        }
    }
    pParser->LeaveList();
    
#ifdef DBG
    if(SUCCEEDED(hr))
    {
        m_bLoaded = true;
    }
#endif

    if(FAILED(hr))
    {
        Cleanup();
    }
    
    LeaveCriticalSection(&m_DMWaveCriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Cleanup

void CWaveObj::Cleanup()
{
	EnterCriticalSection(&m_DMWaveCriticalSection);

	delete [] m_pExtractWaveFormatData;
	m_pExtractWaveFormatData = NULL;
	
	while(!m_ExtensionChunkList.IsEmpty())
	{
		CExtensionChunk* pExtChk = m_ExtensionChunkList.RemoveHead();
		delete pExtChk;
	}

	delete m_pCopyright;
	m_pCopyright = NULL;
	
	if(m_pParent)
	{
		m_pParent->Release();
		m_pParent = NULL;
	}

#ifdef DBG
	m_bLoaded = false;
#endif
	
	LeaveCriticalSection(&m_DMWaveCriticalSection);
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Size

HRESULT CWaveObj::Size(DWORD* pdwSize,DWORD *pdwSampleSize)
{
	// Assumption validation
#ifdef DBG
	assert(m_bLoaded);
#endif
 	assert(pdwSize);

	// If have already calculated the size we do not need to do it again
	if(m_dwSize)
	{
		*pdwSize = m_dwSize;
		*pdwSampleSize = m_WaveFormatWrite.wBitsPerSample;
		return S_OK;
	}
	
	HRESULT hr = S_OK;
	
	DWORD dwTotalSize = 0;
	DWORD dwOffsetCount = 0;
	DWORD dwCountExtChk = 0;

	EnterCriticalSection(&m_DMWaveCriticalSection);

	// Calculate the space needed for DMUS_DOWNLOADINFO 
	dwTotalSize += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	// Calculate the space needed for Wave's extension chunks
	CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
	for(; pExtChk; pExtChk = pExtChk->GetNext())
	{
        DWORD dwOriginalSize = dwTotalSize;
		dwTotalSize += pExtChk->Size();
		if (dwTotalSize < dwOriginalSize) {
		    hr = E_FAIL; // overflow
		    break;
		}
		dwOffsetCount += pExtChk->Count();
		dwCountExtChk++;
	}

	if(SUCCEEDED(hr)) {
        // We want to validate the number of extension chunks
    	if(m_dwCountExtChk == dwCountExtChk)
    	{
    		// Calculate the space needed for wave's copyright
    		if(m_pCopyright)
    		{
                DWORD dwOriginalSize = dwTotalSize;
    			dwTotalSize += m_pCopyright->Size();
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    			dwOffsetCount += m_pCopyright->Count();
    		}
    		// If wave does not have one use collection's
    		else if(SUCCEEDED(hr) && m_pParent && m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
    		{
                DWORD dwOriginalSize = dwTotalSize;
    			dwTotalSize += (m_pParent->m_pCopyright)->Size();
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    			dwOffsetCount += (m_pParent->m_pCopyright)->Count();
    		}
    
            if(SUCCEEDED(hr)) {
    		    // Calculate space needed for WAVE and WAVEDATA
                DWORD dwOriginalSize = dwTotalSize;
    		    dwTotalSize += CHUNK_ALIGN(sizeof(DMUS_WAVE)) + 
        			CHUNK_ALIGN(sizeof(DMUS_WAVEDATA));
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    	    	dwOffsetCount += 2;
            }
    
            if(SUCCEEDED(hr)) {
        		// Calculate space needed for offset table
        		m_cbSizeOffsetTable = dwOffsetCount * sizeof(ULONG);
                DWORD dwOriginalSize = dwTotalSize;
        		dwTotalSize += m_cbSizeOffsetTable;
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    		    m_dwDataSizeWrite = m_dwDataSizeRead;
            }

    		// Calculate space needed for wave data
            // We allocated DMUS_MIN_DATA_SIZE worth when we allocated for DMUS_WAVEDATA
    		if(SUCCEEDED(hr) && m_WaveFormatRead.wFormatTag != WAVE_FORMAT_PCM)
    		{
    			hr = CalcDataSize(&m_dwDataSizeWrite);
    		}
    		
    		if(SUCCEEDED(hr) && m_dwDataSizeWrite > DMUS_MIN_DATA_SIZE)
    		{
                DWORD dwOriginalSize = dwTotalSize;
    			dwTotalSize += (m_dwDataSizeWrite - DMUS_MIN_DATA_SIZE);		
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL; // overflow
        		}
    		}

            if(SUCCEEDED(hr)) {
                DWORD dwOriginalSize = dwTotalSize;
                dwTotalSize = CHUNK_ALIGN(dwTotalSize);
        		if (dwTotalSize < dwOriginalSize) {
        		    hr = E_FAIL;
        		}
    	    }
    	}
    	else
    	{
    		hr = E_FAIL;
    	}
    }
	
	// If everything went well, we have the size
	if(SUCCEEDED(hr))
	{
		m_dwSize = dwTotalSize;
		*pdwSize = m_dwSize;
		*pdwSampleSize = m_WaveFormatWrite.wBitsPerSample;
	}

	LeaveCriticalSection(&m_DMWaveCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::Write

HRESULT CWaveObj::Write(void* pvoid)
{
	// Assumption and argument validation
#ifdef DBG
	assert(m_bLoaded);
#endif

	assert(pvoid);

	DWORD dwSize;
	DWORD dwSampleSize;

	HRESULT hr = Size(&dwSize,&dwSampleSize);
	
	if(FAILED(hr))
	{       
		return hr;
	}

	EnterCriticalSection(&m_DMWaveCriticalSection);

	DWORD dwCurIndex = 0;   // Used to determine what index to store offset in Offset Table
	DWORD dwCurOffset = 0;  // Offset relative to beginning of passed in memory

	// Write DMUS_DOWNLOADINFO
	DMUS_DOWNLOADINFO *pDLInfo = (DMUS_DOWNLOADINFO *) pvoid;
	pDLInfo->dwDLType = DMUS_DOWNLOADINFO_WAVE;
	pDLInfo->dwDLId = m_dwId;
	pDLInfo->dwNumOffsetTableEntries = (m_cbSizeOffsetTable/sizeof(DWORD));
	pDLInfo->cbSize = dwSize;
	
	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

	DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvoid) + dwCurOffset);
	
	// Increment pass the DMUS_OFFSETTABLE structure; we will fill the other members in later
	dwCurOffset += CHUNK_ALIGN(m_cbSizeOffsetTable);

	// First entry in ulOffsetTable is the first data chunk - the DMUS_WAVE in this case.
	pDMOffsetTable->ulOffsetTable[0] = dwCurOffset;

	dwCurIndex = 2;		// First two items are DMUS_WAVE and DMUS_WAVEDATA;

	DMUS_WAVE* pDMWave = (DMUS_WAVE*)(((BYTE*)pvoid) + dwCurOffset);
	pDMWave->ulWaveDataIdx = 1;		// Point to the DMUS_WAVEDATA chunk.

	dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_WAVE));

	DMUS_WAVEDATA* pDMWaveData = (DMUS_WAVEDATA*)(((BYTE*)pvoid) + dwCurOffset);
	pDMOffsetTable->ulOffsetTable[1] = dwCurOffset;
	
	DWORD dwPos = 0;
	DWORD dwRead = 0;
    m_dwDataSizeAfterACM = m_dwDataSizeWrite;
	hr = GetData(pDMWaveData->byData, m_dwDataSizeWrite, &dwPos, &dwRead);

	pDMWaveData->cbSize = m_dwDataSizeAfterACM; 
	
	if(SUCCEEDED(hr))
	{
		if(m_dwDataSizeWrite < DMUS_MIN_DATA_SIZE)
		{
			dwCurOffset += sizeof(DMUS_WAVEDATA);
		}
		else
		{
			dwCurOffset += sizeof(DMUS_WAVEDATA) + m_dwDataSizeWrite - DMUS_MIN_DATA_SIZE;
		}
		dwCurOffset = CHUNK_ALIGN(dwCurOffset);

		CopyMemory(&(pDMWave->WaveformatEx), &m_WaveFormatWrite, sizeof(WAVEFORMATEX));	

		// Write extension chunks
		CExtensionChunk* pExtChk = m_ExtensionChunkList.GetHead();
		if(pExtChk)
		{
			pDMWave->ulFirstExtCkIdx = dwCurIndex;
		}
		else
		{
			// If no extension chunks set to zero
			pDMWave->ulFirstExtCkIdx = 0;
		}

		DWORD dwCountExtChk = m_dwCountExtChk;
		DWORD dwIndexNextExtChk = 0;
		
		for(; pExtChk && SUCCEEDED(hr); pExtChk = pExtChk->GetNext())
		{
		
			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk = dwCurIndex + 1;
			}
			
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			hr = pExtChk->Write(((BYTE *)pvoid + dwCurOffset), 
								&dwCurOffset,
								dwIndexNextExtChk);
			
			dwCountExtChk--;
			dwCurIndex++;
		}
	}

	if(SUCCEEDED(hr))
	{
		// Write copyright information
		if(m_pCopyright)
		{
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMWave->ulCopyrightIdx = dwCurIndex;
			hr = m_pCopyright->Write(((BYTE *)pvoid + dwCurOffset),
									 &dwCurOffset);
			dwCurIndex++;
		}
		// If instrument does not have one use collection's
		else if(m_pParent && m_pParent->m_pCopyright && (m_pParent->m_pCopyright)->m_pDMCopyright)
		{
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMWave->ulCopyrightIdx = dwCurIndex;
			hr = (m_pParent->m_pCopyright)->Write(((BYTE *)pvoid + dwCurOffset), 
												  &dwCurOffset);
			dwCurIndex++;
		}
		else
		{
			pDMWave->ulCopyrightIdx = 0;
		}
	}

	// We need to fix the offset table entries to be relative to the beginning of the data
	// They are currently relative to the beginning of allocated memory.
/*	if(SUCCEEDED(hr))
	{
		for(DWORD i = 0; i < (m_cbSizeOffsetTable/sizeof(DWORD)) ; i++)
		{
			pDMOffsetTable->ulOffsetTable[i] = 
				pDMOffsetTable->ulOffsetTable[i] - 
				CHUNK_ALIGN(m_cbSizeOffsetTable) - 
				CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));
		}
	}*/

	if(FAILED(hr))
	{
		ZeroMemory(pvoid, dwSize);
	}

	LeaveCriticalSection(&m_DMWaveCriticalSection);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::GetData

HRESULT CWaveObj::GetData(BYTE* pbBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead)
{
	// Argument validation
	assert(pbBuffer);
	assert(pdwPos);

#ifdef DBG
	if(pdwRead)
	{
		assert(pdwRead);
	}
#endif

	if(*pdwPos > (m_dwDataOffset + m_dwDataSizeWrite))
	{
		return DMUS_E_INVALIDPOS;
	}

    assert(m_pParent);

	IStream* pStream = m_pParent->m_pStream;

	// Validation
	assert(pStream);
	
	HRESULT hr = S_OK;

	LARGE_INTEGER li;
	li.QuadPart = m_dwDataOffset + *pdwPos;
	hr = pStream->Seek(li, STREAM_SEEK_SET,NULL);
	if(SUCCEEDED(hr))
	{
		if(m_WaveFormatRead.wFormatTag == WAVE_FORMAT_PCM)
		{
			hr = ReadData(pStream, pbBuffer, dwSize, pdwPos, pdwRead);
		}
		else
		{
			hr = ReadCompressedData(pStream, pbBuffer, dwSize, pdwPos, pdwRead);
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::ReadCompressedData

HRESULT CWaveObj::ReadCompressedData(IStream* pStream, BYTE* pbBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead)
{
	// Argument validation
	assert(pbBuffer);
	assert(pdwPos);
	assert(pStream);

#ifdef DBG
	if(pdwRead)
	{
		assert(pdwRead);
	}
#endif
	HRESULT hr = E_FAIL;

	DWORD dwRead = 0;

	DWORD dwLeftToRead = m_dwDataSizeRead - *pdwPos;

	DWORD dwToRead  = dwLeftToRead < dwSize ? dwLeftToRead : dwSize;

	BYTE *pbCompressedBuffer = new  BYTE[dwToRead];
	
	if(pbCompressedBuffer == NULL)
	{
		return hr;
	}
	
	hr = pStream->Read(pbCompressedBuffer, dwToRead, &dwRead);
	
	DWORD temp = m_dwDataSizeWrite;
	
	if(SUCCEEDED(hr))
	{
		WAVEFORMATEX* pwfx = NULL;
		if(m_WaveFormatRead.wFormatTag == MSAUDIO_FORMAT_TAG || m_WaveFormatRead.wFormatTag == WMAUDIO_FORMAT_TAG)
		{
			if(FAILED(hr = AllocWMAudioFormat(&m_WaveFormatRead, &pwfx)))
			{
				delete[] pbCompressedBuffer;
				return hr;
			}
		}
		else
		{
			pwfx = (WAVEFORMATEX*) new BYTE[sizeof(m_WaveFormatRead) + m_WaveFormatRead.cbSize];
			if(pwfx == NULL)
			{
				delete[] pbCompressedBuffer;
				return E_OUTOFMEMORY;
			}
		
			CopyMemory(pwfx, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
			if(m_pExtractWaveFormatData)
			{
				CopyMemory((((BYTE *)pwfx) + sizeof(m_WaveFormatRead)), m_pExtractWaveFormatData, m_WaveFormatRead.cbSize); 
			}
		}

		assert(pwfx);

		hr = DecompressWave(pwfx, 
							&m_WaveFormatWrite, 
							pbCompressedBuffer,
							pbBuffer,
							dwToRead, 
							temp);

		if(SUCCEEDED(hr))
		{
			*pdwPos += dwRead;
		}

		if(pdwRead)
		{
			if(SUCCEEDED(hr))
			{
				*pdwRead = dwRead;
			}
			else
			{
				*pdwRead = 0;
			}
		}

		if(pwfx)
		{
			delete[] pwfx;
		}
	}
	else
	{
		if(pdwRead)
		{
			*pdwRead = 0;
		}
	}

	delete[] pbCompressedBuffer;

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::ReadData

HRESULT CWaveObj::ReadData(IStream* pStream, BYTE* pbBuffer, DWORD dwSize, DWORD* pdwPos, DWORD* pdwRead)
{
	// Argument validation
	assert(pbBuffer);
	assert(pdwPos);
	assert(pStream);

#ifdef DBG
	if(pdwRead)
	{
		assert(pdwRead);
	}
#endif

	HRESULT hr = E_FAIL;

	DWORD dwRead = 0;

	DWORD dwLeftToRead = m_dwDataSizeRead - *pdwPos;

	DWORD dwToRead  = dwLeftToRead < dwSize ? dwLeftToRead : dwSize;

	hr = pStream->Read(pbBuffer, dwToRead, &dwRead);

	if(SUCCEEDED(hr))
	{
		if(pdwRead)
		{
			*pdwRead = dwRead;
		}

		*pdwPos += dwRead;
	}
	else
	{
		if(pdwRead)
		{
			*pdwRead = 0;
		}
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::CalcDataSize

HRESULT CWaveObj::CalcDataSize(DWORD *pdwSize)
{
	assert(pdwSize);

    WAVEFORMATEX *pwfx = NULL;
    if(m_WaveFormatRead.wFormatTag == MSAUDIO_FORMAT_TAG || m_WaveFormatRead.wFormatTag == WMAUDIO_FORMAT_TAG)
	{
		if(FAILED(AllocWMAudioFormat(&m_WaveFormatRead, &pwfx)))
		{
			return E_FAIL;
		}
	}
    else
    {
	    pwfx = (WAVEFORMATEX *) new BYTE[sizeof(m_WaveFormatRead) + m_WaveFormatRead.cbSize];

	    if(pwfx == NULL)
	    {
		    *pdwSize = 0;		
		    return E_FAIL;
	    }
	    
	    CopyMemory(pwfx, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
	    if(m_pExtractWaveFormatData)
	    {
		    CopyMemory((((BYTE *)pwfx) + sizeof(m_WaveFormatRead)), m_pExtractWaveFormatData, m_WaveFormatRead.cbSize); 
	    }
    }

    assert(pwfx);

	HACMSTREAM has;
	MMRESULT mmr = acmStreamOpen(&has, NULL, pwfx, &m_WaveFormatWrite, NULL, 0, 0, 0);
	
	if(mmr != MMSYSERR_NOERROR)
	{
		*pdwSize = 0;
		delete [] (BYTE *)pwfx;
		return E_FAIL;	
	}

	mmr = acmStreamSize(has, m_dwDataSizeRead, pdwSize, ACM_STREAMSIZEF_SOURCE);

	if(mmr != MMSYSERR_NOERROR || *pdwSize == 0)
	{
		*pdwSize = 0;
		acmStreamClose(has, 0);
		delete [] (BYTE *)pwfx;
		return E_FAIL;	
	}

    // Check if we have to throw away some silent samples from the beginning
    //*pdwSize -= m_dwDecompressedStart;

	mmr = acmStreamClose(has, 0);

	if(mmr != MMSYSERR_NOERROR)
	{
		*pdwSize = 0;
		delete [] (BYTE *)pwfx;
		return E_FAIL;
	}

	delete [] (BYTE *)pwfx;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::CanDecompress

HRESULT CWaveObj::CanDecompress()
{
	HRESULT hr = E_FAIL;

	ZeroMemory(&m_WaveFormatWrite, sizeof(m_WaveFormatWrite));
	m_WaveFormatWrite.wFormatTag = WAVE_FORMAT_PCM;
	m_WaveFormatWrite.nChannels = 1;
	m_WaveFormatWrite.wBitsPerSample = 16;

	WAVEFORMATEX* pwfx = NULL; 
	
	if(SUCCEEDED(hr = AllocWMAudioFormat(&m_WaveFormatRead, &pwfx)))
	{
		pwfx = (WAVEFORMATEX *) new BYTE[sizeof(m_WaveFormatRead) + m_WaveFormatRead.cbSize];
		if(pwfx == NULL)
		{
			return E_OUTOFMEMORY;
		}
		
		CopyMemory(pwfx, &m_WaveFormatRead, sizeof(m_WaveFormatRead));
		if(m_pExtractWaveFormatData)
		{
			CopyMemory((((BYTE *)pwfx) + sizeof(m_WaveFormatRead)), m_pExtractWaveFormatData, m_WaveFormatRead.cbSize); 
		}
	}
	else
	{
	    pwfx = &m_WaveFormatRead;
	}

	assert(pwfx);

	if(m_fReadDecompressionFormat == TRUE)
    {
        CopyMemory(&m_WaveFormatWrite, &m_WaveFormatDecompress, sizeof(m_WaveFormatDecompress));
        hr = S_OK;
    }
    else
    {
		// We first try to find a driver that can support wBitsPerSample == 16 if we can not find one 
		// then we try to find a driver that can support wBitsPerSample == 8. If we do not find either we 
		// return an error since we can not decompress.
		MMRESULT mmr = acmFormatSuggest(NULL,
										pwfx,
										&m_WaveFormatWrite,
										sizeof(WAVEFORMATEX),
										ACM_FORMATSUGGESTF_NCHANNELS 
										| ACM_FORMATSUGGESTF_WBITSPERSAMPLE 
										| ACM_FORMATSUGGESTF_WFORMATTAG);


		if(mmr != MMSYSERR_NOERROR)
		{
			m_WaveFormatWrite.wBitsPerSample = 8;
			
			mmr = acmFormatSuggest(NULL,
								   pwfx,
								   &m_WaveFormatWrite,
								   sizeof(WAVEFORMATEX),
								   ACM_FORMATSUGGESTF_NCHANNELS |
								   ACM_FORMATSUGGESTF_WBITSPERSAMPLE |
								   ACM_FORMATSUGGESTF_WFORMATTAG);
		}

		if(mmr == MMSYSERR_NOERROR) 
		{
			hr = S_OK;
		}
	}

	if (pwfx && pwfx != &m_WaveFormatRead)
	{
		delete[] (BYTE*)pwfx;
	}

	return hr; 
}

//////////////////////////////////////////////////////////////////////
// CWaveObj::DecompressWave

HRESULT CWaveObj::DecompressWave(WAVEFORMATEX *pwfxSrc, 
								 WAVEFORMATEX *pwfxDst, 
								 BYTE *pbCompressedBuffer,
								 BYTE *pbDecompressBuffer,
								 DWORD dwSizeCompressed, 
								 DWORD dwSizeDecompressed)
{
	// We're just fooling the compressor!
    WORD wOriginalSampleRate = (WORD)pwfxDst->nSamplesPerSec;
    if(pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec)
    {
        pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
        pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec * pwfxDst->nBlockAlign;
    }

	HACMSTREAM has;
	MMRESULT mmr = acmStreamOpen(&has, NULL, pwfxSrc, pwfxDst, NULL, 0, 0, 0);
	
	if(mmr != MMSYSERR_NOERROR)
	{
		return E_FAIL;	
	}

    BYTE* pbData = NULL;
    if(m_dwDecompressedStart > 0)
    {
        pbData = new BYTE[dwSizeDecompressed];
        if(pbData == NULL)
        {
            return E_OUTOFMEMORY;
        }

        ZeroMemory(pbData, dwSizeCompressed);
    }
    else
    {
        pbData = pbDecompressBuffer;
    }


	ACMSTREAMHEADER ashdr;
	ZeroMemory(&ashdr, sizeof(ashdr));
	ashdr.cbStruct = sizeof(ashdr);
	ashdr.pbSrc = pbCompressedBuffer;
	ashdr.cbSrcLength = dwSizeCompressed;
	ashdr.cbDstLength = dwSizeDecompressed;
	ashdr.pbDst = pbData;
	
	mmr = acmStreamPrepareHeader(has, &ashdr, 0);
	
	if(mmr != MMSYSERR_NOERROR || (ashdr.fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED) == 0)
	{
		acmStreamClose(has, 0);
		return E_FAIL;	
	}

	mmr = acmStreamConvert(has, &ashdr, 0);

	DWORD dwTemp = ashdr.cbDstLength;
    m_dwDataSizeAfterACM = ashdr.cbDstLengthUsed;

	// Need to reset or acmStreamUnprepareHeader will return with an error
	ashdr.cbSrcLength = dwSizeCompressed;
	ashdr.cbDstLength = dwSizeDecompressed;

	if(mmr != MMSYSERR_NOERROR)
	{
		acmStreamUnprepareHeader(has, &ashdr, 0);
		acmStreamClose(has, 0);
		return E_FAIL;	
	}

	mmr = acmStreamUnprepareHeader(has, &ashdr, 0);
	if(mmr != MMSYSERR_NOERROR)
	{
		acmStreamClose(has, 0);		
		return E_FAIL;	
	}
	
	m_dwDataSizeWrite = dwTemp;

	mmr = acmStreamClose(has, 0);

    // Do we have to throw away any silent samples from the beginning?
    if(m_dwDecompressedStart > 0)
    {
        DWORD dwStartByte = m_dwDecompressedStart * (m_WaveFormatDecompress.wBitsPerSample / 8);
        assert(dwSizeDecompressed > dwStartByte);
        DWORD dwBytesToCopy = dwSizeDecompressed - dwStartByte;
        CopyMemory(pbDecompressBuffer, pbData + dwStartByte, dwBytesToCopy);

        m_dwDataSizeWrite = dwBytesToCopy;
        m_dwDataSizeAfterACM = m_dwDataSizeWrite;

        delete[] pbData;
    }

	return mmr == MMSYSERR_NOERROR ? S_OK : E_FAIL;
}


HRESULT CWaveObj::AllocWMAudioFormat(const WAVEFORMATEX* pwfxSrc, WAVEFORMATEX** ppwfxWMAudioWave)
{
	assert(pwfxSrc);
	if(pwfxSrc == NULL)
	{
		return E_POINTER;
	}

	if(pwfxSrc->wFormatTag != 352 && pwfxSrc->wFormatTag != 353)
	{
		return E_FAIL;
	}

	// The new WAVEFORMATEX growsby the length of the key strings
	int nKeyLength = sizeof(MSAUDIO_DEC_KEY);
	DWORD nWaveFormatSize = sizeof(WAVEFORMATEX) + pwfxSrc->cbSize + nKeyLength;

	WAVEFORMATEX* pwfxTemp = (WAVEFORMATEX*)(new BYTE[nWaveFormatSize]);
    if(pwfxTemp == NULL)
    {
        return E_OUTOFMEMORY;
    }
	
	ZeroMemory(pwfxTemp, nWaveFormatSize);

	// Copy the old values
	CopyMemory(pwfxTemp, pwfxSrc, sizeof(WAVEFORMATEX));
	CopyMemory((((BYTE*)pwfxTemp) + sizeof(WAVEFORMATEX)), m_pExtractWaveFormatData, pwfxSrc->cbSize); 

	// Copy the key string 
	strcpy((char*)(pwfxTemp) + sizeof(WAVEFORMATEX) + pwfxTemp->cbSize, MSAUDIO_DEC_KEY);
	pwfxTemp->cbSize += sizeof(MSAUDIO_DEC_KEY);

	*ppwfxWMAudioWave = pwfxTemp;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dsutil.cpp ===
//
// dsutil.cpp
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Note: Utility routines for DirectSound
//
// @doc EXTERNAL
//
//

// Be careful what headers get included here. We have to make sure we get
// the DSound IKsPropertySet definition rather than the incorrect Ks one.
//
#include <windows.h>

#include <objbase.h>
#include <initguid.h>       // Bring in guids from dsprv.h
#include <mmsystem.h>
#include <dsound.h>
#include <dsprv.h>

class CDirectSoundPrivate
{
public:
    CDirectSoundPrivate();
    ~CDirectSoundPrivate();
    HRESULT Init();

    // IKsPropertySet methods
    //
    HRESULT Get(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG);
    HRESULT Set(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);
    HRESULT QuerySupport(REFGUID, ULONG, PULONG);

private:
    HINSTANCE m_hDSound;
    IKsPropertySet *m_pKsPropertySet;
};

CDirectSoundPrivate::CDirectSoundPrivate()
{
    m_hDSound = NULL;
    m_pKsPropertySet = NULL;
}

typedef HRESULT (*PDLLGETCLASSOBJECT)(const CLSID &clsid, const IID &iid, void **ppv);
HRESULT CDirectSoundPrivate::Init()
{
    PDLLGETCLASSOBJECT pDllGetClassObject;
    IClassFactory *pClassFactory;
    HRESULT hr;

    m_hDSound = LoadLibrary("dsound.dll");
    if (m_hDSound == NULL)
    {
        return E_NOINTERFACE;
    }

    pDllGetClassObject = (PDLLGETCLASSOBJECT)GetProcAddress(m_hDSound, "DllGetClassObject");
    if (pDllGetClassObject == NULL)
    {
        return E_NOINTERFACE;
    }

    hr = (*pDllGetClassObject)(CLSID_DirectSoundPrivate, 
                               IID_IClassFactory,
                               (void**)&pClassFactory);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    hr = pClassFactory->CreateInstance(NULL, IID_IKsPropertySet, (void**)&m_pKsPropertySet);
    pClassFactory->Release();

    return hr;
}

CDirectSoundPrivate::~CDirectSoundPrivate()
{
    if (m_pKsPropertySet) {
        m_pKsPropertySet->Release();
        m_pKsPropertySet = NULL;
    }

    if (m_hDSound) 
    {
        FreeLibrary(m_hDSound);
        m_hDSound = NULL;
    }
}

HRESULT CDirectSoundPrivate::Get(REFGUID rguidSet, ULONG ulItem, LPVOID pvInstance, ULONG cbInstance, LPVOID pvData, ULONG cbData, PULONG pcbData)
{
    if (m_pKsPropertySet) 
    {
        return m_pKsPropertySet->Get(rguidSet, ulItem, pvInstance, cbInstance, pvData, cbData, pcbData);
    }

    return E_NOINTERFACE;
}

HRESULT CDirectSoundPrivate::Set(REFGUID rguidSet, ULONG ulItem, LPVOID pvInstance, ULONG cbInstance, LPVOID pvData, ULONG cbData)
{
    if (m_pKsPropertySet) 
    {
        return m_pKsPropertySet->Set(rguidSet, ulItem, pvInstance, cbInstance, pvData, cbData);
    }

    return E_NOINTERFACE;
}

HRESULT CDirectSoundPrivate::QuerySupport(REFGUID rguidSet, ULONG ulItem, PULONG pulSupport)
{
    if (m_pKsPropertySet) 
    {
        return m_pKsPropertySet->QuerySupport(rguidSet, ulItem, pulSupport);
    }

    return E_NOINTERFACE;
}


// DirectSoundDevice
//
// Given an LPDIRECTSOUND, determine the device interface name associated with
// it.
//
HRESULT DirectSoundDevice(
    LPDIRECTSOUND                                   pDirectSound,
    LPSTR                                           *pstrInterface)
{
    HRESULT                                         hr;
    DSBUFFERDESC                                    BufferDesc;
    LPDIRECTSOUNDBUFFER                             pBuffer = NULL;
    DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA      DeviceId;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   DeviceDesc;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   *pDeviceDesc = NULL;
    ULONG                                           cb;
	PCMWAVEFORMAT                                   wfx;

    CDirectSoundPrivate                             DSPriv;
    
    hr = DSPriv.Init();

    if (FAILED(hr)) 
    {
        return hr;
    }


	ZeroMemory(&wfx, sizeof(wfx));
	wfx.wf.wFormatTag = WAVE_FORMAT_PCM;
	wfx.wf.nChannels = 1;
	wfx.wf.nSamplesPerSec = 22050;
	wfx.wf.nAvgBytesPerSec = 22050;
	wfx.wf.nBlockAlign = 1;
	wfx.wBitsPerSample = 8;

    ZeroMemory(&BufferDesc, sizeof(BufferDesc));
    BufferDesc.dwSize  = sizeof(BufferDesc);
    BufferDesc.dwBufferBytes = 32768;
    BufferDesc.lpwfxFormat = (LPWAVEFORMATEX)&wfx;
    
    hr = pDirectSound->CreateSoundBuffer(&BufferDesc, &pBuffer, NULL);
    if (FAILED(hr)) 
    {
        pBuffer = NULL;
        goto Cleanup;
    }
    
    DeviceId.Buffer = pBuffer;
    hr = DSPriv.Get(DSPROPSETID_DirectSoundBuffer,
                    DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID,
                    NULL,
                    0,
                    &DeviceId,
                    sizeof(DeviceId),
                    &cb);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    memset(&DeviceDesc, 0, sizeof(DeviceDesc));
    DeviceDesc.DeviceId = DeviceId.DeviceId;
    hr = DSPriv.Get(DSPROPSETID_DirectSoundDevice,
                    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                    NULL,
                    0,
                    &DeviceDesc,
                    sizeof(DeviceDesc),
                    &cb);
    if (FAILED(hr)) 
    {
        goto Cleanup;
    } 

	pDeviceDesc = &DeviceDesc;
    if (cb > sizeof(DeviceDesc)) 
    {
        pDeviceDesc = (DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA*) new BYTE[cb];
        if (!pDeviceDesc)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memset(pDeviceDesc, 0, cb);

        CopyMemory(pDeviceDesc, &DeviceDesc, sizeof(DeviceDesc));

        hr = DSPriv.Get(DSPROPSETID_DirectSoundDevice,
                        DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                        NULL,
                        0,
                        pDeviceDesc,
                        cb,
                        &cb);
    }

    if (pDeviceDesc->Interface == NULL)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    cb = strlen(pDeviceDesc->Interface);
    
    *pstrInterface = new char[cb + 1];
    if (!*pstrInterface)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    strcpy(*pstrInterface, pDeviceDesc->Interface);

Cleanup:
    if (pBuffer)        pBuffer->Release();
    if (pDeviceDesc && pDeviceDesc != &DeviceDesc)    
		delete[] (BYTE*)pDeviceDesc;

    return hr;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dswave.cpp ===
//
// dswave.cpp
//
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Support for streaming or oneshot waves from IDirectSoundWaveObject
//
//
#include <windows.h>
#include "dmusicp.h"
#include "DsWave.h"
#include "dmdls.h"
#include "dls1.h"
#include "dls2.h"

const DWORD gnRefTicksPerSecond = 10 * 1000 * 1000;

// Global list of all CDirectSoundWave objects in this process
//
CDirectSoundWaveList CDirectSoundWave::sDSWaveList;
CRITICAL_SECTION CDirectSoundWave::sDSWaveCritSect;

//#############################################################################
//
// CDirectSoundWaveDownload
//
// This class contains all the code to maintain one downloaded instance of a
// wave object. It is abstracted away from CDirectSoundWave (which represents
// an IDirectSoundDownloadedWave to the application) because of the case
// of streaming waves. Here's how it works:
//
// In the case of a one-shot download, there is only one set of buffers (one
// per channel in the source wave) for all voices playing the wave. Each
// buffer contains one channel of data for the entire length of the source
// wave. Since there is a one-to-one mapping of a buffer set (and associated
// download ID's) with the application-requested download, this case is
// handled by having CDirectSoundWave own one CDirectSoundWaveDownload.
//
// In the case of a streaming wave, what a download really does is to set up
// a ring of buffers that are kept full and refreshed by the voice service
// thread. There is one set of buffers (three buffer sets, each containing
// as many channels as the original source wave) per voice. Now there is a
// one-to-one correspondence between the downloaded buffer set and the voice,
// so the CDirectSoundWaveDownload is owned by each voice object playing
// the CDirectSoundWave.
//
//#############################################################################

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::CDirectSoundWaveDownload
//
CDirectSoundWaveDownload::CDirectSoundWaveDownload(
    CDirectSoundWave            *pDSWave,
    CDirectMusicPortDownload    *pPortDL,
    SAMPLE_TIME                 stStart,
    SAMPLE_TIME                 stReadAhead)
{
    m_pDSWave = pDSWave;
    m_pPortDL = pPortDL;

    m_ppWaveBuffer     = NULL;
	m_ppWaveBufferData = NULL;
    m_ppArtBuffer      = NULL;

    m_cDLRefCount  = 0;

    // Allocate download ID's
    //
    m_cSegments   = pDSWave->IsStreaming() ? gnDownloadBufferPerStream : 1;
    m_cWaveBuffer = m_cSegments * pDSWave->GetNumChannels();

    CDirectMusicPortDownload::GetDLIdP(&m_dwDLIdWave, m_cWaveBuffer);
    CDirectMusicPortDownload::GetDLIdP(&m_dwDLIdArt,  pDSWave->GetNumChannels());

    TraceI(2, "CDirectSoundWaveDownload: Allocating IDs: wave [%d..%d], art [%d..%d]\n",
        m_dwDLIdWave, m_dwDLIdWave + m_cWaveBuffer - 1,
        m_dwDLIdArt, m_dwDLIdArt + pDSWave->GetNumChannels() - 1);

    // Cache sample positions of where to start and how long the buffers are,
    // based on whether or not this is a streaming wave.
    //
    if (pDSWave->IsStreaming())
    {
        m_stStart     = stStart;
        m_stReadAhead = stReadAhead;
    }
    else
    {
        m_stStart     = 0;
        m_stReadAhead = ENTIRE_WAVE;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::~CDirectSoundWaveDownload
//
CDirectSoundWaveDownload::~CDirectSoundWaveDownload()
{
    if (m_cDLRefCount)
    {
        TraceI(0, "CDirectSoundWaveDownload %p: Released with download count %d\n",
            this,
            m_cDLRefCount);
    }

    if (m_ppWaveBuffer)
    {
        for (UINT idxWaveBuffer = 0; idxWaveBuffer < m_cWaveBuffer; idxWaveBuffer++)
        {
            RELEASE(m_ppWaveBuffer[idxWaveBuffer]);
        }

        delete[] m_ppWaveBuffer;
    }

    if (m_ppArtBuffer)
    {
        for (UINT idxArtBuffer = 0; idxArtBuffer < m_pDSWave->GetNumChannels(); idxArtBuffer++)
        {
            RELEASE(m_ppArtBuffer[idxArtBuffer]);
        }

		delete[] m_ppArtBuffer;
    }

	if(m_ppWaveBufferData)
	{
		delete[] m_ppWaveBufferData;
	}


	if(m_pWaveArt)
	{
		delete[] m_pWaveArt;
	}
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::Init
//
HRESULT CDirectSoundWaveDownload::Init()
{
    HRESULT hr = S_OK;

    m_pWaveArt = new CDirectSoundWaveArt[m_pDSWave->GetNumChannels()];

    hr = HRFromP(m_pWaveArt);

    //For the time being, assume the channel and BusId is the same
    //  Works for stereo.
    DWORD dwFlags = 0;
    if (m_pDSWave->GetNumChannels() > 1)
    {
        dwFlags = F_WAVELINK_MULTICHANNEL;
    }

    for (UINT idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
    {
        // XXX WAVEFORMATEXTENSIBLE parsing to get channel mappings should go here.
        //
        hr = m_pWaveArt[idx].Init(m_pDSWave, m_cSegments, (DWORD)idx, dwFlags);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::Download
//
HRESULT CDirectSoundWaveDownload::Download()
{
    HRESULT                 hr;

    hr = DownloadWaveBuffers();

    if (SUCCEEDED(hr))
    {
        hr = DownloadWaveArt();
    }

    if (SUCCEEDED(hr))
    {
        InterlockedIncrement(&m_cDLRefCount);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::Unload
//
HRESULT CDirectSoundWaveDownload::Unload()
{
    HRESULT                 hr;

    if (InterlockedDecrement(&m_cDLRefCount) != 0)
    {
        return S_OK;
    }

    hr = UnloadWaveArt();

    if (SUCCEEDED(hr))
    {
        hr = UnloadWaveBuffers();
    }

    if (FAILED(hr))
    {
        InterlockedIncrement(&m_cDLRefCount);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::RefreshThroughSample
//
HRESULT CDirectSoundWaveDownload::RefreshThroughSample(SAMPLE_POSITION sp)
{
    int cBuffersLeft;

    // Make sample position be in terms of the stream
    //
    sp += m_stStart;

    TraceI(0, "RTS: Adjusted sp %I64d m_stWrote %I64d m_stReadAhead %I64d m_stLength %I64d\n",
        sp, m_stWrote, m_stReadAhead, m_stLength);

    if (sp > m_stLength)
    {
        TraceI(0, "Wave is over\n");
        return S_FALSE;
    }

    if(sp <= m_stReadAhead && m_stWrote >= m_stReadAhead)
    {
        TraceI(0, "\nAlready have enough data in the buffers\n");
        return S_OK;
    }

    if(m_stWrote >= m_stLength)
    {
        TraceI(0, "Entire wave already in the buffer\n");
        return S_OK;
    }

    // How many buffers left to play?
    //
    if (sp >= m_stWrote)
    {
        TraceI(0, "RTS: Glitch!\n");
        // Glitch! Play cursor has gone beyond end of read buffers.
        //
        cBuffersLeft = 0;
    }
    else
    {
        // Calculate buffers left to play, including partial buffers
        //
        cBuffersLeft = (int)((m_stWrote - sp + m_stReadAhead - 1) / m_stReadAhead);
        assert(cBuffersLeft <= (int)m_cSegments);
        TraceI(0, "RTS: %d buffers left\n", cBuffersLeft);
    }

    HRESULT hr = S_OK;

    int cBuffersToFill = m_cSegments - cBuffersLeft;
    TraceI(0, "RTS: %d buffers to fill\n", cBuffersToFill);

    while (cBuffersToFill--)
    {
        TraceI(0, "Refilling buffer %d\n", m_nNextBuffer);
        hr = m_pDSWave->RefillBuffers(
            &m_ppWaveBufferData[m_nNextBuffer * m_pDSWave->GetNumChannels()],
            m_stWrote,
            m_stReadAhead,
            m_stReadAhead);

        TraceI(0, "Refill buffers returned %08X\n", hr);

        if (SUCCEEDED(hr))
        {
            DWORD dwDLId = m_dwDLIdWave + m_pDSWave->GetNumChannels() * m_nNextBuffer;

            for (UINT idxChannel = 0;
                 idxChannel < m_pDSWave->GetNumChannels() && SUCCEEDED(hr);
                 idxChannel++, dwDLId++)
            {
                // Need to preserve a return code of S_FALSE from RefillBuffers
                // across this call
                //
                TraceI(0, "Marking %d as valid.\n", dwDLId);
                HRESULT hrTemp = m_pPortDL->Refresh(
                    dwDLId,
                    0);
                if (FAILED(hrTemp))
                {
                    hr = hrTemp;
                }
            }

            if (SUCCEEDED(hr))
            {
                m_stWrote += m_stReadAhead;
                m_nNextBuffer = (m_nNextBuffer + 1) % m_cSegments;
            }
        }
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::DownloadWaveBuffers
//
HRESULT CDirectSoundWaveDownload::DownloadWaveBuffers()
{
    HRESULT                 hr = S_OK;
    bool                    fUnloadOnFail = false;
    UINT                    nChannels = m_pDSWave->GetNumChannels();
    DWORD                   dwDownloadType;

    dwDownloadType =
        (m_pDSWave->IsStreaming()) ?
            DMUS_DOWNLOADINFO_STREAMINGWAVE :
            DMUS_DOWNLOADINFO_ONESHOTWAVE;

    // Allocate space to hold the buffers we're going to download
    //
    if (m_ppWaveBuffer == NULL)
    {
        m_ppWaveBuffer = new IDirectMusicDownload*[m_cWaveBuffer];
        hr = HRFromP(m_ppWaveBuffer);
        if (SUCCEEDED(hr))
        {
            memset(m_ppWaveBuffer, 0, m_cWaveBuffer * sizeof(IDirectMusicDownload*));

            // Cache pointers into buffers so we don't continually have to
            // get them.
            //
            assert(!m_ppWaveBufferData);
            m_ppWaveBufferData = new LPVOID[m_cWaveBuffer];
            hr = HRFromP(m_ppWaveBufferData);
        }
    }

    // Figure out how much to add to each buffer
    //
    DWORD                   dwAppend;

    if (SUCCEEDED(hr))
    {
        hr = m_pPortDL->GetCachedAppend(&dwAppend);
    }

    if (SUCCEEDED(hr))
    {
        // Retrieved value is in samples. Convert to bytes.
        //
        dwAppend *= ((m_pDSWave->GetWaveFormat()->wBitsPerSample + 7) / 8);
    }

    // Seek to the start position in the stream
    //
    if (SUCCEEDED(hr))
    {
        m_pDSWave->Seek(m_stStart);
    }

    // Make sure the buffers are all allocated
    //
    if (SUCCEEDED(hr))
    {
        DWORD cbSize;

        m_pDSWave->GetSize(m_stReadAhead, &cbSize);
        cbSize += dwAppend;

        for (UINT idxBuffer = 0; (idxBuffer < m_cWaveBuffer) && SUCCEEDED(hr); idxBuffer++)
        {
            if (m_ppWaveBuffer[idxBuffer])
            {
                continue;
            }

            hr = m_pPortDL->AllocateBuffer(cbSize, &m_ppWaveBuffer[idxBuffer]);

            if (SUCCEEDED(hr))
            {
                DWORD cb;
                hr = m_ppWaveBuffer[idxBuffer]->GetBuffer(
                    &m_ppWaveBufferData[idxBuffer], &cb);
            }
        }
    }

    // We have all the buffers. Try to download if needed.
    //
    if (SUCCEEDED(hr))
    {
        SAMPLE_TIME             stStart = m_stStart;
        SAMPLE_TIME             stRead;
        DWORD                   dwDLId = m_dwDLIdWave;
        IDirectMusicDownload  **ppBuffers = &m_ppWaveBuffer[0];
        UINT                    idxSegment;
        UINT                    idxChannel;
        void                  **ppv = m_ppWaveBufferData;

        m_stLength    = m_pDSWave->GetStreamSize();
        m_stWrote     = m_stStart;
        m_nNextBuffer = 0;

        for (idxSegment = 0;
             idxSegment < m_cSegments;
             idxSegment++, dwDLId += nChannels, ppBuffers += nChannels, ppv += nChannels)
        {
            // Since we guarantee that if one buffer gets downloaded, all
            // get downloaded, we only need to check the first download ID
            // to see if all channels of this segment are already downloaded
            //
            IDirectMusicDownload *pBufferTemp;
            HRESULT hrTemp = m_pPortDL->GetBufferInternal(dwDLId, &pBufferTemp);
            if (SUCCEEDED(hrTemp))
            {
                TraceI(1, "Looks like buffer %d is already downloaded.", dwDLId);
                pBufferTemp->Release();
                continue;
            }

            // There is at least one buffer not downloaded, so yank back
            // everything on failure to guarantee all or nothing.
            //
            fUnloadOnFail = true;

            // We need to download. Get the buffer pointers and fill them with
            // wave data.
            //
            if (SUCCEEDED(hr))
            {
                stRead = min(m_stLength - m_stWrote, m_stReadAhead);
				hr = m_pDSWave->Write(ppv, stStart, stRead, dwDLId, dwDownloadType);
            }

            if (SUCCEEDED(hr))
            {
                // Now try to do the actual downloads
                //
                for (idxChannel = 0;
                     (idxChannel < nChannels) && SUCCEEDED(hr);
                     idxChannel++)
                {
                    hr = m_pPortDL->Download(ppBuffers[idxChannel]);
                }
            }

            TraceI(2, "Downloading wave buffers with dlid %d\n", dwDLId);

            if (SUCCEEDED(hr))
            {
                stStart += stRead;
                m_stWrote += stRead;
                m_nNextBuffer = (m_nNextBuffer + 1) % m_cSegments;
            }
        }
    }

    if (FAILED(hr) && fUnloadOnFail)
    {
        UnloadWaveBuffers();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::UnloadWaveBuffers
//
HRESULT CDirectSoundWaveDownload::UnloadWaveBuffers()
{
    HRESULT                 hr = S_OK;

    if (m_ppWaveBuffer)
    {
        for (UINT idxWaveBuffer = 0; idxWaveBuffer < m_cWaveBuffer; idxWaveBuffer++)
        {
            if (m_ppWaveBuffer[idxWaveBuffer])
            {
                HRESULT hrTemp = m_pPortDL->Unload(m_ppWaveBuffer[idxWaveBuffer]);
				m_ppWaveBuffer[idxWaveBuffer]->Release();
				m_ppWaveBuffer[idxWaveBuffer] = NULL; // Since we unloaded the buffer, zero out the contents


                if (FAILED(hrTemp) && hrTemp != DMUS_E_NOT_DOWNLOADED_TO_PORT)
                {
                    hr = hrTemp;
                }
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::DownloadWaveArt
//
HRESULT CDirectSoundWaveDownload::DownloadWaveArt()
{
    HRESULT                 hr = S_OK;
    UINT                    idx;

    // First see if there are wave articulation buffers already downloaded
    //
    if (m_ppArtBuffer == NULL)
    {
        m_ppArtBuffer = new IDirectMusicDownload*[m_pDSWave->GetNumChannels()];

        hr = HRFromP(m_ppArtBuffer);

        if (SUCCEEDED(hr))
        {
            memset(m_ppArtBuffer, 0, sizeof(IDirectMusicDownload*) * m_pDSWave->GetNumChannels());

            for (idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
            {
                hr = m_pPortDL->AllocateBuffer(m_pWaveArt[idx].GetSize(), &m_ppArtBuffer[idx]);
            }
        }

        if (FAILED(hr))
        {
            if (m_ppArtBuffer)
            {
                for (idx = 0; idx < m_pDSWave->GetNumChannels(); idx++)
                {
                    RELEASE(m_ppArtBuffer[idx]);
                }

                delete[] m_ppArtBuffer;
                m_ppArtBuffer = NULL;
            }
        }
    }

    // Make sure the buffers are all allocated
    //
    if (SUCCEEDED(hr))
    {
        for (idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
        {
            if (m_ppArtBuffer[idx])
            {
                continue;
            }

            hr = m_pPortDL->AllocateBuffer(m_pWaveArt[idx].GetSize(), &m_ppArtBuffer[idx]);
        }

        if (FAILED(hr))
        {
            for (idx = 0; idx < m_pDSWave->GetNumChannels(); idx++)
            {
                RELEASE(m_ppArtBuffer[idx]);
            }

            delete[] m_ppArtBuffer;
            m_ppArtBuffer = NULL;
        }
    }

    // We have all the buffers. Try to download if needed.
    //
    if (SUCCEEDED(hr))
    {
        for (idx = 0; idx < m_pDSWave->GetNumChannels() && SUCCEEDED(hr); idx++)
        {
            IDirectMusicDownload *pBufferTemp;

            HRESULT hrTemp = m_pPortDL->GetBufferInternal(m_dwDLIdArt + idx, &pBufferTemp);
            if (SUCCEEDED(hrTemp))
            {
                pBufferTemp->Release();
            }
            else
            {
                assert(hrTemp == DMUS_E_NOT_DOWNLOADED_TO_PORT);

                LPVOID          pv;
                DWORD           cb;

                hr = m_ppArtBuffer[idx]->GetBuffer(&pv, &cb);

                if (SUCCEEDED(hr))
                {
                    m_pWaveArt[idx].Write(pv, m_dwDLIdArt + idx, m_dwDLIdWave + idx, m_dwDLIdArt);
                }

                if (SUCCEEDED(hr))
                {
                    hr = m_pPortDL->Download(m_ppArtBuffer[idx]);

                    if (FAILED(hr))
                    {
                        UnloadWaveArt();
                    }
                    else
                    {
                        TraceI(0, "Downloading wave art DLID %d\n", m_dwDLIdArt);
                    }
                }
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload::UnloadWaveArt
//
HRESULT CDirectSoundWaveDownload::UnloadWaveArt()
{
    HRESULT                     hr = S_OK;
    UINT                        idx;

    if (m_ppArtBuffer)
    {
        for (idx = 0; idx < m_pDSWave->GetNumChannels(); idx++)
        {
            if (m_ppArtBuffer[idx])
            {
                HRESULT hrTemp = m_pPortDL->Unload(m_ppArtBuffer[idx]);
                m_ppArtBuffer[idx]->Release();
                m_ppArtBuffer[idx] = NULL; // Since we unloaded the buffer, zero out the contents

                if (FAILED(hrTemp) && hrTemp != DMUS_E_NOT_DOWNLOADED_TO_PORT)
                {
                    hr = hrTemp;
                }
            }
        }
    }

    return hr;
}

//#############################################################################
//
// CDirectSoundWave
//
// This class represents a downloaded wave object from the application's
// perspective. It is the implementation of the IDirectSoundDownloadedWave
// object returned to the application from CDirectMusicPort::DownloadWave.
//
// The actual download mechanism will either be delegated to a
// CDirectSoundWaveDownload object and done when the application requests
// the download (one-shot case) or deferred until a voice is allocated on
// the wave (streaming case). See the comments for CDirectSoundWaveDownload.
//
//#############################################################################


////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::CDirectSoundWave
//
CDirectSoundWave::CDirectSoundWave(
    IDirectSoundWave *pIDSWave,
    bool fStreaming,
    REFERENCE_TIME rtReadAhead,
    bool fUseNoPreRoll,
    REFERENCE_TIME rtStartHint) :
    m_cRef(1),
    m_fStreaming(fStreaming),
    m_rtReadAhead(rtReadAhead),
    m_fUseNoPreRoll(fUseNoPreRoll),
    m_rtStartHint(rtStartHint),
    m_pDSWD(NULL),
    m_rpv(NULL),
    m_rpbPrecache(NULL),
	m_pSource(NULL)
{
    m_pIDSWave = pIDSWave;
    m_pIDSWave->AddRef();
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::~CDirectSoundWave
//
CDirectSoundWave::~CDirectSoundWave()
{
    delete[] m_rpv;
    delete m_pDSWD;

    if (m_rpbPrecache)
    {
        // NOTE: Memory is allocated into first array element and the other
        // elements just point at offsets into the block, so only free
        // the first element.
        //
        delete[] m_rpbPrecache[0];
        delete[] m_rpbPrecache;
        m_rpbPrecache = NULL;
    }

    if (m_pwfex)
    {
        BYTE *pb = (BYTE*)m_pwfex;
        delete[] pb;
        m_pwfex = NULL;
    }


    RELEASE(m_pSource);
    RELEASE(m_pIDSWave);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::QueryInterface
//
STDMETHODIMP CDirectSoundWave::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(IDirectSoundWave::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectSoundDownloadedWaveP)
    {
        *ppv = static_cast<IDirectSoundDownloadedWaveP*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::AddRef
//
STDMETHODIMP_(ULONG) CDirectSoundWave::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Release
//
STDMETHODIMP_(ULONG) CDirectSoundWave::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        EnterCriticalSection(&sDSWaveCritSect);
        sDSWaveList.Remove(this);
        LeaveCriticalSection(&sDSWaveCritSect);

        delete this;
        return 0;
    }

    return m_cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::GetMatchingDSWave
//
// See if there's an object yet matching this IDirectSoundWave
//
CDirectSoundWave *CDirectSoundWave::GetMatchingDSWave(
    IDirectSoundWave *pIDSWave)
{
    CDirectSoundWave *pDSWave;

    EnterCriticalSection(&sDSWaveCritSect);

    for (pDSWave = sDSWaveList.GetHead(); pDSWave; pDSWave = pDSWave->GetNext())
    {
        if (pDSWave->m_pIDSWave == pIDSWave)
        {
            break;
        }
    }

    LeaveCriticalSection(&sDSWaveCritSect);

    if (pDSWave)
    {
        pDSWave->AddRef();
    }

    return pDSWave;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Init
//
// Save the wave format of the source wave, and verify that it's a PCM format.
//
//
HRESULT CDirectSoundWave::Init(
    CDirectMusicPortDownload *pPortDL)
{
    HRESULT hr = S_OK;

    DWORD cbwfex;

    // Get the format of the wave
    //
    if (SUCCEEDED(hr))
    {
        cbwfex = 0;
        hr = m_pIDSWave->GetFormat(NULL, 0, &cbwfex);
    }

    if (SUCCEEDED(hr))
    {
        BYTE *pb = new BYTE[cbwfex];
        m_pwfex = (LPWAVEFORMATEX)pb;

        hr = HRFromP(pb);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pIDSWave->GetFormat(m_pwfex, cbwfex, NULL);
    }

    // Synthesizers currently only support PCM format data
    //
    if (SUCCEEDED(hr) && m_pwfex->wFormatTag != WAVE_FORMAT_PCM)
    {
        hr = DMUS_E_NOTPCM;
    }

    // Figure out bytes per sample to avoid lots of divisions later
    //
    if (SUCCEEDED(hr))
    {
        m_nBytesPerSample = ((m_pwfex->wBitsPerSample + 7) / 8);
    }
    // Allocate working pointers. These are used for passing
    // to the wave object to get n channels worth of data for
    // one buffer segment. Keeping this around help us not
    // fail from out-of-memory while streaming.
    //
    if (SUCCEEDED(hr))
    {
        m_rpv = new LPVOID[GetNumChannels()];
        hr = HRFromP(m_rpv);
    }

    // Get a viewport
    //
    if (SUCCEEDED(hr))
    {
        // This is bytes per sample in one channel only.
        //
        m_cbSample = (m_pwfex->wBitsPerSample + 7) / 8;

        DWORD dwFlags = IsStreaming() ? DMUS_DOWNLOADINFO_STREAMINGWAVE : DMUS_DOWNLOADINFO_ONESHOTWAVE;
        hr = m_pIDSWave->CreateSource(&m_pSource, m_pwfex, dwFlags);
    }

    // Get the length of the wave in samples
    //
    ULONGLONG ullStreamSize;
    if (SUCCEEDED(hr))
    {
        hr = m_pSource->GetSize(&ullStreamSize);
    }

    if (SUCCEEDED(hr))
    {
        m_stLength = BytesToSamples((LONG)(ullStreamSize / GetNumChannels()));
    }

    // If a one-shot voice, this object owns the actual download
    // structures as well.
    //
    // This has to happen last because it assumes the CDirectSoundWave
    // object passed is initialized.
    //
    if (SUCCEEDED(hr) && !IsStreaming())
    {
        m_pDSWD = new CDirectSoundWaveDownload(
            this,
            pPortDL,
            0,
            ENTIRE_WAVE);
        hr = HRFromP(m_pDSWD);

        if (SUCCEEDED(hr))
        {
            hr = m_pDSWD->Init();
        }
    }

    // If this is a streaming wave, then preread starting at rtStartHint
    // so that we won't have to do this at download time.
    //
    if (SUCCEEDED(hr) && IsStreaming() && m_fUseNoPreRoll == false)
    {
        // Allocate precache pointers. This is used to
        // preread wave data so we don't have to do it
        // at download time.
        //
        SAMPLE_TIME stReadAhead = RefToSampleTime(m_rtReadAhead);
        stReadAhead *= gnDownloadBufferPerStream;
        DWORD cb = SamplesToBytes(stReadAhead);

        m_rpbPrecache = new LPBYTE[GetNumChannels()];
        hr = HRFromP(m_rpbPrecache);

        // Now get the actual precache buffers
        //
        if (SUCCEEDED(hr))
        {
            m_rpbPrecache[0] = new BYTE[cb * GetNumChannels()];
            hr = HRFromP(m_rpbPrecache);
        }

        if (SUCCEEDED(hr))
        {
            for (UINT i = 1; i < GetNumChannels(); i++)
            {
                m_rpbPrecache[i] = m_rpbPrecache[i - 1] + cb;
            }
        }

        if (SUCCEEDED(hr))
        {
            m_stStartHint = RefToSampleTime(m_rtStartHint);
            hr = Seek(m_stStartHint);
        }

        if (SUCCEEDED(hr))
        {
            LONG lReadPrecache = 2;
            ULONGLONG cbRead = cb;
            hr = m_pSource->Read((LPVOID*)m_rpbPrecache, NULL, NULL, &lReadPrecache, GetNumChannels(), &cbRead);

            if (FAILED(hr) || (((DWORD)cbRead) < cb))
            {
                // Read completed but with less sample data than we expected.
                // Fill the rest of the buffer with silence.
                //
                cb -= (DWORD)cbRead;
                BYTE bSilence = (m_pwfex->wBitsPerSample == 8) ? 0x80 : 0x00;

                for (UINT i = 0; i < GetNumChannels(); i++)
                {
                    memset(m_rpbPrecache[i] + cbRead, bSilence, cb);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            m_stStartLength = stReadAhead;
        }
    }

    if (SUCCEEDED(hr) && !IsStreaming())
    {
        // Everything constructed. Put this object on the global list of
        // waves
        //
        EnterCriticalSection(&sDSWaveCritSect);
        sDSWaveList.AddTail(this);
        LeaveCriticalSection(&sDSWaveCritSect);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::GetSize
//
void CDirectSoundWave::GetSize(
    SAMPLE_TIME             stLength,
    PULONG                  pcbSize) const
{
    HRESULT                 hr = S_OK;

    // Since we're only dealing with PCM formats here, this is easy to compute
    // and is time invariant.
    //

    // If stLength is ENTIRE_WAVE, stStart must be zero.
    //
    if (stLength == ENTIRE_WAVE)
    {
        // We cached the length of the wave in Init
        //
        stLength = m_stLength;
    }

    // This is a workaround to not fail when downloading
    // the buffers to the synth. The synth will complain
    // if the buffer has no wave data so we pretend we have one sample.
    // The buffer is always aloocated to be the ReadAhead size so this
    // shouldn't cause any major problems
    if(stLength == 0)
    {
        stLength = 1;
    }

    // Bytes for one channel's worth of data
    //
    // XXX Overflow?
    //
    DWORD cbChannel = (DWORD)(stLength * m_cbSample);

    // We need:
    // 1. Download header
    // 2. Offset table (one entry per channel)
    // 3. Enough samples per each channel
    //
    *pcbSize =
        CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)) +
        2*sizeof(DWORD) +                       // Offset table. DWORD's are
                                                // by definition chunk aligned
        CHUNK_ALIGN(sizeof(DMUS_WAVEDL)) +
        CHUNK_ALIGN(cbChannel);
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Write
//
//
HRESULT CDirectSoundWave::Write(
    LPVOID                  rpv[],
    SAMPLE_TIME             stStart,
    SAMPLE_TIME             stLength,
    DWORD                   dwDLId,
    DWORD                   dwDLType) const
{
    HRESULT                 hr = S_OK;
    DWORD                   cbWaveData;
    ULONGLONG               cbBytesRead = 0;
    bool                    fUsingPrecache = false;
    bool                    fPartialPreCache = false;
    DWORD                   offPrecache;

    if (IsStreaming() && 
        m_fUseNoPreRoll == false &&
        m_stStartHint <= stStart &&
        stStart <= m_stStartHint + m_stStartLength)
    {
        fUsingPrecache = true;
        offPrecache = SamplesToBytes(stStart - m_stStartHint);
    }

    if((stStart + stLength > m_stStartHint + m_stStartLength) && fUsingPrecache)
    {
        fPartialPreCache = true;
    }

    cbWaveData = SamplesToBytes(stLength);

    for (UINT idxChannel = 0;
         idxChannel < m_pwfex->nChannels && SUCCEEDED(hr);
         idxChannel++)
    {
        unsigned char *pdata = (unsigned char *)rpv[idxChannel];

        // First we have the download header
        //
        DMUS_DOWNLOADINFO *pdmdli = (DMUS_DOWNLOADINFO *)pdata;

        memset(pdmdli, 0, sizeof(DMUS_DOWNLOADINFO));
        pdmdli->dwDLType                = dwDLType;
        pdmdli->dwDLId                  = dwDLId + idxChannel;
        pdmdli->dwNumOffsetTableEntries = 2;

        GetSize(stLength, &pdmdli->cbSize);

        pdata += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

        // Offset table
        //
        DMUS_OFFSETTABLE *pot = (DMUS_OFFSETTABLE*)pdata;
        pdata += CHUNK_ALIGN(sizeof(ULONG) * 2);

        // Wave header chunk
        //
        pot->ulOffsetTable[0] = (ULONG)(pdata - (unsigned char*)rpv[idxChannel]);

        // Wave data chunk
        //
        DMUS_WAVEDL *pwdl = (DMUS_WAVEDL *)pdata;
        pdata += CHUNK_ALIGN(sizeof(DMUS_WAVEDL));

        pwdl->cbWaveData = cbWaveData;

        // Save off pointer to this channel's wave data
        //
        pot->ulOffsetTable[1] = (ULONG)(pdata - (unsigned char*)rpv[idxChannel]);
        m_rpv[idxChannel] = (LPVOID)pdata;
    }

    // Fill in the wave data
    //
    if (SUCCEEDED(hr))
    {
        DWORD cbPreCache = cbWaveData;
        cbBytesRead = cbPreCache;
        ULONGLONG cbRead = 0;

        if(fPartialPreCache)
        {
            SAMPLE_TIME stPreCache = (m_stStartHint + m_stStartLength) - stStart;
            cbPreCache = SamplesToBytes(stPreCache);
            cbRead = cbWaveData - cbPreCache;
        }

        if (fUsingPrecache)
        {
            for (UINT i = 0; i < GetNumChannels(); i++)
            {
                memcpy(m_rpv[i], m_rpbPrecache[i] + offPrecache, cbPreCache);
            }

            // Cache doesn't have enough data so we read the rest
            if(fPartialPreCache)
            {
                // Allocate a temporary pool of buffers to read data into
                LPBYTE* ppbData = new LPBYTE[GetNumChannels()];
                hr = HRFromP(ppbData);

                if(SUCCEEDED(hr))
                {
                    ppbData[0] = new BYTE[(DWORD)(cbRead * GetNumChannels())];
                    hr = HRFromP(ppbData);
                }

                if (SUCCEEDED(hr))
                {
                    for (UINT nChannel = 1; nChannel < GetNumChannels(); nChannel++)
                    {
                        ppbData[nChannel] = ppbData[nChannel - 1] + cbRead;
                    }
                }

                if(SUCCEEDED(hr))
                {
                    // Seek to precache position
                    DWORD cbNewPos = SamplesToBytes(m_stStartHint + m_stStartLength) * GetNumChannels();
                    hr = m_pSource->Seek(cbNewPos);

                    // And read the required number of bytes from there
                    // We use the LPLONG plPitchShifts in the read method as a boolean
                    // this is a HACK!! We need to change this...
                    LONG lPreCacheRead = 1;
                    hr = m_pSource->Read((void**)ppbData, NULL, NULL, &lPreCacheRead, m_pwfex->nChannels, &cbRead);
                }

                if(SUCCEEDED(hr))
                {
                    cbBytesRead += cbRead;

                    // Copy all the data to the actual buffer
                    for (UINT i = 0; i < GetNumChannels(); i++)
                    {
                        memcpy((BYTE*)m_rpv[i] + cbPreCache, ppbData[i], (DWORD)cbRead);
                    }
                }


                if(ppbData)
                {
                    delete[] ppbData[0];
                    delete[] ppbData;
                }
            }
            else if(stStart + stLength >= m_stStartHint + m_stStartLength)
            {
                // Seek is exactly after the precached samples
                DWORD cbNewPos = SamplesToBytes(m_stStartHint + m_stStartLength) * GetNumChannels();
                hr = m_pSource->Seek(cbNewPos);
            }
            else
            {
                // We might have a wave that's shorter than the read-ahead time
                DWORD cbNewPos = SamplesToBytes(stStart + stLength) * GetNumChannels();
                hr = m_pSource->Seek(cbNewPos);
            }
        }
        else
        {
            cbRead = cbWaveData;
            hr = m_pSource->Read(m_rpv, NULL, NULL, NULL, m_pwfex->nChannels, &cbRead);
        }
    }

    if (SUCCEEDED(hr) && cbWaveData != cbBytesRead)
    {
        // Read completed but with less sample data than we expected.
        //
        hr = S_FALSE;
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::RefillBuffers
//
// rpv[] points to one sample buffer per channel
// stStart is the sample starting position within the stream
// stLength is how many samples to read
// stBufferSize is how big the buffers actually are (>= stLength)
//
// If stLength < stBufferSize or there is not enough data left
// in the stream, then fill with PCM silence for the rest of
// the buffer.
//
// Returns S_FALSE if we padded with silence (and therefore
// are past the end of the stream).
//
HRESULT CDirectSoundWave::RefillBuffers(
    LPVOID                  rpv[],
    SAMPLE_TIME             stStart,
    SAMPLE_TIME             stLength,
    SAMPLE_TIME             stBufferSize)
{
    HRESULT                 hr = S_OK;
    ULONGLONG               cbRead;
    DWORD                   cbLength = SamplesToBytes(stLength);
    DWORD                   cbBuffer = SamplesToBytes(stBufferSize);
    UINT                    idxChannel;

    for (idxChannel = 0;
         idxChannel < m_pwfex->nChannels && SUCCEEDED(hr);
         idxChannel++)
    {
        unsigned char *pdata = (unsigned char *)rpv[idxChannel];
        DMUS_OFFSETTABLE *pot =
            (DMUS_OFFSETTABLE *)(pdata + CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)));

        // Update length of data in buffer
        //
        DMUS_WAVEDL *pwdl = (DMUS_WAVEDL*)(pdata + pot->ulOffsetTable[0]);
        pwdl->cbWaveData = SamplesToBytes(stLength);

        // Where to put it
        //
        m_rpv[idxChannel] = pdata + pot->ulOffsetTable[1];
    }

    cbRead = 0;
    if (SUCCEEDED(hr))
    {
        cbRead = cbLength;
        if(stStart == m_stStartHint + m_stStartLength)
        {
            // We use the LPLONG plPitchShifts in the read method as a boolean
            // this is a HACK!! We need to change this...
            LONG lPreCacheRead = 1;
            hr = m_pSource->Read(m_rpv, NULL, NULL, &lPreCacheRead, m_pwfex->nChannels, &cbRead);
        }
        else
        {
            hr = m_pSource->Read(m_rpv, NULL, NULL, NULL, m_pwfex->nChannels, &cbRead);
        }
    }

    TraceI(0, "Wave: RefillBuffer read %d buffer %d bytes hr %08X\n", (DWORD)cbRead, (DWORD)cbBuffer, hr);

    if (FAILED(hr) || (SUCCEEDED(hr) && (cbRead < cbBuffer)))
    {
        // Read completed but with less sample data than we expected.
        // Fill the rest of the buffer with silence.
        //
        cbBuffer -= (DWORD)cbRead;
        BYTE bSilence = (m_pwfex->wBitsPerSample == 8) ? 0x80 : 0x00;

        for (idxChannel = 0; idxChannel < m_pwfex->nChannels; idxChannel++)
        {
            memset(((LPBYTE)m_rpv[idxChannel]) + cbRead, bSilence, cbBuffer);
        }

        TraceI(0, "Wave: RefillBuffer padded with silence\n");
        hr = S_FALSE;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::RefToSampleTime
//
SAMPLE_TIME CDirectSoundWave::RefToSampleTime(REFERENCE_TIME rt) const
{
    // For PCM, the samples per second metric in the waveformat is exact.
    //
    return (rt * m_pwfex->nSamplesPerSec) / gnRefTicksPerSecond;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Download
//
HRESULT CDirectSoundWave::Download()
{
    if (m_pDSWD)
    {
        return m_pDSWD->Download();
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave::Unload
//
HRESULT CDirectSoundWave::Unload()
{
    if (m_pDSWD)
    {
        return m_pDSWD->Unload();
    }

    return S_OK;
}

//#############################################################################
//
// CDirectSoundWaveArt
//
// Implements calculating and writing the wave articulation header into a
// download buffer.
//
//#############################################################################

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::CDirectSoundWaveArt
//
//
CDirectSoundWaveArt::CDirectSoundWaveArt()
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::CDirectSoundWaveArt
//
//
CDirectSoundWaveArt::~CDirectSoundWaveArt()
{
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::Init
//
//
HRESULT CDirectSoundWaveArt::Init(
    CDirectSoundWave        *pDSWave,
    UINT                    nSegments,
    DWORD                   dwBus,
    DWORD                   dwFlags)
{
    HRESULT                 hr = S_OK;

    m_pDSWave = pDSWave;
    const LPWAVEFORMATEX    pwfex = pDSWave->GetWaveFormat();

    // Cache wave format size
    //
    m_cbWaveFormat = sizeof(PCMWAVEFORMAT);
    if (pwfex->wFormatTag != WAVE_FORMAT_PCM)
    {
        m_cbWaveFormat = sizeof(WAVEFORMATEX) + pwfex->cbSize;
    }

    if (SUCCEEDED(hr))
    {
        // This stuff in the wave articulation never changes
        //
        m_WaveArtDL.ulDownloadIdIdx = 1;
        m_WaveArtDL.ulBus           = dwBus;
        m_WaveArtDL.ulBuffers       = nSegments;
        m_WaveArtDL.usOptions       = (USHORT)dwFlags;

        m_nDownloadIds = nSegments;
        DWORD cbDLIds = sizeof(DWORD) * m_nDownloadIds;

        m_cbSize =
            CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO)) +
            CHUNK_ALIGN(3 * sizeof(ULONG)) +            // 3 entry offset table
            CHUNK_ALIGN(sizeof(DMUS_WAVEARTDL)) +
            CHUNK_ALIGN(m_cbWaveFormat) +
            CHUNK_ALIGN(cbDLIds);
    }

   return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt::Write
//
// Write the wave articulation into the buffer
//
//
void CDirectSoundWaveArt::Write(
    void                    *pv,                // To pack into
    DWORD                   dwDLIdArt,          // Articulation chunk DLID
    DWORD                   dwDLIdWave,         // First wave DLId
    DWORD                   dwMasterDLId)       // DLId of group master
{
    unsigned char *pdata = (unsigned char *)pv;
    DMUS_DOWNLOADINFO *pdmdli = (DMUS_DOWNLOADINFO *)pdata;

    memset(pdmdli, 0, sizeof(DMUS_DOWNLOADINFO));
    pdmdli->dwDLType                = DMUS_DOWNLOADINFO_WAVEARTICULATION;
    pdmdli->dwDLId                  = dwDLIdArt;
    pdmdli->dwNumOffsetTableEntries = 3;
    pdmdli->cbSize                  = GetSize();

    pdata += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

    DMUS_OFFSETTABLE *pot = (DMUS_OFFSETTABLE*)pdata;
    pdata += CHUNK_ALIGN(3 * sizeof(ULONG));

    pot->ulOffsetTable[0] = (ULONG)(pdata - (unsigned char *)pv);
    m_WaveArtDL.ulMasterDLId = dwMasterDLId;
    memcpy(pdata, &m_WaveArtDL, sizeof(DMUS_WAVEARTDL));

    pdata += sizeof(DMUS_WAVEARTDL);
    pot->ulOffsetTable[1] = (ULONG)(pdata - (unsigned char *)pv);

    const LPWAVEFORMATEX     pwfex = m_pDSWave->GetWaveFormat();
    memcpy(pdata, pwfex, m_cbWaveFormat);

    pdata += CHUNK_ALIGN(m_cbWaveFormat);
    pot->ulOffsetTable[2] = (ULONG)(pdata - (unsigned char *)pv);

    // Get the download ID's. The download ID's for each buffer are
    // grouped together.
    //
    DWORD nChannels = pwfex->nChannels;
    DWORD dwLastWaveDLId = dwDLIdWave + nChannels * m_WaveArtDL.ulBuffers;
    DWORD dwDLId;
    DWORD *pdw = (DWORD*)pdata;

    for (dwDLId = dwDLIdWave; dwDLId < dwLastWaveDLId; dwDLId += nChannels, pdw++)
    {
        *pdw = dwDLId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\dswave.h ===
//
// dswave.h
// 
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Support for streaming or oneshot waves from IDirectSoundWaveObject
//
//
#ifndef _DSWAVE_H_
#define _DSWAVE_H_

#include "alist.h"

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

#define MAX_CHANNELS    32                      // XXX Is this ok?

// Number of download buffers per streaming wave
//
const UINT gnDownloadBufferPerStream = 3;


class CDirectSoundWave;

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveArt
//
// Wraps wave articulation data
//
class CDirectSoundWaveArt
{
public:
    CDirectSoundWaveArt();
    ~CDirectSoundWaveArt();
    
    HRESULT Init(CDirectSoundWave *pDSWave, UINT nSegments, DWORD dwBus, DWORD dwFlags);

    inline DWORD GetSize() const
    { return m_cbSize; }
   
    void Write(void *pvoid, DWORD dwDLIdArt, DWORD dwDLIdWave, DWORD dwMasterDLId);
    
private:    
    CDirectSoundWave   *m_pDSWave;              // Owning CDirectSoundWave
    DMUS_WAVEARTDL      m_WaveArtDL;            // Wave articulation
    DWORD               m_cbSize;               // Size of download
    UINT                m_nDownloadIds;         // Expected # of download ID's
    DWORD               m_cbWaveFormat;         // Size needed to pack wave format
};

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveDownload
//
// Tracks a set of downloaded wave buffers.
//
//
class CDirectSoundWaveDownload
{
public:
    CDirectSoundWaveDownload(
        CDirectSoundWave           *pDSWave, 
        CDirectMusicPortDownload   *pPortDL,
        SAMPLE_TIME                 stStart,
        SAMPLE_TIME                 stReadAhead);
        
    ~CDirectSoundWaveDownload();
    
    // Initialize
    //
    HRESULT Init();

    // Download wave buffers and articulation. In the case of streaming this
    // means downloading readahead data.
    //    
    HRESULT Download();                         
    
    // Unload everything
    //
    HRESULT Unload();
    
    // Notification that the stream has reached a certain sample position;
    // refresh the buffers as needed. (Streaming only)
    //
    HRESULT RefreshThroughSample(SAMPLE_POSITION sp);
    
    // Return the articulation download ID
    //
    inline DWORD GetDLId()
    { return m_dwDLIdArt; }
    
private:
    CDirectSoundWave           *m_pDSWave;          // Wave object
    CDirectMusicPortDownload   *m_pPortDL;          // Port download object
    
    CDirectSoundWaveArt        *m_pWaveArt;         // Wave articulation wrapper
    DWORD                       m_dwDLIdWave;       // First wave buffer DLID
    DWORD                       m_dwDLIdArt;        // Articulation DLID
    UINT                        m_cSegments;        // How many segments? 
    UINT                        m_cWaveBuffer;      // Number of wave buffers
    IDirectMusicDownload      **m_ppWaveBuffer;     // Wave download buffers
    void                      **m_ppWaveBufferData; //  and their data
    IDirectMusicDownload      **m_ppArtBuffer;      // Articulation buffers (one per channel)
    SAMPLE_TIME                 m_stStart;          // Starting sample
    SAMPLE_TIME                 m_stReadAhead;      // Read ahead (buffer length)
    LONG                        m_cDLRefCount;      // Download reference count
    SAMPLE_TIME                 m_stLength;         // How many samples to 
                                                    //  process? (Lenth of
                                                    //  stream - start pos)
    SAMPLE_TIME                 m_stWrote;          // Buffer-aligned sample
                                                    //  written through                                                    
    UINT                        m_nNextBuffer;      // Next buffer that should
                                                    // be filled.                                                    
    
private:
    HRESULT DownloadWaveBuffers();
    HRESULT UnloadWaveBuffers();
    HRESULT DownloadWaveArt();
    HRESULT UnloadWaveArt();
};

class CDirectSoundWaveList;

#define ENTIRE_WAVE ((SAMPLE_TIME)0x7FFFFFFFFFFFFFFF)

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWave
//
// Internal wrapper for an external IDirectSoundWave.
//
class CDirectSoundWave : public IDirectSoundDownloadedWaveP, public AListItem
{
public:
    // IUnknown
    //
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *);
    STDMETHOD_(ULONG,AddRef)        (THIS);
    STDMETHOD_(ULONG,Release)       (THIS);
    
    CDirectSoundWave(
        IDirectSoundWave            *pIDSWave, 
        bool                        fStreaming, 
        REFERENCE_TIME              rtReadAhead,
        bool                        fUseNoPreRoll,
        REFERENCE_TIME              rtStartHint);
    ~CDirectSoundWave();


    // Find a CDirectSoundWave matching an IDirectSoundWave
    //
    static CDirectSoundWave *GetMatchingDSWave(IDirectSoundWave *pIDSWave);
    
    // General initialization. 
    //
    HRESULT Init(CDirectMusicPortDownload *pPortDL);

    // Write a piece of the wave or the whole wave into the buffer
    // Writes all channels for a single segment
    //
    HRESULT Write(
        LPVOID                  pvBuffer[], 
        SAMPLE_TIME             stStart, 
        SAMPLE_TIME             stLength,
        DWORD                   dwDLId,
        DWORD                   dwDLType) const;
        
    // Refill an already downloaded buffer with new wave data
    //        
    HRESULT RefillBuffers(
        LPVOID                  rpv[], 
        SAMPLE_TIME             stStart, 
        SAMPLE_TIME             stLength,
        SAMPLE_TIME             stBufferLength);
        
    // Convert reference time to samples 
    //
    SAMPLE_TIME RefToSampleTime(REFERENCE_TIME rt) const;                        
    
    // Download and unload all buffers if this is a one-shot
    //
    HRESULT Download();
    HRESULT Unload();
    
    // Override GetNext list operator
    //    
    inline CDirectSoundWave *GetNext() 
    { return (CDirectSoundWave*)AListItem::GetNext(); }
    
    // Determine if this wave is a streaming or one-shot
    //
    inline bool IsStreaming() const
    { return m_fStreaming; }
    
    // Figure out how much buffer to read a piece of the wave
    //
    void GetSize(SAMPLE_TIME stLength, PULONG pcb) const;
    
    // Returns the number of channels
    //
    inline UINT GetNumChannels() const
    { return m_pwfex->nChannels; }

    // Seek to a sample position
    //
    inline HRESULT Seek(SAMPLE_TIME st)
    { return m_pSource->Seek(st * m_nBytesPerSample * GetNumChannels()); }

    // Returns the wrapped IDirectSoundWave
    //
    inline IDirectSoundWave *GetWrappedIDSWave() 
    { m_pIDSWave->AddRef(); return m_pIDSWave; }    
    
    // Returns the wrapped wave format
    //
    inline const LPWAVEFORMATEX GetWaveFormat() const
    { return m_pwfex; }
    
    // Return the length of the stream in samples
    //
    inline SAMPLE_TIME GetStreamSize() const
    { return m_stLength; }
    
    // Get the download ID of the articulation if one-shot
    //
    inline DWORD GetDLId()
    { assert(!m_fStreaming); assert(m_pDSWD); 
      TraceI(1, "CDirectSoundWave::GetDLId() -> %d\n", m_pDSWD->GetDLId());
      return m_pDSWD->GetDLId(); }
      
    inline REFERENCE_TIME GetReadAhead()
    { return m_rtReadAhead; }      
      
    // Convert number of samples to number of bytes for this wave format
    // (assuming PCM). Truncates to a DWORD, so shouldn't be used for
    // huge number of samples.
    //
    inline DWORD SamplesToBytes(SAMPLE_TIME st) const
    { LONGLONG cb = st * m_nBytesPerSample; 
      assert(!(cb & 0xFFFFFFFF00000000));
      return (DWORD)cb; }
      
    inline SAMPLE_TIME BytesToSamples(DWORD cb) const
    { return cb / m_nBytesPerSample; }

    inline SAMPLE_TIME GetPrecacheStart() const
    { assert(IsStreaming()); return m_stStartHint; }

    inline LPBYTE *GetPrecache() const
    { assert(IsStreaming()); return m_rpbPrecache; }

          
    
    static CDirectSoundWaveList sDSWaveList;        // List of all wave objects
    static CRITICAL_SECTION sDSWaveCritSect;        //  and critical section
   
private:
    
    LONG                    m_cRef;                 // COM reference count
    IDirectSoundWave       *m_pIDSWave;             // Wrapped IDirectSoundWave
    bool                    m_fStreaming;           // Is this a streaming wave?
    bool                    m_fUseNoPreRoll;
    REFERENCE_TIME          m_rtReadAhead;          // If so, buffering amount    
    LPWAVEFORMATEX          m_pwfex;                // Native format of wave
    UINT                    m_cbSample;             // Bytes per sample
    SAMPLE_TIME             m_stLength;             // Length of entire wave
    IDirectSoundSource     *m_pSource;              // Source interface
    
    CDirectSoundWaveDownload    
                           *m_pDSWD;                // Wave download wrapper if 
                                                    //  not streaming
    UINT                    m_nBytesPerSample;      // Bytes per sample from wfex
    LPVOID                 *m_rpv;                  // Working space - one pv 
                                                    //  per channel
    LPBYTE                 *m_rpbPrecache;          // Samples starting at start hint
    REFERENCE_TIME          m_rtStartHint;          //  and where it starts
    SAMPLE_TIME             m_stStartHint;          //  in samples as well 
    SAMPLE_TIME             m_stStartLength;        // How many samples in precache?
};

////////////////////////////////////////////////////////////////////////////////
//
// CDirectSoundWaveList
//
// Type-safe wrapper for AList of CDirectSoundWave's
//
class CDirectSoundWaveList : public AList
{
public:
    inline CDirectSoundWave *GetHead()
    { return static_cast<CDirectSoundWave*>(AList::GetHead()); }
    
    inline void AddTail(CDirectSoundWave *pdsw)
    { AList::AddTail(static_cast<AListItem*>(pdsw)); }
    
    inline void Remove(CDirectSoundWave *pdsw)
    { AList::Remove(static_cast<AListItem*>(pdsw)); }
};


#endif // _DSWAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\opnew.cpp ===
// OpNew.cpp
//
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\oledll.h ===
//
// OleDLL.h
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\resource.h ===
// resource.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
#define IDS_SYSTEMCLOCK         1000
#define IDS_DSOUNDCLOCK         1001
#define IDS_EXTCLOCK            1002
#define IDS_EMULATED            1003
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\suwrap.cpp ===
//
// suwrap.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrap needed SetupAPI calls through LoadLibrary so they are only
// called on a platform that supports them.
//
#include <windows.h>
#include "debug.h"
#include <setupapi.h>

#include "debug.h"
#include "suwrap.h"

static const char szSetupAPI[]                  = "setupapi.dll";

static const char szDestroyDeviceInfoList[]     = "SetupDiDestroyDeviceInfoList";
static const char szEnumDeviceInterfaces[]      = "SetupDiEnumDeviceInterfaces";
static const char szGetClassDevs[]              = "SetupDiGetClassDevsA";
static const char szGetDeviceInterfaceDetail[]  = "SetupDiGetDeviceInterfaceDetailA";
static const char szGetDeviceInstanceId[]       = "SetupDiGetDeviceInstanceIdA";

SetupAPI::SetupAPI()
{
    m_fValid = FALSE;
    m_hmodule = LoadLibrary(szSetupAPI);
    if (m_hmodule == (HMODULE)NULL)
    {
        TraceI(0, "SetupAPI: Could not LoadLibrary; error %d", GetLastError());
        goto Cleanup;
    }

    m_pfnGetClassDevs = (PSETUPDIGETCLASSDEVS)GetProcAddress(m_hmodule, szGetClassDevs);
    if (!m_pfnGetClassDevs)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szGetClassDevs);
        goto Cleanup;
    }

    m_pfnEnumDeviceInterfaces = (PENUMDEVICEINTERFACES)GetProcAddress(m_hmodule, szEnumDeviceInterfaces);
    if (!m_pfnEnumDeviceInterfaces)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szEnumDeviceInterfaces);
        goto Cleanup;
    }

    m_pfnDestroyDeviceInfoList = (PDESTROYDEVICEINFOLIST)GetProcAddress(m_hmodule, szDestroyDeviceInfoList);
    if (!m_pfnDestroyDeviceInfoList)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szDestroyDeviceInfoList);
        goto Cleanup;
    }
    
    m_pfnGetDeviceInterfaceDetail = (PSETUPDIGETDEVICEINTERFACEDETAIL)GetProcAddress(m_hmodule, szGetDeviceInterfaceDetail);
    if (!m_pfnGetDeviceInterfaceDetail)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szGetDeviceInterfaceDetail);
        goto Cleanup;
    }

    // SetupDiGetDeviceInstanceId is not available on Win9x, so succeed w/o it
    //
    m_pfnGetDeviceInstanceId = (PSETUPDIGETDEVICEINSTANCEID)GetProcAddress(m_hmodule, szGetDeviceInstanceId);
    if (!m_pfnGetDeviceInstanceId)
    {
        TraceI(0, "SetupAPI: Could not GetProcAddress(%s)", szGetDeviceInstanceId);
    }

    m_fValid = TRUE;

Cleanup:
    if (!m_fValid && m_hmodule != (HMODULE)NULL)
    {
        FreeLibrary(m_hmodule);
        m_hmodule = NULL;                                
    }
}

SetupAPI::~SetupAPI()
{
    if (m_hmodule)
    {
        FreeLibrary(m_hmodule);
    }
}

BOOL SetupAPI::IsValid()
{
    return (BOOL)(m_hmodule != (HMODULE)NULL);
}

BOOL SetupAPI::SetupDiDestroyDeviceInfoList(
    HDEVINFO DeviceInfoSet)
{
    assert(m_fValid);

    return (*m_pfnDestroyDeviceInfoList)(DeviceInfoSet);
}

BOOL SetupAPI::SetupDiEnumDeviceInterfaces(HDEVINFO DeviceInfoSet,
                                           PSP_DEVINFO_DATA DeviceInfoData,
                                           LPGUID InterfaceClassGuid,
                                           DWORD MemberIndex,
                                           PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData)
{
    assert(m_fValid);

    return (*m_pfnEnumDeviceInterfaces)(DeviceInfoSet,
                                        DeviceInfoData,
                                        InterfaceClassGuid,
                                        MemberIndex,
                                        DeviceInterfaceData);
}                                           


HDEVINFO SetupAPI::SetupDiGetClassDevs(
    LPGUID ClassGuid, 
    PCSTR Enumerator, 
    HWND hwndParent, 
    DWORD Flags)
{
    assert(m_fValid);

    return (*m_pfnGetClassDevs)(ClassGuid, Enumerator, hwndParent, Flags);
}

BOOL SetupAPI::SetupDiGetDeviceInterfaceDetail(HDEVINFO DeviceInfoSet,
                                               PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                               PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,
                                               DWORD DeviceInterfaceDetailDataSize,
                                               PDWORD RequiredSize,
                                               PSP_DEVINFO_DATA DeviceInfoData)
{
    assert(m_fValid);

    return (*m_pfnGetDeviceInterfaceDetail)(DeviceInfoSet,
                                            DeviceInterfaceData,
                                            DeviceInterfaceDetailData,
                                            DeviceInterfaceDetailDataSize,
                                            RequiredSize,
                                            DeviceInfoData);
}

BOOL SetupAPI::SetupDiGetDeviceInstanceId(HDEVINFO DeviceInfoSet,
                                          PSP_DEVINFO_DATA DeviceInfoData,
                                          PSTR DeviceInstanceId,
                                          DWORD DeviceInstanceIdSize,
                                          PDWORD RequiredSize)
{
    if (!m_pfnGetDeviceInstanceId)
    {
        SetLastError(ERROR_BAD_COMMAND);
        return FALSE;
    }

    return (*m_pfnGetDeviceInstanceId)(DeviceInfoSet,
                                       DeviceInfoData,
                                       DeviceInstanceId,
                                       DeviceInstanceIdSize,
                                       RequiredSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\suwrap.h ===
//
// suwrap.h
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc INTERNAL
//
//
//
//
//
#ifndef _SUWRAP_
#define _SUWRAP_

#include <setupapi.h>

typedef BOOL (*PDESTROYDEVICEINFOLIST)(
    IN HDEVINFO DeviceInfoSet
    );

typedef BOOL (*PENUMDEVICEINTERFACES)(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
    IN  LPGUID                    InterfaceClassGuid,
    IN  DWORD                     MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );


typedef HDEVINFO (*PSETUPDIGETCLASSDEVS)(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCSTR  Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
);

typedef BOOL (*PSETUPDIGETDEVICEINTERFACEDETAIL)(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    );
    
typedef BOOL (*PSETUPDIGETDEVICEINSTANCEID)(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PSTR             DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    );


class SetupAPI
{
public:
    SetupAPI();
    ~SetupAPI();

    BOOL IsValid();

    BOOL        SetupDiDestroyDeviceInfoList(HDEVINFO DeviceInfoSet);

    BOOL        SetupDiEnumDeviceInterfaces(HDEVINFO DeviceInfoSet,
                                            PSP_DEVINFO_DATA DeviceInfoData,
                                            LPGUID InterfaceClassGuid,
                                            DWORD MemberIndex,
                                            PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData);
    
    HDEVINFO    SetupDiGetClassDevs(LPGUID ClassGuid, PCSTR Enumerator, HWND hwndParent, DWORD Flags);

    BOOL        SetupDiGetDeviceInterfaceDetail(HDEVINFO DeviceInfoSet,
                                                PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
                                                PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,
                                                DWORD DeviceInterfaceDetailDataSize,
                                                PDWORD RequiredSize,
                                                PSP_DEVINFO_DATA DeviceInfoData);
    BOOL        SetupDiGetDeviceInstanceId(HDEVINFO DeviceInfoSet,
                                           PSP_DEVINFO_DATA DeviceInfoData,
                                           PSTR DeviceInstanceId,
                                           DWORD DeviceInstanceIdSize,
                                           PDWORD RequiredSize);
                                                

private:
    HMODULE                     m_hmodule;
    BOOL                        m_fValid;

    PDESTROYDEVICEINFOLIST              m_pfnDestroyDeviceInfoList;
    PENUMDEVICEINTERFACES               m_pfnEnumDeviceInterfaces;
    PSETUPDIGETCLASSDEVS                m_pfnGetClassDevs;
    PSETUPDIGETDEVICEINTERFACEDETAIL    m_pfnGetDeviceInterfaceDetail;
    PSETUPDIGETDEVICEINSTANCEID         m_pfnGetDeviceInstanceId;
};

#endif // _SUWRAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\oledll.cpp ===
// oledll.cpp
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		= TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\sysaudio.cpp ===
//
// SysAudio.CPP
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Interfaces to the WDM System Audio Device
//
#include <objbase.h>
#include <devioctl.h>
#include <setupapi.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <regstr.h>

#ifndef DRVM_MAPPER_PREFERRED_GET
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#endif

#include "dmusicp.h"
#include "debug.h"

#include "suwrap.h"

static int  GetPreferredAudioPlaybackDeviceId();
static BOOL WaveOutIdToInstanceId(int iDeviceId, char **ppInstanceId);

#ifdef DBG
extern void _TraceIGuid(int iLevel, GUID *pGUID);
#define TraceIGuid _TraceIGuid
#else
#define TraceIGuid(x,y)
#endif


typedef struct tag_KSPROPERTYDEVICEINDEX
{
    KSPROPERTY Property;
    ULONG      DeviceIndex;
}   KSPROPERTYDEVICEINDEX, 
    *PKSPROPERTYDEVICEINDEX;


// OpenDefaultDevice
//
// Use the SetupDi API's to retrieve the path of the SysAudio filter and open
// a handle to it.
//
// Handle should be closed with CloseHandle when done using it.
//
// Returns TRUE on success
//
BOOL OpenDefaultDevice(
    IN REFGUID           rguidCategory,
    OUT HANDLE          *pHandle)
{
    BOOL fResult = FALSE;
    SetupAPI suwrap;

    if (!suwrap.IsValid()) 
    {
        return FALSE;
    }

    *pHandle = (HANDLE)NULL;

    // Get the device class for KSCATEGORY_SYSAUDIO
    //
	GUID *pClassGuid = const_cast<GUID*>(&rguidCategory);  //KSCATEGORY_SYSAUDIO);
	HDEVINFO hDevInfo = suwrap.SetupDiGetClassDevs(pClassGuid,
											NULL,
											NULL,
											DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
	if (hDevInfo == NULL || hDevInfo == INVALID_HANDLE_VALUE)
	{
		TraceI(0, "Could not open SetupDiGetClassDevs\n");
        return FALSE;
	}

    // Get device details. There should only be one SysAudio.
    //
	SP_DEVICE_INTERFACE_DATA DevInterfaceData;
	DevInterfaceData.cbSize = sizeof(DevInterfaceData);

	BYTE rgbStorage[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + _MAX_PATH];
	SP_DEVICE_INTERFACE_DETAIL_DATA * pDevInterfaceDetails = (SP_DEVICE_INTERFACE_DETAIL_DATA *)rgbStorage;
	pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

	if (suwrap.SetupDiEnumDeviceInterfaces(hDevInfo, NULL, pClassGuid, 0, &DevInterfaceData))
    {
		if (suwrap.SetupDiGetDeviceInterfaceDetail(hDevInfo, 
		                                    &DevInterfaceData, 
		                                    pDevInterfaceDetails,
 										    sizeof(rgbStorage), 
 										    NULL, 
 										    NULL))
        {
            // Have to convert this since there's no CreateFileW on Win9x.
            //
            HANDLE hFilter = CreateFile(pDevInterfaceDetails->DevicePath,
                                        GENERIC_READ | GENERIC_WRITE, 
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                        NULL);
            if (hFilter != NULL && hFilter != INVALID_HANDLE_VALUE)
            {
                *pHandle = hFilter;
                fResult = TRUE;
            }
            else
            {
                TraceI(0, "Open of SysAudio filter failed.\n");
            }
        }
        else
        {
            TraceI(0, "SetUpDiGetDeviceInterfaceDetail failed\n");
        }
    }
    else
    {
        TraceI(0, "SetUpDiEnumDeviceInterfaces failed\n");
    }

    suwrap.SetupDiDestroyDeviceInfoList(hDevInfo);

    return fResult;
}

// IsEqualInterface
//
// Check the equality of two KS pin interfaces
//
BOOL IsEqualInterface(
    const KSPIN_INTERFACE *pInterface1,
    const KSPIN_INTERFACE *pInterface2)
{
    return ( IsEqualGUID(pInterface1->Set, pInterface2->Set) &&
             (pInterface1->Id    == pInterface2->Id)           &&
             (pInterface1->Flags == pInterface2->Flags) );
}

// CreatePin
//
// Given a handle to SysAudio with the default device set, create a handle to the given pin.
//
HRESULT CreatePin(
    IN      HANDLE          handleFilter,
    IN      ULONG           ulPinId,
    OUT     HANDLE          *pHandle)
{
    static char szKsCreatePin[] = "KsCreatePin";

    DWORD (WINAPI *pKsCreatePin)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, PHANDLE);
    PKSPIN_CONNECT  pKsPinConnect;
    PKSDATAFORMAT   pKsDataFormat;

    *pHandle = NULL;

    if (!LoadKsUser())
    {
        TraceI(0, "CDirectMusicPort::Init() -> No KSUSER.DLL handle");
        return E_NOINTERFACE;
    }

    pKsCreatePin = (DWORD (WINAPI *)(HANDLE, PKSPIN_CONNECT, ACCESS_MASK, PHANDLE))
                   GetProcAddress(g_hModuleKsUser, szKsCreatePin);
    if (!pKsCreatePin)
    {
        TraceI(0, "CDirectMusicPort::Init() -> No entry point");
        return E_NOINTERFACE;
    }

    pKsPinConnect = (PKSPIN_CONNECT)LocalAlloc(LPTR, sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT));

    if (!pKsPinConnect)
    {
        TraceI(0, "LocalAlloc failed in CreatePin\n");
        return E_OUTOFMEMORY;
    }

    pKsPinConnect->Interface.Set              = KSINTERFACESETID_Standard;
    pKsPinConnect->Interface.Id               = KSINTERFACE_STANDARD_STREAMING;
    pKsPinConnect->Interface.Flags            = 0;
    pKsPinConnect->Medium.Set                 = KSMEDIUMSETID_Standard;
    pKsPinConnect->Medium.Id                  = KSMEDIUM_TYPE_ANYINSTANCE;
    pKsPinConnect->Medium.Flags               = 0;
    pKsPinConnect->PinId                      = ulPinId;
    pKsPinConnect->PinToHandle                = NULL;
    pKsPinConnect->Priority.PriorityClass     = KSPRIORITY_NORMAL;
    pKsPinConnect->Priority.PrioritySubClass  = 1;

    pKsDataFormat = PKSDATAFORMAT(pKsPinConnect + 1);
    pKsDataFormat->FormatSize     = sizeof(KSDATAFORMAT);
    pKsDataFormat->Reserved       = 0;
    pKsDataFormat->MajorFormat    = KSDATAFORMAT_TYPE_MUSIC;
    pKsDataFormat->SubFormat      = KSDATAFORMAT_SUBTYPE_DIRECTMUSIC;
    pKsDataFormat->Specifier      = KSDATAFORMAT_SPECIFIER_NONE;

    
    DWORD dwRes = (*pKsCreatePin)(handleFilter,
                                  pKsPinConnect,
                                  GENERIC_WRITE | GENERIC_READ,
                                  pHandle);
    if (dwRes != ERROR_SUCCESS)
    {
        LocalFree(pKsPinConnect);
        return WIN32ERRORtoHRESULT(dwRes);
    }

    LocalFree(pKsPinConnect);
    return S_OK;
}

// GetSizedProperty
//
// Retrieve a property of which the size is unknown. 
//
BOOL GetSizedProperty(
    IN      HANDLE      handle,
    IN      ULONG       ulPropSize,
    IN      PKSPROPERTY pKsProperty,
    OUT     PVOID *     ppvBuffer,
    OUT     PULONG      pulBytesReturned)
{
    *ppvBuffer = NULL;

    // determine size of data we are attempting to retrieve
    //
    ULONG ulSize;

    BOOL fResult = SyncIoctl(
            handle,
            IOCTL_KS_PROPERTY,
            pKsProperty,
            ulPropSize,
            NULL,
            0,
            &ulSize);

    if (fResult)
    {
        *ppvBuffer = LocalAlloc(LPTR, ulSize);

        if (!*ppvBuffer)
        {
            //If we are going to fail, at least say we are returning
            //zero bytes.
            *pulBytesReturned = 0;
            return FALSE;
        }

        fResult = Property(handle,
                           ulPropSize,
                           pKsProperty,
                           ulSize,
                           *ppvBuffer,
                           pulBytesReturned);

        if (fResult && (*pulBytesReturned != ulSize))
        {
            TraceI(0, "GetSizedProperty: Property returned %lu bytes, asked for %lu\n", 
                *pulBytesReturned, ulSize);
            LocalFree(*ppvBuffer);
            *ppvBuffer = NULL;

            fResult = FALSE;
        }
    }
    else
    {
        TraceI(0, "GetSizedProperty: Size query failed\n");
    }

    return fResult;
}

// Property
// 
//
BOOL Property(
    IN      HANDLE      handle,
    IN      ULONG       ulPropSize,
    IN      PKSPROPERTY pKsProperty,
    IN      ULONG       ulBufferSize,
    IN OUT  PVOID       pvBuffer,
    OUT     PULONG      pulBytesReturned)
{
    ULONG   ulReturned = 0;
    PULONG  pulReturned = pulBytesReturned ? pulBytesReturned : &ulReturned;


    BOOL fResult = SyncIoctl(
            handle,
            IOCTL_KS_PROPERTY,
            pKsProperty,
            ulPropSize,
            pvBuffer,
            ulBufferSize,
            pulReturned);

#ifdef DBG
    if (!fResult)
    {
        TraceI(0, "DeviceIoControl: %08X\n", GetLastError());

        TraceI(0, "KS Item: ");
        TraceIGuid(0, &pKsProperty->Set);
        TraceI(0, "\t#%d\n", pKsProperty->Id);
        TraceI(0, "\tFlags: %08X\n", pKsProperty->Flags);
    }
#endif // DBG

    return fResult;
}

// SyncIoctl
//
//
BOOL SyncIoctl(
    IN      HANDLE  handle,
    IN      ULONG   ulIoctl,
    IN      PVOID   pvInBuffer  OPTIONAL,
    IN      ULONG   ulInSize,
    OUT     PVOID   pvOutBuffer OPTIONAL,
    IN      ULONG   ulOutSize,
    OUT     PULONG  pulBytesReturned)
{
    OVERLAPPED overlapped;
    memset(&overlapped,0,sizeof(overlapped));
    overlapped.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!overlapped.hEvent)
    {
        return FALSE;
    }

    BOOL fResult = DeviceIoControl(handle, 
                                   ulIoctl, 
                                   pvInBuffer, 
                                   ulInSize, 
                                   pvOutBuffer, 
                                   ulOutSize, 
                                   pulBytesReturned, 
                                   &overlapped);

    if ((!fResult) && (ERROR_IO_PENDING == GetLastError())) 
    {
        fResult = GetOverlappedResult(handle, &overlapped, pulBytesReturned, TRUE);
    }
    if (!fResult)
    {
        if  (   (ulIoctl == IOCTL_KS_PROPERTY) 
            &&  (ulOutSize == 0)
            &&  (GetLastError() == ERROR_MORE_DATA)
            )
        {
            fResult = TRUE;
        }
        else
        {
            *pulBytesReturned = 0;
        }
    }

    CloseHandle(overlapped.hEvent);

    return fResult;
}

// GetSysAudioDeviceCount
//
BOOL GetSysAudioDeviceCount(
    HANDLE              hSysAudio,
    PULONG              pulDeviceCount)
{
    ULONG               ulBytesReturned;
    KSP_PIN             ksp;
    BOOL                fStatus;

    ksp.Property.Set   = KSPROPSETID_Sysaudio;
    ksp.Property.Id    = KSPROPERTY_SYSAUDIO_DEVICE_COUNT;
    ksp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksp.PinId          = 0;
    ksp.Reserved       = 0;

    fStatus = Property(hSysAudio,
                       sizeof(ksp),
                       (PKSIDENTIFIER)&ksp,
                       sizeof(ULONG),
                       pulDeviceCount,
                       &ulBytesReturned);
    if ((!fStatus) || (ulBytesReturned < sizeof(ULONG)))
    {
        return FALSE;
    }

    return TRUE;
}


// SetDefaultDevice
//
// Set the default SysAudio device to the given index
//
BOOL SetSysAudioDevice(
    HANDLE              hSysAudio,
    ULONG               idxDevice)
{
    SYSAUDIO_INSTANCE_INFO  saInstInfo;
    ZeroMemory(&saInstInfo, sizeof(saInstInfo));

    saInstInfo.Property.Set     = KSPROPSETID_Sysaudio;
    saInstInfo.Property.Id      = KSPROPERTY_SYSAUDIO_INSTANCE_INFO;
    saInstInfo.Property.Flags   = KSPROPERTY_TYPE_SET;
    saInstInfo.Flags            = SYSAUDIO_FLAGS_DONT_COMBINE_PINS;
    saInstInfo.DeviceNumber     = idxDevice;

    return Property(hSysAudio,
                    sizeof(saInstInfo),
                    (PKSIDENTIFIER)&saInstInfo,
                    0,
                    NULL,
                    NULL);
}

// CreateVirtualSource
//
// Create a SysAudio virtual source for controlling volume on this device.
// 
BOOL CreateVirtualSource(
    HANDLE              hSysAudio, 
    PULONG              pulSourceIndex)
{
    SYSAUDIO_CREATE_VIRTUAL_SOURCE  CreateVirtualSource;

    CreateVirtualSource.Property.Set = KSPROPSETID_Sysaudio;
    CreateVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
    CreateVirtualSource.Property.Flags = KSPROPERTY_TYPE_GET;
    
    CreateVirtualSource.PinCategory = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;
    CreateVirtualSource.PinName = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;

    ULONG BytesReturned;

    BOOL fRet = Property(hSysAudio,
                         sizeof(CreateVirtualSource),
                         (PKSIDENTIFIER)&CreateVirtualSource,
                         sizeof(ULONG),
                         pulSourceIndex,
                         &BytesReturned);
    if (!fRet || BytesReturned != sizeof(ULONG)) 
    {
        return FALSE;
    }

    return TRUE;
}

// AttachVirtualSource
//
// Attach the given virtual source to the pin
//
BOOL AttachVirtualSource(
    HANDLE              hPin,
    ULONG               ulSourceIndex)
{
    SYSAUDIO_ATTACH_VIRTUAL_SOURCE  AttachVirtualSource;

    AttachVirtualSource.Property.Set = KSPROPSETID_Sysaudio_Pin;
    AttachVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE;
    AttachVirtualSource.Property.Flags = KSPROPERTY_TYPE_SET;

    AttachVirtualSource.MixerPinId = ulSourceIndex;
    AttachVirtualSource.Reserved = 0;

    return Property(hPin,
                    sizeof(AttachVirtualSource),
                    (PKSIDENTIFIER)&AttachVirtualSource,
                    sizeof(ulSourceIndex),
                    &ulSourceIndex,
                    NULL);
}

// FindGuidNode
//
// Give a handle to SysAudio, find the first node ID within the current device's topology having
// the given GUID.
//
// Returns the node ID or -1 if there is no synthesizer node.
//
int FindGuidNode(
    HANDLE              hSysAudio, 
    ULONG               ulPinId,
    REFGUID             rguid)
{
    KSPROPERTY ksProp;
    LPVOID pvProp;
    ULONG  ulProp;

    // Get node list
    //
    ZeroMemory(&ksProp, sizeof(ksProp));
    ksProp.Set  = KSPROPSETID_Topology;
    ksProp.Id   = KSPROPERTY_TOPOLOGY_NODES;
    ksProp.Flags= KSPROPERTY_TYPE_GET;

    if (!GetSizedProperty(hSysAudio, 
                          sizeof(ksProp),
                          &ksProp,
                          &pvProp,
                          &ulProp))
    {
        TraceI(0, "FindGuidNode: Could not get node topology list\n");
        return -1;
    }                                              

    if (ulProp < sizeof(KSMULTIPLE_ITEM))
    {
        TraceI(0, "FindGuidNode: Node list size smaller than header size!\n");
        LocalFree(pvProp);
        return -1;
    }

    PKSMULTIPLE_ITEM pksmiNodes = (PKSMULTIPLE_ITEM)pvProp;

    // Get connection list
    //
    ZeroMemory(&ksProp, sizeof(ksProp));
    ksProp.Set  = KSPROPSETID_Topology;
    ksProp.Id   = KSPROPERTY_TOPOLOGY_CONNECTIONS;
    ksProp.Flags= KSPROPERTY_TYPE_GET;

    if (!GetSizedProperty(hSysAudio, 
                          sizeof(ksProp),
                          &ksProp,
                          &pvProp,
                          &ulProp))
    {
        TraceI(0, "FindGuidNode: Could not get connection topology list\n");
        LocalFree(pksmiNodes);
        return -1;
    }                                              

    if (ulProp < sizeof(KSMULTIPLE_ITEM))
    {
        TraceI(0, "FindGuidNode: Connection list size smaller than header size!\n");
        LocalFree(pksmiNodes);
        LocalFree(pvProp);
        return -1;
    }

    PKSMULTIPLE_ITEM pksmiConnections = (PKSMULTIPLE_ITEM)pvProp;
    PKSTOPOLOGY_CONNECTION pConnection = PKSTOPOLOGY_CONNECTION(pksmiConnections + 1);
    ULONG idxNodeRet = -1;
    
    // Search connection list for pin ID & guid
    //
    for (ULONG idxConnection = 0; idxConnection < pksmiConnections->Count; ++idxConnection)
    {
        if (pConnection->FromNode == -1 && // filter node
            pConnection->FromNodePin == ulPinId) 
        {
            // REVIEW: walk the topology paths which start from this connection
            
            idxNodeRet = pConnection->ToNode;
        }
        else if (pConnection->ToNode == -1 &&
                 pConnection->ToNodePin == ulPinId)
        {
            idxNodeRet = pConnection->FromNode;
        }
        else 
        {
            idxNodeRet = -1;
        }                    

        if (idxNodeRet != -1)
        {
            ULONG idxNode;
            LPGUID guidNode = LPGUID(pksmiNodes + 1);

            // See if node for connection has the desired guid
            //
            for (idxNode = 0; idxNode < pksmiNodes->Count; ++idxNode)
            {
                if (idxNode == idxNodeRet)
                {
                    break;
                }

                guidNode = LPGUID(PBYTE(guidNode) + ((sizeof(GUID) + 7) & ~7));
            }

            if (idxNode == pksmiNodes->Count ||
                *guidNode != rguid)
            {
                idxNodeRet = -1;
            }
            else
            {
                break;
            }
        }

        pConnection = PKSTOPOLOGY_CONNECTION(PBYTE(pConnection) + ((sizeof(KSTOPOLOGY_CONNECTION) + 7) & ~7));
    }

    LocalFree(pksmiNodes);
    LocalFree(pksmiConnections);
    return idxNodeRet;
}

// GetFilterCaps
//
// Attempts to retrieve the filter caps for this synth filter.
//
BOOL GetFilterCaps(
    HANDLE              hSysAudio,
    ULONG               idxNode,
    PSYNTHCAPS          pcaps)
{
    KSP_NODE ksNodeProp;
    
    ZeroMemory(&ksNodeProp, sizeof(ksNodeProp));
    ksNodeProp.Property.Set     = KSPROPSETID_Synth;
    ksNodeProp.Property.Id      = KSPROPERTY_SYNTH_CAPS;
    ksNodeProp.Property.Flags   = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    ksNodeProp.NodeId           = idxNode;

    if (!Property(hSysAudio,
                  sizeof(ksNodeProp),
                  (PKSPROPERTY)&ksNodeProp,
                  sizeof(SYNTHCAPS),
                  pcaps,
                  NULL))
    {
        TraceI(0, "Could not get caps\n");
        return FALSE;
    }

    return TRUE;    
}

// GetNumPinTypes
//
// Retrieve the number of supported pin types on the current SysAudio device.
// 
BOOL GetNumPinTypes(
    HANDLE              hSysAudio,
    PULONG              pulPinTypes)
{
    ULONG   BytesReturned;
    KSP_PIN ksp;
    BOOL    Status;
    
    ksp.Property.Set   = KSPROPSETID_Pin;
    ksp.Property.Id    = KSPROPERTY_PIN_CTYPES;
    ksp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksp.PinId          = 0;
    ksp.Reserved       = 0;

    Status = Property(hSysAudio,
                      sizeof(ksp),
                      (PKSIDENTIFIER)&ksp,
                      sizeof(ULONG),
                      pulPinTypes,
                      &BytesReturned);
    
    if ((!Status) || (BytesReturned < sizeof(ULONG)))
    {
        TraceI(0, "GetNumPinTypes failed\n");
        return FALSE;
    }
    
    return TRUE;
}


// PinSupportsInterface
//
// Given a pin, return TRUE if the given interface is supported. Assumes the
// default device on SysAudio.
//
BOOL PinSupportsInterface(
    HANDLE              hSysAudio,
    ULONG               ulPinId, 
    REFGUID             rguidInterface, 
    ULONG               ulId)
{
    KSP_PIN             ksp;
    PKSMULTIPLE_ITEM    pksmi; 
    ULONG               ulBytesReturned;

    ksp.Property.Set    = KSPROPSETID_Pin;
    ksp.Property.Id     = KSPROPERTY_PIN_INTERFACES;
    ksp.Property.Flags  = KSPROPERTY_TYPE_GET;
    ksp.PinId           = ulPinId;
    ksp.Reserved        = 0;

    if ( (!GetSizedProperty(hSysAudio,
                           sizeof(ksp),
                           (PKSIDENTIFIER)&ksp,
                           (void**)&pksmi,
                           &ulBytesReturned)) ||
        (ulBytesReturned < sizeof(KSMULTIPLE_ITEM)))
    {
        TraceI(0, "PinSupportsInterface: GetSizedProperty failed!\n");
        return FALSE;
    }

    KSPIN_INTERFACE ksInterface;
    
    ksInterface.Set      = rguidInterface;
    ksInterface.Id       = ulId;
    ksInterface.Flags    = 0;

    PCHAR pchProperty = (PCHAR)(pksmi + 1);

    for (ULONG idxInterface = 0; idxInterface < pksmi->Count; ++idxInterface)
    {
        PKSIDENTIFIER pksi = (PKSIDENTIFIER)pchProperty;
        if (IsEqualInterface(pksi, &ksInterface))
        {
            LocalFree(pksmi);
            return TRUE;
        }

        pchProperty += ((sizeof(KSIDENTIFIER) + 7) & ~7);
    }

    LocalFree(pksmi);
    return FALSE;
}

// PinSupportsDataRange
//
BOOL PinSupportsDataRange(
    HANDLE              hSysAudio, 
    ULONG               ulPinId, 
    REFGUID             rguidFormat, 
    REFGUID             rguidSubformat)
{
    KSP_PIN             ksp;
    PKSMULTIPLE_ITEM    pksmi;
    ULONG               ulBytesReturned;

    ksp.Property.Set    = KSPROPSETID_Pin;
    ksp.Property.Id     = KSPROPERTY_PIN_DATARANGES;
    ksp.Property.Flags  = KSPROPERTY_TYPE_GET;
    ksp.PinId           = ulPinId;
    ksp.Reserved        = 0;

    if ((!GetSizedProperty(hSysAudio,
                           sizeof(ksp),
                           (PKSIDENTIFIER)&ksp,
                           (void**)&pksmi,
                           &ulBytesReturned)) ||
        (ulBytesReturned < sizeof(KSMULTIPLE_ITEM)))
    {
        TraceI(0, "PinSupportsInterface: GetSizedProperty failed!\n");
        return FALSE;
    }

    PCHAR pchPropData = (PCHAR)(pksmi + 1);

    for (ULONG idxDataRange = 0; idxDataRange < pksmi->Count; ++idxDataRange)
    {
        PKSDATARANGE pksdr = (PKSDATARANGE)(pchPropData);

        if (IsEqualGUID(pksdr->MajorFormat, rguidFormat) &&
            IsEqualGUID(pksdr->SubFormat,   rguidSubformat))
        {
            LocalFree(pksmi);
            return TRUE;
        }

        pchPropData += pksdr->Alignment;
    }

    LocalFree(pksmi);
    return FALSE;
}

// PinGetDataFlow
// 
BOOL PinGetDataFlow(
    HANDLE              hSysAudio, 
    ULONG               ulPinId, 
    PKSPIN_DATAFLOW     pkspdf)
{
    KSP_PIN             ksp;
    BOOL                Status;
    ULONG               ulBytesReturned;

    ksp.Property.Set   = KSPROPSETID_Pin;
    ksp.Property.Id    = KSPROPERTY_PIN_DATAFLOW;
    ksp.Property.Flags = KSPROPERTY_TYPE_GET;
    ksp.PinId          = ulPinId;
    ksp.Reserved       = 0;

    Status = Property(hSysAudio,
                      sizeof(ksp),
                      (PKSIDENTIFIER)&ksp,
                      sizeof(KSPIN_DATAFLOW),
                      pkspdf,
                      &ulBytesReturned);

    if ((!Status) || (ulBytesReturned < sizeof(KSPIN_DATAFLOW)))
    {
        TraceI(0, "PinGetDataFlow: Property failed!\n");
        return FALSE;
    }

    return TRUE;
}

// GetDeviceFriendlyName
//
// Assumes the default device is already set.
//
BOOL GetDeviceFriendlyName(
    HANDLE              hSysAudio, 
    ULONG               ulDeviceIndex,
    PWCHAR              pwch, 
    ULONG               cbwch)
{
    KSPROPERTYDEVICEINDEX   kspdi;

    if (cbwch < sizeof(WCHAR))
    {
        return FALSE;
    }

    kspdi.Property.Set   = KSPROPSETID_Sysaudio;
    kspdi.Property.Id    = KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME;
    kspdi.Property.Flags = KSPROPERTY_TYPE_GET;
    kspdi.DeviceIndex    = ulDeviceIndex;

    if (!Property(hSysAudio,
                  sizeof(kspdi),
                  (PKSIDENTIFIER)&kspdi,
                  cbwch,
                  pwch,
                  NULL))
    {
        return FALSE;
    }

    pwch[(cbwch / sizeof(WCHAR)) - 1] = ((WCHAR)0);

    return TRUE;
}

// GetDeviceFriendlyName
//
// Assumes the default device is already set.
//
BOOL GetDeviceInterfaceName(
    HANDLE              hSysAudio, 
    ULONG               ulDeviceIndex,
    PWCHAR              pwch, 
    ULONG               cbwch)
{
    KSPROPERTYDEVICEINDEX   kspdi;

    if (cbwch < sizeof(WCHAR))
    {
        return FALSE;
    }

    kspdi.Property.Set   = KSPROPSETID_Sysaudio;
    kspdi.Property.Id    = KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME;
    kspdi.Property.Flags = KSPROPERTY_TYPE_GET;
    kspdi.DeviceIndex    = ulDeviceIndex;

    if (!Property(hSysAudio,
                  sizeof(kspdi),
                  (PKSIDENTIFIER)&kspdi,
                  cbwch,
                  pwch,
                  NULL))
    {
        return FALSE;
    }

    pwch[(cbwch / sizeof(WCHAR)) - 1] = ((WCHAR)0);

    return TRUE;
}

// GetPreferredAudioPlaybackDevice
//
//
BOOL InstanceIdOfPreferredAudioDevice(char **ppInstanceId)
{
    // Determine the device ID of the preferred audio device
    //
    int iDeviceId = GetPreferredAudioPlaybackDeviceId();
    if (iDeviceId == -1)
    {
        TraceI(0, "Could not determine preferred device ID\n");
        return FALSE;
    }
    
    return WaveOutIdToInstanceId(iDeviceId, ppInstanceId);
}

#ifdef WINNT

// GetPreferredAudioPlaybackDeviceId
//
// Returns the WinMM device ID of the preferred audio playback device, or -1
// if the device could not be found.
//
static int GetPreferredAudioPlaybackDeviceId()
{
    MMRESULT    mmr;
    UINT        uPreferredId;
    DWORD       dwFlags;

    // Use the new improved NT WinMM service for determining the preferred 
    // audio device 
    //
    mmr = waveOutMessage((HWAVEOUT)-1,        // Mapper
                         DRVM_MAPPER_PREFERRED_GET,
                         (DWORD_PTR)&uPreferredId,
                         (DWORD_PTR)&dwFlags);
    if (mmr != MMSYSERR_NOERROR)
    {
        TraceI(0, "GetPreferredAudioPlaybackDeviceId: Mapper returned %d\n", mmr);
        return -1;
    }

    // May still be -1 if there is no preferred device
    //
    return (int)uPreferredId;
}

#else /* Win9x */

// GetPreferredAudioPlaybackDeviceId
//
// Returns the WinMM device ID of the preferred audio playback device, or -1
// if the device could not be found.
//
// Works on both Win9x.
//
#define REGSTR_PREFERRED_AUDIO  "Software\\Microsoft\\Multimedia\\Sound Mapper"
#define PLAYBACK                "Playback"

static int GetPreferredAudioDeviceReg();
static int GetFirstMappableDevice();

// GetPreferredAudioPlaybackDeviceId
//
// Determine the preferred audio playback device as a wave out device ID.
// If the registry has been set, use that setting;
// otherwise, use the first mappable device
//
static int GetPreferredAudioPlaybackDeviceId()
{
    int id = GetPreferredAudioDeviceReg();

    if (id != -1) 
    {
        return id;
    }

    // If the registry method failed, it could be because the control panel
    // has not been run yet and there is nothing written in the registry.
    // In this case the mapper picks the first mappable device.
    //
    // This will return -1 if there are no mappable devices.
    //
    return GetFirstMappableDevice();
}

// GetPreferredAudioDeviceReg
//
// Find the preferred wave out device in the registry if it has been written
// there.
//
static int GetPreferredAudioDeviceReg()
{
    HKEY hk;

    // Save how many wave devices are loaded. If none, no need to continue.
    //
    int nWaveOutDevs = waveOutGetNumDevs();
    if (nWaveOutDevs == 0) 
    {
        return -1;
    }

    // Get the preferred audio playback device from the registry. This is the 
    // name of the audio device.
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     REGSTR_PREFERRED_AUDIO,
                     0,                         // Reserved
                     KEY_READ,
                     &hk) != ERROR_SUCCESS)
    {
        return -1;
    }        

    CHAR szPName[MAXPNAMELEN];
    DWORD cb;
    LONG lResult;

    cb = sizeof(szPName);
    lResult = RegQueryValueEx(hk,
                              PLAYBACK,
                              NULL,                   // Reserved
                              NULL,                   // Type
                              (LPBYTE)szPName,
                              &cb) != ERROR_SUCCESS;
    RegCloseKey(hk);

    if (lResult != ERROR_SUCCESS)
    {
        return -1;
    }

    // Loop through all the loaded wave devices and look for one with the same name
    // as the preferred device name.
    //
    int iWaveOutDev;
    WAVEOUTCAPS woc;

    for (iWaveOutDev = 0; iWaveOutDev < nWaveOutDevs; iWaveOutDev++)
    {
        MMRESULT mmr = waveOutGetDevCaps(iWaveOutDev, &woc, sizeof(woc));
        if (mmr != MMSYSERR_NOERROR) 
        {
            continue;
        }            

        if (!strcmp(szPName, woc.szPname))
        {
            break;
        }
    }

    if (iWaveOutDev >= nWaveOutDevs)
    {
        return -1;
    }

    return iWaveOutDev;
}

// GetFirstMappableDevice
//
// Find the first mappable wave out device, which is what wave mapper is supposed
// to do in the absence of registry settings.
//
static int GetFirstMappableDevice()
{
    int nWaveOutDevs = waveOutGetNumDevs();

    if (nWaveOutDevs == 0) 
    {
        return -1;
    }

    for (int iDeviceId = 0; iDeviceId < nWaveOutDevs; iDeviceId++)
    {
        MMRESULT mmr = waveOutMessage((HWAVEOUT)iDeviceId,
                                      DRV_QUERYMAPPABLE,
                                      0, 0);
        if (mmr == MMSYSERR_NOERROR)
        {
            // This device ID is mappable
            //
            return iDeviceId;
        }                                          
    }
    
    return -1;
}

#endif /* Win9x */

#ifdef WINNT
static BOOL GetDINameFromWaveOutId(int iDeviceId, char **ppDIName);

static BOOL WaveOutIdToInstanceId(int iDeviceId, char **ppInstanceId)
{
    char *pstrDIName;

    if (!GetDINameFromWaveOutId(iDeviceId, &pstrDIName))
    {
        return FALSE;
    }

    BOOL bRet = DINameToInstanceId(pstrDIName, ppInstanceId);

    delete[] pstrDIName;
    return bRet;
}

// GetDINameFromWaveOutId
//
// Given a WaveOut device ID, determine the matching device interface
// name.
//
static BOOL GetDINameFromWaveOutId(int iDeviceId, char **ppDIName)
{
    ULONG cb;
    
    // Ask how many bytes (NOT WCHAR's the name is)
    //
    MMRESULT mmr = waveOutMessage((HWAVEOUT)(UINT64)iDeviceId,
                                  DRV_QUERYDEVICEINTERFACESIZE,
                                  (DWORD_PTR)(PULONG)&cb,
                                  0);
    if (mmr != MMSYSERR_NOERROR)
    {
        return FALSE;
    }

    // Allocate and ask for the name
    //
    ULONG  cwch = (cb + sizeof(WCHAR) - 1) / sizeof(WCHAR);
    PWCHAR pwstrDeviceInterfaceName = new WCHAR[cwch];
    if (pwstrDeviceInterfaceName == NULL)
    {
        return FALSE;
    }

    mmr = waveOutMessage((HWAVEOUT)(UINT64)iDeviceId,
                         DRV_QUERYDEVICEINTERFACE,
                         (DWORD_PTR)pwstrDeviceInterfaceName,
                         cb);
    if (mmr != MMSYSERR_NOERROR)
    {
        delete[] pwstrDeviceInterfaceName;
        return FALSE;
    }

    // We want to name as a multibyte string
    //    
    LPSTR pstrDeviceInterfaceName = new CHAR[cwch];
    if (pstrDeviceInterfaceName == NULL)
    {
        delete[] pwstrDeviceInterfaceName;
        return FALSE;
    }

    wcstombs(pstrDeviceInterfaceName, pwstrDeviceInterfaceName, cwch);

    // Clean up and return it
    //
    *ppDIName = pstrDeviceInterfaceName;
    delete[] pwstrDeviceInterfaceName;

    return TRUE;
}

#else /* Win9x */
static BOOL WaveOutIdToInstanceId(int iDeviceId, char **ppInstanceId)
{
    BOOL bRet = FALSE;

    MMRESULT mmr;
    char szDrvEntry[256];
    char szKey[512];
    HKEY hk;
    DWORD cb;

    *ppInstanceId = NULL;

    mmr = waveOutMessage((HWAVEOUT)iDeviceId,
                         DRV_QUERYDRVENTRY,
                         (DWORD)(LPSTR)szDrvEntry,
                         sizeof(szDrvEntry));
    if (mmr) 
    {
        TraceI(1, "DRV_QUERYDRVENTRY: %d\n", mmr);
        return FALSE;
    }

    wsprintf(szKey, "%s\\%s",
             REGSTR_PATH_MEDIARESOURCES TEXT("\\Wave"),
             szDrvEntry);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szKey,
                     0,
                     KEY_READ,
                     &hk) != ERROR_SUCCESS)
    {
        TraceI(1, "WaveOutIdToInstanceId: RegOpenKeyEx failed\n");
        TraceI(2, "[%s]\n", szKey);
        return FALSE;
    }

    cb = sizeof(szDrvEntry);
    if (RegQueryValueEx(hk,
                        "DeviceID",
                        NULL,
                        NULL,
                        (LPBYTE)szDrvEntry,
                        &cb) == ERROR_SUCCESS)
    {
        *ppInstanceId = new char[strlen(szDrvEntry) + 1];
        if (*ppInstanceId) 
        {
            strcpy(*ppInstanceId, szDrvEntry);
            bRet = TRUE;
        }
    }
    else
    {
        TraceI(1, "WaveOutIdToInstanceId: No DeviceID key, not WDM device\n");
    }

    RegCloseKey(hk);

    return bRet;
}
#endif /* Win9x */


// DINameToInstanceId
//
// Determine the device interface which implements this 
// ID
//
// Walk device list looking for the interface name.
//
//

// The first 4 characters of the DI name are different between setupapi and
// sysaudio, even though the paths match (\\?\ versus \??\). This is how
// much to ignore when matching the paths.
//
#define DI_PATH_PREFIX_LEN 4
static char gszDosDevices[] = "\\DosDevices\\";

BOOL DINameToInstanceId(char *pstrDIName, char **ppInstanceId)
{
    BOOL     bRet = FALSE;

    SetupAPI suwrap;
    long     lErr;
	HDEVINFO hDevInfo;

    if (!suwrap.IsValid())
    {
        return FALSE;
    }

#ifdef WINNT
    // We can get the empty string here, which obviously
    // matches nothing.
    //
    if (strlen(pstrDIName) < DI_PATH_PREFIX_LEN)
    {
        return FALSE;
    }
    pstrDIName += DI_PATH_PREFIX_LEN;
#else
    if (!_strnicmp(pstrDIName, "\\DosDevices\\", strlen(gszDosDevices)))
    {
        pstrDIName += strlen(gszDosDevices);
    }
    else if (!_strnicmp(pstrDIName, "\\\\.\\", DI_PATH_PREFIX_LEN))
    {
        // Already prepended, don't want to see that.
        pstrDIName += DI_PATH_PREFIX_LEN;
    }
#endif       

    *ppInstanceId = NULL;

    if (strlen(pstrDIName) < DI_PATH_PREFIX_LEN)
    {
        return FALSE;
    }
	
	hDevInfo = suwrap.SetupDiGetClassDevs(const_cast<GUID*>(&KSCATEGORY_AUDIO),
										  NULL,
										  NULL,
										  DIGCF_DEVICEINTERFACE);
    if (hDevInfo == NULL || hDevInfo == INVALID_HANDLE_VALUE)
    {
        TraceI(0, "SetupDiGetClassDevs %d\n", GetLastError());
        return FALSE;
    }

	BYTE rgbStorage[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + _MAX_PATH];

	SP_DEVICE_INTERFACE_DETAIL_DATA * pDevInterfaceDetails = 
	    (SP_DEVICE_INTERFACE_DETAIL_DATA *)rgbStorage;
	pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);

    SP_DEVINFO_DATA DevInfo;
    DevInfo.cbSize = sizeof(DevInfo);

    DWORD   dwRequiredInstanceIdSize;

    for (DWORD MemberIndex = 0; ; MemberIndex++)
    {
	    SP_DEVICE_INTERFACE_DATA DevInterfaceData;
	    DevInterfaceData.cbSize = sizeof(DevInterfaceData);

        if (!suwrap.SetupDiEnumDeviceInterfaces(hDevInfo,
                                                NULL,
                                                const_cast<GUID*>(&KSCATEGORY_AUDIO),
                                                MemberIndex,
                                                &DevInterfaceData))
        {
            TraceI(0, "SetupDiEnumDeviceInterfaces %d\n", GetLastError());
            break;
        }

        if (!suwrap.SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                                    &DevInterfaceData,
                                                    pDevInterfaceDetails,
        								  	  	    sizeof(rgbStorage), 
 										            NULL, 
 										            &DevInfo))
        {
            TraceI(0, "SetupDiGetDeviceInterfaceDetail %d\n", GetLastError());
            break;
        }
    
        // Look for a case insensitive match, ignoring the first 
        // DI_PATH_PREFIX_LEN characters.
        //
        if (strlen(pDevInterfaceDetails->DevicePath) < DI_PATH_PREFIX_LEN)
        {
            continue;
        }
                    
        if (_stricmp(pDevInterfaceDetails->DevicePath + DI_PATH_PREFIX_LEN, 
                     pstrDIName))
        {
            continue;
        }

        // We have a match. Get the device instance ID
        //
        lErr = 0;
        char c;
        suwrap.SetupDiGetDeviceInstanceId(hDevInfo,
                                          &DevInfo,
                                          &c,
                                          sizeof(c),
                                          &dwRequiredInstanceIdSize);

        lErr = GetLastError();
        if (lErr != ERROR_INSUFFICIENT_BUFFER)
        {   
            TraceI(0, "SetupDiGetDeviceInstanceId %d\n", lErr);
            break;
        }

        *ppInstanceId = new char[dwRequiredInstanceIdSize];
        if (!*ppInstanceId)
        {
            TraceI(0, "Out of memory determining preferred audio device\n");
            break;
        }

        if (!suwrap.SetupDiGetDeviceInstanceId(hDevInfo,
                                               &DevInfo,
                                               *ppInstanceId,
                                               dwRequiredInstanceIdSize,
                                               &dwRequiredInstanceIdSize))
        {
            TraceI(0, "SetupDiGetDeviceInstanceId %d\n", GetLastError());
            break;
        }

        bRet = TRUE;
        break;
    }                                              

    suwrap.SetupDiDestroyDeviceInfoList(hDevInfo);

    if (!bRet && *ppInstanceId)
    {
        delete[] *ppInstanceId;
        *ppInstanceId = NULL;
    }
    
    return bRet;        
}

#ifdef DBG
void _TraceIGuid(int iLevel, GUID *pGUID)
{
    char sz[256];
    char *psz = sz;
    
    psz += wsprintf(psz, "%08X-%04X-%04X-", pGUID->Data1, pGUID->Data2, pGUID->Data3);
    for (int i = 0; i < 8; i++) 
    {
        psz += wsprintf(psz, "%02X", pGUID->Data4[i]);
        if (i < 7)
        {
            *psz++ = '-';
        }
    }    

    TraceI(iLevel, sz);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic\tlist.h ===
/***************************************************************************
 *
 *  Copyright (c) 1995-1999 Microsoft Corporation
 *
 *  File:       tlist.h
 *  Content:    Linked-list template classes.  There's some seriously
 *              magical C++ in here, so be forewarned all ye C
 *              programmers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/12/97     dereks  Created.
 *
 ***************************************************************************/

#ifndef __TLIST_H__
#define __TLIST_H__

#ifdef __cplusplus

template<class type> class CNode
{
public:
    CNode<type> *       pPrev;          // Previous node in the list
    CNode<type> *       pNext;          // Next node in the list
    type                data;           // Node data

public:
    CNode(CNode<type> *, CNode<type> *, const type&);
};

template<class type> CNode<type>::CNode(CNode<type> *pInitPrev, CNode<type> *pInitNext, const type& rInitData)
{
    pPrev = pInitPrev;
    pNext = pInitNext;
    data = rInitData;
}

template<class type> class CList
{
private:
    CNode<type> *       m_pHead;        // Pointer to the head of the list
    CNode<type> *       m_pTail;        // Pointer to the tail of the list
    UINT                m_uCount;       // Count of nodes in the list

public:
    CList(void);
    virtual ~CList(void);

public:
    virtual CNode<type> *AddNodeToList(const type&);
    virtual void RemoveNodeFromList(CNode<type> *);
    virtual void RemoveDataFromList(const type&);
    virtual CNode<type> *IsDataInList(const type&);
    virtual CNode<type> *GetListHead(void);
    virtual UINT GetNodeCount(void);
};

template<class type> CList<type>::CList(void)
{
    m_pHead = NULL;
    m_pTail = NULL;
    m_uCount = 0;
}

template<class type> CList<type>::~CList(void)
{
    CNode<type> *       pNext;

    while(m_pHead)
    {
        pNext = m_pHead->pNext;
        delete m_pHead;
        m_pHead = pNext;
    }
}

template<class type> CNode<type> *CList<type>::AddNodeToList(const type& data)
{
    CNode<type> *       pNode;

    pNode = new CNode<type>(m_pTail, NULL, data);

    if(pNode)
    {
        if(pNode->pPrev)
        {
            pNode->pPrev->pNext = pNode;
        }

        if(!m_pHead)
        {
            m_pHead = pNode;
        }

        m_pTail = pNode;
        m_uCount++;
    }

    return pNode;
}

template<class type> void CList<type>::RemoveNodeFromList(CNode<type> *pNode)
{
//    ASSERT(pNode);

#ifdef DEBUG

    CNode<type> *pNext;

    for(pNext = m_pHead; pNext && pNext != pNode; pNext = pNext->pNext);
//    ASSERT(pNext == pNode);

#endif // DEBUG

    if(pNode->pPrev)
    {
        pNode->pPrev->pNext = pNode->pNext;
    }

    if(pNode->pNext)
    {
        pNode->pNext->pPrev = pNode->pPrev;
    }

    if(pNode == m_pHead)
    {
        m_pHead = pNode->pNext;
    }

    if(pNode == m_pTail)
    {
        m_pTail = pNode->pPrev;
    }

    delete pNode;
    m_uCount--;
}

template<class type> void CList<type>::RemoveDataFromList(const type& data)
{
    CNode<type> *       pNode;

    if(pNode = IsDataInList(data))
    {
        RemoveNodeFromList(pNode);
    }
}

template<class type> CNode<type> *CList<type>::IsDataInList(const type& data)
{
    CNode<type> *       pNode;

    for(pNode = m_pHead; pNode && !memcmp(&data, &pNode->data, sizeof(data)); pNode = pNode->pNext);

    return pNode;
}

template<class type> CNode<type> *CList<type>::GetListHead(void) 
{ 
    return m_pHead; 
}

template<class type> UINT CList<type>::GetNodeCount(void) 
{ 
    return m_uCount; 
}

#endif // __cplusplus

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\alloc.c ===
/* Copyright (c) 1998-1999 Microsoft Corporation */
/* @doc DMusic16
 *
 * @module Alloc.c - Memory allocation routines |
 *
 * This module provides memory allocation routines for DMusic16.DLL. It allows the MIDI input and
 * output modules to allocated and free <c EVENT> structures.
 *
 * The allocated recognizes two types of events by size. If an event is create with 4 or less bytes
 * of data, then it is allocated as a channel message. Channel message events are allocated one
 * page at a time and kept in a free list.
 *
 * If the event size is greater than 4 bytes, then the event is a system exclusive message (or long
 * data in the legacy API nomenclature). These events are allocated individually, one per page.
 *
 * All allocated memory is preceded with a <c SEGHDR>, which is used to identify the size and type
 * of the segment and to keep it in a list. Since all events will be accessed at event time (in
 * either a MIDI input callback or a timeSetEvent callback), all memory is automatically page
 * locked.
 *
 * @globalv WORD | gsSegList |Selector of first segment in allocated list
 * @globalv LPEVENT | glpFreeEventList | List of free 4-byte events 
 * @globalv LPEVENT | glpFreeBigEventList | List of free 4-byte events 
 */
#include <windows.h>
#include <mmsystem.h>
#include <memory.h>

#include "dmusic16.h"
#include "debug.h"

STATIC WORD gsSegList;
STATIC LPEVENT glpFreeEventList;        
STATIC LPEVENT glpFreeBigEventList;     

/* Given a far pointer, get its selector.
 */
#define SEL_OF(lp) (WORD)((((DWORD)lp) >> 16) & 0xffff)

/* Given a far event pointer, get the far pointer to its segment headear.
 */
#define SEGHDR_OF(lp)   ((LPSEGHDR)(((DWORD)lp) & 0xffff0000l))

STATIC BOOL RefillEventList(VOID);
STATIC LPSEGHDR AllocSeg(WORD cbSeg);
STATIC VOID FreeBigEvents(VOID);
STATIC VOID FreeSeg(LPSEGHDR lpSeg);

/* @func Called at DLL LibInit
 *
 * @comm
 * Initializes all free lists to empty.
 *
 */
VOID PASCAL
AllocOnLoad(VOID)
{
    gsSegList = 0;
    glpFreeEventList = NULL;
    glpFreeBigEventList = NULL;
}

/* @func Called at DLL LibExit
 *
 * @comm
 * Unlock and free all of the memory allocated.
 *
 * AllocOnUnload jettisons all memory the allocator has ever allocated. 
 * It assumes that all pointers to events will no longer ever be touched (i.e. all callbacks must
 * have already been disabled by this point).
 */
VOID PASCAL
AllocOnExit(VOID)
{
    WORD sSel;
    WORD sSelNext;
    LPSEGHDR lpSeg;

    sSel = gsSegList;

    while (sSel)
    {
        lpSeg = (LPSEGHDR)(((DWORD)sSel) << 16);
        sSelNext = lpSeg->selNext;
        
        FreeSeg(lpSeg);

        sSel = sSelNext;
    }
    
    /* This just invalidated both free lists as well as the segment list
     */
    gsSegList = 0;
    glpFreeEventList = NULL;
    glpFreeBigEventList = NULL;
}

/* @func Allocate an event of a given size
 *
 * @rdesc Returns a far pointer to the event or NULL if memory could not be allocated.
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * This function is called to allocate a single event. The event will be allocated from
 * page-locked memory and filled with the given event data.
 *
 * Events are classified as normal events, which contain channel messages, and big events,
 * which contain SysEx data. The two are distinguished by their size: any event containing
 * a DWORD of data or less is a normal event.
 *
 * Since channel messages comprise most of the MIDI stream, allocation of these events is optimized.
 * A segment is allocated containing approximately one page worth (4k) of 4-byte events. These
 * events are doled out of a free pool, which only occasionally needs to be refilled from system
 * memory.
 *
 * Big events are allocated on an as-needed basis. When they have been free'd by a call to FreeEvent,
 * they are placed on a special free list. This list is used to find memory for future big events,
 * and is occasionally free'd back to Windows on a call to AllocEvent in order to minimize the
 * amount of page-locked memory in use.
 */
LPEVENT PASCAL
AllocEvent(
    DWORD msTime,           /* @parm The absolute time based on timeGetTime() of the event */
    QUADWORD rtTime,        /* @parm The absolute time based on the IRferenceClock in 100ns units */
    WORD cbEvent)           /* @parm The number of bytes of event data in pbData */
{
    LPEVENT lpEvent;
    LPEVENT lpEventPrev;
    LPEVENT lpEventCurr;
    LPSEGHDR lpSeg;
    
    /* Check for big event first (Sysex)
     */
    if (cbEvent > sizeof(DWORD))
    {
        /* First see if we have an event that will work already
         */
        lpEventPrev = NULL;
        lpEventCurr = glpFreeBigEventList;
        
        while (lpEventCurr)
        {
            if (SEGHDR_OF(lpEventCurr)->cbSeg >= sizeof(EVENT) + cbEvent)
            {
                break;
            }
            lpEventPrev = lpEventCurr;
            lpEventCurr = lpEventCurr->lpNext;
        }

        if (lpEventCurr)
        {
            /* Remove this event from the list and use it
             */
            if (lpEventPrev)
            {
                lpEventPrev->lpNext = lpEventCurr->lpNext;
            }
            else
            {
                glpFreeBigEventList = lpEventCurr->lpNext;
            }

            lpEventCurr->lpNext = NULL;
        }
        else
        {
            /* Nope, need to allocate one
             */
            lpSeg = AllocSeg(sizeof(EVENT) + cbEvent);
            if (NULL == lpSeg)
            {
                return NULL;
            }

            lpEventCurr = (LPEVENT)(lpSeg + 1);
        }

        lpEventCurr->msTime = msTime;
        lpEventCurr->rtTime = rtTime;
        lpEventCurr->wFlags = 0;
        lpEventCurr->cbEvent = cbEvent;

        return lpEventCurr;
    }

    /* BUGBUG How often???
     */
    FreeBigEvents();

    /* Normal event. Pull it off the free list (refill if needed) and fill it in.
     */
    if (NULL == glpFreeEventList)
    {
        if (!RefillEventList())
        {
            return NULL;
        }
    }

    lpEvent = glpFreeEventList;
    glpFreeEventList = lpEvent->lpNext;

    lpEvent->msTime = msTime;
    lpEvent->rtTime = rtTime;
    lpEvent->wFlags = 0;
    lpEvent->cbEvent = cbEvent;

    return lpEvent;
}

/* @func Free an event back to its appropriate free list
 *
 * @comm
 *
 * FreeEvent makes no system calls; it simply places the given event back on the correct
 * free list. If the event needs to be actually free'd, that will be done at a later time
 * in user mode.
 */
VOID PASCAL
FreeEvent(
    LPEVENT lpEvent)            /* @parm The event to free */
{
    LPSEGHDR lpSeg;

    lpSeg = SEGHDR_OF(lpEvent);
    if (lpSeg->wFlags & SEG_F_4BYTE_EVENTS)
    {
        lpEvent->lpNext = glpFreeEventList;
        glpFreeEventList = lpEvent;
    }
    else
    {
        lpEvent->lpNext = glpFreeBigEventList;
        glpFreeBigEventList = lpEvent;
    }
}

/* @func Refill the free list of normal events
 *
 * @rdesc Returns TRUE if the list was refilled or FALSE if there was no memory.
 *
 * @comm
 *
 * This routine is not callable from interrupt time.
 *
 * Allocate one page-sized segment of normal events and add them to the free list.
 *
 */
STATIC BOOL
RefillEventList(VOID)
{
    LPSEGHDR lpSeg;
    LPEVENT lpEvent;
    UINT cbEvent;
    UINT idx;

    cbEvent = sizeof(EVENT) + sizeof(DWORD);
    lpSeg = AllocSeg(C_PER_SEG * cbEvent);
    if (NULL == lpSeg)
    {
        return FALSE;
    }

    lpSeg->wFlags = SEG_F_4BYTE_EVENTS;

    /* Put the events into the free pool
     */
    lpEvent = (LPEVENT)(lpSeg + 1);

    for (idx = C_PER_SEG - 1; idx; --idx)
    {
        lpEvent->lpNext = (LPEVENT)(((LPBYTE)lpEvent) + cbEvent);
        lpEvent = lpEvent->lpNext;
    }

    lpEvent->lpNext = glpFreeEventList;
    glpFreeEventList = (LPEVENT)(lpSeg + 1);
                                 
    return TRUE;
}

/* @func Free all big events
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * This function frees all big events on the free big event list. Free big events are those
 * with event data sizes of more than one DWORD; they are allocated one event per segment
 * as needed rather than being pooled like channel messages.
 *
 * This function is called every now and then as a side effect of AllocEvent in order to
 * free up the page-locked memory associated with completed big events.
 *
 */ 
STATIC VOID
FreeBigEvents(VOID)
{
    LPEVENT lpEvent;
    LPEVENT lpEventNext;
    LPSEGHDR lpSeg;

    lpEvent = glpFreeBigEventList;
    while (lpEvent)
    {
        lpEventNext = lpEvent->lpNext;

        lpSeg = SEGHDR_OF(lpEvent);
        FreeSeg(lpSeg);

        lpEvent = lpEventNext;
    }

    glpFreeBigEventList = NULL;
}

/* @func Allocate a segment and put it into the list of allocated segments.
 *
 * @rdesc A far pointer to the segment header or NULL if the memory could not be allocated.
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * This is the lowest-level allocation routine which actually calls Windows to allocate the memory.
 * The caller is responsible for carving the memory into one or more events.
 *
 * The data area of the segment will be filled with zeroes.
 *
 * Since events are accessed at interrupt time (timeSetEvent callback), the memory is allocated and
 * page locked.
 *
 * This routine also inserts the segment into the global list of allocated segments for cleanup.
 */
STATIC LPSEGHDR
AllocSeg(
    WORD cbSeg)                 /* @parm The size of data needed in the segment, excluding the segment header */
{
    HANDLE hSeg;
    WORD sSegHdr;
    LPSEGHDR lpSeg;

    /* Allocate and page-lock a segment
     * NOTE: GPTR contains zero-init
     */
    cbSeg += sizeof(SEGHDR);
    hSeg = GlobalAlloc(GPTR | GMEM_SHARE, cbSeg);
    if (0 == hSeg)
    {
        return NULL;
    }

    lpSeg = (LPSEGHDR)GlobalLock(hSeg);
    if (NULL == lpSeg)
    {
        GlobalFree(sSegHdr);
        return NULL;
    }

    sSegHdr = SEL_OF(lpSeg);
    if (!GlobalSmartPageLock(sSegHdr))
    {
        GlobalUnlock(sSegHdr);
        GlobalFree(sSegHdr);
        return NULL;
    }

    lpSeg->hSeg = hSeg;
    lpSeg->cbSeg = cbSeg;

    lpSeg->selNext  = gsSegList;
    gsSegList = sSegHdr;
    
    return lpSeg;
}

/* @func Free a segment back to Windows
 *
 * @comm
 *
 * This function is not callable at interrupt time.
 *
 * Just unlock the segment and free it. The calling cleanup code is assumed to have removed
 * the segment from the global list of allocated segments.
 *
 */
STATIC VOID FreeSeg(
    LPSEGHDR lpSeg)         /* @parm The segment to free */
{
    WORD sSel = SEL_OF(lpSeg);
    HANDLE hSeg;
    
    hSeg = lpSeg->hSeg;
    
    GlobalSmartPageUnlock(sSel);
    GlobalUnlock(hSeg);
    GlobalFree(hSeg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\cmphlp.inc ===
;***
;cmphlp.inc - include to aid in generating compiler helpers
;
;	Copyright (c) 1987-1998 Microsoft Corporation
;
;Purpose:
;	This file is a compiler helper include to aid in generating
;	backwards compatible compiler helpers.
;
;*******************************************************************************


callnahlpr MACRO nm		;;call non-assigning helper
if	sizeC
	push	cs
	call	near ptr __aF&nm
else
	call	near ptr __aN&nm
endif
ENDM


DFLT	MACRO	tag,prfx,nm
externP _a&prfx&tag&nm
cProc	_&tag&nm,<PUBLIC>,<>
cBegin	nogen
	jmp	_a&prfx&tag&nm
cEnd	nogen
ENDM

DFLT2	MACRO	tag,prfx,nm
externP _a&prfx&tag&nm
cProc	_&tag&u&nm,<PUBLIC>,<>
cBegin	nogen
cEnd	nogen
cProc	_&tag&nm,<PUBLIC>,<>
cBegin	nogen
	jmp	_a&prfx&tag&nm
cEnd	nogen
ENDM

ASGN	MACRO	nm		;;macro to fix up entry sequence of non
				;;assigning code helpers
if	sizeC
cProc	_aF&nm,<PUBLIC>,<>
cBegin

else
cProc	_aN&nm,<PUBLIC>,<>
cBegin
endif
ENDM



aASGN	MACRO	nm		;;macro to fix up entry sequence of assigning
				;;code helpers
if	memL	eq 1
externP _aF&nm
cProc	_aFFa&nm,<PUBLIC>,<>
cBegin
endif
if	memM	eq 1
externP _aF&nm
cProc	_aFNa&nm,<PUBLIC>,<>
cBegin
endif
if	memC	eq 1
externP _aN&nm
cProc	_aNFa&nm,<PUBLIC>,<>
cBegin
endif
if	memS	eq 1
externP _aN&nm
cProc	_aNNa&nm,<PUBLIC>,<>
cBegin
endif
ENDM


OLDSLEAZ MACRO

ifdef	lhdiff
OLDASGN hdiff
endif

ifdef	llshl
OLDASGN lshl
endif

ifdef	llshr
OLDASGN lshr
endif

ifdef	lulshr
OLDASGN ulshr
endif

ifdef	lldiv
OLDASGN ldiv
endif

ifdef	llmul
OLDASGN2 lmul
endif

ifdef	llrem
OLDASGN lrem
endif

ifdef	luldiv
OLDASGN uldiv
endif

ifdef	lulrem
OLDASGN ulrem
endif
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\device.c ===
/*
 * @Doc DMusic16
 *
 * @Module Device.c - Device management routines |
 *
 * This module manages handles and handle instances to the legacy MIDI device.
 *
 * Each open device is represented by a handle (which is 
 * an <c OPENHANDLE> struct). This struct contains all of the information
 * concerning the state of the device, including a reference count of the
 * number of clients using the device.
 *
 * Each client use of one device is represented by a handle instance (which
 * is an <c OPENHANDLINSTANCE> struct). A near pointer to this struct is
 * the actual handle seen by the client. These handle instances are used
 * to hold any client-specific information, and to dereference client
 * handles to the proper <c OPENHANDLE> struct.
 *
 * Currently we support multiple clients on the same output device but
 * only one client per input device.
 *
 * @globalv NPLINKNODE | gOpenHandleInstanceList | The master list of all
 * open handle instances.
 *
 * @globalv NPLINKNODE | gOpenHandleList | The master list of all open
 * handles.
 *
 * @globalv UINT | gcOpenInputDevices | A reference count of open MIDI
 * in devices.
 *
 * @globalv UINT | gcOpenOutputDevices | A reference count of open MIDI
 * out devices.
 */

#include <windows.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

NPLINKNODE gOpenHandleInstanceList;  
NPLINKNODE gOpenHandleList;          
UINT gcOpenInputDevices;             
UINT gcOpenOutputDevices;            

STATIC VOID PASCAL UpdateSegmentLocks(BOOL fIsOutput);

#pragma alloc_text(INIT_TEXT, DeviceOnLoad)
#pragma alloc_text(FIX_COMM_TEXT, IsValidHandle)

/* @func Called at DLL LibInit 
 *
 * @comm
 *
 * Initialize the handle lists to empty and clear the device reference counts.
 */
VOID PASCAL
DeviceOnLoad(VOID)
{
   gOpenHandleInstanceList = NULL;
   gOpenHandleList = NULL;

   gcOpenInputDevices = 0;
   gcOpenOutputDevices = 0;
}

/* @func Open a device
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * This function allocates an <c OPENHANDLEINSTANCE> struct on behalf of the caller.
 * If the requested device is already open and is an output device, the device's
 * reference count will be incremented an no other action is taken. If the requested
 * device is already open and is an input device, then the open will fail.
 *
 * If a non-DirectMusic application has the requested device open, then the
 * open will fail regardless of device type.
 *
 * If this open is the first input or output device opened, then it will
 * page lock the appropriate segments containing callback code and data.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_NOMEM | If there was insufficient memory to allocate
 * the tracking structure.
 *
 * @flag MMSYSERR_BADDEVICEID | If the given device ID was out of range.
 * @flag MMSYSERR_ALLOCATED | The specified device is already open.
 *
 */
MMRESULT WINAPI
OpenLegacyDevice(
    UINT id,            /* @parm MMSYSTEM id of device to open */
    BOOL fIsOutput,     /* @parm TRUE if this is an output device */
    BOOL fShare,        /* @parm TRUE if the device should be shareable */
    LPHANDLE ph)        /* @parm Pointer where handle will be returned */
                        /*       on success. */
{
    NPOPENHANDLEINSTANCE pohi;
    NPLINKNODE pLink;
    NPOPENHANDLE poh;
    MMRESULT mmr;

    DPF(2, "OpenLegacyDevice(%d,%s,%s)",
        (UINT)id,
        (LPSTR)(fIsOutput ? "Output" : "Input"),
        (LPSTR)(fShare ? "Shared" : "Exclusive"));
        
    *ph = (HANDLE)NULL;

    /* Sharing capture device is not allowed.
     */
    if ((!fIsOutput) && (fShare))
    {
        return MMSYSERR_ALLOCATED;
    }

    /* Make sure id is in the valid range of devices
     */
    if (fIsOutput)
    {
        if (id != MIDI_MAPPER &&
            id >= midiOutGetNumDevs())
        {
            return MMSYSERR_BADDEVICEID;
        }
    }
    else
    {
        if (id >= midiInGetNumDevs())
        {
            return MMSYSERR_BADDEVICEID;
        }
    }

    /* Create an open handle instance. This will be returned to
     * Win32 as the handle.
     */
    pohi = (NPOPENHANDLEINSTANCE)LocalAlloc(LPTR, sizeof(OPENHANDLEINSTANCE));
    if (NULL == pohi)
    {
        return MMSYSERR_NOMEM;
    }

    /* Search through the handles we already have open and try
     * to find the handle already open.
     */
    mmr = MMSYSERR_NOERROR;
    for (pLink = gOpenHandleList; pLink; pLink = pLink->pNext)
    {   
        poh = (NPOPENHANDLE)pLink;

        if (poh->id != id)
        {
            continue;
        }

        if ((fIsOutput    && (!(poh->wFlags & OH_F_MIDIIN))) ||
            ((!fIsOutput) && (poh->wFlags & OH_F_MIDIIN)))
        {
            break;
        }
    }

    /* If we didn't find it, try to allocate it.
     *
     */
    if (NULL == pLink)
    {
        poh = (NPOPENHANDLE)LocalAlloc(LPTR, sizeof(OPENHANDLE));
        if (NULL == poh)
        {
            LocalFree((HLOCAL)pohi);
            return MMSYSERR_NOMEM;
        }

        poh->uReferenceCount = 1;
        poh->id = id;
        poh->wFlags = (fIsOutput ? 0 : OH_F_MIDIIN);
        if (fShare)
        {
            poh->wFlags |= OH_F_SHARED;
        }
        InitializeCriticalSection(&poh->wCritSect);
    }
    else
    {
        poh = (NPOPENHANDLE)pLink;
        
        /* Validate sharing modes match.
         * If they want exclusive mode, fail. 
         * If the device is already open in exclusive mode, fail.
         */
        if (!fShare)
        {
            DPF(0, "Legacy open failed: non-shared open request, port already open.");
            LocalFree((HLOCAL)pohi);
            return MIDIERR_BADOPENMODE;
        }

        if (!(poh->wFlags & OH_F_SHARED))
        {
            DPF(0, "Legacy open failed: Port already open in exclusive mode.");
            LocalFree((HLOCAL)pohi);
            return MIDIERR_BADOPENMODE;
        }

        ++poh->uReferenceCount;
    }

    pohi->pHandle = poh;
    pohi->fActive = FALSE;
    pohi->wTask = GetCurrentTask();

    /* We lock segments here so we minimize the impacy of activation. However,
     * actual device open is tied to activation.
     */
    if (fIsOutput)
    {
        ++gcOpenOutputDevices;
        mmr = MidiOutOnOpen(pohi);
        if (mmr)
        {
            --gcOpenOutputDevices;
        }
        UpdateSegmentLocks(fIsOutput);
    }
    else
    {
        ++gcOpenInputDevices;
        mmr = MidiInOnOpen(pohi);
        if (mmr)
        {
            --gcOpenInputDevices;
        }
        UpdateSegmentLocks(fIsOutput);
    }

    if (poh->uReferenceCount == 1)
    {
        ListInsert(&gOpenHandleList, &poh->link);
    }

    ListInsert(&gOpenHandleInstanceList, &pohi->link);
    ListInsert(&poh->pInstanceList, &pohi->linkHandleList);

    *ph = (HANDLE)(DWORD)(WORD)pohi;

    return MMSYSERR_NOERROR;
}

/* @func Close a legacy device
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * It just validates the handle and calls the internal close device API.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 *
 * @flag MMSYSERR_INVALHANDLE | If the passed handle was not recognized.
 *
 */
MMRESULT WINAPI
CloseLegacyDevice(
    HANDLE h)       /* @parm The handle to close. */
{
    NPOPENHANDLEINSTANCE pohi = (NPOPENHANDLEINSTANCE)(WORD)h;

    DPF(2, "CloseLegacyDevice %04X\n", h);

    if (!IsValidHandle(h, VA_F_EITHER, &pohi))
    {
        DPF(0, "CloseLegacyDevice: Invalid handle\n");
        return MMSYSERR_INVALHANDLE;
    }

    return CloseLegacyDeviceI(pohi);
}

/* @func Activate or deactivate a legacy device
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * Validate parameters and pass the call to the internal activate.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_INVALHANDLE | If the passed handle was not recognized.
 * Any other MMRESULT that a midiXxx call might return.
 *
 */
MMRESULT WINAPI
ActivateLegacyDevice(
    HANDLE h,
    BOOL fActivate)
{
    NPOPENHANDLEINSTANCE pohi;

    if (!IsValidHandle(h, VA_F_EITHER, &pohi))
    {
        DPF(0, "Activate: Invalid handle\n");
        return MMSYSERR_INVALHANDLE;
    }

    return ActivateLegacyDeviceI(pohi, fActivate);
}

/* @func Close a legacy device (internal)
 *
 * @comm
 *
 * This function deallocates the referenced <c OPENHANDLEINSTANCE> struct.
 * If it is the last reference to the device, then the device will be closed
 * as well.
 *
 * If this is the last input or output device being closed, then the
 * appropriate segments containing callback code and data will be
 * unlocked.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 *
 */
MMRESULT PASCAL
CloseLegacyDeviceI(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh;

    /* Deactivate this device. This might result in the device being closed.
     */
    ActivateLegacyDeviceI(pohi, FALSE);

    poh = pohi->pHandle;
    ListRemove(&gOpenHandleInstanceList, &pohi->link);
    ListRemove(&poh->pInstanceList, &pohi->linkHandleList);

    --poh->uReferenceCount;
    if (poh->wFlags & OH_F_MIDIIN)
    {
        --gcOpenInputDevices;
        MidiInOnClose(pohi);
        UpdateSegmentLocks(FALSE /*fIsOutput*/);
    }
    else
    {
        --gcOpenOutputDevices;
        MidiOutOnClose(pohi);
        UpdateSegmentLocks(TRUE  /*fIsOutput*/);
    }

    if (0 == poh->uReferenceCount)
    {
        ListRemove(&gOpenHandleList, &poh->link);
        LocalFree((HLOCAL)poh);
    }

    LocalFree((HLOCAL)pohi);

    return MMSYSERR_NOERROR;
}

/* @func Activate or deactivate a legacy device (internal)
 *
 * @comm
 *
 * This function is thunked to the 32-bit peer.
 *
 * Handle open and close of the device on first activate and last deactivate.
 *
 * @rdesc Returns one of the following:
 *
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_INVALHANDLE | If the passed handle was not recognized.
 * Any other MMRESULT that a midiXxx call might return.
 *
 */
MMRESULT PASCAL
ActivateLegacyDeviceI(
    NPOPENHANDLEINSTANCE pohi,
    BOOL fActivate)
{
    NPOPENHANDLE poh;
    MMRESULT mmr;

    poh = pohi->pHandle;

    if (fActivate)
    {
        if (pohi->fActive)
        {
            DPF(0, "Activate: Activating already active handle %04X", pohi);
            return MMSYSERR_NOERROR;
        }

        poh->uActiveCount++;
    
        if (poh->wFlags & OH_F_MIDIIN)
        {
            mmr = MidiInOnActivate(pohi);
        }
        else
        {
            mmr = MidiOutOnActivate(pohi);
        }

        if (mmr == MMSYSERR_NOERROR) 
        {
            pohi->fActive = TRUE;
        }
        else
        {
            --poh->uActiveCount;
        }
    }
    else
    {
        if (!pohi->fActive)
        {
            DPF(0, "Activate: Deactivating already inactive handle %04X", pohi);
            return MMSYSERR_NOERROR;
        }

        pohi->fActive = TRUE;
        poh->uActiveCount--;

        if (poh->wFlags & OH_F_MIDIIN)
        {
            mmr = MidiInOnDeactivate(pohi);
        }
        else
        {
            mmr = MidiOutOnDeactivate(pohi);
        }

        if (mmr == MMSYSERR_NOERROR) 
        {
            pohi->fActive = FALSE;
        }
        else
        {
            --poh->uActiveCount;
        }
    }

    return mmr;    
}

/* @func Validate the given handle
 *
 * @comm
 *
 * Determine if the given handle is valid, and if so, return the open handle instance.
 *
 * The handle is merely a pointer to an <c OPENHANDLEINSTANCE> struct. This function,
 * in the debug build, will verify that the handle actually points to a struct allocated
 * by this DLL. In all builds, the handle type will be verified.
 *
 * @rdesc Returns one of the following:
 * @flag MMSYSERR_NOERROR | On success
 * @flag MMSYSERR_INVALHANDLE | If the given handle is invalid or of the wrong type.
 *
 */
BOOL PASCAL
IsValidHandle(
    HANDLE h,                           /* @parm The handle to verify */
    WORD wType,                         /* @parm The required type of handle. One of the following: */
                                        /* @flag VA_F_INPUT  | If the handle must specify an input device */
                                        /* @flag VA_F_OUTPUT | If the handle must specify an output device */
                                        /* @flag VA_F_EITHER | If either type of handle is acceptable */
    NPOPENHANDLEINSTANCE FAR *lppohi)   /* @parm Will contain the open handle instance on return */
{
#ifdef DEBUG
    NPLINKNODE pLink;
#endif
    NPOPENHANDLEINSTANCE pohi = (NPOPENHANDLEINSTANCE)(WORD)h;

#ifdef DEBUG
    /* Find the handle instance in the global list
     */
    for (pLink = gOpenHandleInstanceList; pLink; pLink = pLink->pNext)
    {
        DPF(2, "IsValidHandle: Theirs %04X mine %04X", (WORD)h, (WORD)pLink);
        if (pLink == (NPLINKNODE)(WORD)h)
        {
            break;
        }
    }

    if (NULL == pLink)
    {
        return FALSE;
    }
#endif

    DPF(2, "IsValidHandle: Got handle, flags are %04X", pohi->pHandle->wFlags);

    *lppohi = pohi;
    
    /* Verify the handle type
     */
    if (pohi->pHandle->wFlags & OH_F_MIDIIN)
    {
        if (wType & VA_F_INPUT)
        {
            return TRUE;
        }
    }
    else
    {
        if (wType & VA_F_OUTPUT)
        {
            return TRUE;
        }
    }

    *lppohi = NULL;

    return FALSE;
}


/* @func Lock or unlock segments as need be.
 *
 * @comm
 *
 * This function calls the DLL's Lock and Unlock functions to bring the lock status
 * of the segments containing callback code and data into sync with the actual types
 * of devices currently open. This prevents having too much memory page locked when
 * it is not actually being used.
 *
 */
STATIC VOID PASCAL
UpdateSegmentLocks(
    BOOL fIsOutput)     /* @parm TRUE if the last device opened or closed was an output device */
{
    if (fIsOutput)
    {
        switch(gcOpenOutputDevices)
        {
            case 0:
                if (gcOpenInputDevices)
                {
                    DPF(2, "Unlocking output");
                    UnlockCode(LOCK_F_OUTPUT);
                }
                else
                {
                    DPF(2, "Unlocking output+common");
                    UnlockCode(LOCK_F_OUTPUT | LOCK_F_COMMON);
                }
                break;

            case 1:
                if (gcOpenInputDevices)
                {
                    DPF(2, "Locking output");
                    LockCode(LOCK_F_OUTPUT);
                }
                else
                {
                    DPF(2, "Locking output+common");
                    LockCode(LOCK_F_OUTPUT | LOCK_F_COMMON);
                }
                break;
        }
    }
    else
    {
        switch(gcOpenInputDevices)
        {
            case 0:
                if (gcOpenOutputDevices)
                {
                    DPF(2, "Unlocking input");
                    UnlockCode(LOCK_F_INPUT);
                }
                else
                {
                    DPF(2, "Unlocking input+common");
                    UnlockCode(LOCK_F_INPUT | LOCK_F_COMMON);
                }
                break;

            case 1:
                if (gcOpenOutputDevices)
                {
                    DPF(2, "Locking input");
                    LockCode(LOCK_F_INPUT);
                }
                else
                {
                    DPF(2, "Locking input+common");
                    LockCode(LOCK_F_INPUT | LOCK_F_COMMON);
                }
                break;
        }
    }
}

/* @func Clean up all open handles held by a given task
 *
 * @comm This function is called when a task terminates. It will clean up resources left
 * behind by a process which did not terminate cleanly, and therefore did not tell
 * this DLL to unload in its context.
 */
VOID PASCAL
CloseDevicesForTask(
    WORD wTask)
{
    NPLINKNODE pLink;
    NPOPENHANDLEINSTANCE pohi;

    for (pLink = gOpenHandleInstanceList; pLink; pLink = pLink->pNext)
    {
        pohi = (NPOPENHANDLEINSTANCE)pLink;

        if (pohi->wTask != wTask)
        {
            continue;
        }

        DPF(0, "CloseDevicesForTask: Closing %04X", (WORD)pohi);
        /* NOTE: This will free pohi
         */
        CloseLegacyDeviceI(pohi);

        pLink = gOpenHandleInstanceList;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\debug.c ===
//==========================================================================; 
//
//      Copyright (c) 1991-1999 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifdef   DEBUG

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <stdarg.h>

#include "debug.h"

#ifdef WIN32
   #define  BCODE
#else
   #define  BCODE                   __based(__segname("_TEXT"))
#endif


#define WSPRINTF_LIMIT 1024

typedef struct tagLOG
{
     LPBYTE             lpbQueue;
     UINT               cbBuffer;
     UINT               idxRead;
     UINT               idxWrite;
} LOG, FAR *LPLOG;

#define LOG_INCIDX(pl,x) ((++(x) >= pl->cbBuffer) ? x = 0 : x)

VOID FAR CDECL DbgVPrintF(LPSTR szFmt, LPSTR va) ;

BOOL NEAR PASCAL LogInit(LPLOG lpLog, UINT ckBuffer);
VOID NEAR PASCAL LogWrite(LPLOG lpLog, LPSTR lpstrEvent);
BOOL NEAR PASCAL LogRead(LPLOG lpLog, LPSTR lpstrBuffer, UINT cbBuffer);

#ifdef ISRDEBUG
int wivsprintf(LPSTR lpOut, LPCSTR lpFmt, VOID FAR* lpParms) ;

LPCSTR  NEAR PASCAL SP_GetFmtValue(LPCSTR lpch, LPWORD lpw) ;
UINT    NEAR PASCAL SP_PutNumber(LPSTR lpb, DWORD n, UINT limit, UINT radix, UINT icase) ;
VOID    NEAR PASCAL SP_Reverse(LPSTR lpFirst, LPSTR lpLast) ;
UINT    NEAR PASCAL ilstrlen(LPSTR lpstr) ;
VOID    NEAR PASCAL ilstrcat(LPSTR lpstrDest, LPSTR lpstrSrc) ;
#endif

//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#define wvsprintfA           wvsprintf
#define GetProfileIntA       GetProfileInt
#define OutputDebugStringA   OutputDebugString

#ifdef ISRDEBUG
   #define wvsprintf        wivsprintf
   #define lstrcatA         ilstrcat
   #define lstrlenA         ilstrlen    
#else
   #define lstrcatA         lstrcat
   #define lstrlenA         lstrlen
#endif

//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level
BOOL    __gfLogging     = 0;        // Are we logging as well?
BOOL    __gfAssertBreak = 0;        // Break on assert?

HWND    ghWndCB         = (HWND)NULL;
LOG     gLog;
WORD    wDebugLevel     = 0;

//************************************************************************
//**
//**  DbgAssert();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR lpstrExp
//**     LPSTR lpstrFile
//**     DWORD dwLine  
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************
VOID WINAPI DbgAssert(
    LPSTR           lpstrExp,
    LPSTR           lpstrFile,
    DWORD           dwLine)
{
    static char BCODE szFormat[] =
        "Assert:%s@%lu %s";
    dprintf(0, szFormat, lpstrFile, dwLine, lpstrExp);
    if (__gfAssertBreak)
        DebugBreak();
}

//************************************************************************
//**
//**  DbgVPrintF();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR szFmt
//**     LPSTR va
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID FAR CDECL DbgVPrintF(
   LPSTR szFmt, 
   LPSTR va)
{
    char    ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch(*szFmt)
        {
            case '!':
                fDebugBreak = TRUE;
                szFmt++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFmt++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFmt++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");

    wvsprintfA(ach + lstrlenA(ach), szFmt, (LPSTR)va);

    if (fCRLF)
        lstrcatA(ach, "\r\n");

    if (__gfLogging)
    {
        LogWrite(&gLog, ach);
        if (ghWndCB)
            PostMessage(ghWndCB, WM_DEBUGUPDATE, 0, 0);
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
        DebugBreak();
} //** DbgVPrintF()


//************************************************************************
//**
//**  dprintf();
//**
//**  DESCRIPTION:
//**     dprintf() is called by the DPF macro if DEBUG is defined at compile
//**     time.
//**     
//**     The messages will be send to COM1: like any debug message. To
//**     enable debug output, add the following to WIN.INI :
//**
//**     [debug]
//**     ICSAMPLE=1
//**
//**
//**  ARGUMENTS:
//**     UINT     uDbgLevel
//**     LPCSTR   szFmt
//**     ...
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

VOID FAR CDECL dprintf(
   UINT     uDbgLevel, 
   LPSTR   szFmt, 
   ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFmt);
    DbgVPrintF(szFmt, (LPSTR)va);
    va_end(va);
} //** dprintf()


//************************************************************************
//**
//**  DbgEnable();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     BOOL fEnable
//**
//**  RETURNS:
//**     BOOL 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

BOOL WINAPI DbgEnable(
   BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} //** DbgEnable()



//************************************************************************
//**
//**  DbgSetLevel();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     UINT uLevel
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

UINT WINAPI DbgSetLevel(
   UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = wDebugLevel = uLevel;

    return (uOldLevel);
} //** DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(VOID)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92    cjp     [curtisp] 
//
//--------------------------------------------------------------------------;


UINT WINAPI DbgInitialize(BOOL fEnable)
{
    char            szTemp[64];
    LPSTR           pstr;
    UINT            uLevel;
    UINT            uLogMem;
    
    __gfAssertBreak = GetProfileInt(DEBUG_SECTION, ASSERT_BREAK, 0);

    GetProfileString(DEBUG_SECTION, DEBUG_MODULE_NAME, "", szTemp, sizeof(szTemp));

    pstr = szTemp;
    uLevel = 0;
    while (*pstr >= '0' && *pstr <= '9')
    {
        uLevel = uLevel*10 + (UINT)(*pstr - '0');
        pstr++;
    }

    __gfLogging = FALSE;
    if (*pstr == ',')
    {
        pstr++;
        uLogMem = 0;
        while (*pstr >= '0' && *pstr <= '9')
        {
            uLogMem = uLogMem*10 + (UINT)(*pstr - '0');
            pstr++;
        }

        if (0 == uLogMem) uLogMem = K_DEFAULT_LOGMEM;
        if (uLogMem > K_MAX_LOGMEM) uLogMem = K_MAX_LOGMEM;

        __gfLogging = TRUE;
    }
    
    if (__gfLogging)
        __gfLogging = LogInit(&gLog, uLogMem);
    
    DbgSetLevel(GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

VOID WINAPI DbgRegisterCallback(HWND hWnd)
{
    ghWndCB = hWnd;
}

BOOL WINAPI DbgGetNextLogEntry(LPSTR lpstrBuffer, UINT cbBuffer)
{
    if (!__gfLogging)
        return FALSE;

    return LogRead(&gLog, lpstrBuffer, cbBuffer);
}

BOOL NEAR PASCAL LogInit(LPLOG lpLog, UINT ckMem)
{
    DWORD               cbMem;

    cbMem = 1024L * ckMem;

    lpLog->lpbQueue = GlobalAllocPtr(GPTR, cbMem);
    if (NULL == lpLog->lpbQueue)
        return FALSE;

    if (!GlobalSmartPageLock(HIWORD(lpLog->lpbQueue)))
    {
        GlobalFreePtr(lpLog->lpbQueue);
        return FALSE;
    }

    lpLog->cbBuffer = (UINT)cbMem;
    lpLog->idxRead = 0;
    lpLog->idxWrite = 0;

    return TRUE;
}

VOID NEAR PASCAL LogWrite(LPLOG lpLog, LPSTR lpstrEvent)
{
    if (!*lpstrEvent)
        return;

    while (*lpstrEvent)
    {
        lpLog->lpbQueue[lpLog->idxWrite] = *lpstrEvent++;
        LOG_INCIDX(lpLog,lpLog->idxWrite);
    }

    lpLog->idxRead = lpLog->idxWrite;

    while (lpLog->lpbQueue[lpLog->idxRead])
    {
        lpLog->lpbQueue[lpLog->idxRead] = '\0';
        LOG_INCIDX(lpLog,lpLog->idxRead);
    }
    
    LOG_INCIDX(lpLog,lpLog->idxRead);
    LOG_INCIDX(lpLog,lpLog->idxWrite);
}

BOOL NEAR PASCAL LogRead(LPLOG lpLog, LPSTR lpstrBuffer, UINT cbBuffer)
{
    BYTE                    c;
    UINT                    idx;

    if (!cbBuffer)
        return FALSE;
    
    idx = lpLog->idxRead;

    while ('\0' == lpLog->lpbQueue[idx])
    {
        LOG_INCIDX(lpLog,idx);
        if (idx == lpLog->idxRead)
            return FALSE;
    }

    cbBuffer--;
    while (0 != (c = lpLog->lpbQueue[idx]))
    {
        if (cbBuffer)
        {
            *lpstrBuffer++ = c;
            cbBuffer--;
        }
            
        lpLog->lpbQueue[idx] = '\0';
        LOG_INCIDX(lpLog,idx);
    }

    *lpstrBuffer = '\0';

    LOG_INCIDX(lpLog,idx);

    lpLog->idxRead = idx;
    return TRUE;
}



//--------------------------------------------------------------------------;
//
// The rest of the code is only needed if we're in Win16 and need to be
// interrupt callable.
//
//--------------------------------------------------------------------------;

#ifdef ISRDEBUG

#define OUT(ch) if (--cchLimit) *lpOut++=(ch); else goto error_Out

//************************************************************************
//**
//**  wivsprintf();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of wvsprintf() 
//**
//**
//**  ARGUMENTS:
//**     LPSTR       lpOut    -  Buffer to format into.
//**     LPCSTR      lpFmt    -  Format string.
//**     VOID FAR*   lpParms  -  Points to the first of args 
//**                             described by lpFmt.
//**
//**  RETURNS:
//**     int   -  Number of characters stored.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

int wivsprintf(
    LPSTR       lpOut,
    LPCSTR      lpFmt,
    VOID FAR*   lpParms)
{
    int         left ;
    char        prefix ;
    int         width ;
    int         prec ;
    char        fillch ;
    int         size ;
    int         sign ;
    int         radix ;
    int         upper ;
    int         cchLimit = WSPRINTF_LIMIT;
    int         cch ;
    LPSTR       lpT ;
    union
    {
        long            l ;
        unsigned long   ul ;
        char sz[sizeof(long)] ;
    } val;
                
    while (*lpFmt)
    {
        if (*lpFmt=='%')
        {
            //
            // Read the format flags. 
            //
            left   = 0 ;
            prefix = 0 ;

            while (*++lpFmt)
            {
                if (*lpFmt=='-')
                {    
                    left++;
                }
                else if (*lpFmt=='#')
                {
                    prefix++;
                }
                else
                {
                    break;
                }
            }

            //
            // Find the fill character (either '0' or ' ')
            //
            if (*lpFmt=='0')
            {
                fillch = '0' ;
                lpFmt++ ;
            }
            else
            {
                fillch = ' ' ;
            }

            //
            // Now parse [width[.precision]]
            //
            lpFmt = SP_GetFmtValue(lpFmt,&cch);
            width = cch;

            if (*lpFmt=='.')
            {
                lpFmt = SP_GetFmtValue(++lpFmt,&cch);
                prec = cch;
            }
            else
            {
                prec = (UINT)-1 ;
            }

            //
            // Get the operand size modifier
            //
            if (*lpFmt=='l')
            {
                size = 1 ;
                lpFmt++ ;
            }
            else
            {
                size = 0 ;
                if (*lpFmt=='h')
                {
                    lpFmt++ ;
                }
            }
            
            //
            // We've gotten all the modifier; now format the output
            // based on the type (which should now be pointed at
            // by lpFmt).
            //
            upper = 0 ;
            sign = 0 ;
            radix = 10 ;

            switch (*lpFmt)
            {
                case 0:
                    goto error_Out ;

                case 'i' :
                case 'd' :
                    sign++ ;

                case 'u':
                    //
                    // Don't show a prefix for decimal formats
                    // 
                    prefix=0 ;
do_Numeric:
                    //
                    // Special cases to act like MSC v5.10
                    //
                    if (left || prec>=0)
                    {
                        fillch = ' ';
                    }

                    //
                    // Get value from parm list into val union 
                    // 
                    if (size)
                    {
                        val.l=*((long far *)lpParms)++;
                    }
                    else
                    {
                        if (sign)
                        {
                            val.l=(long)*((short far *)lpParms)++;
                        }
                        else
                        {
                            val.ul=(unsigned long)*((unsigned far *)lpParms)++;
                        }
                    }

                    //
                    // Save sign of val.l in sign and set val.l positive.
                    //
                    if (sign && val.l<0L)
                    {
                        val.l=-val.l;
                    }
                    else
                    {
                        sign=0;
                    }

                    //
                    // Save start of output stream for later reverse
                    //
                    lpT = lpOut;

                    //
                    // Blast the number backwards into the user buffer 
                    //
                    cch = SP_PutNumber(lpOut,val.l,cchLimit,radix,upper) ;
                    if (!(cchLimit-=cch))
                        goto error_Out ;

                    lpOut += cch ;
                    width -= cch ;
                    prec -= cch ;

                    if (prec>0)
                    {
                        width -= prec ;
                    }

                    //
                    // Fill in up to precision
                    //
                    while (prec-- > 0)
                    {
                        OUT('0') ;
                    }

                    if (width>0 && !left)
                    {
                        //
                        // If we're filling with spaces, put sign first 
                        //
                        if (fillch != '0')
                        {
                            if (sign)
                            {
                                sign = 0 ;
                                OUT('-') ;
                                width-- ;
                            }

                            if (prefix)
                            {
                                OUT(prefix) ;
                                OUT('0') ;
                                prefix = 0 ;
                            }
                        }

                        if (sign)
                        {
                            width-- ;
                        }

                        //
                        // Now fill to width
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        //
                        // Still have a sign? 
                        //
                        if (sign)
                        {
                            OUT('-') ;
                        }

                        if (prefix)
                        {
                            OUT(prefix) ;
                            OUT('0') ;
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);
                    }
                    else
                    {
                        //
                        // Add the sign character
                        //
                        if (sign)
                        {
                            OUT('-') ;
                            width-- ;
                        }

                        if (prefix)
                        {
                            OUT(prefix);
                            OUT('0');
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);

                        //
                        // Pad to the right of the string in case left aligned 
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    break ;

                case 'X':
                    upper++ ;
                    //
                    // Falling through...
                    //

                case 'x':
                    radix=16 ;
                    if (prefix)
                    {
                        prefix = upper ? 'X' : 'x' ;
                    }
                    goto do_Numeric ;

                case 'c':
                    //
                    // Save as one character string and join common code
                    // 
                    val.sz[0] = *((char far*)lpParms) ;
                    val.sz[1]=0 ;
                    lpT = val.sz ;
                    cch = 1 ;  
                    (BYTE far*)lpParms += sizeof(WORD) ;

                    goto put_String ;

                case 's':
                    lpT = *((LPSTR FAR *)lpParms)++ ;
                    cch = ilstrlen(lpT) ;
put_String:
                    if (prec>=0 && cch>prec)
                    {
                        cch = prec ;
                    }

                    width -= cch ;

                    if (left)
                    {
                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }

                        while (width-->0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    else
                    {
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }
                    }
                    break ;

                default:
                    //
                    // An unsupported type character was given. We just
                    // print the character and go on. 
                    //
                    OUT(*lpFmt) ;
                    break ;

            } // switch(*lpfmt)
        } // if (*lpfmt == '%')
        else
        {
            //
            // Normal not-format character
            //
            OUT(*lpFmt) ;
        }
                
        lpFmt++ ;
    } // while (*lpFmt) 

error_Out:
    *lpOut = 0 ;

    return WSPRINTF_LIMIT-cchLimit ;
} //** wivsprintf()


//************************************************************************
//**
//**  SP_GetFmtValue();
//**
//**  DESCRIPTION:
//**     Parse a decimal integer forming part of a format string.
//**
//**
//**  ARGUMENTS:
//**     LPCSTR   lpch  -  Points to the string to parse.
//**     LPWORD   lpw   -  Points to a word where the value will be 
//**                       returned.
//**
//**  RETURNS:
//**     LPCSTR   -  Pointer of first character past the format value.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

LPCSTR NEAR PASCAL SP_GetFmtValue(
   LPCSTR   lpch,
   LPWORD   lpw)
{
    WORD        i = 0 ;

    while (*lpch>='0' && *lpch<='9')
    {
        i *= 10;
        i += (UINT)(*lpch++-'0');
    }     

    *lpw = i;

    return(lpch); 
} //** SP_GetFmtValue()

//************************************************************************
//**
//**  SP_PutNumber();
//**
//**  DESCRIPTION:
//**     Formats the given number in the given radix into the buffer
//**     *backwards*. The entire string will be reversed after printf
//**     has added sign, prefix, etc. to it.
//**
//**  
//**  ARGUMENTS:
//**     LPSTR lpb   -  Points to the output buffer.
//**     DWORD n     -  Number to convert.
//**     UINT  limit -  Maximum number of characters to store.
//**     UINT  radix -  Base to format in.
//**     UINT  icase -  Non-zero if the string should be upper case (hex).
//**
//**  RETURNS:
//**     UINT  -  Number of characters output.
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL SP_PutNumber(
   LPSTR lpb,
   DWORD n,
   UINT  limit,
   UINT  radix,
   UINT  icase)
{
   BYTE  bTemp;
   UINT  cchStored = 0;

   //
   // Set icase to the offset to add to the character if it
   // represents a value > 10
   //
   icase = (icase ? 'A' : 'a') - '0' - 10 ;

   while (limit--)
   {
//
//    AVOID a call to __aFulrem
//    This code words because radix is only a word
//
//    bTemp = '0' + (BYTE)(n%radix) ;
//
      _asm
      {
         mov     cx, radix
         mov     ax, word ptr n+2
         xor     dx, dx
         div     cx
         mov     ax, word ptr n
         div     cx
         add     dl, '0'
         mov     bTemp, dl
      }

      if (bTemp > '9')
      {
         bTemp += icase ;
      }

      *lpb++ = bTemp ;
      ++cchStored ;

//       
//    AVOID a call to __aFFauldiv
//    This code words because radix is only a word
//
//    n /= radix
//
      _asm
      {
         push    bx
         mov     cx, radix
         mov     ax, word ptr n+2
         xor     dx, dx
         div     cx
         mov     bx, ax
         mov     ax, word ptr n
         div     cx
         mov     word ptr n+2, bx
         mov     word ptr n, ax
         pop     bx
      }

      if (n == 0)
      {
         break ;
      }    
   }

   return cchStored ;
} //** SP_PutNumber()


//************************************************************************
//**
//**  SP_Reverse();
//**
//**  DESCRIPTION:
//**     Reverse string in place.
//**
//**  ARGUMENTS:
//**     LPSTR pFirst
//**     LPSTR pLast
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL SP_Reverse(
   LPSTR pFirst,
   LPSTR pLast)
{
   UINT  uSwaps = (pLast - pFirst + 1) / 2;
   BYTE  bTemp;

   while (uSwaps--)
   {
      bTemp   = *pFirst;
      *pFirst = *pLast;
      *pLast  = bTemp;

      pFirst++, pLast--;
   }
} //** SP_Reverse()

//************************************************************************
//**
//**  ilstrlen();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of strlen().
//**
//**  ARGUMENTS:
//**     LPSTR   pstr
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL ilstrlen(
    LPSTR   pstr)
{
   UINT    cch = 0 ;

   while (*pstr++)
      ++cch;

   return(cch);
} //** ilstrlen()

//************************************************************************
//**
//**  ilstrcat();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of lstrcat().
//**
//**  ARGUMENTS:
//**     LPSTR   pstrDest
//**     LPSTR   pstrSrc
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL ilstrcat(
    LPSTR   pstrDest,
    LPSTR   pstrSrc)
{
   while (*pstrDest)
      pstrDest++;

   while (*pstrDest++ = *pstrSrc++)
      ;

} //** ilstrcat()

#endif // #ifdef ISRDEBUG

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\debug.h ===
//==========================================================================;
//
//      Copyright (c) 1991-1998 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//      To use this library at interrupt time under Win16, you must do
//      the following:
//
//      1. Defined ISRDEBUG when compiling debug.c
//  
//      2. Add a line in the SEGMENTS section of your .DEF file to
//         define the DEBUG_TEXT segment:
//
//
//      SEGMENTS
//          DEBUG_TEXT FIXED PRELOAD
//
//
//      These routines are callable at interrupt time under Win32 by
//      default.
//
//  win.ini
//  [debug]
//  MIDIMAP=0|1|2|3|4
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define  ISRDEBUG             1
#define  DEBUG_SECTION        "debug"        // section name for 
#define  ASSERT_BREAK         "AssertBreak"  // Key for break on assert
#define  DEBUG_MODULE_NAME    "DMUSIC16"     // key name and prefix for output
#define  DEBUG_MAX_LINE_LEN   255            // max line length (bytes)

#define  K_DEFAULT_LOGMEM     32
#define  K_MAX_LOGMEM         63
    
#define  DRV_ENABLE_DEBUG     (DRV_USER+1)   // Enable/disable debug message
#define  DRV_SET_DEBUG_LEVEL  (DRV_USER+2)   // Message to set the debug level

#define WM_DEBUGUPDATE          (WM_USER+1000)

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    VOID WINAPI DbgAssert(LPSTR lpstrExp, LPSTR lpstrFile, DWORD dwLine);
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI DbgRegisterCallback(HWND hWnd);
    BOOL WINAPI DbgGetNextLogEntry(LPSTR lpstrBuffer, UINT cbBuffer);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define assert(exp) \
        ( (exp) ? (void) 0 : DbgAssert(#exp, __FILE__, __LINE__) )

    #define DPF                  dprintf

    #define D1(sz)               dprintf(1,sz) 
    #define D2(sz)               dprintf(2,sz) 
    #define D3(sz)               dprintf(3,sz) 
    #define D4(sz)               dprintf(4,sz) 
#else
    #define assert(exp)          ((void)0)
    
    #define DbgEnable(x)         FALSE
    #define DbgSetLevel(x)       0
    #define DbgInitialize(x)     0

    #define DPF                  1 ? (void)0 : (void)

    #define D1(sz)
    #define D2(sz)
    #define D3(sz)
    #define D4(sz)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\dmusic16.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* @Doc DMusic16
 *
 * @Module DMusic16.h - Internal definitions for DMusic16.DLL |
 */

#ifndef __DMUSIC16__
#define __DMUSIC16__

#undef  WINAPI                                 
#define WINAPI            _loadds FAR PASCAL   

#ifdef WIN32
   #define  BCODE
   #define  BSTACK
#else
   #define  BCODE                   __based(__segname("_CODE"))
   #define  BSTACK                  __based(__segname("_STACK"))
#endif

/* Make symbols show up in debug builds
 */
#ifdef DEBUG
#define STATIC 
#else
#define STATIC static
#endif

/* MIDI defines 
 */
#define MIDI_CHANNELS           16
 

#define SZCODE const char BCODE

/* Quadword alignment for event lengths in DMEVENT's
 */
#define QWORD_ALIGN(x) (((x) + 7) & ~7)         /* Next highest */

#define QWORD_TRUNC(x) ((x) & ~7)               /* Next lowest */

/* Multiplier to convert between reftime and milliseconds
 */
#define REFTIME_TO_MS (10L*1000L)


/* Number of events we want in the capture pool. Based on about a second's worth of high
 * concentration data
 */
#define CAP_HIGHWATERMARK 1024

/* How often user-mode timer ticks happen (milliseconds)
 */
#define MS_USERMODE 1000

/* Typedefs for everyone. Woohoo!
 */
typedef struct QUADWORD       QUADWORD;
typedef struct QUADWORD NEAR *NPQUADWORD;
typedef struct QUADWORD FAR  *LPQUADWORD;

typedef struct LINKNODE       LINKNODE;
typedef struct LINKNODE NEAR *NPLINKNODE;
typedef struct LINKNODE FAR  *LPLINKNODE;

typedef struct DMEVENT       DMEVENT;
typedef struct DMEVENT NEAR *NPDMEVENT;
typedef struct DMEVENT FAR  *LPDMEVENT;

typedef struct EVENT       EVENT;
typedef struct EVENT NEAR *NPEVENT;
typedef struct EVENT FAR  *LPEVENT;

typedef struct EVENTQUEUE       EVENTQUEUE;
typedef struct EVENTQUEUE NEAR *NPEVENTQUEUE;
typedef struct EVENTQUEUE FAR  *LPEVENTQUEUE;

typedef struct OPENHANDLEINSTANCE        OPENHANDLEINSTANCE;
typedef struct OPENHANDLEINSTANCE NEAR *NPOPENHANDLEINSTANCE;
typedef struct OPENHANDLEINSTANCE FAR  *LPOPENHANDLEINSTANCE;

typedef struct OPENHANDLE       OPENHANDLE;
typedef struct OPENHANDLE NEAR *NPOPENHANDLE;
typedef struct OPENHANDLE FAR  *LPOPENHANDLE;

typedef struct THRUCHANNEL       THRUCHANNEL;
typedef struct THRUCHANNEL NEAR *NPTHRUCHANNEL;
typedef struct THRUCHANNEL FAR  *LPTHRUCHANNEL;

/* 64-bit integer used w/ assembly helpers
 */
struct QUADWORD
{
    DWORD dwLow;
    DWORD dwHigh;
};

/* @struct Holds things in doubly linked lists
 */ 
struct LINKNODE {
    NPLINKNODE pPrev;           /* @field NPLINKNODE | pPrev |
                                   Pointer to the previous node in the list */
    
    NPLINKNODE pNext;           /* @field NPLINKNODE | pNext |
                                   Pointer to the next node in the list */
};

/* @struct DirectMusic event as packed by IDirectMusic
 */
struct DMEVENT {
    DWORD cbEvent;              /* @field DWORD | cbEvent |
                                   Unrounded number of event bytes */
    
    DWORD dwChannelGroup;       /* @field DWORD | dwChannelGroup |
                                   This field determines which channel group (set of 16 MIDI channels) receives the event. */

    QUADWORD rtDelta;			/* @field QUADWORD | rtDelta | Offset from buffer header in 100 ns units */
    
    DWORD dwFlags;              /* @field DWORD | dwFlags | DMEVENT_xxx */
    
    BYTE  abEvent[0];           /* @field BYTE | abEvent[] |
                                   Actual event data, rounded up to be an even number 
                                   of QWORD's (8 bytes) */
};

                                /* Total size of an event needed to hold cb bytes of data */
                                
#define DMEVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMEVENT) + (cb))      

                                /* If we have cb for event + data, how much data can we fit? */
                                
#define DMEVENT_DATASIZE(cb) (QWORD_TRUNC(cb) - sizeof(DMEVENT))

#define DMEVENT_STRUCTURED  0x00000001

#define EVENT_F_MIDIHDR     0x0001

/* @struct Event as stored in an <c EVENTQUEUE>.
 */
struct EVENT {
    LPEVENT lpNext;             /* @field LPEVENT | lpNext |
                                   Next event in queue */
    
    DWORD msTime;               /* @field DWORD | msTime |
                                   Absolute ms time in stream time (i.e. timeSetEvent) */

    QUADWORD rtTime;			/* @field QUADWORD | rtTime |
								   Absolute time in 100ns units relative to reference clock. Use for sorting event queue. */
    
    WORD  wFlags;               /* @field WORD | wFlags |
                                   A bitwise combination of the following flags: 
                                   @flag EVENT_F_MIDIHDR | The event data starts with a MIDIHDR */
    
    WORD  cbEvent;              /* @field WORD | cbEvent |
                                   The unrounded number of bytes in the event data */
    
    BYTE  abEvent[0];           /* @field BYTE | abEvent[] |
                                   The actual event data, rounded up to be an even number of DWORD's */
};

/* @struct A queue of <c EVENT> structs.
 *
 * @comm
 * This is not the same as the generic list in list.c because we don't need
 * the overhead of a prev pointer here and we don't need the overhead of a far
 * pointer there.
 */
struct EVENTQUEUE {
    LPEVENT pHead;              /* @field LPEVENT | pHead | Pointer to the first event */
    LPEVENT pTail;              /* @field LPEVENT | pTail | Pointer to the last event */
    UINT    cEle;               /* @field UINT | cEle | The number of events currently in queue */
};

/* @struct An instance of an open device
 *
 * @comm
 *
 * Since multiple Win32 processes can hold a single MMSYSTEM handle open,
 * we need to track them. There is one of these structs per Win32 client
 * per open handle. It simply refers to the OPENHANDLE which contains
 * all the actual handle data.
 *
 */
struct OPENHANDLEINSTANCE {
    LINKNODE link;               /* @field LINKNODE | link | Holds this handle in gOpenHandleInstanceList */
    LINKNODE linkHandleList;     /* @field LINKNODE | linkHandleList |
                                    Holds this handle in the list maintained in the <c OPENHANDLE> struct for this device. */
                                    
    NPOPENHANDLE pHandle;        /* @field NPOPENHANDLE | pHandle |
                                    Pointer to the <c OPENHANDLE> struct for this device. */
    
    DWORD dwVxDEventHandle;      /* @field DWORD | dwVxDEventHandle |
                                    VxD Event handle for signalling input on this device for this client. */

    BOOL fActive;                /* @field BOOL | fActive | Indicates if the port is active or not. This is used for per-instance
                                    focus management. If the port is flagged as inactive, then the underlying device is not opened. */

    WORD wTask;                  /* @field WORD | wTask | Task which opened the handle. This is used to clean up if the task
                                    terminates abnormally. */

    NPTHRUCHANNEL pThru;         /* @field NPTHRUCHANNEL | pThru If an input device, an array of 16 thru
                                    entries, one per input channel. */
};

/* OPENHANDLE.wFlags
 */
#define OH_F_MIDIIN  0x0001     /* This is a MIDI input device */
#define OH_F_CLOSING 0x0002     /* This device is being closed */
#define OH_F_SHARED  0x0004     /* This device is shareable */

/* @struct An open device
 *
 * @comm
 *
 * There is a one-to-one relationship between open handles and <c OPENHANDLE> structs.
 *
 * All of the following event queues are either
 *  Protected - means it is accessible at callback time and user time, and is
 *              protected by wCritSect
 *  Callback  - Means it is unprotected by a critical section and is only accessible
 *              at callback time. Callbacks, per handle, are not reentered.
 *
 * In the MIDI in callback, we *cannot* just go away if we don't get wCritSect,
 * as we can on output. Hence the multiple input queues below.
 *
 * When the user mode refill algorithm runs, it puts events in qFree, protected
 * by the critical section. (The one exception to this is preloading qFreeCB before
 * midiInStart is called on the handle). When the callback runs, it tried to get the
 * critical section. If it can, it moves the free events from qFree to qFreeCB.
 *
 * In any case, the callback can now use qFreeCB even if it didn't get the critical
 * section. It pulls a free event from the queue, fills it, and puts it back onto
 * the tail of qDoneCB. If the critical section is held, it then transfers the
 * entire contents of qDoneCB to qDone.
 *
 * These transfers are not time consuming; they are merely the manipulation of
 * a couple of pointers.
 */
struct OPENHANDLE {
    LINKNODE link;              /* @field LINKNODE | link |
                                   Holds this handle in gOpenHandles */

    NPLINKNODE pInstanceList;   /* @field NPLINKLINK | pInstanceList |
                                   Points to the first element in the list of open handle instances using
                                   this device. */
    
    UINT uReferenceCount;       /* @field UINT | uReferenceCount |
                                   The number of clients using this device; i.e., the number of elements in the
                                   pInstanceList. */
    UINT uActiveCount;          /* @field UINT | uActiveCount |
                                   The number of clients that have activated this device */                                   

    UINT id;                    /* @field UINT | id | The MMSYSTEM device ID of this device */
    WORD wFlags;                /* @field WORD | wFlags | Some combination of the following flags:
                                   @flag OH_F_MIDIIN | This device is a MIDI input device
                                   @flag OH_F_CLOSING | This device is being closed. 
                                   @flag OH_F_SHARE | This device is opened in shared mode */
    
    HMIDIOUT hmo;               /* @field HMIDIOUT | hmo | MIDI output handle if an output device */
    HMIDIIN  hmi;               /* @field HMIDIIN | hmi | MIDI input handle if an input device */

    WORD wCritSect;             /* @field WORD | wCritSect | Critical section protecting protected queues */
    DWORD msStartTime;          /* @field DWORD | msStartTime | <f timeGetTime()> Time we started input */
    
    EVENTQUEUE qPlay;           /* @field EVENTQUEUE | qPlay |
                                   Output: Queue of events to play (protected) */
    
    EVENTQUEUE qDone;           /* @field EVENTQUEUE | qDone |
                                   Input/Output: Events already done (played or received) (protected) */

    EVENTQUEUE qFree;           /* @field EVENTQUEUE | qFree |
                                   Input: Queue of free events (protected) */
                                   
    EVENTQUEUE qFreeCB;         /* @field EVENTQUEUE | qFreeCB |
                                   Input: Queue of free events used by callback */
     
    EVENTQUEUE qDoneCB;         /* @field EVENTQUEUE | qDoneCB |
                                   Input: Queue of received events used by callback */
                                   
    WORD wPostedSysExBuffers;   /* @field WORD | cPostedSysExBuffers |
                                   Input: Buffers posted in MMSYSTEM for recording SysEx */                                           
};

#define CLASS_MIDI              0 /* dwEventClass */

/* Close to our page size
 */
#define SEG_SIZE 4096
#define C_PER_SEG ((SEG_SIZE - sizeof(SEGHDR)) / (sizeof(EVENT) + sizeof(DWORD)))

#define SEG_F_4BYTE_EVENTS 0x0001

typedef struct SEGHDR SEGHDR;
typedef struct SEGHDR FAR * LPSEGHDR;

/* @struct The header for one segment of allocated memory
 */
struct SEGHDR {
    WORD selNext; /* @field WORD | selNext |
                     The selector of the next block of memory in the allocated list */
    
    WORD hSeg;    /* @field WORD | hSeg |
                     The global handle of the memory block */
    
    WORD wFlags;  /* @field WORD | wFlags |
                     A bitwise combination of the following flags:
                     
                     @flag SEG_F_4BYTE_EVENTS | This segment contains multiple 
                     channel messages */
    
    WORD cbSeg;   /* @field WORD | cbSeg |
                     The size of the segment, less the <c SEGHDR> */
};

/* @struct Thru information for one channel
 *
 * @comm 
 *
 * Each input device handle instance contains an array of 16 of these structures containing
 * the thru destination for data that arrives on that channel.
 *
 */
struct THRUCHANNEL {
    WORD wChannel;              /* @field WORD | wChannel | The destination channel */
    NPOPENHANDLEINSTANCE pohi;  /* @field NPOPENHANDLEINSTANCE | pohi | The output handle instance
                                   to receive the thru'ed data. */
}; 

/* globals */
extern HINSTANCE ghInst;
extern NPLINKNODE gOpenHandleInstanceList;
extern NPLINKNODE gOpenHandleList;
extern UINT gcOpenInputDevices;
extern UINT gcOpenOutputDevices;

/* device.c */
#define VA_F_INPUT  0x0001
#define VA_F_OUTPUT 0x0002
#define VA_F_EITHER (VA_F_INPUT | VA_F_OUTPUT)

extern VOID PASCAL DeviceOnLoad(VOID);
extern MMRESULT PASCAL CloseLegacyDeviceI(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL ActivateLegacyDeviceI(NPOPENHANDLEINSTANCE pohi, BOOL fActivate);

extern BOOL PASCAL IsValidHandle(HANDLE h, WORD wType, NPOPENHANDLEINSTANCE FAR *lppohi);
extern VOID PASCAL CloseDevicesForTask(WORD wTask);


/* list.c */
extern VOID PASCAL ListInsert(NPLINKNODE *pHead, NPLINKNODE pNode);
extern VOID PASCAL ListRemove(NPLINKNODE *pHead, NPLINKNODE pNode);

/* eventq.c */
extern VOID PASCAL QueueInit(NPEVENTQUEUE pQueue);
extern VOID PASCAL QueueAppend(NPEVENTQUEUE pQueue, LPEVENT pEvent);
extern VOID PASCAL QueueCat(NPEVENTQUEUE pDest, NPEVENTQUEUE pSource);
extern LPEVENT PASCAL QueueRemoveFromFront(NPEVENTQUEUE pQueue);

#define QUEUE_FILTER_KEEP   (0)
#define QUEUE_FILTER_REMOVE (1)

typedef int (PASCAL *PFNQUEUEFILTER)(LPEVENT pEvent, DWORD dwInstance);
extern VOID PASCAL QueueFilter(NPEVENTQUEUE pQueue, DWORD dwInstance, PFNQUEUEFILTER pfnFilter);
extern LPEVENT PASCAL QueuePeek(NPEVENTQUEUE pQueue);

#ifdef DEBUG
#define AssertQueueValid(pQueue) _AssertQueueValid((pQueue), __FILE__, __LINE__)
extern VOID PASCAL _AssertQueueValid(NPEVENTQUEUE pQueue, LPSTR pstrFile, UINT uLine);
#else
#define AssertQueueValid
#endif

/* locks.c */
#define LOCK_F_INPUT  0x0001
#define LOCK_F_OUTPUT 0x0002
#define LOCK_F_COMMON 0x0004
extern VOID PASCAL LockCode(WORD wFlags);
extern VOID PASCAL UnlockCode(WORD wFlags);

/* dmhelp.asm */
extern VOID PASCAL InitializeCriticalSection(LPWORD lpwCritSect);

#define CS_NONBLOCKING  (0)
#define CS_BLOCKING     (1)
extern WORD PASCAL EnterCriticalSection(LPWORD lpwCritSect, WORD fBlocking);
extern VOID PASCAL LeaveCriticalSection(LPWORD lpwCritSect);
extern WORD PASCAL DisableInterrupts(VOID);
extern VOID PASCAL RestoreInterrupts(WORD wIntStat);
extern WORD PASCAL InterlockedIncrement(LPWORD pw);
extern WORD PASCAL InterlockedDecrement(LPWORD pw);

extern DWORD PASCAL QuadwordDiv(QUADWORD qwDividend, DWORD dwDivisor);
extern VOID PASCAL QuadwordMul(DWORD m1, DWORD m2, LPQUADWORD qwResult);
extern BOOL PASCAL QuadwordLT(QUADWORD qwLValue, QUADWORD qwRValue);
extern VOID PASCAL QuadwordAdd(QUADWORD qwOp1, QUADWORD qwOp2, LPQUADWORD lpqwResult);

/* alloc.c */
extern VOID PASCAL AllocOnLoad(VOID);
extern VOID PASCAL AllocOnExit(VOID);
extern LPEVENT PASCAL AllocEvent(DWORD msTime, QUADWORD rtTime, WORD cbEvent);
extern VOID PASCAL FreeEvent(LPEVENT lpEvent);

/* midiout.c */
extern VOID PASCAL MidiOutOnLoad(VOID);
extern VOID PASCAL MidiOutOnExit(VOID);
extern MMRESULT PASCAL MidiOutOnOpen(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL MidiOutOnClose(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiOutOnActivate(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiOutOnDeactivate(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL SetOutputTimerRes(BOOL fOnOpen);
extern VOID PASCAL FreeDoneHandleEvents(NPOPENHANDLE poh, BOOL fClosing);
extern VOID PASCAL MidiOutThru(NPOPENHANDLEINSTANCE pohi, DWORD dwMessage);

/* midiin.c */
extern VOID PASCAL MidiInOnLoad(VOID);
extern VOID PASCAL MidiInOnExit(VOID);
extern MMRESULT PASCAL MidiInOnOpen(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL MidiInOnClose(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiInOnActivate(NPOPENHANDLEINSTANCE pohi);
extern MMRESULT PASCAL MidiInOnDeactivate(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL MidiInRefillFreeLists(VOID);
extern VOID PASCAL MidiInUnthruToInstance(NPOPENHANDLEINSTANCE pohi);
extern VOID PASCAL FreeAllQueueEvents(NPEVENTQUEUE peq);

/* mmdevldr.asm */
extern MMRESULT CDECL SetWin32Event(DWORD dwVxDEvent); /* Must be CDECL! */

/* timerwnd.c */
extern BOOL PASCAL CreateTimerTask(VOID);
extern VOID PASCAL DestroyTimerTask(VOID);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\equeue.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @DOC DMusic16
 *
 * @MODULE EQueue.c - Event queue routines |
 *
 * These routines maintain queues of events. It is expected that other routines will operate
 * directly on the queue. The following invariants must be maintained:
 *
 * If the queue is empty, then the head and tail pointers must be NULL and the element count must be zero.
 *
 * The queue must not contain circular links.
 *
 * An event may only be on one queue.
 *
 * The element count must be equal to the number of events in the queue.
 */
#include <windows.h>
#include <mmsystem.h>
#include <memory.h>

#include "dmusic16.h"
#include "debug.h"

/* @func Initialize an event queue to be empty
 *
 * @comm
 *
 * Any previous contents of the queue will be lost (NOT freed).
 */
VOID PASCAL
QueueInit(
    NPEVENTQUEUE pQueue)        /* @parm Pointer to the queue to initialize */
{
    DPF(4, "QueueInit(%04X)", (WORD)pQueue);
    
    pQueue->pHead = NULL;
    pQueue->pTail = NULL;
    pQueue->cEle  = 0;

    AssertQueueValid(pQueue);
}

/* @func Append an event to the end of the queue
 *
 */
VOID PASCAL
QueueAppend(
    NPEVENTQUEUE pQueue,        /* @parm Pointer to the queue */
    LPEVENT pEvent)             /* @parm Pointer to the event to tack on the end of the queue */
{
    DPF(4, "QueueAppend(%04X,%08lX)", (WORD)pQueue, (DWORD)pEvent);
    
    if (pQueue->cEle)
    {
        assert(pQueue->pHead);
        assert(pQueue->pTail);

        pQueue->pTail->lpNext = pEvent;
    }
    else
    {
        assert(NULL == pQueue->pHead);
        assert(NULL == pQueue->pTail);
        
        pQueue->pHead = pEvent;
    }
    
    pEvent->lpNext = NULL;
    pQueue->pTail = pEvent;
    ++pQueue->cEle;

    AssertQueueValid(pQueue);
}

/* @func Concatenate two queues
 *
 * @comm
 *
 * This function tacks the contents of <p pSrc> onto the end of <p pDest> in very short constant time.
 * <p pSrc> is left empty after the operation.
 */
VOID PASCAL
QueueCat(
    NPEVENTQUEUE pDest,     /* @parm The queue to receive new events */
    NPEVENTQUEUE pSrc)      /* @parm The queue which will lost all its events */
{
    DPF(4, "QueueCat(%04X,%04X)", (WORD)pDest, (WORD)pSrc);
    
    if (0 == pSrc->cEle)
    {
        assert(NULL == pSrc->pHead);
        assert(NULL == pSrc->pTail);

        return;
    }

    assert(pSrc->pHead);
    assert(pSrc->pTail);

    if (0 != pDest->cEle)
    {
        assert(pDest->pHead);
        assert(pDest->pTail);
        
        pDest->cEle += pSrc->cEle;
        pDest->pTail->lpNext = pSrc->pHead;
        pDest->pTail = pSrc->pTail;
    }
    else
    {
        assert(NULL == pDest->pHead);
        assert(NULL == pDest->pTail);

        *pDest = *pSrc;
    }

    pSrc->pHead = NULL;
    pSrc->pTail = NULL;
    pSrc->cEle  = 0;
    
    AssertQueueValid(pDest);
    AssertQueueValid(pSrc);
}

/* @func Dequeue an element from the front of the queue
 *
 * @rdesc Returns an event pointer or NULL if the queue is empty
 *
 */
LPEVENT PASCAL
QueueRemoveFromFront(
    NPEVENTQUEUE pQueue)        /* @parm The queue to dequeue from */
{
    LPEVENT pEvent;
    
    DPF(4, "QueueRemoveFromFront(%04X)", (WORD)pQueue);

    if (0 == pQueue->cEle)
    {
        assert(NULL == pQueue->pHead);
        assert(NULL == pQueue->pTail);
        
        return NULL;
    }

    assert(pQueue->pHead);
    assert(pQueue->pTail);

    pEvent = pQueue->pHead;

    if (0 != --pQueue->cEle)
    {
        assert(pQueue->pHead != pQueue->pTail);
        
        pQueue->pHead = pQueue->pHead->lpNext;
    }
    else
    {
        assert(pQueue->pHead == pQueue->pTail);

        pQueue->pHead = NULL;
        pQueue->pTail = NULL;
    }

    AssertQueueValid(pQueue);

    return pEvent;
}

/* @func Enumerate the events in a queue, possibly deleting some or all of them
 *
 * @comm
 *
 * This function calls the function pointed to by <p pfnFilter> once for each event in
 * the queue, starting at the front and working towards the back.
 *
 * The function <p pfnFilter> may return one of two values:
 * @flag QUEUE_FILTER_KEEP | If the event is to be kept
 * @flag QUEUE_FILTER_REMOVE | If the event is to be removed from the queue
 */
VOID PASCAL
QueueFilter(
    NPEVENTQUEUE pQueue,        /* @parm The queue to enumerate */
    DWORD dwInstance,           /* @parm Instance data which will be passed to
                                   <p pfnFilter> on each call. */
    PFNQUEUEFILTER pfnFilter)   /* @parm The function to call with each event */
{
    LPEVENT pPrev;
    LPEVENT pCurr;
    LPEVENT pNext;

    DPF(4, "QueueFilter(%04X, %08lX, %08lX)", (WORD)pQueue, (DWORD)dwInstance, (DWORD)pfnFilter);

    pPrev = NULL;
    pCurr = pQueue->pHead;

    while (pCurr)
    {
        /* Callback is allowed to relink into another queue, so save the next
         * pointer now.
         */
        pNext = pCurr->lpNext;

        switch((*pfnFilter)(pCurr, dwInstance))
        {
            case QUEUE_FILTER_REMOVE:
                if (pPrev)
                {
                    pPrev->lpNext = pNext;
                }
                else
                {
                    pQueue->pHead = pNext;
                }

                if (pNext == NULL)
                {
                    pQueue->pTail = pPrev;
                }

                --pQueue->cEle;
                
                AssertQueueValid(pQueue);
                
                pCurr = pNext;
                break;

            case QUEUE_FILTER_KEEP:
                pPrev = pCurr;
                pCurr = pNext;
                break;
                
            default:
                assert(0);
        }
    }

    AssertQueueValid(pQueue);
}

/* @func Peek at the head of the event queue to see what's next
 *
 * @comm
 *
 * Non-destructively return the first event in the queue
 *
 * @rdesc
 * Returns the event pointer or NULL if the queue is empty
 */
LPEVENT PASCAL
QueuePeek(
    NPEVENTQUEUE pQueue)
{
    DPF(4, "QueuePeek(%04X)", (WORD)pQueue);
            
    return pQueue->pHead;
}

/* @func Look at the queue and make sure it's internally consistent.
 *
 * @comm
 *
 * Walk the queue and make sure it isn't circularly linked. Also make sure the count
 * is correct.
 *
 * Asserts into debugger if queue is corrupt.
 *
 * Called by the AssertQueueValid macro in debug builds.
 *
 * Disables interrupts to avoid false reports of corruption based on the queue changing under
 * the routine.
 *
 */
#ifdef DEBUG
void PASCAL
_AssertQueueValid(
    NPEVENTQUEUE pQueue,
    LPSTR szFile,
    UINT uLine)
{
    LPEVENT pEventSlow;
    LPEVENT pEventFast;
    UINT cEle;
    WORD wIntStat;
    BOOL fTrace = FALSE;

    wIntStat = DisableInterrupts();
    
    if (!pQueue)
    {
        DPF(0, "_AssertQueueValid %s@%u: Passed NULL!", szFile, uLine);
        assert(FALSE);
        goto cleanup;
    }

    pEventFast = pEventSlow = pQueue->pHead;

    cEle = 0;

    while (pEventSlow)
    {
        ++cEle;
        pEventSlow = pEventSlow->lpNext;
        
        if (pEventFast)
        {
            pEventFast = pEventFast->lpNext;
        }

        if (pEventFast)
        {
            pEventFast = pEventFast->lpNext;
        }
        
        if (pEventSlow && pEventFast && pEventSlow == pEventFast)
        {
            DPF(0, "_AssertQueueValid %s@%u: Queue %04X is circularly linked!",
                szFile,
                uLine,
                (WORD)pQueue);
            assert(FALSE);
            fTrace = TRUE;
            break;
        }
    }
    
    if (cEle != pQueue->cEle)
    {
        DPF(0, "_AssertQueueValid %s@%u: Queue %04X has incorrect element count!",
            szFile,
            uLine,
            (WORD)pQueue);
        assert(FALSE);
        fTrace = TRUE;
    }
    
    if ((pQueue->pHead && !pQueue->pTail) ||
        (pQueue->pTail && !pQueue->pHead))
    {
        DPF(0, "_AssertQueueValid %s@%u: Queue %04X head XOR tail is NULL!",
            szFile,
            uLine,
            (WORD)pQueue);
        assert(FALSE);
        fTrace = TRUE;
    }

    if (fTrace)
    {
        DPF(0, "Queue %04X: head %08lX tail %08lX count %u",
            (WORD)pQueue,
            (DWORD)pQueue->pHead,
            (DWORD)pQueue->pTail,
            (WORD)pQueue->cEle);
        
        for (pEventSlow = pQueue->pHead; pEventSlow; pEventSlow = pEventSlow->lpNext)
        {
            DPF(2, "  Event %08lX: lpNext %08lX msTime %lu wFlags %04X cbEvent %04X",
                (DWORD)pEventSlow,
                (DWORD)pEventSlow->lpNext,
                (DWORD)pEventSlow->msTime,
                (WORD)pEventSlow->wFlags,
                (WORD)pEventSlow->cbEvent);
        }
    }

cleanup:
    RestoreInterrupts(wIntStat);
}
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\libentry.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   LIBENTRY.ASM
;
;   Copyright (c) 1989-1998 Microsoft Corporation
;
;   This module contains the entry point for MidiMap.dll
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        PMODE = 1

        include cmacros.inc                   

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   extrns
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP LibMain
        externFP LocalInit
        externFP LibExit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
        __acrtused = 1

sEnd        Data

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Library entry point
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;       SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;       None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;       Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
        ;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
        ;
        push    di
        push    cx
        push    es
        push    si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        xor     ax,ax
        cCall   LocalInit,<ax,ax,cx>

no_heap:
        cCall   LibMain
cEnd

        assumes ds,nothing
        assumes es,nothing

cProc   WEP, <FAR, PUBLIC, PASCAL>, <>
        ParmW   fSystemExit
cBegin nogen
        mov     ax, fSystemExit
        cCall   LibExit, <ax>
        mov     ax, 1
        retf    2
cEnd   nogen

        sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\dmhelp.asm ===
; Copyright (c) 1998 Microsoft Corporation
;
; @Doc DMusic16
;
; @Module  DMHelp.asm - Helper functions |
;
; Thunk helpers for DMusic16.DLL
;

        page    ,132

        TITLE   $dos\usa\dmhelp.asm

        .386
        OPTION READONLY
        OPTION OLDSTRUCTS

        OPTION SEGMENT:USE16
        .model LARGE,PASCAL

;?MEDIUM=1
;?QUIET=1

externDef TileBuffer:far16
externDef UntileBuffer:far16
externDef OutputDebugString:far16

;===========================================================================
;
; 64-bit integer struct as passed in from C routines
;
; This must match the definition in dmusic16.h
;
;
;===========================================================================
QUADWORD	struc
qwLow		dd			?
qwHigh		dd			?
QUADWORD	ends

        .code dmhelp


;===========================================================================

EAXtoDXAX       macro
        shld    edx, eax, 16            ; move HIWORD(eax) to dx
endm

DXAXtoEAX       macro
        ror     eax, 16                 ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax, edx, 16            ; move LOWORD(edx) to HIWORD(eax)
endm

;===========================================================================
public dmTileBuffer
public dmUntileBuffer
public QuadwordDiv

externDef       __FLATDS:abs

_DATA SEGMENT WORD USE16 PUBLIC 'DATA'
FlatData                dw      __FLATDS
ifdef DEBUG
szNotOwner              db      'Critical section released by other than owner', 0
endif
_DATA ENDS

;===========================================================================
;
; @func DWORD | dmTileBuffer | Tile a 32-bit linear address as selectors
;
; @comm 
;
; Take the 32-bit virtual address in <p dwFlatMemory> of length <p dwLength> and create
; tiled selectors for it. This is used to pass a region of memory to a 16 bit thunk
; as a huge pointer.
;
; @rdesc
; 
; Returns a DWORD of tiling information, or 0 if the tiling could not be completed.
; The tiling information consists of a 16 bit selector in the high word and the
; number of tiled selectors in the low word. To make a 16:16 pointer to the 
; block of memory, mask the low 16 bits of the tiling information to zero.
;
; @parm DWORD | dwFlatMemory | The linear address of the memory to tile
;
; @parm DWORD | dwLength | The length in bytes of the region to tile
;
align
dmTileBuffer proc far16 public,
        dwFlatMemory:dword, dwLength:dword
        
        push    edi
        push    esi

        mov     eax, dwFlatMemory
        mov     ecx, dwLength
        call    TileBuffer
        mov     eax, ecx
        EAXtoDXAX

        pop     esi
        pop     edi
        ret
dmTileBuffer endp

;===========================================================================
;
; @func VOID | dmUntileBuffer | Untile a buffer
;
; @comm
;
; Free the tiled selectors allocated by dmTileBuffer. The buffer must have
; been previously tiles with <f dmTileBuffer>.
;
; @parm DWORD | dwTilingInfo | The tiling info returned by a previous call 
; to <f dmTileBuffer>.
;
align
dmUntileBuffer proc far16 public,
        dwTilingInfo:dword

        push    esi
        push    edi
        mov     ecx, dwTilingInfo
        call    UntileBuffer
        pop     edi
        pop     esi
        ret
dmUntileBuffer endp

;===========================================================================
;
; @func VOID PASCAL |  InitializeCriticalSection | Initialize a critical section
;
; @comm
;
; Initialize the critical section to not-in.
;
; @parm LPWORD | lpwCritSect | The critical section to initialize.
;
align
InitializeCriticalSection proc far16 public,
        lpwCritSect:dword

        push    es
        push    di

        les     di, [lpwCritSect]
        mov     word ptr es:[di], 1

        pop     di
        pop     es
        ret

InitializeCriticalSection endp

;===========================================================================
;
; @func WORD PASCAL | EnterCriticalSection | Enter a critical section
;
; @comm
;
; If fBlocking is set, then spin until we can get the critical section.
; Otherwise, return failure if we could not get it. 
;
; @rdesc
; Returns 
;  0 if we did not get the critical section
;  A non-zero ID if we did get the critical section
;
; @parm LPWORD | lpwCritSect | A pointer to the critical section to enter
; @parm WORD | fBlocking | A flag to indicate that the function should block if the 
; critical section is not immediately available
;
align
EnterCriticalSection proc far16 public,
        lpwCritSect:dword,
        fBlocking:word
        
        push    es
        push    di

        les     di, [lpwCritSect]       ; -> critical section
        mov     cx, [fBlocking]

ecs_check:
        dec     word ptr es:[di]        ; 1 -> 0 means we got it
                                        ; atomic on non-MP 
        jz      short ecs_success

        inc     word ptr es:[di]        ; Return to previous state

        or      cx, cx                  ; Blocking?
        jnz     short ecs_check         ; Yes

        xor     ax, ax                  ; Non-blocking and failed
        jmp     ecs_done

ecs_success: 
        mov     ax, 1

ecs_done:
        pop     di
        pop     es
        ret

EnterCriticalSection endp

;===========================================================================
;
; @func VOID PASCAL | LeaveCriticalSection | Leave a critical section
;
; @comm
;
; Leave the critical section. wCritSectID must be the critical section ID returned
; by the matching call to <f EnterCriticalSection> (used to verify nesting in debug
; versions).
;
; @parm LPWORD | lpwCritSect | The critical section to leave
;
align
LeaveCriticalSection proc far16 public,
        lpwCritSect:dword
                
        push    es
        push    di

        les     di, [lpwCritSect]       ; -> critical section
        inc     word ptr es:[di]        ; Reset to default value of 1

        pop     di
        pop     es
        ret

LeaveCriticalSection endp

;===========================================================================
;
; @func WORD PASCAL | DisableInterrupts | Disable interrupts
;
; @comm
;
; Disable interrupts and return the previous status for a call to
; <f RestoreInterrupts>
; 
; @rdesc
;
; Returns the previous state of the interrupt flag
;
;
DisableInterrupts proc far16 public
        
        pushf
        pop     ax                      ; Get state
        and     ax, 0200h               ; Already disabled?
        jz      short @F                ; Don't do it again
        cli
@@:
        ret

DisableInterrupts endp

;===========================================================================
;
; @func VOID PASCAL | RestoreInterrupts | Restore the interrupt state
;
; @comm
;
; Restore interrupts if they were enabled when <f DisableInterrupts> was
; called.
;
; @parm WORD | wIntStat | The previous interrupt state as returned from a 
; call to <f DisableInterrupts> 
;
RestoreInterrupts proc far16 public,
        wIntStat : word
        
        mov     ax, [wIntStat]          ; Previous state
        test    ax, 0200h               ; Enabled before?
        jz      short @F                ; No, don't re-enable now
        sti
@@:
        ret

RestoreInterrupts endp

;===========================================================================
;
; @func WORD PASCAL | InterlockedIncrement | Increment the given word
; atomically and return the result.
;
; @comm
;
; Disable interrupts to guarantee increment-and-read as an atomic 
; operation.
;
; @parm LPWORD | lpw | The word to increment.
;
InterlockedIncrement proc far16 public,
        lpw : dword
        
        pushf
        pop     cx
        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        cli                             ; Yes, disable
@@:
        les     bx, [lpw]   
        inc     word ptr es:[bx]
        mov     ax, word ptr es:[bx]

        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        sti                             ; Yes, reenable
@@:
        ret

InterlockedIncrement endp

;===========================================================================
;
; @func WORD PASCAL | InterlockedDecrement | Decrement the given word
; atomically and return the result.
;
; @comm
;
; Disable interrupts to guarantee decrement-and-read as an atomic 
; operation.
;
; @parm LPWORD | lpw | The word to decrement.
;
InterlockedDecrement proc far16 public,
        lpw : dword
        
        pushf
        pop     cx
        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        cli                             ; Yes, disable
@@:
        les     bx, [lpw]   
        dec     word ptr es:[bx]
        mov     ax, word ptr es:[bx]

        test    cx, 0200h               ; Were interrupts enabled?
        jz      @F                      ; No
        sti                             ; Yes, reenable
@@:
        ret

InterlockedDecrement endp

;===========================================================================
;
; @func void PASCAL | QuadwordMul | Multiply using 64-bit precision
;
; @comm
;
; Multiply the two 32-bit numbers in <p m1> and <p m2> giving a 64-bit result
; in <p lpqwResult>.
;
; @rdesc 
; Returns m1 * m2
;
; @parm DWORD | m1 | First multiplicand
; @parm DWORD | m2 | Second multiplicand
; @parm LPQUADWORD | lpqwResult | 64-bit result
;
QuadwordMul proc far16 public,
        m1 : dword,
        m2 : dword,
        lpqwResult : dword

        mov     edx, [m1]
        mov     eax, [m2]
        mul     edx

        les     bx, [lpqwResult]
        mov     es:[bx.qwLow], eax
        mov     es:[bx.qwHigh], edx

        ret
QuadwordMul endp

;===========================================================================
;
; @func DWORD PASCAL | QuadwordDiv | Divide using 64-bit precision
;
; @comm
;
; Divide the 64-bit number in <p ull> by the 32-bit number in <p dwDivisor> and
; return the result. May throw a divide by zero exception.
;
; @rdesc 
; Returns ull / dwDivisor
;
; @parm QUADWORD | ull | The unsigned long dividend
; @parm DWORD | dwDivisor | The divisor
;
;
QuadwordDiv proc far16 public,
        qwDividend : QUADWORD,
        dwDivisor : dword

        mov     edx, [qwDividend.qwHigh]
        mov     eax, [qwDividend.qwLow]
        mov     ebx, [dwDivisor]
        
        div     ebx
        
        ; Result in eax, needs to be dx:ax for 16-bit code

        ror     eax, 16
        mov     dx, ax
        ror     eax, 16
        
        ret
QuadwordDiv endp

;===========================================================================
;
; @func DWORD PASCAL | QuadwordLT | Compare two quadwords for less than (unsigned)
;
; @rdesc 
; Returns TRUE if qwLValue < qwRValue
;
; @parm QUADWORD | qwLValue | The first operand of less-than
; @parm QUADWORD | qwRValue | The second operand of less-than
;
;
QuadwordLT proc far16 public,
		qwLValue : QUADWORD,
		qwRValue : QUADWORD

		mov		ebx, [qwLValue.qwHigh]
		sub		ebx, [qwRValue.qwHigh]
		jz 		short @F
		sbb		eax, eax
		ret
		
@@:		mov		ebx, [qwLValue.qwLow]
		sub		ebx, [qwRValue.qwLow]
		sbb		eax, eax
		ret			
QuadwordLT endp
         
;===========================================================================
;
; @func DWORD PASCAL | QuadwordAdd | Add two unsigned quadwords
;
; @parm QUADWORD | qwOp1 | The first operand 
; @parm QUADWORD | qwOp2 | The second operand
; @parm LPQUADWORD | lpwqResult | The result
;
;
QuadwordAdd proc far16 public,
		qwOp1 : QUADWORD,
		qwOp2 : QUADWORD,
		lpdwResult : DWORD

		mov		eax, [qwOp1.qwLow]
		add		eax, [qwOp2.qwLow]
		mov		edx, [qwOp1.qwHigh]
		adc		edx, [qwOp2.qwHigh]
		les		bx, [lpdwResult]
		mov		es:[bx.qwLow], eax
		mov		es:[bx.qwHigh], edx

		ret			
QuadwordAdd endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\dmusic16.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic
 *
 * @Module DMusic16.c - Startup code |
 *
 * 16-bit Dll for DirectMusic sequencing on legacy devices (Win95/Win98 non-WDM drivers)
 *
 * This Dll is the 16-bit thunk peer for DMusic32.Dll
 *
 * @globalv HINSTANCE | ghInst | The instance handle for the DLL.
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

HINSTANCE ghInst;
HDRVR ghDrvr;
UINT guReferenceCount = 0;

/* @func LibMain system entry point
 *
 * @comm
 *
 * This entry point is called when the DLL is first loaded (NOT every time).
 *
 * Saves the global instance handle and initializes all the other modules.
 *
 */
int PASCAL
LibMain(
    HINSTANCE   hInst,              /* @parm Instance handle for the DLL */
    WORD        cbHeap,             /* @parm Initial size of the local heap */
    LPSTR       lpszCmdLine)        /* @parm Command-line parameters */
{
    UINT        uLev;
    char        szFilename[260];

    if (GetModuleFileName(hInst, szFilename, sizeof(szFilename)))
    {
        DPF(2, "%s", (LPSTR)szFilename);
    }

    ghDrvr = OpenDriver(szFilename, NULL, 0L);
               
    DPF(1, "DMusic16.DLL task %04X hdrvr %04X", GetCurrentTask(), (WORD)ghDrvr);


    ghInst = hInst;
    uLev = DbgInitialize(TRUE);
    DPF(0, "DMusic16: Debug level is %u", uLev);

    if (uLev > 2)
    {
        DPF(0, "DMusic16: Break in LibMain");
        DebugBreak();
    }
    
    DeviceOnLoad();
    AllocOnLoad();
    MidiOutOnLoad();

#if 0
    // This causes problems at terminate time. Find out later if we really need it.
    //
    if (!CreateTimerTask())
    {
        DPF(0, "CreateTimerTask() failed");
    }


    if (NULL == (LoadLibrary("dmusic16")))
    {
        DPF(0, "Could not LoadLibrary ourselves!");
    }
#endif

    return 1;
}

/* @func LibExit system call
 *
 * @comm
 *
 * This entry point is called just before the DLL is unloaded.
 *
 * Uninitialize all the other modules
 */

VOID PASCAL __loadds
LibExit(VOID)
{
    DPF(2, "LibExit start");
#if 0
    DestroyTimerTask();
#endif
    MidiOutOnExit();
    AllocOnExit();
    DPF(2, "LibExit end, going away now.");
}

extern BOOL FAR PASCAL dmthunk_ThunkConnect16(LPCSTR, LPCSTR, HINSTANCE, DWORD);
STATIC char pszDll16[] = "DMUSIC16.DLL";
STATIC char pszDll32[] = "DMUSIC.DLL";

/* @func DLLEntryPoint system entry point
 *
 * @comm
 *
 * This entry point is called each time the DLL is loaded or unloaded
 *
 * It is used here to initialize the peer connection for the thunk layer.
 */
#define PROCESS_DETACH          0
#define PROCESS_ATTACH          1

BOOL WINAPI
DllEntryPoint(
    DWORD       dwReason,           /* @parm Is the DLL being loaded or unloaded? */
    HINSTANCE   hi,                 /* @parm The instance handle */
    HGLOBAL     hgDS,               /* @parm The global handle of the DLL's (shared) DS */
    WORD        wHeapSize,          /* @parm The initial size of the local heap */
    LPCSTR      lszCmdLine,         /* @parm The command line (always NULL) */
    WORD        wCmdLine)           /* @parm Unused */
{
    // DllEntryPoint is called before LibEntry in a 4.x dll, so we have to LocalInit here if we're
    // going to use LocalAlloc
    //
    if (guReferenceCount == 0 && wHeapSize)
    {
        LocalInit(0, 0, wHeapSize);
    }

    switch(dwReason)
    {
        case PROCESS_ATTACH:
            DPF(2, "ProcessAttach task %04X", GetCurrentTask());
            ++guReferenceCount;
            dmthunk_ThunkConnect16(pszDll16, pszDll32, ghInst, 1);
            break;

        case PROCESS_DETACH:
            DPF(2, "ProcessDetach task %04X", GetCurrentTask());

            /* Clean up after them if they didn't close handles. We must do this here as well as
             * in DriverProc because on the last exit, we will go away before the DriverProc cleanup
             * gets called if the process termination is normal.
             */
            CloseDevicesForTask(GetCurrentTask());
            
            /* NOTE: We close on reference count of 1 since the initial OpenDriver call
               causes one more PROCESS_ATTACH to happen. */
            if (1 == --guReferenceCount)
            {
                CloseDriver(ghDrvr, 0, 0);
            }
            
            break;
    }

    return TRUE;
}

        
/* @func DriverProc entry point for ourselves as a loadable driver.
 *
 * @comm This entry points allows us to know when a task has gone away and therefore to clean
 * up after it even though we don't properly get notified that our thunk peer has gone away.
 */
LRESULT WINAPI DriverProc(
    DWORD               dwID,
    HDRVR               hdrvr,
    UINT                umsg,
    LPARAM              lParam1,
    LPARAM              lParam2)
{
    //
    //  NOTE DS is not valid here.
    //
    switch (umsg) 
    {
        case DRV_LOAD:
            return(1L);

        case DRV_FREE:
            return(0L);

        case DRV_OPEN:
        case DRV_CLOSE:
            return(1L);

        case DRV_EXITAPPLICATION:
            DPF(2, "Cleaning up handles for task %04X", GetCurrentTask());
            CloseDevicesForTask(GetCurrentTask());
            break;

        default:
            return(DefDriverProc(dwID, hdrvr, umsg, lParam1, lParam2));
    }
} //** DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\list.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @DOC DMusic16
 *
 * @MODULE List.c - Generic list management |
 */

#include <windows.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

#ifdef DEBUG
STATIC BOOL PASCAL IsNodeInList(NPLINKNODE pHead, NPLINKNODE pNode);
#endif

/* @func Insert a node into a linked list.
 *
 */
VOID PASCAL
ListInsert(
    NPLINKNODE *pHead,      /* @parm A pointer to the list head */
    NPLINKNODE pNode)       /* @parm A pointer to the node to insert */
{
    assert(!IsNodeInList(*pHead, pNode));
    
    if (*pHead)
    {
        (*pHead)->pPrev = pNode;
    }

    pNode->pNext = *pHead;
    pNode->pPrev = NULL;
    *pHead = pNode;
}

/* @func Remove a node into a linked list.
 *
 * @comm
 *
 * The node must exist in the list. The debug version which check for this.
 */
VOID PASCAL
ListRemove(
    NPLINKNODE *pHead,      /* @parm A pointer to the list head */
    NPLINKNODE pNode)       /* @parm A pointer to the node to delete */
{
    assert(IsNodeInList(*pHead, pNode));

    if (pNode->pPrev)
    {
        pNode->pPrev->pNext = pNode->pNext;
    }
    else
    {
        *pHead = pNode->pNext;
    }

    if (pNode->pNext)
    {
        pNode->pNext->pPrev = pNode->pPrev;
    }
}


#ifdef DEBUG
/* @func Determine if a node is in a linked list.
 *
 */
STATIC BOOL PASCAL
IsNodeInList(
    NPLINKNODE pHead,       /* @parm A pointer to the first node in the list */
    NPLINKNODE pNode)       /* @parm A pointer to the node to look for in the list */
{
    for (; pHead; pHead = pHead->pNext)
    {
        if (pHead == pNode)
        {
            return TRUE;
        }
    }

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\locks.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @module locks.c - Manage page-locking the code which will be accessed via callbacks from MMSYSTEM |
 *
 */
#include <windows.h>
#include <mmsystem.h>
#include "dmusic16.h"
#include "debug.h"

#define SINTEXT     __segname("FIX_IN_TEXT")
#define SOUTTEXT    __segname("FIX_OUT_TEXT")
#define SCOMMTEXT   __segname("FIX_COMM_TEXT")
#define SDATA       __segname("_DATA")

static VOID PASCAL NEAR
ForcePresent(
    WORD wSegment)
{
    LPBYTE lpb = (LPBYTE)MAKELP(wSegment, 0);

    _asm 
    {
        les bx, [lpb]
        mov al, es:[bx]
    }
}


/* @func Page lock needed segments 
 *
 */
VOID PASCAL
LockCode(
    WORD wFlags)            /* @parm What to lock: Any combination of: */
                            /* @flag LOCK_F_INPUT  | To lock the MIDI input code segments */
                            /* @flag LOCK_F_OUTPUT | To lock the MIDI output code segments */
                            /* @flag LOCK_F_COMMON | To lock the common code segments */

{
    if (wFlags & LOCK_F_INPUT)
    {
        ForcePresent(SINTEXT);
        if (!GlobalSmartPageLock(SINTEXT))
        {
            DPF(0, "Could not lock input text");
        }
    }
    
    if (wFlags & LOCK_F_OUTPUT)
    {
        ForcePresent(SOUTTEXT);
        if (!GlobalSmartPageLock(SOUTTEXT))
        {
            DPF(0, "Could not lock output text");
        }
    }

    if (wFlags & LOCK_F_COMMON)
    {
        ForcePresent(SCOMMTEXT);
        if (!GlobalSmartPageLock(SCOMMTEXT))
        {
            DPF(0, "Could not lock common text");
        }

        ForcePresent(SDATA);
        if (!GlobalSmartPageLock(SDATA))
        {
            DPF(0, "Could not lock data segment");
        }
    }
}

/* @func Page unlock needed segments 
 *
 * @comm
 */
VOID PASCAL
UnlockCode(
    WORD wFlags)            /* @parm What to unlock: Any combination of: */
                            /* @flag LOCK_F_INPUT  | To unlock the MIDI input code segments */
                            /* @flag LOCK_F_OUTPUT | To unlock the MIDI output code segments */
                            /* @flag LOCK_F_COMMON | To unlock the common code segments */

{
    if (wFlags & LOCK_F_INPUT)
    {
        if (!GlobalSmartPageUnlock(SINTEXT))
        {
            DPF(0, "Could not unlock input text");
        }
    }
    
    if (wFlags & LOCK_F_OUTPUT)
    {
        if (!GlobalSmartPageUnlock(SOUTTEXT))
        {
            DPF(0, "Could not unlock output text");
        }
    }

    if (wFlags & LOCK_F_COMMON)
    {
        if (!GlobalSmartPageUnlock(SCOMMTEXT))
        {
            DPF(0, "Could not unlock common text");
        }

        if (!GlobalSmartPageUnlock(SDATA))
        {
            DPF(0, "Could not unlock data");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\midiin.c ===
/* Copyright (c) 1998-1999 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @Module MIDIIn.c - Legacy MIDI capture emulation for DirectMusic |
 */
#pragma warning(disable:4704)       /* Inline assembly */

#include <windows.h>
#include <mmsystem.h>
#include <stddef.h>

#include "dmusic16.h"
#include "debug.h"

#define IS_STATUS_BYTE(x)     ((x) & 0x80)
#define IS_CHANNEL_MSG(x)     (((x) & 0xF0) != 0xF0)
#define IS_SYSEX(x)           ((x) == 0xF0)

#define SYSEX_SIZE            4096  
                            /* (65535 - sizeof(MIDIHDR) - sizeof(EVENT) - sizeof(SEGHDR)) */
#define SYSEX_BUFFERS         8                     /* Keep 2 buffers outstanding */

static unsigned cbChanMsg[16] =
{
    0, 0, 0, 0, 0, 0, 0, 0, /* Running status */
    3, 3, 3, 3, 2, 2, 3, 0
};

static unsigned cbSysCommData[16] =
{
    1, 2, 3, 2, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1
};

VOID CALLBACK _loadds midiInProc(HMIDIIN hMidiIn, UINT wMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
STATIC BOOL NEAR PASCAL RecordShortEvent(NPOPENHANDLE poh, DWORD dwMessage, DWORD dwTime);
STATIC BOOL NEAR PASCAL RecordSysExEvent(NPOPENHANDLE poh, LPMIDIHDR lpmh, DWORD dwTime);
STATIC VOID NEAR PASCAL NotifyClientList(LPOPENHANDLE poh);
STATIC VOID NEAR PASCAL ThruClientList(LPOPENHANDLE poh, DWORD dwMessage);
STATIC VOID NEAR PASCAL RefillFreeEventList(NPOPENHANDLE poh);
STATIC VOID NEAR PASCAL MidiInFlushQueues(NPOPENHANDLE poh);

#pragma alloc_text(INIT_TEXT, MidiOutOnLoad)
#pragma alloc_text(FIX_IN_TEXT, midiInProc)
#pragma alloc_text(FIX_IN_TEXT, RecordShortEvent)
#pragma alloc_text(FIX_IN_TEXT, RecordSysExEvent)
#pragma alloc_text(FIX_IN_TEXT, NotifyClientList)
#pragma alloc_text(FIX_IN_TEXT, ThruClientList)

/* @func Called at DLL <f LibInit>
 *
 * @comm
 *
 * Currently does nothing.
 *
 */
VOID PASCAL
MidiInOnLoad(VOID)
{
}

/* @func Called at DLL <f LibExit>
 *
 * @comm
 *
 * Currently does nothing
 */
VOID PASCAL
MidiInOnExit()
{
}

/* @func Open a MIDI in device
 *
 * @rdesc Returns one of the following:
 * @flag MMSYSERR_NOERROR | on success
 * @flag MMSYSERR_NOMEM | on out of memory
 *
 * @comm
 *
 * Makes sure only one client is opening the device.
 *
 * Opens the device and starts MIDI input on it, noting the time of the start for timestamp calculations.
 */
MMRESULT PASCAL
MidiInOnOpen(
    NPOPENHANDLEINSTANCE pohi)      /* @parm The open handle instance to fulfill */
{
    NPOPENHANDLE poh = pohi->pHandle;

    int iChannel;    
    MMRESULT mmr;

    /* Protect here against more than one client opening an input device.
     */
    if (poh->uReferenceCount > 1) 
    {
        return MMSYSERR_ALLOCATED;
    }
    
    /* Per client initialize thruing to NULL. 
     */
    pohi->pThru = (NPTHRUCHANNEL)LocalAlloc(LPTR, MIDI_CHANNELS * sizeof(THRUCHANNEL));
    if (pohi->pThru == NULL)
    {
        return MMSYSERR_NOMEM;
    }

    DPF(2, "MidiInOnOpen: pohi %04X pThru %04X", pohi, pohi->pThru);

    for (iChannel = 0; iChannel < MIDI_CHANNELS; iChannel++)
    {
        pohi->pThru[iChannel].pohi = (HANDLE)NULL;
    }

    return MMSYSERR_NOERROR;
}

/* @func Close a MIDI in device
 *
 * @comm
 *
 * Close the device using the <f midiInClose> API.
 */
VOID PASCAL
MidiInOnClose(
    NPOPENHANDLEINSTANCE pohi)      /* @parm The open handle instance to close */
{
}

/* @func Activate a MIDI in device
 *
 * @rdesc Returns one of the following:
 * @flag MMSYSERR_NOERROR | on success
 * @flag MMSYSERR_ALLOCATED | if the device is already in use
 *
 * May also return any of the possible return codes from the <f midiInOpen> API call.
 *
 * @comm
 *
 * Opens the device and starts MIDI input on it, noting the time of the start for timestamp calculations.
 */
MMRESULT PASCAL
MidiInOnActivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;

    if (1 == poh->uActiveCount)
    {
        poh->wFlags &= ~OH_F_CLOSING;
        mmr = midiInOpen(&poh->hmi,
                         poh->id,
                         (DWORD)midiInProc,
                         (DWORD)(LPOPENHANDLE)poh,
                         CALLBACK_FUNCTION);
        if (mmr)
        {
            return mmr;
        }

        mmr = midiInStart(poh->hmi);
        poh->msStartTime = timeGetTime();
        if (mmr)
        {   
            midiInClose(poh->hmi);
        }

        /* NOTE: poh memory is guaranteed zeroed by allocator, so we have
         * no event count and NULL pointers right now.
         */
        RefillFreeEventList(poh);
    }

    return MMSYSERR_NOERROR;
}

/* @func Deactivate a MIDI in device
 *
 * @comm
 *
 * Close the device using the <f midiInClose> API.
 */
MMRESULT PASCAL
MidiInOnDeactivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;

    if (0 == poh->uActiveCount)
    {
        poh->wFlags |= OH_F_CLOSING;
        mmr = midiInStop(poh->hmi);
        if (mmr)
        {
            return mmr;
        }

        if (MMSYSERR_NOERROR == midiInReset(poh->hmi))
        {
            while (poh->wPostedSysExBuffers)
            {
            }
        }

        midiInClose(poh->hmi);
        MidiInFlushQueues(poh);
    }

    return MMSYSERR_NOERROR;
}


/* @func Set the event handle to signal
 *
 * @rdesc Always returns MMSYSERR_NOERROR.
 *
 * @comm
 *
 * This function is exported through the thunk layer to DMusic32.DLL
 *
 * This handle is already the VxD handle that can be passed to VWin32 via MMDEVLDR using
 * <f SetWin32Event>.
 *
 * Input notification is delivered to the Win32 application using events. The application creates
 * an event using the <f CreateEvent> API and gives it to the DirectMusic port. The port code
 * for legacy emulation calls the undocumented Win9x kernel API <f OpenVxDHandle> to retrieve
 * an equivalent event handle that is valid in any kernel context. That handle is passed to
 * this function.
 *
 * The event handle is stored in our per-client data (<c OPENHANDLEINSTANCE>). When MIDI data
 * arrives, the event will be set. This is done using MMDEVLDR, which already has semantics
 * in place to do the same sort of notification for WinMM event callbacks.
 *
 */
MMRESULT WINAPI
MidiInSetEventHandle(
    HANDLE hMidiIn,             /* @parm The handle of the input device which desires notification */
    DWORD dwEvent)              /* @parm The VxD handle of the event to set when new data arrives */
{
    NPOPENHANDLEINSTANCE pohi;
    
    if (!IsValidHandle(hMidiIn, VA_F_INPUT, &pohi))
    {
        return MMSYSERR_INVALHANDLE;
    }

    pohi->dwVxDEventHandle = dwEvent;

    return MMSYSERR_NOERROR;
}

/* @func Read MIDI input data into a buffer
 *
 * @rdesc Returns one of the following
 *
 * @comm
 *
 * This function is thunked to the 32-bit DLL
 *
 * Take as much data from the given event list as will fit and put it into the buffer.
 */
MMRESULT WINAPI
MidiInRead(
    HANDLE hMidiIn,         /* @parm The handle of the input device to read */
    LPBYTE lpBuffer,        /* @parm A pointer to memory to pack, in DMEVENT format */
    LPDWORD pcbData,        /* @parm On input, the max size of <p lpBuffer> in bytes.
                                     On return, will contain the number of bytes of data packed into the buffer */
    LPDWORD pmsTime)        /* @parm On return, will contain the starting time of the buffer */ 
{
    NPOPENHANDLEINSTANCE pohi;
    NPOPENHANDLE poh;
    WORD wCSID;
    LPEVENT pEvent;
    LPEVENT pEventRemoved;
    LPBYTE pbEventData;
    DWORD cbLength;
    DWORD cbPaddedLength;
    DWORD cbLeft;
    LPBYTE lpNextEvent;
    LPDMEVENT pdm;
    DWORD msFirst;
    MMRESULT mmr;
    LPMIDIHDR lpmh;
            
    if (!IsValidHandle(hMidiIn, VA_F_INPUT, &pohi))
    {
        return MMSYSERR_INVALHANDLE;
    }

    poh = pohi->pHandle;

    lpNextEvent = lpBuffer;
    cbLeft = *pcbData;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);
    msFirst = 0;

    while (NULL != (pEvent = QueuePeek(&poh->qDone)))
    {
        lpmh = NULL;

        if (cbLeft < sizeof(DMEVENT))
        {
            break;
        }

        if (pEvent->wFlags & EVENT_F_MIDIHDR)
        {
            /* This event is a SysEx message starting with a MIDIHDR, which contains
             * the recorded length of the message.
             */
            lpmh = (LPMIDIHDR)(&pEvent->abEvent[0]);

            cbLength = lpmh->dwBytesRecorded - lpmh->dwOffset;
            pbEventData = lpmh->lpData + lpmh->dwOffset;
            cbPaddedLength = DMEVENT_SIZE(cbLength);

            /* For SysEx, split out as much as will fit if the whole message can't.
             */
            if (cbPaddedLength > cbLeft)
            {
                cbLength = DMEVENT_DATASIZE(cbLeft);
                cbPaddedLength = DMEVENT_SIZE(cbLength);        
            }
        }
        else
        {
            /* The data for this event is directly contained in the event.
             */
            cbLength = pEvent->cbEvent;
            pbEventData = &pEvent->abEvent[0];
            cbPaddedLength = DMEVENT_SIZE(cbLength);

            if (cbPaddedLength > cbLeft)
            {
                break;
            }
        }

        assert(cbPaddedLength <= cbLeft);

        pdm = (LPDMEVENT)lpNextEvent;

        pdm->cbEvent = cbLength;
        pdm->dwChannelGroup = 1;
        pdm->dwFlags = 0;

        if (msFirst)
        {
            QuadwordMul( pEvent->msTime - msFirst,
                         REFTIME_TO_MS,
                         &pdm->rtDelta);
        }
        else
        {
            *pmsTime = pEvent->msTime;
            msFirst = pEvent->msTime;

            pdm->rtDelta.dwLow  = 0;
            pdm->rtDelta.dwHigh = 0;
        }
        
        hmemcpy(pdm->abEvent, pbEventData, cbLength);

        lpNextEvent += cbPaddedLength;
        cbLeft -= cbPaddedLength;

        if (lpmh)
        {
            lpmh->dwOffset += cbLength;
            assert(lpmh->dwOffset <= lpmh->dwBytesRecorded);

            if (lpmh->dwOffset == lpmh->dwBytesRecorded)
            {
                pEventRemoved = QueueRemoveFromFront(&poh->qDone);
                assert(pEventRemoved == pEvent);

                InterlockedIncrement(&poh->wPostedSysExBuffers);

                lpmh->dwOffset = 0;
                mmr = midiInAddBuffer(poh->hmi, (LPMIDIHDR)(&pEvent->abEvent[0]), sizeof(MIDIHDR));
                if (mmr)
                {
                    InterlockedDecrement(&poh->wPostedSysExBuffers);
                    DPF(0, "midiInAddBuffer failed with mmr=%d", mmr);
                    mmr = midiInUnprepareHeader(poh->hmi, (LPMIDIHDR)(&pEvent->abEvent[0]), sizeof(MIDIHDR));
                    if (mmr)
                    {
                        DPF(0, "...midiInUnprepareHeader failed too %d, memory leak!", mmr);
                    }
                    else
                    {
                        FreeEvent(pEvent);
                    }
                }
            }
        }
        else
        {
            pEventRemoved = QueueRemoveFromFront(&poh->qDone);
            assert(pEventRemoved == pEvent);

            QueueAppend(&poh->qFree, pEvent);
        }
    }

    *pcbData = lpNextEvent - lpBuffer;

    DPF(1, "MidiInRead: Returning %ld bytes", (DWORD)*pcbData);

    LeaveCriticalSection(&poh->wCritSect);
    return MMSYSERR_NOERROR;
}

/* @func Enable thruing to a MIDI output port
 *
 * @comm For the given channel group and channel, enable (or disable, if the
 * output handle is NULL) thruing to the given output handle, channel group, and
 * channel.
 */
MMRESULT WINAPI
MidiInThru(
    HANDLE hMidiIn,             /* @parm The handle of the input device to thru */
    DWORD dwFrom,               /* @parm The channel of the input stream to thru */
    DWORD dwTo,                 /* @parm Desination channel */
    HANDLE hMidiOut)            /* The output handle to receive the thru'ed data. */
{
    NPOPENHANDLEINSTANCE pohiInput;
    NPOPENHANDLEINSTANCE pohiOutput;
    
    if (!IsValidHandle(hMidiIn, VA_F_INPUT, &pohiInput) ||
        ((hMidiOut != NULL) && !IsValidHandle(hMidiOut, VA_F_OUTPUT, &pohiOutput)))
    {
        return MMSYSERR_INVALHANDLE;
    }    

    /* Note that since only 1 channel group is supported on legacy drivers, 
     * we don't need any channel group information.
     */
    if (dwFrom > 15 || dwTo > 15) 
    {
        return MMSYSERR_INVALPARAM;
    }

    DPF(1, "Thru: Sending <%04X,%u> to <%04X,%u>", 
        (WORD)hMidiIn, (UINT)dwFrom, (WORD)hMidiOut, (UINT)dwTo);
        
    pohiInput->pThru[(WORD)dwFrom].wChannel = (WORD)dwTo;
    pohiInput->pThru[(WORD)dwFrom].pohi = hMidiOut ? pohiOutput : NULL;    

    return MMSYSERR_NOERROR;
}

/* @func MIDI in data callback
 *
 * @comm
 *
 * This is a standard MIDI input callback from MMSYSYTEM. It calls the correct record routine
 * and notifies the client that data has arrived.
 *
 * For a description of event notification of clients, see <f MidiInSetEventHandle>.
 */
VOID CALLBACK _loadds
midiInProc(
    HMIDIIN hMidiIn,            /* @parm The MMSYSTEM handle of the device which received data */
    UINT wMsg,                  /* @parm The type of callback */
    DWORD dwInstance,           /* @parm Instance data; in our case, a pointer to an <c OPENHANDLE> matching <p hMidiIn> */
    DWORD dwParam1,             /* @parm Message-specific parameters */
    DWORD dwParam2)             /* @parm Message-specific parameters */
{
    NPOPENHANDLE poh = (NPOPENHANDLE)(WORD)dwInstance;
    BOOL bIsNewData = FALSE;
    
    WORD wCSID;


    /* If we can get the critical section we can do all sorts of fun stuff like
     * transfer the lists over.
     */
    wCSID = EnterCriticalSection(&poh->wCritSect, CS_NONBLOCKING);
    if (wCSID)
    {
        /* We now have exclusive access to all the queues.
         *
         * Move any new free events into our internal free list.
         */
        QueueCat(&poh->qFreeCB, &poh->qFree);
    }

    switch(wMsg)
    {
        case MIM_DATA:
            DPF(1, "MIM_DATA %08lX %08lX", dwParam1, dwParam2);
            bIsNewData = RecordShortEvent(poh, dwParam1, dwParam2);
            break;

        case MIM_LONGDATA:
            DPF(1, "MIM_LONGDATA %08lX %08lX", dwParam1, dwParam2);
            bIsNewData = RecordSysExEvent(poh, (LPMIDIHDR)dwParam1, dwParam2);
            break;

        default:
            break;
    }

    if (wCSID)
    {
        /* It's safe to move events over to the shared list.
         */
        QueueCat(&poh->qDone, &poh->qDoneCB);
        LeaveCriticalSection(&poh->wCritSect);
    }

    /* Let clients know there is new data
     */
    if (bIsNewData && (!(poh->wFlags & OH_F_CLOSING)))
    {
        NotifyClientList(poh);
    }
}

/* @func Record a short message (channel messsage or system message).
 *
 * @comm
 *
 * Queue the incoming data as quickly as possible.
 *
 * For a description of the queues used for incoming data, see the <c OPENHANDLE> struct.
 *
 * @rdesc
 * Returns TRUE if the data was successfully recorded; FALSE otherwise.
 */
STATIC BOOL NEAR PASCAL 
RecordShortEvent(
    NPOPENHANDLE poh,           /* @parm The handle to record this data to */
    DWORD dwMessage,            /* @parm The short message to record */
    DWORD dwTime)               /* @parm The time stamp of the message */
{
    LPEVENT pEvent;
    LPBYTE pb;
    BYTE b;

    pEvent = QueueRemoveFromFront(&poh->qFreeCB);
    if (pEvent == NULL)
    {
        DPF(0, "midiInProc: Missed a short event!!!");
        return FALSE;
    }
        
    pEvent->msTime = poh->msStartTime + dwTime;
    pEvent->wFlags = 0;

    /* Now we have to parse and rebuild the channel message.
     *
     * NOTE: Endian specific code ahead
     */
    pb = (LPBYTE)&dwMessage;

    assert(!IS_SYSEX(*pb));         /* This should *always* be in MIM_LONGDATA */
    assert(IS_STATUS_BYTE(*pb));    /* API guarantees no running status */

    /* Copying over all the bytes is harmless (we have a DWORD in both
     * source and dest) and is faster than checking to see if we have to.
     */
    b = pEvent->abEvent[0] = *pb++;
    pEvent->abEvent[1] = *pb++;
    pEvent->abEvent[2] = *pb++;

    if (IS_CHANNEL_MSG(b))
    {
        /* 8x, 9x, Ax, Bx, Cx, Dx, Ex */
        /* 0x..7x invalid, that would need running status */
        /* Fx handled below */
        
        pEvent->cbEvent = cbChanMsg[(b >> 4) & 0x0F];

        /* This is also our criteria for thruing
         */
        ThruClientList(poh, dwMessage);
    }
    else
    {
        /* F1..FF */
        /* F0 is sysex, should never see it here */
        pEvent->cbEvent = cbSysCommData[b & 0x0F];
    }

    /* Now we have something to save
     */
    QueueAppend(&poh->qDoneCB, pEvent);

    return TRUE;
}

/* @func Record a SysEx message.
 *
 * @comm
 *
 * Queue the incoming data as quickly as possible.
 *
 * For a description of the queues used for incoming data, see the <c OPENHANDLE> struct.
 *
 * @rdesc
 * Returns TRUE if the data was successfully recorded; FALSE otherwise.
 */
STATIC BOOL NEAR PASCAL 
RecordSysExEvent(
    NPOPENHANDLE poh,           /* @parm The handle to record this data to */
    LPMIDIHDR lpmh,             /* @parm The SysEx message to record */
    DWORD dwTime)               /* @parm The time stamp of the message */
{
    LPEVENT pEvent;
    
    /* Get back the event header for this MIDIHDR. While buffers are in MMSYSTEM, they are not 
     * in any queue.
     */
    InterlockedDecrement(&poh->wPostedSysExBuffers);

    /* dwOffset in the MIDIHDR is used to indicate the start of data to send
     * up to Win32. It is incremented by MidiInRead until the buffer has been
     * emptied, at which time it will be put back into the pool.
     */
    lpmh->dwOffset = 0;

    pEvent = (LPEVENT)(lpmh->dwUser);
    pEvent->msTime = poh->msStartTime + dwTime;
    QueueAppend(&poh->qDoneCB, pEvent);
    
    return TRUE;
}

/* @func Notify all clients of a device that data has arrived.
 *
 * @comm
 *
 * Walks the list of clients for the device and sets the notification event for each one.
 *
 * This function is now overkill since we no longer support multiple input clients per device.
 */
STATIC VOID NEAR PASCAL
NotifyClientList(
    LPOPENHANDLE poh)           /* @parm The handle of the device that has received data */
{
    NPLINKNODE plink;
    NPOPENHANDLEINSTANCE pohi;

    for (plink = poh->pInstanceList; plink; plink = plink->pNext)
    {
        pohi = (NPOPENHANDLEINSTANCE)(((PBYTE)plink) - offsetof(OPENHANDLEINSTANCE, linkHandleList));

        if (!pohi->dwVxDEventHandle)
        {
            /* No notification event registered for this handle yet.
             */
            continue;
        }

        SetWin32Event(pohi->dwVxDEventHandle);
    }
}

/* @func Thru this message based on the settings of all clients of a device.
 *
 * @comm
 *
 * Walks the list of clients for the device and looks at the thru settings of each one.
 *
 * This function is now overkill since we no longer support multiple input clients per device.
 */
STATIC VOID NEAR PASCAL 
ThruClientList(
    LPOPENHANDLE poh, 
    DWORD dwMessage)
{
    NPLINKNODE plink;
    NPOPENHANDLEINSTANCE pohi;
    NPOPENHANDLEINSTANCE pohiDest;
    int iChannel;

    iChannel = (int)(dwMessage & 0x0000000Fl);
    dwMessage &= 0xFFFFFFF0l;

    for (plink = poh->pInstanceList; plink; plink = plink->pNext)
    {
        pohi = (NPOPENHANDLEINSTANCE)(((PBYTE)plink) - offsetof(OPENHANDLEINSTANCE, linkHandleList));

        pohiDest = pohi->pThru[iChannel].pohi;
        if (pohiDest == NULL || !pohiDest->fActive)
        {
            continue;
        }

        MidiOutThru(pohiDest,
                    dwMessage & 0xFFFFFFF0l | pohi->pThru[iChannel].wChannel);
    }
}

/* @func Refill the free lists
 *
 * @comm
 *
 * This function is called periodically from user mode to ensure that there are enough free
 * events available for the input callback. 
 */
VOID PASCAL
MidiInRefillFreeLists(VOID)
{
    NPLINKNODE plink;
    NPOPENHANDLE poh;
    
    for (plink = gOpenHandleList;
         (poh = (NPOPENHANDLE)plink) != NULL;
         plink = plink->pNext)
    {
        /* Only refill MIDI in devices which are not in the process of closing
         */
        if ((poh->wFlags & (OH_F_MIDIIN | OH_F_CLOSING)) != OH_F_MIDIIN)
        {
            continue;
        }

        RefillFreeEventList(poh);
    }
}
                 
/* @func Terminate thruing to this output handle
 *
 * @comm
 *
 * This function is called before the given output handle is closed.
 */
VOID PASCAL 
MidiInUnthruToInstance(
    NPOPENHANDLEINSTANCE pohiClosing)   /* @parm NPOPENHANDLE | pohClosing | 
                                           The handle which is closing. */
{
    NPLINKNODE plink;
    NPOPENHANDLE poh;
    NPLINKNODE plinkInstance;
    NPOPENHANDLEINSTANCE pohiInstance;
    int iChannel;

    for (plink = gOpenHandleList; (poh = (NPOPENHANDLE)plink) != NULL; plink = plink->pNext)
    {
        DPF(2, "Unthru: poh <%04X>", (WORD)poh);

        if (!(poh->wFlags & OH_F_MIDIIN)) 
        {
            DPF(2, "...not input");
            continue;
        }

        for (plinkInstance = poh->pInstanceList; plinkInstance; plinkInstance = plinkInstance->pNext)
        {
            pohiInstance = (NPOPENHANDLEINSTANCE)(((PBYTE)plinkInstance) - offsetof(OPENHANDLEINSTANCE, linkHandleList));

            DPF(2, "pohiInstance <%04X>", (WORD)pohiInstance);
            
            for (iChannel = 0; iChannel < MIDI_CHANNELS; iChannel++)
            {
                DPF(2, "Channel 0 @ <%04X>", (WORD)&pohiInstance->pThru[iChannel]);
                if (pohiInstance->pThru[iChannel].pohi == pohiClosing)
                {
                    DPF(1, "Thru: Closing output handle %04X which is in use!", (WORD)pohiClosing);
                    pohiInstance->pThru[iChannel].pohi = NULL;
                }
            }
        }
    }        
}

/* @func Allocate enough free events to refill the pool to CAP_HIGHWATERMARK
 *
 * @comm
 *
 * BUGBUG call this on a window timer callback
 *
 */
STATIC VOID NEAR PASCAL
RefillFreeEventList(
    NPOPENHANDLE poh)           /* @parm The device to refill the free list of */
{
    int idx;
    LPEVENT pEvent;
    UINT cFree;
    WORD wCSID;
    QUADWORD rt = {0, 0};
    int cNewBuffers;
    LPMIDIHDR lpmh;
    MMRESULT mmr;
    WORD wIntStat;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);
    
    /* NOTE: Technically not allowed to access qFreeCB here, but this is an approximation
     */
    cFree = poh->qFree.cEle + poh->qFreeCB.cEle;
    if (cFree < CAP_HIGHWATERMARK)
    {
        DPF(1, "RefillFreeEventList poh %.4x free %u highwater %u",
            (WORD)poh,
            (UINT)cFree,
            (UINT)CAP_HIGHWATERMARK);
        
        for (idx = CAP_HIGHWATERMARK - cFree; idx; --idx)
        {
            pEvent = AllocEvent(0, rt, sizeof(DWORD));
            if (NULL == pEvent)
            {
                DPF(0, "AllocEvent returned NULL in RefillFreeEventList");
                break;
            }

            QueueAppend(&poh->qFree, pEvent);
        }
    }

    LeaveCriticalSection(&poh->wCritSect);

    if (poh->wPostedSysExBuffers < SYSEX_BUFFERS)
    {
        for (idx = SYSEX_BUFFERS - cFree; idx; --idx)
        {
            pEvent = AllocEvent(0, rt, sizeof(MIDIHDR) + SYSEX_SIZE);
            if (NULL == pEvent)
            {
                break;
            }

            pEvent->wFlags |= EVENT_F_MIDIHDR;

            lpmh = (LPMIDIHDR)(&pEvent->abEvent[0]);
            lpmh->lpData = (LPSTR)(lpmh + 1);
            lpmh->dwBufferLength = SYSEX_SIZE;
            lpmh->dwUser = (DWORD)pEvent;

            mmr = midiInPrepareHeader(poh->hmi, lpmh, sizeof(MIDIHDR));
            if (mmr)
            {   
                DPF(0, "midiInPrepareHeader: %u\n", mmr);
                FreeEvent(pEvent);
                break;
            }

            InterlockedIncrement(&poh->wPostedSysExBuffers);
            mmr = midiInAddBuffer(poh->hmi, lpmh, sizeof(MIDIHDR));
            if (mmr)
            {
                InterlockedDecrement(&poh->wPostedSysExBuffers);

                DPF(0, "midiInAddBuffer: %u\n", mmr);
                midiInUnprepareHeader(poh->hmi, lpmh, sizeof(MIDIHDR));
                FreeEvent(pEvent);
                break;
            }
        }
    }
}

/* @func Return all memory from all queues to the free event list.
 *
 * @comm
 *
 */
STATIC VOID NEAR PASCAL 
MidiInFlushQueues(
    NPOPENHANDLE poh)
{
    WORD wCSID;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    FreeAllQueueEvents(&poh->qDone);
    FreeAllQueueEvents(&poh->qDoneCB);
    FreeAllQueueEvents(&poh->qFree);
    FreeAllQueueEvents(&poh->qFreeCB);

    LeaveCriticalSection(&poh->wCritSect);
}

/* @func Free all events in the given event queue.
 *
 * @comm
 *
 * Assumes that the queue's critical section has already been taken by the caller.
 *
 */
VOID PASCAL
FreeAllQueueEvents(
    NPEVENTQUEUE peq)
{
    LPEVENT lpCurr;
    LPEVENT lpNext;
    
    lpCurr = peq->pHead;
    while (lpCurr)
    {
        lpNext = lpCurr->lpNext;
        FreeEvent(lpCurr);
        lpCurr = lpNext;
    }

    peq->pHead = peq->pTail = NULL;
    peq->cEle = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\locks.h ===
// Copyright (c) 1998 Microsoft Corporation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\mm.inc ===
;***
;mm.inc - macros to write memory model dependent code
;
;	Copyright (c) 1987-1998 Microsoft Corporation
;
;Purpose:
;	This file contains definitions of a number of macros which
;	make the writing of memory model dependent code for the
;	8086 a little easier and more portable.
;
;*******************************************************************************

; the macro below is used by the assigning long arithmetic routines (almul,
; etc) to handle the model dependent data addressing - in small and middle
; models data addresses default to short (2 byte) addresses. in large model,
; data address are long (4 bytes).

LOAD	macro	to,from
if	sizeD
	lds	to,from
else
	mov	to,from
endif
	endm


; general code & data size constants & macros

if	sizeD			; 4 byte data addresses
DAT_ADDR_SZ =	4
BDAT_ADDR_SZ =	2
else				; 2 byte data addresses
DAT_ADDR_SZ =	2
BDAT_ADDR_SZ =	4
endif

if	sizeC			; 4 byte code addresses
TXT_ADDR_SZ =	4
else				; 2 byte code addresses
TXT_ADDR_SZ =	2
endif


; Big/Little Endian Definitions for Long Integers

LOWORD	equ	[0]
HIWORD	equ	[2]


; All Model Definitions

BPARGBAS equ	TXT_ADDR_SZ+2	; offset from BP to first argument


; macro for windows fixup with retf #

return	macro	n
	org	$-1
if	sizeC
	db	0cah
else
	db	0c2h
endif
	dw	n
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\mmdevldr.inc ===
;******************************************************************************
TITLE mmdevldr.inc - Windows/386 MMSYSTEM Device loader DLVxD include file
;******************************************************************************
;
;   (C) Copyright (c) 1993-1998 Microsoft Corporation
;
;   Title:  mmdevldr.INC - Windows/386 Config Manager DLVxD DEVLOADER for MMSYSTEM
;
;   Version:    1.00
;
;
;==============================================================================
Multimedia_OEM_ID           equ 0440h            ; MS Reserved OEM # 34
MMDEVLDR_Device_ID           equ Multimedia_OEM_ID + 10 ;MMDEVLDR's device ID

MMDEVLDR_Ver_Major           equ 1                ; version 1.0 of this VxD
MMDEVLDR_Ver_Minor           equ 0

MMDEVLDR_API_MMSystem_Up        equ 0			;Internal
MMDEVLDR_API_Continue		equ 1			;Internal
MMDEVLDR_API_QueryVxD           equ 2                   ;Internal
MMDEVLDR_API_QueueCallback32    equ 3                   ;Internal
MMDEVLDR_API_SetEvent           equ 4                   ;Internal
MMDEVLDR_API_PageAllocate       equ 5                   ;Internal
MMDEVLDR_API_PageFree           equ 6                   ;Internal
MMDEVLDR_APIS                   equ 7                   ;Internal

ifdef DDB_Sys_Crit_Init_Done
 
Begin_Service_Table	MMDEVLDR
	MMDEVLDR_Service	MMDEVLDR_Register_Device_Driver, LOCAL
	MMDEVLDR_Service	_MMDEVLDR_SetDevicePresence
        MMDEVLDR_Service        _MMDEVLDR_SetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_GetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_RemoveEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_AddEnvironmentString
End_Service_Table MMDEVLDR	

MMDEVLDR_IOCTL_GETVERSION       equ     0		;Internal
MMDEVLDR_IOCTL_LINPAGELOCK      equ     1		;Internal
MMDEVLDR_IOCTL_LINPAGEUNLOCK    equ     2		;Internal
MMDEVLDR_IOCTL_RING0THREADHANDLE equ    3		;Internal
MMDEVLDR_IOCTL_QUEUEAPC         equ     4		;Internal
MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR equ   5		;Internal
MMDEVLDR_IOCTL_CLOSEVXDHANDLE   equ     6		;Internal
MMDEVLDR_IOCTL_PAGEALLOCATE     equ     7		;Internal
MMDEVLDR_IOCTL_PAGEFREE         equ     8		;Internal
MMDEVLDR_IOCTL_GETDEVICESTATUS  equ     9		;Internal
							;Internal
MM_DEVSTATUS_ERROR          equ 0			;Internal
MM_DEVSTATUS_STARTED        equ 1			;Internal
MM_DEVSTATUS_UNKNOWNPROB    equ 2			;Internal
MM_DEVSTATUS_DISABLED       equ 3			;Internal
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\mmdevldr.asm ===
; Copyright (c) 1998 Microsoft Corporation

;;MMDEVLDR.ASM

        page    ,132
;-----------------------------Module-Header-----------------------------;
;
; @Doc DMusic16
;
; @Module MMDevLdr.asm - Interface routines for MMDevLdr |
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE   = 1

        .xlist
        include cmacros.inc
        include windows.inc
        include mmdevldr.inc
        include mmsystem.inc
        .list

externFP        AllocCStoDSAlias        ;(UINT sel);
externFP        FreeSelector            ;(UINT sel);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   equates
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OFFSEL struc
        off     dw  ?
        sel     dw  ?
OFFSEL ends

GetDeviceAPI            EQU     1684h                   ; int 2Fh query

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   segmentation
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;createSeg %SEGNAME, CodeSeg, word, public, CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Remember, we are still 16bit.

    .model medium
        .386

;sBegin CodeSeg
         .code

;        assumes cs, _text

        MMDEVLDR_Entry  dd      ?       ; the api entry point for mmdevldr


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; @func BOOL CDECL | SetWin32Event | Set a Win32 event from any context
;
; @comm
; 
; Given the VxD handle to an event, set the event. This function calls the MMDevLdr
; VxD API entry, which in turn calls the VWin32 function to perform the set.
;
; @rdesc
; Returns TRUE on success, or FALSE if MMDevLdr could not be found.
;
; @parm DWORD | dwRing0Event | The VxD handle of the event as returned
; from the <f OpenVxDHandle> kernel API.
;
;

cProc _SetWin32Event <FAR, CDECL, PUBLIC> <>
        ParmD  dwRing0Evt
cBegin nogen
        mov    dx, MMDEVLDR_API_SetEvent
        jmp    short MMDEVLDR_Call
cEnd nogen

;
;
;
cProc MMDEVLDR_Call <FAR, CDECL> <>
cBegin nogen
        mov     ecx, [MMDEVLDR_Entry]
        jecxz   short mmdevldr_load
        jmp     [MMDEVLDR_Entry]
mmdevldr_load:
        push    dx                      ; save MMDEVLDR command ID
        push    di
        push    si
        cCall   AllocCStoDSAlias, <cs>
        mov     si, ax
        xor     di, di                  ; zero ES:DI before call
        mov     es, di
        mov     ax, GetDeviceAPI        ; get device API entry point
        mov     bx, MMDEVLDR_Device_ID  ; virtual device ID
        int     2Fh                     ; call WIN/386 INT 2F API
        mov     ax, es
        mov     es, si
;        assumes es, CodeSeg
        mov     es:MMDEVLDR_Entry.off, di
        mov     es:MMDEVLDR_Entry.sel, ax
        assumes es, nothing
        push    ax
        cCall   FreeSelector, <si>
        pop     ax
        or      ax, di
        pop     si
        pop     di
        pop     dx
        jz      short mmdevldr_fail
        jmp     [MMDEVLDR_Entry]
mmdevldr_fail:
        mov     ax, MMSYSERR_NODRIVER;
        retf
cEnd nogen


;sEnd CodeSeg

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\midiout.c ===
/* Copyright (c) 1998 Microsoft Corporation */
/*
 * @Doc DMusic16
 *
 * @Module MIDIOut.c - Legacy MIDI output emulation for DirectMusic |
 *
 * @comm
 *
 * BUGBUG Need to deal with timer wraparound
 *
 */
#pragma warning(disable:4704)       /* Inline assembly */

#include <windows.h>
#include <mmsystem.h>

#include "dmusic16.h"
#include "debug.h"

#define MIDI_CHANMSG_STATUS_CMD_MASK    (0xF0)
#define MIDI_NOTE_ON                    (0x90)

/* How far past the current time do we send events?
 */
#define MS_TIMER_SLOP           (3)

STATIC TIMECAPS gTimeCaps;
STATIC BOOL gbTimerRunning;
STATIC DWORD gdwTimerDue;
STATIC UINT guTimerID;
STATIC UINT gcActiveOutputDevices;

int PASCAL IsEventDone(LPEVENT pEvent, DWORD dwInstance);
VOID SetNextTimer();
VOID CALLBACK __loadds midiOutProc(HMIDIOUT hMidiIn, UINT wMsg, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
VOID CALLBACK __loadds RunTimer(UINT uTimerID, UINT wMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
STATIC VOID NEAR PASCAL MidiOutFlushQueues(NPOPENHANDLE poh);
STATIC VOID NEAR PASCAL MidiOutSendAllNow(NPOPENHANDLE poh);

#pragma alloc_text(INIT_TEXT, MidiOutOnLoad)
#pragma alloc_text(FIX_OUT_TEXT, midiOutProc)
#pragma alloc_text(FIX_OUT_TEXT, RunTimer)

/* @func Called at DLL <f LibInit>
 *
 * @comm
 *
 * Get the timer caps.
 * Initialize globals.
 */
VOID PASCAL
MidiOutOnLoad()
{
    /* This cannot fail
     */
    timeGetDevCaps(&gTimeCaps, sizeof(gTimeCaps));

    gbTimerRunning = FALSE;
}

/* @func Called at DLL <f LibExit>
 *
 * @comm
 *
 * The DLL is unloading, so kill any future timer callback.
 */
VOID PASCAL
MidiOutOnExit()
{
    WORD wIntStat;

    wIntStat = DisableInterrupts();

    if (gbTimerRunning)
    {
        DPF(1, "DLL unloading, killing timer interrupts");
        timeKillEvent(guTimerID);
        gbTimerRunning = FALSE;
    }
    
    RestoreInterrupts(wIntStat);
}

/* @func Open a handle instance
 *
 * @comm
 *
 */
MMRESULT PASCAL
MidiOutOnOpen(
    NPOPENHANDLEINSTANCE pohi)
{
    return MMSYSERR_NOERROR;
}

/* @func Close a MIDI device
 *
 * @comm
 *
 */
VOID PASCAL
MidiOutOnClose(
    NPOPENHANDLEINSTANCE pohi)
{
    /* Give MIDI input a chance to turn off thruing to this handle.
     */

    MidiInUnthruToInstance(pohi);
}

/* @func Activate a MIDI device
 *
 * @comm
 *
 * If this is the first activation of the device, open it using the <f midiOutOpen> legacy API.
 */
MMRESULT PASCAL
MidiOutOnActivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;
    HINSTANCE hInstance;
    WORD sel;
    WORD off;
    HTASK FAR *lph;

    DPF(1, "MidiOutActivate poh %04X device %d refcount %u", 
        (WORD)poh,
        poh->id,
        poh->uReferenceCount);

    /* Only open on the first activation 
     */    
    if (1 == poh->uActiveCount)
    {
        mmr = midiOutOpen(&poh->hmo,
                          poh->id,
                          (DWORD)midiOutProc,
                          (DWORD)(LPOPENHANDLE)poh,
                          CALLBACK_FUNCTION);
        if (mmr)
        {
            return mmr;
        }

        /* Since mapper can't be open shared, and we don't want the first instance that opens
         * mapper to take it with it on exit (due to mmsystem appexit), we do really nasty 
         * stuff here. 
         * 
         * The WORD immediately PRECEDING the handle in MMSYSTEM's data segment is the task
         * owner of the handle. We nuke it to NULL (which is all MIDI_IO_SHARED does anyway)
         * to make AppExit ignore us.
         *
         * God help us if anyone changes HNDL in mmsysi.h
         *
         */
        hInstance = LoadLibrary("mmsystem.dll");
        sel = (WORD)hInstance;

        /* hInstance <= 32 means LoadLibrary failed; in this case we just live with it.
         */
        if (sel > 32)
        {
            off = ((WORD)poh->hmo) - sizeof(WORD);
            lph = (HTASK FAR *)MAKELP(sel, off);
            *lph = (HTASK)NULL;
            FreeLibrary(hInstance);
        }

        /* If this is the first output device, bump up timer resolution
         */
        ++gcActiveOutputDevices;
        if (gcActiveOutputDevices == 1)
        {
            SetOutputTimerRes(TRUE);
        }

    }

    return MMSYSERR_NOERROR;
}

/* @func Deactivate a MIDI device
 *
 * @comm
 *
 * If the last client using the device is closing, then close the actual device.
 * If closing the last actual device, then shut down the high precision timer
 *
 */
MMRESULT PASCAL
MidiOutOnDeactivate(
    NPOPENHANDLEINSTANCE pohi)
{
    NPOPENHANDLE poh = pohi->pHandle;

    DPF(1, "MidiOutOnDeactivate poh %04X device %d refcount %u",
        (WORD)poh,
        poh->id,
        poh->uReferenceCount);

    if (poh->uActiveCount)
    {
        /* Still open instances out there
         */
        return MMSYSERR_NOERROR;
    }

	MidiOutSendAllNow(poh);
    midiOutReset(poh->hmo);
    midiOutClose(poh->hmo);
    MidiOutFlushQueues(poh);

    /* If this was the last output device, shut down precision timer resolution
     */
    --gcActiveOutputDevices;
    if (gcActiveOutputDevices == 0)
    {
        SetOutputTimerRes(FALSE);
    }

	return MMSYSERR_NOERROR;
}
             
/* @func Set the timer resolution
 *
 * @comm
 *
 * Set the resolution of the timer callbacks using the <f timeBeginPeriod> and <f timeEndPeriod>
 * API's.
 *
 * If <p fOnOpen> is TRUE, then the timer resolution will be changed to 1 millisecond. Otherwise, it
 * will be set to its previous value.
 *
 */
VOID PASCAL
SetOutputTimerRes(
    BOOL fOnOpen)           /* @parm TRUE if we are supposed to raise precision */
{
    MMRESULT mmr;
    
    if (fOnOpen)
    {
        mmr = timeBeginPeriod(gTimeCaps.wPeriodMin);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Could not timeBeginPeriod() -> %u", (UINT)mmr);
        }
    }
    else
    {
        mmr = timeEndPeriod(gTimeCaps.wPeriodMin);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Could not timeEndPeriod() -> %u", (UINT)mmr);
        }
    }
}
   

/* @func Submit a buffer to a device for playback
 *
 * @rdesc Returns one of the following
 * @flag MMSYSERR_NOERROR | If the buffer was successfully queued
 * @flag MMSYSERR_INVALPARAM | If the buffer is incorrectly packed or the handle is invalid
 * @flag MMSYSERR_NOMEM | If there was no memory available to queue the events
 *
 * @comm
 *
 * This function is thunked to DMusic32.
 *
 * The DirectMusic port interface specifies that a submitted buffer not be
 * kept by the system past the time of the call which submits it.
 *
 * This routine parses the buffer into individual events and copies them into
 * local event structures, which are then queued onto the handle of the device
 * specified by <p h>. The queue for each device is kept in time-increasing order.
 * All local event memory is page-locked (see alloc.c) so that it can be accessed
 * at interrupt time.
 *
 * The time stamps in the buffer are millisecond resolution and are relative to
 * the absolute time <p msStartTime>.
 *
 */
MMRESULT WINAPI
MidiOutSubmitPlaybackBuffer(
    HANDLE h,                   /* @parm The handle of the device to queue these events for */
    LPBYTE lpBuffer,            /* @parm A pointer to the buffer as packed by the IDirectMusicBuffer interface */
    DWORD cbBuffer,             /* @parm The number of bytes of data in the buffer */
    DWORD msStartTime,          /* @parm The starting time of the buffer in absolute time */
    DWORD rtStartTimeLow,       /* @parm Low DWORD of starting reference time */
    DWORD rtStartTimeHigh)      /* @parm High DWORD of starting reference time */
{
    NPOPENHANDLEINSTANCE pohi;
    NPOPENHANDLE poh;
    LPDMEVENT lpEventHdr;
    DWORD cbEvent;
    DWORD msTime;
    LPEVENT pPrev;
    LPEVENT pCurr;
    LPEVENT pNew;
    WORD    wCSID;
    MMRESULT mmr;
    LPMIDIHDR lpmh;
    QUADWORD rtStartTime;
    QUADWORD rtTime;

#ifdef DUMP_EVERY_BUFFER
    UINT idx;
    LPDWORD lpdw;
#endif //DUMP_EVERY_BUFFER
    
    rtStartTime.dwLow = rtStartTimeLow;
    rtStartTime.dwHigh = rtStartTimeHigh;

    DPF(2, "Buffer @ %08lX msStartTime %lu", (DWORD)lpBuffer, (DWORD)msStartTime);
    DPF(2, "At the tone the time will be... %lu <BEEP>", (DWORD)timeGetTime());

#ifdef DUMP_EVERY_BUFFER
    cbEvent = cbBuffer & 0xFFFFFFF0;

    lpdw = (LPDWORD)lpBuffer;
    for (idx = 0; idx < cbEvent; idx += 16) {
        DPF(3, "%04X: %08lX %08lX %08lX %08lX",
            (UINT)idx,
            lpdw[0],
            lpdw[1],
            lpdw[2],
            lpdw[3]);
        lpdw += 4;
    }

    cbEvent = cbBuffer - (cbBuffer & 0xFFFFFFF0);

    if (cbEvent >= 12) {
        DPF(3, "%04x: %08lX %08lX %08lX",
            (UINT)idx, lpdw[0], lpdw[1], lpdw[2]);
    } else if (cbEvent >= 8) {
        DPF(3, "%04x: %08lX %08lX",
            (UINT)idx, lpdw[0], lpdw[1]);
    } else if (cbEvent >= 8) {
        DPF(3, "%04x: %08lX",
            (UINT)idx, lpdw[0]);
    }
#endif // DUMP_EVERY_BUFFER
    
    if (!IsValidHandle(h, VA_F_OUTPUT, &pohi))
    {
        return MMSYSERR_INVALHANDLE;
    }

    /* Get the handle and lock its list
     */
    poh = pohi->pHandle;

    /* Dequeue and free all completed events on this handle
     */
    FreeDoneHandleEvents(poh, FALSE);

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    /* Get the time of the first event and position ourselves in the list
     */
    if (0 == poh->qPlay.cEle)
    {
        pPrev = NULL;
        pCurr = NULL;
    }
    else if (!QuadwordLT(rtStartTime, poh->qPlay.pTail->rtTime))
    {
        pPrev = poh->qPlay.pTail;
        pCurr = NULL;
    }
    else
    {
        pPrev = NULL;
        pCurr = poh->qPlay.pHead;
    }
    
    /* Walk the buffer and add the events to the handle's queue
     */
    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMEVENT))
        {
            return MMSYSERR_INVALPARAM;
        }

        lpEventHdr = (LPDMEVENT)lpBuffer;
        cbEvent = DMEVENT_SIZE(lpEventHdr->cbEvent);
        DPF(2, "cbEvent now %u", (UINT)cbEvent);
        if (cbEvent > cbBuffer)
        {
            DPF(0, "Event past end of buffer");
            return MMSYSERR_INVALPARAM;
        }
        
        lpBuffer += cbEvent;
        cbBuffer -= cbEvent;

        /* We only play events on channel group 1 (0 is broadcast, so we
         * play that as well).
         */
        if (lpEventHdr->dwChannelGroup > 1)
        {
            continue;
        }

        // Time here is in 100ns for queue sorting
        //
        QuadwordAdd(rtStartTime, lpEventHdr->rtDelta, &rtTime);
        
        // Also need msTime for scheduling
        //
        msTime = msStartTime + QuadwordDiv(lpEventHdr->rtDelta, REFTIME_TO_MS);


        // BUGBUG: >64k??
        //
        DPF(2, "Schedule event %02X%02X%02X%02X at %lu",
            (BYTE)lpEventHdr->abEvent[0],
            (BYTE)lpEventHdr->abEvent[1],
            (BYTE)lpEventHdr->abEvent[2],
            (BYTE)lpEventHdr->abEvent[3],
            msTime);

        if (lpEventHdr->cbEvent <= sizeof(DWORD))
        {
            pNew = AllocEvent(msTime, rtTime, (WORD)lpEventHdr->cbEvent);
            if (!pNew)
            {
                return MMSYSERR_NOMEM;
            }
            
            hmemcpy(pNew->abEvent, lpEventHdr->abEvent, lpEventHdr->cbEvent);
        }
        else
        {
            pNew = AllocEvent(msTime, rtTime, (WORD)(lpEventHdr->cbEvent + sizeof(MIDIHDR)));
            if (!pNew)
            {   
                return MMSYSERR_NOMEM;
            }

            pNew->wFlags |= EVENT_F_MIDIHDR;

            lpmh = (LPMIDIHDR)&pNew->abEvent;

            lpmh->lpData =          (LPSTR)(lpmh + 1);
            lpmh->dwBufferLength =  lpEventHdr->cbEvent;
            lpmh->dwUser =          0;  /* Flag if MMSYSTEM owns this buffer */
            lpmh->dwFlags =         0;

            hmemcpy(lpmh->lpData, lpEventHdr->abEvent, lpEventHdr->cbEvent);
            mmr = midiOutPrepareHeader(poh->hmo, lpmh, sizeof(MIDIHDR));
            if (mmr)
            {
                DPF(2, "midiOutPrepareHeader %u", mmr);
                FreeEvent(pNew);
                return mmr;
            }
        }

        while (pCurr)
        {
            if (QuadwordLT(rtTime, pCurr->rtTime))
            {
                break;
            }

            pPrev = pCurr;
            pCurr = pCurr->lpNext;
        }

        if (pPrev)
        {
            pPrev->lpNext = pNew;
        }
        else
        {
            poh->qPlay.pHead = pNew;
        }

        pNew->lpNext = pCurr;
        if (NULL == pCurr)
        {
            poh->qPlay.pTail = pNew;
        }

        pPrev = pNew;
        pCurr = pNew->lpNext;

        ++poh->qPlay.cEle;

        AssertQueueValid(&poh->qPlay);
    }

    LeaveCriticalSection(&poh->wCritSect);

    SetNextTimer();
    
    return MMSYSERR_NOERROR;
}

/* @func VOID PASCAL | FreeDoneHandleEvents | Free events that have already been played, but are still sitting in the done queue
 * on this handle.
 *
 * @comm
 *
 * If fClosing is TRUE, then the events will be free'd regardless of whether they are marked as completed.
 *
 */
typedef struct {
    NPOPENHANDLE poh;
    BOOL fClosing;
} ISEVENTDONEPARMS, FAR *LPISEVENTDONEPARMS;

VOID PASCAL
FreeDoneHandleEvents(
    NPOPENHANDLE poh,       /* @parm What handle? */
    BOOL fClosing)          /* @parm TRUE if the device is being closed. */
{
    ISEVENTDONEPARMS iedp;
    WORD wCSID;

    iedp.poh = poh;
    iedp.fClosing = fClosing;
    
    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    QueueFilter(&poh->qDone, (DWORD)(LPVOID)&iedp, IsEventDone);

    LeaveCriticalSection(&poh->wCritSect);
}

/* @func
 *
 * @comm
 */
int PASCAL
IsEventDone(
    LPEVENT pEvent,
    DWORD dwInstance)
{
    LPISEVENTDONEPARMS piedp = (LPISEVENTDONEPARMS)dwInstance;
    MMRESULT mmr;
    
    if (piedp->fClosing ||
        pEvent->cbEvent <= sizeof(DWORD) ||
        ((LPMIDIHDR)(&pEvent->abEvent[0]))->dwUser == 0)
    {
        /* Ok to free this event
         */
        
        if (pEvent->cbEvent > sizeof(DWORD))
        {
            mmr = midiOutUnprepareHeader(piedp->poh->hmo, (LPMIDIHDR)(&pEvent->abEvent[0]), sizeof(MIDIHDR));
            if (mmr)
            {
                DPF(0, "FreeOldEvents: midiOutUnprepareHeader returned %u", (UINT)mmr);
            }
        }
        
        FreeEvent(pEvent);

        return QUEUE_FILTER_REMOVE;
    }   

    return QUEUE_FILTER_KEEP;
}

/* @func Thru the given message on the given output port
 *
 * @comm
 *
 */
VOID PASCAL 
MidiOutThru(
    NPOPENHANDLEINSTANCE pohi, 
    DWORD dwMessage)
{
    NPOPENHANDLE poh = pohi->pHandle;

    MMRESULT mmr;

    /* !!! Verify that VMM will not interrupt a timer callback with another event
     */
    mmr = midiOutShortMsg(poh->hmo, dwMessage);
    if (mmr)
    {
        DPF(0, "Thru: midiOutShortMsg() -> %d", mmr);
    }    
}


/* @func Set the timer to schedule the next pending event
 *
 * @comm
 *
 * Walk the list of output handles and look at the first scheduled event on each. Save the time
 * of the nearest event. If there is such an event, schedule a timer callback at that time to call
 * <f RunTimer>; otherwise, schedule no callback.
 * 
 * Any pending timer callback will be killed before the new callback is scheduled.
 */
VOID
SetNextTimer(VOID)
{
    WORD wIntStat;

    NPLINKNODE npLink;
    NPOPENHANDLE poh;
    DWORD dwLowTime;
    BOOL fNeedTimer;
    DWORD dwNow;
    LONG lWhen;
    UINT uWhen;

    /* We actually need to disable interrupts here as opposed to just entering a critical section
     * because we don't want the timer callback to fire.
     */
    wIntStat = DisableInterrupts();

    /* BUGBUG: wrap
     */
    fNeedTimer = FALSE;
    dwLowTime = (DWORD)(0xFFFFFFFFL);
    for (npLink = gOpenHandleList; npLink; npLink = npLink->pNext)
    {
        poh = (NPOPENHANDLE)npLink;

        if (0 == poh->qPlay.cEle)
        {
            continue;
        }
        
        assert(poh->qPlay.pHead);
        

        if (poh->qPlay.pHead->msTime < dwLowTime)
        {
            fNeedTimer = TRUE;
            dwLowTime = poh->qPlay.pHead->msTime;
        }
    }

    if (fNeedTimer)
    {
        if ((!gbTimerRunning) || dwLowTime < gdwTimerDue)
        {
            /* We need to set the timer. Kill it now so there's no chance of it
             * firing before being killed
             */
            if (gbTimerRunning)
            {
                timeKillEvent(guTimerID);
                gbTimerRunning = FALSE;
            }
        }
        else
        {
            fNeedTimer = FALSE;
        }
    }

    RestoreInterrupts(wIntStat);

    if (fNeedTimer)
    {
        /* Guaranteed that current timer expired or dead. Reschedule.
         */

        dwNow = timeGetTime();
        gbTimerRunning = TRUE;
        gdwTimerDue = dwLowTime;

        lWhen = gdwTimerDue - dwNow;
        if (lWhen < (LONG)gTimeCaps.wPeriodMin)
        {
            uWhen = gTimeCaps.wPeriodMin;
        }
        else if (lWhen > (LONG)gTimeCaps.wPeriodMax)
        {
            uWhen = gTimeCaps.wPeriodMax;
        }
        else
        {
            uWhen = (UINT)lWhen;
        }

        DPF(2, "SetNextTimer: Now %lu, setting timer for %u ms from now. dwLowTime %lu",
           (DWORD)dwNow, (UINT)uWhen, (DWORD)dwLowTime);
        guTimerID = timeSetEvent(uWhen,
                                 gTimeCaps.wPeriodMin,
                                 RunTimer,
                                 NULL,
                                 TIME_ONESHOT);
        if (0 == guTimerID)
        {
            gbTimerRunning = FALSE;
        }
    }
    else
    {
        DPF(2, "SetNextTimer: Timer cancelled; no pending events.");
    }
}

/* @func Process a high precision timer callback
 *
 * @comm
 *
 * This is a standard callback for the <f timeSetEvent> API.
 *
 * Walk the list of open output handles. For each handle, look at the event queue. Play all
 * the events that are due.
 *
 * Events are pulled from the qPlay queue on each handle. This queue (as well as the qDone queue) are
 * protected by the handle's critical section. If we cannot get the critical section, then the events
 * that may be due on that handle will not be played.
 *
 * If we do get the critical section and play events, then the events will be moved to the qDone
 * queue, where they will later be returned to the free list.
 *
 * This intermediate step is needed because we cannot call <f FreeEvent> at interrupt time. We cannot
 * just protect the free list with a critical section, because we cannot afford to fail getting the
 * critical section. If we did, we would lost the memory for the event we were about to free.
 *
 */
VOID CALLBACK __loadds
RunTimer(
    UINT        uTimerID,           /* @parm The ID of the timer which fired */
    UINT        wMsg,               /* @parm The type of callback (unused) */
    DWORD       dwUser,             /* @parm User instance data */
    DWORD       dw1,                /* @parm Message specific data (unused) */
    DWORD       dw2)                /* @parm Message specific data (unused) */
{    
    NPLINKNODE npLink;
    NPOPENHANDLE poh;
    WORD wCSID;
    WORD wIntStat;
    DWORD msNow;
    DWORD msFence;
    LPEVENT pEvent;
    DWORD dwEvent;
    MMRESULT mmr;


    /* Walk the event queues and send out pending events.
     */
    msNow = timeGetTime();
    msFence = msNow + MS_TIMER_SLOP;
    
    for (npLink = gOpenHandleList; npLink; npLink = npLink->pNext)
    {
        poh = (NPOPENHANDLE)npLink;

        /* If we can't get the critical section, don't sweat it - just reschedule
         */
        wCSID = EnterCriticalSection(&poh->wCritSect, CS_NONBLOCKING);
        if (!wCSID)
        {
            DPF(1, "Timer: Could not get critical section for '%04x'; next time.", (UINT)poh);
            continue;
        }

        /* Now safe against foreground messing with this handle
         */

        for(;;)
        {
            pEvent = poh->qPlay.pHead;
            if (NULL == pEvent || pEvent->msTime > msFence)
            {
                break;
            }

            if (pEvent->msTime > msNow)
            {
                DPF(2, "Late!");
            }

            QueueRemoveFromFront(&poh->qPlay);
            
            if (pEvent->cbEvent <= 4)
            {
                dwEvent = (pEvent->abEvent[0]) |
                          (((DWORD)pEvent->abEvent[1]) << 8) |
                          (((DWORD)pEvent->abEvent[2]) << 16);
                mmr = midiOutShortMsg(poh->hmo, dwEvent);
                if (mmr)
                {
                    DPF(0, "midiOutShortMsg(%04X,%08lX) -> %u",
                        (UINT)poh->hmo,
                        dwEvent,
                        (UINT)mmr);
                }
                else
                {
                    DPF(2, "midiOutShortMsg(%04X,%08lX) ",
                        (UINT)poh->hmo,
                        dwEvent);
                }
            }
            else
            {
                /* Data contains an already prepared long message.
                 * DON'T leave interrupts disabled here! Most legacy MIDI drivers
                 * do this synchronously.
                 *
                 */
                RestoreInterrupts(wIntStat);
                ((LPMIDIHDR)(&pEvent->abEvent[0]))->dwUser = 1;
                mmr = midiOutLongMsg(poh->hmo,
                                     (LPMIDIHDR)(&pEvent->abEvent[0]),
                                     sizeof(MIDIHDR));
                if (mmr)
                {
                    DPF(0, "midiOutLongMsg(%04X, %08lX, %04X) -> %u\n",
                        (UINT)poh->hmo,
                        (DWORD)(LPMIDIHDR)(&pEvent->abEvent[0]),
                        (UINT)sizeof(MIDIHDR),
                        (UINT)mmr);
                }
                DisableInterrupts();
            }
            

            /* We're done with this event; back to the free list with ya!
             *
             * Since we can't protect the free list with a critical section (what
             * would we do if getting the critical section failed here?) we keep
             * a temporary free list in the handle. Free events are moved from
             * the handle to the master free list in user time.
             */
            QueueAppend(&poh->qDone, pEvent);
        }

        LeaveCriticalSection(&poh->wCritSect);
    }

    /* Now reschedule ourselves if needed.
     */
    gbTimerRunning = FALSE;
    SetNextTimer();

}


VOID CALLBACK _loadds
midiOutProc(
    HMIDIOUT hMidiIn,
    UINT wMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2)
{
    LPOPENHANDLE poh = (LPOPENHANDLE)dwInstance;

    switch(wMsg)
    {
        case MOM_DONE:
            /* Buffer is already queued for free on the device's queue. dwUser flags if it
             * is still in use by MMSYSTEM/driver.
             */
            ((LPMIDIHDR)dwParam1)->dwUser = 0;
            break;
    }
}

/* @func Return all memory from all queues to the free event list.
 *
 * @comm
 *
 */
STATIC VOID NEAR PASCAL 
MidiOutFlushQueues(
    NPOPENHANDLE poh)
{
    WORD wCSID;

    wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
    assert(wCSID);

    FreeAllQueueEvents(&poh->qPlay);
    FreeAllQueueEvents(&poh->qDone);

    LeaveCriticalSection(&poh->wCritSect);
}

/* @func Send all pending messages (other than note on) in preperation
 * to close the port.
 *
 * @comm
 *
 */
STATIC VOID NEAR PASCAL 
MidiOutSendAllNow(
	NPOPENHANDLE poh)
{
	LPEVENT pEvent;
	DWORD dwEvent;
	MMRESULT mmr;
	WORD wCSID;
	
	wCSID = EnterCriticalSection(&poh->wCritSect, CS_BLOCKING);
	assert(wCSID);

	/* Now safe against foreground messing with this handle
	 */

	for(;;)
	{
    	pEvent = poh->qPlay.pHead;
	    if (NULL == pEvent)
	    {
	    	DPF(2,"MidiOutSendAllNow: No queued Messages.");
	        break;
	    }

	    QueueRemoveFromFront(&poh->qPlay);
    
	    if (pEvent->cbEvent <= 4)
	    {
	        dwEvent = (pEvent->abEvent[0]) |
	                 (((DWORD)pEvent->abEvent[1]) << 8) |
                  (((DWORD)pEvent->abEvent[2]) << 16);

			// We aren't going to process MIDI_NOTE_ON with a
			// velocity of zero

			//There are two kinds of short messages,  Two Byte and 
			//Three Byte..  They pack differently in MIDI Short message

			//If the first bit if the High Byte of the Low Word is SET we are
			//looking at a 3 byte message.

			//MIDI status messages begin with a 
			//set bit, and every other part of the same message starts with an
			//unset bit.
			if (HIBYTE(LOWORD(dwEvent) & 0x80) )
			{
				//This is a THREE BYTE message

				// note on with a non-zero velocity is skipped
				if ( (HIBYTE(LOWORD(dwEvent)) & MIDI_NOTE_ON) && (LOBYTE(LOWORD(dwEvent)) != 0 ))
				{
					QueueAppend(&poh->qDone, pEvent);
					continue;
				}
			}
			else
			{
				//This is a THREE BYTE Message

				// Any note-on is skiped
				if (LOBYTE(LOWORD(dwEvent)) & MIDI_NOTE_ON)
				{
					QueueAppend(&poh->qDone, pEvent);
					continue;
				}
			}
            
    	    mmr = midiOutShortMsg(poh->hmo, dwEvent);
        	if (mmr)
        	{
            	DPF(0, "midiOutShortMsg(%04X,%08lX) -> %u",
                (UINT)poh->hmo,
                dwEvent,
                (UINT)mmr);
        	}
        	else
        	{
            DPF(2, "midiOutShortMsg(%04X,%08lX) ",
                (UINT)poh->hmo,
                dwEvent);
        	}
    	}
    	else
    	{
        	/* Data contains an already prepared long message.
         	* DON'T leave interrupts disabled here! Most legacy MIDI drivers
         	* do this synchronously.
         	*
         	*/
        	((LPMIDIHDR)(&pEvent->abEvent[0]))->dwUser = 1;
        	mmr = midiOutLongMsg(poh->hmo,
                             (LPMIDIHDR)(&pEvent->abEvent[0]),
                             sizeof(MIDIHDR));
        	if (mmr)
        	{	
            	DPF(0, "midiOutLongMsg(%04X, %08lX, %04X) -> %u\n",
               		(UINT)poh->hmo,
               	 	(DWORD)(LPMIDIHDR)(&pEvent->abEvent[0]),
                	(UINT)sizeof(MIDIHDR),
                	(UINT)mmr);
        	}
    	}
    

    	/* We're done with this event; back to the free list with ya!
     	*
     	* Since we can't protect the free list with a critical section (what
     	* would we do if getting the critical section failed here?) we keep
     	* a temporary free list in the handle. Free events are moved from
     	* the handle to the master free list in user time.
     	*/
    	QueueAppend(&poh->qDone, pEvent);
	}

	LeaveCriticalSection(&poh->wCritSect);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\preclude.h ===
// Copyright (c) 1998 Microsoft Corporation

// MMSYSTEM precludes
//
 
#define     MMNOSOUND
#define     MMNOWAVE
#define     MMNOSEQ
#define     MMNOTIMER
#define     MMNOJOY
////#define     MMNOMCI
#define     MMNOTASK

// MMDDK precludes
//
#define     MMNOWAVEDEV
#define     MMNOAUXDEV
#define     MMNOTIMERDEV
#define     MMNOJOYDEV
/////#define     MMNOMCIDEV
#define     MMNOTASKDEV

// WINDOWS precludes
//

#define     NOGDICAPMASKS        //- CC_*, LC_*, PC_*, CP_*, TC_*, RC_
#define     NOVIRTUALKEYCODES    //- VK_*
#define     NOICONS              //- IDI_*
#define     NOKEYSTATES          //- MK_*
#define     NOSYSCOMMANDS        //- SC_*
#define     NORASTEROPS          //- Binary and Tertiary raster ops
#define     OEMRESOURCE          //- OEM Resource values
#define     NOCLIPBOARD          //- Clipboard routines
#define     NOMETAFILE           //- typedef METAFILEPICT
//#define     NOOPENFILE           //- OpenFile(), OemToAnsi, AnsiToOem, and OF_*
#define     NOSOUND              //- Sound driver routines
#define     NOWH                 //- SetWindowsHook and WH_*
#define     NOCOMM               //- COMM driver routines
#define     NOKANJI              //- Kanji support stuff.
//#define     NOHELP               //- Help engine interface.
#define     NOPROFILER           //- Profiler interface.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\mmsystem.inc ===
; Copyright (c) 1998-1999 Microsoft Corporation

; general constants
MAXPNAMELEN	EQU	32     ; max product name length (including NULL)
MAXERRORLENGTH	EQU	256    ; max error text length (including NULL)
MAX_JOYSTICKOEMVXDNAME	EQU	260 ; max oem vxd name length (including NULL)

MMTIME	STRUC
mmt_wType	DW	?
mmt_TimeUnion	DD	?
MMTIME	ENDS

SMPTE	STRUC
smpte_hour	DB	?
smpte_min	DB	?
smpte_sec	DB	?
smpte_frame	DB	?
smpte_fps	DB	?
smpte_reserved	DB	?
SMPTE	ENDS
; types for wType field in MMTIME struct
TIME_MS	EQU	0001H  ; time in milliseconds
TIME_SAMPLES	EQU	0002H  ; number of wave samples
TIME_BYTES	EQU	0004H  ; current byte offset
TIME_SMPTE	EQU	0008H  ; SMPTE time
TIME_MIDI	EQU	0010H  ; MIDI time
TIME_TICKS	EQU	0020H  ; Ticks within MIDI stream
MM_JOY1MOVE	EQU	3A0H           ; joystick
MM_JOY2MOVE	EQU	3A1H
MM_JOY1ZMOVE	EQU	3A2H
MM_JOY2ZMOVE	EQU	3A3H
MM_JOY1BUTTONDOWN	EQU	3B5H
MM_JOY2BUTTONDOWN	EQU	3B6H
MM_JOY1BUTTONUP	EQU	3B7H
MM_JOY2BUTTONUP	EQU	3B8H
MM_MCINOTIFY	EQU	3B9H           ; MCI
						;internal; 0x3BA is open
MM_WOM_OPEN	EQU	3BBH           ; waveform output
MM_WOM_CLOSE	EQU	3BCH
MM_WOM_DONE	EQU	3BDH
MM_WIM_OPEN	EQU	3BEH           ; waveform input
MM_WIM_CLOSE	EQU	3BFH
MM_WIM_DATA	EQU	3C0H
MM_MIM_OPEN	EQU	3C1H           ; MIDI input
MM_MIM_CLOSE	EQU	3C2H
MM_MIM_DATA	EQU	3C3H
MM_MIM_LONGDATA	EQU	3C4H
MM_MIM_ERROR	EQU	3C5H
MM_MIM_LONGERROR	EQU	3C6H
MM_MOM_OPEN	EQU	3C7H           ; MIDI output
MM_MOM_CLOSE	EQU	3C8H
MM_MOM_DONE	EQU	3C9H
MMSYSERR_BASE	EQU	0
WAVERR_BASE	EQU	32
MIDIERR_BASE	EQU	64
TIMERR_BASE	EQU	96
JOYERR_BASE	EQU	160
MCIERR_BASE	EQU	256
MIXERR_BASE	EQU	1024
MCI_STRING_OFFSET	EQU	512
MCI_VD_OFFSET	EQU	1024
MCI_CD_OFFSET	EQU	1088
MCI_WAVE_OFFSET	EQU	1152
MCI_SEQ_OFFSET	EQU	1216
;***************************************************************************
;	General error return values
;*************************************************************************
; general error return values
MMSYSERR_NOERROR	EQU	0                    ; no error
MMSYSERR_ERROR	EQU	(MMSYSERR_BASE+1)  ; unspecified error
MMSYSERR_BADDEVICEID	EQU	(MMSYSERR_BASE+2)  ; device ID out of range
MMSYSERR_NOTENABLED	EQU	(MMSYSERR_BASE+3)  ; driver failed enable
MMSYSERR_ALLOCATED	EQU	(MMSYSERR_BASE+4)  ; device already allocated
MMSYSERR_INVALHANDLE	EQU	(MMSYSERR_BASE+5)  ; device handle is invalid
MMSYSERR_NODRIVER	EQU	(MMSYSERR_BASE+6)  ; no device driver present
MMSYSERR_NOMEM	EQU	(MMSYSERR_BASE+7)  ; memory allocation error
MMSYSERR_NOTSUPPORTED	EQU	(MMSYSERR_BASE+8)  ; function isn't supported
MMSYSERR_BADERRNUM	EQU	(MMSYSERR_BASE+9)  ; error value out of range
MMSYSERR_INVALFLAG	EQU	(MMSYSERR_BASE+10) ; invalid flag passed
MMSYSERR_INVALPARAM	EQU	(MMSYSERR_BASE+11) ; invalid parameter passed
MMSYSERR_HANDLEBUSY	EQU	(MMSYSERR_BASE+12) ; handle being used
						   ; simultaneously on another
						   ; thread (eg callback)
MMSYSERR_INVALIDALIAS	EQU	(MMSYSERR_BASE+13) ; specified alias not found
MMSYSERR_BADDB	EQU	(MMSYSERR_BASE+14) ; bad registry database
MMSYSERR_KEYNOTFOUND	EQU	(MMSYSERR_BASE+15) ; registry key not found
MMSYSERR_READERROR	EQU	(MMSYSERR_BASE+16) ; registry read error
MMSYSERR_WRITEERROR	EQU	(MMSYSERR_BASE+17) ; registry write error
MMSYSERR_DELETEERROR	EQU	(MMSYSERR_BASE+18) ; registry delete error
MMSYSERR_VALNOTFOUND	EQU	(MMSYSERR_BASE+19) ; registry value not found
MMSYSERR_NODRIVERCB	EQU	(MMSYSERR_BASE+20) ; driver does not call DriverCallback
MMSYSERR_LASTERROR	EQU	(MMSYSERR_BASE+20) ; last error in range
ifndef MMNODRV                                                 ;both
ifndef DRV_RESERVED
DRV_RESERVED	EQU	0800H
DRV_USER	EQU	4000H
endif
DRV_MCI_FIRST	EQU	DRV_RESERVED
DRV_MCI_LAST	EQU	(DRV_RESERVED+0FFFH)
endif                                      ;both; ifndef MMNODRV
;***************************************************************************
;	  Driver callback support
;*************************************************************************
; flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and
; midiOutOpen() to specify the type of the dwCallback parameter.
CALLBACK_TYPEMASK	EQU	00070000H    ; callback type mask
CALLBACK_NULL	EQU	00000000H    ; no callback
CALLBACK_WINDOW	EQU	00010000H    ; dwCallback is a HWND
CALLBACK_TASK	EQU	00020000H    ; dwCallback is a HTASK
CALLBACK_FUNCTION	EQU	00030000H    ; dwCallback is a FARPROC
CALLBACK_THUNK	EQU	00040000H    	;internal; dwCallback is a Ring0 Thread Handle
ifdef _WIN32
CALLBACK_THREAD	EQU	(CALLBACK_TASK); thread ID replaces 16 bit task
CALLBACK_EVENT	EQU	00050000H    ; dwCallback is an EVENT Handle
endif
CALLBACK_EVENT16	EQU	00060000H    	;internal; dwCallback is an EVENT under Win16
SND_SYNC	EQU	0000H  ; play synchronously (default)
SND_ASYNC	EQU	0001H  ; play asynchronously
SND_NODEFAULT	EQU	0002H  ; silence (!default) if sound not found
SND_MEMORY	EQU	0004H  ; pszSound points to a memory file
SND_LOOP	EQU	0008H  ; loop the sound until next sndPlaySound
SND_NOSTOP	EQU	0010H  ; don't stop any currently playing sound
ifndef MMNOWAVE                                                 ;both
;***************************************************************************
;	Waveform audio support
;*************************************************************************
; waveform audio error return values
WAVERR_BADFORMAT	EQU	(WAVERR_BASE+0)    ; unsupported wave format
WAVERR_STILLPLAYING	EQU	(WAVERR_BASE+1)    ; still something playing
WAVERR_UNPREPARED	EQU	(WAVERR_BASE+2)    ; header not prepared
WAVERR_SYNC	EQU	(WAVERR_BASE+3)    ; device is synchronous
WAVERR_LASTERROR	EQU	(WAVERR_BASE+3)    ; last error in range
; wave callback messages
WOM_OPEN	EQU	MM_WOM_OPEN
WOM_CLOSE	EQU	MM_WOM_CLOSE
WOM_DONE	EQU	MM_WOM_DONE
WIM_OPEN	EQU	MM_WIM_OPEN
WIM_CLOSE	EQU	MM_WIM_CLOSE
WIM_DATA	EQU	MM_WIM_DATA
; device ID for wave device mapper
WAVE_MAPPER	EQU	(-1)
; flags for dwFlags parameter in waveOutOpen() and waveInOpen()
WAVE_FORMAT_QUERY	EQU	0001H
WAVE_ALLOWSYNC	EQU	0002H
WAVE_VALID	EQU	800FH			;internal

WAVEHDR	STRUC
lpWaveData	DD	?
dwWaveBufferLength	DD	?
dwWaveBytesRecorded	DD	?
dwWaveUser	DD	?
dwWaveFlags	DD	?
dwWaveLoops	DD	?
lpWaveNext	DD	?
Wavereserved	DD	?
WAVEHDR	ENDS
; flags for dwFlags field of WAVEHDR
WHDR_DONE	EQU	00000001H  ; done bit
WHDR_PREPARED	EQU	00000002H  ; set if this header has been prepared
WHDR_BEGINLOOP	EQU	00000004H  ; loop start block
WHDR_ENDLOOP	EQU	00000008H  ; loop end block
WHDR_INQUEUE	EQU	00000010H  ; reserved for driver
WHDR_MAPPED	EQU	00001000H  	;internal; thunked header
WHDR_VALID	EQU	0000101FH  		;internal; valid flags

WAVEOUTCAPS	STRUC
woc_wMid	DW	?
woc_wPid	DW	?
woc_vDriverVersion	DW	?
woc_szPname	DB	MAXPNAMELEN DUP (?)
woc_dwFormats	DD	?
woc_wChannels	DW	?
woc_dwSupport	DD	?
WAVEOUTCAPS	ENDS
; flags for dwSupport field of WAVEOUTCAPS
WAVECAPS_PITCH	EQU	0001H   ; supports pitch control
WAVECAPS_PLAYBACKRATE	EQU	0002H   ; supports playback rate control
WAVECAPS_VOLUME	EQU	0004H   ; supports volume control
WAVECAPS_LRVOLUME	EQU	0008H   ; separate left-right volume control
WAVECAPS_SYNC	EQU	0010H
WAVECAPS_SAMPLEACCURATE	EQU	0020H
WAVECAPS_DIRECTSOUND	EQU	0040H

WAVEINCAPS	STRUC
wic_wMid	DW	?
wic_wPid	DW	?
wic_vDriverVersion	DW	?
wic_szPname	DB	MAXPNAMELEN DUP (?)
wic_dwFormats	DD	?
wic_wChannels	DW	?
WAVEINCAPS	ENDS
; defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
WAVE_INVALIDFORMAT	EQU	00000000H       ; invalid format
WAVE_FORMAT_1M08	EQU	00000001H       ; 11.025 kHz, Mono,   8-bit
WAVE_FORMAT_1S08	EQU	00000002H       ; 11.025 kHz, Stereo, 8-bit
WAVE_FORMAT_1M16	EQU	00000004H       ; 11.025 kHz, Mono,   16-bit
WAVE_FORMAT_1S16	EQU	00000008H       ; 11.025 kHz, Stereo, 16-bit
WAVE_FORMAT_2M08	EQU	00000010H       ; 22.05  kHz, Mono,   8-bit
WAVE_FORMAT_2S08	EQU	00000020H       ; 22.05  kHz, Stereo, 8-bit
WAVE_FORMAT_2M16	EQU	00000040H       ; 22.05  kHz, Mono,   16-bit
WAVE_FORMAT_2S16	EQU	00000080H       ; 22.05  kHz, Stereo, 16-bit
WAVE_FORMAT_4M08	EQU	00000100H       ; 44.1   kHz, Mono,   8-bit
WAVE_FORMAT_4S08	EQU	00000200H       ; 44.1   kHz, Stereo, 8-bit
WAVE_FORMAT_4M16	EQU	00000400H       ; 44.1   kHz, Mono,   16-bit
WAVE_FORMAT_4S16	EQU	00000800H       ; 44.1   kHz, Stereo, 16-bit

WAVEFORMAT	STRUC
wfmt_wFormatTag	DW	?
wfmt_nChannels	DW	?
wfmt_nSamplesPerSec	DD	?
wfmt_nAvgBytesPerSec	DD	?
wfmt_nBlockAlign	DW	?
WAVEFORMAT	ENDS
; flags for wFormatTag field of WAVEFORMAT
WAVE_FORMAT_PCM	EQU	1

PCMWAVEFORMAT	STRUC
pcm_wf	DB	SIZE WAVEFORMAT DUP (?)
pcm_wBitsPerSample	DW	?
PCMWAVEFORMAT	ENDS
endif                                      ;both; ifndef MMNOWAVE
ifndef MMNOMIDI                               ;both
;***************************************************************************
;	    MIDI audio support
;*************************************************************************
; MIDI error return values
MIDIERR_UNPREPARED	EQU	(MIDIERR_BASE+0)   ; header not prepared
MIDIERR_STILLPLAYING	EQU	(MIDIERR_BASE+1)   ; still something playing
MIDIERR_NOMAP	EQU	(MIDIERR_BASE+2)   ; no configured instruments
MIDIERR_NOTREADY	EQU	(MIDIERR_BASE+3)   ; hardware is still busy
MIDIERR_NODEVICE	EQU	(MIDIERR_BASE+4)   ; port no longer connected
MIDIERR_INVALIDSETUP	EQU	(MIDIERR_BASE+5)   ; invalid MIF
MIDIERR_BADOPENMODE	EQU	(MIDIERR_BASE+6)   ; operation unsupported w/ open mode
MIDIERR_DONT_CONTINUE	EQU	(MIDIERR_BASE+7)   ; thru device 'eating' a message
MIDIERR_LASTERROR	EQU	(MIDIERR_BASE+7)   ; last error in range
MIDIPATCHSIZE	EQU	128
; MIDI callback messages
MIM_OPEN	EQU	MM_MIM_OPEN
MIM_CLOSE	EQU	MM_MIM_CLOSE
MIM_DATA	EQU	MM_MIM_DATA
MIM_LONGDATA	EQU	MM_MIM_LONGDATA
MIM_ERROR	EQU	MM_MIM_ERROR
MIM_LONGERROR	EQU	MM_MIM_LONGERROR
MOM_OPEN	EQU	MM_MOM_OPEN
MOM_CLOSE	EQU	MM_MOM_CLOSE
MOM_DONE	EQU	MM_MOM_DONE
; device ID for MIDI mapper
MIDIMAPPER	EQU	(-1)
MIDI_MAPPER	EQU	(-1)
; flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches()
MIDI_CACHE_ALL	EQU	1
MIDI_CACHE_BESTFIT	EQU	2
MIDI_CACHE_QUERY	EQU	3
MIDI_UNCACHE	EQU	4
MIDI_CACHE_VALID	EQU	(MIDI_CACHE_ALL OR MIDI_CACHE_BESTFIT OR MIDI_CACHE_QUERY OR MIDI_UNCACHE)     ;internal

MIDIOUTCAPS	STRUC
moc_wMid	DW	?
moc_wPid	DW	?
moc_vDriverVersion	DW	?
moc_szPname	DB	MAXPNAMELEN DUP (?)
moc_wTechnology	DW	?
moc_wVoices	DW	?
moc_wNotes	DW	?
moc_wChannelMask	DW	?
moc_dwSupport	DD	?
MIDIOUTCAPS	ENDS
; flags for wTechnology field of MIDIOUTCAPS structure
MOD_MIDIPORT	EQU	1  ; output port
MOD_SYNTH	EQU	2  ; generic internal synth
MOD_SQSYNTH	EQU	3  ; square wave internal synth
MOD_FMSYNTH	EQU	4  ; FM internal synth
MOD_MAPPER	EQU	5  ; MIDI mapper
; flags for dwSupport field of MIDIOUTCAPS structure
MIDICAPS_VOLUME	EQU	0001H  ; supports volume control
MIDICAPS_LRVOLUME	EQU	0002H  ; separate left-right volume control
MIDICAPS_CACHE	EQU	0004H

MIDIINCAPS	STRUC
mic_wMid	DW	?
mic_wPid	DW	?
mic_vDriverVersion	DW	?
mic_szPname	DB	MAXPNAMELEN DUP (?)
MIDIINCAPS	ENDS

MIDIHDR	STRUC
lpMidiData	DD	?
dwMidiBufferLength	DD	?
dwMidiBytesRecorded	DD	?
dwMidiUser	DD	?
dwMidiFlags	DD	?
lpMidiNext	DD	?
Midireserved	DD	?
MididwOffset	DD	?
MididwReserved	DD	4 DUP (?)
MIDIHDR	ENDS

MIDIHDR31	STRUC
w31lpMidiData	DD	?
w31dwMidiBufferLength	DD	?
w31dwMidiBytesRecorded	DD	?
w31dwMidiUser	DD	?
w31dwMidiFlags	DD	?
w31lpMidiNext	DD	?
w31Midireserved	DD	?
MIDIHDR31	ENDS
; flags for dwFlags field of MIDIHDR structure
MHDR_DONE	EQU	00000001H       ; done bit
MHDR_PREPARED	EQU	00000002H       ; set if header prepared
MHDR_INQUEUE	EQU	00000004H       ; reserved for driver
MHDR_ISSTRM	EQU	00000008H       ; Buffer is stream buffer
MHDR_SENDING	EQU	00000020H       ;internal
MHDR_MAPPED	EQU	00001000H       	;internal; thunked header
MHDR_SHADOWHDR	EQU	00002000H        ;internal; MIDIHDR is 16-bit shadow
MHDR_VALID	EQU	0000302FH       	;internal; valid flags
	;internal */;#define MHDR_VALID      0xFFFF000F       /* valid flags
MHDR_SAVE	EQU	00003000H         ;internal; Save these flags
                                          ;internal; past driver calls
endif                                     ;both; ifndef MMNOMIDI
ifndef MMNOAUX                                                  ;both
;***************************************************************************
;	Auxiliary audio support
;*************************************************************************
; device ID for aux device mapper
AUX_MAPPER	EQU	(-1)

AUXCAPS	STRUC
acaps_wMid	DW	?
acaps_wPid	DW	?
acaps_vDriverVersion	DW	?
acaps_szPname	DB	MAXPNAMELEN DUP (?)
acaps_wTechnology	DW	?
acaps_dwSupport	DD	?
AUXCAPS	ENDS
; flags for wTechnology field in AUXCAPS structure
AUXCAPS_CDAUDIO	EQU	1       ; audio from internal CD-ROM drive
AUXCAPS_AUXIN	EQU	2       ; audio from auxiliary input jacks
; flags for dwSupport field in AUXCAPS structure
AUXCAPS_VOLUME	EQU	0001H  ; supports volume control
AUXCAPS_LRVOLUME	EQU	0002H  ; separate left-right volume control
endif                                       ;both; ifndef MMNOAUX
ifndef MMNOTIMER                                               ;both
ifndef _WIN32_VXD
;***************************************************************************
;	    Timer support
;*************************************************************************
; timer error return values
TIMERR_NOERROR	EQU	(0)                  ; no error
TIMERR_NOCANDO	EQU	(TIMERR_BASE+1)      ; request not completed
TIMERR_STRUCT	EQU	(TIMERR_BASE+33)     ; time struct size
; flags for fuEvent parameter of timeSetEvent() function
TIME_ONESHOT	EQU	0000H   ; program timer for single event
TIME_PERIODIC	EQU	0001H   ; program for continuous periodic event
ifdef _WIN32
TIME_CALLBACK_FUNCTION	EQU	0000H  ; callback is function
TIME_CALLBACK_EVENT_SET	EQU	0010H  ; callback is event - use SetEvent
TIME_CALLBACK_EVENT_PULSE	EQU	0020H  ; callback is event - use PulseEvent
TIME_CALLBACK_TYPEMASK	EQU	00F0H  ;internal
endif

TIMECAPS	STRUC
tc_wPeriodMin	DW	?
tc_wPeriodMax	DW	?
TIMECAPS	ENDS
endif  ; ifndef _WIN32_VXD
endif                                    ;both; ifndef MMNOTIMER
ifndef MMNOJOY                                                 ;both
;***************************************************************************
;	    Joystick support
;*************************************************************************
; joystick error return values
JOYERR_NOERROR	EQU	(0)                  ; no error
JOYERR_PARMS	EQU	(JOYERR_BASE+5)      ; bad parameters
JOYERR_NOCANDO	EQU	(JOYERR_BASE+6)      ; request not completed
JOYERR_UNPLUGGED	EQU	(JOYERR_BASE+7)      ; joystick is unplugged
; constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages
JOY_BUTTON1	EQU	0001H
JOY_BUTTON2	EQU	0002H
JOY_BUTTON3	EQU	0004H
JOY_BUTTON4	EQU	0008H
JOY_BUTTON1CHG	EQU	0100H
JOY_BUTTON2CHG	EQU	0200H
JOY_BUTTON3CHG	EQU	0400H
JOY_BUTTON4CHG	EQU	0800H
; constants used with JOYINFOEX
JOY_BUTTON5	EQU	00000010H
JOY_BUTTON6	EQU	00000020H
JOY_BUTTON7	EQU	00000040H
JOY_BUTTON8	EQU	00000080H
JOY_BUTTON9	EQU	00000100H
JOY_BUTTON10	EQU	00000200H
JOY_BUTTON11	EQU	00000400H
JOY_BUTTON12	EQU	00000800H
JOY_BUTTON13	EQU	00001000H
JOY_BUTTON14	EQU	00002000H
JOY_BUTTON15	EQU	00004000H
JOY_BUTTON16	EQU	00008000H
JOY_BUTTON17	EQU	00010000H
JOY_BUTTON18	EQU	00020000H
JOY_BUTTON19	EQU	00040000H
JOY_BUTTON20	EQU	00080000H
JOY_BUTTON21	EQU	00100000H
JOY_BUTTON22	EQU	00200000H
JOY_BUTTON23	EQU	00400000H
JOY_BUTTON24	EQU	00800000H
JOY_BUTTON25	EQU	01000000H
JOY_BUTTON26	EQU	02000000H
JOY_BUTTON27	EQU	04000000H
JOY_BUTTON28	EQU	08000000H
JOY_BUTTON29	EQU	10000000H
JOY_BUTTON30	EQU	20000000H
JOY_BUTTON31	EQU	40000000H
JOY_BUTTON32	EQU	80000000H
; constants used with JOYINFOEX structure
JOY_POVCENTERED	EQU	-1
JOY_POVFORWARD	EQU	0
JOY_POVRIGHT	EQU	9000
JOY_POVBACKWARD	EQU	18000
JOY_POVLEFT	EQU	27000
JOY_RETURNX	EQU	00000001H
JOY_RETURNY	EQU	00000002H
JOY_RETURNZ	EQU	00000004H
JOY_RETURNR	EQU	00000008H
JOY_RETURNU	EQU	00000010H	; axis 5
JOY_RETURNV	EQU	00000020H	; axis 6
JOY_RETURNPOV	EQU	00000040H
JOY_RETURNBUTTONS	EQU	00000080H
JOY_RETURNRAWDATA	EQU	00000100H
JOY_RETURNPOVCTS	EQU	00000200H
JOY_RETURNCENTERED	EQU	00000400H
JOY_USEDEADZONE	EQU	00000800H
JOY_RETURNALL	EQU	(JOY_RETURNX OR JOY_RETURNY OR JOY_RETURNZ OR JOY_RETURNR OR JOY_RETURNU OR JOY_RETURNV OR JOY_RETURNPOV OR JOY_RETURNBUTTONS)
JOY_CAL_READALWAYS	EQU	00010000H
JOY_CAL_READXYONLY	EQU	00020000H
JOY_CAL_READ3	EQU	00040000H
JOY_CAL_READ4	EQU	00080000H
JOY_CAL_READXONLY	EQU	00100000H
JOY_CAL_READYONLY	EQU	00200000H
JOY_CAL_READ5	EQU	00400000H
JOY_CAL_READ6	EQU	00800000H
JOY_CAL_READZONLY	EQU	01000000H
JOY_CAL_READRONLY	EQU	02000000H
JOY_CAL_READUONLY	EQU	04000000H
JOY_CAL_READVONLY	EQU	08000000H
; joystick ID constants
JOYSTICKID1	EQU	0
JOYSTICKID2	EQU	1
; joystick driver capabilites
JOYCAPS_HASZ	EQU	0001H
JOYCAPS_HASR	EQU	0002H
JOYCAPS_HASU	EQU	0004H
JOYCAPS_HASV	EQU	0008H
JOYCAPS_HASPOV	EQU	0010H
JOYCAPS_POV4DIR	EQU	0020H
JOYCAPS_POVCTS	EQU	0040H

JOYCAPS	STRUC
jcaps_wMid	DW	?
jcaps_wPid	DW	?
jcaps_szPname	DB	MAXPNAMELEN DUP (?)
jcaps_wXmin	DW	?
jcaps_wXmax	DW	?
jcaps_wYmin	DW	?
jcaps_wYmax	DW	?
jcaps_wZmin	DW	?
jcaps_wZmax	DW	?
jcaps_wNumButtons	DW	?
jcaps_wPeriodMin	DW	?
jcaps_wPeriodMax	DW	?
jcaps_wRmin	DW	?
jcaps_wRmax	DW	?
jcaps_wUmin	DW	?
jcaps_wUmax	DW	?
jcaps_wVmin	DW	?
jcaps_wVmax	DW	?
jcaps_wCaps	DW	?
jcaps_wMaxAxes	DW	?
jcaps_wNumAxes	DW	?
jcaps_wMaxButtons	DW	?
jcaps_szRegKey	DB	MAXPNAMELEN DUP (?)
jcaps_szOEMVxD	DB	MAX_JOYSTICKOEMVXDNAME DUP (?)
JOYCAPS	ENDS

JOYINFO	STRUC
jinfo_wXpos	DW	?
jinfo_wYpos	DW	?
jinfo_wZpos	DW	?
jinfo_wButtons	DW	?
JOYINFO	ENDS

JOYINFOEX	STRUC
jinfoex_dwSize	DD	?
jinfoex_dwFlags	DD	?
jinfoex_dwXpos	DD	?
jinfoex_dwYpos	DD	?
jinfoex_dwZpos	DD	?
jinfoex_dwRpos	DD	?
jinfoex_dwUpos	DD	?
jinfoex_dwVpos	DD	?
jinfoex_dwButtons	DD	?
jinfoex_dwButtonNumber	DD	?
jinfoex_dwPOV	DD	?
jinfoex_dwReserved1	DD	?
jinfoex_dwReserved2	DD	?
JOYINFOEX	ENDS
endif                                       ;both; ifndef MMNOJOY
ifndef MMNOMMIO                                                ;both
ifndef _WIN32_VXD
;***************************************************************************
;	Multimedia File I/O support
;*************************************************************************
; MMIO error return values
MMIOERR_BASE	EQU	256
MMIOERR_FILENOTFOUND	EQU	(MMIOERR_BASE+1)  ; file not found
MMIOERR_OUTOFMEMORY	EQU	(MMIOERR_BASE+2)  ; out of memory
MMIOERR_CANNOTOPEN	EQU	(MMIOERR_BASE+3)  ; cannot open
MMIOERR_CANNOTCLOSE	EQU	(MMIOERR_BASE+4)  ; cannot close
MMIOERR_CANNOTREAD	EQU	(MMIOERR_BASE+5)  ; cannot read
MMIOERR_CANNOTWRITE	EQU	(MMIOERR_BASE+6)  ; cannot write
MMIOERR_CANNOTSEEK	EQU	(MMIOERR_BASE+7)  ; cannot seek
MMIOERR_CANNOTEXPAND	EQU	(MMIOERR_BASE+8)  ; cannot expand file
MMIOERR_CHUNKNOTFOUND	EQU	(MMIOERR_BASE+9)  ; chunk not found
MMIOERR_UNBUFFERED	EQU	(MMIOERR_BASE+10) ;
MMIOERR_PATHNOTFOUND	EQU	(MMIOERR_BASE+11) ; path incorrect
MMIOERR_ACCESSDENIED	EQU	(MMIOERR_BASE+12) ; file was protected
MMIOERR_SHARINGVIOLATION	EQU	(MMIOERR_BASE+13) ; file in use
MMIOERR_NETWORKERROR	EQU	(MMIOERR_BASE+14) ; network not responding
MMIOERR_TOOMANYOPENFILES	EQU	(MMIOERR_BASE+15) ; no more file handles
MMIOERR_INVALIDFILE	EQU	(MMIOERR_BASE+16) ; default error file error
; MMIO constants
CFSEPCHAR	EQU	<'+'>             ; compound file name separator char.

MMIOINFO	STRUC
mmio_dwFlags	DD	?
mmio_fccIOProc	DD	?
mmio_pIOProc	DD	?
mmio_wErrorRet	DW	?
mmio_htask	DW	?
mmio_cchBuffer	DD	?
mmio_pchBuffer	DD	?
mmio_pchNext	DD	?
mmio_pchEndRead	DD	?
mmio_pchEndWrite	DD	?
mmio_lBufOffset	DD	?
mmio_lDiskOffset	DD	?
mmio_adwInfo	DD	3 DUP (?)
mmio_dwReserved1	DD	?
mmio_dwReserved2	DD	?
mmio_hmmio	DW	?
MMIOINFO	ENDS
; bit field masks
MMIO_RWMODE	EQU	00000003H      ; open file for reading/writing/both
MMIO_SHAREMODE	EQU	00000070H      ; file sharing mode number
; constants for dwFlags field of MMIOINFO
MMIO_CREATE	EQU	00001000H      ; create new file (or truncate file)
MMIO_PARSE	EQU	00000100H      ; parse new file returning path
MMIO_DELETE	EQU	00000200H      ; create new file (or truncate file)
MMIO_EXIST	EQU	00004000H      ; checks for existence of file
MMIO_ALLOCBUF	EQU	00010000H      ; mmioOpen() should allocate a buffer
MMIO_GETTEMP	EQU	00020000H      ; mmioOpen() should retrieve temp name
MMIO_DIRTY	EQU	10000000H      ; I/O buffer is dirty
; read/write mode numbers (bit field MMIO_RWMODE)
MMIO_READ	EQU	00000000H      ; open file for reading only
MMIO_WRITE	EQU	00000001H      ; open file for writing only
MMIO_READWRITE	EQU	00000002H      ; open file for reading and writing
; share mode numbers (bit field MMIO_SHAREMODE)
MMIO_COMPAT	EQU	00000000H      ; compatibility mode
MMIO_EXCLUSIVE	EQU	00000010H      ; exclusive-access mode
MMIO_DENYWRITE	EQU	00000020H      ; deny writing to other processes
MMIO_DENYREAD	EQU	00000030H      ; deny reading to other processes
MMIO_DENYNONE	EQU	00000040H      ; deny nothing to other processes
; various MMIO flags
MMIO_FHOPEN	EQU	0010H  ; mmioClose: keep file handle open
MMIO_EMPTYBUF	EQU	0010H  ; mmioFlush: empty the I/O buffer
MMIO_TOUPPER	EQU	0010H  ; mmioStringToFOURCC: to u-case
MMIO_INSTALLPROC	EQU	00010000H  ; mmioInstallIOProc: install MMIOProc
MMIO_GLOBALPROC	EQU	10000000H  ; mmioInstallIOProc: install globally
MMIO_REMOVEPROC	EQU	00020000H  ; mmioInstallIOProc: remove MMIOProc
MMIO_UNICODEPROC	EQU	01000000H  ; mmioInstallIOProc: Unicode MMIOProc
MMIO_FINDPROC	EQU	00040000H  ; mmioInstallIOProc: find an MMIOProc
MMIO_FINDCHUNK	EQU	0010H  ; mmioDescend: find a chunk by ID
MMIO_FINDRIFF	EQU	0020H  ; mmioDescend: find a LIST chunk
MMIO_FINDLIST	EQU	0040H  ; mmioDescend: find a RIFF chunk
MMIO_CREATERIFF	EQU	0020H  ; mmioCreateChunk: make a LIST chunk
MMIO_CREATELIST	EQU	0040H  ; mmioCreateChunk: make a RIFF chunk
; message numbers for MMIOPROC I/O procedure functions
MMIOM_READ	EQU	MMIO_READ       ; read
MMIOM_WRITE	EQU	MMIO_WRITE       ; write
MMIOM_SEEK	EQU	2       ; seek to a new position in file
MMIOM_OPEN	EQU	3       ; open file
MMIOM_CLOSE	EQU	4       ; close file
MMIOM_WRITEFLUSH	EQU	5       ; write and flush
MMIOM_RENAME	EQU	6       ; rename specified file
MMIOM_USER	EQU	8000H       ; beginning of user-defined messages
; flags for mmioSeek()
ifndef SEEK_SET
SEEK_SET	EQU	0               ; seek to an absolute position
SEEK_CUR	EQU	1               ; seek relative to current position
SEEK_END	EQU	2               ; seek relative to end of file
endif  ; ifndef SEEK_SET
; other constants
MMIO_DEFAULTBUFFER	EQU	8192    ; default buffer size
endif  ; ifndef _WIN32_VXD
endif                                     ;both; ifndef MMNOMMIO
ifndef MMNOMCI                                                 ;both
ifndef _WIN32_VXD
; MCI error return values
MCIERR_INVALID_DEVICE_ID	EQU	(MCIERR_BASE+1)
MCIERR_UNRECOGNIZED_KEYWORD	EQU	(MCIERR_BASE+3)
MCIERR_UNRECOGNIZED_COMMAND	EQU	(MCIERR_BASE+5)
MCIERR_HARDWARE	EQU	(MCIERR_BASE+6)
MCIERR_INVALID_DEVICE_NAME	EQU	(MCIERR_BASE+7)
MCIERR_OUT_OF_MEMORY	EQU	(MCIERR_BASE+8)
MCIERR_DEVICE_OPEN	EQU	(MCIERR_BASE+9)
MCIERR_CANNOT_LOAD_DRIVER	EQU	(MCIERR_BASE+10)
MCIERR_MISSING_COMMAND_STRING	EQU	(MCIERR_BASE+11)
MCIERR_PARAM_OVERFLOW	EQU	(MCIERR_BASE+12)
MCIERR_MISSING_STRING_ARGUMENT	EQU	(MCIERR_BASE+13)
MCIERR_BAD_INTEGER	EQU	(MCIERR_BASE+14)
MCIERR_PARSER_INTERNAL	EQU	(MCIERR_BASE+15)
MCIERR_DRIVER_INTERNAL	EQU	(MCIERR_BASE+16)
MCIERR_MISSING_PARAMETER	EQU	(MCIERR_BASE+17)
MCIERR_UNSUPPORTED_FUNCTION	EQU	(MCIERR_BASE+18)
MCIERR_FILE_NOT_FOUND	EQU	(MCIERR_BASE+19)
MCIERR_DEVICE_NOT_READY	EQU	(MCIERR_BASE+20)
MCIERR_INTERNAL	EQU	(MCIERR_BASE+21)
MCIERR_DRIVER	EQU	(MCIERR_BASE+22)
MCIERR_CANNOT_USE_ALL	EQU	(MCIERR_BASE+23)
MCIERR_MULTIPLE	EQU	(MCIERR_BASE+24)
MCIERR_EXTENSION_NOT_FOUND	EQU	(MCIERR_BASE+25)
MCIERR_OUTOFRANGE	EQU	(MCIERR_BASE+26)
MCIERR_FLAGS_NOT_COMPATIBLE	EQU	(MCIERR_BASE+28)
MCIERR_FILE_NOT_SAVED	EQU	(MCIERR_BASE+30)
MCIERR_DEVICE_TYPE_REQUIRED	EQU	(MCIERR_BASE+31)
MCIERR_DEVICE_LOCKED	EQU	(MCIERR_BASE+32)
MCIERR_DUPLICATE_ALIAS	EQU	(MCIERR_BASE+33)
MCIERR_BAD_CONSTANT	EQU	(MCIERR_BASE+34)
MCIERR_MUST_USE_SHAREABLE	EQU	(MCIERR_BASE+35)
MCIERR_MISSING_DEVICE_NAME	EQU	(MCIERR_BASE+36)
MCIERR_BAD_TIME_FORMAT	EQU	(MCIERR_BASE+37)
MCIERR_NO_CLOSING_QUOTE	EQU	(MCIERR_BASE+38)
MCIERR_DUPLICATE_FLAGS	EQU	(MCIERR_BASE+39)
MCIERR_INVALID_FILE	EQU	(MCIERR_BASE+40)
MCIERR_NULL_PARAMETER_BLOCK	EQU	(MCIERR_BASE+41)
MCIERR_UNNAMED_RESOURCE	EQU	(MCIERR_BASE+42)
MCIERR_NEW_REQUIRES_ALIAS	EQU	(MCIERR_BASE+43)
MCIERR_NOTIFY_ON_AUTO_OPEN	EQU	(MCIERR_BASE+44)
MCIERR_NO_ELEMENT_ALLOWED	EQU	(MCIERR_BASE+45)
MCIERR_NONAPPLICABLE_FUNCTION	EQU	(MCIERR_BASE+46)
MCIERR_ILLEGAL_FOR_AUTO_OPEN	EQU	(MCIERR_BASE+47)
MCIERR_FILENAME_REQUIRED	EQU	(MCIERR_BASE+48)
MCIERR_EXTRA_CHARACTERS	EQU	(MCIERR_BASE+49)
MCIERR_DEVICE_NOT_INSTALLED	EQU	(MCIERR_BASE+50)
MCIERR_GET_CD	EQU	(MCIERR_BASE+51)
MCIERR_SET_CD	EQU	(MCIERR_BASE+52)
MCIERR_SET_DRIVE	EQU	(MCIERR_BASE+53)
MCIERR_DEVICE_LENGTH	EQU	(MCIERR_BASE+54)
MCIERR_DEVICE_ORD_LENGTH	EQU	(MCIERR_BASE+55)
MCIERR_NO_INTEGER	EQU	(MCIERR_BASE+56)
MCIERR_WAVE_OUTPUTSINUSE	EQU	(MCIERR_BASE+64)
MCIERR_WAVE_SETOUTPUTINUSE	EQU	(MCIERR_BASE+65)
MCIERR_WAVE_INPUTSINUSE	EQU	(MCIERR_BASE+66)
MCIERR_WAVE_SETINPUTINUSE	EQU	(MCIERR_BASE+67)
MCIERR_WAVE_OUTPUTUNSPECIFIED	EQU	(MCIERR_BASE+68)
MCIERR_WAVE_INPUTUNSPECIFIED	EQU	(MCIERR_BASE+69)
MCIERR_WAVE_OUTPUTSUNSUITABLE	EQU	(MCIERR_BASE+70)
MCIERR_WAVE_SETOUTPUTUNSUITABLE	EQU	(MCIERR_BASE+71)
MCIERR_WAVE_INPUTSUNSUITABLE	EQU	(MCIERR_BASE+72)
MCIERR_WAVE_SETINPUTUNSUITABLE	EQU	(MCIERR_BASE+73)
MCIERR_SEQ_DIV_INCOMPATIBLE	EQU	(MCIERR_BASE+80)
MCIERR_SEQ_PORT_INUSE	EQU	(MCIERR_BASE+81)
MCIERR_SEQ_PORT_NONEXISTENT	EQU	(MCIERR_BASE+82)
MCIERR_SEQ_PORT_MAPNODEVICE	EQU	(MCIERR_BASE+83)
MCIERR_SEQ_PORT_MISCERROR	EQU	(MCIERR_BASE+84)
MCIERR_SEQ_TIMER	EQU	(MCIERR_BASE+85)
MCIERR_SEQ_PORTUNSPECIFIED	EQU	(MCIERR_BASE+86)
MCIERR_SEQ_NOMIDIPRESENT	EQU	(MCIERR_BASE+87)
MCIERR_NO_WINDOW	EQU	(MCIERR_BASE+90)
MCIERR_CREATEWINDOW	EQU	(MCIERR_BASE+91)
MCIERR_FILE_READ	EQU	(MCIERR_BASE+92)
MCIERR_FILE_WRITE	EQU	(MCIERR_BASE+93)
MCIERR_NO_IDENTITY	EQU	(MCIERR_BASE+94)
; all custom device driver errors must be >= than this value
MCIERR_CUSTOM_DRIVER_BASE	EQU	(MCIERR_BASE+256)
MCI_FIRST	EQU	DRV_MCI_FIRST   ; 0x0800
; MCI command message identifiers
MCI_OPEN	EQU	0803H
MCI_CLOSE	EQU	0804H
MCI_ESCAPE	EQU	0805H
MCI_PLAY	EQU	0806H
MCI_SEEK	EQU	0807H
MCI_STOP	EQU	0808H
MCI_PAUSE	EQU	0809H
MCI_INFO	EQU	080AH
MCI_GETDEVCAPS	EQU	080BH
MCI_SPIN	EQU	080CH
MCI_SET	EQU	080DH
MCI_STEP	EQU	080EH
MCI_RECORD	EQU	080FH
MCI_SYSINFO	EQU	0810H
MCI_BREAK	EQU	0811H
MCI_SOUND	EQU	0812H    ;internal
MCI_SAVE	EQU	0813H
MCI_STATUS	EQU	0814H
MCI_CUE	EQU	0830H
MCI_REALIZE	EQU	0840H
MCI_WINDOW	EQU	0841H
MCI_PUT	EQU	0842H
MCI_WHERE	EQU	0843H
MCI_FREEZE	EQU	0844H
MCI_UNFREEZE	EQU	0845H
MCI_LOAD	EQU	0850H
MCI_CUT	EQU	0851H
MCI_COPY	EQU	0852H
MCI_PASTE	EQU	0853H
MCI_UPDATE	EQU	0854H
MCI_RESUME	EQU	0855H
MCI_DELETE	EQU	0856H
MCI_WIN32CLIENT	EQU	0857H	;internal
; all custom MCI command messages must be >= than this value
MCI_USER_MESSAGES	EQU	(DRV_MCI_FIRST+400H)
MCI_LAST	EQU	0FFFH
MCI_ALL_DEVICE_ID	EQU	-1
; constants for predefined MCI device types
MCI_DEVTYPE_VCR	EQU	513 ; (MCI_STRING_OFFSET + 1)
MCI_DEVTYPE_VIDEODISC	EQU	514 ; (MCI_STRING_OFFSET + 2)
MCI_DEVTYPE_OVERLAY	EQU	515 ; (MCI_STRING_OFFSET + 3)
MCI_DEVTYPE_CD_AUDIO	EQU	516 ; (MCI_STRING_OFFSET + 4)
MCI_DEVTYPE_DAT	EQU	517 ; (MCI_STRING_OFFSET + 5)
MCI_DEVTYPE_SCANNER	EQU	518 ; (MCI_STRING_OFFSET + 6)
MCI_DEVTYPE_ANIMATION	EQU	519 ; (MCI_STRING_OFFSET + 7)
MCI_DEVTYPE_DIGITAL_VIDEO	EQU	520 ; (MCI_STRING_OFFSET + 8)
MCI_DEVTYPE_OTHER	EQU	521 ; (MCI_STRING_OFFSET + 9)
MCI_DEVTYPE_WAVEFORM_AUDIO	EQU	522 ; (MCI_STRING_OFFSET + 10)
MCI_DEVTYPE_SEQUENCER	EQU	523 ; (MCI_STRING_OFFSET + 11)
MCI_DEVTYPE_FIRST	EQU	MCI_DEVTYPE_VCR
MCI_DEVTYPE_LAST	EQU	MCI_DEVTYPE_SEQUENCER
MCI_DEVTYPE_FIRST_USER	EQU	1000H
; return values for 'status mode' command
MCI_MODE_NOT_READY	EQU	(MCI_STRING_OFFSET+12)
MCI_MODE_STOP	EQU	(MCI_STRING_OFFSET+13)
MCI_MODE_PLAY	EQU	(MCI_STRING_OFFSET+14)
MCI_MODE_RECORD	EQU	(MCI_STRING_OFFSET+15)
MCI_MODE_SEEK	EQU	(MCI_STRING_OFFSET+16)
MCI_MODE_PAUSE	EQU	(MCI_STRING_OFFSET+17)
MCI_MODE_OPEN	EQU	(MCI_STRING_OFFSET+18)
; constants used in 'set time format' and 'status time format' commands
MCI_FORMAT_MILLISECONDS	EQU	0
MCI_FORMAT_HMS	EQU	1
MCI_FORMAT_MSF	EQU	2
MCI_FORMAT_FRAMES	EQU	3
MCI_FORMAT_SMPTE_24	EQU	4
MCI_FORMAT_SMPTE_25	EQU	5
MCI_FORMAT_SMPTE_30	EQU	6
MCI_FORMAT_SMPTE_30DROP	EQU	7
MCI_FORMAT_BYTES	EQU	8
MCI_FORMAT_SAMPLES	EQU	9
MCI_FORMAT_TMSF	EQU	10
; flags for wParam of MM_MCINOTIFY message
MCI_NOTIFY_SUCCESSFUL	EQU	0001H
MCI_NOTIFY_SUPERSEDED	EQU	0002H
MCI_NOTIFY_ABORTED	EQU	0004H
MCI_NOTIFY_FAILURE	EQU	0008H
; common flags for dwFlags parameter of MCI command messages
MCI_NOTIFY	EQU	00000001H
MCI_WAIT	EQU	00000002H
MCI_FROM	EQU	00000004H
MCI_TO	EQU	00000008H
MCI_TRACK	EQU	00000010H
; flags for dwFlags parameter of MCI_OPEN command message
MCI_OPEN_SHAREABLE	EQU	00000100H
MCI_OPEN_ELEMENT	EQU	00000200H
MCI_OPEN_ALIAS	EQU	00000400H
MCI_OPEN_ELEMENT_ID	EQU	00000800H
MCI_OPEN_TYPE_ID	EQU	00001000H
MCI_OPEN_TYPE	EQU	00002000H
; flags for dwFlags parameter of MCI_SEEK command message
MCI_SEEK_TO_START	EQU	00000100H
MCI_SEEK_TO_END	EQU	00000200H
; flags for dwFlags parameter of MCI_STATUS command message
MCI_STATUS_ITEM	EQU	00000100H
MCI_STATUS_START	EQU	00000200H
; flags for dwItem field of the MCI_STATUS_PARMS parameter block
MCI_STATUS_LENGTH	EQU	00000001H
MCI_STATUS_POSITION	EQU	00000002H
MCI_STATUS_NUMBER_OF_TRACKS	EQU	00000003H
MCI_STATUS_MODE	EQU	00000004H
MCI_STATUS_MEDIA_PRESENT	EQU	00000005H
MCI_STATUS_TIME_FORMAT	EQU	00000006H
MCI_STATUS_READY	EQU	00000007H
MCI_STATUS_CURRENT_TRACK	EQU	00000008H
; flags for dwFlags parameter of MCI_INFO command message
MCI_INFO_PRODUCT	EQU	00000100H
MCI_INFO_FILE	EQU	00000200H
MCI_INFO_MEDIA_UPC	EQU	00000400H
MCI_INFO_MEDIA_IDENTITY	EQU	00000800H
MCI_INFO_NAME	EQU	00001000H
MCI_INFO_COPYRIGHT	EQU	00002000H
; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_ITEM	EQU	00000100H
; flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block
MCI_GETDEVCAPS_CAN_RECORD	EQU	00000001H
MCI_GETDEVCAPS_HAS_AUDIO	EQU	00000002H
MCI_GETDEVCAPS_HAS_VIDEO	EQU	00000003H
MCI_GETDEVCAPS_DEVICE_TYPE	EQU	00000004H
MCI_GETDEVCAPS_USES_FILES	EQU	00000005H
MCI_GETDEVCAPS_COMPOUND_DEVICE	EQU	00000006H
MCI_GETDEVCAPS_CAN_EJECT	EQU	00000007H
MCI_GETDEVCAPS_CAN_PLAY	EQU	00000008H
MCI_GETDEVCAPS_CAN_SAVE	EQU	00000009H
; flags for dwFlags parameter of MCI_SYSINFO command message
MCI_SYSINFO_QUANTITY	EQU	00000100H
MCI_SYSINFO_OPEN	EQU	00000200H
MCI_SYSINFO_NAME	EQU	00000400H
MCI_SYSINFO_INSTALLNAME	EQU	00000800H
; flags for dwFlags parameter of MCI_SET command message
MCI_SET_DOOR_OPEN	EQU	00000100H
MCI_SET_DOOR_CLOSED	EQU	00000200H
MCI_SET_TIME_FORMAT	EQU	00000400H
MCI_SET_AUDIO	EQU	00000800H
MCI_SET_VIDEO	EQU	00001000H
MCI_SET_ON	EQU	00002000H
MCI_SET_OFF	EQU	00004000H
; flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS
MCI_SET_AUDIO_ALL	EQU	00000000H
MCI_SET_AUDIO_LEFT	EQU	00000001H
MCI_SET_AUDIO_RIGHT	EQU	00000002H
; flags for dwFlags parameter of MCI_BREAK command message
MCI_BREAK_KEY	EQU	00000100H
MCI_BREAK_HWND	EQU	00000200H
MCI_BREAK_OFF	EQU	00000400H
; flags for dwFlags parameter of MCI_RECORD command message
MCI_RECORD_INSERT	EQU	00000100H
MCI_RECORD_OVERWRITE	EQU	00000200H
	;internal; flags for dwFlags parameter of MCI_SOUND command message
MCI_SOUND_NAME	EQU	00000100H		;internal
								;internal
; flags for dwFlags parameter of MCI_SAVE command message
MCI_SAVE_FILE	EQU	00000100H
; flags for dwFlags parameter of MCI_LOAD command message
MCI_LOAD_FILE	EQU	00000100H

MCI_GENERIC_PARMS	STRUC
mcigen_dwCallback	DD	?
MCI_GENERIC_PARMS	ENDS

MCI_OPEN_PARMS	STRUC
mciopen_dwCallback	DD	?
mciopen_wDeviceID	DW	?
mciopen_wReserved0	DW	?
mciopen_lpstrDeviceType	DD	?
mciopen_lpstrElementName	DD	?
mciopen_lpstrAlias	DD	?
MCI_OPEN_PARMS	ENDS

MCI_PLAY_PARMS	STRUC
mciplay_dwCallback	DD	?
mciplay_dwFrom	DD	?
mciplay_dwTo	DD	?
MCI_PLAY_PARMS	ENDS

MCI_SEEK_PARMS	STRUC
mciseek_dwCallback	DD	?
mciseek_dwTo	DD	?
MCI_SEEK_PARMS	ENDS

MCI_STATUS_PARMS	STRUC
mcistat_dwCallback	DD	?
mcistat_dwReturn	DD	?
mcistat_dwItem	DD	?
mcistat_dwTrack	DD	?
MCI_STATUS_PARMS	ENDS

MCI_INFO_PARMS	STRUC
mciinfo_dwCallback	DD	?
mciinfo_lpstrReturn	DD	?
mciinfo_dwRetSize	DD	?
MCI_INFO_PARMS	ENDS

MCI_GETDEVCAPS_PARMS	STRUC
mcigdc_dwCallback	DD	?
mcigdc_dwReturn	DD	?
mcigdc_dwItem	DD	?
MCI_GETDEVCAPS_PARMS	ENDS

MCI_SYSINFO_PARMS	STRUC
mcisi_dwCallback	DD	?
mcisi_lpstrReturn	DD	?
mcisi_dwRetSize	DD	?
mcisi_dwNumber	DD	?
mcisi_wDeviceType	DW	?
mcisi_wReserved0	DW	?
MCI_SYSINFO_PARMS	ENDS

MCI_SET_PARMS	STRUC
mciset_dwCallback	DD	?
mciset_dwTimeFormat	DD	?
mciset_dwAudio	DD	?
MCI_SET_PARMS	ENDS

MCI_BREAK_PARMS	STRUC
mcibreak_dwCallback	DD	?
mcibreak_nVirtKey	DW	?
mcibreak_wReserved0	DW	?
mcibreak_hwndBreak	DW	?
mcibreak_wReserved1	DW	?
MCI_BREAK_PARMS	ENDS

MCI_SAVE_PARMS	STRUC
mcisave_dwCallback	DD	?
mcisave_lpfilename	DD	?
MCI_SAVE_PARMS	ENDS

MCI_LOAD_PARMS	STRUC
mciload_dwCallback	DD	?
mciload_lpfilename	DD	?
MCI_LOAD_PARMS	ENDS

MCI_RECORD_PARMS	STRUC
mcirec_dwCallback	DD	?
mcirec_dwFrom	DD	?
mcirec_dwTo	DD	?
MCI_RECORD_PARMS	ENDS
; MCI extensions for videodisc devices
; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_STATUS_MODE)
MCI_VD_MODE_PARK	EQU	(MCI_VD_OFFSET+1)
; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE)
MCI_VD_MEDIA_CLV	EQU	(MCI_VD_OFFSET+2)
MCI_VD_MEDIA_CAV	EQU	(MCI_VD_OFFSET+3)
MCI_VD_MEDIA_OTHER	EQU	(MCI_VD_OFFSET+4)
MCI_VD_FORMAT_TRACK	EQU	4001H
; flags for dwFlags parameter of MCI_PLAY command message
MCI_VD_PLAY_REVERSE	EQU	00010000H
MCI_VD_PLAY_FAST	EQU	00020000H
MCI_VD_PLAY_SPEED	EQU	00040000H
MCI_VD_PLAY_SCAN	EQU	00080000H
MCI_VD_PLAY_SLOW	EQU	00100000H
; flag for dwFlags parameter of MCI_SEEK command message
MCI_VD_SEEK_REVERSE	EQU	00010000H
; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_VD_STATUS_SPEED	EQU	00004002H
MCI_VD_STATUS_FORWARD	EQU	00004003H
MCI_VD_STATUS_MEDIA_TYPE	EQU	00004004H
MCI_VD_STATUS_SIDE	EQU	00004005H
MCI_VD_STATUS_DISC_SIZE	EQU	00004006H
; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_VD_GETDEVCAPS_CLV	EQU	00010000H
MCI_VD_GETDEVCAPS_CAV	EQU	00020000H
MCI_VD_SPIN_UP	EQU	00010000H
MCI_VD_SPIN_DOWN	EQU	00020000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_VD_GETDEVCAPS_CAN_REVERSE	EQU	00004002H
MCI_VD_GETDEVCAPS_FAST_RATE	EQU	00004003H
MCI_VD_GETDEVCAPS_SLOW_RATE	EQU	00004004H
MCI_VD_GETDEVCAPS_NORMAL_RATE	EQU	00004005H
; flags for the dwFlags parameter of MCI_STEP command message
MCI_VD_STEP_FRAMES	EQU	00010000H
MCI_VD_STEP_REVERSE	EQU	00020000H
; flag for the MCI_ESCAPE command message
MCI_VD_ESCAPE_STRING	EQU	00000100H

MCI_VD_PLAY_PARMS	STRUC
mcivdplay_dwCallback	DD	?
mcivdplay_dwFrom	DD	?
mcivdplay_dwTo	DD	?
mcivdplay_dwSpeed	DD	?
MCI_VD_PLAY_PARMS	ENDS

MCI_VD_STEP_PARMS	STRUC
mcivdstep_dwCallback	DD	?
mcivdstep_dwFrames	DD	?
MCI_VD_STEP_PARMS	ENDS

MCI_VD_ESCAPE_PARMS	STRUC
mcivcesc_dwCallback	DD	?
mcivcesc_lpstrCommand	DD	?
MCI_VD_ESCAPE_PARMS	ENDS
; MCI extensions for CD audio devices
; flags for the dwItem field of the MCI_STATUS_PARMS parameter block
MCI_CDA_STATUS_TYPE_TRACK	EQU	00004001H
; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK)
MCI_CDA_TRACK_AUDIO	EQU	(MCI_CD_OFFSET+0)
MCI_CDA_TRACK_OTHER	EQU	(MCI_CD_OFFSET+1)
; MCI extensions for waveform audio devices
MCI_WAVE_PCM	EQU	(MCI_WAVE_OFFSET+0)
MCI_WAVE_MAPPER	EQU	(MCI_WAVE_OFFSET+1)
; flags for the dwFlags parameter of MCI_OPEN command message
MCI_WAVE_OPEN_BUFFER	EQU	00010000H
; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_FORMATTAG	EQU	00010000H
MCI_WAVE_SET_CHANNELS	EQU	00020000H
MCI_WAVE_SET_SAMPLESPERSEC	EQU	00040000H
MCI_WAVE_SET_AVGBYTESPERSEC	EQU	00080000H
MCI_WAVE_SET_BLOCKALIGN	EQU	00100000H
MCI_WAVE_SET_BITSPERSAMPLE	EQU	00200000H
; flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages
MCI_WAVE_INPUT	EQU	00400000H
MCI_WAVE_OUTPUT	EQU	00800000H
; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_WAVE_STATUS_FORMATTAG	EQU	00004001H
MCI_WAVE_STATUS_CHANNELS	EQU	00004002H
MCI_WAVE_STATUS_SAMPLESPERSEC	EQU	00004003H
MCI_WAVE_STATUS_AVGBYTESPERSEC	EQU	00004004H
MCI_WAVE_STATUS_BLOCKALIGN	EQU	00004005H
MCI_WAVE_STATUS_BITSPERSAMPLE	EQU	00004006H
MCI_WAVE_STATUS_LEVEL	EQU	00004007H
; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_ANYINPUT	EQU	04000000H
MCI_WAVE_SET_ANYOUTPUT	EQU	08000000H
; flags for the dwFlags parameter of MCI_GETDEVCAPS command message
MCI_WAVE_GETDEVCAPS_INPUTS	EQU	00004001H
MCI_WAVE_GETDEVCAPS_OUTPUTS	EQU	00004002H

MCI_WAVE_OPEN_PARMS	STRUC
mciwopen_dwCallback	DD	?
mciwopen_wDeviceID	DW	?
mciwopen_wReserved0	DW	?
mciwopen_lpstrDeviceType	DD	?
mciwopen_lpstrElementName	DD	?
mciwopen_lpstrAlias	DD	?
mciwopen_dwBufferSeconds	DD	?
MCI_WAVE_OPEN_PARMS	ENDS

MCI_WAVE_DELETE_PARMS	STRUC
mciwdel_dwCallback	DD	?
mciwdel_dwFrom	DD	?
mciwdel_dwTo	DD	?
MCI_WAVE_DELETE_PARMS	ENDS

MCI_WAVE_SET_PARMS	STRUC
mciwset_dwCallback	DD	?
mciwset_dwTimeFormat	DD	?
mciwset_dwAudio	DD	?
mciwset_wInput	DW	?
mciwset_wReserved0	DW	?
mciwset_wOutput	DW	?
mciwset_wReserved1	DW	?
mciwset_wFormatTag	DW	?
mciwset_wReserved2	DW	?
mciwset_nChannels	DW	?
mciwset_wReserved3	DW	?
mciwset_nSamplesPerSec	DW	?
mciwset_nAvgBytesPerSec	DW	?
mciwset_nBlockAlign	DW	?
mciwset_wReserved4	DW	?
mciwset_wBitsPerSample	DW	?
mciwset_wReserved5	DW	?
MCI_WAVE_SET_PARMS	ENDS
; MCI extensions for MIDI sequencer devices
; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE)
MCI_SEQ_DIV_PPQN	EQU	(0+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_24	EQU	(1+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_25	EQU	(2+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30DROP	EQU	(3+MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30	EQU	(4+MCI_SEQ_OFFSET)
; flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block
; MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER)
MCI_SEQ_FORMAT_SONGPTR	EQU	4001H
MCI_SEQ_FILE	EQU	4002H
MCI_SEQ_MIDI	EQU	4003H
MCI_SEQ_SMPTE	EQU	4004H
MCI_SEQ_NONE	EQU	65533
MCI_SEQ_MAPPER	EQU	65535
; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_SEQ_STATUS_TEMPO	EQU	00004002H
MCI_SEQ_STATUS_PORT	EQU	00004003H
MCI_SEQ_STATUS_SLAVE	EQU	00004007H
MCI_SEQ_STATUS_MASTER	EQU	00004008H
MCI_SEQ_STATUS_OFFSET	EQU	00004009H
MCI_SEQ_STATUS_DIVTYPE	EQU	0000400AH
MCI_SEQ_STATUS_NAME	EQU	0000400BH
MCI_SEQ_STATUS_COPYRIGHT	EQU	0000400CH
; flags for the dwFlags parameter of MCI_SET command message
MCI_SEQ_SET_TEMPO	EQU	00010000H
MCI_SEQ_SET_PORT	EQU	00020000H
MCI_SEQ_SET_SLAVE	EQU	00040000H
MCI_SEQ_SET_MASTER	EQU	00080000H
MCI_SEQ_SET_OFFSET	EQU	01000000H

MCI_SEQ_SET_PARMS	STRUC
mcisset_dwCallback	DD	?
mcisset_dwTimeFormat	DD	?
mcisset_dwAudio	DD	?
mcisset_dwTempo	DD	?
mcisset_dwPort	DD	?
mcisset_dwSlave	DD	?
mcisset_dwMaster	DD	?
mcisset_dwOffset	DD	?
MCI_SEQ_SET_PARMS	ENDS
; MCI extensions for animation devices
; flags for dwFlags parameter of MCI_OPEN command message
MCI_ANIM_OPEN_WS	EQU	00010000H
MCI_ANIM_OPEN_PARENT	EQU	00020000H
MCI_ANIM_OPEN_NOSTATIC	EQU	00040000H
; flags for dwFlags parameter of MCI_PLAY command message
MCI_ANIM_PLAY_SPEED	EQU	00010000H
MCI_ANIM_PLAY_REVERSE	EQU	00020000H
MCI_ANIM_PLAY_FAST	EQU	00040000H
MCI_ANIM_PLAY_SLOW	EQU	00080000H
MCI_ANIM_PLAY_SCAN	EQU	00100000H
; flags for dwFlags parameter of MCI_STEP command message
MCI_ANIM_STEP_REVERSE	EQU	00010000H
MCI_ANIM_STEP_FRAMES	EQU	00020000H
; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_ANIM_STATUS_SPEED	EQU	00004001H
MCI_ANIM_STATUS_FORWARD	EQU	00004002H
MCI_ANIM_STATUS_HWND	EQU	00004003H
MCI_ANIM_STATUS_HPAL	EQU	00004004H
MCI_ANIM_STATUS_STRETCH	EQU	00004005H
; flags for the dwFlags parameter of MCI_INFO command message
MCI_ANIM_INFO_TEXT	EQU	00010000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_ANIM_GETDEVCAPS_CAN_REVERSE	EQU	00004001H
MCI_ANIM_GETDEVCAPS_FAST_RATE	EQU	00004002H
MCI_ANIM_GETDEVCAPS_SLOW_RATE	EQU	00004003H
MCI_ANIM_GETDEVCAPS_NORMAL_RATE	EQU	00004004H
MCI_ANIM_GETDEVCAPS_PALETTES	EQU	00004006H
MCI_ANIM_GETDEVCAPS_CAN_STRETCH	EQU	00004007H
MCI_ANIM_GETDEVCAPS_MAX_WINDOWS	EQU	00004008H
; flags for the MCI_REALIZE command message
MCI_ANIM_REALIZE_NORM	EQU	00010000H
MCI_ANIM_REALIZE_BKGD	EQU	00020000H
; flags for dwFlags parameter of MCI_WINDOW command message
MCI_ANIM_WINDOW_HWND	EQU	00010000H
MCI_ANIM_WINDOW_STATE	EQU	00040000H
MCI_ANIM_WINDOW_TEXT	EQU	00080000H
MCI_ANIM_WINDOW_ENABLE_STRETCH	EQU	00100000H
MCI_ANIM_WINDOW_DISABLE_STRETCH	EQU	00200000H
; flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block
; MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND)
MCI_ANIM_WINDOW_DEFAULT	EQU	00000000H
; flags for dwFlags parameter of MCI_PUT command message
MCI_ANIM_RECT	EQU	00010000H
MCI_ANIM_PUT_SOURCE	EQU	00020000H
MCI_ANIM_PUT_DESTINATION	EQU	00040000H
; flags for dwFlags parameter of MCI_WHERE command message
MCI_ANIM_WHERE_SOURCE	EQU	00020000H
MCI_ANIM_WHERE_DESTINATION	EQU	00040000H
; flags for dwFlags parameter of MCI_UPDATE command message
MCI_ANIM_UPDATE_HDC	EQU	00020000H

MCI_ANIM_OPEN_PARMS	STRUC
mciaopen_dwCallback	DD	?
mciaopen_wDeviceID	DW	?
mciaopen_wReserved0	DW	?
mciaopen_lpstrDeviceType	DD	?
mciaopen_lpstrElementName	DD	?
mciaopen_lpstrAlias	DD	?
mciaopen_dwStyle	DD	?
mciaopen_hWndParent	DW	?
mciaopen_wReserved1	DW	?
MCI_ANIM_OPEN_PARMS	ENDS

MCI_ANIM_PLAY_PARMS	STRUC
mciaplay_dwCallback	DD	?
mciaplay_dwFrom	DD	?
mciaplay_dwTo	DD	?
mciaplay_dwSpeed	DD	?
MCI_ANIM_PLAY_PARMS	ENDS

MCI_ANIM_STEP_PARMS	STRUC
mciastep_dwCallback	DD	?
mciastep_dwFrames	DD	?
MCI_ANIM_STEP_PARMS	ENDS

MCI_ANIM_WINDOW_PARMS	STRUC
mciawin_dwCallback	DD	?
mciawin_hWnd	DW	?
mciawin_wReserved1	DW	?
mciawin_nCmdShow	DW	?
mciawin_wReserved2	DW	?
mciawin_lpstrText	DD	?
MCI_ANIM_WINDOW_PARMS	ENDS

MCI_ANIM_RECT_PARMS	STRUC
mciarect_dwCallback	DD	?
ifdef MCI_USE_OFFEXT
mciarect_ptOffset	DB	SIZE POINT DUP (?)
mciarect_ptExtent	DB	SIZE POINT DUP (?)
else	;ifdef MCI_USE_OFFEXT
mciarect_rc	DB	SIZE RECT DUP (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_ANIM_RECT_PARMS	ENDS

MCI_ANIM_UPDATE_PARMS	STRUC
mciaupd_dwCallback	DD	?
mciaupd_rc	DB	SIZE RECT DUP (?)
mciaupd_hDC	DW	?
MCI_ANIM_UPDATE_PARMS	ENDS
; MCI extensions for video overlay devices
; flags for dwFlags parameter of MCI_OPEN command message
MCI_OVLY_OPEN_WS	EQU	00010000H
MCI_OVLY_OPEN_PARENT	EQU	00020000H
; flags for dwFlags parameter of MCI_STATUS command message
MCI_OVLY_STATUS_HWND	EQU	00004001H
MCI_OVLY_STATUS_STRETCH	EQU	00004002H
; flags for dwFlags parameter of MCI_INFO command message
MCI_OVLY_INFO_TEXT	EQU	00010000H
; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_OVLY_GETDEVCAPS_CAN_STRETCH	EQU	00004001H
MCI_OVLY_GETDEVCAPS_CAN_FREEZE	EQU	00004002H
MCI_OVLY_GETDEVCAPS_MAX_WINDOWS	EQU	00004003H
; flags for dwFlags parameter of MCI_WINDOW command message
MCI_OVLY_WINDOW_HWND	EQU	00010000H
MCI_OVLY_WINDOW_STATE	EQU	00040000H
MCI_OVLY_WINDOW_TEXT	EQU	00080000H
MCI_OVLY_WINDOW_ENABLE_STRETCH	EQU	00100000H
MCI_OVLY_WINDOW_DISABLE_STRETCH	EQU	00200000H
; flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block
MCI_OVLY_WINDOW_DEFAULT	EQU	00000000H
; flags for dwFlags parameter of MCI_PUT command message
MCI_OVLY_RECT	EQU	00010000H
MCI_OVLY_PUT_SOURCE	EQU	00020000H
MCI_OVLY_PUT_DESTINATION	EQU	00040000H
MCI_OVLY_PUT_FRAME	EQU	00080000H
MCI_OVLY_PUT_VIDEO	EQU	00100000H
; flags for dwFlags parameter of MCI_WHERE command message
MCI_OVLY_WHERE_SOURCE	EQU	00020000H
MCI_OVLY_WHERE_DESTINATION	EQU	00040000H
MCI_OVLY_WHERE_FRAME	EQU	00080000H
MCI_OVLY_WHERE_VIDEO	EQU	00100000H

MCI_OVLY_OPEN_PARMS	STRUC
mcioopen_dwCallback	DD	?
mcioopen_wDeviceID	DW	?
mcioopen_wReserved0	DW	?
mcioopen_lpstrDeviceType	DD	?
mcioopen_lpstrElementName	DD	?
mcioopen_lpstrAlias	DD	?
mcioopen_dwStyle	DD	?
mcioopen_hWndParent	DW	?
mcioopen_wReserved1	DW	?
MCI_OVLY_OPEN_PARMS	ENDS

MCI_OVLY_WINDOW_PARMS	STRUC
mciowin_dwCallback	DD	?
mciowin_hWnd	DW	?
mciowin_wReserved1	DW	?
mciowin_nCmdShow	DW	?
mciowin_wReserved2	DW	?
mciowin_lpstrText	DD	?
MCI_OVLY_WINDOW_PARMS	ENDS

MCI_OVLY_RECT_PARMS	STRUC
mciorect_dwCallback	DD	?
ifdef MCI_USE_OFFEXT
mciorect_ptOffset	DB	SIZE POINT DUP (?)
mciorect_ptExtent	DB	SIZE POINT DUP (?)
else	;ifdef MCI_USE_OFFEXT
mciorect_rc	DB	SIZE RECT DUP (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_OVLY_RECT_PARMS	ENDS

MCI_OVLY_SAVE_PARMS	STRUC
mciosave_dwCallback	DD	?
mciosave_lpfilename	DD	?
mciosave_rc	DB	SIZE RECT DUP (?)
MCI_OVLY_SAVE_PARMS	ENDS

MCI_OVLY_LOAD_PARMS	STRUC
mcioload_dwCallback	DD	?
mcioload_lpfilename	DD	?
mcioload_rc	DB	SIZE RECT DUP (?)
MCI_OVLY_LOAD_PARMS	ENDS
endif  ; ifndef _WIN32_VXD
endif                                      ;both; ifndef MMNOMCI
;***************************************************************************
;	DISPLAY Driver extensions
;*************************************************************************
ifndef NEWTRANSPARENT
NEWTRANSPARENT	EQU	3           ; use with SetBkMode()
QUERYROPSUPPORT	EQU	40          ; use to determine ROP support
endif  ; ifndef NEWTRANSPARENT
;***************************************************************************
;	DIB Driver extensions
;*************************************************************************
SELECTDIB	EQU	41                      ; DIB.DRV select dib escape
ifndef SC_SCREENSAVE
SC_SCREENSAVE	EQU	0F140H
endif  ; ifndef SC_SCREENSAVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\uldiv.asm ===
page	,132
	title	uldiv - unsigned long divide routine
;***
;uldiv.asm - unsigned long divide routine
;
;	Copyright (c) 1985-1998 Microsoft Corporation
;
;Purpose:
;	defines the unsigned long divide routine
;	the following routines are created:
;	    __aFuldiv	(large, medium models)
;	    __aNuldiv	(small, compact models)
;
;*******************************************************************************

.xlist

        ?PLM = 0
        ?WIN = 1
	PMODE= 1
        memM = 1


include cmacros.inc
include cmphlp.inc
include mm.inc
.list

CreateSeg       FIXMIDI,        MidiFix, word, public, CODE

sBegin	MidiFix
	assumes cs,MidiFix
	assumes ds,data

page
;***
;uldiv - unsigned long divide
;
;Purpose:
;	Does a unsigned long divide of the arguments.  Arguments are
;	not changed.
;
;Entry:
;	Arguments are passed on the stack:
;		1st pushed: divisor (DWORD)
;		2nd pushed: dividend (DWORD)
;
;Exit:
;	DX:AX contains the quotient (dividend/divisor)
;	NOTE: this routine removes the parameters from the stack.
;
;Uses:
;	CX
;
;Exceptions:
;
;*******************************************************************************

;	ASGN	uldiv
if	sizeC
cProc	_aFuldiv,<PUBLIC>,<>

else
cProc	_aNuldiv,<PUBLIC>,<>
endif

ParmD	DVND1
ParmD   DVSR1
cBegin

	push	bx
	push	si

; Set up the local stack and save the index registers.	When this is done
; the stack frame will look as follows (assuming that the expression a/b will
; generate a call to uldiv(a, b)):
;
;		-----------------
;		|		|
;		|---------------|
;		|		|
;		|--divisor (b)--|
;		|		|
;		|---------------|
;		|		|
;		|--dividend (a)-|
;		|		|
;		|---------------|
;		| return addr** |
;		|---------------|
;	BP----->|    old BP	|
;		|---------------|
;		|      BX	|
;		|---------------|
;	SP----->|      SI	|
;		-----------------
;
; ** - 2 bytes if small/compact model; 4 bytes if medium/large model

DVND	equ	BPARGBAS[bp]	; stack address of dividend (a)
DVSR	equ	BPARGBAS+4[bp]	; stack address of divisor (b)

;
; Now do the divide.  First look to see if the divisor is less than 64K.
; If so, then we can use a simple algorithm with word divides, otherwise
; things get a little more complex.
;

	mov	ax,HIWORD(DVSR) ; check to see if divisor < 64K
	or	ax,ax
	jnz	L1		; nope, gotta do this the hard way
	mov	cx,LOWORD(DVSR) ; load divisor
	mov	ax,HIWORD(DVND) ; load high word of dividend
	xor	dx,dx
	div	cx		; get high order bits of quotient
	mov	bx,ax		; save high bits of quotient
	mov	ax,LOWORD(DVND) ; dx:ax <- remainder:lo word of dividend
	div	cx		; get low order bits of quotient
	mov	dx,bx		; dx:ax <- quotient hi:quotient lo
	jmp	short L2	; restore stack and return

;
; Here we do it the hard way.  Remember, ax contains DVSRHI
;

L1:
	mov	cx,ax		; cx:bx <- divisor
	mov	bx,LOWORD(DVSR)
	mov	dx,HIWORD(DVND) ; dx:ax <- dividend
	mov	ax,LOWORD(DVND)
L3:
	shr	cx,1		; shift divisor right one bit; hi bit <- 0
	rcr	bx,1
	shr	dx,1		; shift dividend right one bit; hi bit <- 0
	rcr	ax,1
	or	cx,cx
	jnz	L3		; loop until divisor < 64K
	div	bx		; now divide, ignore remainder
	mov	si,ax		; save quotient

;
; We may be off by one, so to check, we will multiply the quotient
; by the divisor and check the result against the orignal dividend
; Note that we must also check for overflow, which can occur if the
; dividend is close to 2**32 and the quotient is off by 1.
;

	mul	word ptr HIWORD(DVSR) ; QUOT * HIWORD(DVSR)
	xchg	cx,ax		; "mov cx,ax" but only 1 byte
	mov	ax,LOWORD(DVSR)
	mul	si		; QUOT * LOWORD(DVSR)
	add	dx,cx		; DX:AX = QUOT * DVSR
	jc	L4		; carry means Quotient is off by 1

;
; do long compare here between original dividend and the result of the
; multiply in dx:ax.  If original is larger or equal, we are ok, otherwise
; subtract one (1) from the quotient.
;

	cmp	dx,HIWORD(DVND) ; compare hi words of result and original
	ja	L4		; if result > original, do subtract
	jb	L5		; if result < original, we are ok
	cmp	ax,LOWORD(DVND) ; hi words are equal, compare lo words
	jbe	L5		; if less or equal we are ok, else subtract
L4:
	dec	si		; subtract 1 from quotient
L5:
	xor	dx,dx		; dx:ax <- quotient
	xchg	ax,si		; "mov ax,si" but only 1 byte

;
; Just the cleanup left to do.	dx:ax contains the quotient.
; Restore the saved registers and return.
;

L2:

	pop	si
	pop	bx

cEnd	<nolocals>
return	8

sEnd

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\win9x\makefile.inc ===
#
# Copyright (c) 1998-2000 Microsoft Corporation
#
#

LIBS=                                      \
    ..\..\..\public\sdk\lib16\libw.lib     \
    ..\..\..\public\sdk\lib16\mmsystem.lib \
    ..\..\..\public\sdk\lib16\kernel.lib

!if $(FREEBUILD)
DEFS=
!else
DEFS=-DDEBUG_RETAIL=1 -DDEBUG=1
!endif

CL=$(DXROOT)\public\tools\c816\bin\cl
ML=$(BASEDIR)\tools\x86\ml
THUNK=$(BASEDIR)\tools\x86\thunk
LINK=$(DXROOT)\public\tools\c816\bin\link
MAPSYM=$(DXROOT)\public\tools\c816\bin\mapsym
RC=$(DXROOT)\public\tools\c816\bin\rc

C16FLAGS=-DWIN16 -DWINVER=0x0400 /Alnw /GD -G3s -Fd$* -Fo$@ -Fc -Fl -c $(DEFS) \
    -I..\..\..\public\tools\c816\inc \
    -I..\..\..\public\sdk\inc16
AFLAGS=-D?MEDIUM -D?QUIET -c -Zm -Fo$@ $(DEFS) \
    -I..\..\..\public\sdk\inc16
RFLAGS=$(DEFS)

OBJS=                   \
    $(O)\libentry.obj   \
    $(O)\alloc.obj      \
    $(O)\debug.obj      \
    $(O)\device.obj     \
    $(O)\dmthunk.obj    \
    $(O)\dmusic16.obj   \
    $(O)\equeue.obj     \
    $(O)\list.obj       \
    $(O)\locks.obj      \
    $(O)\midiin.obj     \
    $(O)\midiout.obj    \
    $(O)\dmhelp.obj     \
    $(O)\mmdevldr.obj

$(O)\dmusic16.res: ..\dmusic16.rc
    $(DXROOT)\public\tools\c816\bin\rc \
    -I..\..\..\inc \
    -I..\..\..\public\sdk\inc16 \
    $(RFLAGS) -r -fo $@ ..\dmusic16.rc

$(O)\dmusic16.dll: $(OBJS)  $(O)\dmusic16.res
    $(LINK) @<<
$(OBJS: =+
),
$(O)\dmusic16.dll /AL:16/onerror:noexe/NODEF,
$(O)\dmusic16.map,
$(LIBS),
..\dmusic16.def
<<
    $(RC) $(O)\dmusic16.res $@
    $(MAPSYM) -o $(@:dll=sym) $(O)\dmusic16.map

$(O)\alloc.obj:    ..\alloc.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\debug.obj:    ..\debug.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\device.obj:   ..\device.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\dmusic16.obj: ..\dmusic16.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\equeue.obj:   ..\equeue.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\list.obj:     ..\list.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\locks.obj:    ..\locks.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\midiin.obj:   ..\midiin.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\midiout.obj:  ..\midiout.c
    $(CL) $(C16FLAGS) ..\$(@B).c

$(O)\dmhelp.obj:   ..\dmhelp.asm
    $(ML) $(AFLAGS) ..\$(@B).asm

$(O)\libentry.obj: ..\libentry.asm
    $(ML) $(AFLAGS) ..\$(@B).asm

$(O)\mmdevldr.obj: ..\mmdevldr.asm
    $(ML) $(AFLAGS) ..\$(@B).asm

$(O)\uldiv.obj:    ..\uldiv.asm
    $(ML) $(AFLAGS) ..\$(@B).asm


$(O)\dmthunk.obj:  $(O)\dmthunk.asm
    $(ML) -c -DIS_16 -Fo$(O)\dmthunk.obj $(O)\dmthunk.asm

$(O)\dmthunk.asm:    ..\..\dmusic32\dmthunk.thk
    $(THUNK) -o $(O)\dmthunk.asm ..\..\dmusic32\dmthunk.thk
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic16\res.h ===
/**********************************************************************

    Copyright (c) 1992-1998 Microsoft Corporation

    res.h

    DESCRIPTION:

*********************************************************************/

#ifndef _RES_
#define _RES_

#define IDS_DMUSIC16    1000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

#ifdef DBG
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);
#define Trace DebugTrace
#define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )
#else
#define Trace
#define assert(exp)	((void)0)
#endif
#endif // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMUSIC32"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\devioctl.cpp ===
// Copyright (c) 1998 Microsoft Corporation
#include <windows.h>

#include <objbase.h>
#include <assert.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "mmdevldr.h"

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"
#include "dmusic32.h"
#include "dm32p.h"

static CONST TCHAR cszMMDEVLDR[] = "\\\\.\\MMDEVLDR.VXD";

static HANDLE ghMMDEVLDR = INVALID_HANDLE_VALUE;

BOOL WINAPI OpenMMDEVLDR(
    void)
{
    ghMMDEVLDR = CreateFile(
        cszMMDEVLDR,
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    return ghMMDEVLDR != INVALID_HANDLE_VALUE;
}


VOID WINAPI CloseMMDEVLDR(
    void)
{
    if (ghMMDEVLDR != INVALID_HANDLE_VALUE)
    {
        CloseHandle(ghMMDEVLDR);
        ghMMDEVLDR = INVALID_HANDLE_VALUE;
    }
}
                          
                          

VOID WINAPI CloseVxDHandle(
    DWORD hVxDHandle)                           
{
    DWORD cb;

    DeviceIoControl(ghMMDEVLDR,
                    MMDEVLDR_IOCTL_CLOSEVXDHANDLE,
                    NULL,
                    0,
                    &hVxDHandle,
                    sizeof(hVxDHandle),
                    &cb,
                    NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\dm32dll.cpp ===
// Copyright (c) 1998 Microsoft Corporation
// dm32dll.cpp
//
// Dll entry points 
//
#include <objbase.h>
#include <assert.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"
#include "debug.h"

#include "dmusic32.h"
#include "dm32p.h"

// Globals
//

// Dll's hModule
//
HMODULE g_hModule = NULL;

extern "C" BOOL PASCAL dmthunk_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);

static CONST TCHAR pszDll16[] = "DMUSIC16.DLL";
static CONST TCHAR pszDll32[] = "DMUSIC32.DLL";

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

// Standard Win32 DllMain
//
BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    OSVERSIONINFO osvi;
    HANDLE ph;
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        Trace(2, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        Trace(2, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif
                if (!DisableThreadLibraryCalls(hModule))
                {
                    Trace(0, "DisableThreadLibraryCalls failed.\n");
                }

                if (!OpenMMDEVLDR())
                {
                    Trace(0, "OpenMMDEVLDR failed.\n");
                }
            }
            break;

        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                Trace(1, "Last process detach\n");
                CloseMMDEVLDR();
            }
            break;

        default:
            Trace(-1, "Got a non-process at/detach!\n");
            break;
    }


    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = hModule;

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        if (osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS)
        {
            return FALSE;
        }
    }


    if (!dmthunk_ThunkConnect32(pszDll16, pszDll32, hModule, dwReason))
    {
        Trace(-1, "Could not connect to thunk layer! - not loading.\n");
        return FALSE;
    }       

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\dmthunk.h ===
// Copyright (c) 1998 Microsoft Corporation
/*
 * Prototypes for thunked functions between DMusic32.dll and DMusic16.dll
 */
#ifndef _DMTHUNK_
#define _DMTHUNK_

#ifdef __cplusplus
extern "C" {
#endif

extern void PASCAL dmUntileBuffer(DWORD dwTilingInfo);
extern DWORD PASCAL dmTileBuffer(DWORD dwFlatMemory, DWORD dwLength);
extern MMRESULT PASCAL OpenLegacyDevice(DWORD dwId, BOOL fIsOutput, BOOL fShare, HANDLE *pHandle);
extern MMRESULT PASCAL CloseLegacyDevice(HANDLE h);
extern MMRESULT PASCAL ActivateLegacyDevice(HANDLE h, DWORD fActivate);

extern MMRESULT PASCAL MidiOutSubmitPlaybackBuffer(HANDLE hMidiOut, DWORD pbBuffer, DWORD cbBuffer, DWORD msStartTime,
												   DWORD rtStartTimeLow, DWORD rtStartTimeHigh);

extern MMRESULT PASCAL MidiInSetEventHandle(HANDLE hMidiIn, DWORD hEvent);
extern MMRESULT PASCAL MidiInRead(HANDLE hMidiIn, DWORD pbBuffer, DWORD *cbBuffer, DWORD *msStartTime);
extern MMRESULT PASCAL MidiInThru(HANDLE hMidiIn, DWORD dwFrom, DWORD dwTo, HANDLE hMidiOut);

#ifdef __cplusplus
};
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\enumport.cpp ===
// Copyright (c) 1998 Microsoft Corporation
#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include <regstr.h>

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"

#include "dmusic32.h"


// @globalv Registry location of legacy driver port definitions
const char cszPortsRoot[] = REGSTR_PATH_PRIVATEPROPERTIES "\\Midi\\Ports";

// @mfunc:(INTERNAL) Update the port list with legacy devices enumerated via 
// the WinMM MIDI API.
//
// @rdesc Returns one of the following:
//
// @flag S_OK | On success
// @flag S_FALSE | If there were no devices found
// @flag E_OUTOFMEMORY | If there was insufficient memory to build the port list
//
//
HRESULT EnumLegacyDevices(
    LPVOID pInstance,
    PORTENUMCB cb)                          
{
    MIDIOUTCAPS moc;
    MIDIINCAPS mic;
    int idxDev;
    int cDev;
    UINT cAdded;
    HRESULT hr;
    HKEY hkPortsRoot;
    DMUS_PORTCAPS dmpc;

    // Initialize caps with stuff that doesn't change
    //
    ZeroMemory(&dmpc, sizeof(dmpc));
    dmpc.dwSize = sizeof(dmpc);
    dmpc.dwMaxChannelGroups = 1;


    // Try to open the port registry key. We will continue even if this fails and use
    // non-persistent GUID's.
    //
    if (RegCreateKey(HKEY_LOCAL_MACHINE, cszPortsRoot, &hkPortsRoot))
    {
        hkPortsRoot = NULL;
    }

    cAdded = 0;
    
    // MIDI output devices
    //
    // Starts at -1 == MIDI mapper
    //
    cDev = (int)midiOutGetNumDevs();
    for (idxDev = -1; idxDev < cDev; ++idxDev)
    {
        if (midiOutGetDevCaps((UINT)idxDev, &moc, sizeof(moc)))
        {
            continue;
        }

        // NOTE: Since this DLL is only Win9x, we know that moc.szPname
        // is from midiOutGetDevCapsA
        //
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            moc.szPname,
            -1,
            dmpc.wszDescription,
            sizeof(dmpc.wszDescription));

        dmpc.dwClass = DMUS_PC_OUTPUTCLASS;
        dmpc.dwType  = DMUS_PORT_WINMM_DRIVER;
        dmpc.dwFlags = DMUS_PC_SHAREABLE;

        if (moc.wTechnology == MOD_MIDIPORT)
        {
            dmpc.dwFlags |= DMUS_PC_EXTERNAL;
        }
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,
                   -1,          
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    // MIDI input devices
    //
    // NOTE: Starts at 0, no input mapper
    //
    cDev = (int)midiInGetNumDevs();
    for (idxDev = 0; idxDev < cDev; ++idxDev)
    {
        if (midiInGetDevCaps((UINT)idxDev, &mic, sizeof(mic)))
        {
            continue;
        }
                   
        MultiByteToWideChar(
            CP_OEMCP,
            0,
            mic.szPname,
            -1,
            dmpc.wszDescription,
            sizeof(dmpc.wszDescription));

        
        dmpc.dwClass = DMUS_PC_INPUTCLASS;
        dmpc.dwFlags = DMUS_PC_EXTERNAL;
        
        hr = (*cb)(pInstance,
                   dmpc,
                   ptLegacyDevice,
                   idxDev,
                   -1,        // PinID -1 flags as legacy device
                   -1,
                   hkPortsRoot);
        if (SUCCEEDED(hr))
        {
            ++cAdded;
        }
        else if (hr == E_OUTOFMEMORY)
        {
            return hr;
        }
    }

    if (hkPortsRoot)
    {
        RegCloseKey(hkPortsRoot);
    }

    return cAdded ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\dmusic32.h ===
// Copyright (c) 1998 Microsoft Corporation
//
    //
//
#ifndef _DMUSIC32_
#define _DMUSIC32_

typedef HRESULT (*PORTENUMCB)(
    LPVOID pInstance,          // @parm Callback instance data
    DMUS_PORTCAPS &dmpc,                              
    PORTTYPE pt,                              
    int idxDev,                // @parm The WinMM or SysAudio device ID of this driver
    int idxPin,                // @parm The Pin ID of the device or -1 if the device is a legacy device
    int idxNode,               // @parm The node ID of the device's synth node (unused for legacy)
    HKEY hkPortsRoot);         // @parm Where port information is stored in the registry


extern HRESULT EnumLegacyDevices(
    LPVOID pInstance,          // @parm Callback instance data
    PORTENUMCB cb);            // @parm Pointer to callback function

typedef HRESULT (__stdcall *PENUMLEGACYDEVICES)(
    LPVOID pInstance,          // @parm Callback instance data
    PORTENUMCB cb);            // @parm Pointer to callback function

extern HRESULT CreateCDirectMusicEmulatePort(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    LPDMUS_PORTPARAMS pPortParams,
    IDirectMusicPort **pPort);

typedef HRESULT (__stdcall *PCREATECDIRECTMUSICEMULATEPORT)(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    LPDMUS_PORTPARAMS pPortParams,
    IDirectMusicPort **pPort);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\dmeport.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmeport.cpp
//
// CDirectMusicEmulatePort
// Implements the MMSYSTEM API version of IDirectMusicPort.
//
#define INITGUID
#include <objbase.h>
#include <ks.h>
#include <ksproxy.h>
#include <assert.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusicc.h"
#include "..\dmusic\dmusicp.h"
#include "debug.h"
#include "dmusic32.h"
#include "dm32p.h"
#include "dmthunk.h"
#include "..\shared\validate.h"

#include <ks.h>             // KSDATAFORMAT_SUBTYPE_MIDI

#pragma warning(disable:4530)

#define CLOCK_UPDATE_INTERVAL   100         // milliseconds

#define MS_TO_REFERENCE_TIME    (10 * 1000)

static HRESULT MMRESULTToHRESULT(
    MMRESULT mmr);

static DWORD InputWorker(LPVOID lpv);

// @func API call into DLL to get a new port
//
HRESULT
CreateCDirectMusicEmulatePort(
    PORTENTRY *pPE,
    CDirectMusic *pDM,
    LPDMUS_PORTPARAMS pPortParams,
    CDirectMusicEmulatePort **pPort)
{
    HRESULT hr;
    
    *pPort = new CDirectMusicEmulatePort(pPE, pDM);
    if (NULL == *pPort)
    {
        return E_OUTOFMEMORY;
    }

    hr = (*pPort)->Init(pPortParams);
    if (!SUCCEEDED(hr))
    {
        delete *pPort;
        *pPort = NULL;
        return hr;
    }

    return hr;
}
   

// @mfunc Constructor for CDirectMusicEmulatePort
//
CDirectMusicEmulatePort::CDirectMusicEmulatePort(
                                                 PORTENTRY *pPE,    // @parm The portentry of this device
                                                 CDirectMusic *pDM):// @parm The CDirectMusic implementation which created this port
                                                 m_cRef(1),
                                                 m_id(pPE->idxDevice),
                                                 m_pDM(pDM),
                                                 m_hKillThreads(NULL),
                                                 m_hDataReady(NULL),
                                                 m_hAppEvent(NULL),
                                                 m_dwWorkBufferTileInfo(0),
                                                 m_pThruBuffer(NULL),
                                                 m_pThruMap(NULL),
                                                 m_lActivated(0),
                                                 m_hCaptureThread(NULL),
                                                 m_pMasterClock(NULL),
                                                 m_fCSInitialized(FALSE)
{
    m_fIsOutput = (pPE->pc.dwClass == DMUS_PC_OUTPUTCLASS) ? TRUE : FALSE;
    m_hDevice = NULL;
    m_pLatencyClock = NULL;
    dmpc = pPE->pc;
}

// @mfunc Destructor for CDirectMusicEmulatePort
//
CDirectMusicEmulatePort::~CDirectMusicEmulatePort()
{
    Close();
}

// @mfunc Initialization of CDirectMusicEmulatePort
//
// @comm Call through the thunk layer to open the requested device. 
//

// Flags we recognize 
//
#define DMUS_ALL_FLAGS (DMUS_PORTPARAMS_VOICES |            \
                        DMUS_PORTPARAMS_CHANNELGROUPS |     \
                        DMUS_PORTPARAMS_AUDIOCHANNELS |     \
                        DMUS_PORTPARAMS_SAMPLERATE |        \
                        DMUS_PORTPARAMS_EFFECTS |           \
                        DMUS_PORTPARAMS_SHARE)

// Of those, which do we actually look at?
//
#define DMUS_SUP_FLAGS (DMUS_PORTPARAMS_CHANNELGROUPS |     \
                        DMUS_PORTPARAMS_SHARE)

HRESULT
CDirectMusicEmulatePort::Init(
    LPDMUS_PORTPARAMS pPortParams)
{
    MMRESULT mmr;
    HRESULT hr;
    BOOL fChangedParms;

    // Get, but don't hold onto, the notification interface
    //
    hr = m_pDM->QueryInterface(IID_IDirectMusicPortNotify, (void**)&m_pNotify);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pNotify->Release();

    // Munge the portparams to match what we support.
    //
    fChangedParms = FALSE;
    if (pPortParams->dwValidParams & ~DMUS_ALL_FLAGS) 
    {
        Trace(0, "Undefined flags in port parameters: %08X\n", pPortParams->dwValidParams & ~DMUS_ALL_FLAGS);
        // Flags set we don't recognize.
        //
        pPortParams->dwValidParams &= DMUS_ALL_FLAGS;
        fChangedParms = TRUE;
    }

    // We recognize these flags but don't support them.
    //
    if (pPortParams->dwValidParams & ~DMUS_SUP_FLAGS)
    {
        pPortParams->dwValidParams &= DMUS_SUP_FLAGS;
        fChangedParms = TRUE;
    }

    // Channel groups better be one.
    //
    if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
    {
        if (pPortParams->dwChannelGroups != 1)
        {
            pPortParams->dwChannelGroups = 1;
            fChangedParms = TRUE;
        }
    }
    else
    {
        pPortParams->dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
        pPortParams->dwChannelGroups = 1;
    }

    BOOL fShare = FALSE;
    if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE)
    {
        if (m_fIsOutput)
        {
            fShare = pPortParams->fShare;
        }
        else
        {
            pPortParams->fShare = FALSE;
            fChangedParms = TRUE;
        }
    }
    else
    {
        pPortParams->dwValidParams |= DMUS_PORTPARAMS_SHARE;
        pPortParams->fShare = fShare;
    }

    mmr = OpenLegacyDevice(m_id, m_fIsOutput, fShare, &m_hDevice);
    if (mmr)
    {
        return MMRESULTToHRESULT(mmr);
    }

    // Set up the master clock and our latency clock
    //
    hr = InitializeClock();
    if (FAILED(hr))
    {
        return hr;
    }

    // If an input port, initialize capture specific stuff like thruing
    //    
    if (!m_fIsOutput)
    {
        hr = InitializeCapture();
        if (FAILED(hr))
        {  
            return hr;
        }
    }

    return fChangedParms ? S_FALSE : S_OK;
}

HRESULT CDirectMusicEmulatePort::InitializeClock()
{
    HRESULT hr;
    GUID guidMasterClock;
    DWORD dwThreadID;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;

    hr = m_pDM->GetMasterClock(&guidMasterClock, &m_pMasterClock);
    if (FAILED(hr))
    {
        return hr;
    }

    m_pLatencyClock = new CEmulateLatencyClock(m_pMasterClock);

    if (NULL == m_pLatencyClock)
    {
        return E_OUTOFMEMORY;
    }

#if 0
    if (guidMasterClock == GUID_SysClock)
    {
        m_fSyncToMaster = FALSE;
        return S_OK;
    }
#endif

    m_fSyncToMaster = TRUE;
    // Read both clocks 
    //
    hr = m_pMasterClock->GetTime(&rtMasterClock);
    rtSlaveClock = MS_TO_REFERENCE_TIME * ((ULONGLONG)timeGetTime());
    
    if (FAILED(hr))
    {
        return hr;
    }

    m_lTimeOffset = rtMasterClock - rtSlaveClock;

    return S_OK;
}

HRESULT CDirectMusicEmulatePort::InitializeCapture()
{
    HRESULT hr;
    MMRESULT mmr;
    DWORD dwThreadID;

    // Allocate thru map for 16 channels, since we only have one channel group
    // Initialize to no thruing (destination port is NULL).
    //
    m_pThruMap = new DMUS_THRU_CHANNEL[MIDI_CHANNELS];
    ZeroMemory(m_pThruMap, MIDI_CHANNELS * sizeof(DMUS_THRU_CHANNEL));

    // Create thruing buffer
    //
    // XXX Defer this until the first call to thru?
    //
    // Note: guaranteed by dmusic16 this is the biggest event ever to be returned
    // (thunk api asking?)
    //
    DMUS_BUFFERDESC dmbd;
    ZeroMemory(&dmbd, sizeof(dmbd));
    dmbd.dwSize = sizeof(dmbd);
    dmbd.cbBuffer = 4096;               // XXX Where should we get this???

    hr = m_pDM->CreateMusicBuffer(&dmbd, &m_pThruBuffer, NULL);
    if (FAILED(hr))
    {
        Trace(0, "Failed to create thruing buffer\n");
        return hr;
    }

    // Create events
    //
    m_hDataReady = CreateEvent(NULL,        // Event attributes
                               FALSE,       // Manual reset
                               FALSE,       // Not signalled
                               NULL);       // Name

    m_hKillThreads = CreateEvent(NULL,       // Event attributes
                                 FALSE,      // Manual reset
                                 FALSE,      // Not signalled
                                 NULL);      // Name

    if (m_hDataReady == (HANDLE)NULL || m_hKillThreads == (HANDLE)NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Set our data ready event for dmusic16 
    //
    m_hVxDEvent = OpenVxDHandle(m_hDataReady);

    Trace(2, "Setting event handle; hDevice %08x hEvent=%08X hVxDEvent=%08X\n",
          (DWORD)m_hDevice,
          (DWORD)m_hDataReady,
          (DWORD)m_hVxDEvent);
    
    mmr = MidiInSetEventHandle(m_hDevice, m_hVxDEvent);
    if (mmr)
    {
        Trace(0, "MidiInSetEventHandle returned [%d]\n", mmr);
        return MMRESULTToHRESULT(mmr);
    }

    // Create a tiling for our work buffer so we only need to do it once
    //
    m_dwWorkBufferTileInfo = dmTileBuffer((DWORD)m_WorkBuffer, sizeof(m_WorkBuffer));
    m_p1616WorkBuffer = TILE_P1616(m_dwWorkBufferTileInfo);
    if (m_p1616WorkBuffer == NULL)
    {
        Trace(0, "Could not tile work buffer\n");
        return E_OUTOFMEMORY;
    }

    // Initialize cs to protect event queues.
    //
    // Unfortunately this can throw an exception if out of memory.
    //
    _try 
    {
        InitializeCriticalSection(&m_csEventQueues);
    } 
    _except (EXCEPTION_EXECUTE_HANDLER) 
    {
        return E_OUTOFMEMORY;
    }
    
    m_fCSInitialized = TRUE;

    m_hCaptureThread = CreateThread(NULL,          // Thread attributes
                                    0,             // Stack size
                                    ::InputWorker,
                                    this,
                                    0,             // Flags
                                    &dwThreadID);
    if (m_hCaptureThread == NULL)
    {
        Trace(0, "CreateThread failed with error %d\n", GetLastError());
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

static DWORD WINAPI InputWorker(LPVOID lpv)
{
    CDirectMusicEmulatePort *pPort = (CDirectMusicEmulatePort*)lpv;

    return pPort->InputWorker();
}



// @mfunc
//
// @comm Standard QueryInterface
//
STDMETHODIMP
CDirectMusicEmulatePort::QueryInterface(const IID &iid,
                                        void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicPort)
    {
        *ppv = static_cast<IDirectMusicPort*>(this);
    }
    else if (iid == IID_IDirectMusicPortP)
    {
        *ppv = static_cast<IDirectMusicPortP*>(this);
    }
    else if (iid == IID_IDirectMusicPortPrivate)
    {
        *ppv = static_cast<IDirectMusicPortPrivate*>(this);
    }
    else if (iid == IID_IKsControl)
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else if (iid == IID_IDirectMusicThru)
    {
        *ppv = static_cast<IDirectMusicThru*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


// CDirectMusicEmulatePort::AddRef
//
STDMETHODIMP_(ULONG)
CDirectMusicEmulatePort::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectMusicEmulatePort::Release
//
STDMETHODIMP_(ULONG)
CDirectMusicEmulatePort::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        if (m_pNotify)
        {
            m_pNotify->NotifyFinalRelease(static_cast<IDirectMusicPort*>(this));
        }
        
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicEmulatePort::Compact

STDMETHODIMP
CDirectMusicEmulatePort::Compact()
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicEmulatePort::GetCaps

STDMETHODIMP
CDirectMusicEmulatePort::GetCaps(
    LPDMUS_PORTCAPS pPortCaps)
{
    V_INAME(IDirectMusicPort::GetCaps);
    V_STRUCTPTR_WRITE(pPortCaps, DMUS_PORTCAPS);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    CopyMemory(pPortCaps, &dmpc, sizeof(DMUS_PORTCAPS));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicEmulatePort::DeviceIoControl

STDMETHODIMP 
CDirectMusicEmulatePort::DeviceIoControl(
    DWORD dwIoControlCode, 
    LPVOID lpInBuffer, 
    DWORD nInBufferSize, 
    LPVOID lpOutBuffer, 
    DWORD nOutBufferSize, 
    LPDWORD lpBytesReturned, 
    LPOVERLAPPED lpOverlapped)
{
    return E_NOTIMPL;
}


STDMETHODIMP
CDirectMusicEmulatePort::SetNumChannelGroups(
    DWORD   dwNumChannelGroups)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (dwNumChannelGroups != 1)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::GetNumChannelGroups(
    LPDWORD   pdwChannelGroups)
{
    V_INAME(IDirectMusicPort::GetNumChannelGroups);
    V_PTR_WRITE(pdwChannelGroups, DWORD);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    *pdwChannelGroups = 1;
    
    return S_OK;
}




// @mfunc Queue a buffer for playback
//
#define REFTIME_TO_MS (10L*1000L)

STDMETHODIMP
CDirectMusicEmulatePort::PlayBuffer(
    IDirectMusicBuffer *pIBuffer)
{
    CDirectMusicBuffer *pBuffer = reinterpret_cast<CDirectMusicBuffer *>(pIBuffer);

    REFERENCE_TIME rt;
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  dwTileInfo;
    LONGLONG msTime;
    MMRESULT mmr;

    V_INAME(IDirectMusicPort::PlayBuffer);
    V_INTERFACE(pIBuffer);
    
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (!m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    if (!m_lActivated)
    {
        return DMUS_E_SYNTHINACTIVE;
    }
    
    // Make sure the object doesn't disappear out from under us while we're in Win16
    //
    pBuffer->AddRef();
    pBuffer->GetUsedBytes(&cbData);
    if (cbData == 0)
    {
        pBuffer->Release();
        return S_OK;
    }

    pBuffer->GetRawBufferPtr(&pbData);
    assert(pbData);
    pBuffer->GetStartTime(&rt);

    // Adjust timebase if we are not using the timeGetTime clock
    //

    Trace(2, "Buffer base time %I64d timeGetTime %u\n", rt, timeGetTime());
    SyncClocks();
    MasterToSlave(&rt);
    Trace(2, "Buffer adjusted base time %I64d\n", rt);



    msTime = rt / REFTIME_TO_MS;

    // Send it through the thunk
    //
    dwTileInfo = dmTileBuffer((DWORD)pbData, cbData);
    mmr = MidiOutSubmitPlaybackBuffer(m_hDevice,
                               TILE_P1616(dwTileInfo),
                               cbData,
                               (DWORD)msTime,
                               (DWORD)(rt & 0xFFFFFFFF),                  // RefTime low
                               (DWORD)((rt >> 32) & 0xFFFFFFFF));       // RefTime high
    dmUntileBuffer(dwTileInfo);

    pBuffer->Release();
    
    return MMRESULTToHRESULT(mmr);
}

STDMETHODIMP
CDirectMusicEmulatePort::Read(
    IDirectMusicBuffer *pIBuffer)
{
    HRESULT hr;
    
    V_INAME(IDirectMusicPort::Read);
    V_INTERFACE(pIBuffer);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    LPBYTE pbBuffer;
    hr = pIBuffer->GetRawBufferPtr(&pbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD cbBuffer;
    hr = pIBuffer->GetMaxBytes(&cbBuffer);
    if (FAILED(hr))
    {
        return hr;
    }

    Trace(1, "Read: buffer size %u\n", cbBuffer);

    LPBYTE pbData = pbBuffer;

    // Since events are now buffered, we read them out of the local queue
    //
    //
    EnterCriticalSection(&m_csEventQueues);

    REFERENCE_TIME rtStart;

    if (m_ReadEvents.pFront)
    {
        rtStart = m_ReadEvents.pFront->e.rtDelta;
    }
    else
    {
        Trace(2, "Read: No events queued\n");
    }

    while (m_ReadEvents.pFront)
    {               
        QUEUED_EVENT *pQueuedEvent = m_ReadEvents.pFront;

        DWORD cbQueuedEvent = DMUS_EVENT_SIZE(pQueuedEvent->e.cbEvent);
        Trace(2, "Read: cbEvent %u  cbQueuedEvent %u\n", 
            pQueuedEvent->e.cbEvent,
            cbQueuedEvent);

        if (cbQueuedEvent > cbBuffer)
        {
            Trace(2, "Read: No more room for events in buffer.\n");
            break;
        }

        Trace(2, "Read: Got an event!\n");

        pQueuedEvent->e.rtDelta -= rtStart;

        CopyMemory(pbData, 
                   &pQueuedEvent->e,
                   sizeof(DMEVENT) - sizeof(DWORD) + pQueuedEvent->e.cbEvent);

        pbData += cbQueuedEvent;
        cbBuffer -= cbQueuedEvent;

        m_ReadEvents.pFront = pQueuedEvent->pNext;

        if (pQueuedEvent->e.cbEvent <= sizeof(DWORD))
        {
            // This event came out of the pool
            //
            m_FreeEvents.Free(pQueuedEvent);
        }
        else
        {
            // This event was allocated via new char[]
            //
            char *pOriginalMemory = (char*)pQueuedEvent;
            delete[] pOriginalMemory;
        }
    }

    if (m_ReadEvents.pFront == NULL)
    {
        m_ReadEvents.pRear = NULL;
    }

    LeaveCriticalSection(&m_csEventQueues);

    // Update the buffer header information to match the events just packed
    //
    Trace(2, "Read: Leaving with %u bytes in buffer\n", (unsigned)(pbData - pbBuffer));
    pIBuffer->SetStartTime(rtStart);
    pIBuffer->SetUsedBytes(pbData - pbBuffer);

    return (pbData == pbBuffer) ? S_FALSE : S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::SetReadNotificationHandle(
    HANDLE hEvent)
{
    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }

    m_hAppEvent = hEvent;

    return S_OK;    
}

STDMETHODIMP
CDirectMusicEmulatePort::DownloadInstrument(
    IDirectMusicInstrument *pInstrument,
    IDirectMusicDownloadedInstrument **pDownloadedInstrument,
    DMUS_NOTERANGE *pRange,
    DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicEmulatePort::UnloadInstrument(
    IDirectMusicDownloadedInstrument *pDownloadedInstrument)
{
    V_INAME(IDirectMusicPort::UnloadInstrument);
    V_INTERFACE(pDownloadedInstrument);

    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicEmulatePort::GetLatencyClock(
    IReferenceClock **ppClock)
{
    V_INAME(IDirectMusicPort::GetLatencyClock);
    V_PTRPTR_WRITE(ppClock);

    if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    m_pLatencyClock->AddRef();
    *ppClock = m_pLatencyClock;
    return S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::GetRunningStats(
    LPDMUS_SYNTHSTATS pStats)
{
    V_INAME(IDirectMusicPort::GetRunningStats);
    V_STRUCTPTR_WRITE(pStats, DMUS_SYNTHSTATS);

    return E_NOTIMPL;
}

STDMETHODIMP
CDirectMusicEmulatePort::Activate(
    BOOL fActivate)
{
    MMRESULT mmr;

	V_INAME(IDirectMusicPort::Activate);
	
	if (!m_pDM)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }

    if (fActivate)
    {
        if (InterlockedExchange(&m_lActivated, 1)) 
        {
            Trace(0, "Activate: Already active\n");
            // Already activated
            //
            return S_FALSE;
        }    

        mmr = ActivateLegacyDevice(m_hDevice, TRUE);
        if (mmr)
        {
            Trace(0, "Activate: Activate mmr %d\n", mmr);
            m_lActivated = 0;
        }
    }
    else
    {
        if (InterlockedExchange(&m_lActivated, 0) == 0)
        {
            Trace(0, "Activate: Already inactive\n");
            // Already deactivated
            //
            return S_FALSE;
        }

        mmr = ActivateLegacyDevice(m_hDevice, FALSE);
        if (mmr)
        {
            Trace(0, "Activate: Deactivate mmr %d\n", mmr);
            m_lActivated = 1;
        }
    }

    return MMRESULTToHRESULT(mmr);
}

STDMETHODIMP 
CDirectMusicEmulatePort::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    return E_NOTIMPL;
}
    
STDMETHODIMP 
CDirectMusicEmulatePort::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    return E_NOTIMPL;
}    


STDMETHODIMP
CDirectMusicEmulatePort::Close()
{
    if (m_hCaptureThread)
    {
        SetEvent(m_hKillThreads);
        if (WaitForSingleObject(m_hCaptureThread, THREAD_KILL_TIMEOUT) == WAIT_TIMEOUT)
        {
            Trace(0, "Warning: Input thread timed out; exit anyway.\n");
        }

        m_hCaptureThread = NULL;
    }

    if (m_pThruMap)
    {
        for (int iChannel = 0; iChannel < 16; iChannel++)
        {
            if (m_pThruMap[iChannel].pDestinationPort == NULL)
            {
                continue;
            }

            if (m_pThruMap[iChannel].fThruInWin16)
            {
                MMRESULT mmr = MidiInThru(m_hDevice,
                                          (DWORD)iChannel,
                                          0,
                                          NULL);
            }

            m_pThruMap[iChannel].pDestinationPort->Release();
        }

        delete[] m_pThruMap;
        m_pThruMap = NULL;
    }

    if (m_pThruBuffer)
    {
        m_pThruBuffer->Release();
        m_pThruBuffer = NULL;
    }

    if (m_hDataReady)
    {
        CloseHandle(m_hDataReady);
        m_hDataReady = NULL;
    }

    if (m_hKillThreads)
    {
        CloseHandle(m_hKillThreads);
        m_hKillThreads = NULL;
    }

    if (m_hAppEvent)
    {
        m_hAppEvent = NULL;
    }

    if (m_dwWorkBufferTileInfo)
    {
        dmUntileBuffer(m_dwWorkBufferTileInfo);
        m_dwWorkBufferTileInfo = 0;
        m_p1616WorkBuffer = NULL; 
    }

    if (m_hVxDEvent)
    {
        CloseVxDHandle(m_hVxDEvent);
        m_hVxDEvent = NULL;
    }
    
    if (m_hDevice)
    {
        CloseLegacyDevice(m_hDevice);
        m_hDevice = NULL;
    }

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pLatencyClock)
    {
        m_pLatencyClock->Close();
        m_pLatencyClock->Release();
        m_pLatencyClock = NULL;
    }

    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_csEventQueues);
    }

    m_pDM = NULL;
    m_pNotify = NULL;

    
    return S_OK;
}

STDMETHODIMP
CDirectMusicEmulatePort::Report()
{
    return S_OK;
}

// StartVoice and StopVoice don't work on legacy devices
//
STDMETHODIMP CDirectMusicEmulatePort::StartVoice(          
     DWORD dwVoiceId,
     DWORD dwChannel,
     DWORD dwChannelGroup,
     REFERENCE_TIME rtStart,
     DWORD dwDLId,
     LONG prPitch,
     LONG veVolume,
     SAMPLE_TIME stVoiceStart,
     SAMPLE_TIME stLoopStart,
     SAMPLE_TIME stLoopEnd)
{
    return E_NOTIMPL;
}    

STDMETHODIMP CDirectMusicEmulatePort::StopVoice(
     DWORD dwVoiceID,
     REFERENCE_TIME rtStop)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDirectMusicEmulatePort::GetVoiceState(   
     DWORD dwVoice[], 
     DWORD cbVoice,
     DMUS_VOICE_STATE VoiceState[])
{
    return E_NOTIMPL;
}
    
STDMETHODIMP CDirectMusicEmulatePort::Refresh(
     DWORD dwDownloadID,
     DWORD dwFlags)
{
    return E_NOTIMPL;
}


// CDirectMusicEmulatePort::ThruChannel
//
STDMETHODIMP 
CDirectMusicEmulatePort::ThruChannel(
    DWORD dwSourceChannelGroup, 
    DWORD dwSourceChannel, 
    DWORD dwDestinationChannelGroup,
    DWORD dwDestinationChannel,
    LPDIRECTMUSICPORT pDestinationPort)
{
    V_INAME(IDirectMusicPort::Thru);
    V_INTERFACE_OPT(pDestinationPort);

    if (m_fIsOutput)
    {
        return E_NOTIMPL;
    }    

    // Channel group must not be zero (broadcast) but in range 1..NumChannelGroups]
    // (which for legacy is always 1)
    //
    if (dwSourceChannelGroup != 1 ||
        dwSourceChannel > 15)
    {
        return E_INVALIDARG;
    }
    
    // Given a port means enable thruing for this channel; NULL means
    // disable.
    //
    if (pDestinationPort)
    {
        // Enabling thruing on this channel. First look at the destination port.
        //
        DMUS_PORTCAPS dmpc;
        dmpc.dwSize = sizeof(dmpc);
        HRESULT hr = pDestinationPort->GetCaps(&dmpc);
        if (FAILED(hr))
        {
            Trace(0, "ThruChannel: Destination port failed portcaps [%08X]\n", hr);
            return hr;
        }

        // Port must be an output port
        //
        if (dmpc.dwClass != DMUS_PC_OUTPUTCLASS)
        {
            return DMUS_E_PORT_NOT_RENDER;
        }

        // Channel group and channel must be in range.
        //
        if (dwDestinationChannel > 15 ||
            dwDestinationChannelGroup > dmpc.dwMaxChannelGroups) 
        {
            return E_INVALIDARG;
        }

        // Release existing port
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            // Reference to another port type, release it.
            // (NOTE: No need to turn off native dmusic16 thruing at this point,
            // that's handled in dmusic16).
            //
            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
        }


        m_pThruMap[dwSourceChannel].dwDestinationChannel = dwDestinationChannel;
        m_pThruMap[dwSourceChannel].dwDestinationChannelGroup = dwDestinationChannelGroup;
        m_pThruMap[dwSourceChannel].pDestinationPort = pDestinationPort;
        m_pThruMap[dwSourceChannel].fThruInWin16 = FALSE;

        // Is the destination also a legacy port?
        //
        if (dmpc.dwType == DMUS_PORT_WINMM_DRIVER)
        {
            // Woohoo! We can do native thruing in Win16!
            //
            m_pThruMap[dwSourceChannel].fThruInWin16 = TRUE;

            Trace(2, "32: Thruing <%d> -> <%d> in Win16\n", 
                dwSourceChannel,
                dwDestinationChannel);

            MMRESULT mmr = MidiInThru(m_hDevice,
                                      dwSourceChannel,
                                      dwDestinationChannel,
                                      ((CDirectMusicEmulatePort*)pDestinationPort)->m_hDevice);
            if (mmr)
            {
                Trace(0, "ThruChannel: MidiInThru returned %d\n", mmr);
                return MMRESULTToHRESULT(mmr);

            }
        }
        else
        { 
            Trace(2, "ThruChannel: From (%u,%u) -> (%u,%u,%p)\n",
                dwSourceChannelGroup,
                dwSourceChannel,
                dwDestinationChannelGroup,
                dwDestinationChannel,
                pDestinationPort);
        }

        pDestinationPort->AddRef();
    } 
    else
    {
        // Disabling thruing on this channel
        //
        if (m_pThruMap[dwSourceChannel].pDestinationPort)
        {
            if (m_pThruMap[dwSourceChannel].fThruInWin16)
            {
                MMRESULT mmr = MidiInThru(m_hDevice,
                                          dwSourceChannel,
                                          0,
                                          (HANDLE)NULL);
            
                if (mmr)
                {
                    Trace(0, "ThruChannel: MidiInThru returned %d\n", mmr);
                    return MMRESULTToHRESULT(mmr);

                }
            }

            m_pThruMap[dwSourceChannel].pDestinationPort->Release();
            m_pThruMap[dwSourceChannel].pDestinationPort = NULL;
        }
    }

    return S_OK;
}

STDMETHODIMP 
CDirectMusicEmulatePort::SetDirectSound(
    LPDIRECTSOUND pDirectSound, 
    LPDIRECTSOUNDBUFFER pDirectSoundBuffer)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CDirectMusicEmulatePort::GetFormat(
    LPWAVEFORMATEX pWaveFormatEx, 
    LPDWORD pdwWaveFormatExSize, 
    LPDWORD pdwBufferSize)
{
    return E_NOTIMPL;
}

// CDirectMusicEmulatePort::DownloadWave
//
STDMETHODIMP 
CDirectMusicEmulatePort::DownloadWave(
    IDirectSoundWave *pWave,               
    IDirectSoundDownloadedWaveP **ppWave,
    REFERENCE_TIME rtStartHint)
{
    V_INAME(IDirectMusicPort::DownloadWave);
    V_INTERFACE(pWave);
	V_PTRPTR_WRITE(ppWave);

    return E_NOTIMPL;
}

// CDirectMusicEmulatePort::UnloadWave
//
STDMETHODIMP 
CDirectMusicEmulatePort::UnloadWave(
    IDirectSoundDownloadedWaveP *pDownloadedWave)
{
    V_INAME(IDirectMusicPort::UnloadWave);
    V_INTERFACE(pDownloadedWave);

    return E_NOTIMPL;
}

            
// CDirectMusicEmulatePort::AllocVoice
//
STDMETHODIMP 
CDirectMusicEmulatePort::AllocVoice(
    IDirectSoundDownloadedWaveP *pWave,     
    DWORD dwChannel,                       
    DWORD dwChannelGroup,                  
    REFERENCE_TIME rtStart,                     
    SAMPLE_TIME stLoopStart,
    SAMPLE_TIME stLoopEnd,
    IDirectMusicVoiceP **ppVoice)
{
    V_INAME(IDirectMusicPort::AllocVoice);
    V_INTERFACE(pWave);
    V_PTRPTR_WRITE(ppVoice);

    return E_NOTIMPL;
}        

// CDirectMusicEmulatePort::AssignChannelToBuses
//
STDMETHODIMP 
CDirectMusicEmulatePort::AssignChannelToBuses(
    DWORD dwChannelGroup,
    DWORD dwChannel,
    LPDWORD pdwBuses,
    DWORD cBusCount)
{
    return E_NOTIMPL;
}        

STDMETHODIMP
CDirectMusicEmulatePort::SetSink(
    IDirectSoundConnect *pSinkConnect)
{
    return E_NOTIMPL;
}        

STDMETHODIMP
CDirectMusicEmulatePort::GetSink(
    IDirectSoundConnect **ppSinkConnect)
{
    return E_NOTIMPL;
}        

GENERICPROPERTY CDirectMusicEmulatePort::m_aProperty[] = 
{      
    { &GUID_DMUS_PROP_LegacyCaps,           // Set
      0,                                    // Item
      KSPROPERTY_SUPPORT_GET,               // KS support flags
      GENPROP_F_FNHANDLER,                  // GENPROP flags
      NULL, 0,                              // static data and size
      CDirectMusicEmulatePort::LegacyCaps   // Handler
    }
};

const int CDirectMusicEmulatePort::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);


HRESULT CDirectMusicEmulatePort::LegacyCaps(
    ULONG               ulId, 
    BOOL                fSet, 
    LPVOID              pbBuffer, 
    PULONG              pcbBuffer)
{
    if (fSet == KSPROPERTY_SUPPORT_SET)
    {
        return DMUS_E_SET_UNSUPPORTED;
    }

    MIDIINCAPS  mic;
    MIDIOUTCAPS moc;
    LPBYTE      pbData;
    ULONG       cbData;

    if (m_fIsOutput)
    {    
        MMRESULT mmr = midiOutGetDevCaps(m_id, &moc, sizeof(moc));
        if (mmr)
        {
            Trace(0, "midiOutGetDevCaps failed!\n");
            return MMRESULTToHRESULT(mmr);
        }

        pbData = (LPBYTE)&moc;
        cbData = sizeof(moc);
    }
    else
    {
        MMRESULT mmr = midiInGetDevCaps(m_id, &mic, sizeof(mic));
        if (mmr)
        {
            Trace(0, "midiInGetDevCaps failed!\n");
            return MMRESULTToHRESULT(mmr);
        }

        pbData = (LPBYTE)&mic;
        cbData = sizeof(mic);
    }

    ULONG cbToCopy = min(*pcbBuffer, cbData);
    CopyMemory(pbBuffer, pbData, cbToCopy);
    *pcbBuffer = cbToCopy;

    return S_OK;
}

// 
// CDirectMusicEmulatePort::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CDirectMusicEmulatePort::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid && 
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }

    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

STDMETHODIMP CDirectMusicEmulatePort::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);
    V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;
    if ((dwFlags == 0) || (dwFlags == (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET)))
    {
    }

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_GET, pvPropertyData, pulBytesReturned);
            }
    
            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, KSPROPERTY_SUPPORT_SET, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;
            

        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;    
            *pulBytesReturned = sizeof(DWORD);
            
            return S_OK;
    }

    Trace(-1, "%s: Flags must contain one of\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

STDMETHODIMP CDirectMusicEmulatePort::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}
STDMETHODIMP CDirectMusicEmulatePort::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    return DMUS_E_UNKNOWN_PROPERTY;
}

#define OFFSET_DATA_READY   0
#define OFFSET_KILL_THREAD  1

DWORD CDirectMusicEmulatePort::InputWorker()
{
    HANDLE h[2];

    h[OFFSET_DATA_READY]  = m_hDataReady;
    h[OFFSET_KILL_THREAD] = m_hKillThreads;

    UINT uWait;

    for(;;) 
    {
        uWait = WaitForMultipleObjects(2, h, FALSE, INFINITE);

        switch(uWait)
        {
            case WAIT_OBJECT_0 + OFFSET_DATA_READY:
                // m_hDataReady set
                //
                InputWorkerDataReady();
                if (m_hAppEvent)
                {
                    try
                    {
                        SetEvent(m_hAppEvent);
                    } 
                    catch (...)
                    {
                        Trace(0, "Capture: Application notify event handle prematurely free'd!\n");
                    }
                }
                break;

            case WAIT_OBJECT_0 + OFFSET_KILL_THREAD:
                // m_hKillThread set
                //
                Trace(0, "CDirectMusicEmulateWorker::InputWorker thread exit\n");
                return 0;

            case WAIT_FAILED:
                Trace(0, "WaitForMultipleObjects failed %d killing thread\n", GetLastError());
                return 0;

            default:
                break;
        }            
    }

    return 0;
}

// CDirectMusicEmulatePort::InputWorkerDataReady()
//
// The input worker thread has been notified that there is data available. 
// Read any pending events from the 16-bit DLL, perform needed thruing, and
// save the data in a queue so we can repackage it on the read request
// from the client.
//
void CDirectMusicEmulatePort::InputWorkerDataReady()
{
    MMRESULT mmr;
    DWORD cbData;
    DWORD msTime;
    LPBYTE pbData;
    DMEVENT *pEvent;
    DWORD cbRounded;
    REFERENCE_TIME rtStart;
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;

    Trace(0, "Enter InputWorkerDataReady()\n");
    for(;;)
    {
        // Fill temporary buffer
        //
        cbData = sizeof(m_WorkBuffer);
        mmr = MidiInRead(m_hDevice,
                         m_p1616WorkBuffer,
                         &cbData,
                         &msTime);

        rtStart = ((ULONGLONG)msTime) * REFTIME_TO_MS;
        SyncClocks();
        SlaveToMaster(&rtStart);
        
        hr = m_pMasterClock->GetTime(&rtMasterClock);

        if (mmr)
        {
            Trace(2, "InputWorkerDataReady: MidiInRead returned %d\n", mmr);
            return;
        }

        if (cbData == 0)
        {
            Trace(2, "MidiInRead returned no data\n");
            return;
        }

        // Copy temporary buffer as events into queue
        //
        pbData = m_WorkBuffer;
        while (cbData)
        {
            pEvent = (DMEVENT*)pbData;
            cbRounded = DMUS_EVENT_SIZE(pEvent->cbEvent);

            Trace(2, "cbData %u  cbRounded %u\n", cbData, cbRounded);

            if (cbRounded > cbData)
            {
                Trace(0, "InputWorkerDataReady: Event ran off end of buffer\n");
                break;
            }

            cbData -= cbRounded;
            pbData += cbRounded;

            EnterCriticalSection(&m_csEventQueues);

            QUEUED_EVENT *pQueuedEvent;
            int cbEvent;

            
            if (pEvent->cbEvent <= sizeof(DWORD))
            {
                // Channel message or other really small event, take from
                // free pool.
                //
                pQueuedEvent = m_FreeEvents.Alloc();
                cbEvent = sizeof(DMEVENT);

                Trace(2, "Queue [%02X %02X %02X %02X]\n",
                    pEvent->abEvent[0],
                    pEvent->abEvent[1],
                    pEvent->abEvent[2],
                    pEvent->abEvent[3]);
            }
            else
            {
                // SysEx or other long event, just allocate it
                //
                cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);
                pQueuedEvent = (QUEUED_EVENT*)new char[QUEUED_EVENT_SIZE(pEvent->cbEvent)];
            }

            if (pQueuedEvent)
            {

                CopyMemory(&pQueuedEvent->e, pEvent, cbEvent);

                // rtDelta is the absolute time of the event while it's in our queue
                //
                pQueuedEvent->e.rtDelta += rtStart;
                ThruEvent(&pQueuedEvent->e);

        
                if (m_ReadEvents.pFront)
                {
                    m_ReadEvents.pRear->pNext = pQueuedEvent;
                }
                else
                {
                    m_ReadEvents.pFront = pQueuedEvent;   
                }

                m_ReadEvents.pRear = pQueuedEvent;
                pQueuedEvent->pNext = NULL;
            }
            else
            {
                Trace(1, "InputWorker: Failed to allocate event; dropping\n");
            }        
            LeaveCriticalSection(&m_csEventQueues);
        }
    }    
    Trace(2, "Leave InputWorkerDataReady()\n");
}

void CDirectMusicEmulatePort::ThruEvent(
    DMEVENT *pEvent)
{
    // Since we know we only have one event and we already have it in the right format,
    // just slam it into the thru buffer. We only have to do this because we might modify 
    // it.
    //
    LPBYTE pbData;
    DWORD  cbData;
    DWORD  cbEvent = DMUS_EVENT_SIZE(pEvent->cbEvent);

    // First see if the event is thruable
    //
    if (pEvent->cbEvent > 3 || ((pEvent->abEvent[0] & 0xF0) == 0xF0))
    {
        // SysEx of some description
        return;
    }

    // Note: legacy driver assures no running status
    //
    DWORD dwSourceChannel = (DWORD)(pEvent->abEvent[0] & 0x0F);

    DMUS_THRU_CHANNEL *pThru = &m_pThruMap[dwSourceChannel];
    if (pThru->pDestinationPort == NULL ||
        pThru->fThruInWin16)
    {
        return;
    }

    if (FAILED(m_pThruBuffer->GetRawBufferPtr(&pbData)))
    {
        Trace(0, "Thru: GetRawBufferPtr\n");
        return;
    }

    if (FAILED(m_pThruBuffer->GetMaxBytes(&cbData)))
    {
        Trace(0, "Thru: GetMaxBytes\n");
        return;
    }

    if (cbEvent > cbData)
    {
        Trace(0, "Thru: cbData %u  cbEvent %u\n", cbData, cbEvent);
        return;
    }
    
    if (FAILED(m_pThruBuffer->SetStartTime(pEvent->rtDelta)) ||
        FAILED(m_pThruBuffer->SetUsedBytes(cbEvent)))
    {
        Trace(0, "Thru: buffer setup failed\n");
    }

    pEvent->rtDelta = 50000;
    CopyMemory(pbData, pEvent, cbEvent);

    pEvent = (DMEVENT*)pbData;
    pEvent->dwChannelGroup = pThru->dwDestinationChannelGroup;
    pEvent->abEvent[0] = (BYTE)((pEvent->abEvent[0] & 0xF0) | pThru->dwDestinationChannel);

    pThru->pDestinationPort->PlayBuffer(m_pThruBuffer);
}

void CDirectMusicEmulatePort::MasterToSlave(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt -= m_lTimeOffset;
    }
}

void CDirectMusicEmulatePort::SlaveToMaster(
    REFERENCE_TIME *prt)
{
    if (m_fSyncToMaster)
    {
        *prt += m_lTimeOffset;
    }
}

void CDirectMusicEmulatePort::SyncClocks()
{
    HRESULT hr;
    REFERENCE_TIME rtMasterClock;
    REFERENCE_TIME rtSlaveClock;
    LONGLONG drift;

    if (m_fSyncToMaster)
    {
        hr = m_pMasterClock->GetTime(&rtMasterClock);
        rtSlaveClock = ((ULONGLONG)timeGetTime()) * MS_TO_REFERENCE_TIME;
        if (FAILED(hr))
        {
            return;
        }


        drift = (rtSlaveClock + m_lTimeOffset) - rtMasterClock;

        // Work-around 46782 for DX8 release:
        // If drift is greater than 10ms, jump to the new offset value instead
        // of drifting there slowly.
        if( drift > 10000 * 10
        ||  drift < 10000 * -10 )
        {
            m_lTimeOffset -= drift;
        }
        else
        {
            m_lTimeOffset -= drift / 100;
        }
    }
}




/////////////////////////////////////////////////////////////////////
//
// CEmulateLatencyClock
//
// Latency clock for emulated ports, which is just a fixed offset from
// the DirectMusic master clock
//
CEmulateLatencyClock::CEmulateLatencyClock(IReferenceClock *pMasterClock) :
   m_cRef(1),
   m_pMasterClock(pMasterClock)
{
    pMasterClock->AddRef();
}

CEmulateLatencyClock::~CEmulateLatencyClock()
{
    Close();
}

STDMETHODIMP
CEmulateLatencyClock::QueryInterface(
    const IID &iid,
    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CEmulateLatencyClock::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CEmulateLatencyClock::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CEmulateLatencyClock::GetTime(
    REFERENCE_TIME *pTime)
{
    REFERENCE_TIME rt;

    V_INAME(IReferenceClock::GetTime);
    V_PTR_WRITE(pTime, REFERENCE_TIME);

    if (!m_pMasterClock)
    {
        return DMUS_E_DMUSIC_RELEASED;
    }
    
    HRESULT hr = m_pMasterClock->GetTime(&rt);

    rt += FIXED_LEGACY_LATENCY_OFFSET;          // Default : 10 ms
    *pTime = rt;
    
    return hr;
}

STDMETHODIMP
CEmulateLatencyClock::AdviseTime(
    REFERENCE_TIME baseTime,  
    REFERENCE_TIME streamTime,
    HANDLE hEvent,            
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

STDMETHODIMP
CEmulateLatencyClock::AdvisePeriodic(
    REFERENCE_TIME startTime,
    REFERENCE_TIME periodTime,
    HANDLE hSemaphore,   
    DWORD * pdwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}

STDMETHODIMP
CEmulateLatencyClock::Unadvise(
    DWORD dwAdviseCookie)
{
    return DMUS_E_UNKNOWN_PROPERTY;
}


void
CEmulateLatencyClock::Close()
{
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }
}

static HRESULT MMRESULTToHRESULT(
    MMRESULT mmr)
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_ALLOCATED:
        return DMUS_E_DEVICE_IN_USE;

    case MIDIERR_BADOPENMODE:
        return DMUS_E_ALREADYOPEN;

    case MMSYSERR_NOMEM:
        return E_OUTOFMEMORY;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\dm32p.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/*
 * Internal function prototypes for DMusic32.dll
 */
#ifndef _DM32P_
#define _DM32P_

#include "..\shared\dmusiccp.h"
#include "tpool.h"

#define THREAD_KILL_TIMEOUT         5000
#define THREAD_WORK_BUFFER_SIZE     4096

#define QWORD_ALIGN(x) (((x) + 7) & ~7)

#define MIDI_CHANNELS               16

/* DevIoctl.c - MMDEVLDR hooks we use
 */
extern BOOL WINAPI OpenMMDEVLDR(void);
extern VOID WINAPI CloseMMDEVLDR(void);
extern VOID WINAPI CloseVxDHandle(DWORD hVxDHandle);

/* From Win32 kernel
 */
extern "C" DWORD WINAPI OpenVxDHandle(HANDLE hEvent);

// 10 ms in 100ns units
//
#define FIXED_LEGACY_LATENCY_OFFSET (10L * 10L * 1000L)

class CEmulateLatencyClock : public IReferenceClock
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IReferenceClock
    //
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,  
				    REFERENCE_TIME streamTime,
				    HANDLE hEvent,            
				    DWORD * pdwAdviseCookie); 

    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,
					REFERENCE_TIME periodTime,
					HANDLE hSemaphore,   
					DWORD * pdwAdviseCookie);

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Class
    //
    CEmulateLatencyClock(IReferenceClock *pMasterClock);
    ~CEmulateLatencyClock();

    void Close();

private:
    long m_cRef;
    IReferenceClock *m_pMasterClock;
};

// Struct for holding a property item supported by the synth
//

class CDirectMusicEmulatePort;

typedef HRESULT (CDirectMusicEmulatePort::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};






class CDirectMusicEmulatePort : 
    public IDirectMusicPort, 
    public IDirectMusicPortP, 
    public IDirectMusicThru,
    public IDirectMusicPortPrivate, 
    public IKsControl
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPort
    //
    STDMETHODIMP PlayBuffer(LPDIRECTMUSICBUFFER pBuffer);
    STDMETHODIMP SetReadNotificationHandle(HANDLE hEvent);
    STDMETHODIMP Read(LPDIRECTMUSICBUFFER pBuffer);
	STDMETHODIMP DownloadInstrument(IDirectMusicInstrument*,
                                            IDirectMusicDownloadedInstrument**,
                                            DMUS_NOTERANGE*,
                                            DWORD);
	STDMETHODIMP UnloadInstrument(IDirectMusicDownloadedInstrument*);
    
    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
    STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
    STDMETHODIMP Compact();
    STDMETHODIMP GetCaps(LPDMUS_PORTCAPS pPortCaps);
	STDMETHODIMP DeviceIoControl(DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, 
	                                 LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNumChannelGroups(DWORD dwNumChannelGroups);
    STDMETHODIMP GetNumChannelGroups(LPDWORD pdwNumChannelGroups);
    STDMETHODIMP Activate(BOOL fActivate);
    STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
    STDMETHODIMP SetDirectSound(LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize);
        
    // IDirectMusicThru
    STDMETHODIMP ThruChannel(DWORD dwSourceChannelGroup, 
                             DWORD dwSourceChannel, 
                             DWORD dwDestinationChannelGroup,
                             DWORD dwDestinationChannel,
                             LPDIRECTMUSICPORT pDestinationPort);
    
    // IDirectMusicPortP
    //
    STDMETHODIMP DownloadWave(
         IN  IDirectSoundWave *pWave,               
         OUT IDirectSoundDownloadedWaveP **ppWave,
         IN  REFERENCE_TIME rtStartHint
        );
        
    STDMETHODIMP UnloadWave(
         IN  IDirectSoundDownloadedWaveP *pWave      
        );
            
    STDMETHODIMP AllocVoice(
         IN  IDirectSoundDownloadedWaveP *pWave,     
         IN  DWORD dwChannel,                       
         IN  DWORD dwChannelGroup,                  
         IN  REFERENCE_TIME rtStart,                     
         IN  SAMPLE_TIME stLoopStart,
         IN  SAMPLE_TIME stLoopEnd,
         OUT IDirectMusicVoiceP **ppVoice            
        );        
        
    STDMETHODIMP AssignChannelToBuses(
         IN DWORD dwChannelGroup,
         IN DWORD dwChannel,
         IN LPDWORD pdwBuses,
         IN DWORD cBusCount
        );        
        
    STDMETHODIMP SetSink(
        IN IDirectSoundConnect *pSinkConnect
    );

    STDMETHODIMP GetSink(
        IN IDirectSoundConnect **ppSinkConnect
    );

    // IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    // IDirectMusicPortPrivate
    STDMETHODIMP Close();
	STDMETHODIMP Report();
    STDMETHODIMP StartVoice(          
         DWORD dwVoiceId,
         DWORD dwChannel,
         DWORD dwChannelGroup,
         REFERENCE_TIME rtStart,
         DWORD dwDLId,
         LONG prPitch,
         LONG veVolume,
         SAMPLE_TIME stVoiceStart,
         SAMPLE_TIME stLoopStart,
         SAMPLE_TIME stLoopEnd
        );

    STDMETHODIMP StopVoice(
         DWORD dwVoiceID,
         REFERENCE_TIME rtStop
        );
    
    STDMETHODIMP GetVoiceState(   
         DWORD dwVoice[], 
         DWORD cbVoice,
         DMUS_VOICE_STATE VoiceState[] 
        );
        
    STDMETHODIMP Refresh(
         DWORD dwDownloadID,
         DWORD dwFlags
         );        
         
    // Class
    //
    CDirectMusicEmulatePort(PORTENTRY *pPE, CDirectMusic *pDM);
    ~CDirectMusicEmulatePort();
    HRESULT Init(LPDMUS_PORTPARAMS pPortParams);

    HRESULT LegacyCaps(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

    DWORD InputWorker();
    DWORD TimerWorker();
    
   

private:
    long                    m_cRef;
    UINT                    m_id;
    BOOL                    m_fIsOutput;
    HANDLE                  m_hDevice;
    CDirectMusic            *m_pDM;
    DWORD                   m_hVxDEvent;
    DMUS_PORTCAPS           dmpc;
    IReferenceClock         *m_pMasterClock;
    CEmulateLatencyClock    *m_pLatencyClock;
    IDirectMusicPortNotify  *m_pNotify;
    
    HANDLE                  m_hAppEvent;
    HANDLE                  m_hDataReady;
    HANDLE                  m_hKillThreads;
    HANDLE                  m_hCaptureThread;
    BYTE                    m_WorkBuffer[THREAD_WORK_BUFFER_SIZE];
    DWORD                   m_dwWorkBufferTileInfo;
    DWORD                   m_p1616WorkBuffer;
    EVENT_POOL              m_FreeEvents;        
    EVENT_QUEUE             m_ReadEvents;
    CRITICAL_SECTION        m_csEventQueues;
    BOOL                    m_fCSInitialized;
    
    IDirectMusicBuffer      *m_pThruBuffer;
    LPDMUS_THRU_CHANNEL     m_pThruMap;

    long                    m_lActivated;    
    
    BOOL                    m_fSyncToMaster;
    LONGLONG                m_lTimeOffset;
    
private:
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    
private:
    HRESULT InitializeClock();
    HRESULT InitializeCapture();
    void InputWorkerDataReady();    
    void ThruEvent(DMEVENT *pEvent);
    void MasterToSlave(REFERENCE_TIME *prt);
    void SlaveToMaster(REFERENCE_TIME *prt);
    void SyncClocks();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\mmdevldr.h ===
/*
 *  MMDEVLDR.H - The main include file for the DevLoader
 *
 *  Version 4.00
 *
 *  Copyright (c) 1994-1998 Microsoft Corporation
 *
 */

#ifdef _WIN32                                                           /* ;BeginInternal */
#define MMDEVLDR_IOCTL_GETVERSION           0
#define MMDEVLDR_IOCTL_LINPAGELOCK          1
#define MMDEVLDR_IOCTL_LINPAGEUNLOCK        2
#define MMDEVLDR_IOCTL_RING0THREADHANDLE    3
#define MMDEVLDR_IOCTL_QUEUEAPC             4
#define MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR   5
#define MMDEVLDR_IOCTL_CLOSEVXDHANDLE       6
#define MMDEVLDR_IOCTL_PAGEALLOCATE         7
#define MMDEVLDR_IOCTL_PAGEFREE             8
#define MMDEVLDR_IOCTL_GETDEVICESTATUS      9

#define MM_DEVSTATUS_ERROR          0
#define MM_DEVSTATUS_STARTED        1
#define MM_DEVSTATUS_UNKNOWNPROB    2
#define MM_DEVSTATUS_DISABLED       3


typedef struct tagLOCKUNLOCKPARMS
{
    DWORD           dwStartPage;
    DWORD           dwPageCount;
    DWORD           fdwOperation;
}   LOCKUNLOCKPARMS;

typedef struct tagQUEUEAPCPARMS
{
    DWORD           fnCallback;
    DWORD           dwUser;
    DWORD           hRing0Thd;
}   QUEUEAPCPARMS;

typedef struct tagPAGEALLOCATEPARMS
{
    DWORD           dwFlags;
    DWORD           dwPageCount;
} PAGEALLOCATEPARMS;

typedef struct tagPAGEALLOCATERETURN
{
    VOID *          lpvBase;
    DWORD           hMem;
    DWORD           dwPageCount;
    DWORD           dwPhysBase;
} PAGEALLOCATERETURN;

#endif

#ifdef MMDEVLDR_VXD
#define MM_STOP         0
#define MM_START        1
#define MM_MMDEVLDR_UP  3
#define MM_REMOVE       4

#define CONFIG_QUERYSTART       0x01000

#define MAXLEN  256

typedef struct tagMMDEVNODE
{
   DEVNODE      dn ;
   DWORD        dwDevStatus ;
   VMMLIST      hlDrivers ;
   BOOL         IsWDMDriver ;

} MMDEVNODE, *PMMDEVNODE ;


typedef struct tagMMDRVNODE
{
   CMCONFIGHANDLER  pConfigHandler ;
   DWORD            dwRefData ;

} MMDRVNODE, *PMMDRVNODE ;

//
// macros
//

#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

#if defined(DEBUG_RETAIL) || defined(DEBUG)
#define DBG_TRACE(strings) {\
        _Debug_Printf_Service( "MMDEVLDR: "); \
        _Debug_Printf_Service##strings; \
        _Debug_Printf_Service("\n");}
#ifdef DEBUG
#define DBG_ERROR(strings) {\
        _Debug_Printf_Service( "MMDEVLDR ERROR: "); \
        _Debug_Printf_Service##strings; \
        _Debug_Printf_Service("\n");\
        {_asm   int     3}}
#else
#define DBG_ERROR(strings) {\
        _Debug_Printf_Service( "MMDEVLDR ERROR: "); \
        _Debug_Printf_Service##strings; \
        _Debug_Printf_Service("\n");}
#endif
#else
   #define DBG_TRACE(strings)
   #define DBG_ERROR(strings)
#endif

#ifdef DEBUG
#define DPF( strings ) _Debug_Printf_Service##strings;

void __cdecl _my_assert(void *, void *, unsigned);

#define ASSERT(exp) (void)( (exp) || (_my_assert(#exp, __FILE__, __LINE__), 0) )

#else

#define DPF( strings )
#define ASSERT( exp )

#endif

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

//
// internal function prototypes
//

void MMDEVLDR_Call_MMSystem(DEVNODE dnDevNode, DWORD fLoad);
void MMDEVLDR_CheckForMMSystem(void);
DWORD StringLen(PCHAR psz);
PCHAR StringCopy(PCHAR pszDst, PCHAR pszSrc);
PCHAR StringCat(PCHAR pszDst, PCHAR pszSrc);

#pragma warning (disable:4035)          // turn off no return code warning
PSTR VXDINLINE Get_Environment_String
(
    PSTR            pszName
)
{
    _asm push esi
    _asm mov esi, pszName
    VMMCall( Get_Environment_String ) ;
    _asm mov   eax, edx
    _asm pop   esi
}
#pragma warning (default:4035)     // turn on no return code warning

BOOL _InitGlobalEnvironment() ;

VOID MMDEVLDR_SetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

BOOL MMDEVLDR_GetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue,
    UINT            uBufSize
) ;

VOID MMDEVLDR_RemoveEnvironmentString
(
    PSTR            pszName
) ;

VOID    MMDEVLDR_AddEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

#else                                                           /* ;EndInternal */


#define Multimedia_OEM_ID   0x0440      //            ; MS Reserved OEM # 34
#define MMDEVLDR_DEVICE_ID  Multimedia_OEM_ID + 10      //;MMDEVLDR's device ID

#ifdef Begin_Service_Table              // define only if vmm.h is included

#define MMDEVLDR_Service        Declare_Service
#pragma warning (disable:4003)          // turn off not enough params warning

//MACROS
Begin_Service_Table(MMDEVLDR)

MMDEVLDR_Service        (MMDEVLDR_Register_Device_Driver, LOCAL)
MMDEVLDR_Service        (MMDEVLDR_SetDevicePresence)
MMDEVLDR_Service  (MMDEVLDR_SetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_GetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_RemoveEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_AddEnvironmentString)

End_Service_Table(MMDEVLDR)
//ENDMACROS

#pragma warning (default:4003)          // turn on not enough params warning

#pragma warning (disable:4035)          // turn off no return code warning

VOID VXDINLINE MMDEVLDR_Register_Device_Driver
(
    DEVNODE         dnDevNode,
    DWORD           fnConfigHandler,
    DWORD           dwUserData
)
{
    _asm push ebx
    _asm mov eax,dnDevNode
    _asm mov ebx,fnConfigHandler
    _asm mov ecx,dwUserData
    Touch_Register(edx)
    VxDCall(MMDEVLDR_Register_Device_Driver);
    _asm pop ebx
}

VOID VXDINLINE MMDEVLDR_SetDevicePresence
(
    DEVNODE         dn,
    PCHAR           pszReg,
    BOOL            fPresent
)
{
    _asm push fPresent
    _asm push pszReg
    _asm push dn
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetDevicePresence);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_SetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetEnvironmentString);
    _asm add  esp, 2*4
} ;

BOOL VXDINLINE MMDEVLDR_GetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue,
    UINT            uBufSize
)
{
    _asm push uBufSize
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_GetEnvironmentString);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_RemoveEnvironmentString
(
    PCHAR           pszName
)
{
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_RemoveEnvironmentString);
    _asm add  esp, 4
} ;

VOID VXDINLINE MMDEVLDR_AddEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_AddEnvironmentString);
    _asm add  esp, 2*4
} ;

#pragma warning (disable:4035)          // turn on no return code warning

#endif // Begin_Service_Table

#endif                  /* ;Internal */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\tpool.h ===
// Copyright (c) 1998 Microsoft Corporation
//
// TPool.h
//
// Template pool memory manager. Efficiently manage requests for many of the same (small) object.
// Named after t'Pool, the Vulcan programmer who invented the technique.
//
#ifndef _TPOOL_H_
#define _TPOOL_H_

#include "debug.h"

#define POOL_DEFAULT_BYTE_PER_BLOCK     4096
#define MIN_ITEMS_PER_BLOCK             4

///////////////////////////////////////////////////////////////////////////////
//
// CPool
//
// A simple memory manager that efficiently handles many objects of the same 
// size by allocating blocks containing multiple objects at once.
//
// 
template<class contained> class CPool
{
public:
    CPool(int nApproxBytesPerBlock = POOL_DEFAULT_BYTE_PER_BLOCK);
    ~CPool();

    contained *Alloc();
    void Free(contained* pToFree);

private:
    union CPoolNode
    {
        CPoolNode       *pNext;
        contained       c;
    };

    class CPoolBlock
    {
    public:
        CPoolBlock      *pNext;
        CPoolNode       *pObjects;
    };

    int                 nItemsPerBlock;             // Based on bytes per block
    int                 nAllocatedBlocks;           // # allocated blocks
    CPoolBlock          *pAllocatedBlocks;          // list of allocated blocks
    int                 nFreeList;                  // # nodes in free list
    CPoolNode           *pFreeList;                 // free list

private:
    bool RefillFreeList();

#ifdef DBG
    bool IsPoolNode(CPoolNode *pNode);
    bool IsInFreeList(CPoolNode *pNode);
#endif

};

///////////////////////////////////////////////////////////////////////////////
//
// CPool::CPool
//
// Figure out the number of contained objects per block based on the requested
// approximate block size. Initialize the free list to contain one block's 
// worth of objects.
// 
//
template<class contained> CPool<contained>::CPool(int nApproxBytesPerBlock)
{
    // Figure out how many items per block and cheat if too small
    //
    nItemsPerBlock = nApproxBytesPerBlock / sizeof(CPoolNode);
    if (nItemsPerBlock < MIN_ITEMS_PER_BLOCK)
    {
        nItemsPerBlock = MIN_ITEMS_PER_BLOCK;
    }

    nAllocatedBlocks = 0;
    pAllocatedBlocks = NULL;
    nFreeList = 0;
    pFreeList = NULL;

    // Fill up with some items ahead of time
    //
    RefillFreeList();
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::~CPool
//
// Free up all allocated blocks. There should be no outstanding blocks 
// allocated at this point.
//
// 
template<class contained> CPool<contained>::~CPool()
{
#ifdef DBG
    if (nFreeList < nAllocatedBlocks * nItemsPerBlock)
    {
        Trace(0, "CPool::~Cpool: Warning: free'ing with outstanding objects allocated.\n");
    }
#endif
    
    // Clean up all allocated blocks and contained objects.
    //
    while (pAllocatedBlocks)
    {
        CPoolBlock *pNext = pAllocatedBlocks->pNext;

        delete[] pAllocatedBlocks->pObjects;
        delete pAllocatedBlocks;

        pAllocatedBlocks = pNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Alloc
//
// Attempt to allocate a contained object and return NULL if out of memory.
// If the free list is empty then allocate another block.
//
// 
template<class contained> contained *CPool<contained>::Alloc()
{
    if (pFreeList == NULL)
    {
        if (!RefillFreeList())
        {
            return false;
        }
    }

    nFreeList--;
    contained *pAlloc = (contained*)pFreeList;
    pFreeList = pFreeList->pNext;

    return pAlloc;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Free
//
// Return a contained object to the free list. In the debug version make sure
// the object was in fact allocated from this pool in the first place and that
// it isn't already in the free list.
//
// 
template<class contained> void CPool<contained>::Free(contained *pToFree)
{
    CPoolNode *pNode = (CPoolNode*)pToFree;

#ifdef DBG
    if (!IsPoolNode(pNode))
    {
        Trace(0, "CPool::Free() Object %p is not a pool node; ignored.\n", pToFree);
        return;
    }
    
    if (IsInFreeList(pNode))
    {
        Trace(0, "CPool::Free() Object %p is already in the free list; ignored.\n", pToFree);
        return;
    }
#endif

    nFreeList++;
    pNode->pNext = pFreeList;
    pFreeList = pNode;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::RefillFreeList
//
// Add one block's worth of contained objects to the free list, tracking the 
// allocated memory so we can free it later.
//
// 
template<class contained> bool CPool<contained>::RefillFreeList()
{
    // Allocate a new block and the actual block of objects
    //
    CPoolBlock *pNewBlock = new CPoolBlock;
    if (pNewBlock == NULL)
    {
        return false;
    }

    pNewBlock->pObjects = new CPoolNode[nItemsPerBlock];
    if (pNewBlock->pObjects == NULL)
    {
        delete pNewBlock;
        return false;
    }

    // Link the block and objects into the right places. First link the new block
    // into the list of allocated blocks.
    //
    pNewBlock->pNext = pAllocatedBlocks;
    pAllocatedBlocks = pNewBlock;

    // Link all the contained object nodes into the free list.
    //
    CPoolNode *pFirstNode = &pNewBlock->pObjects[0];
    CPoolNode *pLastNode  = &pNewBlock->pObjects[nItemsPerBlock - 1];

    for (CPoolNode *pNode = pFirstNode; pNode < pLastNode; pNode++)
    {
        pNode->pNext = pNode + 1;
    }

    pLastNode->pNext = pFreeList;
    pFreeList = pFirstNode;
    
    nFreeList += nItemsPerBlock;
    nAllocatedBlocks++;

    return true;
}

#ifdef DBG
///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsPoolNode (debug)
//
// Verify that the passed pointer is a pointer to a pool node by walking the list
// of allocated blocks.
//
// 
template<class contained> bool CPool<contained>::IsPoolNode(CPoolNode *pTest)
{
    for (CPoolBlock *pBlock = pAllocatedBlocks; pBlock; pBlock = pBlock->pNext)
    {
        CPoolNode *pFirstNode = &pBlock->pObjects[0];
        CPoolNode *pLastNode  = &pBlock->pObjects[nItemsPerBlock - 1];

        for (CPoolNode *pNode = pFirstNode; pNode <= pLastNode; pNode++)
        {
            if (pNode == pTest)
            {
                return true;
            }
        }
    }

    return false;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsInFreeList (debug)
//
// Verify that the passed pointer points to a node that is already in the free
// list.
//
// 
template<class contained> bool CPool<contained>::IsInFreeList(CPoolNode *pTest)
{
    for (CPoolNode *pNode = pFreeList; pNode; pNode = pNode->pNext)
    {
        if (pTest == pNode)
        {
            return true;
        }
    }
    
    return false;
}
#endif  // DBG
#endif  // _TPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic32\win9x\makefile.inc ===
..\i386\dmthunk.asm:    ..\dmthunk.thk
    thunk -o $@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\debug.cpp ===
//
// Debug.CPP
//
// Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DSWAVE"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\guids.cpp ===
#include <objbase.h>
#include "initguid.h"
#include <mmsystem.h>
#include <dsoundp.h>
#include "dmusicc.h"
#include "dmusici.h"
#include "riff.h"
#include "dswave.h"
#include "dmstrm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2001 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
    if(pIStream == NULL || ppIDMStream == NULL)
    {
        return E_INVALIDARG;            
    }

    if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    ((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream
   
CDirectMusicStream::~CDirectMusicStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init
   
STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CDirectMusicStream::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if(iid == IID_IUnknown || iid == IID_IDMStream)
    {
        *ppv = static_cast<IDMStream*>(this);
    } 
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }

    m_pStream = pStream;
    
    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }
    
    return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

    FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
    {
        ckidFind = lpck->ckid;
        fccTypeFind = NULL;
    }
    else if(wFlags & MMIO_FINDRIFF)
    {
        ckidFind = FOURCC_RIFF;
        fccTypeFind = lpck->fccType;
    }
    else if(wFlags & MMIO_FINDLIST)
    {
        ckidFind = FOURCC_LIST;
        fccTypeFind = lpck->fccType;
    }
    else
    {
        ckidFind = fccTypeFind = NULL;
    }

    lpck->dwFlags = 0L;

    for(;;)
    {
        HRESULT hr;
        LARGE_INTEGER li;
        ULARGE_INTEGER uli;
        ULONG cbRead;

        // Read the chunk header
        hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // Store the offset of the data part of the chunk
        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lpck->dwDataOffset = uli.LowPart;
        }

        // See if the chunk is within the parent chunk (if given)
        if((lpckParent != NULL) &&
           (lpck->dwDataOffset - 8L >=
           lpckParent->dwDataOffset + lpckParent->cksize))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // If the chunk is a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

            if(FAILED(hr) || (cbRead != sizeof(DWORD)))
            {
                Trace(1,"Error: Unable to read file.\n");
                return DMUS_E_DESCEND_CHUNK_FAIL;
            }
        }
        else
        {
            lpck->fccType = NULL;
        }

        // If this is the chunk we're looking for, stop looking
        if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
           ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
        {
            break;
        }

        // Ascend out of the chunk and try again
        HRESULT w = Ascend(lpck, 0);
        if(FAILED(w))
        {
            return w;
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    assert(lpck);

    HRESULT hr;
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;
    
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG lOffset;           // current offset in file
        LONG lActualSize;   // actual size of chunk data

        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lOffset = uli.LowPart;
        }
        
        if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }

        if(LOWORD(lActualSize) & 1)
        {
            ULONG cbWritten;

            // Chunk size is odd -- write a null pad byte
            hr = m_pStream->Write("\0", 1, &cbWritten); 
            
            if(FAILED(hr) || cbWritten != 1)
            {
                Trace(1,"Error: Unable to write file.\n");
                return DMUS_E_CANNOTWRITE;
            }
        
        }
    
        if(lpck->cksize == (DWORD)lActualSize)
        {
            return S_OK;
        }

        // Fix the chunk header
        lpck->cksize = lActualSize;

        li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
        hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }

        ULONG cbWritten;

        hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
        
        if(FAILED(hr) || cbWritten != sizeof(DWORD))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }
    }

    // Seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
    hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

    // Store the offset of the data part of the chunk
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    li.QuadPart = 0;
    HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }
    else
    {
        lOffset = uli.LowPart;
    }
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
    {
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
    else if(wFlags & MMIO_CREATELIST)
    {
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    }
    else
    {
        iBytes = 2 * sizeof(DWORD);
    }

    // Write the chunk header
    ULONG cbWritten;

    hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
        
    if(FAILED(hr) || cbWritten != iBytes)
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTWRITE;
    }

    lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
        HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
            {
                hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
            }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
        li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\dll.cpp ===
// dll.cpp
//
// Dll entry points and IDirectSoundWaveFactory implementation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"

#include "oledll.h"
#include "debug.h" 
#include "dmusicc.h"
#include "dmusici.h"
#include "riff.h"
#include "dswave.h"

#include <regstr.h>


// Globals
//

// Version information for our class
//
char g_szFriendlyName[]    = "Microsoft DirectSound Wave";
char g_szVerIndProgID[]    = "Microsoft.DirectSoundWave";
char g_szProgID[]          = "Microsoft.DirectSoundWave.1";

// Dll's hModule
//
HMODULE g_hModule = NULL; 

// Track whether running on Unicode machine.

BOOL g_fIsUnicode = FALSE;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;


static char const g_szDoEmulation[] = "DoEmulation";

// CDirectSoundWaveFactory::QueryInterface
//
HRESULT __stdcall
CDirectSoundWaveFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CDirectSoundWaveFactory::CDirectSoundWaveFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CDirectSoundWaveFactory::~CDirectSoundWaveFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CDirectSoundWaveFactory::AddRef
//
ULONG __stdcall
CDirectSoundWaveFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CDirectSoundWaveFactory::Release
//
ULONG __stdcall
CDirectSoundWaveFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CDirectSoundWaveFactory::CreateInstance
//
//
HRESULT __stdcall
CDirectSoundWaveFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CWave *pWave;
    
    try
    {
        pWave = new CWave;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pWave == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pWave->QueryInterface(iid, ppv);
    pWave->Release();
    
    return hr;
}

// CDirectSoundWaveFactory::LockServer
//
HRESULT __stdcall
CDirectSoundWaveFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
        IUnknown* pIUnknown = NULL;

        if(clsid == CLSID_DirectSoundWave)
        {
            pIUnknown = static_cast<IUnknown*> (new CDirectSoundWaveFactory);
            if(!pIUnknown) 
            {
                    return E_OUTOFMEMORY;
            }
        }
        else
        {
			return CLASS_E_CLASSNOTAVAILABLE;
		}

        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();

    return hr;
}

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectSoundWave,
                     g_szFriendlyName,
                     g_szVerIndProgID,
                     g_szProgID);
    return S_OK;
}

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectSoundWave,
                   g_szFriendlyName,
                   g_szVerIndProgID,
                   g_szProgID);
    return S_OK; 
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    OSVERSIONINFO osvi;
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        DebugTrace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        DebugTrace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
        { 
            DisableThreadLibraryCalls(hModule);
            g_hModule = hModule;
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx(&osvi);
            g_fIsUnicode = 
				(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS);
#ifdef DBG
			DebugInit();
#endif
		}
    }
#ifdef DBG
    else if (dwReason == DLL_PROCESS_DETACH) {
        if (--nReferenceCount == 0)
        {
            TraceI(-1, "Unloading DSWave : g_cLock = %d, g_cComponent = %d", g_cLock, g_cComponent);

            // Assert if we still have some objects hanging around
            assert(g_cComponent == 0);
            assert(g_cLock == 0);
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\dswave.h ===
// dswave.h
// (c) 1999-2000 Microsoft Corp.

#ifndef _DSWAVE_H_
#define _DSWAVE_H_

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "dsoundp.h"    // For IDirectSoundWave and IDirectSoundSource
#include "dmusicc.h"
#include "dmusici.h"
#include "riff.h"

extern long g_cComponent;

#define REF_PER_MIL     10000   // For converting from reference time to mils 
#define CONVERTLENGTH   250

// #define DSWCS_F_DEINTERLEAVED 0x00000001    // Multi-channel data as multiple buffers
// FIXME: unimplemented so far?

typedef struct tCREATEVIEWPORT
{
    IStream            *pStream;
    DWORD               cSamples;
    DWORD               dwDecompressedStart;
    DWORD               cbStream;
    LPWAVEFORMATEX      pwfxSource;
    LPWAVEFORMATEX      pwfxTarget;
    DWORD               fdwOptions;
} CREATEVIEWPORT, *PCREATEVIEWPORT;


// Private interface for getting the length of a wave
interface IPrivateWave : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetLength(REFERENCE_TIME *prtLength)=0;
};

DEFINE_GUID(IID_IPrivateWave, 0xce6ae366, 0x9d61, 0x420a, 0xad, 0x53, 0xe5, 0xe5, 0xf6, 0xa8, 0x4a, 0xe4);

// Flags for SetWaveBehavior()

#define DSOUND_WAVEF_ONESHOT        1           /* The wave will be played as a one shot */
#define DSOUND_WAVEF_PORT           2           /* The wave will be played via a DMusic port. */
#define DSOUND_WAVEF_SINK           4           /* The wave will be played via a streamed sink interface. */
#define DSOUND_WAVEF_CREATEMASK     0x00000001  /*  Currently only ONESHOT is define for CreateSource  */

#define DSOUND_WVP_NOCONVERT        0x80000000  /*  The viewport data is the same format as the wave  */
#define DSOUND_WVP_STREAMEND        0x40000000  /*  The viewport data is the same format as the wave  */
#define DSOUND_WVP_CONVERTSTATE_01  0x01000000
#define DSOUND_WVP_CONVERTSTATE_02  0x02000000
#define DSOUND_WVP_CONVERTSTATE_03  0x04000000

#define DSOUND_WVP_CONVERTMASK      0x0f000000

/*  The CWaveViewPort structure represents one instance, or "view", of the
    wave object. It manages the reading of the wave data, ACM decompression,
    and demultiplexing into mono buffers. If a wave object is being
    streamed, each playback instance gets a unique CWaveViewPort. 
    However, in the more typical case where the wave object is being
    played as a one shot, each playback instance uses the same
    CWaveViewPort.
    Each additional CWaveViewPort owns a cloned instance of the IStream.
*/

class CWaveViewPort :
    public IDirectSoundSource   // Used by a port or sink to pull data. 
{
public:
    CWaveViewPort();            // Constructor receives stream.
    ~CWaveViewPort();           //  Destructor releases memory, streams, etc.

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundSource
    STDMETHODIMP SetSink(IDirectSoundConnect *pSinkConnect);
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pwfx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP Seek(ULONGLONG sp);
    STDMETHODIMP Read(LPVOID *ppvBuffer, LPDWORD pdwBusIds, LPDWORD pdwFuncIds, LPLONG plPitchShifts, DWORD cpvBuffer, ULONGLONG *pcb);
    STDMETHODIMP GetSize(ULONGLONG *pcb);

    // Misc
    HRESULT Create(PCREATEVIEWPORT pCreate);

private:

    HRESULT acmRead();

    //  General stuff...
    CRITICAL_SECTION    m_CriticalSection;  //  Used to ensure thread safe
    long                m_cRef;             //  COM reference counter.

    //  Details about original data stream...
    IStream *           m_pStream;          //  IStream pointer which is connected to IPersistStream
                                            //  interface to pull data from file. 
    DWORD               m_cSamples;         //  Number of samples (if available)
    DWORD               m_cbStream;         //  Number of bytes in stream.
    DWORD               m_dwStart;          //  Offset into stream where data starts
    //LPWAVEFORMATEX      m_pwfxSource;       //  Do we need to hold on to this?

    //  Details needed for this viewport.
    DWORD               m_dwOffset;   //  Current byte offset into data stream
    DWORD               m_dwStartPos; //  Initial Start Offset
    LPWAVEFORMATEX      m_pwfxTarget; //  Target destination format.
    ACMSTREAMHEADER     m_ash;        //  ACM Stream header (used for conversion)
    HACMSTREAM          m_hStream;    //  ACM Stream handle for conversion
    LPBYTE              m_pDst;       //  Pointer to (decompressed) destination  
    LPBYTE              m_pRaw;       //  Pointer to compressed source buffer
    DWORD               m_fdwOptions; //  Options for viewport

    DWORD               m_dwDecompressedStart;  // Actual start for the data after decompression in Samples
                                                // This is important for MP3 and WMA codecs that 
                                                // insert some amount of silence in the beginning
    
    DWORD               m_dwDecompStartOffset;  // Byte Offset in the compressed stream to the block which
                                                // needs to be decompressed to get to the right start value
    
    DWORD               m_dwDecompStartOffsetPCM;// Byte offset in the decompressed stream...corresponds to
                                                // m_dwDecompressedStart samples

    DWORD               m_dwDecompStartDelta;   // The delta (in bytes) to add when we decompress the block starting
                                                // from m_dwDecompStartOffset

    // Only used to accurately get data after precached data for DirectSoundWave in DMusic
    DWORD               m_dwPreCacheFilePos;
    DWORD               m_dwFirstPCMSample;
    DWORD               m_dwPCMSampleOut;
};

/*  The CWave class represents one instance of a wave object. It
    supports the IDirectSoundWave interface, which the application
    uses to access the wave. It also support IPersistStream and
    IDirectMusicObject, which are used by the loader to load the 
    wave data from a stream into the wave object.
    And, the IDirectSoundSource interface manages the direct 
    transfer of the wave data from the object to the
    synth or DirectSound. This is for internal use, not by the
    application (though it represents an easy way for an app 
    to load wave data and then extract it.) 
    CWave maintains a list of CWaveViewPorts, though typically
    there is only one.
*/

class CWave : 
    public IDirectSoundWave,    // Standard interface.
    public IPersistStream,      // For file io
    public IDirectMusicObject,  // For DirectMusic loader
    public IPrivateWave         // For GetLength
{
public:
    CWave();
    ~CWave();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundWave
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP CreateSource(IDirectSoundSource **ppSource, LPWAVEFORMATEX pwfx, DWORD dwFlags);
    STDMETHODIMP GetStreamingParms(LPDWORD pdwFlags, LPREFERENCE_TIME prtReadahread);

    // IPersist functions (base class for IPersistStream)
    STDMETHODIMP GetClassID( CLSID* pClsId );

    // IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

    // IDirectMusicObject 
    STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IPrivateWave
    STDMETHODIMP GetLength(REFERENCE_TIME *prtLength);

private:
    
    // Internal methods.

    BOOL ParseHeader(IStream *pIStream, IRIFFStream* pIRiffStream, LPMMCKINFO pckMain);

    void FallbackStreamingBehavior()
    {
        REFERENCE_TIME rtLength = 0;
        if (SUCCEEDED(GetLength(&rtLength)))
        {
            // if > 5000 milliseconds, set to streaming with a 500 ms readahead
            if (rtLength > 5000)
            {
                m_rtReadAheadTime = 500 * REF_PER_MIL;
                m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
            }
            else
            {
                m_rtReadAheadTime = 0;
                m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
            }
        }
    }

    CRITICAL_SECTION    m_CriticalSection;      //  Used to ensure thread safe
    LPWAVEFORMATEX      m_pwfxDst;              //  Destination format, if compressed 
    REFERENCE_TIME      m_rtReadAheadTime;      //  Readahead for streaming.
    DWORD               m_fdwFlags;             //  Various flags, including whether this is a one-shot.
    long                m_cRef;                 //  COM reference counter.
    IStream *           m_pStream;              //  IStream pointer which is connected to IPersistStream
    DWORD               m_fdwOptions;           //  Flags set by call to SetWaveBehavior().
    LPWAVEFORMATEX      m_pwfx;                 //  File's format
    DWORD               m_cbStream;
    DWORD               m_cSamples;
    GUID                m_guid;
    FILETIME            m_ftDate;
    DMUS_VERSION        m_vVersion;
    WCHAR               m_wszFilename[DMUS_MAX_FILENAME];
    DWORD               m_dwDecompressedStart;
};

class CDirectSoundWaveFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectSoundWaveFactory();

    // Destructor
    ~CDirectSoundWaveFactory(); 

private:
    long m_cRef;
};

#endif // _DSWAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\ima.h ===
// IMA.h : Declaration of private interface for IMA legacy mode.
//
//

#ifndef __IMA_H_
#define __IMA_H_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif


#undef  INTERFACE
#define INTERFACE  IDirectMusicIMA
DECLARE_INTERFACE_(IDirectMusicIMA, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicIMA */
	STDMETHOD(LegacyCaching)		(THIS_ BOOL fEnable) PURE;
};

DEFINE_GUID(IID_IDirectMusicIMA,0xd2ac28b3, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef __IMA_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\oledll.h ===
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const char *szFriendlyName,
               const char *szVerIndProgID,
               const char *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const char *szFriendlyName,
                 const char *szVerIndProgID,
                 const char *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const char *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   char *szStr,
				   int cbStr);

HRESULT StrToCLSID(char *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\oledll.cpp ===
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

static const char g_szCLSID[]           = "CLSID";
static const char g_szCLSIDSlash[]      = "CLSID\\";
static const char g_szInProc32[]        = "InProcServer32";
static const char g_szProgIDKey[]       = "ProgID";
static const char g_szVerIndProgIDKey[] = "VersionIndependentProgID";
static const char g_szCurVer[]          = "CurVer"; 
static const char g_szThreadingModel[]	= "ThreadingModel";
static const char g_szBoth[]		= "Both";

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCSTR pstrKey, LPCSTR pstrSubkey, LPCSTR pstrValueName, LPCSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const char *szFriendlyName,
               const char *szVerIndProgID,
               const char *szProgID)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);

    char szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const char *szFriendlyName,
                 const char *szVerIndProgID,
                 const char *szProgID)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const char *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    char szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    char szClsKey[256];
    strcpy(szClsKey, g_szCLSIDSlash);
    strcat(szClsKey, szCLSID);
	strcat(szClsKey, "\\");
    if (szKey)
    {
	    strcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           char *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(char *szStr,
		   CLSID &clsid,
		   int cbStr)
{
	WCHAR wsz[512];

    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
}
   

static LONG
RegSetDefValue(LPCSTR pstrKey,
               LPCSTR pstrSubkey,
			   LPCSTR pstrValueName,
               LPCSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    char sz[1024];
    LPCSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        strcpy(sz, pstrKey);
        strcat(sz, "\\");
        strcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+strlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

    char szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\riff.h ===
//
// riff.h
//

#include <objbase.h>

#ifndef __RIFF__
#define __RIFF__
#include <windows.h>
#include <mmsystem.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IRIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IRIFFStream
DECLARE_INTERFACE_(IRIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};



struct CRIFFStream : IRIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IRIFFStream ) )
        {
            *ppvObj = (IRIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};
/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocFileStream( LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream );
*/
STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff );

#endif  // __RIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\waveutil.cpp ===
#include <windows.h>
#include <mmsystem.h>
#include "waveutil.h"


void CopyFormat
(
	LPWAVEFORMATEX 	pwfxDst,
	LPWAVEFORMATEX 	pwfxSrc
)
{
	DWORD	cbSize;

	cbSize = SIZEOFFORMAT(pwfxSrc);

	CopyMemory(pwfxDst, pwfxSrc, cbSize);
}

void CopyFormatEx
(
	LPWAVEFORMATEX 	pwfxDst,
	LPWAVEFORMATEX 	pwfxSrc
)
{
	DWORD	cbSize;

	cbSize = SIZEOFFORMATEX(pwfxSrc);

	CopyMemory(pwfxDst, pwfxSrc, cbSize);

	if (WAVE_FORMAT_PCM == pwfxDst->wFormatTag)
	{
		pwfxDst->cbSize = 0;
	}
}

BOOL FormatCmp
(
	LPWAVEFORMATEX 	pwfx1,
	LPWAVEFORMATEX 	pwfx2
)
{
	DWORD	cbSize;

	cbSize = SIZEOFFORMAT(pwfx1);

	if (cbSize != SIZEOFFORMAT(pwfx2))
	{
		return (FALSE);
	}
	else
	{
		LPBYTE	pb1 = (LPBYTE)pwfx1, pb2 = (LPBYTE)pwfx2;

		for (; cbSize; cbSize--)
		{
			if (pb1[cbSize - 1] != pb2[cbSize - 1])
			{
				return (FALSE);
			}
		}
	}

	return (TRUE);
}


DWORD DeinterleaveBuffers
(
	LPWAVEFORMATEX 	pwfx,
	LPBYTE 			pSrc,
	LPBYTE 			*ppbDst,
	DWORD 			cBuffers,
	DWORD 			cbSrcLength,
	DWORD 			dwOffset
)
{
	DWORD			ii;

	//	Note:  Right now, we don't deal with anything but PCM

	if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
	{
		return (dwOffset);
	}

	if (1 == cBuffers)
	{
		LPBYTE	pDst = ppbDst[0];

		pDst += dwOffset;

		CopyMemory(pDst, pSrc, cbSrcLength);

		dwOffset += cbSrcLength;
		return (dwOffset);
	}

	if (8 == pwfx->wBitsPerSample)
	{
		if ( !cBuffers || (0 != (cbSrcLength % cBuffers)) )
		{
			//  Hmm... Buffer sizes don't line up!

			return (dwOffset);
		}

		for (; cbSrcLength; cbSrcLength -= cBuffers)
		{
			for (ii = 0; ii < cBuffers; ii++)
			{
				ppbDst[ii][dwOffset] = *pSrc++;
			}

			dwOffset++;
		}

		return (dwOffset);
	}
	else
	{
		PWORD	*ppwDst = (PWORD*)ppbDst;
		PWORD	pwSrc   = (PWORD)pSrc;

		//  Assuming 16-bit...

		if ( !cBuffers || (0 != (cbSrcLength % (cBuffers * 2))) || (0 != (dwOffset % sizeof(WORD))))
		{
			//	Hmm... Buffer sizes don't line up!

			return (0);
		}

		// Convert byte index into word index
		//
        dwOffset /= sizeof(WORD);            
		for (; cbSrcLength; cbSrcLength -= (2 * cBuffers))
		{
			for (ii = 0; ii < cBuffers; ii++)
			{
				ppwDst[ii][dwOffset] = *pwSrc++;
			}

			dwOffset++;
		}

		// Return byte index
		//
		dwOffset *= sizeof(WORD);

		return (dwOffset);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\viewport.cpp ===
#include <objbase.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "debug.h" 
#include "dmusicc.h" 
#include "dmusici.h" 
#include "validate.h"
#include "riff.h"
#include "dswave.h"
#include "waveutil.h"
#include "riff.h"
#include <regstr.h>
#include <share.h>

//    CWaveViewPort(IStream *pStream);  // Constructor receives stream.
//    ~CWaveViewPort();                 //  Destructor releases memory, streams, etc.
//
//    STDMETHODIMP Init();
//    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize);
//    STDMETHODIMP Seek(DWORD dwSample);
//    STDMETHODIMP Read(LPVOID *ppvBuffer, DWORD cpvBuffer, LPDWORD pcb);


CWaveViewPort::CWaveViewPort() : m_dwDecompressedStart(0), m_dwDecompStartOffset(0), m_dwDecompStartOffsetPCM(0), m_dwDecompStartDelta(0)
{
    V_INAME(CWaveViewPort::CWaveViewPort);

    InterlockedIncrement(&g_cComponent);

    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.

    m_cRef = 1;

    //  General stuff...
    m_pStream    = NULL; 
    m_cSamples   = 0L;
    m_cbStream   = 0L;
    m_dwStart    = 0L;

    //  Viewport info...
    m_pwfxTarget = NULL;
    ZeroMemory(&m_ash, sizeof(ACMSTREAMHEADER));
    m_hStream    = NULL;   
    m_pDst       = NULL;      
    m_pRaw       = NULL;      
    m_fdwOptions = 0L;

    m_dwPreCacheFilePos = 0;
    m_dwFirstPCMSample = 0;
    m_dwPCMSampleOut = 0;

    return;
}


CWaveViewPort::~CWaveViewPort()
{
    V_INAME(CWaveViewPort::~CWaveViewPort);

    if (m_pStream) m_pStream->Release();
    if (m_hStream)
    {
        acmStreamUnprepareHeader(m_hStream, &m_ash, 0L);
        acmStreamClose(m_hStream, 0);
    }
    if (NULL != m_pwfxTarget)
    {
        GlobalFreePtr(m_pwfxTarget);
    }
    if (NULL != m_ash.pbDst)
    {
        GlobalFreePtr(m_ash.pbDst);
    }
    if (NULL != m_ash.pbSrc)
    {
        GlobalFreePtr(m_ash.pbSrc);
    }
    
    DeleteCriticalSection(&m_CriticalSection);

    InterlockedDecrement(&g_cComponent);

    return;
}

STDMETHODIMP CWaveViewPort::QueryInterface
(
    const IID &iid,
    void **ppv
)
{
    V_INAME(CWaveViewPort::QueryInterface);

    if (iid == IID_IUnknown || iid == IID_IDirectSoundSource)
    {
        *ppv = static_cast<IDirectSoundSource*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Viewport\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CWaveViewPort::AddRef()
{
    V_INAME(CWaveViewPort::AddRef);

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CWaveViewPort::Release()
{
    V_INAME(CWaveViewPort::Release);

    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CWaveViewPort::SetSink
(
    IDirectSoundConnect *pSinkConnect
)
{
    V_INAME(CWaveViewPort::Init);
    
    return S_OK;
}

STDMETHODIMP CWaveViewPort::GetFormat
(
    LPWAVEFORMATEX pwfx,
    DWORD dwSizeAllocated,
    LPDWORD pdwSizeWritten
)
{
    DWORD           cbSize;

    V_INAME(CWaveViewPort::GetFormat);

    if (!pwfx && !pdwSizeWritten)
    {
        Trace(1, "ERROR: GetFormat (Viewport): Must request either the format or the required size");
        return E_INVALIDARG;
    }

    if (!m_pwfxTarget)
    {
        return DSERR_BADFORMAT;
    }

    //  Note: Assuming that the wave object fills the cbSize field even
    //  on PCM formats...

    if (WAVE_FORMAT_PCM == m_pwfxTarget->wFormatTag)
    {
        cbSize = sizeof(PCMWAVEFORMAT);
    }
    else
    {
        cbSize = sizeof(WAVEFORMATEX) + m_pwfxTarget->cbSize;
    }

    if (pdwSizeWritten)
    {
        V_PTR_WRITE(pdwSizeWritten, DWORD);
        *pdwSizeWritten = cbSize;
    }

    if (pwfx)
    {
        V_BUFPTR_WRITE(pwfx, dwSizeAllocated);
        if (dwSizeAllocated < cbSize)
        {
            return DSERR_INVALIDPARAM;
        }
        else
        {
            CopyMemory(pwfx, m_pwfxTarget, cbSize);
            // Set the cbSize field in destination if we have room
            if (WAVE_FORMAT_PCM == m_pwfxTarget->wFormatTag && dwSizeAllocated >= sizeof(WAVEFORMATEX))
            {
                pwfx->cbSize = 0;
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CWaveViewPort::Seek
(
    ULONGLONG       ullPosition
)
{
    LARGE_INTEGER   li;
    HRESULT         hr;
    MMRESULT        mmr;
    DWORD           cbSize;

    V_INAME(CWaveViewPort::Seek);

    m_fdwOptions &= ~DSOUND_WVP_STREAMEND; // rsw clear this on seek: no longer at stream end

    if (m_fdwOptions & DSOUND_WVP_NOCONVERT)
    {
        if ((DWORD) ullPosition >= m_cbStream)
        {
            // Seek past end of stream
            //
            m_fdwOptions |= DSOUND_WVP_STREAMEND;
            m_dwOffset = m_cbStream;

            return S_OK;
        }

        m_dwOffset = (DWORD) ullPosition;      // rsw initialize offset to Seek position

        if (0 != (ullPosition % m_pwfxTarget->nBlockAlign))
        {
            //  Seek position not block aligned?

            Trace(1, "ERROR: Seek (wave): Seek position is not block-aligned.\n");
            return (DMUS_E_BADWAVE);
        }

        li.HighPart = 0;
        li.LowPart  = ((DWORD)ullPosition) + m_dwStartPos;

        hr = m_pStream->Seek(li, STREAM_SEEK_SET, NULL);

        if (FAILED(hr))
        {
            Trace(1, "ERROR: Seek (Viewport): Seeking the vieport's stream failed.\n");
            return (DMUS_E_BADWAVE);
        }
    }
    else
    {
        //  Estimating source stream position...
        //
        //  Should we create lookup table?!

        cbSize = (DWORD)ullPosition;

        if (cbSize)
        {
            mmr = acmStreamSize(m_hStream, cbSize, &cbSize, ACM_STREAMSIZEF_DESTINATION);

            if (MMSYSERR_NOERROR != mmr)
            {
                Trace(1, "ERROR: Seek (viewport): Could not convert target stream size to source format.\n");
                return (DMUS_E_BADWAVE);
            }
        }

        if (cbSize >= m_cbStream)
        {
            // Seek past end of stream
            //
            m_fdwOptions |= DSOUND_WVP_STREAMEND;
            m_dwOffset = m_cbStream;

            return S_OK;
        }

        // If this is a seek to the precache end we know where to start reading from
        if((m_fdwOptions & DSOUND_WAVEF_ONESHOT) == 0)
        {
            // Go back to the block that was read for the end of the precached data
            if(cbSize != 0 && m_dwPCMSampleOut == ullPosition)
            {
                m_dwOffset = m_dwPreCacheFilePos;
                li.HighPart = 0;
                li.LowPart  = m_dwOffset + m_dwStartPos;
            }
            else
            {
                m_dwOffset = cbSize; // rsw initialize offset to Seek position
                li.HighPart = 0;
                li.LowPart  = cbSize + m_dwStartPos;

            }

            hr = m_pStream->Seek(li, STREAM_SEEK_SET, NULL);

            if (FAILED(hr))
            {
                Trace(1, "ERROR: Seek (viewport): Seeking the viewport's stream failed.\n");
                return (DMUS_E_BADWAVE);
            }

            // Since we're restarting, re-initialize.
            m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
            m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_01;

            m_ash.cbSrcLength     = (DWORD)m_ash.dwSrcUser;
            m_ash.cbSrcLengthUsed = m_ash.cbSrcLength;

            m_ash.dwDstUser       = 0L;
            m_ash.cbDstLengthUsed = 0L;

        }

        /////////////////////////////////////////////////////////////////////////////////////
        // If we're starting the wave, re-seek the stream (one-shots always need to re-seek).
        // NOTE: The following assumes that compressed waves always seek from the beginning,
        // since the value returned by acmStreamSize is pretty unreliable.
        /////////////////////////////////////////////////////////////////////////////////////
        else if ( cbSize == 0 || (m_fdwOptions & DSOUND_WAVEF_ONESHOT) )
        {
        
            m_dwOffset = cbSize; // rsw initialize offset to Seek position
            li.HighPart = 0;
            li.LowPart  = cbSize + m_dwStartPos;

            hr = m_pStream->Seek(li, STREAM_SEEK_SET, NULL);

            if (FAILED(hr))
            {
                Trace(1, "ERROR: Seek (viewport): Seeking the viewport's stream failed.\n");
                return (DMUS_E_BADWAVE);
            }

            // Since we're restarting, re-initialize.
            m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
            m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_01;

            m_ash.cbSrcLength     = (DWORD)m_ash.dwSrcUser;
            m_ash.cbSrcLengthUsed = m_ash.cbSrcLength;

            m_ash.dwDstUser       = 0L;
            m_ash.cbDstLengthUsed = 0L;

        }
    }

    TraceI(5, "Seek (Viewport): Succeeded.\n");
    return S_OK;
}

static inline HRESULT MMRESULTToHRESULT(
    MMRESULT mmr)
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_ALLOCATED:
        return DSERR_ALLOCATED;

    case MMSYSERR_NOMEM:
        return E_OUTOFMEMORY;
    }

    return E_FAIL;
}   

HRESULT CWaveViewPort::acmRead
(
    void
)
{
    DWORD       cbSize;
    DWORD       dwOffset;
    DWORD       fdwConvert = 0;
    MMRESULT    mmr;
    HRESULT     hr;

    V_INAME(CWaveViewPort::acmRead);
    
    for (m_ash.cbDstLengthUsed = 0; 0 == m_ash.cbDstLengthUsed; )
    {
        //  Did we use up the entire buffer?

        if (m_ash.cbSrcLengthUsed == m_ash.cbSrcLength)
        {
            //  Yep!

            dwOffset = 0L;
            cbSize   = (DWORD)m_ash.dwSrcUser;
        }
        else
        {
            //  Nope!

            dwOffset = m_ash.cbSrcLength - m_ash.cbSrcLengthUsed;
            cbSize   = (DWORD)m_ash.dwSrcUser - dwOffset;

            //  Moving the remaining data from the end of buffer to the beginning

            MoveMemory(
                    m_ash.pbSrc,                            //  Base address
                    &(m_ash.pbSrc[m_ash.cbSrcLengthUsed]),  //  Address of unused bytes
                    dwOffset);                              //  Number of unused bytes
        }

        //  Are we at the end of the stream?
        cbSize = min(cbSize, m_cbStream - m_dwOffset);

        if (0 == cbSize)
        {
            if (dwOffset)
            {
                m_ash.cbSrcLength = dwOffset;
            }
        }
        else
        {
            hr = m_pStream->Read(&(m_ash.pbSrc[dwOffset]), cbSize, &cbSize);

            if (FAILED(hr))
            {
                Trace(1, "ERROR: Read (Viewport): Attempt to read source stream returned 0x%08lx\n", hr);
                //>>>>>>>>>>>>>>>>>>>> 
                m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
                m_fdwOptions |= DSOUND_WVP_STREAMEND;
                return(DMUS_E_CANNOTREAD);
                //>>>>>>>>>>>>>>>>>>>> 
            }

            m_dwOffset        += cbSize;
            m_ash.cbSrcLength  = cbSize + dwOffset;
        }

        switch (m_fdwOptions & DSOUND_WVP_CONVERTMASK)
        {
            case DSOUND_WVP_CONVERTSTATE_01:
                fdwConvert = ACM_STREAMCONVERTF_BLOCKALIGN;
                break;

            case DSOUND_WVP_CONVERTSTATE_02:
                fdwConvert = ACM_STREAMCONVERTF_BLOCKALIGN | ACM_STREAMCONVERTF_END;
                break;

            case DSOUND_WVP_CONVERTSTATE_03:
                fdwConvert = ACM_STREAMCONVERTF_END;
                break;

            default:
                TraceI(3, "CWaveViewPort::acmRead: Default case?!\n");
                break;
        }

        mmr = acmStreamConvert(m_hStream, &m_ash, fdwConvert);

        if (MMSYSERR_NOERROR != mmr)
        {
            Trace(1, "ERROR: Read (Viewport): Attempt to convert wave to PCM failed.\n");
            return (MMRESULTToHRESULT(mmr));
        }

        if (0 != m_ash.cbDstLengthUsed)
        {
            m_ash.dwDstUser = 0L;
            return (S_OK);
        }

        //  No data returned?

        switch (m_fdwOptions & DSOUND_WVP_CONVERTMASK)
        {
            case DSOUND_WVP_CONVERTSTATE_01:
                if (0 == cbSize)
                {
                    //  We're at the end of the stream..

                    m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
                    m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_02;
                    TraceI(5, "CWaveViewPort::acmRead: Moving to stage 2\n");
                }

                //  Otherwise, continue converting data as normal.
                break;

            case DSOUND_WVP_CONVERTSTATE_02:
                //  We have hit the last partial block!

                m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
                m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_03;
                TraceI(5, "CWaveViewPort::acmRead: Moving to stage 3\n");
                break;

            case DSOUND_WVP_CONVERTSTATE_03:
                //  No more data after end flag, NO MORE DATA!!
                m_fdwOptions &= (~DSOUND_WVP_CONVERTMASK);
                m_fdwOptions |= DSOUND_WVP_STREAMEND;
                Trace(2, "WARNING: Read (Viewport): End of source stream.\n");
                return (DMUS_E_BADWAVE);

            default:
                TraceI(3, "CWaveViewPort::acmRead: Default case?!\n");
                break;
        }
    }

    TraceI(3, "CWaveViewPort::acmRead: We should never get here!\n");

    return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//
// ppvBuffer[] contains cpvBuffer pointers-to-samples, each to be filled with
// *pcb bytes of data. On output *pcb will contain the number of bytes (per
// buffer) actually read.
//
// pdwBusIds and pdwFuncIds are used to specify the bus and functionality
// of each buffer, but these are ignored by the wave object.
//
STDMETHODIMP CWaveViewPort::Read
(
    LPVOID         *ppvBuffer,
    LPDWORD         pdwBusIds,
    LPDWORD         pdwFuncIds,
    LPLONG          plPitchShifts,
    DWORD           cpvBuffer,
    ULONGLONG      *pcb
)
{
    HRESULT     hr = S_OK;
    DWORD       cbRead;
    DWORD       dwOffset;
    DWORD       cbSize;

    V_INAME(CWaveViewPort::Read);
    V_BUFPTR_READ(ppvBuffer, (cpvBuffer * sizeof(LPVOID)));
    V_BUFPTR_READ_OPT(pdwBusIds, (cpvBuffer * sizeof(LPDWORD)));
    V_BUFPTR_READ_OPT(pdwFuncIds, (cpvBuffer * sizeof(LPDWORD)));

    for (cbRead = cpvBuffer, cbSize = (DWORD)*pcb; cbRead; cbRead--)
    {
        V_BUFPTR_WRITE(ppvBuffer[cbRead - 1], cbSize);
    }

    if (m_fdwOptions & DSOUND_WVP_STREAMEND)
    {
        *pcb = 0;
        Trace(2, "WARNING: Read (Viewport): Attempt to read at end of stream.\n");
        return (S_FALSE);
    }

    LPVOID *ppvWriteBuffers  = ppvBuffer;
    DWORD dwWriteBufferCount = cpvBuffer;

    if (m_fdwOptions & DSOUND_WVP_NOCONVERT)
    {
        //  Total number of bytes to read... size of each buffer * number of buffers

        cbRead   = ((DWORD)*pcb) * dwWriteBufferCount;
        dwOffset = 0;

        TraceI(5, "CWaveViewPort::Read - No conversion [%d bytes]\n", cbRead);

        do
        {
            //  Calculate read size...  It's going to be the size of:
            //    1.  Remaining bytes to read.
            //    2.  Size of the buffer.
            //    3.  Remaining bytes in the stream.
            //  Whichever happens to be the smallest.

            cbSize = min(cbRead, m_ash.cbDstLength);
            cbSize = min(cbSize, m_cbStream - m_dwOffset);

            TraceI(5, "CWaveViewPort::Read - Trying to read %d bytes\n", cbSize);

            DWORD _cbSize = cbSize; cbSize = 0; // Read may not set cbSize to zero 
        
            hr = m_pStream->Read(m_ash.pbDst, _cbSize, &cbSize);

            TraceI(5, "CWaveViewPort::Read - Read %d bytes\n", cbSize);

            if (FAILED(hr))
            {
                Trace(2, "WARNING: Read (Viewport): Attempt to read returned 0x%08lx.\n", hr);
                break;
            }

            dwOffset = DeinterleaveBuffers(
                            m_pwfxTarget,
                            m_ash.pbDst,
                            (LPBYTE *)ppvWriteBuffers,
                            dwWriteBufferCount,
                            cbSize,
                            dwOffset);

            cbRead     -= cbSize;
            m_dwOffset += cbSize;

            if (m_dwOffset >= m_cbStream)
            {
                m_fdwOptions |= DSOUND_WVP_STREAMEND;
                break;
            }
        }
        while (0 != cbRead);

        if (SUCCEEDED(hr))
        {
            *pcb = dwOffset;
        }
    }
    else
    {
        // If this is the read for the precache then we should remember the fileposition, 
        // start sample for the decompressed block and the last sample passed back so we 
        // can accurately pick up from there when refilling buffers
        // We use the LPLONG plPitchShifts in the read method as a boolean
        // this is a HACK!! We need to change this...
        // *plPitchShifts == 2 is to remember the precache offset
        // *plPitchShifts == 1 is to read from there
        bool fRememberPreCache = false;
        if(plPitchShifts != NULL && *plPitchShifts == 2 && (m_fdwOptions & DSOUND_WAVEF_ONESHOT) == 0)
        {
            fRememberPreCache = true;
        }

        bool bRemoveSilence = false;
        
        cbRead   = ((DWORD)*pcb) * dwWriteBufferCount;
        dwOffset = 0;

        TraceI(5, "CWaveViewPort::Read - Conversion needed\n");

        do
        {
            if(m_dwDecompressedStart > 0 && m_dwOffset <= m_dwDecompStartOffset)
            {
                bRemoveSilence = true;
            }

            //  Is there any remnant data in destination buffer?
            if (m_ash.dwDstUser >= m_ash.cbDstLengthUsed)
            {
                if(fRememberPreCache)
                {
                    // Go back on block
                    m_dwPreCacheFilePos = m_dwOffset - m_ash.cbSrcLength;
                    m_dwFirstPCMSample = dwOffset * dwWriteBufferCount;
                }

                if(plPitchShifts != NULL && *plPitchShifts == 1)
                {
                    // Seek to the right place first
                    Seek(m_dwPCMSampleOut);

                    // Read one block since we're starting one block behind
                    hr = acmRead();
                    if(FAILED(hr))
                    {
                        break;
                    }
                }

                hr = acmRead();
            }

            if (FAILED(hr))
            {
                // acmRead spews when it fails; no need to do it again here
                break;
            }

            DWORD dwDstOffset = (ULONG)m_ash.dwDstUser;

            if(bRemoveSilence)
            {
                // We have partial data to throw away
                if(m_dwDecompStartOffset <= m_dwOffset)
                {
                    if(dwDstOffset > 0)
                    {
                        dwDstOffset += m_dwDecompStartDelta;
                    }
                    else
                    {
                        // This is the first decompressed block so we go straight to the value we know
                        dwDstOffset += m_dwDecompStartOffsetPCM;
                    }

                    m_ash.dwDstUser = dwDstOffset;
                    bRemoveSilence = false;
                }
                else
                {
                    // This is all throw away data
                    bRemoveSilence = false;
                    cbSize = min(cbRead, m_ash.cbDstLengthUsed - dwDstOffset);
                    m_ash.dwDstUser += cbSize;
                    continue;
                }
            }


            // We use the LPLONG plPitchShifts in the read method as a boolean
            // this is a HACK!! We need to change this...
            if(plPitchShifts && *plPitchShifts == 1)
            {
                dwDstOffset = m_dwPCMSampleOut - m_dwFirstPCMSample;
                m_ash.dwDstUser = dwDstOffset;
                plPitchShifts = 0;
            }

            cbSize = min(cbRead, m_ash.cbDstLengthUsed - dwDstOffset);

            dwOffset = DeinterleaveBuffers(
                            m_pwfxTarget,
                            &(m_ash.pbDst[dwDstOffset]),
                            (LPBYTE *)ppvWriteBuffers,
                            dwWriteBufferCount,
                            cbSize,
                            dwOffset);

            cbRead -= cbSize;
            m_ash.dwDstUser += cbSize;

            if ((m_fdwOptions & DSOUND_WVP_STREAMEND) &&
                (m_ash.dwDstUser >= m_ash.cbDstLengthUsed))
            {
                break;
            }
        }
        while(0 != cbRead);

        if(fRememberPreCache)
        {
            m_dwPCMSampleOut = dwOffset * dwWriteBufferCount;
        }

        if (SUCCEEDED(hr))
        {
            *pcb = dwOffset;
        }
    }

    TraceI(5, "CWaveViewPort::Read returning %x (%d bytes)\n", hr, dwOffset);
    return hr;
}

STDMETHODIMP CWaveViewPort::GetSize
(
    ULONGLONG      *pcb
)
{
    V_INAME(CWaveViewPort::GetSize);
    V_PTR_WRITE(pcb, ULONGLONG);
    
    TraceI(5, "CWaveViewPort::GetSize [%d samples]\n", m_cSamples);
    HRESULT hr = S_OK;

    if (m_fdwOptions & DSOUND_WVP_NOCONVERT)
    {
        //  No conversion.  This is trivial

        *pcb = (SAMPLE_TIME)(m_cbStream);
    }
    else if (!m_pwfxTarget)
    {
        hr = DSERR_UNINITIALIZED;
    }
    else
    {
        //  Conversion required; let's hope target format is PCM

        if (WAVE_FORMAT_PCM == m_pwfxTarget->wFormatTag)
        {
            //  Cool.  This is simply the number of samples X the block align

            *pcb = (SAMPLE_TIME)((m_cSamples - m_dwDecompressedStart) * m_pwfxTarget->nBlockAlign);
        }
        else
        {
            Trace(1, "ERROR: GetSize (Viewport): Conversion required and target is not PCM.\n");
            hr = DSERR_BADFORMAT;
        }
    }

    return (hr);
}

HRESULT CWaveViewPort::Create
(
    PCREATEVIEWPORT     pCreate
)
{
    DWORD           cbSize;
    MMRESULT        mmr;
    HRESULT         hr;
    LARGE_INTEGER   li;
    LPWAVEFORMATEX  pwfxSrc = pCreate->pwfxSource;
    LPWAVEFORMATEX  pwfxDst = pCreate->pwfxTarget;

    V_INAME(CWaveViewPort::Create);
    
    TraceI(5, "CWaveViewPort::Create [%d samples]\n", pCreate->cSamples);

    EnterCriticalSection(&m_CriticalSection);

    //  Clone source stream...

    hr = pCreate->pStream->Clone(&m_pStream);

    if (FAILED(hr))
    {
        LeaveCriticalSection(&m_CriticalSection);
        return (hr);
    }

    //  Misc assignments
    m_cSamples   = pCreate->cSamples;
    m_cbStream   = pCreate->cbStream;
    m_dwOffset   = 0L;
    m_fdwOptions = pCreate->fdwOptions;
    m_dwDecompressedStart = pCreate->dwDecompressedStart;
    m_dwDecompStartOffset = 0L;
    m_dwDecompStartOffsetPCM = 0L;
    m_dwDecompStartDelta = 0L;

    TraceI(5, "CWaveViewPort:: %d samples\n", m_cSamples);

    //  Allocate destination format
    cbSize = SIZEOFFORMATEX(pwfxDst);

    m_pwfxTarget = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbSize);

    if (NULL == m_pwfxTarget)
    {
        LeaveCriticalSection(&m_CriticalSection);
        TraceI(1, "OUT OF MEMORY: CWaveViewPort::Create - size: %d \n", cbSize);
        return (E_OUTOFMEMORY);
    }

    //  We don't own the buffer for pwfxDst, so we can't touch its cbSize.
    //  We have to set the size manually on PCM, we KNOW the buffer is
    //  large enough.

    CopyFormat(m_pwfxTarget, pwfxDst);
    if (WAVE_FORMAT_PCM == m_pwfxTarget->wFormatTag)
    {
        m_pwfxTarget->cbSize = 0;
    }

    //  Calculating (block-aligned) size of destination buffer...
    cbSize = (pwfxDst->nAvgBytesPerSec * CONVERTLENGTH) / 1000;
    cbSize = BLOCKALIGN(cbSize, pwfxDst->nBlockAlign);

    m_ash.pbDst = (LPBYTE)GlobalAllocPtr(GHND, cbSize);

    if (NULL == m_ash.pbDst)
    {
        LeaveCriticalSection(&m_CriticalSection);
        TraceI(1, "OUT OF MEMORY: CWaveViewPort::Create 01\n");
        return (E_OUTOFMEMORY);
    }

    m_ash.cbDstLength = cbSize;

    //  Getting stream starting offset...

    li.HighPart = 0;
    li.LowPart  = 0;
    hr = m_pStream->Seek(li, STREAM_SEEK_CUR, (ULARGE_INTEGER *)(&li));

    m_dwStartPos = li.LowPart;

    //  Do we need to use the ACM?
    if (FormatCmp(pwfxSrc, pwfxDst))
    {
        //  Formats compare!!  All we need to do is to copy the data straight
        //  from the source stream.  Way Cool!!

        TraceI(5, "Source and Destination formats are similar!\n");

        m_fdwOptions |= DSOUND_WVP_NOCONVERT;
    }
    else
    {
        //  Source and destination formats are different...

        TraceI(5, "CWaveViewPort:Create: Formats are different... Use ACM!\n");

        m_fdwOptions |= DSOUND_WVP_CONVERTSTATE_01;

        mmr = acmStreamOpen(&m_hStream, NULL, pwfxSrc, pwfxDst, NULL, 0, 0, 0);

        if (MMSYSERR_NOERROR != mmr)
        {
            Trace(1, "ERROR: Create (Viewport): Attempt to open a conversion stream failed.\n");
            LeaveCriticalSection(&m_CriticalSection);
            return MMRESULTToHRESULT(mmr);
        }

        mmr = acmStreamSize(m_hStream, cbSize, &cbSize, ACM_STREAMSIZEF_DESTINATION);

        if (MMSYSERR_NOERROR != mmr)
        {
            Trace(1, "ERROR: Create(Viewport): Could not convert target stream size to source format.\n");
            LeaveCriticalSection(&m_CriticalSection);
            return MMRESULTToHRESULT(mmr);
        }

        m_ash.cbSrcLength = cbSize;
        m_ash.pbSrc       = (LPBYTE)GlobalAllocPtr(GHND, cbSize);

        if (NULL == m_ash.pbSrc)
        {
            TraceI(1, "OUT OF MEMORY: CWaveViewPort:Create: GlobalAlloc failed.\n");
            LeaveCriticalSection(&m_CriticalSection);
            return E_OUTOFMEMORY;
        }

        // Also get the position for the actual start for the decompressed data
        if(m_dwDecompressedStart > 0)
        {
            m_dwDecompStartOffsetPCM = m_dwDecompressedStart * (pwfxDst->wBitsPerSample / 8) * pwfxDst->nChannels;
            mmr = acmStreamSize(m_hStream, m_dwDecompStartOffsetPCM, &m_dwDecompStartOffset, ACM_STREAMSIZEF_DESTINATION);
            
            DWORD dwDelta = 0;
            mmr = acmStreamSize(m_hStream, m_dwDecompStartOffset, &dwDelta, ACM_STREAMSIZEF_SOURCE);

            m_dwDecompStartDelta = m_dwDecompStartOffsetPCM - dwDelta;
            m_dwDecompStartOffset += m_dwStartPos;
        }

        //  For the source buffer, it is the full buffer size.
        m_ash.dwSrcUser       = m_ash.cbSrcLength;
        m_ash.cbSrcLengthUsed = m_ash.cbSrcLength;

        //  For the destination buffer, it is the offset into the buffer
        //  where the data can be found.
        m_ash.dwDstUser       = 0L;
        m_ash.cbDstLengthUsed = 0L;

        m_ash.cbStruct = sizeof(ACMSTREAMHEADER);

        mmr= acmStreamPrepareHeader(m_hStream, &m_ash, 0L);

        if (MMSYSERR_NOERROR != mmr)
        {
            Trace(1, "ERROR: Create (Viewport): Attempt to prepare header for conversion stream failed.\n");
            LeaveCriticalSection(&m_CriticalSection);
            return MMRESULTToHRESULT(mmr);
        }
    }

    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\waveutil.h ===
#ifndef	WAVEUTIL_H
#define WAVEUTIL_H

#define SIZEOFFORMAT(pwfx)		((WAVE_FORMAT_PCM == pwfx->wFormatTag)? \
								(sizeof(PCMWAVEFORMAT)): \
								(sizeof(WAVEFORMATEX)+pwfx->cbSize))

#define SIZEOFFORMATEX(pwfx)	(sizeof(WAVEFORMATEX) + \
								((WAVE_FORMAT_PCM == pwfx->wFormatTag)?0:pwfx->cbSize))

#define BLOCKALIGN(cb, b)		((DWORD)((DWORD)((DWORD)((cb) + (b) - 1) / (b)) * (b)))

#define V_PWFX_READ(p)			{ \
	V_PTR_READ(p, PCMWAVEFORMAT); \
	if (WAVE_FORMAT_PCM != p->wFormatTag) { V_PTR_READ(p, WAVEFORMATEX); \
		V_BUFPTR_READ(p, (sizeof(WAVEFORMATEX) + p->cbSize)); } \
}

void CopyFormat
(
	LPWAVEFORMATEX 	pwfxDst,
	LPWAVEFORMATEX 	pwfxSrc
);

void CopyFormatEx
(
	LPWAVEFORMATEX 	pwfxDst,
	LPWAVEFORMATEX 	pwfxSrc
);

BOOL FormatCmp
(
	LPWAVEFORMATEX 	pwfx1,
	LPWAVEFORMATEX 	pwfx2
);

DWORD DeinterleaveBuffers
(
	LPWAVEFORMATEX 	pwfx,
	LPBYTE 			pSrc,
	LPBYTE 			*ppbDst,
	DWORD 			cBuffers,
	DWORD 			cbSrcLength,
	DWORD 			dwBytesWritten
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dswave

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dswave.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1
USE_IOSTREAM=1

!if !$(FREEBUILD)

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32

TARGETLIBS=$(BASEDIR)\public\sdk\lib\*\kernel32.lib             \
           $(BASEDIR)\public\sdk\lib\*\advapi32.lib             \
           $(BASEDIR)\public\sdk\lib\*\uuid.lib                 \
           $(BASEDIR)\public\sdk\lib\*\msacm32.lib              \
           $(BASEDIR)\public\sdk\lib\*\ole32.lib        


INCLUDES=$(INCLUDES);   \
    ..\..\shared



SOURCES=..\debug.cpp   \
..\dll.cpp             \
..\guids.cpp           \
..\oledll.cpp          \
..\wave.cpp            \
..\stream.cpp          \
..\viewport.cpp        \
..\waveutil.cpp        \
..\dmstrm.cpp          \
..\dswave.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\wave.cpp ===
#include <objbase.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <dsoundp.h>
//#include "debug.h"

#include "debug.h" 
#include "dmusicc.h" 
#include "dmusici.h" 
#include "dmusicf.h" 
#include "validate.h"
#include "riff.h"
#include "dswave.h"
#include "riff.h"
#include <regstr.h>
#include <share.h>
#include "waveutil.h"
#include "dmstrm.h"

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

CWave::CWave() : m_dwDecompressedStart(0)
{
	V_INAME(CWave::CWave);

	InterlockedIncrement(&g_cComponent);

    InitializeCriticalSection(&m_CriticalSection);

    m_pwfx            = NULL;
    m_pwfxDst         = NULL;
	m_fdwFlags		  = 0;
    m_fdwOptions      = 0;
    m_cSamples        = 0L;
	m_pStream         = NULL;
	m_rtReadAheadTime = 0;

    m_cRef = 1;
}

CWave::~CWave()
{
	V_INAME(CWave::~CWave);

    if (NULL != m_pwfx)
    {
        GlobalFreePtr(m_pwfx);
    }
    if (NULL != m_pwfxDst)
    {
        GlobalFreePtr(m_pwfxDst);
    }

	if (m_pStream) m_pStream->Release();

    DeleteCriticalSection(&m_CriticalSection);

	InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CWave::QueryInterface
(
    const IID &iid,
    void **ppv
)
{
	V_INAME(CWave::QueryInterface);
	V_REFGUID(iid);
	V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectSoundWave)
    {
        *ppv = static_cast<IDirectSoundWave*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IPrivateWave)
    {
        *ppv = static_cast<IPrivateWave*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Wave Object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CWave::AddRef()
{
	V_INAME(CWave::AddRef);

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CWave::Release()
{
	V_INAME(CWave::Release);

    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

static inline HRESULT MMRESULTToHRESULT(
    MMRESULT mmr)
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_ALLOCATED:
        return DSERR_ALLOCATED;

    case MMSYSERR_NOMEM:
        return E_OUTOFMEMORY;

    case MMSYSERR_INVALFLAG:
        return E_INVALIDARG;

    case MMSYSERR_INVALHANDLE:
        return E_INVALIDARG;

    case MMSYSERR_INVALPARAM:
        return E_INVALIDARG;
    }

    return E_FAIL;
}   

STDMETHODIMP CWave::GetFormat
(
    LPWAVEFORMATEX pwfx,
    DWORD dwSizeAllocated,
    LPDWORD pdwSizeWritten
)
{
    DWORD           cbSize;
    LPWAVEFORMATEX  pwfxTemp = NULL;

	V_INAME(CWave::GetFormat);

    if (!pwfx && !pdwSizeWritten)
    {
        Trace(1, "ERROR: GetFormat (Wave): Must request either the format or the required size\n.");
        return E_INVALIDARG;
    }

    if (!m_pwfx)
    {
        return DSERR_BADFORMAT;
    }
    if (WAVE_FORMAT_PCM == m_pwfx->wFormatTag)
    {
        pwfxTemp = m_pwfx;
    }
    else
    {
        pwfxTemp = m_pwfxDst;
        if (!pwfxTemp)
        {
            return DSERR_BADFORMAT;
        }
    }

    //  Note: Assuming that the wave object fills the cbSize field even
    //  on PCM formats...

    if (WAVE_FORMAT_PCM == pwfxTemp->wFormatTag)
    {
        cbSize = sizeof(PCMWAVEFORMAT);
    }
    else
    {
        cbSize = sizeof(WAVEFORMATEX) + pwfxTemp->cbSize;
    }

    if (cbSize > dwSizeAllocated || !pwfx)
    {
        if (pdwSizeWritten)
        {
            *pdwSizeWritten = cbSize;
            return S_OK;  //  What to return?
        }
        else
        {
            return DSERR_INVALIDPARAM;
        }
    }

	//	We don't validate this parameter any earlier on the off chance
	//	that they're doing a query...

	V_BUFPTR_WRITE(pwfx, dwSizeAllocated); 

    CopyMemory(pwfx, pwfxTemp, cbSize);

    //  Set the cbSize field in destination for PCM, IF WE HAVE ROOM...

    if (WAVE_FORMAT_PCM == pwfxTemp->wFormatTag)
    {
        if (sizeof(WAVEFORMATEX) <= dwSizeAllocated)
        {
            pwfx->cbSize = 0;
        }
    }

    // Return the numbers of bytes actually writted
    if (pdwSizeWritten)
    {
        *pdwSizeWritten = cbSize;
    }

    return S_OK;
}

STDMETHODIMP CWave::CreateSource
(
    IDirectSoundSource  **ppSource,
    LPWAVEFORMATEX      pwfx,
    DWORD               fdwFlags
)
{
	HRESULT			hr = S_OK;
	CWaveViewPort* 	pVP;
	CREATEVIEWPORT	cvp;

	V_INAME(CWave::CreateSource);
	V_PTRPTR_WRITE(ppSource);
    V_PWFX_READ(pwfx);

    DWORD dwCreateFlags = 0;
    if (fdwFlags == DMUS_DOWNLOADINFO_ONESHOTWAVE)
    {
        dwCreateFlags |= DSOUND_WAVEF_ONESHOT;
    }
	if (dwCreateFlags & (~DSOUND_WAVEF_CREATEMASK))
	{
        Trace(1, "ERROR: CreateSource (Wave): Unknown flag.\n");
		return (E_INVALIDARG);
	}

    TraceI(5, "CWave::CreateSource [%d samples]\n", m_cSamples);
	
	pVP = new CWaveViewPort;
    if (!pVP)
    {
        return E_OUTOFMEMORY;
    }

	cvp.pStream 	        = m_pStream;
	cvp.cSamples	        = m_cSamples;
    cvp.dwDecompressedStart = m_dwDecompressedStart;
	cvp.cbStream	        = m_cbStream;
	cvp.pwfxSource	        = m_pwfx;
	cvp.pwfxTarget          = pwfx;
    cvp.fdwOptions          = dwCreateFlags;

	hr = pVP->Create(&cvp);

	if (SUCCEEDED(hr)) 
	{
		hr = pVP->QueryInterface(IID_IDirectSoundSource, (void **)ppSource);
	}
	else
	{
	    TraceI(5, "CWave::CreateSource 00\n");
	}

	if (SUCCEEDED(hr))
	{
		// The QI gave us one ref too many
		pVP->Release();
	}
	else
	{
	    TraceI(5, "CWave::CreateSource 01\n");
	}

    return hr;
}

STDMETHODIMP CWave::GetStreamingParms
(
    LPDWORD              pdwFlags, 
    LPREFERENCE_TIME    prtReadAhead
)
{
    V_INAME(IDirectSoundWave::GetStreamingParms);
    V_PTR_WRITE(pdwFlags, DWORD);
    V_PTR_WRITE(prtReadAhead, REFERENCE_TIME);
    
    *pdwFlags = 0;

    if(!(m_fdwFlags & DSOUND_WAVEF_ONESHOT))
    {
        *pdwFlags |= DMUS_WAVEF_STREAMING;
    }

    if(m_fdwFlags & DMUS_WAVEF_NOPREROLL)
    {
        *pdwFlags |= DMUS_WAVEF_NOPREROLL;
    }

    *prtReadAhead  = m_rtReadAheadTime;
    return S_OK;
}

STDMETHODIMP CWave::GetClassID
(
    CLSID*  pClsId
)
{
	V_INAME(CWave::GetClassID);
	V_PTR_WRITE(pClsId, CLSID); 

    *pClsId = CLSID_DirectSoundWave;
    return S_OK;
}

STDMETHODIMP CWave::IsDirty()
{
	V_INAME(CWave::IsDirty);

    return S_FALSE;
}

BOOL CWave::ParseHeader
(
    IStream*        pIStream,
    IRIFFStream*    pIRiffStream,
    LPMMCKINFO      pckMain
)
{
    MMCKINFO    ck;
    DWORD       cb = 0;
    DWORD       dwPos = 0;
    MMCKINFO    ckINFO;
    HRESULT     hr;

    ck.ckid    = 0;
    ck.fccType = 0;

	V_INAME(CWave::ParseHeader);

	BOOL fFormat = FALSE;
 	BOOL fData = FALSE;
 	BOOL fHeader = FALSE;
    BOOL fReadDecompressionFmt = FALSE;
    DWORD dwSamplesFromFact = 0;
   
    while (0 == pIRiffStream->Descend(&ck, pckMain, MMIO_FINDCHUNK))
    {
        switch (ck.ckid)
        {
            case mmioFOURCC('w','a','v','u') :
			{
                cb = 0;
                bool bRuntime = false;
                hr = pIStream->Read(&bRuntime, sizeof(bool), &cb);
                if(FAILED(hr) || cb != sizeof(bool))
                {
                    return FALSE;
                }

                cb = 0;
                bool bCompressed = false;
                hr = pIStream->Read(&bCompressed, sizeof(bool), &cb);
                if(FAILED(hr) || cb != sizeof(bool))
                {
                    return FALSE;
                }

                if(bRuntime && bCompressed)
                {
                    // If we have already allocated m_pwfxDst, delete it first
                    if (NULL != m_pwfxDst)
                    {
                        GlobalFreePtr(m_pwfxDst);
                    }

                    m_pwfxDst = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));
                    if (NULL == m_pwfxDst)
                    {
				        return FALSE;
                    }

                    cb = 0;
                    hr = pIStream->Read(m_pwfxDst, sizeof(WAVEFORMATEX), &cb);
                    if(FAILED(hr) || cb != sizeof(WAVEFORMATEX))
                    {
                        GlobalFreePtr(m_pwfxDst);
                        return FALSE;
                    }

                    // Read the actual start for the decompressed data if available
                    // This is very important for MP3 and WMA codecs which insert silence in the beginning
                    if(ck.cksize > 2 + sizeof(WAVEFORMATEX))
                    {
                        cb = 0;
                        hr = pIStream->Read(&m_dwDecompressedStart, sizeof(DWORD), &cb);
                        if(FAILED(hr) || cb != sizeof(DWORD))
                        {
                            GlobalFreePtr(m_pwfxDst);
                            return FALSE;
                        }
                    }

                    fReadDecompressionFmt = TRUE;
                }

				break;
			}

            case DMUS_FOURCC_WAVEHEADER_CHUNK:
			{
                m_fdwFlags = 0;
				fHeader = TRUE;
				DMUS_IO_WAVE_HEADER iWaveHeader;
				memset(&iWaveHeader, 0, sizeof(iWaveHeader));
                hr = pIStream->Read(&iWaveHeader, sizeof(iWaveHeader), &cb);
				if (iWaveHeader.dwFlags & DMUS_WAVEF_STREAMING)
				{
					m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
					m_rtReadAheadTime = iWaveHeader.rtReadAhead;
				}
				else
				{
					m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
					m_rtReadAheadTime = 0;
				}

                if (iWaveHeader.dwFlags & DMUS_WAVEF_NOPREROLL)
                {
                    m_fdwFlags |= DMUS_WAVEF_NOPREROLL;
                }
                else
                {
                    m_fdwFlags &= ~DMUS_WAVEF_NOPREROLL;
                }

                break;
			}

			case DMUS_FOURCC_GUID_CHUNK:
				hr = pIStream->Read(&m_guid, sizeof(GUID), &cb);
				m_fdwOptions |= DMUS_OBJ_OBJECT;
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
				hr = pIStream->Read( &m_vVersion, sizeof(DMUS_VERSION), &cb );
				m_fdwOptions |= DMUS_OBJ_VERSION;
                break;

            case FOURCC_LIST:
				switch(ck.fccType)
				{
                    case DMUS_FOURCC_INFO_LIST:
		                while( pIRiffStream->Descend( &ckINFO, &ck, 0 ) == 0 )
		                {
		                    switch(ckINFO.ckid)
		                    {
			                    case mmioFOURCC('I','N','A','M'):
			                    {
				                    DWORD cbSize;
				                    cbSize = min(ckINFO.cksize, DMUS_MAX_NAME);
				                    char szName[DMUS_MAX_NAME];
				                    hr = pIStream->Read((BYTE*)szName, cbSize, &cb);
				                    if(SUCCEEDED(hr))
				                    {
					                    MultiByteToWideChar(CP_ACP, 0, szName, -1, m_wszFilename, DMUS_MAX_NAME);
							            m_fdwOptions |= DMUS_OBJ_NAME;
				                    }
                                    break;
                                }
                            }
    		                pIRiffStream->Ascend( &ckINFO, 0 );
                        }
                        break;
                }
                break;

            case mmioFOURCC('f','m','t',' '):
            {
                // If we have already allocated m_pwfx, delete it first
                if (NULL != m_pwfx)
                {
                    GlobalFreePtr(m_pwfx);
                }

				m_pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, max (sizeof(WAVEFORMATEX), ck.cksize));

                if (NULL == m_pwfx)
                {
                    return FALSE;
                }

                hr = pIStream->Read(m_pwfx, ck.cksize, &cb);

                if (S_OK != hr)
                {
                    return FALSE;
                }

			    if (m_pwfx && WAVE_FORMAT_PCM != m_pwfx->wFormatTag)
			    {
                    if(fReadDecompressionFmt == FALSE)
                    {
                        // If we have already allocated m_pwfxDst, delete it first
                        if (NULL != m_pwfxDst)
                        {
                            GlobalFreePtr(m_pwfxDst);
                        }

                        m_pwfxDst = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));
                        if (NULL == m_pwfxDst)
                        {
				            return FALSE;
                        }
                        m_pwfxDst->wFormatTag = WAVE_FORMAT_PCM;

                        MMRESULT mmr = acmFormatSuggest(NULL, m_pwfx, m_pwfxDst, sizeof(WAVEFORMATEX), ACM_FORMATSUGGESTF_WFORMATTAG);
	                    if(MMSYSERR_NOERROR != mmr)
                        {
                            GlobalFreePtr(m_pwfxDst);
                            m_pwfxDst = NULL;
                            return FALSE;
                        }
                    }
                }

				fFormat = TRUE;
                TraceI(5, "Format [%d:%d%c%02d]\n", m_pwfx->wFormatTag, m_pwfx->nSamplesPerSec/1000, ((2==m_pwfx->nChannels)?'S':'M'), m_pwfx->wBitsPerSample);
                break;
            }

            case mmioFOURCC('f','a','c','t'):
                hr = pIStream->Read(&dwSamplesFromFact, sizeof(DWORD), &cb);
                TraceI(5, "Stream is %d samples\n", dwSamplesFromFact);
                break;

            case mmioFOURCC('d','a','t','a'):
                TraceI(5, "Data chunk %d bytes\n", ck.cksize);
                m_cbStream = ck.cksize;

				fData = TRUE;
				if (!fHeader) FallbackStreamingBehavior();

                // save stream position so we can seek back later
                dwPos = StreamTell( pIStream ); 
                break;

            default:
                break;
        }
        pIRiffStream->Ascend(&ck, 0);
        ck.ckid    = 0;
        ck.fccType = 0;
    }

	if (m_pwfx && WAVE_FORMAT_PCM != m_pwfx->wFormatTag && dwSamplesFromFact)
	{
        m_cSamples = dwSamplesFromFact;
    }

	if (!fHeader) FallbackStreamingBehavior();

    // Seek to beginning of data
    if (fData)
    {
		StreamSeek(pIStream, dwPos, STREAM_SEEK_SET);
    }
    return fFormat && fData;
}

STDMETHODIMP CWave::Load
(
    IStream*    pIStream
)
{
    IRIFFStream*    pIRiffStream = NULL;
    HRESULT         hr = S_OK;

	V_INAME(CWave::Load);

    if (NULL == pIStream)
    {
        Trace(1, "ERROR: Load (Wave): Attempt to load from null stream.\n");
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );

    if (SUCCEEDED(AllocRIFFStream(pIStream, &pIRiffStream)))
    {
        MMCKINFO    ckMain;

        ckMain.fccType = mmioFOURCC('W','A','V','E');

        if (0 != pIRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF))
        {
            Trace(1, "ERROR: Load (Wave): Stream does not contain a wave chunk.\n");
            hr = E_INVALIDARG;
			goto ON_END;
        }

        //  Parses the header information and seeks to the beginning
        //  of the data in the data chunk.

        if (0 == ParseHeader(pIStream, pIRiffStream, &ckMain))
        {
		    Trace(1, "ERROR: Load (Wave): Attempt to read wave's header information failed.\n");
            hr = E_INVALIDARG;
			goto ON_END;
        }

		if (0 == m_cSamples)
		{
			if (m_pwfx && WAVE_FORMAT_PCM == m_pwfx->wFormatTag)
			{
				m_cSamples = m_cbStream / m_pwfx->nBlockAlign;
			}
			else // wave format not supported
			{
				hr = DSERR_BADFORMAT;
				goto ON_END;
			}
		}
    }

	pIStream->AddRef();
    if (m_pStream)
    {
        m_pStream->Release();
    }
	m_pStream = pIStream;

ON_END:
	if (pIRiffStream) pIRiffStream->Release();
    LeaveCriticalSection( &m_CriticalSection );
    TraceI(5, "CWave::Load01\n");

    return hr;
}

STDMETHODIMP CWave::Save
(
    IStream*    pIStream,
    BOOL        fClearDirty
)
{
	V_INAME(CWave::Save);

	return E_NOTIMPL; 
}

STDMETHODIMP CWave::GetSizeMax
(
    ULARGE_INTEGER FAR* pcbSize
)
{
	V_INAME(CWave::GetSizeMax);

	return E_NOTIMPL; 
}

STDMETHODIMP CWave::GetDescriptor
(
    LPDMUS_OBJECTDESC   pDesc
)
{
    //  Parameter validation...

	V_INAME(CWave::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC)

    ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));

    pDesc->dwSize      = sizeof(DMUS_OBJECTDESC);
    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass   = CLSID_DirectSoundWave;

    if (NULL != m_pwfx)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }

    if (m_fdwOptions & DMUS_OBJ_OBJECT)
    {
        pDesc->guidObject   = m_guid;
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
    }

    if (m_fdwOptions & DMUS_OBJ_NAME)
    {
        memcpy( pDesc->wszName, m_wszFilename, sizeof(m_wszFilename) );
        pDesc->dwValidData |= DMUS_OBJ_NAME;
    }

    if (m_fdwOptions & DMUS_OBJ_VERSION)
    {
		pDesc->vVersion.dwVersionMS = m_vVersion.dwVersionMS;
		pDesc->vVersion.dwVersionLS = m_vVersion.dwVersionLS;
        pDesc->dwValidData |= DMUS_OBJ_VERSION;
    }

    return S_OK;
}

STDMETHODIMP CWave::SetDescriptor
(
    LPDMUS_OBJECTDESC   pDesc
)
{
    HRESULT hr = E_INVALIDARG;
    DWORD   dw = 0;

    //  Parameter validation...

	V_INAME(CWave::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC)

    if (pDesc->dwSize >= sizeof(DMUS_OBJECTDESC))
    {
        if(pDesc->dwValidData & DMUS_OBJ_CLASS)
        {
            dw           |= DMUS_OBJ_CLASS;
        }

        if(pDesc->dwValidData & DMUS_OBJ_LOADED)
        {
            dw           |= DMUS_OBJ_LOADED;
        }

        if (pDesc->dwValidData & DMUS_OBJ_OBJECT)
        {
            m_guid        = pDesc->guidObject;
            dw           |= DMUS_OBJ_OBJECT;
            m_fdwOptions |= DMUS_OBJ_OBJECT;
        }

        if (pDesc->dwValidData & DMUS_OBJ_NAME)
        {
            memcpy( m_wszFilename, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw           |= DMUS_OBJ_NAME;
            m_fdwOptions |= DMUS_OBJ_NAME;
        }

        if (pDesc->dwValidData & DMUS_OBJ_VERSION)
        {
			m_vVersion.dwVersionMS = pDesc->vVersion.dwVersionMS;
			m_vVersion.dwVersionLS = pDesc->vVersion.dwVersionLS;
			dw           |= DMUS_OBJ_VERSION;
			m_fdwOptions |= DMUS_OBJ_VERSION;
        }

        if (pDesc->dwValidData & (~dw))
        {
            Trace(2, "WARNING: SetDescriptor (Wave): Descriptor contains fields that were not set.\n");
            hr = S_FALSE;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CWave::ParseDescriptor
(
    LPSTREAM            pStream,
    LPDMUS_OBJECTDESC   pDesc
)
{
	V_INAME(CWave::ParseDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC)

    CRiffParser Parser(pStream);
    RIFFIO ckMain;
	RIFFIO ckNext;
    RIFFIO ckINFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == mmioFOURCC('W','A','V','E')))
    {
        Parser.EnterList(&ckNext);
	    while(Parser.NextChunk(&hr))
	    {
		    switch(ckNext.ckid)
		    {
            case DMUS_FOURCC_GUID_CHUNK:
				hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
				if( SUCCEEDED(hr) )
				{
					pDesc->dwValidData |= DMUS_OBJ_OBJECT;
				}
				break;

            case DMUS_FOURCC_VERSION_CHUNK:
				hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
				if( SUCCEEDED(hr) )
				{
					pDesc->dwValidData |= DMUS_OBJ_VERSION;
				}
				break;

			case FOURCC_LIST:
				switch(ckNext.fccType)
				{
                case DMUS_FOURCC_INFO_LIST:
                    Parser.EnterList(&ckINFO);
                    while (Parser.NextChunk(&hr))
					{
						switch( ckINFO.ckid )
						{
                        case mmioFOURCC('I','N','A','M'):
						{
				            DWORD cbSize;
				            cbSize = min(ckINFO.cksize, DMUS_MAX_NAME);
						    char szName[DMUS_MAX_NAME];
                            hr = Parser.Read(&szName, sizeof(szName));
						    if(SUCCEEDED(hr))
						    {
								MultiByteToWideChar(CP_ACP, 0, szName, -1, pDesc->wszName, DMUS_MAX_NAME);
								pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
							break;
						}
						default:
							break;
						}
					}
                    Parser.LeaveList();
					break;            
				}
				break;

			default:
				break;

		    }
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(2, "WARNING: ParseDescriptor (Wave): The stream does not contain a Wave chunk.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }
	
	return hr;
}

STDMETHODIMP CWave::GetLength(REFERENCE_TIME *prtLength)
{
	HRESULT hr = S_OK;
	if (0 == m_cSamples)
	{
		if (m_pwfx && WAVE_FORMAT_PCM == m_pwfx->wFormatTag)
		{
			m_cSamples = m_cbStream / m_pwfx->nBlockAlign;
		}
	}
	if (m_cSamples && m_pwfx && m_pwfx->nSamplesPerSec)
	{
        if(m_dwDecompressedStart > 0)
        {
            assert(m_dwDecompressedStart < m_cSamples);
            *prtLength = 1000 * (REFERENCE_TIME)(m_cSamples - m_dwDecompressedStart) / m_pwfx->nSamplesPerSec;
        }
        else
        {
		    *prtLength = 1000 * (REFERENCE_TIME)m_cSamples / m_pwfx->nSamplesPerSec;
        }
	}
	else
	{
        Trace(2, "WARNING: Couldn't get a length for a Wave.\n");
		hr = DMUS_E_BADWAVE;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dswave\stream.cpp ===
//	stream.cpp
// Copyright (C) 1997, 1998 Microsoft Corporation.  All Rights Reserved
//
// @doc EXTERNAL

#include <objbase.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"

#include "dmusicc.h" 
#include "dmusici.h" 
#include "riff.h"
#include "dswave.h"

STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff )
{
    if( ( *ppRiff = (IRIFFStream*) new CRIFFStream( pStream ) ) == NULL )
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


/* MyRead, MyWrite, MySeek
 *
 * These are functionally identical to mmioRead, mmioWrite, and mmioSeek,
 * except for the absence of the HMMIO parameter.
 */

long CRIFFStream::MyRead(void *pv, long cb)
{
    ULONG cbRead;
    if (FAILED(m_pStream->Read(pv, cb, &cbRead)))
        return -1;
    return cbRead;
}

long CRIFFStream::MyWrite(const void *pv, long cb)
{
    ULONG cbWritten;
    if (FAILED(m_pStream->Write(pv, cb, &cbWritten)))
        return -1;
    return cbWritten;
}

long CRIFFStream::MySeek(long lOffset, int iOrigin)
{
    LARGE_INTEGER   dlibSeekTo;
    ULARGE_INTEGER  dlibNewPos;

    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = lOffset;
    if (FAILED(m_pStream->Seek(dlibSeekTo, iOrigin, &dlibNewPos)))
        return -1;

    return dlibNewPos.LowPart;
}


UINT CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    FOURCC          ckidFind;       // chunk ID to find (or NULL)
    FOURCC          fccTypeFind;    // form/list type to find (or NULL)

    /* figure out what chunk id and form/list type to search for */
    if (wFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = NULL;
    else
    if (wFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (wFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = NULL;

    lpck->dwFlags = 0L;

    for(;;)
    {
        UINT        w;

        /* read the chunk header */
        if (MyRead(lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
        return MMIOERR_CHUNKNOTFOUND;
        FixBytes( FBT_LONG, &lpck->cksize );

        /* store the offset of the data part of the chunk */
        if ((lpck->dwDataOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        /* see if the chunk is within the parent chunk (if given) */
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        /* if the chunk if a 'RIFF' or 'LIST' chunk, read the
         * form type or list type
         */
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (MyRead(&lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = NULL;

        /* if this is the chunk we're looking for, stop looking */
        if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
            break;

        /* ascend out of the chunk and try again */
        if ((w = Ascend(lpck, 0)) != 0)
            return w;
    }

    return 0;
}


UINT CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        /* <lpck> refers to a chunk created by CreateChunk();
         * check that the chunk size that was written when
         * CreateChunk() was called is the real chunk size;
         * if not, fix it
         */
        LONG            lOffset;        // current offset in file
        LONG            lActualSize;    // actual size of chunk data

        if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {
            /* chunk size is odd -- write a null pad byte */
            if (MyWrite("\0", 1) != 1)
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        /* fix the chunk header */
        lpck->cksize = lActualSize;
        if (MySeek(lpck->dwDataOffset - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        FixBytes( FBT_LONG, &lpck->cksize );
        if (MyWrite(&lpck->cksize, sizeof(DWORD)) != sizeof(DWORD))  {
        	FixBytes( FBT_LONG, &lpck->cksize );
            return MMIOERR_CANNOTWRITE;
        }
        FixBytes( FBT_LONG, &lpck->cksize );
    }

    /* seek to the end of the chunk, past the null pad byte
     * (which is only there if chunk size is odd)
     */
    if (MySeek(lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L),
            SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


UINT CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    int             iBytes;         // bytes to write
    LONG            lOffset;        // current offset in file

    /* store the offset of the data part of the chunk */
    if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    /* figure out if a form/list type needs to be written */
    if (wFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (wFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    /* write the chunk header */
	FixBytes( FBT_MMCKINFO, lpck );
    if (MyWrite(lpck, (LONG) iBytes) != (LONG) iBytes)  {
    	FixBytes( FBT_MMCKINFO, lpck );
        return MMIOERR_CANNOTWRITE;
    }
    FixBytes( FBT_MMCKINFO, lpck );

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\alist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.h
//
#ifndef __ALIST_H__
#define __ALIST_H__

#include <windows.h>

class AListItem
{
public:
    AListItem() { m_pNext=NULL; };
    AListItem *GetNext() const {return m_pNext;};
    void SetNext(AListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    AListItem* Cat(AListItem* pItem);
    AListItem* AddTail(AListItem* pItem) {return Cat(pItem);};
    AListItem* Remove(AListItem* pItem);
    AListItem* GetPrev(AListItem *pItem) const;
    AListItem* GetItem(LONG index);

protected:
    AListItem *m_pNext;
};

class AList
{
public:
    AList() {m_pHead=NULL;};
    AListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    AListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(AListItem *pItem,AListItem *pInsert);
    void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(AList *pList)
        {
//            assert(pList!=NULL);
            if (pList)
            {
                m_pHead=m_pHead->Cat(pList->GetHead());
            }
        };
    void AddHead(AListItem *pItem)
        {
            if (pItem!=NULL)
            {
                pItem->SetNext(m_pHead);
                m_pHead=pItem;
            }
        };
    void AddTail(AListItem *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(AListItem *pItem) 
        {
            if (pItem != NULL)
            {
                m_pHead=m_pHead->Remove(pItem);
            }
        };
    AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    AListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(AListItem *pItem);
    AListItem *RemoveHead(void)
        {
            AListItem *li;
            li = m_pHead;
            if(m_pHead)
            {
                m_pHead = m_pHead->GetNext();
                li->SetNext(NULL);
            }
            return li;
        }
    void Reverse();

protected:
    AListItem *m_pHead;
};

#endif // __ALIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\dmscriptautguids.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declares the CLSIDs for creating the wrapper objects that implement the IDispatch
// interfaces for the various DirectMusic objects.  These CLSIDs are not public --
// they are only needed in the implementation of the DirectMusic objects.  A user of
// the IDispatch interface will get ahold of it by QueryInterface from the associated
// DirectMusic object.

#pragma once

DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\dmstrm.h ===
//
// dmstrm.h
// 
// Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
//


#ifndef DMSTRM_H
#define DMSTRM_H

DEFINE_GUID(IID_IDMStream, 0x1894c260, 0xaa21, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

DECLARE_INTERFACE_(IDMStream, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDMStream
	STDMETHOD(Init)					(THIS_ IStream* pStream) PURE;
    STDMETHOD(Descend)		(THIS_ LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD(Ascend)		(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(CreateChunk)	(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
   	STDMETHOD(SetStream)			(THIS_ IStream* pIStream) PURE;
    STDMETHOD_(IStream*, GetStream)	(THIS) PURE;
};

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream);

class CDirectMusicStream : public IDMStream
{
public:

    CDirectMusicStream();
    ~CDirectMusicStream();
 
	STDMETHODIMP Init(IStream* pStream);
	
	// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDMStream
    STDMETHODIMP Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags);
    STDMETHODIMP Ascend(LPMMCKINFO lpck, UINT wFlags);
    STDMETHODIMP CreateChunk(LPMMCKINFO lpck, UINT wFlags);

	STDMETHODIMP SetStream(IStream* pStream);
    STDMETHODIMP_(IStream*) GetStream();

private:
	long		m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on
};

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // #ifndef DMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2000 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
	if(pIStream == NULL || ppIDMStream == NULL)
	{
		return E_INVALIDARG;            
	}

	if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
		return E_OUTOFMEMORY;
    }
	
	((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream
   
CDirectMusicStream::~CDirectMusicStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init
   
STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CDirectMusicStream::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if(iid == IID_IUnknown || iid == IID_IDMStream)
	{
		*ppv = static_cast<IDMStream*>(this);
    } 
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
		m_pStream->Release();
    }

	m_pStream = pStream;
    
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

	FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
	{
		ckidFind = lpck->ckid;
		fccTypeFind = NULL;
	}
    else if(wFlags & MMIO_FINDRIFF)
    {
		ckidFind = FOURCC_RIFF;
		fccTypeFind = lpck->fccType;
    }
	else if(wFlags & MMIO_FINDLIST)
	{
		ckidFind = FOURCC_LIST;
		fccTypeFind = lpck->fccType;
	}
    else
    {
		ckidFind = fccTypeFind = NULL;
	}

    lpck->dwFlags = 0L;

    for(;;)
    {
		HRESULT hr;
		LARGE_INTEGER li;
		ULARGE_INTEGER uli;
		ULONG cbRead;

		// Read the chunk header
		hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// Store the offset of the data part of the chunk
		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lpck->dwDataOffset = uli.LowPart;
		}

		// See if the chunk is within the parent chunk (if given)
		if((lpckParent != NULL) &&
		   (lpck->dwDataOffset - 8L >=
		   lpckParent->dwDataOffset + lpckParent->cksize))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// If the chunk is a 'RIFF' or 'LIST' chunk, read the
		// form type or list type
		if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{

			ULONG cbRead;

			hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

			if(FAILED(hr) || (cbRead != sizeof(DWORD)))
			{
                Trace(1,"Error: Unable to read file.\n");
				return DMUS_E_DESCEND_CHUNK_FAIL;
			}
		}
		else
		{
			lpck->fccType = NULL;
		}

		// If this is the chunk we're looking for, stop looking
		if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
		   ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
		{
			break;
		}

		// Ascend out of the chunk and try again
		HRESULT w = Ascend(lpck, 0);
		if(FAILED(w))
		{
			return w;
		}
	}

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
	assert(lpck);

    HRESULT hr;
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;
	
	if (lpck->dwFlags & MMIO_DIRTY)
    {
		// <lpck> refers to a chunk created by CreateChunk();
		// check that the chunk size that was written when
		// CreateChunk() was called is the real chunk size;
		// if not, fix it
		LONG lOffset;           // current offset in file
		LONG lActualSize;   // actual size of chunk data

		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lOffset = uli.LowPart;
		}
		
		if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}

		if(LOWORD(lActualSize) & 1)
		{
			ULONG cbWritten;

			// Chunk size is odd -- write a null pad byte
			hr = m_pStream->Write("\0", 1, &cbWritten); 
			
			if(FAILED(hr) || cbWritten != 1)
			{
                Trace(1,"Error: Unable to write file.\n");
				return DMUS_E_CANNOTWRITE;
			}
		
		}
	
		if(lpck->cksize == (DWORD)lActualSize)
		{
			return S_OK;
		}

		// Fix the chunk header
		lpck->cksize = lActualSize;

		li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
		hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}

		ULONG cbWritten;

		hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
		
		if(FAILED(hr) || cbWritten != sizeof(DWORD))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}
    }

	// Seek to the end of the chunk, past the null pad byte
	// (which is only there if chunk size is odd)
	li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
	hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
	assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

	// Store the offset of the data part of the chunk
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;

	li.QuadPart = 0;
	HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}
    else
	{
		lOffset = uli.LowPart;
	}
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
	{
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
	else if(wFlags & MMIO_CREATELIST)
	{
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	}
    else
    {
		iBytes = 2 * sizeof(DWORD);
	}

    // Write the chunk header
	ULONG cbWritten;

	hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
		
	if(FAILED(hr) || cbWritten != iBytes)
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTWRITE;
	}

	lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\dmusicp.h ===
//
// dmusicp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICP_DOT_H_
#define _DMUSICP_DOT_H_

#include <dmusicf.h>

// private guid for script track events
DEFINE_GUID(IID_CScriptTrackEvent, 0x8f42c9da, 0xd37a, 0x499c, 0x85, 0x82, 0x1a, 0x80, 0xeb, 0xf9, 0xb2, 0x3c);

// Stuff used in melody formulation that's currently either not implemented or hidden by Producer.

/* Used to get a playmode to be used for a melody (pParam points to a single byte) */
DEFINE_GUID(GUID_MelodyPlaymode, 0x288ea6ca, 0xaecc, 0x4327, 0x9f, 0x79, 0xfb, 0x46, 0x44, 0x37, 0x4a, 0x65);

#define DMUS_FRAGMENTF_ANTICIPATE      (0x1 << 3) /* Anticipate next chord */
#define DMUS_FRAGMENTF_INVERT          (0x1 << 4) /* Invert the fragment */
#define DMUS_FRAGMENTF_REVERSE         (0x1 << 5) /* Reverse the fragment */
#define DMUS_FRAGMENTF_SCALE           (0x1 << 6) /* Align MIDI values with scale intervals */
#define DMUS_FRAGMENTF_CHORD           (0x1 << 7) /* Align MIDI values with chord intervals */
#define DMUS_FRAGMENTF_USE_PLAYMODE    (0x1 << 8) /* Use playmode to compute MIDI values */

#define DMUS_CONNECTIONF_GHOST         0x1        /* Use ghost notes for transitions */

// flags used in ComposeSegmentFromTemplateEx
typedef enum enumDMUS_COMPOSE_TEMPLATEF_FLAGS
{
    DMUS_COMPOSE_TEMPLATEF_ACTIVITY    = 0x1, // Use activity level (dx7 default)
    DMUS_COMPOSE_TEMPLATEF_CLONE       = 0x2  // Clone a segment from the template (dx7 default)
} DMUS_COMPOSE_TEMPLATEF_FLAGS;

// Interfaces/methods removed from Direct Music Performance layer:

// IDirectMusicSegment8P
interface IDirectMusicSegment8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicSegment8P
	virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(
		DWORD dwPChannel,    /* PChannel to search. */
		DWORD dwStage,       /* Which stage in the path. */
		DWORD dwBuffer,      /* Which buffer to address, if more than one. */
		REFGUID guidObject,  /* ClassID of object. */
		DWORD dwIndex,       /* Which object of that class. */
		REFGUID iidInterface,/* Requested COM interface. */
		void ** ppObject)=0; /* Pointer to interface. */
    virtual HRESULT STDMETHODCALLTYPE GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority) = 0;      /* Priority to set. */
    virtual HRESULT STDMETHODCALLTYPE SetAudioPathConfig(
        IUnknown *pAudioPathConfig) = 0; /* Audio path config, from file. */
};


// IDirectMusicComposer8P
interface IDirectMusicComposer8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicComposer8P
    // Use style to get embellishment lengths
	virtual HRESULT STDMETHODCALLTYPE ComposeTemplateFromShapeEx(
		WORD wNumMeasures,
		WORD wShape, 
		BOOL fIntro,
		BOOL fEnd,
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment** ppTemplate)=0;
    // New flags DWORD (discard activity level; compose in place)
    virtual HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplateEx(
        IDirectMusicStyle* pStyle, 
        IDirectMusicSegment* pTemplate, 
        DWORD dwFlags,
        DWORD dwActivity,
        IDirectMusicChordMap* pChordMap, 
        IDirectMusicSegment** ppSegment)=0;
};

//  IDirectMusicStyle8P
interface IDirectMusicStyle8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	//  IDirectMusicStyle8P
	virtual HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment* pTemplate, 
        IDirectMusicSegment** ppSegment)=0;
};

// IDirectMusicLoader8P
interface IDirectMusicLoader8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicLoader8P
	virtual HRESULT STDMETHODCALLTYPE GetDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		LPDMUS_OBJECTDESC pDesc,
		REFIID riid,
		LPVOID FAR *ppv)=0;
	virtual HRESULT STDMETHODCALLTYPE ReportDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		IUnknown *pReferencedObject)=0;

	// These should probably never be exposed publicly.
	// Scripts hold a reference to the loader because they need to be able to inform it
	// when they set variables to reference DirectMusic objects the loader tracks for
	// garbage collection.  However, that would create a circular reference because the
	// loader also holds a reference to scripts in its cache.  Garbage collection can't break
	// a circular reference that the loader itself is involved in.  Instead we use these private
	// ref count methods.  When the app is no longer using the loader (public Release drops
	// to zero) then the loader can clear its cache.  This releases references to scripts
	// (and also to streams, which use the same technique), triggering them to do ReleaseP
	// and everything gets cleaned up.
	virtual ULONG STDMETHODCALLTYPE AddRefP() = 0;	// Private AddRef, for scripts.
	virtual ULONG STDMETHODCALLTYPE ReleaseP() = 0;	// Private Release, for scripts.
};

// IDirectMusicBandP
interface IDirectMusicBandP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicBandP
	virtual HRESULT STDMETHODCALLTYPE DownloadEx(IUnknown *pAudioPath)=0; 
	virtual HRESULT STDMETHODCALLTYPE UnloadEx(IUnknown *pAudioPath)=0; 
};

// IDirectMusicObjectP
interface IDirectMusicObjectP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicObjectP
	virtual void STDMETHODCALLTYPE Zombie()=0; 
};

// IDirectMusicPerformanceP
interface IDirectMusicPerformanceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPerformanceP
    virtual HRESULT STDMETHODCALLTYPE GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags) = 0;
};

#define DM_PORTFLAGS_GM     1       /* Synth has GM set locally. */
#define DM_PORTFLAGS_GS     2       /* Synth has GS set locally. */
#define DM_PORTFLAGS_XG     4       /* Synth has XG set locally. */


// Private path stage to access the sink.
#define DMUS_PATH_SINK             0x5000      /* Access the DSound Sink interface. */

// GUIDs for new performance layer private interfaces
DEFINE_GUID(IID_IDirectMusicSegment8P, 0x4bd7fb35, 0x8253, 0x48e0, 0x90, 0x64, 0x8a, 0x20, 0x89, 0x82, 0x37, 0xcb);
DEFINE_GUID(IID_IDirectMusicComposer8P, 0xabaf70dc, 0xdfba, 0x4adf, 0xbf, 0xa9, 0x7b, 0x0, 0xe4, 0x19, 0xeb, 0xbb);
DEFINE_GUID(IID_IDirectMusicStyle8P, 0x2b7c5f39, 0x990a, 0x4fd7, 0x9b, 0x70, 0x1e, 0xa3, 0xde, 0x31, 0x55, 0xa5);
DEFINE_GUID(IID_IDirectMusicLoader8P, 0x3939facd, 0xf6ed, 0x4619, 0xbd, 0x16, 0x56, 0x60, 0x3f, 0x1, 0x51, 0xca);
DEFINE_GUID(IID_IDirectMusicBandP, 0xf2e00137, 0xa131, 0x4289, 0xaa, 0x6c, 0xa9, 0x60, 0x7d, 0x4, 0x85, 0xf5);
DEFINE_GUID(IID_IDirectMusicObjectP, 0x6a20c217, 0xeb3e, 0x40ec, 0x9f, 0x3a, 0x92, 0x5, 0x8, 0x70, 0x2b, 0x5e);
DEFINE_GUID(IID_IDirectMusicPerformanceP, 0xe583be58, 0xe93f, 0x4316, 0xbb, 0x6b, 0xcb, 0x2c, 0x71, 0x96, 0x40, 0x44);


/* DMUS_PMSGT_PRIVATE_TYPES fill the DMUS_PMSG's dwType member */
/* These start at 15000 in order to avoid conflicting with public DMUS_PMSGT_TYPES. */
typedef enum enumDMUS_PMSGT_PRIVATE_TYPES
{
    DMUS_PMSGT_SCRIPTTRACKERROR = 15000, /* Sent by the script track when an error occurs in the script. */
} DMUS_PMSGT_PRIVATE_TYPES;

/* DMUS_SCRIPT_TRACK_ERROR_PMSG */
/* These PMsgs are sent by the script track if there is a syntax error in a script it tries to connect to or
   if a routine it calls fails. */
typedef struct _DMUS_SCRIPT_TRACK_ERROR_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DMUS_SCRIPT_ERRORINFO ErrorInfo; /* The error that occured.  Same as structure returned by IDirectMusicScript's Init and CallRoutine members. */
} DMUS_SCRIPT_TRACK_ERROR_PMSG;

/* Track param type guids */

/* Use (call SetParam on the script track) to turn on PMsgs (DMUS_SCRIPT_TRACK_ERROR_PMSG) the script track sends if there
   is a syntax error in the script it tries to connect to or if one of the routines it calls fails. */
DEFINE_GUID(GUID_EnableScriptTrackError,0x1cc7e0bf, 0x981c, 0x4b9f, 0xbe, 0x17, 0xd5, 0x72, 0xfc, 0x5f, 0xa9, 0x33); // {1CC7E0BF-981C-4b9f-BE17-D572FC5FA933}

#endif          // _DMUSICP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\dmusiccp.h ===
//
// dmusiccp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICCP_DOT_H_
#define _DMUSICCP_DOT_H_

#include <dsoundp.h>  // For IDirectSoundWave

// Interfaces/methods removed from Direct Music Core layer:

// IDirectMusicVoiceP
interface IDirectMusicVoiceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicVoiceP
	virtual HRESULT STDMETHODCALLTYPE Play(
         REFERENCE_TIME rtStart,                // Time to play
         LONG prPitch,                          // Initial pitch
         LONG vrVolume                          // Initial volume
        )=0;
    
	virtual HRESULT STDMETHODCALLTYPE Stop(
          REFERENCE_TIME rtStop                 // When to stop
        )=0;
};


// IDirectSoundDownloadedWaveP
interface IDirectSoundDownloadedWaveP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectSoundDownloadedWaveP
};

// IDirectMusicPortP
interface IDirectMusicPortP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPortP
	virtual HRESULT STDMETHODCALLTYPE DownloadWave(
		IDirectSoundWave *pWave,                // Wave object
        IDirectSoundDownloadedWaveP **ppWave,   // Returned downloaded wave
        REFERENCE_TIME rtStartHint = 0          // Where we're likely to start
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE UnloadWave(
		IDirectSoundDownloadedWaveP *pWave      // Wave object
        )=0;
            
	virtual HRESULT STDMETHODCALLTYPE AllocVoice(
         IDirectSoundDownloadedWaveP *pWave,    // Wave to play on this voice
         DWORD dwChannel,                       // Channel and channel group
         DWORD dwChannelGroup,                  //  this voice will play on
         REFERENCE_TIME rtStart,                // Start position (stream only)
         SAMPLE_TIME stLoopStart,               // Loop start (one-shot only)
         SAMPLE_TIME stLoopEnd,                 // Loop end (one-shot only)
         IDirectMusicVoiceP **ppVoice           // Returned voice
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE AssignChannelToBuses(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
		LPDWORD pdwBuses,                       // Array of bus id's to assign
		DWORD cBusCount                         // Count of bus id's           
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE SetSink(
		IDirectSoundConnect *pSinkConnect       // From IDirectSoundPrivate::AllocSink
        )=0;
        
 	virtual HRESULT STDMETHODCALLTYPE GetSink(
		IDirectSoundConnect **ppSinkConnect     // The sink in use 
        )=0;
};

// GUIDs for new core layer private interfaces
DEFINE_GUID(IID_IDirectMusicVoiceP, 0x827ae928, 0xe44, 0x420d, 0x95, 0x24, 0x56, 0xf4, 0x93, 0x57, 0x8, 0xa6);
DEFINE_GUID(IID_IDirectSoundDownloadedWaveP, 0x3b527b6e, 0x5577, 0x4060, 0xb9, 0x6, 0xcd, 0x34, 0xa, 0x46, 0x71, 0x27);
DEFINE_GUID(IID_IDirectMusicPortP, 0x7048bcd8, 0x43fd, 0x4ca5, 0x93, 0x11, 0xf3, 0x24, 0x8f, 0xa, 0x25, 0x22);

// Class ID for synth sink. We pulled this from public headers since apps should never cocreate this.
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);


#endif          // _DMUSICCP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\miscutil.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Misc tiny helper functions.
//

#pragma once

// Releases a COM pointer and then sets it to NULL.  No effect if pointer already was NULL.
template<class T>
void SafeRelease(T *&t) { if (t) t->Release(); t = NULL; }

// Returns the number of elements in an array determined at compile time.
// Note: Only works for variables actually declared as arrays.  Don't try this with a pointer to an array.  There's no way to determine the size at that point.
#define ARRAY_SIZE(array) (sizeof(array) / sizeof(*(array)))

// Zeros memory of struct pointed to.
// Note: This is statically typed.  Don't use it with a pointer to void, pointer to an array, or a pointer to a base class because the size will be too small.
template<class T> void Zero(T *pT) { ZeroMemory(pT, sizeof(*pT)); }

// Zeros memory of the struct pointed to and sets its dwSize field.
template<class T> void ZeroAndSize(T *pT) { Zero(pT); pT->dwSize = sizeof(*pT); }

// Copies one dwSize struct to another dwSize struct without reading/writing beyond either struct
template<class T> void CopySizedStruct(T *ptDest, const T *ptSrc)
{
	assert(ptDest && ptSrc);
	DWORD dwDestSize = ptDest->dwSize;
	memcpy(ptDest, ptSrc, std::_cpp_min(ptDest->dwSize, ptSrc->dwSize));
	ptDest->dwSize = dwDestSize;
}

// Copy pwszSource to pwszDest where pwszDest is a buffer of size uiBufferSize.
// Returns S_OK if successful or DMUS_S_STRING_TRUNCATED if the string had to be truncated.
// Faster then wcsncpy for short strings because the entire buffer isn't padded with nulls.
inline HRESULT wcsTruncatedCopy(WCHAR *pwszDest, const WCHAR *pwszSource, UINT uiBufferSize)
{
    for (UINT i = 0; i < uiBufferSize; ++i)
    {
        if (!(pwszDest[i] = pwszSource[i])) // assign and check for null
            return S_OK; // the whole string copied
    }

    // string needs to be truncated
    pwszDest[uiBufferSize - 1] = L'\0';
    return DMUS_S_STRING_TRUNCATED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szApartment[]		= TEXT("Apartment");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szApartment);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
	lstrcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}

template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\toolprops_i.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Wed Jun 07 15:59:39 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Wed Jun 07 15:59:39 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\tpool.h ===
// Copyright (c) 1998 Microsoft Corporation
//
// TPool.h
//
// Template pool memory manager. Efficiently manage requests for many of the same (small) object.
// Named after t'Pool, the Vulcan programmer who invented the technique.
//
#ifndef _TPOOL_H_
#define _TPOOL_H_

#include "debug.h"

#define POOL_DEFAULT_BYTE_PER_BLOCK     4096
#define MIN_ITEMS_PER_BLOCK             4

///////////////////////////////////////////////////////////////////////////////
//
// CPool
//
// A simple memory manager that efficiently handles many objects of the same 
// size by allocating blocks containing multiple objects at once.
//
// 
template<class contained> class CPool
{
public:
    CPool(int nApproxBytesPerBlock = POOL_DEFAULT_BYTE_PER_BLOCK);
    ~CPool();

    contained *Alloc();
    void Free(contained* pToFree);

private:
    union CPoolNode
    {
        CPoolNode       *pNext;
        contained       c;
    };

    class CPoolBlock
    {
    public:
        CPoolBlock      *pNext;
        CPoolNode       *pObjects;
    };

    int                 nItemsPerBlock;             // Based on bytes per block
    int                 nAllocatedBlocks;           // # allocated blocks
    CPoolBlock          *pAllocatedBlocks;          // list of allocated blocks
    int                 nFreeList;                  // # nodes in free list
    CPoolNode           *pFreeList;                 // free list

private:
    bool RefillFreeList();

#ifdef DBG
    bool IsPoolNode(CPoolNode *pNode);
    bool IsInFreeList(CPoolNode *pNode);
#endif

};

///////////////////////////////////////////////////////////////////////////////
//
// CPool::CPool
//
// Figure out the number of contained objects per block based on the requested
// approximate block size. Initialize the free list to contain one block's 
// worth of objects.
// 
//
template<class contained> CPool<contained>::CPool(int nApproxBytesPerBlock)
{
    // Figure out how many items per block and cheat if too small
    //
    nItemsPerBlock = nApproxBytesPerBlock / sizeof(CPoolNode);
    if (nItemsPerBlock < MIN_ITEMS_PER_BLOCK)
    {
        nItemsPerBlock = MIN_ITEMS_PER_BLOCK;
    }

    nAllocatedBlocks = 0;
    pAllocatedBlocks = NULL;
    nFreeList = 0;
    pFreeList = NULL;

    // Fill up with some items ahead of time
    //
    RefillFreeList();
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::~CPool
//
// Free up all allocated blocks. There should be no outstanding blocks 
// allocated at this point.
//
// 
template<class contained> CPool<contained>::~CPool()
{
#ifdef DBG
    if (nFreeList < nAllocatedBlocks * nItemsPerBlock)
    {
        TraceI(0, "CPool::~Cpool: Warning: free'ing with outstanding objects allocated.\n");
    }
#endif
    
    // Clean up all allocated blocks and contained objects.
    //
    while (pAllocatedBlocks)
    {
        CPoolBlock *pNext = pAllocatedBlocks->pNext;

        delete[] pAllocatedBlocks->pObjects;
        delete pAllocatedBlocks;

        pAllocatedBlocks = pNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Alloc
//
// Attempt to allocate a contained object and return NULL if out of memory.
// If the free list is empty then allocate another block.
//
// 
template<class contained> contained *CPool<contained>::Alloc()
{
    if (pFreeList == NULL)
    {
        if (!RefillFreeList())
        {
            return false;
        }
    }

    nFreeList--;
    contained *pAlloc = (contained*)pFreeList;
    pFreeList = pFreeList->pNext;

    return pAlloc;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Free
//
// Return a contained object to the free list. In the debug version make sure
// the object was in fact allocated from this pool in the first place and that
// it isn't already in the free list.
//
// 
template<class contained> void CPool<contained>::Free(contained *pToFree)
{
    CPoolNode *pNode = (CPoolNode*)pToFree;

#ifdef DBG
    if (!IsPoolNode(pNode))
    {
        TraceI(0, "CPool::Free() Object %p is not a pool node; ignored.\n", pToFree);
        return;
    }
    
    if (IsInFreeList(pNode))
    {
        TraceI(0, "CPool::Free() Object %p is already in the free list; ignored.\n", pToFree);
        return;
    }
#endif

    nFreeList++;
    pNode->pNext = pFreeList;
    pFreeList = pNode;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::RefillFreeList
//
// Add one block's worth of contained objects to the free list, tracking the 
// allocated memory so we can free it later.
//
// 
template<class contained> bool CPool<contained>::RefillFreeList()
{
    // Allocate a new block and the actual block of objects
    //
    CPoolBlock *pNewBlock = new CPoolBlock;
    if (pNewBlock == NULL)
    {
        return false;
    }

    pNewBlock->pObjects = new CPoolNode[nItemsPerBlock];
    if (pNewBlock->pObjects == NULL)
    {
        delete pNewBlock;
        return false;
    }
    
    TraceI(1, "CPool: Alllocated block %p objects %p for %d bytes\n", 
        pNewBlock, pNewBlock->pObjects, sizeof(CPoolNode) * nItemsPerBlock);

    // Link the block and objects into the right places. First link the new block
    // into the list of allocated blocks.
    //
    pNewBlock->pNext = pAllocatedBlocks;
    pAllocatedBlocks = pNewBlock;

    // Link all the contained object nodes into the free list.
    //
    CPoolNode *pFirstNode = &pNewBlock->pObjects[0];
    CPoolNode *pLastNode  = &pNewBlock->pObjects[nItemsPerBlock - 1];

    for (CPoolNode *pNode = pFirstNode; pNode < pLastNode; pNode++)
    {
        pNode->pNext = pNode + 1;
    }

    pLastNode->pNext = pFreeList;
    pFreeList = pFirstNode;
    
    nFreeList += nItemsPerBlock;
    nAllocatedBlocks++;

    return true;
}

#ifdef DBG
///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsPoolNode (debug)
//
// Verify that the passed pointer is a pointer to a pool node by walking the list
// of allocated blocks.
//
// 
template<class contained> bool CPool<contained>::IsPoolNode(CPoolNode *pTest)
{
    for (CPoolBlock *pBlock = pAllocatedBlocks; pBlock; pBlock = pBlock->pNext)
    {
        CPoolNode *pFirstNode = &pBlock->pObjects[0];
        CPoolNode *pLastNode  = &pBlock->pObjects[nItemsPerBlock - 1];

        for (CPoolNode *pNode = pFirstNode; pNode <= pLastNode; pNode++)
        {
            if (pNode == pTest)
            {
                return true;
            }
        }
    }

    return false;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsInFreeList (debug)
//
// Verify that the passed pointer points to a node that is already in the free
// list.
//
// 
template<class contained> bool CPool<contained>::IsInFreeList(CPoolNode *pTest)
{
    for (CPoolNode *pNode = pFreeList; pNode; pNode = pNode->pNext)
    {
        if (pTest == pNode)
        {
            return true;
        }
    }
    
    return false;
}
#endif  // DBG
#endif  // _TPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\trackhelp.inl ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CPlayingTrack.
//

//////////////////////////////////////////////////////////////////////
// Creation

template<class T, class EventItem, class StateData>
CPlayingTrack<T, EventItem, StateData>::CPlayingTrack(
		long *plModuleLockCounter,
		const CLSID &rclsid,
		bool fNeedsLoader,
		bool fPlayInvalidations)
  : m_dwValidate(0),
	m_fNeedsLoader(fNeedsLoader),
	m_fPlayInvalidations(fPlayInvalidations),
	CBasicTrack(plModuleLockCounter, rclsid)
{
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

// Function used to sort the event list according to trigger time.
template<class EventItem>
struct CmpStruct //  shouldn't need this, but I had trouble getting a straight templated function to match the function pointer with the NT compiler.  try again later with the new one.
{
	static BOOL EventCompare(EventItem &ri1, EventItem &ri2)
	{
		return ri1.lTriggerTime < ri2.lTriggerTime;
	}
};

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::Load(IStream* pIStream)
{
	V_INAME(CPlayingTrack::Load);
	V_INTERFACE(pIStream);
	HRESULT hr = S_OK;

	SmartRef::CritSec CS(&m_CriticalSection);

	// Clear the event list in case we're being reloaded.
	m_EventList.CleanUp();
	// Increment counter so the next play will update state data with the new list.
	++m_dwValidate;

	// Get the loader if requested in constructor
	SmartRef::ComPtr<IDirectMusicLoader> scomLoader;
	if (m_fNeedsLoader)
	{
		IDirectMusicGetLoader *pIGetLoader;
		hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader, reinterpret_cast<void**>(&pIGetLoader));
		if (FAILED(hr))
			return hr;
		hr = pIGetLoader->GetLoader(&scomLoader);
		pIGetLoader->Release();
		if (FAILED(hr))
			return hr;
	}

	SmartRef::RiffIter ri(pIStream);
	if (!ri)
		return ri.hr();

	hr = this->LoadRiff(ri, scomLoader);
	if (FAILED(hr))
		return hr;

	m_EventList.MergeSort(CmpStruct<EventItem>::EventCompare);

	return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	V_INAME(CPlayingTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	SmartRef::CritSec CS(&m_CriticalSection);

	// Set up state data
	StateData *pStateData = new StateData;
	if (!pStateData)
		return E_OUTOFMEMORY;

	*ppStateData = pStateData;

	return S_OK;
}

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::EndPlay(void *pStateData)
{
	V_INAME(CPlayingTrack::EndPlay);
	V_BUFPTR_WRITE(pStateData, sizeof(StateData));

	SmartRef::CritSec CS(&m_CriticalSection);

	StateData *pSD = static_cast<StateData *>(pStateData);
	delete pSD;

	return S_OK;
}

template<class T, class EventItem, class StateData>
STDMETHODIMP
CPlayingTrack<T, EventItem, StateData>::Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack)
{
	V_INAME(CPlayingTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	SmartRef::CritSec CS(&m_CriticalSection);

	HRESULT hr = S_OK;

	T *pTrack = new T(&hr);
	if (FAILED(hr))
		return hr;
	*ppTrack = pTrack;
	if (!pTrack)
		return E_OUTOFMEMORY;

	pTrack->AddRef();
	for (TListItem<EventItem> *pItem = m_EventList.GetHead();
			pItem;
			pItem = pItem->GetNext())
	{
		EventItem &ritem = pItem->GetItemValue();
		if (ritem.lTriggerTime >= mtEnd)
			break;
		if (ritem.lTriggerTime < mtStart)
			continue;

		TListItem<EventItem> *pNewItem = new TListItem<EventItem>;
		if (!pNewItem)
		{
			hr = E_OUTOFMEMORY;
			goto End;
		}

		EventItem &rnew = pNewItem->GetItemValue();
		hr = rnew.Clone(ritem, mtStart);
		if (FAILED(hr))
		{
			delete pNewItem;
			goto End;
		}
		pTrack->m_EventList.AddHead(pNewItem);
	}
	pTrack->m_EventList.Reverse();
	++pTrack->m_dwValidate;

End:
	if (FAILED(hr))
		pTrack->Release();
	return hr;
}

template<class T, class EventItem, class StateData>
HRESULT
CPlayingTrack<T, EventItem, StateData>::PlayMusicOrClock(
	void *pStateData,
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	MUSIC_TIME mtOffset,
	REFERENCE_TIME rtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
	bool fClockTime)
{
	V_INAME(CPlayingTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(StateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	if (dwFlags & DMUS_TRACKF_PLAY_OFF)
		return S_OK;

	SmartRef::CritSec CS(&m_CriticalSection);

	StateData *pSD = static_cast<StateData *>(pStateData);
	TListItem<EventItem> *li = pSD->pCurrentEvent;

	// Seek through the event list to find the proper first event if
	// the event list pointed to by the state data has been reloaded
	// or if playback has made a jump to a different position in the track.
	if (m_dwValidate != pSD->dwValidate ||
			dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_LOOP | DMUS_TRACKF_FLUSH))
	{
		assert(m_dwValidate != pSD->dwValidate || dwFlags & DMUS_TRACKF_SEEK); // by contract SEEK should be set whenever the other dwFlags are
		li = this->Seek(mtStart);
		pSD->dwValidate = m_dwValidate;
	}

	if (m_fPlayInvalidations || !(dwFlags & DMUS_TRACKF_FLUSH))
	{
		for (; li; li = li->GetNext())
		{
			EventItem &rinfo = li->GetItemValue();
			if (rinfo.lTriggerTime < mtStart) // this can happen if DMUS_TRACKF_PLAY_OFF was set and the seek pointer remains at events from the past
				continue;
			if (rinfo.lTriggerTime >= mtEnd)
				break;
			if (FAILED(this->PlayItem(rinfo, *pSD, pPerf, pSegSt, dwVirtualID, mtOffset, rtOffset, fClockTime)))
			{
				// Returning an error from Play is not allowed.  Just ignore it and assert
				// so we would detect this while testing.
				assert(false);
				continue;
			}
		}
	}

	pSD->pCurrentEvent = li;
	return li ? S_OK : DMUS_S_END;
}

template<class T, class EventItem, class StateData>
TListItem<EventItem> *
CPlayingTrack<T, EventItem, StateData>::Seek(MUSIC_TIME mtStart)
{
	TListItem<EventItem> *li;
	for (li = m_EventList.GetHead();
			li && li->GetItemValue().lTriggerTime < mtStart;
			li = li->GetNext())
	{}

	return li;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\trackhelp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Unless you're doing something pretty unusual, you should be able to inherit from one
//    of these classes and reduce the work needed to implement a new track type.
//
// * CBasicTrack
//    Contains stubs that no-op or return notimpl most track methods.
//    You implement Load, InitPlay, EndPlay, PlayMusicOrClock, and Clone.
//
// * CPlayingTrack
//    CBasicTrack plus standard implementations of InitPlay, EndPlay, Clone.
//    PlayMusicOrClock and Load are partially implemented.  You fill in the rest by implementing
//       the methods PlayItem and LoadRiff.
//    You also must implement classes for event items and (optionally) state data.

#pragma once

#include "dmusici.h"
#include "validate.h"
#include "miscutil.h"
#include "tlist.h"
#include "smartref.h"


const int gc_RefPerMil = 10000; // Value for converting from reference time to milliseconds


//////////////////////////////////////////////////////////////////////
// TrackHelpCreateInstance
// Standard implementation of CreateInstance to call from class factory templated on
// the type of your derived class.  Your class constructor must take an HRESULT pointer
// it can use to return an error.

template <class T>
HRESULT TrackHelpCreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv, T *pUnused = NULL)
{
	// 
	// pUnused is just a dummy to force generation of the correct template type T.
	// Compiler bug?

	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	HRESULT hr = S_OK;
	T *pInst = new T(&hr);
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	if (FAILED(hr))
		return hr;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// CBasicTrack
//
// Base class with a standard implementation the following aspects of a DirectMusic track:
// - IUnknown: AddRef, Release, and QueryInterface (QI for IUnknown, IDirectMusicTrack, IDirectMusicTrack8, IPersistStream, IPersist)
// - IPersistStrea: stubs out GetClassID, IsDirty, Save, and GetSizeMax.
// - IDirectMusicTrack:
//      stubs out IsParamSupported, Init, GetParam, SetParam, AddNotificationType, RemoveNotificationType.
//      implements millisecond time conversion for PlayEx, GetParamEx, SetParamEx.
// - Declares and initializes a critical section.
//
// Pure virtual functions you must implement:
// - Load
// - InitPlay
// - EndPlay
// - Clone
// - PlayMusicOrClock (single method called by both Play and PlayEx)

class CBasicTrack
  : public IPersistStream,
	public IDirectMusicTrack8
{
public:
	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IPersistStream functions
	STDMETHOD(GetClassID)(CLSID* pClassID);
	STDMETHOD(IsDirty)() {return S_FALSE;}
	STDMETHOD(Load)(IStream* pStream) = 0;
	STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicTrack methods
	STDMETHOD(IsParamSupported)(REFGUID rguid) {return DMUS_E_TYPE_UNSUPPORTED;}
	STDMETHOD(Init)(IDirectMusicSegment *pSegment);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags) = 0;
	STDMETHOD(EndPlay)(void *pStateData) = 0;
	STDMETHOD(Play)(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHOD(GetParam)(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData) {return DMUS_E_GET_UNSUPPORTED;}
	STDMETHOD(SetParam)(REFGUID rguid,MUSIC_TIME mtTime,void *pData) {return DMUS_E_SET_UNSUPPORTED;}
	STDMETHOD(AddNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(RemoveNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack) = 0;

	// IDirectMusicTrack8
	STDMETHODIMP PlayEx(
		void* pStateData,
		REFERENCE_TIME rtStart,
		REFERENCE_TIME rtEnd,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHODIMP GetParamEx(REFGUID rguidType, REFERENCE_TIME rtTime, REFERENCE_TIME* prtNext, void* pParam, void * pStateData, DWORD dwFlags);
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid); // Takes pointer to lock counter to increment and decrement on component creation/destruction.  Typically, pass &g_cComponent and the clsid of your track.
	virtual ~CBasicTrack() { InterlockedDecrement(m_plModuleLockCounter); }

	// Shared implentation of play for either music or clock time.
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime) = 0;

	// Use this critical section to guard entry points for thread safety
	CRITICAL_SECTION m_CriticalSection;

private:
	long m_cRef;
	long *m_plModuleLockCounter;
	const CLSID &m_rclsid;
};

//////////////////////////////////////////////////////////////////////
// CPlayingTrack
//
// Base class that provides standard implementations of InitPlay, EndPlay, and Clone.
// Also, partially implemented are:
//  - PlayMusicOrClock.  You must implement the pure virual function PlayItem, which is
//    called during play as each event needs to be performed.
//  - Load.  This just does a few standard things (clearing the event list, incrementing the
//    state data counter, optionally getting the loader, and sorting the results).  It
//    depends on your implementation of the pure virtual function LoadRiff that you must
//    implement to do the real processing.
// Template types required:
//    T: Your derived class (needed for New in clone).  Must have a constructor that takes a pointer to an HRESULT.
//    StateData: Type for your state data.  Must contain dwValidate, used to check if the track has been reloaded, and pCurrentEvent, a pointer to the next event item to be played.
//    EventItem: Type for the event items in your track.  Must contain lTriggerTime, which is the time during Play when PlayItem will be called.  Must implement Clone, which copies another EventItem, shifting it back according to a start MUSIC_TIME.

// Standard state data for use with CPlayingTrack.  Or inherit from it and add more information.
template<class EventItem>
struct CStandardStateData
{
	CStandardStateData() : dwValidate(0), pCurrentEvent(NULL) {}
	DWORD dwValidate;
	TListItem<EventItem> *pCurrentEvent;
};

template<class T, class EventItem, class StateData = CStandardStateData<EventItem> >
class CPlayingTrack
  : public CBasicTrack
{
public:
	typedef StateData statedata;

	STDMETHOD(Load)(IStream* pIStream);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);
	STDMETHOD(EndPlay)(void *pStateData);
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime);

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	// fNeedsLoader: pass true if you will need a reference to the loader when your LoadRiff method is called
	// fPlayInvalidations: if true, then your items will be played more than once when an invalidation occurs
	//						pass false if your track doesn't want to respond to invalidations
	CPlayingTrack(long *plModuleLockCounter, const CLSID &rclsid, bool fNeedsLoader, bool fPlayInvalidations);

	virtual HRESULT PlayItem(
		const EventItem &item,
		StateData &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime) = 0; // feel free to add additional parameters if you need to pass more information from Play
	virtual HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader) = 0; // note that pIDMLoader will be null unless true is passed for fNeedsLoader in constructor

	virtual TListItem<EventItem> *Seek(MUSIC_TIME mtStart); // this method is provided in case you want to inherit and intercept when a seek is happening

	// Increment this counter in Load, causing the state data to synchonize with the new events
	DWORD m_dwValidate;
	TList<EventItem> m_EventList;
	bool m_fNeedsLoader;
	bool m_fPlayInvalidations;
};

#include "trackhelp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\smartref.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

// This is particularly helpful if you are using exception handling or simulating it (painfully)
//    in OLE by putting "if (FAILED(hr)) return;" after every function call.  In such circumstances
//    it simpler if you know that the resource will be automatically freed no matter how you end
//    up exiting the function.
// Since we're not using exception handling, these classes do not throw.  If resource acquisition
//    could fail, be sure to check for the error before using the resource!
// Sometimes these helper classes are more than just simple wrappers for freeing the resource.
//    They may also provide useful methods that make it easier to perform operations on the resource.
// Everything here is enclosed in the SmartRef namespace.  Thus you can't refer to CritSec directly.
//    Instead you must say SmartRef::CritSec.

#pragma once
#include "debug.h"
#include "mmsystem.h"
#include "dmstrm.h"
#include "dmerror.h"
#include "dmusici.h"

// Place this in the private: section of a class to prevent use of the default C++ copy and assignment.
// Creates an error if someone later tries to use the automatic member-by-member copy that would be incorrect.
// Use this if you don't do the work to implement correct copying or if copying doesn't make sense for this class.
#define NOCOPYANDASSIGN(classname) classname(const classname &o); classname &operator= (const classname &o);

namespace SmartRef
{

	// Enters a critical section on contruction.  Leaves on destruction.
	class CritSec
	{
	public:
		CritSec(CRITICAL_SECTION *pCriticalSection) : m_pCriticalSection(pCriticalSection) { EnterCriticalSection(m_pCriticalSection); }
		~CritSec() { LeaveCriticalSection(m_pCriticalSection); }
	private:
		NOCOPYANDASSIGN(CritSec)
		CRITICAL_SECTION *m_pCriticalSection;
	};

	// Makes a copy of an ANSI string and frees it on destruction.
	// hungarian: astr
	class AString
	{
	public:
		AString(const WCHAR *psz) : m_psz(NULL) { this->AssignFromW(psz); }
		AString(const char *psz = NULL) : m_psz(NULL) { *this = psz; }
		AString(const char *psz, UINT cch); // take first cch characters of psz
		AString(const AString &str) : m_psz(NULL) { *this = str.m_psz; }
		~AString() { *this = NULL; }
		operator const char *() const { return m_psz; }
		AString &operator= (const char *psz);
		AString &operator= (const AString &str) { return *this = str.m_psz; }
		AString &Assign(const char *psz, UINT cch); // take first cch characters of psz
		AString &AssignFromW(const WCHAR *psz);

		char ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		char *m_psz;
	};

	// Same as AString for Unicode strings.
	// Also accepts ANSI strings, converting them to Unicode.
	// hungarian: wstr
	class WString
	{
	public:
		WString(const char *psz) : m_psz(NULL) { this->AssignFromA(psz); }
		WString(const WCHAR *psz = NULL) : m_psz(NULL) { *this = psz; }
		WString(const WCHAR *psz, UINT cch) : m_psz(NULL) { this->Assign(psz, cch); }
		WString(const WString &str) : m_psz(NULL) { *this = str.m_psz; }
		~WString() { *this = static_cast<WCHAR *>(NULL); }
		operator const WCHAR *() const { return m_psz; }
		WString &operator= (const WCHAR *psz);
		WString &operator= (const WString &str) { return *this = str.m_psz; }
		WString &Assign(const WCHAR *psz, UINT cch); // take first cch characters of psz
		WString &AssignFromA(const char *psz);

		WCHAR ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		WCHAR *m_psz;
	};

	// Allocates a writable buffer of a fixed size and frees it on destruction.
	// (For example, you could use a Buffer<char> to write a string into.)
	// hungarian: buf prefixed by type
	//            use abuf for Buffer<char> and wbuf for Buffer<WCHAR>
	template<class T>
	class Buffer
	{
	public:
		Buffer(UINT uiSize) { m_p = new T[uiSize + 1]; }
		~Buffer() { delete[] m_p; }
		operator T *() { return m_p; }

		// use to defer allocation (say, if you don't know the size at the declaration)
		Buffer() : m_p(NULL) {}
		void Alloc(UINT uiSize) { delete[] m_p; m_p = new T[uiSize + 1]; }
		T* disown() { T *_p = m_p; m_p = NULL; return _p; }
		T** operator& () { assert(!m_p); return &m_p; } // allows direct setting of m_p, adopting a string without copying it

	private:
		NOCOPYANDASSIGN(Buffer)
		T *m_p;
	};

	// Holds an array that grows automatically.
	// Doesn't throw so you must call AccessTo before using a position that might have required
	//    reallocation to ensure that memory didn't run out.
	// Values held in the vector must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: vec prefixed by type
	//            of just use svec (for smart vector) without specifying the type
	//            use avec for Vector<char> and wvec for Vector<WCHAR>
	template<class T>
	class Vector
	{
	public:
		Vector() : m_pT(NULL), m_size(0), m_capacity(0) {}
		~Vector() { delete[] m_pT; }
		UINT size() { return m_size; }
		operator bool() { return m_fFail; }
		bool AccessTo(UINT uiPos) { return Grow(uiPos + 1); }
		T& operator[](UINT uiPos) { assert(uiPos < m_size); return m_pT[uiPos]; }
		T* GetArray() { return m_pT; } // Danger: only use when needed and don't write past the end.
		void Shrink(UINT uiNewSize) { m_size = uiNewSize; } // Semantically shrinks -- doesn't actually free up any memory

	private:
		NOCOPYANDASSIGN(Vector)
		bool Grow(UINT size)
			{
				if (size > m_size)
				{
					if (size > m_capacity)
					{
						for (UINT capacity = m_capacity ? m_capacity : 1;
								capacity < size;
								capacity *= 2)
						{}
						T *pT = new T[capacity];
						if (!pT)
							return false;
						for (UINT i = 0; i < m_size; ++i)
							pT[i] = m_pT[i];
						delete[] m_pT;
						m_pT = pT;
						m_capacity = capacity;
					}
					m_size = size;
				}
				return true;
			}

		T *m_pT;
		UINT m_size;
		UINT m_capacity;
	};

	// Standard stack abstract data type.
	// Values held in the stack must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: stack prefixed by type
	template<class T>
	class Stack
	{
	public:
		Stack() : iTop(-1) {}
		bool empty() { return iTop < 0; }
		HRESULT push(const T& t) { if (!m_vec.AccessTo(iTop + 1)) return E_OUTOFMEMORY; m_vec[++iTop] = t; return S_OK; }
		T top() { if (empty()) {assert(false); return T();} return m_vec[iTop]; }
		void pop() { if (empty()) {assert(false); return;} --iTop; }

	private:
		Vector<T> m_vec;
		int iTop;
	};

	// Lookup table that maps keys to values.  Grows automatically as needed.
	// Type K (keys) must support operator =, operator ==. and a Hash function that returns an int.
	// Type V must support operator =.
	template <class K, class V>
	class Hash
	{
	public:
		Hash(HRESULT *phr, int iInitialSize = 2) : m_p(NULL), m_iCapacity(0), m_iSize(0) { *phr = Grow(iInitialSize); }
		~Hash() { delete[] m_p; }

		struct entry
		{
			V v;
			bool fFound() { return iHash != -1; }
		private:
			// only let the hash make them
			friend class Hash<K, V>;
			entry() : iHash(-1) {};
			entry(const entry &o); // disallowed copy constructor

			int iHash;
			K k;
		};

		entry &Find(K k) // if iHash is -1 then it wasn't found and you may immediately add the entry using Add().
		{
			assert(m_p);
			return HashTo(k.Hash(), k, m_p, m_iCapacity);
		}

		// Warning: no intervening additions may have occurred between the time e was returned by Find and the time Add(e, ...) is called.
		// Also k must be the same in both calls.  If you want to be crafty, "same" can be replaced with equivalence in terms of Hash and operator==.
		HRESULT Add(entry &e, K k, V v)
		{
			assert(!e.fFound());
			assert(&e == &Find(k));

			e.v = v;
			e.iHash = k.Hash();
			e.k = k;
			++m_iSize;
			if (m_iSize * 2 > m_iCapacity)
				return Grow(m_iCapacity * 2);
			return S_OK;
		}

		V &operator[](K k)
		{
			entry &e = Find(k);
			assert(e.fFound());
			return e.v;
		}

	private:
		HRESULT Grow(int iCapacity)
		{
#ifdef DBG
			// size must be at least 2 and a power of 2
			for (int iCheckSize = iCapacity; !(iCheckSize & 1); iCheckSize >>= 1)
			{}
			assert(iCapacity > 1 && iCheckSize == 1);
#endif

			// alloc new table
			entry *p = new entry[iCapacity];
			if (!p)
			{
				delete[] m_p;
				return E_OUTOFMEMORY;
			}

			// rehash everything into the larger table
			for (int i = 0; i < m_iCapacity; ++i)
			{
				entry &eSrc = m_p[i];
				if (eSrc.iHash != -1)
				{
					entry &eDst = HashTo(eSrc.iHash, eSrc.k, p, iCapacity);
					assert(eDst.iHash == -1);
					eDst = eSrc;
				}
			}

			delete[] m_p;
			m_p = p;
			m_iCapacity = iCapacity;
			return S_OK;
		}

		entry &HashTo(int iHash, K k, entry *p, int iCapacity)
		{
			// initial hash using modulus, then jump three slots at a time (3 is guaranteed to take us to all slots because capacity is a power of 2)
			assert(iHash >= 0);
			for (int i = iHash % iCapacity;
					p[i].iHash != -1 && (p[i].iHash != iHash || !(p[i].k == k)); // rehash while slot occupied or it doesn't match
					i = (i + 3) % iCapacity)
			{}
			return p[i];
		}
		
		entry *m_p;
		int m_iCapacity;
		int m_iSize;
	};

	// Holds the supplied pointer and frees it on destruction.
	// hungarian: sp (smart pointer)
	template <class T>
	class Ptr
	{
	public:
		Ptr(T *_p) : p(_p) {}
		~Ptr() { delete p; }
		operator T*() { return p; }
		T *operator->() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(Ptr)
		T* p;
	};

	// Holds the supplied pointer to an array and frees it (with delete[]) on destruction.
	// hungarian: sprg
	template <class T>
	class PtrArray
	{
	public:
		PtrArray(T *_p) : p(_p) {}
		~PtrArray() { delete[] p; }
		operator T*() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(PtrArray)
		T* p;
	};

	// Holds the supplied COM interface and releases it on destruction.
	// hungarian: scom
	template <class T>
	class ComPtr
	{
	public:
		ComPtr(T *_p = NULL) : p(_p) {}
		~ComPtr() { *this = NULL; }
		operator T*() { return p; }
		T* operator-> () { assert(p); return p; }
		ComPtr &operator= (T *_p) { if (p) p->Release(); p = _p; return *this; }
		T** operator& () { assert(!p); return &p; }

		void Release() { *this = NULL; }
		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		T* p;
	};

	// Holds the supplied registry key handle and closes it on destruction.
	// hungarian: shkey
	class HKey
	{
	public:
		HKey(HKEY hkey = NULL) : m_hkey(hkey) {}
		~HKey() { *this = NULL; }
		HKey &operator= (HKEY hkey) { if (m_hkey) ::RegCloseKey(m_hkey); m_hkey = hkey; return *this; }
		HKEY *operator& () { assert(!m_hkey); return &m_hkey; }
		operator HKEY() { return m_hkey; }

	private:
		NOCOPYANDASSIGN(HKey)
		HKEY m_hkey;
	};

	// Allocates and clears a one of the DMUS_*_PMSG structures.  You fill out its fields
	// and then call StampAndSend.  The message is automatically cleared after a successful
	// send or freed on destruction.  Be sure the check the hr function for failures.
	// hungarian: pmsg
	template <class T>
	class PMsg
	{
	public:
		T *p; // pointer to the message structure -- use to set the fields before sending
		PMsg(IDirectMusicPerformance *pPerf, UINT cbExtra = 0) // use cbExtra to allocate extra space in the structure, such as for DMUS_SYSEX_PMSG or DMUS_LYRIC_PMSG
		  : m_pPerf(pPerf), m_hr(S_OK), p(NULL)
		{
			const UINT cb = sizeof(T) + cbExtra;
			m_hr = m_pPerf->AllocPMsg(cb, reinterpret_cast<DMUS_PMSG**>(&p));
			if (SUCCEEDED(m_hr))
			{
				assert(p->dwSize == cb);
				ZeroMemory(p, cb);
				p->dwSize = cb;
			}
		}
		~PMsg() { if (p) m_pPerf->FreePMsg(reinterpret_cast<DMUS_PMSG*>(p)); }
		void StampAndSend(IDirectMusicGraph *pGraph)
		{
			m_hr = pGraph->StampPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (FAILED(m_hr))
				return;

			m_hr = m_pPerf->SendPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (SUCCEEDED(m_hr))
				p = NULL; // PMsg now owned by the performance
		}
		HRESULT hr() { return m_hr; }

	private:
		NOCOPYANDASSIGN(PMsg)
		IDirectMusicPerformance *m_pPerf; // weak ref
		HRESULT m_hr;
	};

	// Walks through the RIFF file structure held in a stream.  Releases it on destruction.
	// Although I found this to be quite useful, it a bit complicated.  You should look over
	//    the source or step through some examples before you use it.  Although I'm not positive
	//    this wouldn't work, it is not designed to have multiple RiffIter's walking over the
	//    same stream at once (see note in Descend).
	// hungarian: ri
	class RiffIter
	{
	public:
		enum RiffType { Riff, List, Chunk };

		RiffIter(IStream *pStream);
		~RiffIter();

		RiffIter &operator ++();
		RiffIter &Find(RiffType t, FOURCC id);
		HRESULT FindRequired(RiffType t, FOURCC id, HRESULT hrOnNotFound) { if (Find(t, id)) return S_OK; HRESULT _hr = hr(); return SUCCEEDED(_hr) ? hrOnNotFound : _hr; } // Attempts to find the expected chunk.  Returns S_OK if found, an error code if there was a problem reading, and hrOnNotFound if reading worked OK but the chunk simply wasn't there.

		// With Descend, use the returned iterator to process the children before resuming use of the parent.  Using both at once won't work.
		RiffIter Descend() { validate(); return RiffIter(*this, m_ckChild); }

		operator bool() const { return SUCCEEDED(m_hr); }
		HRESULT hr() const { return (m_hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : m_hr; }

		RiffType type() const { validate(); return (m_ckChild.ckid == FOURCC_LIST) ? List : ((m_ckChild.ckid == FOURCC_RIFF) ? Riff : Chunk); }
		FOURCC id() const { validate(); return (type() == Chunk) ? m_ckChild.ckid : m_ckChild.fccType; }

		DWORD size() const { validate(); assert(type() == Chunk); return m_ckChild.cksize; }
		HRESULT ReadChunk(void *pv, UINT cb);
		HRESULT ReadArrayChunk(DWORD cbSize, void **ppv, int *pcRecords); // Reads an array chunk that is an array of records where the first DWORD gives the size of the records.  The records are copied into an array of records of size dwSize (filling with zero if the actual records in the file are smaller and ignoring additional fields if the actual records are larger).  ppv is set to return a pointer to this array, which the caller now owns and must delete.  pcRecords is set to the number of records returned.

		// Find the chunk (or return hrOnNoteFound). Load an object embedded in the stream. Then leaves the iterator on the next chunk.
		HRESULT FindAndGetEmbeddedObject(RiffType t, FOURCC id, HRESULT hrOnNotFound, IDirectMusicLoader *pLoader, REFCLSID rclsid, REFIID riid, LPVOID *ppv);

		// read specific RIFF structures
		HRESULT ReadReference(DMUS_OBJECTDESC *pDESC); // no need to init (zero, set size) the passed descriptor before calling
		HRESULT LoadReference(IDirectMusicLoader *pIDMLoader, const IID &iid, void **ppvObject)
		{
			DMUS_OBJECTDESC desc;
			HRESULT hr = ReadReference(&desc);
			if(SUCCEEDED(hr))
				hr = pIDMLoader->GetObject(&desc, iid, ppvObject);
			return hr;
		}

		struct ObjectInfo
		{
			ObjectInfo() { Clear(); }
			void Clear() { wszName[0] = L'\0'; guid = GUID_NULL; vVersion.dwVersionMS = 0; vVersion.dwVersionLS = 0; }

			WCHAR wszName[DMUS_MAX_NAME];
			GUID guid;
			DMUS_VERSION vVersion;
		};
		HRESULT LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop); // No need to init/zero. Reads from <guid-ck>, <vers-ck>, and <UNFO-list>/<UNAM-ck>. Stops at rtypeStop/ridStop, or returns E_FAIL if not found.

		HRESULT ReadText(WCHAR **ppwsz); // allocates a buffer and reads the current chunk--a NULL-terminated Unicode string--into it
		HRESULT ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize); // reads only as much as it can fit in the buffer with a terminator

		// This is deliberately placed in the public section but never implemented in order to allow statements such as:
		//   SmartRef::RiffIter riChild = ri.Descend();
		// But it is never defined to prevent someone from trying to actually make two copies of a riffiter and then use them, which is not supported.
		// This would yield an unresolved symbol error:
		//   SmartRef::RiffIter riError = ri;
		// We don't allow general copying of RiffIters.  Only used to get the return value of Descend, where it is optimized away.
		RiffIter(const RiffIter &o);

	private:
		RiffIter &operator= (const RiffIter &o); // Also never defined -- don't allow assignment

		RiffIter(const RiffIter &other, MMCKINFO ckParent);
		bool validate() const { if (FAILED(m_hr)) { assert(false); return true; } else return false; }

		HRESULT m_hr;
		IStream *m_pIStream;
		IDMStream *m_pIDMStream;
		bool m_fParent;
		MMCKINFO m_ckParent;
		MMCKINFO m_ckChild;
	};

	// Templated ReadChunk typed helpers (templated member function wasn't working for me on current version of compiler)
	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }
	template <class T> HRESULT RiffIterReadArrayChunk(RiffIter &ri, T **ppT, int *pcRecords) { return ri.ReadArrayChunk(sizeof(T), reinterpret_cast<void**>(ppT), pcRecords); }

}; // namespace SmartRef
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\validp.h ===
// Copyright (c) 1998 Microsoft Corporation
// ValidP.h --- An inline function to test for valid pointers

#ifndef __VALID_P__
#define __VALID_P__

// The debug version checks for Null pointers and pointers to unreadable/unwriteable data.
// (NOTE: only the first byte pointed to is checked)
// The non-debug version just checks for Null pointers.

template <class T>
inline BOOL Validate(T *p)
{ 
#ifdef _DEBUG
	return (p != NULL) && !IsBadReadPtr(p, 1) && !IsBadWritePtr(p, 1);
#else
	return p != NULL;
#endif
}

/* Use:

  Foo *pFoo;
  //
  // stuff...
  //
  if (Validate(pFoo))
  {
     // do stuff with the pointer
  }
  else
  {
     // don't do stuff with the pointer
  }

*/

#endif // __VALID_P__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\common\dputils.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dputils.c
 *  Content:	common support routines
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *  3/17/97	kipo	created it
 ***************************************************************************/

#include <windows.h>

#include "dpf.h"
#include "dputils.h"

/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr)
{
	int rval;
	BOOL bDefault;


	bDefault = FALSE;
	if (!lpWStr && cchStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DDASSERT(FALSE);
		return 0;
	}
	
	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
			DPLAY_DEFAULT_CHAR,&bDefault);

	if (bDefault)
	{
		DPF(0,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
		DPF(0,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
	}
	
	return rval;

} // WideToAnsi

/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr)
{
	int rval;

	if (!lpStr && cchWStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DDASSERT(FALSE);
		return 0;
	}

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);

	return rval;
}  // AnsiToWide
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\shared\validate.h ===
//
// validate.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Parameter validation macros
//
// Summary:
//
// V_INAME(interfacename)                - Set the interface name for error display
// V_STRUCTPTR_READ(ptr,type)            - A dwSize struct which we will read
// V_STRUCTPTR_WRITE(ptr,type)           - A dwSize struct which we will read/write
// V_PTR_READ(ptr,type)                  - A typed ptr w/o a dwSize which we will read
// V_PTR_WRITE(ptr,type)                 - A typed ptr w/o a dwSize which we will read/write
// V_PTR_WRITE_OPT(ptr,type)             - An optional typed ptr w/o a dwSize which we will read/write
// V_BUFPTR_READ(ptr,size)               - A variable-size buffer that we will read
// V_BUFPTR_READ_OPT(ptr,size)			 - An optional variable-size buffer that we will read
// V_BUFPTR_WRITE(ptr,size)              - A variable-size buffer that we will read/write
// V_BUFPTR_WRITE_OPT(ptr,size)          - An optional variable-size buffer that we will read/write
// V_PTRPTR_WRITE(ptrptr)                - A pointer to a pointer to write to
// V_PTRPTR_WRITE_OPT(ptrptr)            - A pointer to a pointer to write to that is optional
// V_PUNKOUTER(punk)                     - A pointer to a controlling unknown, aggregation supported
// V_PUNKOUTER_NOADD(punk)               - A pointer to a controlling unknown, aggregation not supported
// V_INTERFACE(ptr)                      - A pointer to a COM interface
// V_INTERFACE_OPT(ptr)                  - An optional pointer to a COM interface
// V_REFGUID(ref)                        - A reference to a GUID (type REFGUID)
// V_HWND(hwnd)							 - A window handle
// V_HWNDOPT(hwnd)						 - An optional window handle
//
// For handling different versions of structures:
// 
// V_STRUCTPTR_READ_VER(ptr,ver)         - Begin a struct version block for read access
//                                         At the end, 'ver' will contain the 
//                                         discovered version of the struct
// V_STRUCTPTR_READ_VER_CASE(base,ver)   - Test struct against version ver of
//                                         type 'base'. 
// V_STRUCTPTR_READ_VER_END(base,ptr)    - End a struct version block
//
// V_STRUCTPTR_WRITE_VER(ptr,ver)        - Struct version block for write access
// V_STRUCTPTR_WRITE_VER_CASE(base,ver)
// V_STRUCTPTR_WRITE_VER_END(base,ptr)
//
// The struct version block expects type names of a base type followed by a 
// numeric version, such as
//
// typedef struct { } FOO7;
// typedef struct { } FOO8;
//
// In the header FOO and LPFOO are conditionally typedef'd based on a version
// #define. The DLL will be compiled with the latest version number and hence
// the largest version of the struct.
//
// Since Windows headers are compiled by default with 8-byte alignment, adding
// one DWORD may not cause the size of the structure to change. If this happens
// you will get a 'case label already used' error on one of the VER_CASE macros.
// If this happens, you can get around it by adding a dwReserved field to the 
// end of the struct to force the padding.
//
// 'optional' means the pointer is allowed to be NULL by the interface specification.
//
// Sample usage:
//
// int IDirectMusic::SetFooBarInterface(
//     LPDMUS_REQUESTED_CAPS    pCaps,          // Caps w/ dwSize (read-only)
//     LPVOID                   pBuffer,        // Buffer we will fill in
//     DWORD                    cbSize,         // Size of the buffer
//     PDIRECTMUSICBAR          pBar)           // Callback interface for bar on this buffer
// {
//     V_INTERFACE(IDirectMusic::SetFooBarInterface);
//     V_BUFPTR_WRITE(pBuffer, cbSize);
//     V_INTERFACE(pBar);
//     DWORD dwCapsVer;                         // Must be a DWORD!!!
//
//     V_STRUCTPTR_READ_VER(pCaps, dwCapsVer);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 7);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 8);
//     V_STRUCTPTR_READ_VER_END_(DMUS_REQUESTED_CAPS, pCaps);
//
//     // At this point, if we are still in the function we have a valid pCaps
//     // pointer and dwCapsVer is either 7 or 8, indicating the version of
//     // the struct passed in.
//
//     ...
// }
//
#ifndef _VALIDATE_H_
#define _VALIDATE_H_


#ifdef DBG
#include <stddef.h>

#include "debug.h"

// To turn on DebugBreak on parameter error, use the following or -DRIP_BREAK in the build:
//
//#define RIP_BREAK 1

#ifdef RIP_BREAK
#define _RIP_BREAK DebugBreak();
#else
#define _RIP_BREAK 
#endif

#define V_INAME(x) \
    static const char __szValidateInterfaceName[] = #x;                       

#define RIP_E_POINTER(ptr) \
{   Trace(-1, "%s: Invalid pointer " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_POINTER; }

#define RIP_E_INVALIDARG(ptr) \
{   Trace(-1, "%s: Invalid argument " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }

#define RIP_E_HANDLE(h) \
{	Trace(-1, "%s: Invalid handle " #h "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
	return E_HANDLE; }
    
#define RIP_W_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize matches no known structure size. Defaulting to oldest structure.\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    }
    
#define RIP_E_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize is too small\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }
    
#define RIP_E_BLOCKVSDWSIZE(ptr) \
{   Trace(-1, "%s: " #ptr " does not point to as much memory as " #ptr "->dwSize indicates\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }    

// NOTE: The DebugBreak() not in #ifdef is intentional - this is something that
// must be fixed in our code, not an app-generated error.
//
#define V_ASSERT(exp) \
{   if (!(exp)) { \
        Trace(-1, "%s@%s: %s\n", __FILE__, __LINE__, #exp); \
        DebugBreak(); }}

#else

#define V_INAME(x)
#define RIP_E_POINTER(ptr)          { return E_POINTER; }
#define RIP_E_INVALIDARG(ptr)       { return E_INVALIDARG; }
#define RIP_E_HANDLE(h)	            { return E_HANDLE; }
#define RIP_E_BLOCKVSDWSIZE(ptr)    { return E_INVALIDARG; }
#define RIP_W_INVALIDSIZE(ptr)
#define RIP_E_INVALIDSIZE(ptr)      { return E_INVALIDARG; }
#define V_ASSERT(exp)

#endif          // DBG

// A passed struct we will only read from or may write to. Must be a struct
// with a dwSize.
//
// int foo(CFoo *pFoo)
// ...
// V_STRUCTPTR_READ(pFoo, CFoo);
// V_STRUCTPTR_WRITE(pFoo, CFoo);
//
// Use _PTR_ variants for structs w/o a dwSize
//
#define V_STRUCTPTR_READ(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_STRUCTPTR_WRITE(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_PTR_READ(ptr,type) \
{ if (IsBadReadPtr(ptr, sizeof(type)))                  RIP_E_POINTER(ptr); }

#define V_PTR_WRITE(ptr,type) \
{ if (IsBadWritePtr(ptr, sizeof(type)))                 RIP_E_POINTER(ptr); }

#define V_PTR_WRITE_OPT(ptr,type) \
{ if (ptr) if (IsBadWritePtr(ptr, sizeof(type)))        RIP_E_POINTER(ptr); }

// A buffer pointer with separate length (not defined by the pointer type) we will only
// read from or may write to.
//
// int foo(LPVOID *pBuffer, DWORD cbBuffer)
// ...
// V_BUFPTR_READ(pBuffer, cbBuffer);
// V_BUFPTR_WRITE(pBuffer, cbBuffer);
//
#define V_BUFPTR_READ(ptr,len) \
{   if (IsBadReadPtr(ptr, len))                         RIP_E_POINTER(ptr); }

#define V_BUFPTR_READ_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_READ(ptr,len); }

#define V_BUFPTR_WRITE(ptr,len) \
{   if (IsBadWritePtr(ptr, len))                        RIP_E_POINTER(ptr); }

#define V_BUFPTR_WRITE_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_WRITE(ptr,len); }

// A pointer to a pointer (such as a pointer to an interface pointer) to return
//
// int foo(IReturnMe **ppRet)
// ...
// V_PTRPTR_WRITE(ppRet);
// V_PTRPTR_WRITE_OPT(ppRet);
//
#define V_PTRPTR_WRITE(ptr) \
{   if (IsBadWritePtr(ptr, sizeof(void*)))              RIP_E_POINTER(ptr); }

#define V_PTRPTR_WRITE_OPT(ptr) \
{   if (ptr) if (IsBadWritePtr(ptr, sizeof(void*)))     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown
//
#define V_PUNKOUTER(punk) \
{   if (punk && IsBadCodePtr(punk))                     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown for which we don't support aggregation
//
#define V_PUNKOUTER_NOAGG(punk) \
{   if (punk && IsBadReadPtr(punk, sizeof(IUnknown)))   RIP_E_POINTER(ptr); \
    if (punk) return CLASS_E_NOAGGREGATION; }

// Validate an incoming interface pointer. 
//
struct _V_GENERIC_INTERFACE
{
    FARPROC *(__vptr[1]);
};

#define V_INTERFACE(ptr) \
{   if (IsBadReadPtr(ptr, sizeof(_V_GENERIC_INTERFACE)))                              RIP_E_POINTER(ptr); \
    if (IsBadReadPtr(*reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr, sizeof(FARPROC))) \
                                                                                      RIP_E_POINTER(ptr); \
    if (IsBadCodePtr(*(reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr)[0]))     RIP_E_POINTER(ptr); }

#define V_INTERFACE_OPT(ptr) \
{   if (ptr) V_INTERFACE(ptr); }

// Validation for a reference to a GUID, which we only ever read. 
//
#define V_REFGUID(ref) \
{   if (IsBadReadPtr((void*)&ref, sizeof(GUID)))        RIP_E_POINTER((void*)&ref); }

// Validation for a window handle
//
#define V_HWND(h) \
{	if (!IsWindow(h))									RIP_E_HANDLE(h); }	

#define V_HWND_OPT(h) \
{	if (h) if (!IsWindow(h))							RIP_E_HANDLE(h); }	

// Validation for multiple sized structs based on version
//
#define V_STRUCTPTR_READ_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_READ_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
    V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
    *pdw = ver; break;
    
#define V_STRUCTPTR_READ_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}


#define V_STRUCTPTR_WRITE_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_WRITE_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
        V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
        *pdw = ver; break;
    
#define V_STRUCTPTR_WRITE_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}



#endif          // _VALIDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\common\dputils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dputils.h
 *  Content:	common upport routines
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *  3/17/97	kipo	created it
 ***************************************************************************/

#include <windows.h>

// char used when we can't convert from unicode to ansi
#define DPLAY_DEFAULT_CHAR "-"

extern int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr);
extern int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\common\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT_PTR __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\common\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *   22-dec-00  aarono  use process heap in retail (whistler b#190380)
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "newdpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;
static LONG             lBytesAlloc;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
	lBytesAlloc+=pmt->dwSize;\
		{	\
			IN_WRITESTATS InWS;	\
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	\
		 	InWS.stat_USER3=lBytesAlloc;	\
			DbgWriteStats(&InWS);	\
		} \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
UINT_PTR __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

#ifdef DEBUG
	    lBytesAlloc -= pmt->dwSize;
		{	
			IN_WRITESTATS InWS;	
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	
		 	InWS.stat_USER3=lBytesAlloc;	
			DbgWriteStats(&InWS);	
		}
#endif

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	lBytesAlloc -= pmt->dwSize;

	pmt->dwSize = size - sizeof( MEMTRACK );

	lBytesAlloc += pmt->dwSize;

	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER3=lBytesAlloc;
		DbgWriteStats(&InWS);
	}

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
    #ifdef DEBUG
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
    #else
    hHeap = GetProcessHeap();
    #endif
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lBytesAlloc = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
    #ifdef DEBUG
	HeapDestroy( hHeap );
    #endif
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\common\memlog.h ===
#include <windows.h>
#include <mmsystem.h>

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

#define BASE_LOG_FILENAME  "DPLAYLOG-0"
#define BASE_LOG_MUTEXNAME "DPLAYLOGMUTEX-0"

#define DPLOG_NUMENTRIES	5000
#define DPLOG_ENTRYSIZE		120
#define DPLOG_SIZE (sizeof(SHARED_LOG_FILE)+((sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)*DPLOG_NUMENTRIES))

//
// Globals for shared memory based logging
//
typedef struct _SHARED_LOG_FILE{
	CHAR	szAppName[16];
	DWORD   nEntries;
	DWORD	cbLine;
	DWORD 	iWrite;
	DWORD	cInUse;
	// followed by an array of LOGENTRIES.
}SHARED_LOG_FILE, *PSHARED_LOG_FILE;

typedef struct _LOG_ENTRY {
	DWORD	hThread;
	DWORD	tLogged;
	DWORD	DebugLevel;
	CHAR	str[0];
} LOG_ENTRY, *PLOG_ENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\common\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *   6/10/98   a-peterz Check CreateFile() result against INVALID_HANDLE_VALUE
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "newdpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static 
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef DPF_MODULE_NAME
    #define DPF_MODULE_NAME ""
#endif

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

static BOOL bLogging=FALSE; // whether to use the logging VxD instead of dumping.


DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
	extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
        while (n && (*(to++) = *(from++)))    /* copy string */
                n--;
        
        *to = '\0';
}
char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;
 
int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

/*
BOOL DeviceIoControl( 
HANDLE hDevice, 			// handle to device of interest 
DWORD dwIoControlCode, 		// control code of operation to perform 
LPVOID lpInBuffer, 			// pointer to buffer to supply input data 
DWORD nInBufferSize, 		// size of input buffer 
LPVOID lpOutBuffer, 		// pointer to buffer to receive output data 
DWORD nOutBufferSize, 		// size of output buffer 
LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count 
LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation 
); 
*/

#define MAX_STRING       240
#define LOG_SIZE         2000
#define FIRST_DEBUG_PROC 100

#define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
#define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)
#define WRITE_STATS     (FIRST_DEBUG_PROC+2)

HANDLE hDPLAY_VxD=0;
HANDLE hLogMutex=0;
HANDLE hLogFile=0;
PSHARED_LOG_FILE pLogFile=0;

typedef struct _LOGENTRY {
	CHAR	debuglevel;
	CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

typedef struct {
	UINT	nLogEntries;
	UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
	UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
	CHAR	debuglevel;
	CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
	UINT	hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;

void DbgWriteStats(PIN_WRITESTATS pIn)
{
	UINT rc;
	UINT cbRet;

	if(hDPLAY_VxD){
		DeviceIoControl(hDPLAY_VxD,WRITE_STATS,pIn,sizeof(IN_WRITESTATS), &rc, sizeof(rc), &cbRet, NULL);
	}
}

static BOOL InitMemLogString(VOID)
{
	DWORD dwLastError;

	hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
	dwLastError=GetLastError();
	hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
	pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);

	if(!hLogFile || !hLogMutex || !pLogFile){
		if(hLogFile){
			CloseHandle(hLogFile);
			hLogFile=0;
		}
		if(hLogMutex){
			CloseHandle(hLogMutex);
			hLogMutex=0;
		}
		if(pLogFile){
			UnmapViewOfFile(pLogFile);
			pLogFile=NULL;
		}
		return FALSE;
	} else {
		WaitForSingleObject(hLogMutex,INFINITE);
			if((dwLastError!=ERROR_ALREADY_EXISTS) || 
				(pLogFile->nEntries > DPLOG_NUMENTRIES) || (pLogFile->nEntries == 0) ||
				(pLogFile->cbLine   > DPLOG_ENTRYSIZE)  || (pLogFile->cbLine   == 0) ||
				(pLogFile->iWrite   > DPLOG_NUMENTRIES) ||
				(pLogFile->cInUse   > DPLOG_NUMENTRIES)
			){
				pLogFile->nEntries = DPLOG_NUMENTRIES;
				pLogFile->cbLine   = DPLOG_ENTRYSIZE;
				pLogFile->iWrite   = 0;
				pLogFile->cInUse   = 0;
			}	
		ReleaseMutex(hLogMutex);
	}
	return TRUE;
}

static void MemLogString(LPSTR str)
{
	PLOG_ENTRY pEntry;
	DWORD cbCopy;
	
	if(!hLogFile){
		if(!InitMemLogString()){
			return;
		}
	}

	WaitForSingleObject(hLogMutex,INFINITE);

	pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
	pEntry->hThread=GetCurrentThreadId();
	pEntry->tLogged=timeGetTime();
	pEntry->DebugLevel=0;

	cbCopy=strlen(str)+1;
	if(cbCopy > DPLOG_ENTRYSIZE){
		str[DPLOG_ENTRYSIZE]=0;
		cbCopy=DPLOG_ENTRYSIZE;
	}
	memcpy(pEntry->str, str, cbCopy);

	if(pLogFile->iWrite+1 > pLogFile->cInUse){
		pLogFile->cInUse=pLogFile->iWrite+1;
	}

	pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
	ReleaseMutex(hLogMutex);

}

static void LogString( LPSTR str )
{
	char logstring[MAX_STRING+sizeof(LOGENTRY)];
	int  i=0;
	PLOGENTRY pLogEntry=(PLOGENTRY)logstring;
	UINT rc;
	UINT cbRet;
	int maxlen = MAX_STRING+sizeof(LOGENTRY);

	if(hDPLAY_VxD && str){
		while(str[i] && i < maxlen)
			i++;
		pLogEntry->debuglevel=0;
		memcpy(pLogEntry->str,str,i+1);
		DeviceIoControl(hDPLAY_VxD,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
	}

	if(bLogging & 2){
		MemLogString(str);
	}
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
	if(!bLogging || bLogging & 1)
	{            
	    OUTPUTDEBUGSTRING( str );
	    OUTPUTDEBUGSTRING("\n");
    }
    if(bLogging)
    {
	    LogString(str);
	}    
    
}
    
void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif
    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        bLogging    = (signed int) GETPROFILEINT( PROF_SECT, "log" , 0);

        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }

        if(bLogging){
        	hDPLAY_VxD = CreateFileA("\\\\.\\DPLAY",0,0,0,0,0,0);
        	if(hDPLAY_VxD != INVALID_HANDLE_VALUE){
        		IN_LOGINIT In;
        		OUT_LOGINIT Out;
        		UINT cbRet;
        		In.nCharsPerLine=MAX_STRING;
        		In.nLogEntries=5000;
				DeviceIoControl(hDPLAY_VxD,OPEN_DEBUGLOG,&In,sizeof(In), &Out, sizeof(Out), &cbRet, NULL);
        	}
        }
    }
    else
    {
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(volatile DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE 1000
    char cMsg[MSGBUFFERSIZE];
    char cTopics[20];
    DWORD_PTR arg;
    LPSTR szFormat;
    BOOL bAllowed=FALSE;
    BOOL bMiscMessage=TRUE;
    int i;

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

    //error checking:
    if (dwDetail >= 10)
        return 1;

    if ( (bDetailOn & (1<<dwDetail)) == 0 )
        return 1;

    if (bMute)
        return 1;

    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    while ( (arg = va_arg(ap,DWORD_PTR)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }
    if (bMiscMessage)
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;

    if ( bPrintAllTopics )
        bAllowed=TRUE;

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) arg;

    cMsg[0]=0;
    
    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME ":" );
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;
    
}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    // 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
	DebugPrintf(2,A,"%p->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}


#ifdef cplusplus
}
#endif

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\common\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>
#include <memlog.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
    typedef struct {
    	UINT stat_ThrottleRate;
		UINT stat_BytesSent;
		UINT stat_BackLog;
	 	UINT stat_BytesLost;
	 	UINT stat_RemBytesReceived;
		UINT stat_Latency; 
		UINT stat_MinLatency;
		UINT stat_AvgLatency;
		UINT stat_AvgDevLatency;
		UINT stat_USER1;
		UINT stat_USER2;
		UINT stat_USER3;
		UINT stat_USER4;
		UINT stat_USER5;	// remote tDelta
		UINT stat_USER6;	// Remote tDelta sign (0=+ve, 1=-ve)
	} IN_WRITESTATS, *PIN_WRITESTATS;

	typedef struct {
		UINT	hr;
	} OUT_WRITESTATS, *POUT_WRITESTATS;

   extern void DbgWriteStats(PIN_WRITESTATS pIn);
  
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(volatile DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define DbgWriteStats()
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD myclockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD myclock()	 {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= myclock(), t ## N ++
    #define TIMESTOP(t)   t ## T += myclock()
    #define TIMEFMT(t)	  ((DWORD)(t) / myclockrate()), (((DWORD)(t) * 1000 / myclockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\apphack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       apphack.c
 *
 *  Content:	Hacks to make broken apps work
 *
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *  12/03/98  aarono        original
 *  12/03/98  aarono        Formula1 J crashes when MMTIMER starts
 *  08/18/99  rodtoll		Extended apphacks to allow ID=0 that will match
 *                          any version of the specified EXE.  Also, made
 *							the name comparison case-insensitive.  (For Win98)
 *
 ***************************************************************************/
 
#include "dplaypr.h"
//#include "winnt.h"

#define DPLAY_REGISTRY_APPHACKS "Software\\Microsoft\\DirectPlay\\Compatibility"
#define REGSTR_VAL_NAME		    "Name"
#define REGSTR_VAL_APPID	    "ID"
#define REGSTR_VAL_FLAGS	    "Flags"

__inline static BOOL fileRead( HANDLE hFile, void *data, int len )
{
    DWORD	len_read;

    if( !ReadFile( hFile,  data, (DWORD) len, &len_read, NULL ) ||
    	len_read != (DWORD) len )
    {
		return FALSE;
    }
    return TRUE;

} /* fileRead */

__inline static BOOL fileSeek( HANDLE hFile, DWORD offset )
{
    if( SetFilePointer( hFile, offset, NULL, FILE_BEGIN ) != offset )
    {
		return FALSE;
    }
    return TRUE;

} /* fileSeek */


HRESULT GetAppHacks(LPDPLAYI_DPLAY this)
{
	CHAR name[_MAX_PATH];  // general purpose
	CHAR name_last[_MAX_PATH]; // stores last component of name
	LONG lErr;
	HKEY hKey;
	HANDLE hFile;
	IMAGE_NT_HEADERS nth;
	IMAGE_DOS_HEADER dh;
	DWORD appid;

	DWORD index;
	INT i;

	name[0]=0;
	name_last[0]=0;

	// open the base key - 
	// "HKEY_LOCAL_MACHINE\Software\Microsoft\DirectPlay\Service Providers"
	lErr = RegOpenKeyExA(HKEY_LOCAL_MACHINE,DPLAY_REGISTRY_APPHACKS,0,KEY_READ,&hKey);
	
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d, guess there are no apphacks\n",lErr);
		return DP_OK;	// ok, no app hacks to apply.
	}

	// ok, we now know there are some overrides to apply - so get info about this application.
    hFile =  GetModuleHandleA( NULL );
	
	GetModuleFileNameA( hFile, name, sizeof(name));

	DPF(3,"full name = %s",name);

    i = strlen( name )-1;
    while( i >=0 && name[i] != '\\' )
    {
	i--;
    }
    i++;
    strcpy( name_last, &name[i] );

    /*
     * go find the timestamp in the file
     */
    appid = 0;
    do
    {
        hFile = CreateFileA( name, GENERIC_READ, FILE_SHARE_READ,
	        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( hFile == INVALID_HANDLE_VALUE )
        {
	    DPF( 0, "Could not open file %s", name );
	    break;
        }
        if( !fileRead( hFile, &dh, sizeof( dh ) ) )
        {
	    DPF( 0, "Could not read DOS header for file %s", name );
	    break;
        }
        if( dh.e_magic != IMAGE_DOS_SIGNATURE )
        {
	    DPF( 0, "Invalid DOS header for file %s", name );
	    break;
        }
        if( !fileSeek( hFile, dh.e_lfanew ) )
        {
	    DPF( 0, "Could not seek to PE header in file %s", name );
	    break;
        }
        if( !fileRead( hFile, &nth, sizeof( nth ) ) )
        {
	    DPF( 0, "Could not read PE header for file %s", name );
	    break;
        }
        if( nth.Signature != IMAGE_NT_SIGNATURE )
        {
	    DPF( 0, "Bogus PE header for file %s", name );
	    break;
        }
        appid = nth.FileHeader.TimeDateStamp;
        if( appid == 0 )
        {
	    DPF( 0, "TimeDataStamp is 0 for file %s", name );
	    break;
        }
        DPF( 1, "Obtained appid: 0x%08lx", appid );
    } while(0); //fake try-except

    if(hFile != INVALID_HANDLE_VALUE){
    	CloseHandle( hFile );
    }
   	hFile=NULL;

	// now have a valid appid (timestamp) and filename, also hKey point to the apphack list.
	// apphack keys are stored as follows
    //
	// ProgramName -+-- Flags (BINARY-LO BYTE FIRST)
	//              |
	//              +-- ID (BINARY - TIMESTAMP (ID))
	//              |
	//              +-- NAME (STRING - EXE NAME)
	//
	// We will now run through looking for a matching ID and then if that matches check the name
	// if both match, we will add the flags to this->dwAppHacks 

	index = 0;
    /*
     * run through all keys
     */
    while( !RegEnumKeyA( hKey, index, name, sizeof( name ) ) )
    {
		HKEY	hsubkey;
	    DWORD	type;
	    DWORD	cb;
	    DWORD	id;
	    DWORD	flags;

		if(!RegOpenKeyA(hKey,name,&hsubkey)){

		    cb = sizeof( name );
		    if( !RegQueryValueExA( hsubkey, REGSTR_VAL_NAME, NULL, &type, name, &cb ) )
		    {
				if( type == REG_SZ )
				{
				    cb = sizeof( flags );
				    if( !RegQueryValueExA( hsubkey, REGSTR_VAL_FLAGS, NULL, &type, (LPSTR) &flags, &cb ) )
				    {
				    
						if( (type == REG_DWORD) || (type == REG_BINARY && cb == sizeof( flags )) )
						{
							cb = 4;
							if( !RegQueryValueExA( hsubkey, REGSTR_VAL_APPID, NULL, &type, (LPSTR) &id, &cb ) )
							{
							    if( (type == REG_DWORD) ||
								(type == REG_BINARY && cb == sizeof( flags )) )
							    {
									/*
									 * finally!  we have all the data. check if its the same as this one.
									 */
									 if((id==appid || id==0) && !_memicmp(name,name_last,cb))
									 {
									 	this->dwAppHacks |= flags;
									 	DPF(0,"Setting dwAppHacks to %x\n", this->dwAppHacks);
									 	RegCloseKey(hsubkey);
									 	break; // punt outta here.
									 }
							    } else {
									DPF( 0, "    AppID not a DWORD for app %s", name );
							    }
						    } else {
						    	DPF(0, "    AppID not Found");
						    }
					    } else {
					    	DPF( 0, "    Not BINARY DWORD flags\n");
					    }
					} else {
						DPF( 0, "    No flags found for app %s", name );
				    }
				} else	{
				    DPF( 0, "    Executable name not a string!!!" );
				}
		    } else {
				DPF( 0, "    Executable name not found!!!" );
		    }
		} else {
		    DPF( 0, "  RegOpenKey for %ld FAILED!" );
		} 
		if(hsubkey)RegCloseKey(hsubkey);
		hsubkey=NULL;
		index++;
	}

	RegCloseKey(hKey);

	return DP_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay4\dplay\api.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       api.c
 *  Content:	DirectPlay api's
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *    1/96		andyco	   	created it
 *	2/15/96 	andyco	   	hardwired  to load dpwsock sp, return fake enum
 *	3/16/96 	andyco	   	spinit - new structure
 *	3/23/96		andyco	   	use registry
 *	4/10/96		andyco	   	added verifyspcallbacks
 *	4/23/96		andyco	   	added check for mw2 on enum. only return dp1.0 service
 *						   	providers if the .exe is mw2.
 *	5/6/96		andyco	   	moved os functionality to dpos.c
 *	5/29/96		andyco	   	new vtbls
 *	6/19/96		kipo	   	Bug #2052 in api.c: changed MW2Enum() to use the TAPI
 *						   	service provider GUID from DirectPlay 1.0 instead of the
 *						   	new serial service provider GUID. This will let
 *						   	MechWarrior work over TAPI; changed time bomb date to 8/31/96.
 *	6/20/96		andyco	   	added WSTRLEN_BYTES
 *	6/21/96 	kipo	   	Bug #2078. Changed modem service provider GUID so it's not the
 *						   	same as the DPlay 1.0 GUID, so games that are checking won't
 *						   	put up their loopy modem-specific UI.
 *	6/22/96		kipo	   	added EnumConnectionData() method.
 *	6/23/96		kipo	   	updated for latest service provider interfaces.
 *  6/26/96		andyco	   	take service lock b4 dplay lock on DirectPlayConnect
 *	6/26/96		kipo	   	changed guidGame to guidApplication; added support for DPADDRESS.
 *						   	changed GetFlags to GetPlayerFlags.
 *  6/26/96		kipo	   	check version returned by service provider
 *	6/28/96		andyco	   	check for DPLERR_BUFFERTOOSMALL on getconnectionsettings
 *	6/28/96		kipo	   	added support for CreateAddress() method.
 *  7/8/96  	AjayJ      	Adjusted vtable for IDirectPlay2 and IDirectPlay2A to match
 *          	           	dplay.h (remove EnableNewPlayers, SaveSession, alphabetize)
 *          	           	DummyEnumSessionsCallBack - fixed prototype to match dplay.h
 *  7/10/96		kipo	   	turned stack frame generation on around calls to DirectPlayEnumerateA
 *						   	so that poor apps that use _cdecl callbacks will continue
 *						   	to work. Fixes bug #2260 that was crashing "Space Hulk".
 * 	7/13/96		andyco	   	added DirectPlayEnumerate entry for compat. set MW2 global
 *						   	bool.
 *	7/23/96		andyco	   	added get max message size after sp init
 *	8/10/96		kipo	   	updated time bomb date
 *  8/ 9/96 	sohailm    	Bug #2376: added logic to free sp module if an error occurs in LoadSP.
 *	8/15/96		andyco		call sp_shutdown if sp_init succeeds but we don't like the
 *							version
 *	8/23/96		kipo		removed time bomb
 *  10/3/96 	sohailm     renamed VALID_UUID_PTR() call to VALID_GUID_PTR()
 *	10/31/96	andyco		added idirectplay3
 *	1/24/97		andyco		call freelibrary on the sp
 *	2/30/97		andyco		added enumconnections, initializeconnection to dp3 vtbl
 *	3/04/97		kipo		updated gdwDPlaySPRefCount definition
 *	3/12/97		myronth		added Lobby object creation code
 *  3/12/97     sohailm     added SecureOpen(), SecureOpenA() to DIRECTPLAYCALLBACKS3 and 
 *                          DIRECTPLAYCALLBACKS3A respectively, updated existing code to reflect 
 *                          changes in function parameters (InternalOpenSession, FreeSessionList)
 *	3/17/97		kipo		added support for CreateCompoundAddress()
 *	4/1/97		andyco		put in app hack for ms-golf.  don't load guid_local_tcp.
 *							use guid_tcp instead.  this is because guid_local_tcp 
 *							points to a sp that uses ddhelp.exe.  but, dplay is no longer
 *							using ddhelp.exe (see dplaysvr), so they're broken.
 *	3/31/97		myronth		Fixed DPF spew level for checking if a game was lobbied.
 *	4/20/97		andyco		added group in group stuff
 *	5/8/97		myronth		added Get/SetGroupConnectionSettings, StartSession
 *	5/12/97		kipo		fixed bugs #5506 and 5507
 *	5/17/97		myronth		Added SendChatMessage to IDirectPlay3
 *	5/27/97		kipo		Changed time bomb data to 10/15/97
 *	5/29/97		andyco		made ConnectFindSession() async
 *	5/30/97		myronth		Added GetGroupParent
 *  5/30/97     sohailm     Added GetPlayerAccount to vtable.
 *	5/30/97		kipo		Added GetPlayerFlags() and GetGroupFlags()
 *	6/16/97		andyco		don't take service lock on connect, so dpthread
 *							can run.
 *	6/25/97		kipo		remove time bomb for DX5
 *	7/30/97		myronth		Fixed wrong validation macro for guid
 *	8/5/97		andyco		async addforward. init this->dwMinVersion.
 *	8/19/97		myronth		Save the lobby object that lobbied us
 *	8/19/97		myronth		Change that to saving a copy of the lobby interface
 *	8/14/97		sohailm		Not verifying sp callback ptrs correctly (#10929)
 *	8/22/97		myronth		Added registry support for Description and Private values
 *	10/21/97	myronth		Added IDirectPlay4 callback tables
 *	10/29/97	myronth		Changed Get/SetGroupOwner callback pointers
 *	11/13/97	myronth		Added functions for asynchronous Connect (#12541)
 *	11/19/97	myronth		Changed Connect timeout to max at a minute (#13216)
 *	11/20/97	myronth		Made EnumConnections & DirectPlayEnumerate 
 *							drop the lock before calling the callback (#15208)
 *	11/24/97	kipo		Added time bomb for DX6
 *	12/3/97		myronth		Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	12/5/97		andyco		voice entries
 *  12/18/97    aarono      added pool allocation
 *	01/20/97	sohailm		don't free sp list after DirectPlayEnumerate (#17006)
 *	1/20/98		myronth		Changed PRV_SendStandardSystemMessage
 *	1/20/98		myronth		#ifdef'd out voice support
 *  2/18/98		aarono      unpatched protocol from table, moved InitProtocol
 *  4/30/98     aarono      fix connect when talking to secure server
 *  6/18/98     aarono      fix group SendEx ASYNC to use unique Header
 *  6/25/98     a-peterz    fix incorrect sizeof() in ConnectMe
 *  8/02/99		rodtoll		added voice v-table
 *  8/04/99		aarono		modified voice v-table, added IsValidEntity
 *  9/09/99     aarono      added vances fix for client/server pw validation
 * 10/04/99     aarono      added patching for loopback SP
 * 01/20/00		rodtoll		Added DV_IsValidGroup / DV_IsValidPlayer to conform to new transport interface 
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set
 * 07/22/00		rodtoll		Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  		Now for a thread to make an indication into voice they addref the interface
 *							so that the voice core can tell when all indications have returned.   
 ***************************************************************************/
		
					
// todo - do we need to check the version on mw2?

#include "dplaypr.h"
#include "dplobby.h"
#include "dpprot.h"
#include "fpm.h"
#include "..\protocol\mytimer.h"
#include "loopbksp.h"
#include "verinfo.h"

#include <initguid.h>

#ifdef VOICE_BUILD_CUSTOM
SPNODE ASPNode;
#endif

// gdwDPLaySPRefCount is here so SP's can statically link to dplay
// this can keep some apps from unloading dplayx before the SP (no
// release) and crashing. Disable the warning so that we can include the
// extern declaration in dplaysp.h
#define DllExport	__declspec( dllexport )
#pragma warning( disable : 4273 )

DllExport DWORD gdwDPlaySPRefCount = 0;

// list of all sp info gotten from the registry
LPSPNODE gSPNodes;

// set if we're running mech
BOOL gbMech;

// set if we have a dx3 SP loaded. once we load a dx3 SP, 
// we do not allow any more directplay objects to be created
// (since in dx3 you could only have one directplay, we don't 
// want to risk crashing the SP)
BOOL gbDX3SP;											

// gpObjectList is the list of all dplay objects that exist in
// this dll.  used in dllmain and classfactory->canunloadnow
LPDPLAYI_DPLAY gpObjectList;
UINT gnObjects; // the # of dplay objects in the gpObjectList

//
// DP_1_xxx is a dplay 10 function.  see iplay1.c
// DP_A_xxx is a dplay 20 ansi function.  see iplaya.c
// DP_xxx is a dplay 20 function.  see iplay.c and enum.c
// DP_SP_xxx is a service provider callback.  see sphelp.c and handler.c
//

DIRECTPLAYVOICETRANSPORTCALLBACKS dvtCallbacks =
{
	(LPVOID)DP_QueryInterface,
	(LPVOID)DP_AddRef,
	(LPVOID)DP_Release,
	(LPVOID)DV_Advise,
	(LPVOID)DV_UnAdvise,
	(LPVOID)DV_IsGroupMember,
	(LPVOID)DV_SendSpeech,
	(LPVOID)DV_GetSessionInfo,
	(LPVOID)DV_IsValidEntity,
	(LPVOID)DV_SendSpeechEx,
	(LPVOID)DV_IsValidGroup,
	(LPVOID)DV_IsValidPlayer
};

/*
 * the one copy of the direct play 1.0 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS dpCallbacks =
{
    DP_QueryInterface,
    DP_AddRef,
    DP_Release,
    DP_AddPlayerToGroup,
    DP_Close,
    DP_1_CreatePlayer,
    DP_1_CreateGroup,
    DP_DeletePlayerFromGroup,
    DP_DestroyPlayer,
    DP_DestroyGroup,
    DP_EnableNewPlayers,
    DP_1_EnumGroupPlayers,
    DP_1_EnumGroups,
    DP_1_EnumPlayers,
    DP_1_EnumSessions,
    DP_1_GetCaps,
    DP_GetMessageCount,
    DP_1_GetPlayerCaps,
    DP_1_GetPlayerName,
    DP_Initialize,
    DP_1_Open,
    DP_1_Receive,
    DP_1_SaveSession,
    DP_Send,
    DP_1_SetPlayerName      	
};  				

/*
 *  the direct play 2 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS2 dpCallbacks2 =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_CreateGroup,          
	(LPVOID)DP_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_EnumGroupPlayers,     
	(LPVOID)DP_EnumGroups,           
	(LPVOID)DP_EnumPlayers,          
	(LPVOID)DP_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,
	(LPVOID)DP_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_GetPlayerName,
	(LPVOID)DP_GetSessionDesc,
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_Open,           
	(LPVOID)DP_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData, 
	(LPVOID)DP_SetGroupName,	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_SetPlayerName,	  
	(LPVOID)DP_SetSessionDesc
};  				

/*
 *  the direct play 2A callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS2A dpCallbacks2A =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_A_CreateGroup,          
	(LPVOID)DP_A_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_A_EnumGroupPlayers,     
	(LPVOID)DP_A_EnumGroups,           
	(LPVOID)DP_A_EnumPlayers,          
	(LPVOID)DP_A_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,   
	(LPVOID)DP_A_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_A_GetPlayerName,
	(LPVOID)DP_A_GetSessionDesc,	  
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_A_Open,           
	(LPVOID)DP_A_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData,   
	(LPVOID)DP_A_SetGroupName,	  	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_A_SetPlayerName,	  	  
	(LPVOID)DP_A_SetSessionDesc
};  				

// Protocol needs to wrap SendComplete since unlike HandleMessage, the values to complete
// will change from an SP code to a Protocol code, so there is no propogation
// method other than wrapping the SendComplete.

DIRECTPLAYCALLBACKSSP dpCallbacksSP =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_SP_AddMRUEntry,
	(LPVOID)DP_SP_CreateAddress,
	(LPVOID)DP_SP_EnumAddress,
	(LPVOID)DP_SP_EnumMRUEntries,
	(LPVOID)DP_SP_GetPlayerFlags,
	(LPVOID)DP_SP_GetSPPlayerData,
	(LPVOID)DP_SP_HandleMessage, 
	(LPVOID)DP_SP_SetSPPlayerData,
    /*** IDirectPlaySP methods added for DX 5***/
    (LPVOID)DP_SP_CreateCompoundAddress,
	(LPVOID)DP_SP_GetSPData,
	(LPVOID)DP_SP_SetSPData,
#ifdef BIGMESSAGEDEFENSE
	(LPVOID)DP_SP_ProtocolSendComplete,   // Goes through protocol.lib to DP_SP_ProtocolSendComplete
	(LPVOID)DP_SP_HandleSPWarning
#else
	(LPVOID)DP_SP_ProtocolSendComplete   // Goes through protocol.lib to DP_SP_ProtocolSendComplete
#endif
};    
	 

/*
 *  the direct play 3 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS3 dpCallbacks3 =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_CreateGroup,          
	(LPVOID)DP_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_EnumGroupPlayers,     
	(LPVOID)DP_EnumGroups,           
	(LPVOID)DP_EnumPlayers,          
	(LPVOID)DP_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,
	(LPVOID)DP_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_GetPlayerName,
	(LPVOID)DP_GetSessionDesc,
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_Open,           
	(LPVOID)DP_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData, 
	(LPVOID)DP_SetGroupName,	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_SetPlayerName,	  
	(LPVOID)DP_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_EnumConnections,
	(LPVOID)DP_EnumGroupsInGroup,
	(LPVOID)DPL_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_SecureOpen,
	(LPVOID)DP_SendChatMessage,
	(LPVOID)DPL_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags
};  				


/*
 *  the direct play 3A callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS3A dpCallbacks3A =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_A_CreateGroup,          
	(LPVOID)DP_A_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_A_EnumGroupPlayers,     
	(LPVOID)DP_A_EnumGroups,           
	(LPVOID)DP_A_EnumPlayers,          
	(LPVOID)DP_A_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,   
	(LPVOID)DP_A_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_A_GetPlayerName,
	(LPVOID)DP_A_GetSessionDesc,	  
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_A_Open,           
	(LPVOID)DP_A_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData,   
	(LPVOID)DP_A_SetGroupName,	  	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_A_SetPlayerName,	  	  
	(LPVOID)DP_A_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_A_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_A_EnumConnectionsPreDP4,
	(LPVOID)DP_A_EnumGroupsInGroup,
	(LPVOID)DPL_A_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_A_SecureOpen,
	(LPVOID)DP_A_SendChatMessage,
	(LPVOID)DPL_A_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_A_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags
};  				
	 
/*
 *  the direct play 4 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS4 dpCallbacks4 =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_CreateGroup,          
	(LPVOID)DP_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_EnumGroupPlayers,     
	(LPVOID)DP_EnumGroups,           
	(LPVOID)DP_EnumPlayers,          
	(LPVOID)DP_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,
	(LPVOID)DP_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_GetPlayerName,
	(LPVOID)DP_GetSessionDesc,
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_Open,           
	(LPVOID)DP_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData, 
	(LPVOID)DP_SetGroupName,	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_SetPlayerName,	  
	(LPVOID)DP_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_EnumConnections,
	(LPVOID)DP_EnumGroupsInGroup,
	(LPVOID)DPL_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_SecureOpen,
	(LPVOID)DP_SendChatMessage,
	(LPVOID)DPL_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags,
    /*** IDirectPlay4 methods ***/
	(LPVOID)DPL_GetGroupOwner,
	(LPVOID)DPL_SetGroupOwner,
	(LPVOID)DP_SendEx,
	(LPVOID)DP_GetMessageQueue,
	(LPVOID)DP_CancelMessage,
	(LPVOID)DP_CancelPriority,
};  				


/*
 *  the direct play 4A callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS4A dpCallbacks4A =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_A_CreateGroup,          
	(LPVOID)DP_A_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_A_EnumGroupPlayers,     
	(LPVOID)DP_A_EnumGroups,           
	(LPVOID)DP_A_EnumPlayers,          
	(LPVOID)DP_A_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,   
	(LPVOID)DP_A_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_A_GetPlayerName,
	(LPVOID)DP_A_GetSessionDesc,	  
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_A_Open,           
	(LPVOID)DP_A_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData,   
	(LPVOID)DP_A_SetGroupName,	  	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_A_SetPlayerName,	  	  
	(LPVOID)DP_A_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_A_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_A_EnumConnections,
	(LPVOID)DP_A_EnumGroupsInGroup,
	(LPVOID)DPL_A_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_A_SecureOpen,
	(LPVOID)DP_A_SendChatMessage,
	(LPVOID)DPL_A_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_A_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags,
    /*** IDirectPlay4 methods ***/
	(LPVOID)DPL_GetGroupOwner,
	(LPVOID)DPL_SetGroupOwner,
	(LPVOID)DP_SendEx,
	(LPVOID)DP_GetMessageQueue,
	(LPVOID)DP_CancelMessage,
	(LPVOID)DP_CancelPriority,
};  				

// todo - Add DP_A_GetAccountDesc() to vtable

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayCreate"

#ifndef DX_FINAL_RELEASE

// shut 'em down if they try to use the beta bits too long
HRESULT TimeBomb() 
{
    #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
    SYSTEMTIME st;
    GetSystemTime(&st);

    if ( st.wYear > DX_EXPIRE_YEAR ||
         ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH)))
    ) {
        MessageBox(0, DX_EXPIRE_TEXT,
                      TEXT("Microsoft DirectPlay"), MB_OK);
        return DP_OK;// let it work anyway.
    }
     return DP_OK;   
} // TimeBomb

#endif

#define NUM_CALLBACKS( ptr ) ((ptr->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID ))
// called by loadsp to make sure we didn't get bogus call back ptrs
HRESULT VerifySPCallbacks(LPDPLAYI_DPLAY this) 
{
	PDWORD_PTR lpCallback;
	int nCallbacks = NUM_CALLBACKS(this->pcbSPCallbacks);
	int i;

	DPF(1,"verifying %d callbacks\n",nCallbacks);
	lpCallback = (PDWORD_PTR)((DWORD_PTR)this->pcbSPCallbacks + (sizeof(DWORD) * 2)); // + 1 for dwSize, + 1 for dwFlags

	for (i=0;i<nCallbacks ;i++ )
	{
		if ((*lpCallback) && !VALIDEX_CODE_PTR(*lpCallback)) 
		{
			DPF_ERR("sp provided bad callback pointer!");
			return E_FAIL;
		}
		lpCallback++;
	}

	return DP_OK;	
} // VerifySPCallbacks


// get the max message sizes for this xport
HRESULT GetMaxMessageSize(LPDPLAYI_DPLAY this)
{
	HRESULT hr;
	DPCAPS caps;

	memset(&caps,0,sizeof(DPCAPS));
	caps.dwSize = sizeof(DPCAPS);

	hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,0);
	if (FAILED(hr))
	{
		ASSERT(FALSE); // sp should at least support unreliable!
		return hr;
	}
	
	this->dwSPMaxMessage = caps.dwMaxBufferSize+sizeof(MSG_PLAYERMESSAGE);

	hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,DPGETCAPS_GUARANTEED);
	if (FAILED(hr))
	{
		// use unreliable
		this->dwSPMaxMessageGuaranteed = this->dwSPMaxMessage;
	}
	else 
	{
		this->dwSPMaxMessageGuaranteed = caps.dwMaxBufferSize;		
	}

	return DP_OK;

} // GetMaxMessageSize

// find the sp correspoding to lpGUID, and load it. call SPInit.
HRESULT LoadSP(LPDPLAYI_DPLAY this,LPGUID lpGUID,LPDPADDRESS lpAddress,DWORD dwAddressSize)
{
	SPINITDATA sd;
	LPSPNODE pspNode;
	BOOL bFound=FALSE;
	BOOL bLoopBack=FALSE;
	LPDPSP_SPINIT spinit;	
	HRESULT hr;
	LPDPLAYI_DPLAY_INT pInt=NULL;
	DWORD	dwError;

#ifdef DEBUG
	CHAR szGuid[GUID_STRING_SIZE];
	hr = AnsiStringFromGUID(lpGUID, szGuid, GUID_STRING_SIZE);
	if (!FAILED(hr))
	{
		DPF(5, "LoadSP called for GUID = %s, address = 0x%08x",szGuid, lpGUID);		
	}
#endif

	// Build the list
	hr = InternalEnumerate();
	if (FAILED(hr))
	{
		// rut ro!
		ASSERT(FALSE);
		return hr;
	}

	// find the right spnode
	pspNode = gSPNodes;
	while (pspNode && !(bFound))
	{
		if (IsEqualGUID(&(pspNode->guid),lpGUID)) bFound=TRUE;
		else pspNode=pspNode->pNextSPNode;
	}

	// loopback SP check
	if(IsEqualGUID(&GUID_DPLAY_LOOPBACKSP,lpGUID)){
		bFound=TRUE;
		bLoopBack=TRUE;
	}
	
	if (!bFound) 
	{
		DPF_ERR("could not find specified service provider!!");
		return DPERR_UNAVAILABLE;
	}
	
	if(bLoopBack){
		DPF(0,"Using Loopback SP");
		memset(&LBSPNode, 0, sizeof(LBSPNode));
		pspNode=&LBSPNode;
		this->pspNode = &LBSPNode;
		LBSPNode.guid = GUID_DPLAY_LOOPBACKSP;
		LBSPNode.lpszName = L"Loopback Service Provider";
		spinit=LBSPInit;
#if defined(VOICE_BUILD_CUSTOM)
    } else {
        DPF(0,"Auto-Loading " DPLAY_FILENAME_DPWSOCKX_A " provider");
/*        memset(&ASPNode, 0, sizeof(LBSPNode));
        pspNode=&ASPNode;
        this->pspNode = &ASPNode;
        ASPNode.guid = DPSPGUID_TCPIP;
        ASPNode.lpszName = NULL;  */
        this->hSPModule = OS_LoadLibrary(DPLAY_FILENAME_DPWSOCKX);
		if (!this->hSPModule) 
		{
			DPF(0,"Could not load service provider - %ls\n",DPLAY_FILENAME_DPWSOCKX_A);
			return DPERR_UNAVAILABLE;
		}

	    spinit= (LPDPSP_SPINIT) OS_GetProcAddress(this->hSPModule,"SPInit");
		if (!spinit) 
		{
			DPF(0,"Could not find service provider entry point");
			hr = DPERR_UNAVAILABLE;
	        goto CLEANUP_AND_EXIT;
		}
    }
#else		
	} else {
		DPF(0,"loading sp = %ls\n",pspNode->lpszPath);	
		// store the pspnode
		this->pspNode = pspNode;
	 	// try to load the specified sp
	    this->hSPModule = OS_LoadLibrary(pspNode->lpszPath);
		if (!this->hSPModule) 
		{
			DPF(0,"Could not load service provider - %ls\n",pspNode->lpszPath);
			return DPERR_UNAVAILABLE;
		}

	    spinit= (LPDPSP_SPINIT) OS_GetProcAddress(this->hSPModule,"SPInit");
		if (!spinit) 
		{
			DPF(0,"Could not find service provider entry point");
			hr = DPERR_UNAVAILABLE;
	        goto CLEANUP_AND_EXIT;
		}

	}	
#endif

	// get an IDirectPlaySP to pass it
	hr = GetInterface(this,&pInt,&dpCallbacksSP);
	if (FAILED(hr)) 
	{
		DPF(0,"could not get interface to directplaysp object. hr = 0x%08lx\n",hr);
        goto CLEANUP_AND_EXIT;
	}

	// set up the init d